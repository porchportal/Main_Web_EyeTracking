"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_pages_collected-dataset_components-gui_cameraAccess_js",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/cameraAccess.js":
/*!****************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/cameraAccess.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n// cameraAccess.js\n\nvar _s = $RefreshSig$();\n\nconst CameraAccess = (param)=>{\n    let { isShowing, onClose, onCameraReady, showHeadPose = false, showBoundingBox = false, showMask = false, showParameters = false } = param;\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [stream, setStream] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [errorMessage, setErrorMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [fps, setFps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const fpsTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const processingInterval = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [isVideoReady, setIsVideoReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Start camera on component mount if isShowing is true\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (isShowing) {\n                startCamera();\n            } else {\n                stopCamera();\n            }\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    stopCamera();\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Setup FPS counter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            fpsTimerRef.current = setInterval({\n                \"CameraAccess.useEffect\": ()=>{\n                    setFps({\n                        \"CameraAccess.useEffect\": (prevFps)=>{\n                            // Simple mock for fps counter\n                            const newFps = Math.floor(Math.random() * 10) + 25; // Random between 25-35 fps\n                            return newFps;\n                        }\n                    }[\"CameraAccess.useEffect\"]);\n                }\n            }[\"CameraAccess.useEffect\"], 1000);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    if (fpsTimerRef.current) {\n                        clearInterval(fpsTimerRef.current);\n                    }\n                    if (processingInterval.current) {\n                        clearInterval(processingInterval.current);\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Update dimensions when container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            const updateDimensions = {\n                \"CameraAccess.useEffect.updateDimensions\": ()=>{\n                    if (containerRef.current) {\n                        const { width, height } = containerRef.current.getBoundingClientRect();\n                        setDimensions({\n                            width,\n                            height\n                        });\n                    }\n                }\n            }[\"CameraAccess.useEffect.updateDimensions\"];\n            updateDimensions();\n            window.addEventListener('resize', updateDimensions);\n            return ({\n                \"CameraAccess.useEffect\": ()=>window.removeEventListener('resize', updateDimensions)\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Handle video element ready state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing || !videoRef.current || !stream) return;\n            const video = videoRef.current;\n            const handleLoadedMetadata = {\n                \"CameraAccess.useEffect.handleLoadedMetadata\": ()=>{\n                    console.log('Video metadata loaded');\n                    setIsVideoReady(true);\n                    // Get video dimensions\n                    const videoWidth = video.videoWidth || 640;\n                    const videoHeight = video.videoHeight || 480;\n                    console.log(\"Video dimensions: \".concat(videoWidth, \"x\").concat(videoHeight));\n                    // Setup canvas for processing\n                    if (canvasRef.current) {\n                        // Store actual dimensions for capture\n                        canvasRef.current.width = videoWidth;\n                        canvasRef.current.height = videoHeight;\n                        // Set display size to maintain aspect ratio\n                        const aspectRatio = videoWidth / videoHeight;\n                        const containerWidth = dimensions.width;\n                        const containerHeight = containerWidth / aspectRatio;\n                        canvasRef.current.style.width = \"\".concat(containerWidth, \"px\");\n                        canvasRef.current.style.height = \"\".concat(containerHeight, \"px\");\n                    }\n                    // Start processing frames\n                    startProcessing();\n                    // Notify parent component that camera is ready\n                    if (onCameraReady) {\n                        onCameraReady({\n                            width: videoWidth,\n                            height: videoHeight\n                        });\n                    }\n                }\n            }[\"CameraAccess.useEffect.handleLoadedMetadata\"];\n            video.addEventListener('loadedmetadata', handleLoadedMetadata);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        stream,\n        dimensions,\n        isShowing,\n        onCameraReady\n    ]);\n    // Simplified camera start function\n    const startCamera = async ()=>{\n        setErrorMessage('');\n        setIsVideoReady(false);\n        try {\n            console.log('Starting camera access...');\n            // Request camera access with optimized settings\n            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 640\n                    },\n                    height: {\n                        ideal: 480\n                    },\n                    facingMode: \"user\",\n                    frameRate: {\n                        ideal: 30\n                    } // Explicitly set frame rate\n                },\n                audio: false\n            });\n            console.log('Camera access granted!');\n            // Store the stream\n            setStream(mediaStream);\n            // Apply stream to video element immediately\n            if (videoRef.current) {\n                videoRef.current.srcObject = mediaStream;\n                // Start video processing as soon as possible\n                const video = videoRef.current;\n                video.onloadedmetadata = ()=>{\n                    console.log('Video metadata loaded');\n                    setIsVideoReady(true);\n                    // Get video dimensions\n                    const videoWidth = video.videoWidth || 640;\n                    const videoHeight = video.videoHeight || 480;\n                    // Setup canvas for processing\n                    if (canvasRef.current) {\n                        canvasRef.current.width = videoWidth;\n                        canvasRef.current.height = videoHeight;\n                        // Set display size to maintain aspect ratio\n                        const aspectRatio = videoWidth / videoHeight;\n                        const containerWidth = dimensions.width;\n                        const containerHeight = containerWidth / aspectRatio;\n                        canvasRef.current.style.width = \"\".concat(containerWidth, \"px\");\n                        canvasRef.current.style.height = \"\".concat(containerHeight, \"px\");\n                    }\n                    // Start processing immediately\n                    startProcessing();\n                    // Notify parent component that camera is ready\n                    if (onCameraReady) {\n                        onCameraReady({\n                            width: videoWidth,\n                            height: videoHeight\n                        });\n                    }\n                };\n                // Try to play video immediately\n                try {\n                    await video.play();\n                    console.log('Video playing successfully!');\n                } catch (playError) {\n                    console.error('Error playing video:', playError);\n                    setErrorMessage('Unable to start video stream. Please try again.');\n                }\n            } else {\n                throw new Error('Video element not found');\n            }\n        } catch (error) {\n            console.error('Camera access error:', error);\n            setErrorMessage(\"Camera error: \".concat(error.message || 'Unknown error'));\n        }\n    };\n    const stopCamera = ()=>{\n        // Stop all tracks in the stream\n        if (stream) {\n            stream.getTracks().forEach((track)=>track.stop());\n            setStream(null);\n        }\n        // Clear video source\n        if (videoRef.current) {\n            videoRef.current.srcObject = null;\n        }\n        // Clear processing interval\n        if (processingInterval.current) {\n            clearInterval(processingInterval.current);\n            processingInterval.current = null;\n        }\n        setIsVideoReady(false);\n    };\n    const startProcessing = ()=>{\n        if (!canvasRef.current || !videoRef.current || !isVideoReady) return;\n        const video = videoRef.current;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Clear any existing interval\n        if (processingInterval.current) {\n            clearInterval(processingInterval.current);\n        }\n        // Start processing frames at ~30fps\n        processingInterval.current = setInterval(()=>{\n            if (video.readyState !== 4) return;\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Save the current context state\n            ctx.save();\n            // Flip the context horizontally to mirror the video\n            ctx.translate(canvas.width, 0);\n            ctx.scale(-1, 1);\n            // Draw video frame to canvas\n            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n            // Restore the context state\n            ctx.restore();\n            // Draw visualizations based on enabled options\n            if (showBoundingBox) {\n                drawBoundingBox(ctx, canvas);\n            }\n            if (showHeadPose) {\n                drawHeadPose(ctx, canvas);\n            }\n            if (showMask) {\n                drawFaceMask(ctx, canvas);\n            }\n            if (showParameters) {\n                drawParameters(ctx, canvas);\n            }\n        }, 33); // ~30fps\n    };\n    // Helper function to draw bounding box\n    const drawBoundingBox = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const boxWidth = canvas.width * 0.6;\n        const boxHeight = canvas.height * 0.8;\n        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);\n    };\n    // Helper function to draw head pose axes\n    const drawHeadPose = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const time = Date.now() / 1000;\n        const length = canvas.width * 0.1;\n        // X axis (red)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX + length * Math.sin(time), centerY);\n        ctx.strokeStyle = 'red';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        // Y axis (green)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX, centerY + length * Math.sin(time + 1));\n        ctx.strokeStyle = 'green';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        // Z axis (blue)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX + length / 2 * Math.sin(time + 2), centerY - length / 2 * Math.cos(time + 2));\n        ctx.strokeStyle = 'blue';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n    };\n    // Helper function to draw face mask\n    const drawFaceMask = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const radius = Math.min(canvas.width, canvas.height) * 0.2;\n        // Draw mask\n        ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        ctx.fill();\n        // Draw eyes\n        const eyeRadius = radius * 0.2;\n        const eyeOffsetX = radius * 0.3;\n        const eyeOffsetY = radius * 0.1;\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n        // Left eye\n        ctx.beginPath();\n        ctx.arc(centerX - eyeOffsetX, centerY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);\n        ctx.fill();\n        // Right eye\n        ctx.beginPath();\n        ctx.arc(centerX + eyeOffsetX, centerY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);\n        ctx.fill();\n    };\n    // Helper function to draw parameters\n    const drawParameters = (ctx, canvas)=>{\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(5, canvas.height - 60, 150, 50);\n        ctx.font = '12px Arial';\n        ctx.fillStyle = 'white';\n        ctx.fillText(\"Resolution: \".concat(canvas.width, \"x\").concat(canvas.height), 10, canvas.height - 40);\n        ctx.fillText(\"FPS: \".concat(fps), 10, canvas.height - 25);\n    };\n    if (!isShowing) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            width: '30vw',\n            height: '30vh',\n            backgroundColor: 'white',\n            borderRadius: '8px',\n            boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',\n            overflow: 'hidden',\n            zIndex: 1000\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                ref: videoRef,\n                style: {\n                    width: '100%',\n                    height: '100%',\n                    objectFit: 'cover',\n                    transform: 'scaleX(-1)',\n                    opacity: 0 // Keep video hidden but functional\n                },\n                playsInline: true,\n                muted: true,\n                autoPlay: true\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 392,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    zIndex: 1\n                }\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 405,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: onClose,\n                style: {\n                    position: 'absolute',\n                    top: '10px',\n                    right: '10px',\n                    padding: '8px 12px',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    color: 'white',\n                    border: 'none',\n                    borderRadius: '4px',\n                    cursor: 'pointer',\n                    zIndex: 2\n                },\n                children: \"Close\"\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 416,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n        lineNumber: 376,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CameraAccess, \"cuZXl+FEVXCsOqKGqJz43nrfPwQ=\");\n_c = CameraAccess;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CameraAccess);\nvar _c;\n$RefreshReg$(_c, \"CameraAccess\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL2NhbWVyYUFjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtCQUFrQjs7O0FBQ3lDO0FBRTNELE1BQU1JLGVBQWU7UUFBQyxFQUNwQkMsU0FBUyxFQUNUQyxPQUFPLEVBQ1BDLGFBQWEsRUFDYkMsZUFBZSxLQUFLLEVBQ3BCQyxrQkFBa0IsS0FBSyxFQUN2QkMsV0FBVyxLQUFLLEVBQ2hCQyxpQkFBaUIsS0FBSyxFQUN2Qjs7SUFDQyxNQUFNQyxXQUFXViw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNVyxZQUFZWCw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNWSxlQUFlWiw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNhLFFBQVFDLFVBQVUsR0FBR2IsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDYyxjQUFjQyxnQkFBZ0IsR0FBR2YsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDZ0IsS0FBS0MsT0FBTyxHQUFHakIsK0NBQVFBLENBQUM7SUFDL0IsTUFBTWtCLGNBQWNuQiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNb0IscUJBQXFCcEIsNkNBQU1BLENBQUM7SUFDbEMsTUFBTSxDQUFDcUIsWUFBWUMsY0FBYyxHQUFHckIsK0NBQVFBLENBQUM7UUFBRXNCLE9BQU87UUFBR0MsUUFBUTtJQUFFO0lBQ25FLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUVqRCx1REFBdUQ7SUFDdkRGLGdEQUFTQTtrQ0FBQztZQUNSLElBQUlJLFdBQVc7Z0JBQ2J3QjtZQUNGLE9BQU87Z0JBQ0xDO1lBQ0Y7WUFFQTswQ0FBTztvQkFDTEE7Z0JBQ0Y7O1FBQ0Y7aUNBQUc7UUFBQ3pCO0tBQVU7SUFFZCxvQkFBb0I7SUFDcEJKLGdEQUFTQTtrQ0FBQztZQUNSLElBQUksQ0FBQ0ksV0FBVztZQUVoQmdCLFlBQVlVLE9BQU8sR0FBR0M7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YWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9jYW1lcmFBY2Nlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FtZXJhQWNjZXNzLmpzXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDYW1lcmFBY2Nlc3MgPSAoeyBcbiAgaXNTaG93aW5nLCBcbiAgb25DbG9zZSwgXG4gIG9uQ2FtZXJhUmVhZHksXG4gIHNob3dIZWFkUG9zZSA9IGZhbHNlLFxuICBzaG93Qm91bmRpbmdCb3ggPSBmYWxzZSxcbiAgc2hvd01hc2sgPSBmYWxzZSxcbiAgc2hvd1BhcmFtZXRlcnMgPSBmYWxzZVxufSkgPT4ge1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtzdHJlYW0sIHNldFN0cmVhbV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2Vycm9yTWVzc2FnZSwgc2V0RXJyb3JNZXNzYWdlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2Zwcywgc2V0RnBzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBmcHNUaW1lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJvY2Vzc2luZ0ludGVydmFsID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbZGltZW5zaW9ucywgc2V0RGltZW5zaW9uc10gPSB1c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gIGNvbnN0IFtpc1ZpZGVvUmVhZHksIHNldElzVmlkZW9SZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBTdGFydCBjYW1lcmEgb24gY29tcG9uZW50IG1vdW50IGlmIGlzU2hvd2luZyBpcyB0cnVlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzU2hvd2luZykge1xuICAgICAgc3RhcnRDYW1lcmEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcENhbWVyYSgpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcENhbWVyYSgpO1xuICAgIH07XG4gIH0sIFtpc1Nob3dpbmddKTtcblxuICAvLyBTZXR1cCBGUFMgY291bnRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTaG93aW5nKSByZXR1cm47XG4gICAgXG4gICAgZnBzVGltZXJSZWYuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldEZwcyhwcmV2RnBzID0+IHtcbiAgICAgICAgLy8gU2ltcGxlIG1vY2sgZm9yIGZwcyBjb3VudGVyXG4gICAgICAgIGNvbnN0IG5ld0ZwcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSArIDI1OyAvLyBSYW5kb20gYmV0d2VlbiAyNS0zNSBmcHNcbiAgICAgICAgcmV0dXJuIG5ld0ZwcztcbiAgICAgIH0pO1xuICAgIH0sIDEwMDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZnBzVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKGZwc1RpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc1Nob3dpbmddKTtcblxuICAvLyBVcGRhdGUgZGltZW5zaW9ucyB3aGVuIGNvbnRhaW5lciBzaXplIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU2hvd2luZykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgc2V0RGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgfSwgW2lzU2hvd2luZ10pO1xuXG4gIC8vIEhhbmRsZSB2aWRlbyBlbGVtZW50IHJlYWR5IHN0YXRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1Nob3dpbmcgfHwgIXZpZGVvUmVmLmN1cnJlbnQgfHwgIXN0cmVhbSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHZpZGVvID0gdmlkZW9SZWYuY3VycmVudDtcbiAgICBcbiAgICBjb25zdCBoYW5kbGVMb2FkZWRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdWaWRlbyBtZXRhZGF0YSBsb2FkZWQnKTtcbiAgICAgIHNldElzVmlkZW9SZWFkeSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHZpZGVvIGRpbWVuc2lvbnNcbiAgICAgIGNvbnN0IHZpZGVvV2lkdGggPSB2aWRlby52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgIGNvbnN0IHZpZGVvSGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgVmlkZW8gZGltZW5zaW9uczogJHt2aWRlb1dpZHRofXgke3ZpZGVvSGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBTZXR1cCBjYW52YXMgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBTdG9yZSBhY3R1YWwgZGltZW5zaW9ucyBmb3IgY2FwdHVyZVxuICAgICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IHZpZGVvV2lkdGg7XG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCA9IHZpZGVvSGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGRpc3BsYXkgc2l6ZSB0byBtYWludGFpbiBhc3BlY3QgcmF0aW9cbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSB2aWRlb1dpZHRoIC8gdmlkZW9IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgXG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gYCR7Y29udGFpbmVyV2lkdGh9cHhgO1xuICAgICAgICBjYW52YXNSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtjb250YWluZXJIZWlnaHR9cHhgO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdGFydCBwcm9jZXNzaW5nIGZyYW1lc1xuICAgICAgc3RhcnRQcm9jZXNzaW5nKCk7XG4gICAgICBcbiAgICAgIC8vIE5vdGlmeSBwYXJlbnQgY29tcG9uZW50IHRoYXQgY2FtZXJhIGlzIHJlYWR5XG4gICAgICBpZiAob25DYW1lcmFSZWFkeSkge1xuICAgICAgICBvbkNhbWVyYVJlYWR5KHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGhhbmRsZUxvYWRlZE1ldGFkYXRhKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBoYW5kbGVMb2FkZWRNZXRhZGF0YSk7XG4gICAgfTtcbiAgfSwgW3N0cmVhbSwgZGltZW5zaW9ucywgaXNTaG93aW5nLCBvbkNhbWVyYVJlYWR5XSk7XG5cbiAgLy8gU2ltcGxpZmllZCBjYW1lcmEgc3RhcnQgZnVuY3Rpb25cbiAgY29uc3Qgc3RhcnRDYW1lcmEgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0RXJyb3JNZXNzYWdlKCcnKTtcbiAgICBzZXRJc1ZpZGVvUmVhZHkoZmFsc2UpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgY2FtZXJhIGFjY2Vzcy4uLicpO1xuICAgICAgXG4gICAgICAvLyBSZXF1ZXN0IGNhbWVyYSBhY2Nlc3Mgd2l0aCBvcHRpbWl6ZWQgc2V0dGluZ3NcbiAgICAgIGNvbnN0IG1lZGlhU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIHdpZHRoOiB7IGlkZWFsOiA2NDAgfSwgLy8gUmVkdWNlZCBmcm9tIDEyODAgdG8gNjQwIGZvciBmYXN0ZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICBoZWlnaHQ6IHsgaWRlYWw6IDQ4MCB9LCAvLyBSZWR1Y2VkIGZyb20gNzIwIHRvIDQ4MFxuICAgICAgICAgIGZhY2luZ01vZGU6IFwidXNlclwiLFxuICAgICAgICAgIGZyYW1lUmF0ZTogeyBpZGVhbDogMzAgfSAvLyBFeHBsaWNpdGx5IHNldCBmcmFtZSByYXRlXG4gICAgICAgIH0sXG4gICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdDYW1lcmEgYWNjZXNzIGdyYW50ZWQhJyk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSBzdHJlYW1cbiAgICAgIHNldFN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50IGltbWVkaWF0ZWx5XG4gICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xuICAgICAgICB2aWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgdmlkZW8gcHJvY2Vzc2luZyBhcyBzb29uIGFzIHBvc3NpYmxlXG4gICAgICAgIGNvbnN0IHZpZGVvID0gdmlkZW9SZWYuY3VycmVudDtcbiAgICAgICAgdmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVmlkZW8gbWV0YWRhdGEgbG9hZGVkJyk7XG4gICAgICAgICAgc2V0SXNWaWRlb1JlYWR5KHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCB2aWRlbyBkaW1lbnNpb25zXG4gICAgICAgICAgY29uc3QgdmlkZW9XaWR0aCA9IHZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgIGNvbnN0IHZpZGVvSGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldHVwIGNhbnZhcyBmb3IgcHJvY2Vzc2luZ1xuICAgICAgICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQud2lkdGggPSB2aWRlb1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNldCBkaXNwbGF5IHNpemUgdG8gbWFpbnRhaW4gYXNwZWN0IHJhdGlvXG4gICAgICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHZpZGVvV2lkdGggLyB2aWRlb0hlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckhlaWdodCA9IGNvbnRhaW5lcldpZHRoIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gYCR7Y29udGFpbmVyV2lkdGh9cHhgO1xuICAgICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gYCR7Y29udGFpbmVySGVpZ2h0fXB4YDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RhcnQgcHJvY2Vzc2luZyBpbW1lZGlhdGVseVxuICAgICAgICAgIHN0YXJ0UHJvY2Vzc2luZygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE5vdGlmeSBwYXJlbnQgY29tcG9uZW50IHRoYXQgY2FtZXJhIGlzIHJlYWR5XG4gICAgICAgICAgaWYgKG9uQ2FtZXJhUmVhZHkpIHtcbiAgICAgICAgICAgIG9uQ2FtZXJhUmVhZHkoe1xuICAgICAgICAgICAgICB3aWR0aDogdmlkZW9XaWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiB2aWRlb0hlaWdodFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIHBsYXkgdmlkZW8gaW1tZWRpYXRlbHlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB2aWRlby5wbGF5KCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1ZpZGVvIHBsYXlpbmcgc3VjY2Vzc2Z1bGx5IScpO1xuICAgICAgICB9IGNhdGNoIChwbGF5RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwbGF5aW5nIHZpZGVvOicsIHBsYXlFcnJvcik7XG4gICAgICAgICAgc2V0RXJyb3JNZXNzYWdlKCdVbmFibGUgdG8gc3RhcnQgdmlkZW8gc3RyZWFtLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvIGVsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbWVyYSBhY2Nlc3MgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3JNZXNzYWdlKGBDYW1lcmEgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN0b3BDYW1lcmEgPSAoKSA9PiB7XG4gICAgLy8gU3RvcCBhbGwgdHJhY2tzIGluIHRoZSBzdHJlYW1cbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgc2V0U3RyZWFtKG51bGwpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciB2aWRlbyBzb3VyY2VcbiAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xuICAgICAgdmlkZW9SZWYuY3VycmVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciBwcm9jZXNzaW5nIGludGVydmFsXG4gICAgaWYgKHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50KSB7XG4gICAgICBjbGVhckludGVydmFsKHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50KTtcbiAgICAgIHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNWaWRlb1JlYWR5KGZhbHNlKTtcbiAgfTtcblxuICBjb25zdCBzdGFydFByb2Nlc3NpbmcgPSAoKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCAhdmlkZW9SZWYuY3VycmVudCB8fCAhaXNWaWRlb1JlYWR5KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdmlkZW8gPSB2aWRlb1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyBpbnRlcnZhbFxuICAgIGlmIChwcm9jZXNzaW5nSW50ZXJ2YWwuY3VycmVudCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChwcm9jZXNzaW5nSW50ZXJ2YWwuY3VycmVudCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmcgZnJhbWVzIGF0IH4zMGZwc1xuICAgIHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgaWYgKHZpZGVvLnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgY29udGV4dCBzdGF0ZVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIFxuICAgICAgLy8gRmxpcCB0aGUgY29udGV4dCBob3Jpem9udGFsbHkgdG8gbWlycm9yIHRoZSB2aWRlb1xuICAgICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIDApO1xuICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcbiAgICAgIFxuICAgICAgLy8gRHJhdyB2aWRlbyBmcmFtZSB0byBjYW52YXNcbiAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgdGhlIGNvbnRleHQgc3RhdGVcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBcbiAgICAgIC8vIERyYXcgdmlzdWFsaXphdGlvbnMgYmFzZWQgb24gZW5hYmxlZCBvcHRpb25zXG4gICAgICBpZiAoc2hvd0JvdW5kaW5nQm94KSB7XG4gICAgICAgIGRyYXdCb3VuZGluZ0JveChjdHgsIGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzaG93SGVhZFBvc2UpIHtcbiAgICAgICAgZHJhd0hlYWRQb3NlKGN0eCwgY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHNob3dNYXNrKSB7XG4gICAgICAgIGRyYXdGYWNlTWFzayhjdHgsIGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChzaG93UGFyYW1ldGVycykge1xuICAgICAgICBkcmF3UGFyYW1ldGVycyhjdHgsIGNhbnZhcyk7XG4gICAgICB9XG4gICAgfSwgMzMpOyAvLyB+MzBmcHNcbiAgfTtcbiAgXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBkcmF3IGJvdW5kaW5nIGJveFxuICBjb25zdCBkcmF3Qm91bmRpbmdCb3ggPSAoY3R4LCBjYW52YXMpID0+IHtcbiAgICBjb25zdCBjZW50ZXJYID0gY2FudmFzLndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgYm94V2lkdGggPSBjYW52YXMud2lkdGggKiAwLjY7XG4gICAgY29uc3QgYm94SGVpZ2h0ID0gY2FudmFzLmhlaWdodCAqIDAuODtcbiAgICBcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDI1NSwgMCwgMC43KSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgY3R4LnN0cm9rZVJlY3QoXG4gICAgICBjZW50ZXJYIC0gYm94V2lkdGgvMiwgXG4gICAgICBjZW50ZXJZIC0gYm94SGVpZ2h0LzIsIFxuICAgICAgYm94V2lkdGgsIFxuICAgICAgYm94SGVpZ2h0XG4gICAgKTtcbiAgfTtcbiAgXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBkcmF3IGhlYWQgcG9zZSBheGVzXG4gIGNvbnN0IGRyYXdIZWFkUG9zZSA9IChjdHgsIGNhbnZhcykgPT4ge1xuICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBjYW52YXMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgY29uc3QgbGVuZ3RoID0gY2FudmFzLndpZHRoICogMC4xO1xuICAgIFxuICAgIC8vIFggYXhpcyAocmVkKVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKGNlbnRlclgsIGNlbnRlclkpO1xuICAgIGN0eC5saW5lVG8oY2VudGVyWCArIGxlbmd0aCAqIE1hdGguc2luKHRpbWUpLCBjZW50ZXJZKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgXG4gICAgLy8gWSBheGlzIChncmVlbilcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICBjdHgubGluZVRvKGNlbnRlclgsIGNlbnRlclkgKyBsZW5ndGggKiBNYXRoLnNpbih0aW1lICsgMSkpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIFogYXhpcyAoYmx1ZSlcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICBjdHgubGluZVRvKFxuICAgICAgY2VudGVyWCArIGxlbmd0aC8yICogTWF0aC5zaW4odGltZSArIDIpLCBcbiAgICAgIGNlbnRlclkgLSBsZW5ndGgvMiAqIE1hdGguY29zKHRpbWUgKyAyKVxuICAgICk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsdWUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfTtcbiAgXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBkcmF3IGZhY2UgbWFza1xuICBjb25zdCBkcmF3RmFjZU1hc2sgPSAoY3R4LCBjYW52YXMpID0+IHtcbiAgICBjb25zdCBjZW50ZXJYID0gY2FudmFzLndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSAqIDAuMjtcbiAgICBcbiAgICAvLyBEcmF3IG1hc2tcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMjU1LCAyNTUsIDAuMiknO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gRHJhdyBleWVzXG4gICAgY29uc3QgZXllUmFkaXVzID0gcmFkaXVzICogMC4yO1xuICAgIGNvbnN0IGV5ZU9mZnNldFggPSByYWRpdXMgKiAwLjM7XG4gICAgY29uc3QgZXllT2Zmc2V0WSA9IHJhZGl1cyAqIDAuMTtcbiAgICBcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSc7XG4gICAgXG4gICAgLy8gTGVmdCBleWVcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhjZW50ZXJYIC0gZXllT2Zmc2V0WCwgY2VudGVyWSAtIGV5ZU9mZnNldFksIGV5ZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gUmlnaHQgZXllXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoY2VudGVyWCArIGV5ZU9mZnNldFgsIGNlbnRlclkgLSBleWVPZmZzZXRZLCBleWVSYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbCgpO1xuICB9O1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRyYXcgcGFyYW1ldGVyc1xuICBjb25zdCBkcmF3UGFyYW1ldGVycyA9IChjdHgsIGNhbnZhcykgPT4ge1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAwLjcpJztcbiAgICBjdHguZmlsbFJlY3QoNSwgY2FudmFzLmhlaWdodCAtIDYwLCAxNTAsIDUwKTtcbiAgICBcbiAgICBjdHguZm9udCA9ICcxMnB4IEFyaWFsJztcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFRleHQoYFJlc29sdXRpb246ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCwgMTAsIGNhbnZhcy5oZWlnaHQgLSA0MCk7XG4gICAgY3R4LmZpbGxUZXh0KGBGUFM6ICR7ZnBzfWAsIDEwLCBjYW52YXMuaGVpZ2h0IC0gMjUpO1xuICB9O1xuXG4gIGlmICghaXNTaG93aW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgXG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgIHN0eWxlPXt7IFxuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgIHdpZHRoOiAnMzB2dycsIC8vIDMwJSBvZiB2aWV3cG9ydCB3aWR0aFxuICAgICAgICBoZWlnaHQ6ICczMHZoJywgLy8gMzAlIG9mIHZpZXdwb3J0IGhlaWdodFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHpJbmRleDogMTAwMFxuICAgICAgfX1cbiAgICA+XG4gICAgICA8dmlkZW9cbiAgICAgICAgcmVmPXt2aWRlb1JlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIG9iamVjdEZpdDogJ2NvdmVyJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoLTEpJywgLy8gRmxpcCBob3Jpem9udGFsbHlcbiAgICAgICAgICBvcGFjaXR5OiAwIC8vIEtlZXAgdmlkZW8gaGlkZGVuIGJ1dCBmdW5jdGlvbmFsXG4gICAgICAgIH19XG4gICAgICAgIHBsYXlzSW5saW5lXG4gICAgICAgIG11dGVkXG4gICAgICAgIGF1dG9QbGF5XG4gICAgICAvPlxuICAgICAgPGNhbnZhc1xuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25DbGljaz17b25DbG9zZX1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6ICcxMHB4JyxcbiAgICAgICAgICByaWdodDogJzEwcHgnLFxuICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCcsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgIHpJbmRleDogMlxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICBDbG9zZVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFBY2Nlc3M7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJDYW1lcmFBY2Nlc3MiLCJpc1Nob3dpbmciLCJvbkNsb3NlIiwib25DYW1lcmFSZWFkeSIsInNob3dIZWFkUG9zZSIsInNob3dCb3VuZGluZ0JveCIsInNob3dNYXNrIiwic2hvd1BhcmFtZXRlcnMiLCJ2aWRlb1JlZiIsImNhbnZhc1JlZiIsImNvbnRhaW5lclJlZiIsInN0cmVhbSIsInNldFN0cmVhbSIsImVycm9yTWVzc2FnZSIsInNldEVycm9yTWVzc2FnZSIsImZwcyIsInNldEZwcyIsImZwc1RpbWVyUmVmIiwicHJvY2Vzc2luZ0ludGVydmFsIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsImlzVmlkZW9SZWFkeSIsInNldElzVmlkZW9SZWFkeSIsInN0YXJ0Q2FtZXJhIiwic3RvcENhbWVyYSIsImN1cnJlbnQiLCJzZXRJbnRlcnZhbCIsInByZXZGcHMiLCJuZXdGcHMiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJjbGVhckludGVydmFsIiwidXBkYXRlRGltZW5zaW9ucyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwidmlkZW8iLCJoYW5kbGVMb2FkZWRNZXRhZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJhc3BlY3RSYXRpbyIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0Iiwic3R5bGUiLCJzdGFydFByb2Nlc3NpbmciLCJtZWRpYVN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImlkZWFsIiwiZmFjaW5nTW9kZSIsImZyYW1lUmF0ZSIsImF1ZGlvIiwic3JjT2JqZWN0Iiwib25sb2FkZWRtZXRhZGF0YSIsInBsYXkiLCJwbGF5RXJyb3IiLCJlcnJvciIsIkVycm9yIiwibWVzc2FnZSIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJjYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwicmVhZHlTdGF0ZSIsImNsZWFyUmVjdCIsInNhdmUiLCJ0cmFuc2xhdGUiLCJzY2FsZSIsImRyYXdJbWFnZSIsInJlc3RvcmUiLCJkcmF3Qm91bmRpbmdCb3giLCJkcmF3SGVhZFBvc2UiLCJkcmF3RmFjZU1hc2siLCJkcmF3UGFyYW1ldGVycyIsImNlbnRlclgiLCJjZW50ZXJZIiwiYm94V2lkdGgiLCJib3hIZWlnaHQiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZVJlY3QiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsImxlbmd0aCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInNpbiIsInN0cm9rZSIsImNvcyIsInJhZGl1cyIsIm1pbiIsImZpbGxTdHlsZSIsImFyYyIsIlBJIiwiZmlsbCIsImV5ZVJhZGl1cyIsImV5ZU9mZnNldFgiLCJleWVPZmZzZXRZIiwiZmlsbFJlY3QiLCJmb250IiwiZmlsbFRleHQiLCJkaXYiLCJyZWYiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ0cmFuc2Zvcm0iLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJib3hTaGFkb3ciLCJvdmVyZmxvdyIsInpJbmRleCIsIm9iamVjdEZpdCIsIm9wYWNpdHkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwiYXV0b1BsYXkiLCJidXR0b24iLCJvbkNsaWNrIiwicmlnaHQiLCJwYWRkaW5nIiwiY29sb3IiLCJib3JkZXIiLCJjdXJzb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/cameraAccess.js\n"));

/***/ })

});