"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Helper/savefile.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureImagesAtPoint: () => (/* binding */ captureImagesAtPoint),\n/* harmony export */   saveCSVToServer: () => (/* binding */ saveCSVToServer),\n/* harmony export */   saveImageToServer: () => (/* binding */ saveImageToServer)\n/* harmony export */ });\n// Helper/savefile.js - Added highest resolution webcam capture\n/**\n * Resize an image to fit within a certain size limit\n * @param {string} imageDataUrl - Base64 encoded image data\n * @param {number} maxWidth - Maximum width of the resized image\n * @param {number} maxHeight - Maximum height of the resized image\n * @param {number} quality - JPEG quality (0-1)\n * @returns {Promise<string>} - Resized image data URL\n */ const resizeImage = async function(imageDataUrl) {\n    let maxWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 800, maxHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 600, quality = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85;\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = new Image();\n            img.onload = ()=>{\n                // Calculate new dimensions while maintaining aspect ratio\n                let width = img.width;\n                let height = img.height;\n                if (width > maxWidth) {\n                    height = Math.round(height * (maxWidth / width));\n                    width = maxWidth;\n                }\n                if (height > maxHeight) {\n                    width = Math.round(width * (maxHeight / height));\n                    height = maxHeight;\n                }\n                // Create canvas for resizing\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                // Draw and resize image on canvas\n                const ctx = canvas.getContext('2d');\n                ctx.drawImage(img, 0, 0, width, height);\n                // Convert to JPEG with specified quality\n                const resizedDataUrl = canvas.toDataURL('image/jpeg', quality);\n                resolve(resizedDataUrl);\n            };\n            img.onerror = (err)=>reject(err);\n            img.src = imageDataUrl;\n        } catch (err) {\n            reject(err);\n        }\n    });\n};\n/**\n * Check if an image is too large for the server API\n * @param {string} imageDataUrl - Base64 encoded image data\n * @param {number} maxSizeBytes - Maximum size in bytes (default 900KB)\n * @returns {boolean} - True if image is too large\n */ const isImageTooLarge = function(imageDataUrl) {\n    let maxSizeBytes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 900 * 1024;\n    // Base64 data URLs have a 4:3 ratio to actual bytes\n    // We subtract the data URL prefix length\n    const prefix = 'data:image/jpeg;base64,';\n    const base64Length = imageDataUrl.length - (imageDataUrl.startsWith(prefix) ? prefix.length : 0);\n    const approximateBytes = base64Length * 3 / 4;\n    return approximateBytes > maxSizeBytes;\n};\n/**\n * Save an image or data to the server with group ID to ensure consistent numbering\n * @param {string} imageData - Base64 encoded image data\n * @param {string} filename - Filename pattern to save as\n * @param {string} type - Type of file (screen, webcam, parameters)\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveImageToServer = async function(imageData, filename, type) {\n    let folder = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'eye_tracking_captures', captureGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    try {\n        // Check image size and resize if necessary for non-parameter files\n        let processedImageData = imageData;\n        if (type !== 'parameters' && isImageTooLarge(imageData)) {\n            console.log(\"Image too large for \".concat(type, \", resizing before sending to server\"));\n            // Start with higher quality and progressively reduce quality/size until it's small enough\n            const sizes = [\n                {\n                    width: 1920,\n                    height: 1080,\n                    quality: 0.9\n                },\n                {\n                    width: 1280,\n                    height: 720,\n                    quality: 0.85\n                },\n                {\n                    width: 800,\n                    height: 600,\n                    quality: 0.8\n                },\n                {\n                    width: 640,\n                    height: 480,\n                    quality: 0.75\n                }\n            ];\n            for (const { width, height, quality } of sizes){\n                processedImageData = await resizeImage(imageData, width, height, quality);\n                if (!isImageTooLarge(processedImageData)) {\n                    console.log(\"Successfully resized \".concat(type, \" to \").concat(width, \"x\").concat(height, \" at quality \").concat(quality));\n                    break;\n                }\n            }\n        }\n        const response = await fetch('/api/save-capture', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                imageData: processedImageData,\n                filename,\n                type,\n                folder,\n                captureGroup\n            })\n        });\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error(\"Error saving \".concat(type, \":\"), error);\n        return null;\n    }\n};\n/**\n * Save CSV data to the server\n * @param {string} csvData - CSV data\n * @param {string} filename - Filename pattern to save as\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveCSVToServer = async function(csvData, filename) {\n    let folder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'eye_tracking_captures', captureGroup = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        const csvBlob = new Blob([\n            csvData\n        ], {\n            type: 'text/csv'\n        });\n        const reader = new FileReader();\n        const csvDataUrl = await new Promise((resolve)=>{\n            reader.onloadend = ()=>resolve(reader.result);\n            reader.readAsDataURL(csvBlob);\n        });\n        const result = await saveImageToServer(csvDataUrl, filename, 'parameters', folder, captureGroup);\n        return result;\n    } catch (error) {\n        console.error('Error saving CSV:', error);\n        return null;\n    }\n};\n/**\n * Get the highest resolution camera constraints supported by the device\n * @returns {Promise<MediaStreamConstraints>} - Camera constraints with highest resolution\n */ const getHighestResolutionConstraints = async ()=>{\n    // Define possible resolutions in descending order of quality\n    const resolutions = [\n        {\n            width: {\n                ideal: 4096\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 3840\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 2560\n            },\n            height: {\n                ideal: 1440\n            }\n        },\n        {\n            width: {\n                ideal: 1920\n            },\n            height: {\n                ideal: 1080\n            }\n        },\n        {\n            width: {\n                ideal: 1280\n            },\n            height: {\n                ideal: 720\n            }\n        },\n        {\n            width: {\n                ideal: 640\n            },\n            height: {\n                ideal: 480\n            }\n        },\n        {} // Default - let browser decide\n    ];\n    // Try the resolutions in order until one works\n    for (const resolution of resolutions){\n        try {\n            const constraints = {\n                video: {\n                    ...resolution,\n                    facingMode: \"user\"\n                }\n            };\n            // Test if this resolution is supported\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n            // Stop the test stream immediately\n            stream.getTracks().forEach((track)=>track.stop());\n            console.log(\"Highest supported resolution:\", resolution);\n            return constraints;\n        } catch (err) {\n            console.log(\"Resolution not supported: \".concat(JSON.stringify(resolution)));\n        // Continue to next resolution\n        }\n    }\n    // If nothing worked, return basic constraints\n    return {\n        video: true\n    };\n};\n/**\n * Capture and save images at a specific point with consistent numbering\n * @param {Object} options - Capture options\n * @returns {Promise<Object>} - Capture results\n */ const captureImagesAtPoint = async (param)=>{\n    let { point, captureCount = 1, canvasRef, setCaptureCount, showCapturePreview } = param;\n    try {\n        const folder = 'eye_tracking_captures';\n        // Create a unique ID for this capture group\n        const captureGroupId = \"capture-\".concat(Date.now());\n        console.log(\"Generated capture group ID: \".concat(captureGroupId));\n        // File patterns for saving\n        const screenFilename = 'screen_001.jpg'; // Pattern only - server will assign number\n        const webcamFilename = 'webcam_001.jpg'; // Pattern only - server will assign number\n        const parameterFilename = 'parameter_001.csv'; // Pattern only - server will assign number\n        // For logging\n        console.log(\"Starting capture with group ID:\", captureGroupId);\n        const canvas = canvasRef.current;\n        let screenImage = null;\n        let webcamImage = null;\n        let captureNumber = null;\n        // Variables to store webcam resolution\n        let webcamWidth = 0;\n        let webcamHeight = 0;\n        // 1. Prepare all data first\n        // 1.1 Canvas/screen image\n        if (canvas) {\n            screenImage = canvas.toDataURL('image/png');\n        }\n        // 1.2 Webcam image - Try to get the highest resolution available\n        let webcamImagePreview = null; // Separate lower-resolution version for preview\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            // Use existing video element if available\n            webcamWidth = videoElement.videoWidth || 0;\n            webcamHeight = videoElement.videoHeight || 0;\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = webcamWidth;\n            tempCanvas.height = webcamHeight;\n            tempCanvas.getContext('2d').drawImage(videoElement, 0, 0);\n            // Create high-resolution version for saving\n            webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n            // Create lower-resolution version for preview\n            webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n            console.log(\"Existing webcam resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n        } else {\n            try {\n                // Get highest resolution constraints for this device\n                const constraints = await getHighestResolutionConstraints();\n                console.log(\"Using camera constraints:\", constraints);\n                // Try to get stream with highest resolution\n                const stream = await navigator.mediaDevices.getUserMedia(constraints);\n                // Create temporary video element to get the stream\n                const tempVideo = document.createElement('video');\n                tempVideo.srcObject = stream;\n                tempVideo.muted = true;\n                tempVideo.playsInline = true;\n                tempVideo.autoplay = true;\n                document.body.appendChild(tempVideo);\n                // Need to wait for video to be initialized\n                await new Promise((resolve)=>{\n                    tempVideo.onloadedmetadata = ()=>{\n                        tempVideo.play();\n                        resolve();\n                    };\n                    // Fallback if onloadedmetadata doesn't fire\n                    setTimeout(resolve, 1000);\n                });\n                // Wait a bit longer for the video to actually start playing\n                await new Promise((res)=>setTimeout(res, 500));\n                // Store webcam resolution\n                webcamWidth = tempVideo.videoWidth || 0;\n                webcamHeight = tempVideo.videoHeight || 0;\n                if (webcamWidth > 0 && webcamHeight > 0) {\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                    console.log(\"High-resolution webcam capture: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    console.warn(\"Unable to determine video dimensions, using fallback method\");\n                    const track = stream.getVideoTracks()[0];\n                    const settings = track.getSettings();\n                    webcamWidth = settings.width || 0;\n                    webcamHeight = settings.height || 0;\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth || 640;\n                    tempCanvas.height = webcamHeight || 480;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                    console.log(\"Fallback webcam resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Clean up\n                stream.getTracks().forEach((t)=>t.stop());\n                tempVideo.remove();\n            } catch (err) {\n                console.warn(\"High-resolution webcam capture failed:\", err);\n                // Try one more time with basic constraints\n                try {\n                    const stream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const tempVideo = document.createElement('video');\n                    tempVideo.srcObject = stream;\n                    tempVideo.muted = true;\n                    tempVideo.playsInline = true;\n                    document.body.appendChild(tempVideo);\n                    await tempVideo.play();\n                    await new Promise((res)=>setTimeout(res, 300));\n                    webcamWidth = tempVideo.videoWidth || 0;\n                    webcamHeight = tempVideo.videoHeight || 0;\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.9);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.8);\n                    console.log(\"Basic webcam resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                    stream.getTracks().forEach((t)=>t.stop());\n                    tempVideo.remove();\n                } catch (fallbackErr) {\n                    console.error(\"All webcam capture methods failed:\", fallbackErr);\n                }\n            }\n        }\n        // 1.3 Parameter data - Now including webcam resolution\n        const csvData = [\n            \"name,value\",\n            \"dot_x,\".concat(point.x),\n            \"dot_y,\".concat(point.y),\n            \"canvas_width,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.width) || 0),\n            \"canvas_height,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.height) || 0),\n            \"window_width,\".concat(window.innerWidth),\n            \"window_height,\".concat(window.innerHeight),\n            \"webcam_resolution_width,\".concat(webcamWidth),\n            \"webcam_resolution_height,\".concat(webcamHeight),\n            \"timestamp,\".concat(new Date().toISOString()),\n            \"group_id,\".concat(captureGroupId)\n        ].join('\\n');\n        // 2. Save all files with the same group ID so they get the same number\n        // 2.1 Save parameter file\n        const paramResult = await saveCSVToServer(csvData, parameterFilename, folder, captureGroupId);\n        if (paramResult && paramResult.success) {\n            captureNumber = paramResult.number;\n            console.log(\"Server assigned capture number: \".concat(captureNumber, \" for group: \").concat(captureGroupId));\n        }\n        // 2.2 Save screen image if available\n        let screenResult = null;\n        if (screenImage) {\n            screenResult = await saveImageToServer(screenImage, screenFilename, 'screen', folder, captureGroupId);\n        }\n        // 2.3 Save webcam image if available\n        let webcamResult = null;\n        if (webcamImage) {\n            webcamResult = await saveImageToServer(webcamImage, webcamFilename, 'webcam', folder, captureGroupId);\n        }\n        // 3. Show preview if needed - use the lower resolution version for preview\n        if (showCapturePreview && typeof showCapturePreview === 'function') {\n            showCapturePreview(screenImage, webcamImagePreview || webcamImage, point);\n        }\n        // 4. Increment counter for next capture\n        if (setCaptureCount && typeof setCaptureCount === 'function') {\n            setCaptureCount((prevCount)=>prevCount + 1);\n        }\n        // 5. Return results - now including webcam resolution\n        return {\n            screenImage,\n            webcamImage,\n            success: true,\n            point,\n            captureNumber,\n            groupId: captureGroupId,\n            webcamWidth,\n            webcamHeight\n        };\n    } catch (err) {\n        console.error(\"captureImagesAtPoint failed:\", err);\n        return {\n            success: false,\n            error: err.message,\n            screenImage: null,\n            webcamImage: null,\n            webcamWidth: 0,\n            webcamHeight: 0\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0hlbHBlci9zYXZlZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrREFBK0Q7QUFFL0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLGNBQWMsZUFBT0M7UUFBY0MsNEVBQVcsS0FBS0MsNkVBQVksS0FBS0MsMkVBQVU7SUFDbEYsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCLElBQUk7WUFDRixNQUFNQyxNQUFNLElBQUlDO1lBQ2hCRCxJQUFJRSxNQUFNLEdBQUc7Z0JBQ1gsMERBQTBEO2dCQUMxRCxJQUFJQyxRQUFRSCxJQUFJRyxLQUFLO2dCQUNyQixJQUFJQyxTQUFTSixJQUFJSSxNQUFNO2dCQUV2QixJQUFJRCxRQUFRVCxVQUFVO29CQUNwQlUsU0FBU0MsS0FBS0MsS0FBSyxDQUFDRixTQUFVVixDQUFBQSxXQUFXUyxLQUFJO29CQUM3Q0EsUUFBUVQ7Z0JBQ1Y7Z0JBRUEsSUFBSVUsU0FBU1QsV0FBVztvQkFDdEJRLFFBQVFFLEtBQUtDLEtBQUssQ0FBQ0gsUUFBU1IsQ0FBQUEsWUFBWVMsTUFBSztvQkFDN0NBLFNBQVNUO2dCQUNYO2dCQUVBLDZCQUE2QjtnQkFDN0IsTUFBTVksU0FBU0MsU0FBU0MsYUFBYSxDQUFDO2dCQUN0Q0YsT0FBT0osS0FBSyxHQUFHQTtnQkFDZkksT0FBT0gsTUFBTSxHQUFHQTtnQkFFaEIsa0NBQWtDO2dCQUNsQyxNQUFNTSxNQUFNSCxPQUFPSSxVQUFVLENBQUM7Z0JBQzlCRCxJQUFJRSxTQUFTLENBQUNaLEtBQUssR0FBRyxHQUFHRyxPQUFPQztnQkFFaEMseUNBQXlDO2dCQUN6QyxNQUFNUyxpQkFBaUJOLE9BQU9PLFNBQVMsQ0FBQyxjQUFjbEI7Z0JBQ3RERSxRQUFRZTtZQUNWO1lBRUFiLElBQUllLE9BQU8sR0FBRyxDQUFDQyxNQUFRakIsT0FBT2lCO1lBQzlCaEIsSUFBSWlCLEdBQUcsR0FBR3hCO1FBQ1osRUFBRSxPQUFPdUIsS0FBSztZQUNaakIsT0FBT2lCO1FBQ1Q7SUFDRjtBQUNGO0FBRUE7Ozs7O0NBS0MsR0FDRCxNQUFNRSxrQkFBa0IsU0FBQ3pCO1FBQWMwQixnRkFBZSxNQUFNO0lBQzFELG9EQUFvRDtJQUNwRCx5Q0FBeUM7SUFDekMsTUFBTUMsU0FBUztJQUNmLE1BQU1DLGVBQWU1QixhQUFhNkIsTUFBTSxHQUFJN0IsQ0FBQUEsYUFBYThCLFVBQVUsQ0FBQ0gsVUFBVUEsT0FBT0UsTUFBTSxHQUFHO0lBQzlGLE1BQU1FLG1CQUFtQixlQUFnQixJQUFLO0lBRTlDLE9BQU9BLG1CQUFtQkw7QUFDNUI7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNNLE1BQU1NLG9CQUFvQixlQUFPQyxXQUFXQyxVQUFVQztRQUFNQywwRUFBUyx5QkFBeUJDLGdGQUFlO0lBQ2xILElBQUk7UUFDRixtRUFBbUU7UUFDbkUsSUFBSUMscUJBQXFCTDtRQUV6QixJQUFJRSxTQUFTLGdCQUFnQlYsZ0JBQWdCUSxZQUFZO1lBQ3ZETSxRQUFRQyxHQUFHLENBQUMsdUJBQTRCLE9BQUxMLE1BQUs7WUFFeEMsMEZBQTBGO1lBQzFGLE1BQU1NLFFBQVE7Z0JBQ1o7b0JBQUUvQixPQUFPO29CQUFNQyxRQUFRO29CQUFNUixTQUFTO2dCQUFJO2dCQUMxQztvQkFBRU8sT0FBTztvQkFBTUMsUUFBUTtvQkFBS1IsU0FBUztnQkFBSztnQkFDMUM7b0JBQUVPLE9BQU87b0JBQUtDLFFBQVE7b0JBQUtSLFNBQVM7Z0JBQUk7Z0JBQ3hDO29CQUFFTyxPQUFPO29CQUFLQyxRQUFRO29CQUFLUixTQUFTO2dCQUFLO2FBQzFDO1lBRUQsS0FBSyxNQUFNLEVBQUVPLEtBQUssRUFBRUMsTUFBTSxFQUFFUixPQUFPLEVBQUUsSUFBSXNDLE1BQU87Z0JBQzlDSCxxQkFBcUIsTUFBTXZDLFlBQVlrQyxXQUFXdkIsT0FBT0MsUUFBUVI7Z0JBRWpFLElBQUksQ0FBQ3NCLGdCQUFnQmEscUJBQXFCO29CQUN4Q0MsUUFBUUMsR0FBRyxDQUFDLHdCQUFtQzlCLE9BQVh5QixNQUFLLFFBQWV4QixPQUFURCxPQUFNLEtBQXdCUCxPQUFyQlEsUUFBTyxnQkFBc0IsT0FBUlI7b0JBQzdFO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE1BQU11QyxXQUFXLE1BQU1DLE1BQU0scUJBQXFCO1lBQ2hEQyxRQUFRO1lBQ1JDLFNBQVM7Z0JBQ1AsZ0JBQWdCO1lBQ2xCO1lBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztnQkFDbkJmLFdBQVdLO2dCQUNYSjtnQkFDQUM7Z0JBQ0FDO2dCQUNBQztZQUNGO1FBQ0Y7UUFFQSxNQUFNWSxTQUFTLE1BQU1QLFNBQVNRLElBQUk7UUFDbEMsT0FBT0Q7SUFDVCxFQUFFLE9BQU9FLE9BQU87UUFDZFosUUFBUVksS0FBSyxDQUFDLGdCQUFxQixPQUFMaEIsTUFBSyxNQUFJZ0I7UUFDdkMsT0FBTztJQUNUO0FBQ0YsRUFBRTtBQUVGOzs7Ozs7O0NBT0MsR0FDTSxNQUFNQyxrQkFBa0IsZUFBT0MsU0FBU25CO1FBQVVFLDBFQUFTLHlCQUF5QkMsZ0ZBQWU7SUFDeEcsSUFBSTtRQUNGLE1BQU1pQixVQUFVLElBQUlDLEtBQUs7WUFBQ0Y7U0FBUSxFQUFFO1lBQUVsQixNQUFNO1FBQVc7UUFDdkQsTUFBTXFCLFNBQVMsSUFBSUM7UUFDbkIsTUFBTUMsYUFBYSxNQUFNLElBQUl0RCxRQUFRLENBQUNDO1lBQ3BDbUQsT0FBT0csU0FBUyxHQUFHLElBQU10RCxRQUFRbUQsT0FBT1AsTUFBTTtZQUM5Q08sT0FBT0ksYUFBYSxDQUFDTjtRQUN2QjtRQUVBLE1BQU1MLFNBQVMsTUFBTWpCLGtCQUFrQjBCLFlBQVl4QixVQUFVLGNBQWNFLFFBQVFDO1FBQ25GLE9BQU9ZO0lBQ1QsRUFBRSxPQUFPRSxPQUFPO1FBQ2RaLFFBQVFZLEtBQUssQ0FBQyxxQkFBcUJBO1FBQ25DLE9BQU87SUFDVDtBQUNGLEVBQUU7QUFFRjs7O0NBR0MsR0FDRCxNQUFNVSxrQ0FBa0M7SUFDdEMsNkRBQTZEO0lBQzdELE1BQU1DLGNBQWM7UUFDbEI7WUFBRXBELE9BQU87Z0JBQUVxRCxPQUFPO1lBQUs7WUFBR3BELFFBQVE7Z0JBQUVvRCxPQUFPO1lBQUs7UUFBRTtRQUNsRDtZQUFFckQsT0FBTztnQkFBRXFELE9BQU87WUFBSztZQUFHcEQsUUFBUTtnQkFBRW9ELE9BQU87WUFBSztRQUFFO1FBQ2xEO1lBQUVyRCxPQUFPO2dCQUFFcUQsT0FBTztZQUFLO1lBQUdwRCxRQUFRO2dCQUFFb0QsT0FBTztZQUFLO1FBQUU7UUFDbEQ7WUFBRXJELE9BQU87Z0JBQUVxRCxPQUFPO1lBQUs7WUFBR3BELFFBQVE7Z0JBQUVvRCxPQUFPO1lBQUs7UUFBRTtRQUNsRDtZQUFFckQsT0FBTztnQkFBRXFELE9BQU87WUFBSztZQUFHcEQsUUFBUTtnQkFBRW9ELE9BQU87WUFBSTtRQUFFO1FBQ2pEO1lBQUVyRCxPQUFPO2dCQUFFcUQsT0FBTztZQUFJO1lBQUdwRCxRQUFRO2dCQUFFb0QsT0FBTztZQUFJO1FBQUU7UUFDaEQsQ0FBQyxFQUFHLCtCQUErQjtLQUNwQztJQUVELCtDQUErQztJQUMvQyxLQUFLLE1BQU1DLGNBQWNGLFlBQWE7UUFDcEMsSUFBSTtZQUNGLE1BQU1HLGNBQWM7Z0JBQ2xCQyxPQUFPO29CQUNMLEdBQUdGLFVBQVU7b0JBQ2JHLFlBQVk7Z0JBQ2Q7WUFDRjtZQUVBLHVDQUF1QztZQUN2QyxNQUFNQyxTQUFTLE1BQU1DLFVBQVVDLFlBQVksQ0FBQ0MsWUFBWSxDQUFDTjtZQUV6RCxtQ0FBbUM7WUFDbkNHLE9BQU9JLFNBQVMsR0FBR0MsT0FBTyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNQyxJQUFJO1lBRTlDcEMsUUFBUUMsR0FBRyxDQUFDLGlDQUFpQ3dCO1lBQzdDLE9BQU9DO1FBQ1QsRUFBRSxPQUFPMUMsS0FBSztZQUNaZ0IsUUFBUUMsR0FBRyxDQUFDLDZCQUF3RCxPQUEzQk8sS0FBS0MsU0FBUyxDQUFDZ0I7UUFDeEQsOEJBQThCO1FBQ2hDO0lBQ0Y7SUFFQSw4Q0FBOEM7SUFDOUMsT0FBTztRQUFFRSxPQUFPO0lBQUs7QUFDdkI7QUFFQTs7OztDQUlDLEdBQ00sTUFBTVUsdUJBQXVCO1FBQU8sRUFBRUMsS0FBSyxFQUFFQyxlQUFlLENBQUMsRUFBRUMsU0FBUyxFQUFFQyxlQUFlLEVBQUVDLGtCQUFrQixFQUFFO0lBQ3BILElBQUk7UUFDRixNQUFNN0MsU0FBUztRQUVmLDRDQUE0QztRQUM1QyxNQUFNOEMsaUJBQWlCLFdBQXNCLE9BQVhDLEtBQUtDLEdBQUc7UUFDMUM3QyxRQUFRQyxHQUFHLENBQUMsK0JBQThDLE9BQWYwQztRQUUzQywyQkFBMkI7UUFDM0IsTUFBTUcsaUJBQWlCLGtCQUFtQiwyQ0FBMkM7UUFDckYsTUFBTUMsaUJBQWlCLGtCQUFtQiwyQ0FBMkM7UUFDckYsTUFBTUMsb0JBQW9CLHFCQUFzQiwyQ0FBMkM7UUFFM0YsY0FBYztRQUNkaEQsUUFBUUMsR0FBRyxDQUFDLG1DQUFtQzBDO1FBRS9DLE1BQU1wRSxTQUFTaUUsVUFBVVMsT0FBTztRQUNoQyxJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLGNBQWM7UUFDbEIsSUFBSUMsZ0JBQWdCO1FBRXBCLHVDQUF1QztRQUN2QyxJQUFJQyxjQUFjO1FBQ2xCLElBQUlDLGVBQWU7UUFFbkIsNEJBQTRCO1FBRTVCLDBCQUEwQjtRQUMxQixJQUFJL0UsUUFBUTtZQUNWMkUsY0FBYzNFLE9BQU9PLFNBQVMsQ0FBQztRQUNqQztRQUVBLGlFQUFpRTtRQUNqRSxJQUFJeUUscUJBQXFCLE1BQU0sZ0RBQWdEO1FBQy9FLE1BQU1DLGVBQWVDLE9BQU9ELFlBQVksSUFBSWhGLFNBQVNrRixhQUFhLENBQUM7UUFDbkUsSUFBSUYsY0FBYztZQUNoQiwwQ0FBMEM7WUFDMUNILGNBQWNHLGFBQWFHLFVBQVUsSUFBSTtZQUN6Q0wsZUFBZUUsYUFBYUksV0FBVyxJQUFJO1lBRTNDLE1BQU1DLGFBQWFyRixTQUFTQyxhQUFhLENBQUM7WUFDMUNvRixXQUFXMUYsS0FBSyxHQUFHa0Y7WUFDbkJRLFdBQVd6RixNQUFNLEdBQUdrRjtZQUNwQk8sV0FBV2xGLFVBQVUsQ0FBQyxNQUFNQyxTQUFTLENBQUM0RSxjQUFjLEdBQUc7WUFFdkQsNENBQTRDO1lBQzVDTCxjQUFjVSxXQUFXL0UsU0FBUyxDQUFDLGNBQWM7WUFFakQsOENBQThDO1lBQzlDeUUscUJBQXFCLE1BQU0vRixZQUFZMkYsYUFBYSxLQUFLLEtBQUs7WUFFOURuRCxRQUFRQyxHQUFHLENBQUMsK0JBQThDcUQsT0FBZkQsYUFBWSxLQUFnQixPQUFiQztRQUM1RCxPQUFPO1lBQ0wsSUFBSTtnQkFDRixxREFBcUQ7Z0JBQ3JELE1BQU01QixjQUFjLE1BQU1KO2dCQUMxQnRCLFFBQVFDLEdBQUcsQ0FBQyw2QkFBNkJ5QjtnQkFFekMsNENBQTRDO2dCQUM1QyxNQUFNRyxTQUFTLE1BQU1DLFVBQVVDLFlBQVksQ0FBQ0MsWUFBWSxDQUFDTjtnQkFFekQsbURBQW1EO2dCQUNuRCxNQUFNb0MsWUFBWXRGLFNBQVNDLGFBQWEsQ0FBQztnQkFDekNxRixVQUFVQyxTQUFTLEdBQUdsQztnQkFDdEJpQyxVQUFVRSxLQUFLLEdBQUc7Z0JBQ2xCRixVQUFVRyxXQUFXLEdBQUc7Z0JBQ3hCSCxVQUFVSSxRQUFRLEdBQUc7Z0JBQ3JCMUYsU0FBUytCLElBQUksQ0FBQzRELFdBQVcsQ0FBQ0w7Z0JBRTFCLDJDQUEyQztnQkFDM0MsTUFBTSxJQUFJakcsUUFBUUMsQ0FBQUE7b0JBQ2hCZ0csVUFBVU0sZ0JBQWdCLEdBQUc7d0JBQzNCTixVQUFVTyxJQUFJO3dCQUNkdkc7b0JBQ0Y7b0JBQ0EsNENBQTRDO29CQUM1Q3dHLFdBQVd4RyxTQUFTO2dCQUN0QjtnQkFFQSw0REFBNEQ7Z0JBQzVELE1BQU0sSUFBSUQsUUFBUTBHLENBQUFBLE1BQU9ELFdBQVdDLEtBQUs7Z0JBRXpDLDBCQUEwQjtnQkFDMUJsQixjQUFjUyxVQUFVSCxVQUFVLElBQUk7Z0JBQ3RDTCxlQUFlUSxVQUFVRixXQUFXLElBQUk7Z0JBRXhDLElBQUlQLGNBQWMsS0FBS0MsZUFBZSxHQUFHO29CQUN2QyxNQUFNTyxhQUFhckYsU0FBU0MsYUFBYSxDQUFDO29CQUMxQ29GLFdBQVcxRixLQUFLLEdBQUdrRjtvQkFDbkJRLFdBQVd6RixNQUFNLEdBQUdrRjtvQkFDcEJPLFdBQVdsRixVQUFVLENBQUMsTUFBTUMsU0FBUyxDQUFDa0YsV0FBVyxHQUFHO29CQUVwRCw0Q0FBNEM7b0JBQzVDWCxjQUFjVSxXQUFXL0UsU0FBUyxDQUFDLGNBQWM7b0JBRWpELDhDQUE4QztvQkFDOUN5RSxxQkFBcUIsTUFBTS9GLFlBQVkyRixhQUFhLEtBQUssS0FBSztvQkFFOURuRCxRQUFRQyxHQUFHLENBQUMsbUNBQWtEcUQsT0FBZkQsYUFBWSxLQUFnQixPQUFiQztnQkFDaEUsT0FBTztvQkFDTHRELFFBQVF3RSxJQUFJLENBQUM7b0JBQ2IsTUFBTXJDLFFBQVFOLE9BQU80QyxjQUFjLEVBQUUsQ0FBQyxFQUFFO29CQUN4QyxNQUFNQyxXQUFXdkMsTUFBTXdDLFdBQVc7b0JBQ2xDdEIsY0FBY3FCLFNBQVN2RyxLQUFLLElBQUk7b0JBQ2hDbUYsZUFBZW9CLFNBQVN0RyxNQUFNLElBQUk7b0JBRWxDLE1BQU15RixhQUFhckYsU0FBU0MsYUFBYSxDQUFDO29CQUMxQ29GLFdBQVcxRixLQUFLLEdBQUdrRixlQUFlO29CQUNsQ1EsV0FBV3pGLE1BQU0sR0FBR2tGLGdCQUFnQjtvQkFDcENPLFdBQVdsRixVQUFVLENBQUMsTUFBTUMsU0FBUyxDQUFDa0YsV0FBVyxHQUFHO29CQUVwRCw0Q0FBNEM7b0JBQzVDWCxjQUFjVSxXQUFXL0UsU0FBUyxDQUFDLGNBQWM7b0JBRWpELDhDQUE4QztvQkFDOUN5RSxxQkFBcUIsTUFBTS9GLFlBQVkyRixhQUFhLEtBQUssS0FBSztvQkFFOURuRCxRQUFRQyxHQUFHLENBQUMsK0JBQThDcUQsT0FBZkQsYUFBWSxLQUFnQixPQUFiQztnQkFDNUQ7Z0JBRUEsV0FBVztnQkFDWHpCLE9BQU9JLFNBQVMsR0FBR0MsT0FBTyxDQUFDMEMsQ0FBQUEsSUFBS0EsRUFBRXhDLElBQUk7Z0JBQ3RDMEIsVUFBVWUsTUFBTTtZQUNsQixFQUFFLE9BQU83RixLQUFLO2dCQUNaZ0IsUUFBUXdFLElBQUksQ0FBQywwQ0FBMEN4RjtnQkFFdkQsMkNBQTJDO2dCQUMzQyxJQUFJO29CQUNGLE1BQU02QyxTQUFTLE1BQU1DLFVBQVVDLFlBQVksQ0FBQ0MsWUFBWSxDQUFDO3dCQUFFTCxPQUFPO29CQUFLO29CQUN2RSxNQUFNbUMsWUFBWXRGLFNBQVNDLGFBQWEsQ0FBQztvQkFDekNxRixVQUFVQyxTQUFTLEdBQUdsQztvQkFDdEJpQyxVQUFVRSxLQUFLLEdBQUc7b0JBQ2xCRixVQUFVRyxXQUFXLEdBQUc7b0JBQ3hCekYsU0FBUytCLElBQUksQ0FBQzRELFdBQVcsQ0FBQ0w7b0JBQzFCLE1BQU1BLFVBQVVPLElBQUk7b0JBQ3BCLE1BQU0sSUFBSXhHLFFBQVEwRyxDQUFBQSxNQUFPRCxXQUFXQyxLQUFLO29CQUV6Q2xCLGNBQWNTLFVBQVVILFVBQVUsSUFBSTtvQkFDdENMLGVBQWVRLFVBQVVGLFdBQVcsSUFBSTtvQkFFeEMsTUFBTUMsYUFBYXJGLFNBQVNDLGFBQWEsQ0FBQztvQkFDMUNvRixXQUFXMUYsS0FBSyxHQUFHa0Y7b0JBQ25CUSxXQUFXekYsTUFBTSxHQUFHa0Y7b0JBQ3BCTyxXQUFXbEYsVUFBVSxDQUFDLE1BQU1DLFNBQVMsQ0FBQ2tGLFdBQVcsR0FBRztvQkFFcEQsNENBQTRDO29CQUM1Q1gsY0FBY1UsV0FBVy9FLFNBQVMsQ0FBQyxjQUFjO29CQUVqRCw4Q0FBOEM7b0JBQzlDeUUscUJBQXFCLE1BQU0vRixZQUFZMkYsYUFBYSxLQUFLLEtBQUs7b0JBRTlEbkQsUUFBUUMsR0FBRyxDQUFDLDRCQUEyQ3FELE9BQWZELGFBQVksS0FBZ0IsT0FBYkM7b0JBRXZEekIsT0FBT0ksU0FBUyxHQUFHQyxPQUFPLENBQUMwQyxDQUFBQSxJQUFLQSxFQUFFeEMsSUFBSTtvQkFDdEMwQixVQUFVZSxNQUFNO2dCQUNsQixFQUFFLE9BQU9DLGFBQWE7b0JBQ3BCOUUsUUFBUVksS0FBSyxDQUFDLHNDQUFzQ2tFO2dCQUN0RDtZQUNGO1FBQ0Y7UUFFQSx1REFBdUQ7UUFDdkQsTUFBTWhFLFVBQVU7WUFDZDtZQUNDLFNBQWdCLE9BQVJ3QixNQUFNeUMsQ0FBQztZQUNmLFNBQWdCLE9BQVJ6QyxNQUFNMEMsQ0FBQztZQUNmLGdCQUFrQyxPQUFuQnpHLENBQUFBLG1CQUFBQSw2QkFBQUEsT0FBUUosS0FBSyxLQUFJO1lBQ2hDLGlCQUFvQyxPQUFwQkksQ0FBQUEsbUJBQUFBLDZCQUFBQSxPQUFRSCxNQUFNLEtBQUk7WUFDbEMsZ0JBQWlDLE9BQWxCcUYsT0FBT3dCLFVBQVU7WUFDaEMsaUJBQW1DLE9BQW5CeEIsT0FBT3lCLFdBQVc7WUFDbEMsMkJBQXNDLE9BQVo3QjtZQUMxQiw0QkFBd0MsT0FBYkM7WUFDM0IsYUFBcUMsT0FBekIsSUFBSVYsT0FBT3VDLFdBQVc7WUFDbEMsWUFBMEIsT0FBZnhDO1NBQ2IsQ0FBQ3lDLElBQUksQ0FBQztRQUVQLHVFQUF1RTtRQUV2RSwwQkFBMEI7UUFDMUIsTUFBTUMsY0FBYyxNQUFNeEUsZ0JBQWdCQyxTQUFTa0MsbUJBQW1CbkQsUUFBUThDO1FBRTlFLElBQUkwQyxlQUFlQSxZQUFZQyxPQUFPLEVBQUU7WUFDdENsQyxnQkFBZ0JpQyxZQUFZRSxNQUFNO1lBQ2xDdkYsUUFBUUMsR0FBRyxDQUFDLG1DQUErRDBDLE9BQTVCUyxlQUFjLGdCQUE2QixPQUFmVDtRQUM3RTtRQUVBLHFDQUFxQztRQUNyQyxJQUFJNkMsZUFBZTtRQUNuQixJQUFJdEMsYUFBYTtZQUNmc0MsZUFBZSxNQUFNL0Ysa0JBQWtCeUQsYUFBYUosZ0JBQWdCLFVBQVVqRCxRQUFROEM7UUFDeEY7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSThDLGVBQWU7UUFDbkIsSUFBSXRDLGFBQWE7WUFDZnNDLGVBQWUsTUFBTWhHLGtCQUFrQjBELGFBQWFKLGdCQUFnQixVQUFVbEQsUUFBUThDO1FBQ3hGO1FBRUEsMkVBQTJFO1FBQzNFLElBQUlELHNCQUFzQixPQUFPQSx1QkFBdUIsWUFBWTtZQUNsRUEsbUJBQW1CUSxhQUFhSyxzQkFBc0JKLGFBQWFiO1FBQ3JFO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUlHLG1CQUFtQixPQUFPQSxvQkFBb0IsWUFBWTtZQUM1REEsZ0JBQWdCaUQsQ0FBQUEsWUFBYUEsWUFBWTtRQUMzQztRQUVBLHNEQUFzRDtRQUN0RCxPQUFPO1lBQ0x4QztZQUNBQztZQUNBbUMsU0FBUztZQUNUaEQ7WUFDQWM7WUFDQXVDLFNBQVNoRDtZQUNUVTtZQUNBQztRQUNGO0lBQ0YsRUFBRSxPQUFPdEUsS0FBSztRQUNaZ0IsUUFBUVksS0FBSyxDQUFDLGdDQUFnQzVCO1FBQzlDLE9BQU87WUFDTHNHLFNBQVM7WUFDVDFFLE9BQU81QixJQUFJNEcsT0FBTztZQUNsQjFDLGFBQWE7WUFDYkMsYUFBYTtZQUNiRSxhQUFhO1lBQ2JDLGNBQWM7UUFDaEI7SUFDRjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9IZWxwZXIvc2F2ZWZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSGVscGVyL3NhdmVmaWxlLmpzIC0gQWRkZWQgaGlnaGVzdCByZXNvbHV0aW9uIHdlYmNhbSBjYXB0dXJlXG5cbi8qKlxuICogUmVzaXplIGFuIGltYWdlIHRvIGZpdCB3aXRoaW4gYSBjZXJ0YWluIHNpemUgbGltaXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGFVcmwgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGggLSBNYXhpbXVtIHdpZHRoIG9mIHRoZSByZXNpemVkIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gTWF4aW11bSBoZWlnaHQgb2YgdGhlIHJlc2l6ZWQgaW1hZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBxdWFsaXR5IC0gSlBFRyBxdWFsaXR5ICgwLTEpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIFJlc2l6ZWQgaW1hZ2UgZGF0YSBVUkxcbiAqL1xuY29uc3QgcmVzaXplSW1hZ2UgPSBhc3luYyAoaW1hZ2VEYXRhVXJsLCBtYXhXaWR0aCA9IDgwMCwgbWF4SGVpZ2h0ID0gNjAwLCBxdWFsaXR5ID0gMC44NSkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBuZXcgZGltZW5zaW9ucyB3aGlsZSBtYWludGFpbmluZyBhc3BlY3QgcmF0aW9cbiAgICAgICAgbGV0IHdpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIGlmICh3aWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQgKiAobWF4V2lkdGggLyB3aWR0aCkpO1xuICAgICAgICAgIHdpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChoZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGggKiAobWF4SGVpZ2h0IC8gaGVpZ2h0KSk7XG4gICAgICAgICAgaGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgY2FudmFzIGZvciByZXNpemluZ1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IGFuZCByZXNpemUgaW1hZ2Ugb24gY2FudmFzXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIEpQRUcgd2l0aCBzcGVjaWZpZWQgcXVhbGl0eVxuICAgICAgICBjb25zdCByZXNpemVkRGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCBxdWFsaXR5KTtcbiAgICAgICAgcmVzb2x2ZShyZXNpemVkRGF0YVVybCk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICBpbWcub25lcnJvciA9IChlcnIpID0+IHJlamVjdChlcnIpO1xuICAgICAgaW1nLnNyYyA9IGltYWdlRGF0YVVybDtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFuIGltYWdlIGlzIHRvbyBsYXJnZSBmb3IgdGhlIHNlcnZlciBBUElcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGFVcmwgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4U2l6ZUJ5dGVzIC0gTWF4aW11bSBzaXplIGluIGJ5dGVzIChkZWZhdWx0IDkwMEtCKVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBpbWFnZSBpcyB0b28gbGFyZ2VcbiAqL1xuY29uc3QgaXNJbWFnZVRvb0xhcmdlID0gKGltYWdlRGF0YVVybCwgbWF4U2l6ZUJ5dGVzID0gOTAwICogMTAyNCkgPT4ge1xuICAvLyBCYXNlNjQgZGF0YSBVUkxzIGhhdmUgYSA0OjMgcmF0aW8gdG8gYWN0dWFsIGJ5dGVzXG4gIC8vIFdlIHN1YnRyYWN0IHRoZSBkYXRhIFVSTCBwcmVmaXggbGVuZ3RoXG4gIGNvbnN0IHByZWZpeCA9ICdkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCc7XG4gIGNvbnN0IGJhc2U2NExlbmd0aCA9IGltYWdlRGF0YVVybC5sZW5ndGggLSAoaW1hZ2VEYXRhVXJsLnN0YXJ0c1dpdGgocHJlZml4KSA/IHByZWZpeC5sZW5ndGggOiAwKTtcbiAgY29uc3QgYXBwcm94aW1hdGVCeXRlcyA9IChiYXNlNjRMZW5ndGggKiAzKSAvIDQ7XG4gIFxuICByZXR1cm4gYXBwcm94aW1hdGVCeXRlcyA+IG1heFNpemVCeXRlcztcbn07XG5cbi8qKlxuICogU2F2ZSBhbiBpbWFnZSBvciBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2l0aCBncm91cCBJRCB0byBlbnN1cmUgY29uc2lzdGVudCBudW1iZXJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGEgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBGaWxlbmFtZSBwYXR0ZXJuIHRvIHNhdmUgYXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBmaWxlIChzY3JlZW4sIHdlYmNhbSwgcGFyYW1ldGVycylcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBpblxuICogQHBhcmFtIHtzdHJpbmd9IGNhcHR1cmVHcm91cCAtIFVuaXF1ZSBJRCBmb3IgZ3JvdXBpbmcgZmlsZXMgZnJvbSB0aGUgc2FtZSBjYXB0dXJlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFNlcnZlciByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3Qgc2F2ZUltYWdlVG9TZXJ2ZXIgPSBhc3luYyAoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgdHlwZSwgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsIGNhcHR1cmVHcm91cCA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBDaGVjayBpbWFnZSBzaXplIGFuZCByZXNpemUgaWYgbmVjZXNzYXJ5IGZvciBub24tcGFyYW1ldGVyIGZpbGVzXG4gICAgbGV0IHByb2Nlc3NlZEltYWdlRGF0YSA9IGltYWdlRGF0YTtcbiAgICBcbiAgICBpZiAodHlwZSAhPT0gJ3BhcmFtZXRlcnMnICYmIGlzSW1hZ2VUb29MYXJnZShpbWFnZURhdGEpKSB7XG4gICAgICBjb25zb2xlLmxvZyhgSW1hZ2UgdG9vIGxhcmdlIGZvciAke3R5cGV9LCByZXNpemluZyBiZWZvcmUgc2VuZGluZyB0byBzZXJ2ZXJgKTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgd2l0aCBoaWdoZXIgcXVhbGl0eSBhbmQgcHJvZ3Jlc3NpdmVseSByZWR1Y2UgcXVhbGl0eS9zaXplIHVudGlsIGl0J3Mgc21hbGwgZW5vdWdoXG4gICAgICBjb25zdCBzaXplcyA9IFtcbiAgICAgICAgeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwLCBxdWFsaXR5OiAwLjkgfSxcbiAgICAgICAgeyB3aWR0aDogMTI4MCwgaGVpZ2h0OiA3MjAsIHF1YWxpdHk6IDAuODUgfSxcbiAgICAgICAgeyB3aWR0aDogODAwLCBoZWlnaHQ6IDYwMCwgcXVhbGl0eTogMC44IH0sXG4gICAgICAgIHsgd2lkdGg6IDY0MCwgaGVpZ2h0OiA0ODAsIHF1YWxpdHk6IDAuNzUgfVxuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkgfSBvZiBzaXplcykge1xuICAgICAgICBwcm9jZXNzZWRJbWFnZURhdGEgPSBhd2FpdCByZXNpemVJbWFnZShpbWFnZURhdGEsIHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFpc0ltYWdlVG9vTGFyZ2UocHJvY2Vzc2VkSW1hZ2VEYXRhKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmVzaXplZCAke3R5cGV9IHRvICR7d2lkdGh9eCR7aGVpZ2h0fSBhdCBxdWFsaXR5ICR7cXVhbGl0eX1gKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgaW1hZ2VEYXRhOiBwcm9jZXNzZWRJbWFnZURhdGEsIFxuICAgICAgICBmaWxlbmFtZSwgXG4gICAgICAgIHR5cGUsIFxuICAgICAgICBmb2xkZXIsXG4gICAgICAgIGNhcHR1cmVHcm91cCAvLyBJbmNsdWRlIHRoZSBjYXB0dXJlIGdyb3VwIElEXG4gICAgICB9KVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyAke3R5cGV9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBTYXZlIENTViBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3ZEYXRhIC0gQ1NWIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIEZpbGVuYW1lIHBhdHRlcm4gdG8gc2F2ZSBhc1xuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIEZvbGRlciB0byBzYXZlIGluXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FwdHVyZUdyb3VwIC0gVW5pcXVlIElEIGZvciBncm91cGluZyBmaWxlcyBmcm9tIHRoZSBzYW1lIGNhcHR1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gU2VydmVyIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBzYXZlQ1NWVG9TZXJ2ZXIgPSBhc3luYyAoY3N2RGF0YSwgZmlsZW5hbWUsIGZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLCBjYXB0dXJlR3JvdXAgPSBudWxsKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoY3N2RGF0YVVybCwgZmlsZW5hbWUsICdwYXJhbWV0ZXJzJywgZm9sZGVyLCBjYXB0dXJlR3JvdXApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIENTVjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBoaWdoZXN0IHJlc29sdXRpb24gY2FtZXJhIGNvbnN0cmFpbnRzIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPn0gLSBDYW1lcmEgY29uc3RyYWludHMgd2l0aCBoaWdoZXN0IHJlc29sdXRpb25cbiAqL1xuY29uc3QgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cyA9IGFzeW5jICgpID0+IHtcbiAgLy8gRGVmaW5lIHBvc3NpYmxlIHJlc29sdXRpb25zIGluIGRlc2NlbmRpbmcgb3JkZXIgb2YgcXVhbGl0eVxuICBjb25zdCByZXNvbHV0aW9ucyA9IFtcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiA0MDk2IH0sIGhlaWdodDogeyBpZGVhbDogMjE2MCB9IH0sIC8vIDRLXG4gICAgeyB3aWR0aDogeyBpZGVhbDogMzg0MCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDIxNjAgfSB9LCAvLyA0SyBVSERcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiAyNTYwIH0sIGhlaWdodDogeyBpZGVhbDogMTQ0MCB9IH0sIC8vIDJLIFFIRFxuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDE5MjAgfSwgaGVpZ2h0OiB7IGlkZWFsOiAxMDgwIH0gfSwgLy8gRnVsbCBIRFxuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDEyODAgfSwgaGVpZ2h0OiB7IGlkZWFsOiA3MjAgfSB9LCAgLy8gSERcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiA2NDAgfSwgaGVpZ2h0OiB7IGlkZWFsOiA0ODAgfSB9LCAgIC8vIFZHQVxuICAgIHt9ICAvLyBEZWZhdWx0IC0gbGV0IGJyb3dzZXIgZGVjaWRlXG4gIF07XG5cbiAgLy8gVHJ5IHRoZSByZXNvbHV0aW9ucyBpbiBvcmRlciB1bnRpbCBvbmUgd29ya3NcbiAgZm9yIChjb25zdCByZXNvbHV0aW9uIG9mIHJlc29sdXRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIC4uLnJlc29sdXRpb24sXG4gICAgICAgICAgZmFjaW5nTW9kZTogXCJ1c2VyXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCBpZiB0aGlzIHJlc29sdXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBcbiAgICAgIC8vIFN0b3AgdGhlIHRlc3Qgc3RyZWFtIGltbWVkaWF0ZWx5XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkhpZ2hlc3Qgc3VwcG9ydGVkIHJlc29sdXRpb246XCIsIHJlc29sdXRpb24pO1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coYFJlc29sdXRpb24gbm90IHN1cHBvcnRlZDogJHtKU09OLnN0cmluZ2lmeShyZXNvbHV0aW9uKX1gKTtcbiAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQgcmVzb2x1dGlvblxuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgbm90aGluZyB3b3JrZWQsIHJldHVybiBiYXNpYyBjb25zdHJhaW50c1xuICByZXR1cm4geyB2aWRlbzogdHJ1ZSB9O1xufTtcblxuLyoqXG4gKiBDYXB0dXJlIGFuZCBzYXZlIGltYWdlcyBhdCBhIHNwZWNpZmljIHBvaW50IHdpdGggY29uc2lzdGVudCBudW1iZXJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENhcHR1cmUgcmVzdWx0c1xuICovXG5leHBvcnQgY29uc3QgY2FwdHVyZUltYWdlc0F0UG9pbnQgPSBhc3luYyAoeyBwb2ludCwgY2FwdHVyZUNvdW50ID0gMSwgY2FudmFzUmVmLCBzZXRDYXB0dXJlQ291bnQsIHNob3dDYXB0dXJlUHJldmlldyB9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcyc7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIGNhcHR1cmUgZ3JvdXBcbiAgICBjb25zdCBjYXB0dXJlR3JvdXBJZCA9IGBjYXB0dXJlLSR7RGF0ZS5ub3coKX1gO1xuICAgIGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgY2FwdHVyZSBncm91cCBJRDogJHtjYXB0dXJlR3JvdXBJZH1gKTtcbiAgICBcbiAgICAvLyBGaWxlIHBhdHRlcm5zIGZvciBzYXZpbmdcbiAgICBjb25zdCBzY3JlZW5GaWxlbmFtZSA9ICdzY3JlZW5fMDAxLmpwZyc7ICAvLyBQYXR0ZXJuIG9ubHkgLSBzZXJ2ZXIgd2lsbCBhc3NpZ24gbnVtYmVyXG4gICAgY29uc3Qgd2ViY2FtRmlsZW5hbWUgPSAnd2ViY2FtXzAwMS5qcGcnOyAgLy8gUGF0dGVybiBvbmx5IC0gc2VydmVyIHdpbGwgYXNzaWduIG51bWJlclxuICAgIGNvbnN0IHBhcmFtZXRlckZpbGVuYW1lID0gJ3BhcmFtZXRlcl8wMDEuY3N2JzsgIC8vIFBhdHRlcm4gb25seSAtIHNlcnZlciB3aWxsIGFzc2lnbiBudW1iZXJcbiAgICBcbiAgICAvLyBGb3IgbG9nZ2luZ1xuICAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgY2FwdHVyZSB3aXRoIGdyb3VwIElEOlwiLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgbGV0IHNjcmVlbkltYWdlID0gbnVsbDtcbiAgICBsZXQgd2ViY2FtSW1hZ2UgPSBudWxsO1xuICAgIGxldCBjYXB0dXJlTnVtYmVyID0gbnVsbDtcbiAgICBcbiAgICAvLyBWYXJpYWJsZXMgdG8gc3RvcmUgd2ViY2FtIHJlc29sdXRpb25cbiAgICBsZXQgd2ViY2FtV2lkdGggPSAwO1xuICAgIGxldCB3ZWJjYW1IZWlnaHQgPSAwO1xuICAgIFxuICAgIC8vIDEuIFByZXBhcmUgYWxsIGRhdGEgZmlyc3RcbiAgICBcbiAgICAvLyAxLjEgQ2FudmFzL3NjcmVlbiBpbWFnZVxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHNjcmVlbkltYWdlID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgfVxuXG4gICAgLy8gMS4yIFdlYmNhbSBpbWFnZSAtIFRyeSB0byBnZXQgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvbiBhdmFpbGFibGVcbiAgICBsZXQgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gbnVsbDsgLy8gU2VwYXJhdGUgbG93ZXItcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgY29uc3QgdmlkZW9FbGVtZW50ID0gd2luZG93LnZpZGVvRWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgIGlmICh2aWRlb0VsZW1lbnQpIHtcbiAgICAgIC8vIFVzZSBleGlzdGluZyB2aWRlbyBlbGVtZW50IGlmIGF2YWlsYWJsZVxuICAgICAgd2ViY2FtV2lkdGggPSB2aWRlb0VsZW1lbnQudmlkZW9XaWR0aCB8fCAwO1xuICAgICAgd2ViY2FtSGVpZ2h0ID0gdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICBcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3ZWJjYW1XaWR0aDtcbiAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gd2ViY2FtSGVpZ2h0O1xuICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh2aWRlb0VsZW1lbnQsIDAsIDApO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgaGlnaC1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHNhdmluZ1xuICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOTUpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgbG93ZXItcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgICB3ZWJjYW1JbWFnZVByZXZpZXcgPSBhd2FpdCByZXNpemVJbWFnZSh3ZWJjYW1JbWFnZSwgNjQwLCA0ODAsIDAuODUpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgRXhpc3Rpbmcgd2ViY2FtIHJlc29sdXRpb246ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBHZXQgaGlnaGVzdCByZXNvbHV0aW9uIGNvbnN0cmFpbnRzIGZvciB0aGlzIGRldmljZVxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IGdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBjYW1lcmEgY29uc3RyYWludHM6XCIsIGNvbnN0cmFpbnRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBnZXQgc3RyZWFtIHdpdGggaGlnaGVzdCByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSB0ZW1wb3JhcnkgdmlkZW8gZWxlbWVudCB0byBnZXQgdGhlIHN0cmVhbVxuICAgICAgICBjb25zdCB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICB0ZW1wVmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICB0ZW1wVmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgIFxuICAgICAgICAvLyBOZWVkIHRvIHdhaXQgZm9yIHZpZGVvIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHRlbXBWaWRlby5vbmxvYWRlZG1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgdGVtcFZpZGVvLnBsYXkoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIEZhbGxiYWNrIGlmIG9ubG9hZGVkbWV0YWRhdGEgZG9lc24ndCBmaXJlXG4gICAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGEgYml0IGxvbmdlciBmb3IgdGhlIHZpZGVvIHRvIGFjdHVhbGx5IHN0YXJ0IHBsYXlpbmdcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCA1MDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIHdlYmNhbSByZXNvbHV0aW9uXG4gICAgICAgIHdlYmNhbVdpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgMDtcbiAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgIFxuICAgICAgICBpZiAod2ViY2FtV2lkdGggPiAwICYmIHdlYmNhbUhlaWdodCA+IDApIHtcbiAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdlYmNhbVdpZHRoO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gd2ViY2FtSGVpZ2h0O1xuICAgICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgaGlnaC1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHNhdmluZ1xuICAgICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgbG93ZXItcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgICAgICAgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gYXdhaXQgcmVzaXplSW1hZ2Uod2ViY2FtSW1hZ2UsIDY0MCwgNDgwLCAwLjg1KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgSGlnaC1yZXNvbHV0aW9uIHdlYmNhbSBjYXB0dXJlOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbmFibGUgdG8gZGV0ZXJtaW5lIHZpZGVvIGRpbWVuc2lvbnMsIHVzaW5nIGZhbGxiYWNrIG1ldGhvZFwiKTtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHNldHRpbmdzLndpZHRoIHx8IDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gc2V0dGluZ3MuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3ZWJjYW1XaWR0aCB8fCA2NDA7XG4gICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQgfHwgNDgwO1xuICAgICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgaGlnaC1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHNhdmluZ1xuICAgICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgbG93ZXItcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgICAgICAgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gYXdhaXQgcmVzaXplSW1hZ2Uod2ViY2FtSW1hZ2UsIDY0MCwgNDgwLCAwLjg1KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRmFsbGJhY2sgd2ViY2FtIHJlc29sdXRpb246ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkhpZ2gtcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZSBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgb25lIG1vcmUgdGltZSB3aXRoIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgICBhd2FpdCB0ZW1wVmlkZW8ucGxheSgpO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMzAwKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgd2ViY2FtV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCAwO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCAwO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2ViY2FtV2lkdGg7XG4gICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGxvd2VyLXJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgICAgICAgIHdlYmNhbUltYWdlUHJldmlldyA9IGF3YWl0IHJlc2l6ZUltYWdlKHdlYmNhbUltYWdlLCA2NDAsIDQ4MCwgMC44KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQmFzaWMgd2ViY2FtIHJlc29sdXRpb246ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpO1xuICAgICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQWxsIHdlYmNhbSBjYXB0dXJlIG1ldGhvZHMgZmFpbGVkOlwiLCBmYWxsYmFja0Vycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxLjMgUGFyYW1ldGVyIGRhdGEgLSBOb3cgaW5jbHVkaW5nIHdlYmNhbSByZXNvbHV0aW9uXG4gICAgY29uc3QgY3N2RGF0YSA9IFtcbiAgICAgIFwibmFtZSx2YWx1ZVwiLFxuICAgICAgYGRvdF94LCR7cG9pbnQueH1gLFxuICAgICAgYGRvdF95LCR7cG9pbnQueX1gLFxuICAgICAgYGNhbnZhc193aWR0aCwke2NhbnZhcz8ud2lkdGggfHwgMH1gLFxuICAgICAgYGNhbnZhc19oZWlnaHQsJHtjYW52YXM/LmhlaWdodCB8fCAwfWAsXG4gICAgICBgd2luZG93X3dpZHRoLCR7d2luZG93LmlubmVyV2lkdGh9YCxcbiAgICAgIGB3aW5kb3dfaGVpZ2h0LCR7d2luZG93LmlubmVySGVpZ2h0fWAsXG4gICAgICBgd2ViY2FtX3Jlc29sdXRpb25fd2lkdGgsJHt3ZWJjYW1XaWR0aH1gLFxuICAgICAgYHdlYmNhbV9yZXNvbHV0aW9uX2hlaWdodCwke3dlYmNhbUhlaWdodH1gLFxuICAgICAgYHRpbWVzdGFtcCwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgYGdyb3VwX2lkLCR7Y2FwdHVyZUdyb3VwSWR9YFxuICAgIF0uam9pbignXFxuJyk7XG4gICAgXG4gICAgLy8gMi4gU2F2ZSBhbGwgZmlsZXMgd2l0aCB0aGUgc2FtZSBncm91cCBJRCBzbyB0aGV5IGdldCB0aGUgc2FtZSBudW1iZXJcbiAgICBcbiAgICAvLyAyLjEgU2F2ZSBwYXJhbWV0ZXIgZmlsZVxuICAgIGNvbnN0IHBhcmFtUmVzdWx0ID0gYXdhaXQgc2F2ZUNTVlRvU2VydmVyKGNzdkRhdGEsIHBhcmFtZXRlckZpbGVuYW1lLCBmb2xkZXIsIGNhcHR1cmVHcm91cElkKTtcbiAgICBcbiAgICBpZiAocGFyYW1SZXN1bHQgJiYgcGFyYW1SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgY2FwdHVyZU51bWJlciA9IHBhcmFtUmVzdWx0Lm51bWJlcjtcbiAgICAgIGNvbnNvbGUubG9nKGBTZXJ2ZXIgYXNzaWduZWQgY2FwdHVyZSBudW1iZXI6ICR7Y2FwdHVyZU51bWJlcn0gZm9yIGdyb3VwOiAke2NhcHR1cmVHcm91cElkfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyAyLjIgU2F2ZSBzY3JlZW4gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gICAgbGV0IHNjcmVlblJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBzY3JlZW5SZXN1bHQgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcihzY3JlZW5JbWFnZSwgc2NyZWVuRmlsZW5hbWUsICdzY3JlZW4nLCBmb2xkZXIsIGNhcHR1cmVHcm91cElkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gMi4zIFNhdmUgd2ViY2FtIGltYWdlIGlmIGF2YWlsYWJsZVxuICAgIGxldCB3ZWJjYW1SZXN1bHQgPSBudWxsO1xuICAgIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgICAgd2ViY2FtUmVzdWx0ID0gYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIod2ViY2FtSW1hZ2UsIHdlYmNhbUZpbGVuYW1lLCAnd2ViY2FtJywgZm9sZGVyLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDMuIFNob3cgcHJldmlldyBpZiBuZWVkZWQgLSB1c2UgdGhlIGxvd2VyIHJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgIGlmIChzaG93Q2FwdHVyZVByZXZpZXcgJiYgdHlwZW9mIHNob3dDYXB0dXJlUHJldmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3KHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZVByZXZpZXcgfHwgd2ViY2FtSW1hZ2UsIHBvaW50KTtcbiAgICB9XG4gICAgXG4gICAgLy8gNC4gSW5jcmVtZW50IGNvdW50ZXIgZm9yIG5leHQgY2FwdHVyZVxuICAgIGlmIChzZXRDYXB0dXJlQ291bnQgJiYgdHlwZW9mIHNldENhcHR1cmVDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgc2V0Q2FwdHVyZUNvdW50KHByZXZDb3VudCA9PiBwcmV2Q291bnQgKyAxKTtcbiAgICB9XG4gICAgXG4gICAgLy8gNS4gUmV0dXJuIHJlc3VsdHMgLSBub3cgaW5jbHVkaW5nIHdlYmNhbSByZXNvbHV0aW9uXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbkltYWdlLFxuICAgICAgd2ViY2FtSW1hZ2UsXG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgcG9pbnQsXG4gICAgICBjYXB0dXJlTnVtYmVyLFxuICAgICAgZ3JvdXBJZDogY2FwdHVyZUdyb3VwSWQsXG4gICAgICB3ZWJjYW1XaWR0aCxcbiAgICAgIHdlYmNhbUhlaWdodFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJjYXB0dXJlSW1hZ2VzQXRQb2ludCBmYWlsZWQ6XCIsIGVycik7XG4gICAgcmV0dXJuIHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogZXJyLm1lc3NhZ2UsXG4gICAgICBzY3JlZW5JbWFnZTogbnVsbCxcbiAgICAgIHdlYmNhbUltYWdlOiBudWxsLFxuICAgICAgd2ViY2FtV2lkdGg6IDAsXG4gICAgICB3ZWJjYW1IZWlnaHQ6IDBcbiAgICB9O1xuICB9XG59OyJdLCJuYW1lcyI6WyJyZXNpemVJbWFnZSIsImltYWdlRGF0YVVybCIsIm1heFdpZHRoIiwibWF4SGVpZ2h0IiwicXVhbGl0eSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW1nIiwiSW1hZ2UiLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsIk1hdGgiLCJyb3VuZCIsImNhbnZhcyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJyZXNpemVkRGF0YVVybCIsInRvRGF0YVVSTCIsIm9uZXJyb3IiLCJlcnIiLCJzcmMiLCJpc0ltYWdlVG9vTGFyZ2UiLCJtYXhTaXplQnl0ZXMiLCJwcmVmaXgiLCJiYXNlNjRMZW5ndGgiLCJsZW5ndGgiLCJzdGFydHNXaXRoIiwiYXBwcm94aW1hdGVCeXRlcyIsInNhdmVJbWFnZVRvU2VydmVyIiwiaW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ0eXBlIiwiZm9sZGVyIiwiY2FwdHVyZUdyb3VwIiwicHJvY2Vzc2VkSW1hZ2VEYXRhIiwiY29uc29sZSIsImxvZyIsInNpemVzIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInJlc3VsdCIsImpzb24iLCJlcnJvciIsInNhdmVDU1ZUb1NlcnZlciIsImNzdkRhdGEiLCJjc3ZCbG9iIiwiQmxvYiIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVhZEFzRGF0YVVSTCIsImdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMiLCJyZXNvbHV0aW9ucyIsImlkZWFsIiwicmVzb2x1dGlvbiIsImNvbnN0cmFpbnRzIiwidmlkZW8iLCJmYWNpbmdNb2RlIiwic3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInRyYWNrIiwic3RvcCIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwicG9pbnQiLCJjYXB0dXJlQ291bnQiLCJjYW52YXNSZWYiLCJzZXRDYXB0dXJlQ291bnQiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJjYXB0dXJlR3JvdXBJZCIsIkRhdGUiLCJub3ciLCJzY3JlZW5GaWxlbmFtZSIsIndlYmNhbUZpbGVuYW1lIiwicGFyYW1ldGVyRmlsZW5hbWUiLCJjdXJyZW50Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImNhcHR1cmVOdW1iZXIiLCJ3ZWJjYW1XaWR0aCIsIndlYmNhbUhlaWdodCIsIndlYmNhbUltYWdlUHJldmlldyIsInZpZGVvRWxlbWVudCIsIndpbmRvdyIsInF1ZXJ5U2VsZWN0b3IiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJ0ZW1wQ2FudmFzIiwidGVtcFZpZGVvIiwic3JjT2JqZWN0IiwibXV0ZWQiLCJwbGF5c0lubGluZSIsImF1dG9wbGF5IiwiYXBwZW5kQ2hpbGQiLCJvbmxvYWRlZG1ldGFkYXRhIiwicGxheSIsInNldFRpbWVvdXQiLCJyZXMiLCJ3YXJuIiwiZ2V0VmlkZW9UcmFja3MiLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwidCIsInJlbW92ZSIsImZhbGxiYWNrRXJyIiwieCIsInkiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJwYXJhbVJlc3VsdCIsInN1Y2Nlc3MiLCJudW1iZXIiLCJzY3JlZW5SZXN1bHQiLCJ3ZWJjYW1SZXN1bHQiLCJwcmV2Q291bnQiLCJncm91cElkIiwibWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\n"));

/***/ })

});