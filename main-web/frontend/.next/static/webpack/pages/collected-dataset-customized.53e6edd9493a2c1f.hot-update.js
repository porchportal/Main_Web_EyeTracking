"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js":
/*!***************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CalibratePoints.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawCalibrationGrid: () => (/* binding */ drawCalibrationGrid),\n/* harmony export */   drawCalibrationPoint: () => (/* binding */ drawCalibrationPoint),\n/* harmony export */   generateCalibrationPoints: () => (/* binding */ generateCalibrationPoints)\n/* harmony export */ });\n// CalibratePoints.js\n// Utility for generating and managing calibration points on a canvas\n/**\n * Generate a grid of calibration points based on canvas dimensions\n * @param {number} width - Canvas width\n * @param {number} height - Canvas height\n * @returns {Array} Array of point objects with x,y coordinates\n */ const generateCalibrationPoints = (width, height)=>{\n    if (!width || !height || width <= 0 || height <= 0) {\n        console.error(\"generateCalibrationPoints: Invalid canvas dimensions\", {\n            width,\n            height\n        });\n        return [];\n    }\n    const conditionalRound = (dimension, percentage)=>Math.round(dimension * percentage);\n    // Outer frame (12% from edges)\n    const xLeftOuter = conditionalRound(width, 0.12);\n    const xRightOuter = width - xLeftOuter;\n    const yTopOuter = conditionalRound(height, 0.12);\n    const yBottomOuter = height - yTopOuter;\n    // Inner frame (26% from edges)\n    const xLeftInner = conditionalRound(width, 0.26);\n    const xRightInner = width - xLeftInner;\n    const yTopInner = conditionalRound(height, 0.26);\n    const yBottomInner = height - yTopInner;\n    const xCenter = Math.floor(width / 2);\n    const yCenter = Math.floor(height / 2);\n    return [\n        // Outer frame (8 points)\n        {\n            x: xLeftOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopOuter,\n            label: \"Outer Top-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yCenter,\n            label: \"Outer Middle-Left\"\n        },\n        {\n            x: xRightOuter,\n            y: yCenter,\n            label: \"Outer Middle-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Right\"\n        },\n        // Inner frame (8 points)\n        {\n            x: xLeftInner,\n            y: yTopInner,\n            label: \"Inner Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopInner,\n            label: \"Inner Top-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yTopInner,\n            label: \"Inner Top-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yCenter,\n            label: \"Inner Middle-Left\"\n        },\n        {\n            x: xRightInner,\n            y: yCenter,\n            label: \"Inner Middle-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomInner,\n            label: \"Inner Bottom-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Right\"\n        }\n    ];\n};\n/**\n * Draw a calibration point on a canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {Object} options - Optional settings (color, radius)\n * @returns {Object} Point position object {x, y}\n */ const drawCalibrationPoint = function(canvas, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (!canvas) return {\n        x,\n        y\n    };\n    const ctx = canvas.getContext('2d');\n    const color = options.color || 'red';\n    const radius = options.radius || 8;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = color;\n    ctx.fill();\n    // Glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * Draw all calibration points on a canvas (for debugging/visualization)\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Array} points - Array of point objects\n * @param {number} activeIndex - Index of the currently active point\n */ const drawCalibrationGrid = function(canvas, points) {\n    let activeIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;\n    if (!canvas || !points || !points.length) return;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    points.forEach((point, index)=>{\n        const isActive = index === activeIndex;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, isActive ? 8 : 4, 0, Math.PI * 2);\n        ctx.fillStyle = isActive ? 'red' : 'rgba(0, 102, 204, 0.7)';\n        ctx.fill();\n        ctx.fillStyle = 'black';\n        ctx.font = '10px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(\"\".concat(index + 1), point.x, point.y);\n        if (isActive && point.label) {\n            ctx.font = '12px Arial';\n            ctx.fillText(point.label, point.x, point.y - 20);\n        }\n    });\n    // Draw connecting lines (optional)\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for(let i = 1; i < points.length; i++){\n        ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.strokeStyle = 'rgba(0, 102, 204, 0.3)';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n};\n// Optional: Default export all for convenience\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    generateCalibrationPoints,\n    drawCalibrationPoint,\n    drawCalibrationGrid\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDckIscUVBQXFFO0FBRXJFOzs7OztDQUtDLEdBQ00sTUFBTUEsNEJBQTRCLENBQUNDLE9BQU9DO0lBQy9DLElBQUksQ0FBQ0QsU0FBUyxDQUFDQyxVQUFVRCxTQUFTLEtBQUtDLFVBQVUsR0FBRztRQUNsREMsUUFBUUMsS0FBSyxDQUFDLHdEQUF3RDtZQUFFSDtZQUFPQztRQUFPO1FBQ3RGLE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTUcsbUJBQW1CLENBQUNDLFdBQVdDLGFBQWVDLEtBQUtDLEtBQUssQ0FBQ0gsWUFBWUM7SUFFM0UsK0JBQStCO0lBQy9CLE1BQU1HLGFBQWFMLGlCQUFpQkosT0FBTztJQUMzQyxNQUFNVSxjQUFjVixRQUFRUztJQUM1QixNQUFNRSxZQUFZUCxpQkFBaUJILFFBQVE7SUFDM0MsTUFBTVcsZUFBZVgsU0FBU1U7SUFFOUIsK0JBQStCO0lBQy9CLE1BQU1FLGFBQWFULGlCQUFpQkosT0FBTztJQUMzQyxNQUFNYyxjQUFjZCxRQUFRYTtJQUM1QixNQUFNRSxZQUFZWCxpQkFBaUJILFFBQVE7SUFDM0MsTUFBTWUsZUFBZWYsU0FBU2M7SUFFOUIsTUFBTUUsVUFBVVYsS0FBS1csS0FBSyxDQUFDbEIsUUFBUTtJQUNuQyxNQUFNbUIsVUFBVVosS0FBS1csS0FBSyxDQUFDakIsU0FBUztJQUVwQyxPQUFPO1FBQ0wseUJBQXlCO1FBQ3pCO1lBQUVtQixHQUFHWDtZQUFZWSxHQUFHVjtZQUFXVyxPQUFPO1FBQWlCO1FBQ3ZEO1lBQUVGLEdBQUdIO1lBQVNJLEdBQUdWO1lBQVdXLE9BQU87UUFBbUI7UUFDdEQ7WUFBRUYsR0FBR1Y7WUFBYVcsR0FBR1Y7WUFBV1csT0FBTztRQUFrQjtRQUN6RDtZQUFFRixHQUFHWDtZQUFZWSxH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ekRULElBQUlLLFNBQVMsR0FBR2dCLFdBQVcsUUFBUTtRQUNuQ3JCLElBQUlVLElBQUk7UUFFUlYsSUFBSUssU0FBUyxHQUFHO1FBQ2hCTCxJQUFJc0IsSUFBSSxHQUFHO1FBQ1h0QixJQUFJdUIsU0FBUyxHQUFHO1FBQ2hCdkIsSUFBSXdCLFlBQVksR0FBRztRQUNuQnhCLElBQUl5QixRQUFRLENBQUMsR0FBYSxPQUFWTCxRQUFRLElBQUtELE1BQU16QixDQUFDLEVBQUV5QixNQUFNeEIsQ0FBQztRQUU3QyxJQUFJMEIsWUFBWUYsTUFBTXZCLEtBQUssRUFBRTtZQUMzQkksSUFBSXNCLElBQUksR0FBRztZQUNYdEIsSUFBSXlCLFFBQVEsQ0FBQ04sTUFBTXZCLEtBQUssRUFBRXVCLE1BQU16QixDQUFDLEVBQUV5QixNQUFNeEIsQ0FBQyxHQUFHO1FBQy9DO0lBQ0Y7SUFFQSxtQ0FBbUM7SUFDbkNLLElBQUlPLFNBQVM7SUFDYlAsSUFBSTBCLE1BQU0sQ0FBQ1gsTUFBTSxDQUFDLEVBQUUsQ0FBQ3JCLENBQUMsRUFBRXFCLE1BQU0sQ0FBQyxFQUFFLENBQUNwQixDQUFDO0lBQ25DLElBQUssSUFBSWdDLElBQUksR0FBR0EsSUFBSVosT0FBT0UsTUFBTSxFQUFFVSxJQUFLO1FBQ3RDM0IsSUFBSTRCLE1BQU0sQ0FBQ2IsTUFBTSxDQUFDWSxFQUFFLENBQUNqQyxDQUFDLEVBQUVxQixNQUFNLENBQUNZLEVBQUUsQ0FBQ2hDLENBQUM7SUFDckM7SUFDQUssSUFBSVcsV0FBVyxHQUFHO0lBQ2xCWCxJQUFJWSxTQUFTLEdBQUc7SUFDaEJaLElBQUlhLE1BQU07QUFDWixFQUFFO0FBRUYsK0NBQStDO0FBQy9DLGlFQUFlO0lBQ2J4QztJQUNBd0I7SUFDQWlCO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENhbGlicmF0ZVBvaW50cy5qc1xuLy8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBhbmQgbWFuYWdpbmcgY2FsaWJyYXRpb24gcG9pbnRzIG9uIGEgY2FudmFzXG5cbi8qKlxuICogR2VuZXJhdGUgYSBncmlkIG9mIGNhbGlicmF0aW9uIHBvaW50cyBiYXNlZCBvbiBjYW52YXMgZGltZW5zaW9uc1xuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gQ2FudmFzIHdpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gQ2FudmFzIGhlaWdodFxuICogQHJldHVybnMge0FycmF5fSBBcnJheSBvZiBwb2ludCBvYmplY3RzIHdpdGggeCx5IGNvb3JkaW5hdGVzXG4gKi9cbmV4cG9ydCBjb25zdCBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0IHx8IHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50czogSW52YWxpZCBjYW52YXMgZGltZW5zaW9uc1wiLCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgY29uZGl0aW9uYWxSb3VuZCA9IChkaW1lbnNpb24sIHBlcmNlbnRhZ2UpID0+IE1hdGgucm91bmQoZGltZW5zaW9uICogcGVyY2VudGFnZSk7XG5cbiAgLy8gT3V0ZXIgZnJhbWUgKDEyJSBmcm9tIGVkZ2VzKVxuICBjb25zdCB4TGVmdE91dGVyID0gY29uZGl0aW9uYWxSb3VuZCh3aWR0aCwgMC4xMik7XG4gIGNvbnN0IHhSaWdodE91dGVyID0gd2lkdGggLSB4TGVmdE91dGVyO1xuICBjb25zdCB5VG9wT3V0ZXIgPSBjb25kaXRpb25hbFJvdW5kKGhlaWdodCwgMC4xMik7XG4gIGNvbnN0IHlCb3R0b21PdXRlciA9IGhlaWdodCAtIHlUb3BPdXRlcjtcblxuICAvLyBJbm5lciBmcmFtZSAoMjYlIGZyb20gZWRnZXMpXG4gIGNvbnN0IHhMZWZ0SW5uZXIgPSBjb25kaXRpb25hbFJvdW5kKHdpZHRoLCAwLjI2KTtcbiAgY29uc3QgeFJpZ2h0SW5uZXIgPSB3aWR0aCAtIHhMZWZ0SW5uZXI7XG4gIGNvbnN0IHlUb3BJbm5lciA9IGNvbmRpdGlvbmFsUm91bmQoaGVpZ2h0LCAwLjI2KTtcbiAgY29uc3QgeUJvdHRvbUlubmVyID0gaGVpZ2h0IC0geVRvcElubmVyO1xuXG4gIGNvbnN0IHhDZW50ZXIgPSBNYXRoLmZsb29yKHdpZHRoIC8gMik7XG4gIGNvbnN0IHlDZW50ZXIgPSBNYXRoLmZsb29yKGhlaWdodCAvIDIpO1xuXG4gIHJldHVybiBbXG4gICAgLy8gT3V0ZXIgZnJhbWUgKDggcG9pbnRzKVxuICAgIHsgeDogeExlZnRPdXRlciwgeTogeVRvcE91dGVyLCBsYWJlbDogXCJPdXRlciBUb3AtTGVmdFwiIH0sXG4gICAgeyB4OiB4Q2VudGVyLCB5OiB5VG9wT3V0ZXIsIGxhYmVsOiBcIk91dGVyIFRvcC1DZW50ZXJcIiB9LFxuICAgIHsgeDogeFJpZ2h0T3V0ZXIsIHk6IHlUb3BPdXRlciwgbGFiZWw6IFwiT3V0ZXIgVG9wLVJpZ2h0XCIgfSxcbiAgICB7IHg6IHhMZWZ0T3V0ZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIk91dGVyIE1pZGRsZS1MZWZ0XCIgfSxcbiAgICB7IHg6IHhSaWdodE91dGVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJPdXRlciBNaWRkbGUtUmlnaHRcIiB9LFxuICAgIHsgeDogeExlZnRPdXRlciwgeTogeUJvdHRvbU91dGVyLCBsYWJlbDogXCJPdXRlciBCb3R0b20tTGVmdFwiIH0sXG4gICAgeyB4OiB4Q2VudGVyLCB5OiB5Qm90dG9tT3V0ZXIsIGxhYmVsOiBcIk91dGVyIEJvdHRvbS1DZW50ZXJcIiB9LFxuICAgIHsgeDogeFJpZ2h0T3V0ZXIsIHk6IHlCb3R0b21PdXRlciwgbGFiZWw6IFwiT3V0ZXIgQm90dG9tLVJpZ2h0XCIgfSxcblxuICAgIC8vIElubmVyIGZyYW1lICg4IHBvaW50cylcbiAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlUb3BJbm5lciwgbGFiZWw6IFwiSW5uZXIgVG9wLUxlZnRcIiB9LFxuICAgIHsgeDogeENlbnRlciwgeTogeVRvcElubmVyLCBsYWJlbDogXCJJbm5lciBUb3AtQ2VudGVyXCIgfSxcbiAgICB7IHg6IHhSaWdodElubmVyLCB5OiB5VG9wSW5uZXIsIGxhYmVsOiBcIklubmVyIFRvcC1SaWdodFwiIH0sXG4gICAgeyB4OiB4TGVmdElubmVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJJbm5lciBNaWRkbGUtTGVmdFwiIH0sXG4gICAgeyB4OiB4UmlnaHRJbm5lciwgeTogeUNlbnRlciwgbGFiZWw6IFwiSW5uZXIgTWlkZGxlLVJpZ2h0XCIgfSxcbiAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlCb3R0b21Jbm5lciwgbGFiZWw6IFwiSW5uZXIgQm90dG9tLUxlZnRcIiB9LFxuICAgIHsgeDogeENlbnRlciwgeTogeUJvdHRvbUlubmVyLCBsYWJlbDogXCJJbm5lciBCb3R0b20tQ2VudGVyXCIgfSxcbiAgICB7IHg6IHhSaWdodElubmVyLCB5OiB5Qm90dG9tSW5uZXIsIGxhYmVsOiBcIklubmVyIEJvdHRvbS1SaWdodFwiIH1cbiAgXTtcbn07XG5cbi8qKlxuICogRHJhdyBhIGNhbGlicmF0aW9uIHBvaW50IG9uIGEgY2FudmFzXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzIChjb2xvciwgcmFkaXVzKVxuICogQHJldHVybnMge09iamVjdH0gUG9pbnQgcG9zaXRpb24gb2JqZWN0IHt4LCB5fVxuICovXG5leHBvcnQgY29uc3QgZHJhd0NhbGlicmF0aW9uUG9pbnQgPSAoY2FudmFzLCB4LCB5LCBvcHRpb25zID0ge30pID0+IHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiB7IHgsIHkgfTtcblxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY29uc3QgY29sb3IgPSBvcHRpb25zLmNvbG9yIHx8ICdyZWQnO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cyB8fCA4O1xuXG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICBjdHguZmlsbCgpO1xuXG4gIC8vIEdsb3cgZWZmZWN0XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gIGN0eC5saW5lV2lkdGggPSAyO1xuICBjdHguc3Ryb2tlKCk7XG5cbiAgcmV0dXJuIHsgeCwgeSB9O1xufTtcblxuLyoqXG4gKiBEcmF3IGFsbCBjYWxpYnJhdGlvbiBwb2ludHMgb24gYSBjYW52YXMgKGZvciBkZWJ1Z2dpbmcvdmlzdWFsaXphdGlvbilcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgLSBBcnJheSBvZiBwb2ludCBvYmplY3RzXG4gKiBAcGFyYW0ge251bWJlcn0gYWN0aXZlSW5kZXggLSBJbmRleCBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBwb2ludFxuICovXG5leHBvcnQgY29uc3QgZHJhd0NhbGlicmF0aW9uR3JpZCA9IChjYW52YXMsIHBvaW50cywgYWN0aXZlSW5kZXggPSAtMSkgPT4ge1xuICBpZiAoIWNhbnZhcyB8fCAhcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSByZXR1cm47XG5cbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gIHBvaW50cy5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGluZGV4ID09PSBhY3RpdmVJbmRleDtcblxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGlzQWN0aXZlID8gOCA6IDQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gaXNBY3RpdmUgPyAncmVkJyA6ICdyZ2JhKDAsIDEwMiwgMjA0LCAwLjcpJztcbiAgICBjdHguZmlsbCgpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgY3R4LmZvbnQgPSAnMTBweCBBcmlhbCc7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZmlsbFRleHQoYCR7aW5kZXggKyAxfWAsIHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgaWYgKGlzQWN0aXZlICYmIHBvaW50LmxhYmVsKSB7XG4gICAgICBjdHguZm9udCA9ICcxMnB4IEFyaWFsJztcbiAgICAgIGN0eC5maWxsVGV4dChwb2ludC5sYWJlbCwgcG9pbnQueCwgcG9pbnQueSAtIDIwKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIERyYXcgY29ubmVjdGluZyBsaW5lcyAob3B0aW9uYWwpXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgfVxuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLCAxMDIsIDIwNCwgMC4zKSc7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHguc3Ryb2tlKCk7XG59O1xuXG4vLyBPcHRpb25hbDogRGVmYXVsdCBleHBvcnQgYWxsIGZvciBjb252ZW5pZW5jZVxuZXhwb3J0IGRlZmF1bHQge1xuICBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzLFxuICBkcmF3Q2FsaWJyYXRpb25Qb2ludCxcbiAgZHJhd0NhbGlicmF0aW9uR3JpZFxufTsiXSwibmFtZXMiOlsiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsIndpZHRoIiwiaGVpZ2h0IiwiY29uc29sZSIsImVycm9yIiwiY29uZGl0aW9uYWxSb3VuZCIsImRpbWVuc2lvbiIsInBlcmNlbnRhZ2UiLCJNYXRoIiwicm91bmQiLCJ4TGVmdE91dGVyIiwieFJpZ2h0T3V0ZXIiLCJ5VG9wT3V0ZXIiLCJ5Qm90dG9tT3V0ZXIiLCJ4TGVmdElubmVyIiwieFJpZ2h0SW5uZXIiLCJ5VG9wSW5uZXIiLCJ5Qm90dG9tSW5uZXIiLCJ4Q2VudGVyIiwiZmxvb3IiLCJ5Q2VudGVyIiwieCIsInkiLCJsYWJlbCIsImRyYXdDYWxpYnJhdGlvblBvaW50IiwiY2FudmFzIiwib3B0aW9ucyIsImN0eCIsImdldENvbnRleHQiLCJjb2xvciIsInJhZGl1cyIsImNsZWFyUmVjdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJkcmF3Q2FsaWJyYXRpb25HcmlkIiwicG9pbnRzIiwiYWN0aXZlSW5kZXgiLCJsZW5ndGgiLCJmb3JFYWNoIiwicG9pbnQiLCJpbmRleCIsImlzQWN0aXZlIiwiZm9udCIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsImZpbGxUZXh0IiwibW92ZVRvIiwiaSIsImxpbmVUbyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Memoize button configurations\n    // const buttons = useMemo(() => [\n    //   { \n    //     text: \"Set Random\", \n    //     abbreviatedText: \"SRandom\", \n    //     onClick: handleSetRandom,\n    //     disabled: isCapturing\n    //   },\n    //   { \n    //     text: \"Random Dot\", \n    //     abbreviatedText: \"Random\", \n    //     onClick: handleRandomDot,\n    //     disabled: isCapturing \n    //   },\n    //   { \n    //     text: \"Set Calibrate\", \n    //     abbreviatedText: \"Calibrate\", \n    //     onClick: handleSetCalibrate,\n    //     disabled: isCapturing \n    //   },\n    //   { \n    //     text: \"Clear All\", \n    //     abbreviatedText: \"Clear\", \n    //     onClick: handleClearAll\n    //   },\n    //   { divider: true },\n    //   { \n    //     text: \"Draw Head pose\", \n    //     abbreviatedText: \"Head pose\", \n    //     onClick: handleToggleHeadPose,\n    //     active: showHeadPose\n    //   },\n    //   { \n    //     text: \"Show Bounding Box\", \n    //     abbreviatedText: \"â˜ Box\", \n    //     onClick: handleToggleBoundingBox,\n    //     active: showBoundingBox\n    //   },\n    //   { \n    //     text: isCameraActive ? \"Stop Camera\" : \"Show Preview\", \n    //     abbreviatedText: isCameraActive ? \"Stop\" : \"Preview\", \n    //     onClick: () => {\n    //       if (!isCameraActive && !triggerCameraAccess(true)) {\n    //         setShowPermissionPopup(true);\n    //       } else {\n    //         handleToggleCamera();\n    //       }\n    //     },\n    //     active: isCameraActive,\n    //     disabled: isCapturing\n    //   },\n    //   { \n    //     text: \"ðŸ˜· Show Mask\", \n    //     abbreviatedText: \"ðŸ˜· Mask\", \n    //     onClick: handleToggleMask,\n    //     active: showMask\n    //   },\n    //   { \n    //     text: \"Parameters\", \n    //     abbreviatedText: \"Values\", \n    //     onClick: handleToggleParameters,\n    //     active: showParameters\n    //   }\n    // ], [isCapturing, showHeadPose, showBoundingBox, isCameraActive, showMask, showParameters]);\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    const initializeCanvas = (canvas, parent)=>{\n        if (!canvas || !parent) {\n            // console.warn('[initializeCanvas] Canvas or parent is null', { canvas, parent });\n            return false;\n        }\n        try {\n            // Set canvas dimensions to match parent\n            canvas.width = parent.clientWidth || 800;\n            canvas.height = parent.clientHeight || 600;\n            // Clear canvas and set white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // console.log(`Canvas initialized with dimensions: ${canvas.width}x${canvas.height}`);\n            return true;\n        } catch (error) {\n            console.error('[initializeCanvas] Error initializing canvas:', error);\n            return false;\n        }\n    };\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas = ()=>{\n        // Try multiple methods to find the canvas\n        if (canvasRef.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef.current;\n        }\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef.current = window.whiteScreenCanvas;\n            return window.whiteScreenCanvas;\n        }\n        if (typeof document !== 'undefined') {\n            // Try multiple selectors to find the canvas\n            const selectors = [\n                '.tracking-canvas',\n                'canvas',\n                '#tracking-canvas'\n            ];\n            for (const selector of selectors){\n                const canvasElement = document.querySelector(selector);\n                if (canvasElement) {\n                    console.log(\"Found canvas via selector: \".concat(selector));\n                    canvasRef.current = canvasElement;\n                    if (true) {\n                        window.whiteScreenCanvas = canvasElement;\n                    }\n                    return canvasElement;\n                }\n            }\n        }\n        console.error(\"No canvas found through any method\");\n        return null;\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        // First initialize with parent dimensions\n        const parent = canvas.parentElement || document.body;\n        initializeCanvas(canvas, parent);\n        // Then force fullscreen styling\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '5';\n        // Force dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear and prepare canvas again\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas set to fullscreen: \".concat(canvas.width, \"x\").concat(canvas.height));\n    };\n    const restoreCanvasSize = (canvas)=>{\n        // Restore original canvas styling\n        canvas.style.position = '';\n        canvas.style.top = '';\n        canvas.style.left = '';\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n        canvas.style.zIndex = '';\n        // Restore original dimensions\n        if (canvas.parentElement) {\n            initializeCanvas(canvas, canvas.parentElement);\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas, originalParent, originalStyle)=>{\n        if (!canvas || !originalParent) return;\n        // Append the canvas back to its original parent if needed\n        if (canvas.parentElement !== originalParent) {\n            originalParent.appendChild(canvas);\n        }\n        // Restore the inline styles saved earlier\n        canvas.style.position = originalStyle.position;\n        canvas.style.top = originalStyle.top;\n        canvas.style.left = originalStyle.left;\n        canvas.style.width = originalStyle.width;\n        canvas.style.height = originalStyle.height;\n        canvas.style.zIndex = originalStyle.zIndex;\n        // Reset the dimensions based on the parent element's size or fallback defaults\n        canvas.width = originalParent.clientWidth || 800;\n        canvas.height = originalParent.clientHeight || 600;\n        // Clear the canvas and fill with a white background\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ // Modified handleDotProcess function with improved dot and countdown alignment\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get canvas reference with retries\n            let canvas = null;\n            let retryCount = 0;\n            const maxRetries = 3;\n            while(!canvas && retryCount < maxRetries){\n                canvas = getMainCanvas();\n                if (!canvas) {\n                    console.warn(\"Canvas not found, retry \".concat(retryCount + 1, \"/\").concat(maxRetries));\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    retryCount++;\n                }\n            }\n            if (!canvas) {\n                throw new Error(\"Canvas not available after multiple retries\");\n            }\n            // Save original state for restoration\n            const originalParent = canvas.parentElement;\n            const originalStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Prepare canvas for fullscreen display\n            document.body.appendChild(canvas);\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            // Clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            let keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            // Important: Position the countdown centered directly over the dot\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"âœ“\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Clear redraw interval\n            clearInterval(keepDotVisibleInterval);\n            // Restore canvas to original state\n            if (originalParent && canvas.parentElement !== originalParent) {\n                originalParent.appendChild(canvas);\n            }\n            canvas.style.position = originalStyle.position || '';\n            canvas.style.top = originalStyle.top || '';\n            canvas.style.left = originalStyle.left || '';\n            canvas.style.width = originalStyle.width || '100%';\n            canvas.style.height = originalStyle.height || '100%';\n            canvas.style.zIndex = originalStyle.zIndex || '';\n            // Reset dimensions\n            if (originalParent) {\n                canvas.width = originalParent.clientWidth || 800;\n                canvas.height = originalParent.clientHeight || 600;\n            }\n            // Clear canvas\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2000);\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            // Show TopBar again if there's an error\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"âœ“\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            // Restore canvas to original parent and styling - Only if canvas was successfully initialized\n            if (canvas) {\n                try {\n                    // Try to find original parent\n                    if (originalCanvasParent && canvas.parentElement !== originalCanvasParent) {\n                        originalCanvasParent.appendChild(canvas);\n                    } else if (!originalCanvasParent) {\n                        // Fallback to looking for a container element\n                        const possibleParent = document.querySelector('.canvas-container');\n                        if (possibleParent && canvas.parentElement !== possibleParent) {\n                            possibleParent.appendChild(canvas);\n                        }\n                    }\n                    // Restore styling\n                    canvas.style.position = originalCanvasStyle.position || '';\n                    canvas.style.top = originalCanvasStyle.top || '';\n                    canvas.style.left = originalCanvasStyle.left || '';\n                    canvas.style.width = originalCanvasStyle.width || '100%';\n                    canvas.style.height = originalCanvasStyle.height || '100%';\n                    canvas.style.zIndex = originalCanvasStyle.zIndex || '';\n                    // Reset dimensions based on parent\n                    const parent = canvas.parentElement;\n                    if (parent) {\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                    } else {\n                        canvas.width = 800;\n                        canvas.height = 600;\n                    }\n                    // Clear canvas with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas restored to original state\");\n                } catch (e) {\n                    console.error(\"Error restoring canvas:\", e);\n                }\n            }\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        // Use the consolidated function with random position\n        await handleDotProcess({\n            useRandomPosition: true,\n            onStatusUpdate: (status)=>{\n                if (status.processStatus) setProcessStatus(status.processStatus);\n                if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n            },\n            toggleTopBar: (show)=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', show);\n                }\n            },\n            triggerCameraAccess,\n            setIsCapturing,\n            captureCount,\n            setCaptureCount: setCaptureCount,\n            postCountdownDelay: 1000\n        });\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        clearCanvas();\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1421,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1420,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1425,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1424,\n                columnNumber: 9\n            }, undefined),\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"ActionButtonGroupInner.useMemo\": ()=>(processStatus || remainingCaptures > 0 || countdownValue) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"status-display mt-4 p-2 bg-blue-50 rounded-md\",\n                        children: [\n                            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-blue-800\",\n                                children: processStatus\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1434,\n                                columnNumber: 15\n                            }, undefined),\n                            remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-yellow-600\",\n                                children: [\n                                    \"Remaining: \",\n                                    remainingCaptures\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1437,\n                                columnNumber: 15\n                            }, undefined),\n                            countdownValue && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-2xl font-bold text-red-600\",\n                                children: countdownValue\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1440,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1432,\n                        columnNumber: 11\n                    }, undefined)\n            }[\"ActionButtonGroupInner.useMemo\"], [\n                processStatus,\n                remainingCaptures,\n                countdownValue\n            ]),\n            showCanvas && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"canvas-container mt-4\",\n                style: {\n                    position: 'relative',\n                    width: '100%',\n                    height: '40vh',\n                    minHeight: '300px',\n                    border: '1px solid #e0e0e0',\n                    backgroundColor: 'white',\n                    borderRadius: '4px',\n                    overflow: 'hidden'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                        ref: canvasRef,\n                        className: \"tracking-canvas\",\n                        id: \"tracking-canvas\",\n                        style: {\n                            width: '100%',\n                            height: '100%',\n                            display: 'block' // Ensure canvas is displayed as block\n                        },\n                        onLoad: (e)=>{\n                            // Initialize canvas when it loads\n                            const canvas = e.target;\n                            if (canvas) {\n                                canvasRef.current = canvas;\n                                if (true) {\n                                    window.whiteScreenCanvas = canvas;\n                                }\n                                // Initialize canvas with white background\n                                const ctx = canvas.getContext('2d');\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                            }\n                        }\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1461,\n                        columnNumber: 11\n                    }, undefined),\n                    countdownValue && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"dot-countdown\",\n                        style: {\n                            position: 'absolute',\n                            left: \"\".concat(currentDot.x - 15, \"px\"),\n                            top: \"\".concat(currentDot.y - 40, \"px\"),\n                            color: 'red',\n                            fontSize: '28px',\n                            fontWeight: 'bold'\n                        },\n                        children: countdownValue\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1488,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1448,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1532,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1542,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1560,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1573,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1552,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1522,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1507,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1418,\n        columnNumber: 5\n    }, undefined);\n}, \"HJt9EyoiQgJ9MXgzyruz0YP98Dc=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1595,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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QUFRO2dDQUNSUCxVQUFVO2dDQUNWUyxZQUFZOzRCQUNkO3NDQUNEOzs7Ozs7c0NBR0QsOERBQUNqTjs0QkFDQ2xCLFdBQVU7NEJBQ1ZpSCxPQUFPO2dDQUNMcUcsU0FBUztnQ0FDVE0sZ0JBQWdCO2dDQUNoQlEsS0FBSzs0QkFDUDs7OENBRUEsOERBQUNuTjtvQ0FDQ2pDLFNBQVN5STtvQ0FDVHpILFdBQVU7b0NBQ1ZpSCxPQUFPO3dDQUNMNkcsU0FBUzt3Q0FDVFosaUJBQWlCO3dDQUNqQkQsUUFBUTt3Q0FDUkUsY0FBYzt3Q0FDZGtCLFFBQVE7b0NBQ1Y7OENBQ0Q7Ozs7Ozs4Q0FHRCw4REFBQ3BOO29DQUNDakMsU0FBU3dJO29DQUNUeEgsV0FBVTtvQ0FDVmlILE9BQU87d0NBQ0w2RyxTQUFTO3dDQUNUWixpQkFBaUI7d0NBQ2pCTyxPQUFPO3dDQUNQUixRQUFRO3dDQUNSRSxjQUFjO3dDQUNka0IsUUFBUTtvQ0FDVjs4Q0FDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFTZjs7UUFwOUNpQnJRLGtEQUFTQTtRQUNhQyw0REFBZ0JBOzs7TUFGakRrRDtBQXM5Q04sTUFBTW1OLG9CQUFvQjlRLG1EQUFPQSxPQUFDLElBQU04SyxRQUFRQyxPQUFPLGVBQ3JEbEwsaURBQVVBLENBQUMsQ0FBQ2tSLE9BQU9uTixvQkFBUSw4REFBQ0Q7WUFBd0IsR0FBR29OLEtBQUs7WUFBRW5OLEtBQUtBOzs7Ozt5QkFDbEU7SUFBRW9OLEtBQUs7QUFBTTs7QUFDaEIsb0RBQW9EO0FBQ3BELG9HQUFvRztBQUVwRywrQkFBK0I7QUFDaEIsU0FBU0M7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtNQUZ3QkE7QUFJbUIiLCJzb3VyY2VzIjpbIi9hcHAvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9hY3Rpb25CdXR0b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgXG4gIHNob3dDYXB0dXJlUHJldmlldywgXG4gIGRyYXdSZWREb3QsIFxuICBnZXRSYW5kb21Qb3NpdGlvbixcbiAgY3JlYXRlQ291bnRkb3duRWxlbWVudCxcbiAgcnVuQ291bnRkb3duXG59IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZSc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG5pbXBvcnQgeyB1c2VBZG1pblNldHRpbmdzIH0gZnJvbSAnLi9hZG1pblNldHRpbmdzJztcblxuLy8gQWRkIGRlZXAgY29tcGFyaXNvbiB1dGlsaXR5XG5jb25zdCBpc0VxdWFsID0gKG9iajEsIG9iajIpID0+IHtcbiAgaWYgKG9iajEgPT09IG9iajIpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iajEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmoyICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSA9PT0gbnVsbCB8fCBvYmoyID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIFxuICByZXR1cm4ga2V5czEuZXZlcnkoa2V5ID0+IFxuICAgIGtleXMyLmluY2x1ZGVzKGtleSkgJiYgaXNFcXVhbChvYmoxW2tleV0sIG9iajJba2V5XSlcbiAgKTtcbn07XG5cbi8vIENyZWF0ZSBhIGJhc2ljIEFjdGlvbkJ1dHRvbiBjb21wb25lbnQgd2l0aCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbiA9ICh7IHRleHQsIGFiYnJldmlhdGVkVGV4dCwgb25DbGljaywgY3VzdG9tQ2xhc3MgPSAnJywgZGlzYWJsZWQgPSBmYWxzZSwgYWN0aXZlID0gZmFsc2UgfSkgPT4ge1xuICBjb25zdCBbaXNBYmJyZXZpYXRlZCwgc2V0SXNBYmJyZXZpYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MoKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnRlciwgc2V0Q2FwdHVyZUNvdW50ZXJdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtwcm9jZXNzU3RhdHVzLCBzZXRQcm9jZXNzU3RhdHVzXSA9IHVzZVN0YXRlKCcnKTtcblxuICAvLyBNZW1vaXplIGJ1dHRvbiBwcm9wcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcbiAgY29uc3QgYnV0dG9uUHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2xhc3NOYW1lOiBgYWN0aW9uLWJ1dHRvbiAke2N1c3RvbUNsYXNzfSAke2lzQWJicmV2aWF0ZWQgPyAnYWJicmV2aWF0ZWQnIDogJyd9ICR7YWN0aXZlID8gJ2FjdGl2ZScgOiAnJ31gLFxuICAgIG9uQ2xpY2ssXG4gICAgZGlzYWJsZWQsXG4gICAgdGl0bGU6IHRleHRcbiAgfSksIFtjdXN0b21DbGFzcywgaXNBYmJyZXZpYXRlZCwgYWN0aXZlLCBvbkNsaWNrLCBkaXNhYmxlZCwgdGV4dF0pO1xuXG4gIC8vIENoZWNrIHdpbmRvdyBzaXplIGFuZCBzZXQgYWJicmV2aWF0ZWQgbW9kZSB3aXRoIGRlYm91bmNlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBzZXRJc0FiYnJldmlhdGVkKHdpZHRoIDwgNzY4KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfTtcbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICBoYW5kbGVSZXNpemUoKTsgLy8gSW5pdGlhbCBjYWxsXG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEFkZCBlZmZlY3QgdG8gbGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXMgd2l0aCBvcHRpbWl6YXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIGlmIChuZXdVc2VySWQgIT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIHsuLi5idXR0b25Qcm9wc30+XG4gICAgICB7aXNBYmJyZXZpYXRlZCA/IGFiYnJldmlhdGVkVGV4dCA6IHRleHR9XG4gICAgICB7cHJvY2Vzc1N0YXR1cyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvY2Vzcy1zdGF0dXNcIj5cbiAgICAgICAgICB7cHJvY2Vzc1N0YXR1c31cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBBY3Rpb25CdXR0b25Hcm91cCBjb21wb25lbnQgd2l0aCBjbGllbnQtc2lkZSBvbmx5IHJlbmRlcmluZyBhbmQgb3B0aW1pemF0aW9uXG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cElubmVyID0gZm9yd2FyZFJlZigoeyB0cmlnZ2VyQ2FtZXJhQWNjZXNzLCBpc0NvbXBhY3RNb2RlLCBvbkFjdGlvbkNsaWNrIH0sIHJlZikgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MocmVmKTtcbiAgXG4gIC8vIFN0YXRlIGZvciBidXR0b24gYWN0aW9uc1xuICBjb25zdCBbcmFuZG9tVGltZXMsIHNldFJhbmRvbVRpbWVzXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbZGVsYXlTZWNvbmRzLCBzZXREZWxheVNlY29uZHNdID0gdXNlU3RhdGUoMyk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbY291bnRkb3duVmFsdWUsIHNldENvdW50ZG93blZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY3VycmVudERvdCwgc2V0Q3VycmVudERvdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NhbGlicmF0aW9uUG9pbnRzLCBzZXRDYWxpYnJhdGlvblBvaW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtjdXJyZW50Q2FsaWJyYXRpb25JbmRleCwgc2V0Q3VycmVudENhbGlicmF0aW9uSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtyZW1haW5pbmdDYXB0dXJlcywgc2V0UmVtYWluaW5nQ2FwdHVyZXNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtzaG93Q2FudmFzLCBzZXRTaG93Q2FudmFzXSA9IHVzZVN0YXRlKHRydWUpO1xuICBcbiAgLy8gVHJhY2sgdGhlIGNhcHR1cmUgY291bnRcbiAgY29uc3QgW2NhbGlicmF0aW9uSGFuZGxlciwgc2V0Q2FsaWJyYXRpb25IYW5kbGVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FwdHVyZUNvdW50LCBzZXRDYXB0dXJlQ291bnRdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gVG9nZ2xlIHN0YXRlc1xuICBjb25zdCBbc2hvd0hlYWRQb3NlLCBzZXRTaG93SGVhZFBvc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0JvdW5kaW5nQm94LCBzZXRTaG93Qm91bmRpbmdCb3hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd01hc2ssIHNldFNob3dNYXNrXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQYXJhbWV0ZXJzLCBzZXRTaG93UGFyYW1ldGVyc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0NhbWVyYUFjdGl2ZSwgc2V0SXNDYW1lcmFBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1Blcm1pc3Npb25Qb3B1cCwgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCdkZWZhdWx0Jyk7XG5cbiAgLy8gQWRkIGNhY2hlIGZvciBzZXR0aW5nc1xuICBjb25zdCBzZXR0aW5nc0NhY2hlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IGxhc3RTZXR0aW5nc1VwZGF0ZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIGNvbmZpZ3VyYXRpb25zXG4gIC8vIGNvbnN0IGJ1dHRvbnMgPSB1c2VNZW1vKCgpID0+IFtcbiAgLy8gICB7IFxuICAvLyAgICAgdGV4dDogXCJTZXQgUmFuZG9tXCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIlNSYW5kb21cIiwgXG4gIC8vICAgICBvbkNsaWNrOiBoYW5kbGVTZXRSYW5kb20sXG4gIC8vICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmdcbiAgLy8gICB9LFxuICAvLyAgIHsgXG4gIC8vICAgICB0ZXh0OiBcIlJhbmRvbSBEb3RcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiUmFuZG9tXCIsIFxuICAvLyAgICAgb25DbGljazogaGFuZGxlUmFuZG9tRG90LFxuICAvLyAgICAgZGlzYWJsZWQ6IGlzQ2FwdHVyaW5nIFxuICAvLyAgIH0sXG4gIC8vICAgeyBcbiAgLy8gICAgIHRleHQ6IFwiU2V0IENhbGlicmF0ZVwiLCBcbiAgLy8gICAgIGFiYnJldmlhdGVkVGV4dDogXCJDYWxpYnJhdGVcIiwgXG4gIC8vICAgICBvbkNsaWNrOiBoYW5kbGVTZXRDYWxpYnJhdGUsXG4gIC8vICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmcgXG4gIC8vICAgfSxcbiAgLy8gICB7IFxuICAvLyAgICAgdGV4dDogXCJDbGVhciBBbGxcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiQ2xlYXJcIiwgXG4gIC8vICAgICBvbkNsaWNrOiBoYW5kbGVDbGVhckFsbFxuICAvLyAgIH0sXG4gIC8vICAgeyBkaXZpZGVyOiB0cnVlIH0sXG4gIC8vICAgeyBcbiAgLy8gICAgIHRleHQ6IFwiRHJhdyBIZWFkIHBvc2VcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiSGVhZCBwb3NlXCIsIFxuICAvLyAgICAgb25DbGljazogaGFuZGxlVG9nZ2xlSGVhZFBvc2UsXG4gIC8vICAgICBhY3RpdmU6IHNob3dIZWFkUG9zZVxuICAvLyAgIH0sXG4gIC8vICAgeyBcbiAgLy8gICAgIHRleHQ6IFwiU2hvdyBCb3VuZGluZyBCb3hcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwi4piQIEJveFwiLCBcbiAgLy8gICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94LFxuICAvLyAgICAgYWN0aXZlOiBzaG93Qm91bmRpbmdCb3hcbiAgLy8gICB9LFxuICAvLyAgIHsgXG4gIC8vICAgICB0ZXh0OiBpc0NhbWVyYUFjdGl2ZSA/IFwiU3RvcCBDYW1lcmFcIiA6IFwiU2hvdyBQcmV2aWV3XCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBpc0NhbWVyYUFjdGl2ZSA/IFwiU3RvcFwiIDogXCJQcmV2aWV3XCIsIFxuICAvLyAgICAgb25DbGljazogKCkgPT4ge1xuICAvLyAgICAgICBpZiAoIWlzQ2FtZXJhQWN0aXZlICYmICF0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpKSB7XG4gIC8vICAgICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgLy8gICAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgICBoYW5kbGVUb2dnbGVDYW1lcmEoKTtcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSxcbiAgLy8gICAgIGFjdGl2ZTogaXNDYW1lcmFBY3RpdmUsXG4gIC8vICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmdcbiAgLy8gICB9LFxuICAvLyAgIHsgXG4gIC8vICAgICB0ZXh0OiBcIvCfmLcgU2hvdyBNYXNrXCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIvCfmLcgTWFza1wiLCBcbiAgLy8gICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZU1hc2ssXG4gIC8vICAgICBhY3RpdmU6IHNob3dNYXNrXG4gIC8vICAgfSxcbiAgLy8gICB7IFxuICAvLyAgICAgdGV4dDogXCJQYXJhbWV0ZXJzXCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIlZhbHVlc1wiLCBcbiAgLy8gICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMsXG4gIC8vICAgICBhY3RpdmU6IHNob3dQYXJhbWV0ZXJzXG4gIC8vICAgfVxuICAvLyBdLCBbaXNDYXB0dXJpbmcsIHNob3dIZWFkUG9zZSwgc2hvd0JvdW5kaW5nQm94LCBpc0NhbWVyYUFjdGl2ZSwgc2hvd01hc2ssIHNob3dQYXJhbWV0ZXJzXSk7XG5cbiAgLy8gT3B0aW1pemUgc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdKSB7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldChjdXJyZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc0VxdWFsKGNhY2hlZFNldHRpbmdzLCB1c2VyU2V0dGluZ3MpKSB7XG4gICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgbmV3IHVzZXJcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzW25ld1VzZXJJZF0pIHtcbiAgICAgICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tuZXdVc2VySWRdO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzX3NldF9yYW5kb20sIGRlbGF5X3NldF9yYW5kb20gfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGlmICh0aW1lc19zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVzID0gTnVtYmVyKHRpbWVzX3NldF9yYW5kb20pIHx8IDE7XG4gICAgICAgICAgICBzZXRSYW5kb21UaW1lcyhuZXdUaW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWxheV9zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlbGF5ID0gTnVtYmVyKGRlbGF5X3NldF9yYW5kb20pIHx8IDM7XG4gICAgICAgICAgICBzZXREZWxheVNlY29uZHMobmV3RGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTWFrZSBmdW5jdGlvbnMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBhcyBhIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zID0ge1xuICAgICAgICBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSxcbiAgICAgICAgaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAgICAgICBoYW5kbGVDbGVhckFsbFxuICAgICAgfTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9uIGZ1bmN0aW9ucyBleHBvc2VkIHRvIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucztcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGdldCBjb250cm9sIHZhbHVlcyBmcm9tIFRvcEJhclxuICAgIGNvbnN0IHVwZGF0ZUNvbnRyb2xWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIHRpbWUgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSBwYXJzZUludCh0aW1lSW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTih0aW1lVmFsdWUpICYmIHRpbWVWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgcmFuZG9tVGltZXMgdG86JywgdGltZVZhbHVlKTtcbiAgICAgICAgICBzZXRSYW5kb21UaW1lcyh0aW1lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgZGVsYXkgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBjb25zdCBkZWxheVZhbHVlID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKGRlbGF5VmFsdWUpICYmIGRlbGF5VmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGRlbGF5U2Vjb25kcyB0bzonLCBkZWxheVZhbHVlKTtcbiAgICAgICAgICBzZXREZWxheVNlY29uZHMoZGVsYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGNvbnRyb2wgaW5wdXRzXG4gICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgIFxuICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIC8vIEluaXRpYWwgdXBkYXRlXG4gICAgdXBkYXRlQ29udHJvbFZhbHVlcygpO1xuICAgIFxuICAgIC8vIENsZWFudXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkge1xuICAgICAgLy8gY29uc29sZS53YXJuKCdbaW5pdGlhbGl6ZUNhbnZhc10gQ2FudmFzIG9yIHBhcmVudCBpcyBudWxsJywgeyBjYW52YXMsIHBhcmVudCB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyBhbmQgc2V0IHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gY29uc29sZS5sb2coYENhbnZhcyBpbml0aWFsaXplZCB3aXRoIGRpbWVuc2lvbnM6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW2luaXRpYWxpemVDYW52YXNdIEVycm9yIGluaXRpYWxpemluZyBjYW52YXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBtYWluIGNhbnZhcyAtIGltcHJvdmVkIHRvIGJlIG1vcmUgcmVsaWFibGVcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICAvLyBUcnkgbXVsdGlwbGUgbWV0aG9kcyB0byBmaW5kIHRoZSBjYW52YXNcbiAgICBpZiAoY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZGlyZWN0IGNhbnZhc1JlZi5jdXJyZW50IHJlZmVyZW5jZVwiKTtcbiAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcykge1xuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBnbG9iYWwgd2hpdGVTY3JlZW5DYW52YXMgcmVmZXJlbmNlXCIpO1xuICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgICByZXR1cm4gd2luZG93LndoaXRlU2NyZWVuQ2FudmFzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUcnkgbXVsdGlwbGUgc2VsZWN0b3JzIHRvIGZpbmQgdGhlIGNhbnZhc1xuICAgICAgY29uc3Qgc2VsZWN0b3JzID0gWycudHJhY2tpbmctY2FudmFzJywgJ2NhbnZhcycsICcjdHJhY2tpbmctY2FudmFzJ107XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmIChjYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGNhbnZhcyB2aWEgc2VsZWN0b3I6ICR7c2VsZWN0b3J9YCk7XG4gICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSBjYW52YXNFbGVtZW50O1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5lcnJvcihcIk5vIGNhbnZhcyBmb3VuZCB0aHJvdWdoIGFueSBtZXRob2RcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IG1ha2VDYW52YXNGdWxsc2NyZWVuID0gKGNhbnZhcykgPT4ge1xuICAgIC8vIEZpcnN0IGluaXRpYWxpemUgd2l0aCBwYXJlbnQgZGltZW5zaW9uc1xuICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXMsIHBhcmVudCk7XG4gICAgXG4gICAgLy8gVGhlbiBmb3JjZSBmdWxsc2NyZWVuIHN0eWxpbmdcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzUnO1xuICAgIFxuICAgIC8vIEZvcmNlIGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciBhbmQgcHJlcGFyZSBjYW52YXMgYWdhaW5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYENhbnZhcyBzZXQgdG8gZnVsbHNjcmVlbjogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgfTtcbiAgY29uc3QgcmVzdG9yZUNhbnZhc1NpemUgPSAoY2FudmFzKSA9PiB7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjYW52YXMgc3R5bGluZ1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnJztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcnO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnJztcbiAgICBcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGRpbWVuc2lvbnNcbiAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGluaXRpYWxpemVDYW52YXMoY2FudmFzLCBjYW52YXMucGFyZW50RWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBpZiAodHJpZ2dlckNhbWVyYUFjY2Vzcykge1xuICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlciB0byBjYW5jZWwgcGVybWlzc2lvbiBwb3B1cFxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uRGVuaWVkID0gKCkgPT4ge1xuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byByZXN0b3JlIHRoZSBjYW52YXMgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGluZ1xuICBjb25zdCByZXN0b3JlQ2FudmFzID0gKGNhbnZhcywgb3JpZ2luYWxQYXJlbnQsIG9yaWdpbmFsU3R5bGUpID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhb3JpZ2luYWxQYXJlbnQpIHJldHVybjtcblxuICAgIC8vIEFwcGVuZCB0aGUgY2FudmFzIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBpZiBuZWVkZWRcbiAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IG9yaWdpbmFsUGFyZW50KSB7XG4gICAgICBvcmlnaW5hbFBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXN0b3JlIHRoZSBpbmxpbmUgc3R5bGVzIHNhdmVkIGVhcmxpZXJcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbFN0eWxlLnBvc2l0aW9uO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbFN0eWxlLnRvcDtcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsU3R5bGUubGVmdDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbFN0eWxlLndpZHRoO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbFN0eWxlLmhlaWdodDtcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gb3JpZ2luYWxTdHlsZS56SW5kZXg7XG4gICAgXG4gICAgLy8gUmVzZXQgdGhlIGRpbWVuc2lvbnMgYmFzZWQgb24gdGhlIHBhcmVudCBlbGVtZW50J3Mgc2l6ZSBvciBmYWxsYmFjayBkZWZhdWx0c1xuICAgIGNhbnZhcy53aWR0aCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgY2FudmFzIGFuZCBmaWxsIHdpdGggYSB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9O1xuXG5cbiAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICBjb25zdCBjbGVhckNhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCBmb3IgY2xlYXJpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICB9O1xuICAvLyBBZGQgdGhpcyBmdW5jdGlvbiB0byBhY3Rpb25CdXR0b24uanNcblxuICAvKipcbiAgICogQ29uc29saWRhdGVkIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgZW50aXJlIGRvdCBwcm9jZXNzOiBkcmF3aW5nLCBjb3VudGRvd24sIGNhcHR1cmUsIGFuZCBwcmV2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IGNvb3JkaW5hdGVzIHdoZXJlIHRvIGRyYXcgdGhlIGRvdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU3RhdHVzVXBkYXRlIC0gQ2FsbGJhY2sgZm9yIHN0YXR1cyB1cGRhdGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRyaWdnZXJDYW1lcmFBY2Nlc3MgLSBGdW5jdGlvbiB0byBlbnN1cmUgY2FtZXJhIGlzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldElzQ2FwdHVyaW5nIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmluZyBzdGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnQgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudCAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy51c2VSYW5kb21Qb3NpdGlvbiAtIFdoZXRoZXIgdG8gZ2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZSBkYXRhXG4gICAqL1xuICAvLyBNb2RpZmllZCBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggaW1wcm92ZWQgZG90IGFuZCBjb3VudGRvd24gYWxpZ25tZW50XG4gIGNvbnN0IGhhbmRsZURvdFByb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICB1c2VSYW5kb21Qb3NpdGlvbiA9IGZhbHNlLFxuICAgICAgcG9zdENvdW50ZG93bkRlbGF5ID0gNTAwIFxuICAgIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHNob3dpbmcgdGhlIGRvdFxuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZVxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiB1c2VSYW5kb21Qb3NpdGlvbiA/ICdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nIDogJ1N0YXJ0aW5nIGRvdCBwcm9jZXNzLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlIHdpdGggcmV0cmllc1xuICAgICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICAgIFxuICAgICAgd2hpbGUgKCFjYW52YXMgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FudmFzIG5vdCBmb3VuZCwgcmV0cnkgJHtyZXRyeUNvdW50ICsgMX0vJHttYXhSZXRyaWVzfWApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllc1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZSBmb3IgcmVzdG9yYXRpb25cbiAgICAgIGNvbnN0IG9yaWdpbmFsUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBvcmlnaW5hbFN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcblxuICAgICAgLy8gUHJlcGFyZSBjYW52YXMgZm9yIGZ1bGxzY3JlZW4gZGlzcGxheVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgXG4gICAgICAvLyBTZXQgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3cgZXhhY3RseVxuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgICAgY29uc3QgZG90UG9zaXRpb24gPSB1c2VSYW5kb21Qb3NpdGlvbiBcbiAgICAgICAgPyBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKSBcbiAgICAgICAgOiBwb3NpdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKCFkb3RQb3NpdGlvbiB8fCB0eXBlb2YgZG90UG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDEyO1xuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSByZWRyYXcgaW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICBsZXQga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgfSwgNTApOyAgLy8gTW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJpbGl0eVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBjb3VudGRvd24gZWxlbWVudCBkaXJlY3RseSBvbiB0b3Agb2YgdGhlIGRvdFxuICAgICAgLy8gSW1wb3J0YW50OiBQb3NpdGlvbiB0aGUgY291bnRkb3duIGNlbnRlcmVkIGRpcmVjdGx5IG92ZXIgdGhlIGRvdFxuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgbGVmdDogJHtkb3RQb3NpdGlvbi54fXB4O1xuICAgICAgICB0b3A6ICR7ZG90UG9zaXRpb24ueX1weDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRyYXcgdGhlIGRvdCBmb3IgcmVsaWFiaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkaXRpb25hbCByZWRyYXcgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgYWZ0ZXIgY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHBvc3RDb3VudGRvd25EZWxheSkpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgIHBvaW50OiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgY2xlYXJJbnRlcnZhbChrZWVwRG90VmlzaWJsZUludGVydmFsKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBjYW52YXMgdG8gb3JpZ2luYWwgc3RhdGVcbiAgICAgIGlmIChvcmlnaW5hbFBhcmVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCAhPT0gb3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgICAgb3JpZ2luYWxQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxTdHlsZS5wb3NpdGlvbiB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbFN0eWxlLnRvcCB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gb3JpZ2luYWxTdHlsZS5sZWZ0IHx8ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gb3JpZ2luYWxTdHlsZS53aWR0aCB8fCAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxTdHlsZS5oZWlnaHQgfHwgJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IG9yaWdpbmFsU3R5bGUuekluZGV4IHx8ICcnO1xuICAgICAgXG4gICAgICAvLyBSZXNldCBkaW1lbnNpb25zXG4gICAgICBpZiAob3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0NhcHR1cmUgY29tcGxldGVkJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAyMDAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IGRvdFBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlUmVzdWx0XG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBoYW5kbGVEb3RQcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIERlY2xhcmUgdGhlc2UgdmFyaWFibGVzIE9VVFNJREUgdGhlIHRyeSBibG9ja1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1BhcmVudCA9IG51bGw7XG4gICAgbGV0IG9yaWdpbmFsQ2FudmFzU3R5bGUgPSB7fTtcbiAgICBsZXQgc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBIaWRlIFRvcEJhclxuICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIlN0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlXG4gICAgICBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKFwiRXJyb3I6IENhbnZhcyBub3QgZm91bmRcIik7XG4gICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGVcbiAgICAgIG9yaWdpbmFsQ2FudmFzUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBvcmlnaW5hbENhbnZhc1N0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTW92ZSBjYW52YXMgdG8gYm9keSBmb3IgbWF4aW11bSByZWxpYWJpbGl0eVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgXG4gICAgICAvLyBNYWtlIGNhbnZhcyBmdWxsc2NyZWVuIHdpdGggZml4ZWQgcG9zaXRpb25pbmdcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgIFxuICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93IGV4YWN0bHlcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgc2V0IHRvIGZ1bGxzY3JlZW46ICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcblxuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIHRoZSBjYW52YXMgc2l6ZVxuICAgICAgY29uc3QgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJyk7XG4gICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgXG4gICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgIHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgcmVkcmF3IGludGVydmFsXG4gICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBkaXNwbGF5c1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGNhbnZhcyBpZiBkaW1lbnNpb25zIGNoYW5nZWRcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYW52YXMgZGltZW5zaW9ucyBjaGFuZ2VkLiBSZXNldHRpbmcgdG8gJHtjYW52YXNXaWR0aH14JHtjYW52YXNIZWlnaHR9YCk7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5IGFuZCBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBjb25zdCByYWRpdXMgPSAxNDsgLy8gU2xpZ2h0bHkgbGFyZ2VyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGZ1bmN0aW9uIGZvciB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHJlZHJhd0N1cnJlbnREb3QgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVmVyaWZ5IGNhbnZhcyBkaW1lbnNpb25zIGFuZCBwYXJlbnRcbiAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGJvZHlcbiAgICAgICAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVkcmF3IGRvdCB3aXRob3V0IGNsZWFyaW5nXG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgcmVkcmF3IGludGVydmFsIC0gbW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJsZSBkb3QgdmlzaWJpbGl0eVxuICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChyZWRyYXdDdXJyZW50RG90LCA1MCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7IC8vIENvbnNpc3RlbnQgY2xhc3MgbmFtZVxuICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIGxlZnQ6ICR7cG9pbnQueH1weDtcbiAgICAgICAgICB0b3A6ICR7cG9pbnQueSAtIDYwfXB4O1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3IG11bHRpcGxlIHRpbWVzIGR1cmluZyBjb3VudGRvd24gdG8gZW5zdXJlIHZpc2liaWxpdHlcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0IHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuXG4gICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtwb2ludC54fSwgJHtwb2ludC55fSlgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYW51YWwgZm9yY2UgcmVkcmF3IG9uZSBtb3JlIHRpbWUganVzdCBiZWZvcmUgY2FwdHVyZVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIENsZWFuIHVwIGNvdW50ZG93biBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgIH1cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbGlicmF0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCByZWRyYXcgaW50ZXJ2YWxcbiAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZW1vdmUgc3RhdHVzIGluZGljYXRvciBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IgJiYgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgY2FudmFzIHRvIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGluZyAtIE9ubHkgaWYgY2FudmFzIHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWRcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBvcmlnaW5hbCBwYXJlbnRcbiAgICAgICAgICBpZiAob3JpZ2luYWxDYW52YXNQYXJlbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IG9yaWdpbmFsQ2FudmFzUGFyZW50KSB7XG4gICAgICAgICAgICBvcmlnaW5hbENhbnZhc1BhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW9yaWdpbmFsQ2FudmFzUGFyZW50KSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBsb29raW5nIGZvciBhIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJyk7XG4gICAgICAgICAgICBpZiAocG9zc2libGVQYXJlbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IHBvc3NpYmxlUGFyZW50KSB7XG4gICAgICAgICAgICAgIHBvc3NpYmxlUGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlc3RvcmUgc3R5bGluZ1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsQ2FudmFzU3R5bGUucG9zaXRpb24gfHwgJyc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUudG9wIHx8ICcnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gb3JpZ2luYWxDYW52YXNTdHlsZS5sZWZ0IHx8ICcnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUud2lkdGggfHwgJzEwMCUnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbENhbnZhc1N0eWxlLmhlaWdodCB8fCAnMTAwJSc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUuekluZGV4IHx8ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlc2V0IGRpbWVuc2lvbnMgYmFzZWQgb24gcGFyZW50XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gODAwO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IDYwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbnZhcyByZXN0b3JlZCB0byBvcmlnaW5hbCBzdGF0ZVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZXN0b3JpbmcgY2FudmFzOlwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTZXRSYW5kb20gPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFsd2F5cyBnZXQgdGhlIGxhdGVzdCBzZXR0aW5ncyBmcm9tIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdID8gc2V0dGluZ3NbY3VycmVudFVzZXJJZF0gOiB7fTtcbiAgICAgIGNvbnN0IHRpbWVzID0gTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCBOdW1iZXIocmFuZG9tVGltZXMpIHx8IDE7XG4gICAgICBjb25zdCBkZWxheSA9IE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgTnVtYmVyKGRlbGF5U2Vjb25kcykgfHwgMztcblxuICAgICAgLy8gTG9nIGN1cnJlbnQgc2V0dGluZ3MgYmVmb3JlIHN0YXJ0aW5nXG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgU2V0IFJhbmRvbSB3aXRoIHNldHRpbmdzOicsIHtcbiAgICAgICAgcmFuZG9tVGltZXMsXG4gICAgICAgIGRlbGF5U2Vjb25kcyxcbiAgICAgICAgY3VycmVudFVzZXJJZCxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgIHVzZXJTZXR0aW5ncyxcbiAgICAgICAgdGltZXMsXG4gICAgICAgIGRlbGF5XG4gICAgICB9KTtcblxuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgU3RhcnRpbmcgJHt0aW1lc30gcmFuZG9tIGNhcHR1cmVzIHdpdGggJHtkZWxheX1zIGRlbGF5Li4uYCk7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIGNhcHR1cmVzIGluIHNlcXVlbmNlXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgY3VycmVudEluZGV4ID0gMTsgY3VycmVudEluZGV4IDw9IHRpbWVzOyBjdXJyZW50SW5kZXgrKykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMgLSBjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlICR7Y3VycmVudEluZGV4fSBvZiAke3RpbWVzfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIGhhbmRsZURvdFByb2Nlc3MgZm9yIGVhY2ggY2FwdHVyZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgICAgICB1c2VSYW5kb21Qb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9LyR7dGltZXN9OiAke3N0YXR1cy5wcm9jZXNzU3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IFRvcEJhciBhZnRlciB0aGUgbGFzdCBjYXB0dXJlXG4gICAgICAgICAgICBpZiAoc2hvdyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHNob3cgeWV0IGZvciBpbnRlcm1lZGlhdGUgY2FwdHVyZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoc2hvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgICAgIHNldElzQ2FwdHVyaW5nOiAoY2FwdHVyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCBjYXB0dXJpbmcgdG8gZmFsc2UgYWZ0ZXIgYWxsIGNhcHR1cmVzXG4gICAgICAgICAgICBpZiAoIWNhcHR1cmluZyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIFN0YXkgaW4gY2FwdHVyaW5nIHN0YXRlIGJldHdlZW4gZG90c1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoY2FwdHVyaW5nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiA4MDBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgY2FwdHVyZSAke2N1cnJlbnRJbmRleH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG1heSBoYXZlIGZhaWxlZDpgLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgLSBidXQgb25seSBpZiB0aGVyZSBhcmUgbW9yZSBjYXB0dXJlcyB0byBnb1xuICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IGNhcHR1cmVzIHN1Y2Nlc3NmdWxgKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgICAgY29uc29sZS5sb2coYENvbXBsZXRlZCBhbGwgY2FwdHVyZXM6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBzdWNjZXNzZnVsYCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJhbmRvbSBzZXF1ZW5jZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUmFuZG9tIHNlcXVlbmNlIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGhhbmRsZVJhbmRvbURvdCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBVc2UgdGhlIGNvbnNvbGlkYXRlZCBmdW5jdGlvbiB3aXRoIHJhbmRvbSBwb3NpdGlvblxuICAgIGF3YWl0IGhhbmRsZURvdFByb2Nlc3Moe1xuICAgICAgdXNlUmFuZG9tUG9zaXRpb246IHRydWUsXG4gICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICBpZiAoc3RhdHVzLmlzQ2FwdHVyaW5nICE9PSB1bmRlZmluZWQpIHNldElzQ2FwdHVyaW5nKHN0YXR1cy5pc0NhcHR1cmluZyk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiAxMDAwXG4gICAgfSk7XG4gIH07XG4gIFxuXG4gIC8vIExvYWQgY2FsaWJyYXRpb24gc2V0dXBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIGNvbnN0IHNldHVwQ2FsaWJyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IENhbGlicmF0ZUhhbmRsZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyJyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW52YXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgc2V0dXBDYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIG1ha2VDYW52YXNGdWxsc2NyZWVuKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhcyBzaXplOicsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0dlbmVyYXRlZCBjYWxpYnJhdGlvbiBwb2ludHM6JywgcG9pbnRzKTtcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25Qb2ludHMocG9pbnRzKTtcbiAgICBcbiAgICAgICAgY29uc3QgY2FsaWJyYXRlSGFuZGxlciA9IG5ldyBDYWxpYnJhdGVIYW5kbGVyKHtcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgY2FsaWJyYXRpb25Qb2ludHM6IHBvaW50cyxcbiAgICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiBvbkFjdGlvbkNsaWNrPy4oJ3RvZ2dsZVRvcEJhcicsIHNob3cpLFxuICAgICAgICAgIHNldE91dHB1dFRleHQ6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudGVyOiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0NvdW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KHByZXYgPT4gbmV3Q291bnRlcihwcmV2KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQobmV3Q291bnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBzZXRDYWxpYnJhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgIGhhbmRsZUFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbi4uLicpO1xuICAgICAgICAgICAgYXdhaXQgY2FsaWJyYXRlSGFuZGxlci5zdGFydENhbGlicmF0aW9uKCk7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIHJlc3RvcmVDYW52YXNTaXplKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY2FsaWJyYXRpb246JywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0dXBDYWxpYnJhdGlvbigpO1xuICB9LCBbY2FwdHVyZUNvdW50LCBvbkFjdGlvbkNsaWNrXSk7XG4gIFxuICAvLyBDbGVhciBBbGwgQnV0dG9uIC0gUmVzZXQgZXZlcnl0aGluZ1xuICBjb25zdCBoYW5kbGVDbGVhckFsbCA9ICgpID0+IHtcbiAgICBjbGVhckNhbnZhcygpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSBIZWFkIFBvc2UgdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVIZWFkUG9zZSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdIZWFkUG9zZVN0YXRlID0gIXNob3dIZWFkUG9zZTtcbiAgICBzZXRTaG93SGVhZFBvc2UobmV3SGVhZFBvc2VTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgSGVhZCBwb3NlIHZpc3VhbGl6YXRpb24gJHtuZXdIZWFkUG9zZVN0YXRlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnaGVhZFBvc2UnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93SGVhZFBvc2U6IG5ld0hlYWRQb3NlU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBoZWFkIHBvc2U6ICR7bmV3SGVhZFBvc2VTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEJvdW5kaW5nIEJveCB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94ID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0JvdW5kaW5nQm94U3RhdGUgPSAhc2hvd0JvdW5kaW5nQm94O1xuICAgIHNldFNob3dCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveFN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBCb3VuZGluZyBib3ggJHtuZXdCb3VuZGluZ0JveFN0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdib3VuZGluZ0JveCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dCb3VuZGluZ0JveDogbmV3Qm91bmRpbmdCb3hTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGJvdW5kaW5nIGJveDogJHtuZXdCb3VuZGluZ0JveFN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgTWFzayB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZU1hc2sgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFza1N0YXRlID0gIXNob3dNYXNrO1xuICAgIHNldFNob3dNYXNrKG5ld01hc2tTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgTWFzayAke25ld01hc2tTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnbWFzaycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dNYXNrOiBuZXdNYXNrU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBtYXNrOiAke25ld01hc2tTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIFBhcmFtZXRlcnMgZGlzcGxheVxuICBjb25zdCBoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld1BhcmFtZXRlcnNTdGF0ZSA9ICFzaG93UGFyYW1ldGVycztcbiAgICBzZXRTaG93UGFyYW1ldGVycyhuZXdQYXJhbWV0ZXJzU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYFBhcmFtZXRlcnMgJHtuZXdQYXJhbWV0ZXJzU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3BhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93UGFyYW1ldGVyczogbmV3UGFyYW1ldGVyc1N0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgcGFyYW1ldGVyczogJHtuZXdQYXJhbWV0ZXJzU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBjYW1lcmEgcHJldmlld1xuICBjb25zdCBoYW5kbGVUb2dnbGVDYW1lcmEgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Q2FtZXJhU3RhdGUgPSAhaXNDYW1lcmFBY3RpdmU7XG4gICAgc2V0SXNDYW1lcmFBY3RpdmUobmV3Q2FtZXJhU3RhdGUpO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHdpdGggJ3ByZXZpZXcnIGFjdGlvblxuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdwcmV2aWV3JywgbmV3Q2FtZXJhU3RhdGUpOyAvLyBQYXNzIHRoZSBuZXcgc3RhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IHRyaWdnZXIgaWYgbm8gYWN0aW9uIGhhbmRsZXJcbiAgICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHR1cm5pbmcgb24gY2FtZXJhLCBlbnN1cmUgd2UgYXBwbHkgY3VycmVudCB2aXN1YWxpemF0aW9uIHNldHRpbmdzXG4gICAgaWYgKG5ld0NhbWVyYVN0YXRlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgLy8gV2FpdCBhIHNob3J0IG1vbWVudCB0byBlbnN1cmUgdGhlIHZpZGVvIGVsZW1lbnQgaXMgcmVhZHlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgc2hvd0hlYWRQb3NlLFxuICAgICAgICAgICAgc2hvd0JvdW5kaW5nQm94LFxuICAgICAgICAgICAgc2hvd01hc2ssXG4gICAgICAgICAgICBzaG93UGFyYW1ldGVyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYmFjayBidXR0b24gaGFuZGxlclxuICBjb25zdCBoYW5kbGVHb0JhY2sgPSAoKSA9PiB7XG4gICAgcm91dGVyLnB1c2goJy8nKTtcbiAgfTtcblxuICAvLyBNb2JpbGUgbGF5b3V0IC0gMng1IGdyaWRcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAge2lzQ29tcGFjdE1vZGUgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMiBtYi00XCI+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTJcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIHsvKiBTdGF0dXMgZGlzcGxheSB3aXRoIG1lbW9pemF0aW9uICovfVxuICAgICAge3VzZU1lbW8oKCkgPT4gKFxuICAgICAgICAocHJvY2Vzc1N0YXR1cyB8fCByZW1haW5pbmdDYXB0dXJlcyA+IDAgfHwgY291bnRkb3duVmFsdWUpICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN0YXR1cy1kaXNwbGF5IG10LTQgcC0yIGJnLWJsdWUtNTAgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAge3Byb2Nlc3NTdGF0dXMgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ibHVlLTgwMFwiPntwcm9jZXNzU3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtyZW1haW5pbmdDYXB0dXJlcyA+IDAgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC15ZWxsb3ctNjAwXCI+UmVtYWluaW5nOiB7cmVtYWluaW5nQ2FwdHVyZXN9PC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2NvdW50ZG93blZhbHVlICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC1yZWQtNjAwXCI+e2NvdW50ZG93blZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgICAgKSwgW3Byb2Nlc3NTdGF0dXMsIHJlbWFpbmluZ0NhcHR1cmVzLCBjb3VudGRvd25WYWx1ZV0pfVxuICAgICAgXG4gICAgICB7LyogQ2FudmFzIGZvciBkcmF3aW5nIGRvdHMgKi99XG4gICAgICB7c2hvd0NhbnZhcyAmJiAoXG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgY2xhc3NOYW1lPVwiY2FudmFzLWNvbnRhaW5lciBtdC00XCIgXG4gICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICc0MHZoJyxcbiAgICAgICAgICAgIG1pbkhlaWdodDogJzMwMHB4JyxcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZTBlMGUwJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGNhbnZhcyBcbiAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidHJhY2tpbmctY2FudmFzXCJcbiAgICAgICAgICAgIGlkPVwidHJhY2tpbmctY2FudmFzXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycgLy8gRW5zdXJlIGNhbnZhcyBpcyBkaXNwbGF5ZWQgYXMgYmxvY2tcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkxvYWQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgY2FudmFzIHdoZW4gaXQgbG9hZHNcbiAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogT3ZlcmxheSBmb3IgY291bnRkb3duIG9uIGRvdCAqL31cbiAgICAgICAgICB7Y291bnRkb3duVmFsdWUgJiYgY3VycmVudERvdCAmJiAoXG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkb3QtY291bnRkb3duXCJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtjdXJyZW50RG90LnggLSAxNX1weGAsXG4gICAgICAgICAgICAgICAgdG9wOiBgJHtjdXJyZW50RG90LnkgLSA0MH1weGAsXG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMjhweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgey8qIENhbWVyYSBQZXJtaXNzaW9uIFBvcHVwICovfVxuICAgICAge3Nob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMTVcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWRpYWxvZ1wiIFxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aDMgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDE1cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENhbWVyYSBBY2Nlc3MgUmVxdWlyZWRcbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tbWVzc2FnZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICBnYXA6ICcxMHB4J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7XG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFxuICBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiA8QWN0aW9uQnV0dG9uR3JvdXBJbm5lciB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPilcbiksIHsgc3NyOiBmYWxzZSB9KTtcbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgQWN0aW9uQnV0dG9uR3JvdXBcbi8vIGNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoQWN0aW9uQnV0dG9uR3JvdXBJbm5lciksIHsgc3NyOiBmYWxzZSB9KTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWN0aW9uQnV0dG9uUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59XG5cbmV4cG9ydCB7IEFjdGlvbkJ1dHRvbiwgQWN0aW9uQnV0dG9uR3JvdXAgfTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImR5bmFtaWMiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInJ1bkNvdW50ZG93biIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwidXNlUm91dGVyIiwidXNlQWRtaW5TZXR0aW5ncyIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsIkFjdGlvbkJ1dHRvbiIsInRleHQiLCJhYmJyZXZpYXRlZFRleHQiLCJvbkNsaWNrIiwiY3VzdG9tQ2xhc3MiLCJkaXNhYmxlZCIsImFjdGl2ZSIsImlzQWJicmV2aWF0ZWQiLCJzZXRJc0FiYnJldmlhdGVkIiwic2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJidXR0b25Qcm9wcyIsImNsYXNzTmFtZSIsInRpdGxlIiwidGltZW91dElkIiwiaGFuZGxlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJ0eXBlIiwibmV3VXNlcklkIiwidXNlcklkIiwiYnV0dG9uIiwiZGl2IiwiQWN0aW9uQnV0dG9uR3JvdXBJbm5lciIsInJlZiIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsInJvdXRlciIsInVwZGF0ZVNldHRpbmdzIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbnZhc1JlZiIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJjdXJyZW50Q2FsaWJyYXRpb25JbmRleCIsInNldEN1cnJlbnRDYWxpYnJhdGlvbkluZGV4IiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzZXRSZW1haW5pbmdDYXB0dXJlcyIsInNob3dDYW52YXMiLCJzZXRTaG93Q2FudmFzIiwiY2FsaWJyYXRpb25IYW5kbGVyIiwic2V0Q2FsaWJyYXRpb25IYW5kbGVyIiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0hlYWRQb3NlIiwic2V0U2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2V0U2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzZXRTaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2V0U2hvd1BhcmFtZXRlcnMiLCJpc0NhbWVyYUFjdGl2ZSIsInNldElzQ2FtZXJhQWN0aXZlIiwic2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldFNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXR0aW5nc0NhY2hlIiwiTWFwIiwibGFzdFNldHRpbmdzVXBkYXRlIiwidXNlclNldHRpbmdzIiwiY2FjaGVkU2V0dGluZ3MiLCJjdXJyZW50IiwiZ2V0IiwiTnVtYmVyIiwidGltZXNfc2V0X3JhbmRvbSIsImRlbGF5X3NldF9yYW5kb20iLCJzZXQiLCJEYXRlIiwibm93IiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJ1bmRlZmluZWQiLCJuZXdUaW1lcyIsIm5ld0RlbGF5IiwiYWN0aW9uQnV0dG9uRnVuY3Rpb25zIiwiaGFuZGxlUmFuZG9tRG90IiwiaGFuZGxlU2V0UmFuZG9tIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwiaGFuZGxlQ2xlYXJBbGwiLCJ1cGRhdGVDb250cm9sVmFsdWVzIiwidGltZUlucHV0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGltZVZhbHVlIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImlzTmFOIiwiY29uc29sZSIsImxvZyIsImRlbGF5SW5wdXQiLCJkZWxheVZhbHVlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImNhbnZhcyIsInBhcmVudCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZXJyb3IiLCJnZXRNYWluQ2FudmFzIiwid2hpdGVTY3JlZW5DYW52YXMiLCJzZWxlY3RvcnMiLCJzZWxlY3RvciIsImNhbnZhc0VsZW1lbnQiLCJtYWtlQ2FudmFzRnVsbHNjcmVlbiIsInBhcmVudEVsZW1lbnQiLCJib2R5Iiwic3R5bGUiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ6SW5kZXgiLCJpbm5lckhlaWdodCIsInJlc3RvcmVDYW52YXNTaXplIiwiaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkIiwiaGFuZGxlUGVybWlzc2lvbkRlbmllZCIsInJlc3RvcmVDYW52YXMiLCJvcmlnaW5hbFBhcmVudCIsIm9yaWdpbmFsU3R5bGUiLCJhcHBlbmRDaGlsZCIsImNsZWFyQ2FudmFzIiwid2FybiIsImhhbmRsZURvdFByb2Nlc3MiLCJvcHRpb25zIiwib25TdGF0dXNVcGRhdGUiLCJ0b2dnbGVUb3BCYXIiLCJ1c2VSYW5kb21Qb3NpdGlvbiIsInBvc3RDb3VudGRvd25EZWxheSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmV0cnlDb3VudCIsIm1heFJldHJpZXMiLCJFcnJvciIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZG90UG9zaXRpb24iLCJ4IiwieSIsImRvdFJhZGl1cyIsImtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImV4aXN0aW5nQ291bnRkb3ducyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjb3VudGRvd25FbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNzc1RleHQiLCJjb3VudCIsInRleHRDb250ZW50IiwiY2FwdHVyZVJlc3VsdCIsInBvaW50IiwiY2xlYXJJbnRlcnZhbCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwib3JpZ2luYWxDYW52YXNQYXJlbnQiLCJvcmlnaW5hbENhbnZhc1N0eWxlIiwic3RhdHVzSW5kaWNhdG9yIiwiY3VycmVudFJlZHJhd0ludGVydmFsIiwicG9pbnRzIiwic3VjY2Vzc0NvdW50IiwiaSIsInJhZGl1cyIsInJlZHJhd0N1cnJlbnREb3QiLCJzY3JlZW5JbWFnZSIsInBvc3NpYmxlUGFyZW50IiwiZSIsInRpbWVzIiwiZGVsYXkiLCJjdXJyZW50SW5kZXgiLCJyZXN1bHQiLCJzdGF0dXMiLCJzaG93IiwiY2FwdHVyaW5nIiwic2V0dXBDYWxpYnJhdGlvbiIsImRlZmF1bHQiLCJDYWxpYnJhdGVIYW5kbGVyIiwiY2FsaWJyYXRlSGFuZGxlciIsInNldE91dHB1dFRleHQiLCJuZXdDb3VudGVyIiwicHJldiIsImNhcHR1cmVGb2xkZXIiLCJvbkNvbXBsZXRlIiwiaGFuZGxlQWN0aW9uIiwic3RhcnRDYWxpYnJhdGlvbiIsImVyciIsImhhbmRsZVRvZ2dsZUhlYWRQb3NlIiwibmV3SGVhZFBvc2VTdGF0ZSIsInZpZGVvUHJvY2Vzc29yIiwidXBkYXRlT3B0aW9ucyIsImhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94IiwibmV3Qm91bmRpbmdCb3hTdGF0ZSIsImhhbmRsZVRvZ2dsZU1hc2siLCJuZXdNYXNrU3RhdGUiLCJoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzIiwibmV3UGFyYW1ldGVyc1N0YXRlIiwiaGFuZGxlVG9nZ2xlQ2FtZXJhIiwibmV3Q2FtZXJhU3RhdGUiLCJoYW5kbGVHb0JhY2siLCJwdXNoIiwibWluSGVpZ2h0IiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyUmFkaXVzIiwib3ZlcmZsb3ciLCJpZCIsImRpc3BsYXkiLCJvbkxvYWQiLCJ0YXJnZXQiLCJjb2xvciIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJoMyIsIm1hcmdpbiIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiY3Vyc29yIiwiQWN0aW9uQnV0dG9uR3JvdXAiLCJwcm9wcyIsInNzciIsIkFjdGlvbkJ1dHRvblBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/index.js":
/*!*****************************************************!*\
  !*** ./pages/collected-dataset-customized/index.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollectedDatasetPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"(pages-dir-browser)/./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_gui_topBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components-gui/topBar */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/topBar.js\");\n/* harmony import */ var _components_gui_displayResponse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components-gui/displayResponse */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/displayResponse.js\");\n/* harmony import */ var _components_gui_actionButton__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components-gui/actionButton */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/consent/ConsentContext */ \"(pages-dir-browser)/./components/consent/ConsentContext.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_9__);\n// Modified index.js - Fixing canvas reference issues\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// import { generateCalibrationPoints } from '../../components/collected-dataset-customized/Action/CalibratePoints';\n\n\n// Dynamically load the video processor component (not the hook directly)\nconst VideoProcessorComponent = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_pages_collected-dataset-customized_components-gui_VideoProcessorComponent_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/VideoProcessorComponent */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/VideoProcessorComponent.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"pages/collected-dataset-customized/index.js -> \" + \"./components-gui/VideoProcessorComponent\"\n        ]\n    },\n    ssr: false\n});\n_c = VideoProcessorComponent;\n// Dynamically import the camera component with SSR disabled\nconst DynamicCameraAccess = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_pages_collected-dataset-customized_components-gui_cameraAccess_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/cameraAccess */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/cameraAccess.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"pages/collected-dataset-customized/index.js -> \" + \"./components-gui/cameraAccess\"\n        ]\n    },\n    ssr: false,\n    loading: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                position: 'absolute',\n                top: '50%',\n                left: '50%',\n                transform: 'translate(-50%, -50%)',\n                width: '480px',\n                height: '360px',\n                backgroundColor: '#f0f8ff',\n                border: '2px solid #0066cc',\n                borderRadius: '8px',\n                display: 'flex',\n                flexDirection: 'column',\n                justifyContent: 'center',\n                alignItems: 'center',\n                textAlign: 'center',\n                zIndex: 999\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        fontSize: '48px',\n                        marginBottom: '15px'\n                    },\n                    children: \"\\uD83D\\uDCF7\"\n                }, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 42,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    style: {\n                        fontSize: '16px',\n                        fontWeight: 'bold',\n                        color: '#0066cc'\n                    },\n                    children: \"Loading camera...\"\n                }, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/app/pages/collected-dataset-customized/index.js\",\n            lineNumber: 25,\n            columnNumber: 7\n        }, undefined)\n});\n_c1 = DynamicCameraAccess;\nfunction CollectedDatasetPage() {\n    _s();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_9__.useRouter)();\n    const { userId: consentUserId } = (0,_components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_8__.useConsent)();\n    const [userData, setUserData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isHydrated, setIsHydrated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [backendStatus, setBackendStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('checking');\n    const [showTopBar, setShowTopBar] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showWarning, setShowWarning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [warningMessage, setWarningMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [statusMessage, setStatusMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [outputText, setOutputText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [showMetrics, setShowMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [cameraPermissionGranted, setCameraPermissionGranted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showCamera, setShowCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showCameraPlaceholder, setShowCameraPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [windowSize, setWindowSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0,\n        percentage: 100\n    });\n    const [metrics, setMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: '---',\n        height: '---',\n        distance: '---'\n    });\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [captureFolder, setCaptureFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [showSettings, setShowSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Refs\n    const previewAreaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const actionButtonGroupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Set hydrated state after mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            setIsHydrated(true);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Load user data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const loadUserData = {\n                \"CollectedDatasetPage.useEffect.loadUserData\": async ()=>{\n                    if (!router.isReady) return;\n                    try {\n                        if (router.query.userData) {\n                            const parsedData = JSON.parse(router.query.userData);\n                            setUserData(parsedData);\n                            return;\n                        }\n                        if (router.query.userId) {\n                            const response = await fetch(\"/user-preferences/\".concat(router.query.userId), {\n                                headers: {\n                                    'Accept': 'application/json',\n                                    'Content-Type': 'application/json',\n                                    'X-API-Key': \"A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV\" || 0\n                                }\n                            });\n                            if (!response.ok) {\n                                throw new Error('Failed to fetch user data');\n                            }\n                            const data = await response.json();\n                            setUserData(data);\n                        }\n                    } catch (err) {\n                        console.error('Error loading user data:', err);\n                        setError(err.message);\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.loadUserData\"];\n            loadUserData();\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        router.isReady,\n        router.query\n    ]);\n    // Check backend connection\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const checkBackendConnection = {\n                \"CollectedDatasetPage.useEffect.checkBackendConnection\": async ()=>{\n                    try {\n                        const response = await fetch('/api/check-backend-connection');\n                        const data = await response.json();\n                        setBackendStatus(data.connected ? 'connected' : 'disconnected');\n                    } catch (error) {\n                        console.error('Error checking backend connection:', error);\n                        setBackendStatus('disconnected');\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.checkBackendConnection\"];\n            if (isHydrated) {\n                checkBackendConnection();\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Update window size\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const updateDimensions = {\n                \"CollectedDatasetPage.useEffect.updateDimensions\": ()=>{\n                    if (previewAreaRef.current) {\n                        const width = previewAreaRef.current.offsetWidth;\n                        const height = previewAreaRef.current.offsetHeight;\n                        const screenPercentage = window.innerWidth / window.screen.width * 100;\n                        setMetrics({\n                            \"CollectedDatasetPage.useEffect.updateDimensions\": (prev)=>({\n                                    ...prev,\n                                    width,\n                                    height\n                                })\n                        }[\"CollectedDatasetPage.useEffect.updateDimensions\"]);\n                        setWindowSize({\n                            width: window.innerWidth,\n                            height: window.innerHeight,\n                            percentage: Math.round(screenPercentage)\n                        });\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.updateDimensions\"];\n            if (isHydrated) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                return ({\n                    \"CollectedDatasetPage.useEffect\": ()=>window.removeEventListener('resize', updateDimensions)\n                })[\"CollectedDatasetPage.useEffect\"];\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Initialize settings based on user data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (userData && consentUserId) {\n                console.log('Initializing settings for user:', consentUserId, userData);\n                // Initialize user-specific settings\n                if (userData.preferences) {\n                    const { preferences } = userData;\n                    // Update camera settings if available\n                    if (preferences.cameraSettings) {\n                        const { showHeadPose, showBoundingBox, showMask, showParameters } = preferences.cameraSettings;\n                        setShowHeadPose(showHeadPose || false);\n                        setShowBoundingBox(showBoundingBox || false);\n                        setShowMask(showMask || false);\n                        setShowParameters(showParameters || false);\n                    }\n                    // Update other settings as needed\n                    if (preferences.metrics) {\n                        setShowMetrics(preferences.metrics.show || true);\n                    }\n                    if (preferences.topBar) {\n                        setShowTopBar(preferences.topBar.show || true);\n                    }\n                }\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        userData,\n        consentUserId\n    ]);\n    // Improved get canvas function that tries multiple methods\n    const getMainCanvas = ()=>{\n        // Method 1: Check if we have a direct reference\n        if (canvasRef.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef.current;\n        }\n        // Method 2: Try to get global reference\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef.current = window.whiteScreenCanvas; // Update our ref\n            return window.whiteScreenCanvas;\n        }\n        // Method 3: Try to find via DOM\n        if (typeof document !== 'undefined') {\n            const canvasElement = document.querySelector('.tracking-canvas');\n            if (canvasElement) {\n                console.log(\"Found canvas via DOM selector\");\n                canvasRef.current = canvasElement; // Update our ref\n                if (true) {\n                    window.whiteScreenCanvas = canvasElement; // Update global ref too\n                }\n                return canvasElement;\n            }\n        }\n        console.warn(\"No canvas found via any method\");\n        return null;\n    };\n    // Check if we're on the client or server\n    const isClient = \"object\" !== 'undefined';\n    // Add effect to initialize canvas and make it globally available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Debug info to verify canvas size and availability\n            const canvas = canvasRef.current;\n            if (canvas) {\n                console.log(\"Index.js: Canvas initialized\", {\n                    width: canvas.width,\n                    height: canvas.height\n                });\n                // Make canvas EXPLICITLY available globally\n                window.whiteScreenCanvas = canvas;\n                // Also store canvas dimensions\n                window.canvasDimensions = {\n                    width: canvas.width,\n                    height: canvas.height\n                };\n            } else {\n                console.warn(\"Canvas reference is not available during initialization\");\n            }\n            // Expose canvas initialization function globally\n            window.initializeCanvas = ({\n                \"CollectedDatasetPage.useEffect\": (canvas, parent)=>{\n                    if (!canvas || !parent) {\n                        console.warn('[initializeCanvas] Canvas or parent is null', {\n                            canvas,\n                            parent\n                        });\n                        return false;\n                    }\n                    try {\n                        // Set canvas dimensions to match parent\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                        // Clear canvas and set white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        console.log(\"Canvas initialized with dimensions: \".concat(canvas.width, \"x\").concat(canvas.height));\n                        // Update global reference\n                        window.whiteScreenCanvas = canvas;\n                        window.canvasDimensions = {\n                            width: canvas.width,\n                            height: canvas.height\n                        };\n                        return true;\n                    } catch (error) {\n                        console.error('[initializeCanvas] Error initializing canvas:', error);\n                        return false;\n                    }\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n            // Check canvas visibility and force initialization after a brief delay\n            setTimeout({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    const canvas = getMainCanvas();\n                    if (canvas) {\n                        const rect = canvas.getBoundingClientRect();\n                        console.log(\"Canvas initial visibility check:\", {\n                            dimensions: \"\".concat(canvas.width, \"x\").concat(canvas.height),\n                            rectSize: \"\".concat(rect.width, \"x\").concat(rect.height),\n                            isVisible: rect.width > 0 && rect.height > 0\n                        });\n                        // Force initialization if needed\n                        adjustCanvasDimensions();\n                    } else {\n                        console.warn(\"Canvas not found during visibility check\");\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect\"], 500);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    delete window.whiteScreenCanvas;\n                    delete window.canvasDimensions;\n                    delete window.initializeCanvas;\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Improved canvas dimensions adjustment\n    const adjustCanvasDimensions = ()=>{\n        if (!isClient || !isHydrated || !previewAreaRef.current) return;\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found to adjust dimensions\");\n            return;\n        }\n        const container = previewAreaRef.current;\n        // Get the size of the preview area\n        const rect = container.getBoundingClientRect();\n        // Calculate proper height based on top bar visibility\n        const topBarHeight = showTopBar ? 120 : 0; // Adjust this value based on your top bar's actual height\n        console.log(\"Adjusting canvas dimensions\", {\n            containerWidth: rect.width,\n            containerHeight: rect.height,\n            topBarVisible: showTopBar,\n            calculatedHeight: rect.height\n        });\n        // Set canvas dimensions to match container size with top bar adjustment\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n        // Clear the canvas\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Fill with white background\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas dimensions adjusted: \".concat(canvas.width, \"x\").concat(canvas.height));\n        // Update global reference with current dimensions\n        window.whiteScreenCanvas = canvas;\n        window.canvasDimensions = {\n            width: canvas.width,\n            height: canvas.height\n        };\n    };\n    // Create a capture folder on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!captureFolder && isClient && isHydrated) {\n                const timestamp = new Date().toISOString().replace(/[:\\.]/g, '-');\n                setCaptureFolder(\"session_\".concat(timestamp));\n                console.log(\"Created capture folder: session_\".concat(timestamp));\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        captureFolder,\n        isClient,\n        isHydrated\n    ]);\n    // Check backend connection on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return; // Skip on server or before hydration\n            const checkBackendConnection = {\n                \"CollectedDatasetPage.useEffect.checkBackendConnection\": async ()=>{\n                    try {\n                        const response = await fetch('/api/check-backend-connection');\n                        const data = await response.json();\n                        setBackendStatus(data.connected ? 'connected' : 'disconnected');\n                        console.log(\"Backend connection: \".concat(data.connected ? 'OK' : 'Failed'));\n                        // Show status in output text\n                        setOutputText(\"Backend \".concat(data.connected ? 'connected' : 'disconnected - using mock mode'));\n                    } catch (error) {\n                        console.error('Error checking backend connection:', error);\n                        setBackendStatus('disconnected');\n                        setOutputText('Backend disconnected - using mock mode');\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.checkBackendConnection\"];\n            checkBackendConnection();\n            // Welcome message after backend check\n            setTimeout({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    setOutputText('Camera system ready. Click \"Show Preview\" to start camera.');\n                }\n            }[\"CollectedDatasetPage.useEffect\"], 2000);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Add styles to document head for button highlighting\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Create a style element\n            const style = document.createElement('style');\n            style.textContent = \"\\n      @keyframes pulse {\\n        0% { box-shadow: 0 0 0 0 rgba(0, 102, 204, 0.7); }\\n        70% { box-shadow: 0 0 0 10px rgba(0, 102, 204, 0); }\\n        100% { box-shadow: 0 0 0 0 rgba(0, 102, 204, 0); }\\n      }\\n      \\n      @keyframes fadeIn {\\n        from { opacity: 0; transform: translateY(-10px); }\\n        to { opacity: 1; transform: translateY(0); }\\n      }\\n      \\n      .btn-highlight {\\n        animation: pulse 1.5s infinite;\\n        background-color: #0099ff !important;\\n        color: white !important;\\n        transform: scale(1.05);\\n        transition: all 0.3s ease;\\n      }\\n      \\n      .warning-banner {\\n        animation: fadeIn 0.3s ease-in-out;\\n      }\\n    \";\n            document.head.appendChild(style);\n            // Clean up\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    document.head.removeChild(style);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Make toggleTopBar function available globally\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Make toggleTopBar available to other components\n            window.toggleTopBar = ({\n                \"CollectedDatasetPage.useEffect\": (show)=>{\n                    setShowTopBar(show);\n                    // Also hide metrics when hiding the top bar\n                    if (!show) {\n                        setShowMetrics(false);\n                    }\n                    // Adjust canvas dimensions after toggling\n                    setTimeout(adjustCanvasDimensions, 100);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    // Clean up\n                    delete window.toggleTopBar;\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Toggle camera function\n    const toggleCamera = (shouldEnable)=>{\n        if (!isClient || !isHydrated) return;\n        if (shouldEnable) {\n            setShowCamera(true);\n            setShowCameraPlaceholder(false);\n            setOutputText('Camera preview started');\n        } else {\n            setShowCamera(false);\n            setShowCameraPlaceholder(false);\n            setOutputText('Camera preview stopped');\n        }\n    };\n    // Handler for action button clicks\n    const handleActionButtonClick = (actionType, params)=>{\n        if (!isClient || !isHydrated) return;\n        // Special case for toggling the top bar\n        if (actionType === 'toggleTopBar') {\n            // const newTopBarState = value !== undefined ? !!value : !showTopBar;\n            let newTopBarState;\n            if (typeof params === 'boolean') {\n                newTopBarState = params;\n            } else if (params && typeof params.value !== 'undefined') {\n                newTopBarState = !!params.value;\n            } else {\n                newTopBarState = !showTopBar;\n            }\n            setShowTopBar(newTopBarState);\n            // Also hide metrics when hiding the top bar\n            if (!newTopBarState) {\n                setShowMetrics(false);\n            }\n            setOutputText(\"TopBar \".concat(newTopBarState ? 'shown' : 'hidden').concat(!newTopBarState ? ', Metrics hidden' : ''));\n            // Adjust canvas dimensions after toggling\n            setTimeout(adjustCanvasDimensions, 100);\n            return;\n        }\n        const canvas = getMainCanvas();\n        setShowWarning(false);\n        // Clear any existing warnings\n        const safeParams = params || {};\n        // Use safeParams instead of controlValues\n        const randomTimes = safeParams.randomTimes || 1;\n        const delaySeconds = safeParams.delaySeconds || 3;\n        switch(actionType){\n            case 'preview':\n                // Toggle camera state\n                if (showCamera) {\n                    toggleCamera(false);\n                } else if (cameraPermissionGranted) {\n                    toggleCamera(true);\n                } else {\n                    // Otherwise show permission popup\n                    setShowPermissionPopup(true);\n                    setOutputText('Opening camera preview');\n                    setShowCameraPlaceholder(true);\n                }\n                break;\n            case 'setRandom':\n                setOutputText('Starting random sequence...');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                // Use the imported module approach - similar to calibrate\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleSetRandom) {\n                    // Use the reference method if available\n                    console.log('Using ActionButtonGroup ref method for Set Random');\n                    actionButtonGroupRef.current.handleSetRandom();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleSetRandom === 'function') {\n                    // Fallback to global method\n                    console.log('Using global bridge method for Set Random');\n                    window.actionButtonFunctions.handleSetRandom();\n                } else {\n                    // Make sure we have a canvas to work with\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for random sequence\");\n                        setOutputText(\"Error: Canvas not available for random sequence\");\n                        setShowTopBar(true);\n                        return;\n                    }\n                    // Get control values from the TopBar\n                    const timeInput = document.querySelector('.control-input-field');\n                    const delayInput = document.querySelectorAll('.control-input-field')[1];\n                    // Default values if inputs can't be found\n                    let times = 1;\n                    let delay = 3;\n                    // Parse input values if available\n                    if (timeInput) {\n                        const parsedTime = parseInt(timeInput.value, 10);\n                        if (!isNaN(parsedTime) && parsedTime > 0) {\n                            times = parsedTime;\n                        }\n                    }\n                    if (delayInput) {\n                        const parsedDelay = parseInt(delayInput.value, 10);\n                        if (!isNaN(parsedDelay) && parsedDelay > 0) {\n                            delay = parsedDelay;\n                        }\n                    }\n                    // Load all required modules first, then proceed with execution\n                    Promise.all([\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\"))\n                    ]).then(async (param)=>{\n                        let [countSaveModule, savefileModule] = param;\n                        // Destructure the imported modules\n                        const { getRandomPosition, drawRedDot, runCountdown, showCapturePreview } = countSaveModule;\n                        const { captureImagesAtPoint } = savefileModule;\n                        try {\n                            // Process all captures sequentially\n                            let successCount = 0;\n                            let currentCapture = 1;\n                            while(currentCapture <= times){\n                                // Update status for current capture\n                                setOutputText(\"Capture \".concat(currentCapture, \" of \").concat(times));\n                                // Clear canvas before each capture\n                                const ctx = canvas.getContext('2d');\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                // Generate random position for this capture\n                                const position = getRandomPosition(canvas, 20);\n                                // Draw the dot\n                                drawRedDot(ctx, position.x, position.y);\n                                // Create a redrawInterval to ensure dot stays visible\n                                let redrawInterval = setInterval(()=>{\n                                    drawRedDot(ctx, position.x, position.y, 12, false);\n                                }, 200);\n                                // Run countdown and wait for it to complete\n                                await new Promise((resolve)=>{\n                                    runCountdown(position, canvas, (status)=>{\n                                        // Update UI based on status\n                                        if (status.processStatus) {\n                                            setOutputText(\"Capture \".concat(currentCapture, \"/\").concat(times, \": \").concat(status.processStatus));\n                                        }\n                                    }, resolve // This will be called when countdown completes\n                                    );\n                                });\n                                // Clear redrawInterval after countdown\n                                clearInterval(redrawInterval);\n                                // Wait briefly after countdown\n                                await new Promise((resolve)=>setTimeout(resolve, 500));\n                                // Capture images at this point\n                                try {\n                                    const captureResult = await captureImagesAtPoint({\n                                        point: position,\n                                        captureCount: captureCounter,\n                                        canvasRef: {\n                                            current: canvas\n                                        },\n                                        setCaptureCount: setCaptureCounter,\n                                        showCapturePreview\n                                    });\n                                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                        successCount++;\n                                    }\n                                    // Increment counter\n                                    setCaptureCounter((prev)=>prev + 1);\n                                } catch (error) {\n                                    console.error(\"Error capturing point \".concat(currentCapture, \":\"), error);\n                                }\n                                // Wait between captures for the specified delay time\n                                if (currentCapture < times) {\n                                    setOutputText(\"Waiting \".concat(delay, \"s before next capture...\"));\n                                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                                }\n                                // Move to next capture\n                                currentCapture++;\n                            }\n                            // Sequence complete\n                            setOutputText(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n                        } catch (error) {\n                            console.error(\"Random sequence error:\", error);\n                            setOutputText(\"Random sequence error: \".concat(error.message));\n                        } finally{\n                            // Show TopBar again\n                            setTimeout(()=>setShowTopBar(true), 2000);\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to import required modules:\", error);\n                        setOutputText(\"Error: \".concat(error.message));\n                        setShowTopBar(true);\n                    });\n                }\n                break;\n            case 'randomDot':\n                setOutputText('Random dot action triggered');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                console.log('Attempting to access Random Dot functionality');\n                // Use the random dot functionality from actionButton.js by delegating to ActionButtonGroup\n                // This assumes you have a ref to the ActionButtonGroup component\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleRandomDot) {\n                    console.log('Using ref method');\n                    actionButtonGroupRef.current.handleRandomDot();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleRandomDot === 'function') {\n                    console.log('Using global bridge method');\n                    window.actionButtonFunctions.handleRandomDot();\n                } else {\n                    // Fallback implementation\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for random dot action\");\n                        setOutputText(\"Error: Canvas not available for random dot\");\n                        setShowTopBar(true); // Show TopBar again if there's an error\n                        break;\n                    }\n                    const parent = previewAreaRef.current;\n                    if (!parent) {\n                        console.error(\"Parent not found for canvas\");\n                        setOutputText(\"Error: Canvas parent not available\");\n                        setShowTopBar(true);\n                        break;\n                    }\n                    // Initialize canvas explicitly\n                    canvas.width = parent.clientWidth || 800;\n                    canvas.height = parent.clientHeight || 600;\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas ready for random dot: \".concat(canvas.width, \"x\").concat(canvas.height));\n                    // Update global reference\n                    window.whiteScreenCanvas = canvas;\n                    // Generate random position\n                    const position = (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.getRandomPosition)(canvas, 20);\n                    // Draw the dot using the imported function\n                    const dot = (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.drawRedDot)(ctx, position.x, position.y, 8, false);\n                    console.log(\"Random dot drawn at: \".concat(position.x, \", \").concat(position.y));\n                    // Start a countdown for capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.runCountdown)(position, canvas, (status)=>{\n                        // Update UI based on status\n                        if (status.processStatus) {\n                            setOutputText(status.processStatus);\n                        }\n                    }, ()=>{\n                        // Enable camera before capture\n                        // triggerCameraAccess(true);\n                        // Wait briefly for camera to initialize\n                        setTimeout(()=>{\n                            // Use the directly imported captureImagesAtPoint from the Helper/savefile.js\n                            Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\")).then((param)=>{\n                                let { captureImagesAtPoint } = param;\n                                captureImagesAtPoint({\n                                    point: position,\n                                    captureCount: captureCounter,\n                                    canvasRef: {\n                                        current: canvas\n                                    },\n                                    setCaptureCount: setCaptureCounter,\n                                    showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.showCapturePreview\n                                }).then(()=>{\n                                    setCaptureCounter((prev)=>prev + 1);\n                                    // Show TopBar again after capture\n                                    setTimeout(()=>{\n                                        setShowTopBar(true);\n                                    }, 2200);\n                                }).catch((err)=>{\n                                    console.error(\"Error capturing images:\", err);\n                                    setOutputText(\"Error: \".concat(err.message));\n                                    setShowTopBar(true);\n                                });\n                            }).catch((err)=>{\n                                console.error(\"Error importing savefile module:\", err);\n                                setOutputText(\"Error: \".concat(err.message));\n                                setShowTopBar(true);\n                            });\n                        }, 500);\n                    });\n                }\n                break;\n            case 'headPose':\n                const newHeadPoseState = !showHeadPose;\n                setShowHeadPose(newHeadPoseState);\n                setOutputText(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n                if (newHeadPoseState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newHeadPoseState && !showBoundingBox && !showMask && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showHeadPose: newHeadPoseState\n                    });\n                }\n                break;\n            case 'boundingBox':\n                const newBoundingBoxState = !showBoundingBox;\n                setShowBoundingBox(newBoundingBoxState);\n                setOutputText(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n                if (newBoundingBoxState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newBoundingBoxState && !showHeadPose && !showMask && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showBoundingBox: newBoundingBoxState\n                    });\n                }\n                break;\n            case 'mask':\n                const newMaskState = !showMask;\n                setShowMask(newMaskState);\n                setOutputText(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n                if (newMaskState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newMaskState && !showHeadPose && !showBoundingBox && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showMask: newMaskState\n                    });\n                }\n                break;\n            case 'parameters':\n                const newParametersState = !showParameters;\n                setShowParameters(newParametersState);\n                setOutputText(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n                if (newParametersState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newParametersState && !showHeadPose && !showBoundingBox && !showMask) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showParameters: newParametersState\n                    });\n                }\n                break;\n            // Fixed calibrate case handler in index.js\n            case 'calibrate':\n                setOutputText('Starting calibration sequence...');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleSetCalibrate) {\n                    // Use the reference method if available\n                    console.log('Using ActionButtonGroup ref method for calibration');\n                    actionButtonGroupRef.current.handleSetCalibrate();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleSetCalibrate === 'function') {\n                    // Fallback to global method\n                    console.log('Using global bridge method for calibration');\n                    window.actionButtonFunctions.handleSetCalibrate();\n                } else {\n                    // Make sure we have a canvas to work with\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for calibration\");\n                        setOutputText(\"Error: Canvas not available for calibration\");\n                        setShowTopBar(true);\n                        return;\n                    }\n                    // Load all required modules first, then proceed with execution\n                    Promise.all([\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\"))\n                    ]).then(async (param)=>{\n                        let [calibratePointsModule, countSaveModule, savefileModule] = param;\n                        // Destructure the imported modules\n                        const { generateCalibrationPoints } = calibratePointsModule;\n                        const { drawRedDot, runCountdown, showCapturePreview } = countSaveModule;\n                        const { captureImagesAtPoint } = savefileModule;\n                        try {\n                            // Generate calibration points\n                            const points = generateCalibrationPoints(canvas.width, canvas.height);\n                            if (!points || points.length === 0) {\n                                throw new Error(\"Failed to generate calibration points\");\n                            }\n                            // Create status indicator\n                            const statusIndicator = document.createElement('div');\n                            statusIndicator.className = 'calibrate-status-indicator';\n                            statusIndicator.style.cssText = \"\\n                position: fixed;\\n                top: 10px;\\n                right: 10px;\\n                background-color: rgba(0, 102, 204, 0.9);\\n                color: white;\\n                font-size: 14px;\\n                font-weight: bold;\\n                padding: '8px 12px';\\n                border-radius: 6px;\\n                z-index: 9999;\\n                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n              \";\n                            statusIndicator.textContent = 'Calibration: Initializing...';\n                            document.body.appendChild(statusIndicator);\n                            // Access webcam before starting calibration if available\n                            if (typeof triggerCameraAccess === 'function') {\n                                triggerCameraAccess(true);\n                                await new Promise((resolve)=>setTimeout(resolve, 500));\n                            }\n                            // Process points sequentially\n                            let successCount = 0;\n                            for(let i = 0; i < points.length; i++){\n                                const point = points[i];\n                                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                                setOutputText(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                                // Clear the canvas before drawing new point\n                                const ctx = canvas.getContext('2d');\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                // Draw the dot\n                                drawRedDot(ctx, point.x, point.y);\n                                // Run countdown\n                                await new Promise((resolve)=>{\n                                    runCountdown(point, canvas, (status)=>{\n                                        if (status.processStatus) {\n                                            setOutputText(status.processStatus);\n                                        }\n                                    }, resolve // This will be called when countdown completes\n                                    );\n                                });\n                                // Capture images at this point\n                                try {\n                                    const captureResult = await captureImagesAtPoint({\n                                        point: point,\n                                        captureCount: captureCounter,\n                                        canvasRef: {\n                                            current: canvas\n                                        },\n                                        setCaptureCount: setCaptureCounter,\n                                        showCapturePreview: showCapturePreview\n                                    });\n                                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                        successCount++;\n                                    }\n                                    // Increment counter\n                                    setCaptureCounter((prev)=>prev + 1);\n                                } catch (error) {\n                                    console.error(\"Error capturing point \".concat(i + 1, \":\"), error);\n                                }\n                                // Wait between points\n                                await new Promise((resolve)=>setTimeout(resolve, 1200));\n                            }\n                            // Calibration complete\n                            statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                            setOutputText(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                            // Remove the status indicator after a delay\n                            setTimeout(()=>{\n                                if (statusIndicator.parentNode) {\n                                    statusIndicator.parentNode.removeChild(statusIndicator);\n                                }\n                            }, 3000);\n                        } catch (error) {\n                            console.error(\"Calibration error:\", error);\n                            setOutputText(\"Calibration error: \".concat(error.message));\n                        } finally{\n                            // Show TopBar again\n                            setTimeout(()=>setShowTopBar(true), 2000);\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to import required modules:\", error);\n                        setOutputText(\"Calibration error: \".concat(error.message));\n                        setShowTopBar(true);\n                    });\n                }\n                break;\n            case 'clearAll':\n                // Clear canvas\n                // const canvas = getMainCanvas();\n                if (canvas) {\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    setOutputText('Canvas cleared');\n                }\n                break;\n            default:\n                setOutputText(\"Action triggered: \".concat(actionType));\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        if (!isClient || !isHydrated) return;\n        setShowPermissionPopup(false);\n        setCameraPermissionGranted(true);\n        toggleCamera(true);\n    };\n    const handlePermissionDenied = ()=>{\n        if (!isClient || !isHydrated) return;\n        setShowPermissionPopup(false);\n        setShowCameraPlaceholder(false);\n        setOutputText('Camera permission denied');\n    };\n    const handleCameraClose = ()=>{\n        if (!isClient || !isHydrated) return;\n        toggleCamera(false);\n    };\n    const handleCameraReady = (dimensions)=>{\n        if (!isClient || !isHydrated) return;\n        setMetrics({\n            width: dimensions.width,\n            height: dimensions.height,\n            distance: dimensions.distance || '---'\n        });\n        setOutputText(\"Camera ready: \".concat(dimensions.width, \"x\").concat(dimensions.height));\n    };\n    // Toggle top bar function\n    const toggleTopBar = (show)=>{\n        const newTopBarState = show !== undefined ? show : !showTopBar;\n        setShowTopBar(newTopBarState);\n        // Also hide metrics when hiding the top bar\n        if (!newTopBarState) {\n            setShowMetrics(false);\n        }\n        setOutputText(\"TopBar \".concat(newTopBarState ? 'shown' : 'hidden').concat(!newTopBarState ? ', Metrics hidden' : ''));\n        // Wait for state update and DOM changes, then adjust canvas\n        setTimeout(adjustCanvasDimensions, 100);\n    };\n    // Toggle metrics function\n    const toggleMetrics = ()=>{\n        if (showTopBar) {\n            setShowMetrics((prev)=>!prev);\n            setOutputText(\"Metrics \".concat(!showMetrics ? 'shown' : 'hidden'));\n        } else {\n            // If topBar is hidden, we can't show metrics\n            setOutputText('Cannot show metrics when TopBar is hidden');\n        }\n    };\n    // Function to trigger camera access\n    const triggerCameraAccess = (forceEnable)=>{\n        if (forceEnable) {\n            // Try to enable camera directly\n            if (window.videoProcessor) {\n                setShowCamera(true);\n                setShowCameraPlaceholder(false);\n                setCameraPermissionGranted(true);\n                // Start video processing with current options\n                window.videoProcessor.startVideoProcessing({\n                    showHeadPose,\n                    showBoundingBox,\n                    showMask,\n                    showParameters,\n                    showProcessedImage: true\n                });\n                return true;\n            }\n            return false;\n        }\n        // Just toggle current state if not forcing\n        if (cameraPermissionGranted) {\n            toggleCamera(!showCamera);\n            return true;\n        } else {\n            setShowPermissionPopup(true);\n            return false;\n        }\n    };\n    // Dynamic class to reflect current window size\n    const getSizeClass = ()=>{\n        const { percentage } = windowSize;\n        if (percentage < 35) return 'window-size-tiny';\n        if (percentage < 50) return 'window-size-small';\n        if (percentage < 70) return 'window-size-medium';\n        return 'window-size-large';\n    };\n    // Add this function to handle settings visibility\n    const handleSettingsVisibility = (isVisible)=>{\n        setShowSettings(isVisible);\n    };\n    // Add this effect to listen for settings visibility changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleSettingsMessage = {\n                \"CollectedDatasetPage.useEffect.handleSettingsMessage\": (event)=>{\n                    if (event.data.type === 'SHOW_SETTINGS') {\n                        setShowSettings(event.data.show);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleSettingsMessage\"];\n            window.addEventListener('message', handleSettingsMessage);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('message', handleSettingsMessage);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"CollectedDatasetPage.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        setCurrentUserId(event.detail.userId);\n                        // Dispatch event to update settings for the new user\n                        const event = new CustomEvent('captureSettingsUpdate', {\n                            detail: {\n                                type: 'captureSettings',\n                                userId: event.detail.userId\n                            }\n                        });\n                        window.dispatchEvent(event);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Initialize settings when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (consentUserId) {\n                // Set the current user ID\n                setCurrentUserId(consentUserId);\n                // Dispatch event to update settings for this user\n                const event = new CustomEvent('captureSettingsUpdate', {\n                    detail: {\n                        type: 'captureSettings',\n                        userId: consentUserId\n                    }\n                });\n                window.dispatchEvent(event);\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Load settings from backend when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const loadSettings = {\n                \"CollectedDatasetPage.useEffect.loadSettings\": async ()=>{\n                    if (!consentUserId) return;\n                    try {\n                        const response = await fetch(\"/api/data-center/settings/\".concat(consentUserId));\n                        if (!response.ok) {\n                            throw new Error('Failed to load settings');\n                        }\n                        const loadedSettings = await response.json();\n                        // Wait for the component to be mounted and ref to be initialized\n                        const waitForRef = {\n                            \"CollectedDatasetPage.useEffect.loadSettings.waitForRef\": function() {\n                                let retries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n                                if (actionButtonGroupRef.current && typeof actionButtonGroupRef.current.updateSettings === 'function') {\n                                    // Update the settings for this user\n                                    actionButtonGroupRef.current.updateSettings(loadedSettings);\n                                    // Dispatch event to update UI\n                                    const event = new CustomEvent('captureSettingsUpdate', {\n                                        detail: {\n                                            type: 'captureSettings',\n                                            userId: consentUserId,\n                                            times: loadedSettings.times,\n                                            delay: loadedSettings.delay\n                                        }\n                                    });\n                                    window.dispatchEvent(event);\n                                } else if (retries > 0) {\n                                    setTimeout({\n                                        \"CollectedDatasetPage.useEffect.loadSettings.waitForRef\": ()=>waitForRef(retries - 1)\n                                    }[\"CollectedDatasetPage.useEffect.loadSettings.waitForRef\"], 500);\n                                } else {\n                                    console.warn('ActionButtonGroup ref not initialized after retries');\n                                }\n                            }\n                        }[\"CollectedDatasetPage.useEffect.loadSettings.waitForRef\"];\n                        waitForRef();\n                    } catch (error) {\n                        console.error('Error loading settings:', error);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.loadSettings\"];\n            // Add a small delay to ensure components are mounted\n            setTimeout(loadSettings, 1000);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Add polling for real-time updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const fetchUpdates = {\n                \"CollectedDatasetPage.useEffect.fetchUpdates\": async ()=>{\n                    if (!consentUserId) return;\n                    try {\n                        const response = await fetch(\"/api/data-center/settings/\".concat(consentUserId));\n                        if (!response.ok) throw new Error('Failed to fetch settings');\n                        const settings = await response.json();\n                        if (actionButtonGroupRef.current && actionButtonGroupRef.current.updateSettings) {\n                            actionButtonGroupRef.current.updateSettings(settings);\n                        }\n                    // You can add image fetching logic here if needed\n                    } catch (error) {\n                        console.error('Error fetching updates:', error);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.fetchUpdates\"];\n            // Initial fetch\n            fetchUpdates();\n            // Set up polling interval\n            const interval = setInterval(fetchUpdates, 3000);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    clearInterval(interval);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Add event listeners for settings and image updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"CollectedDatasetPage.useEffect.handleSettingsUpdate\": (event)=>{\n                    var _event_detail, _event_detail1;\n                    if (((_event_detail = event.detail) === null || _event_detail === void 0 ? void 0 : _event_detail.type) === 'captureSettings' && ((_event_detail1 = event.detail) === null || _event_detail1 === void 0 ? void 0 : _event_detail1.userId) === consentUserId) {\n                        const { times, delay } = event.detail;\n                        if (actionButtonGroupRef.current && actionButtonGroupRef.current.updateSettings) {\n                            actionButtonGroupRef.current.updateSettings({\n                                times,\n                                delay\n                            });\n                        }\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleSettingsUpdate\"];\n            const handleImageUpdate = {\n                \"CollectedDatasetPage.useEffect.handleImageUpdate\": (event)=>{\n                    var _event_detail, _event_detail1;\n                    if (((_event_detail = event.detail) === null || _event_detail === void 0 ? void 0 : _event_detail.type) === 'image' && ((_event_detail1 = event.detail) === null || _event_detail1 === void 0 ? void 0 : _event_detail1.userId) === consentUserId) {\n                        const { image } = event.detail;\n                    // Update image in the UI if needed\n                    // You can add your image update logic here\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleImageUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            window.addEventListener('imageUpdate', handleImageUpdate);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                    window.removeEventListener('imageUpdate', handleImageUpdate);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Load settings for a specific user\n    const loadSettings = async (userId)=>{\n        try {\n            console.log('Loading settings for user:', userId);\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId));\n            if (!response.ok) throw new Error('Failed to fetch settings');\n            const userSettings = await response.json();\n            console.log('Fetched settings:', userSettings);\n            // Dispatch settings update event\n            const event = new CustomEvent('captureSettingsUpdate', {\n                detail: {\n                    type: 'captureSettings',\n                    userId,\n                    ...userSettings\n                }\n            });\n            window.dispatchEvent(event);\n        } catch (error) {\n            console.error('Error loading settings:', error);\n        }\n    };\n    // Handle user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (consentUserId && consentUserId !== currentUserId) {\n                console.log('User ID changed in index.js:', consentUserId);\n                setCurrentUserId(consentUserId);\n                // Dispatch event to notify other components\n                const event = new CustomEvent('userIdChange', {\n                    detail: {\n                        userId: consentUserId\n                    }\n                });\n                window.dispatchEvent(event);\n                // Load settings for the new user\n                loadSettings(consentUserId);\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId,\n        currentUserId\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"CollectedDatasetPage.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        if (userId === currentUserId) {\n                            // Update the settings for this user\n                            if (actionButtonGroupRef.current && actionButtonGroupRef.current.updateSettings) {\n                                actionButtonGroupRef.current.updateSettings({\n                                    times: times || 1,\n                                    delay: delay || 3\n                                });\n                            }\n                        }\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"main-container \".concat(getSizeClass()),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Camera Dataset Collection\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1371,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1372,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1370,\n                columnNumber: 7\n            }, this),\n            isHydrated && backendStatus === 'disconnected' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    padding: '6px 0',\n                    backgroundColor: '#ffe0b2',\n                    color: '#e65100',\n                    textAlign: 'center',\n                    fontSize: '14px',\n                    fontWeight: 'bold',\n                    zIndex: 1100\n                },\n                children: \"âš ï¸ Backend disconnected. Hurry up, Make ONLINE please and Using mock mode\"\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1377,\n                columnNumber: 9\n            }, this),\n            isHydrated && showWarning && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"warning-banner\",\n                style: {\n                    position: 'fixed',\n                    top: showTopBar ? backendStatus === 'disconnected' ? '32px' : '60px' : '0',\n                    left: '0',\n                    width: '100%',\n                    backgroundColor: '#ffeb3b',\n                    color: '#333',\n                    padding: '10px',\n                    textAlign: 'center',\n                    boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n                    zIndex: 1010,\n                    animation: 'fadeIn 0.3s ease-in-out'\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                    children: [\n                        \"âš ï¸ \",\n                        warningMessage\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 1409,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1396,\n                columnNumber: 9\n            }, this),\n            isLoading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loading-container\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: \"Loading user settings...\"\n                }, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 1415,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1414,\n                columnNumber: 9\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    isHydrated && isClient && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(VideoProcessorComponent, {}, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1420,\n                        columnNumber: 38\n                    }, this),\n                    showTopBar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_topBar__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        onButtonClick: handleActionButtonClick,\n                        onCameraAccess: ()=>setShowPermissionPopup(true),\n                        outputText: statusMessage || outputText,\n                        onOutputChange: (text)=>setOutputText(text),\n                        onToggleTopBar: toggleTopBar,\n                        onToggleMetrics: toggleMetrics,\n                        canvasRef: canvasRef\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1424,\n                        columnNumber: 13\n                    }, this),\n                    !showTopBar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"restore-button-container\",\n                        style: {\n                            position: 'fixed',\n                            top: '10px',\n                            right: '10px',\n                            zIndex: 1000\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"restore-btn\",\n                            onClick: ()=>toggleTopBar(true),\n                            title: \"Show TopBar and Metrics\",\n                            style: {\n                                padding: '5px 10px',\n                                background: '#0066cc',\n                                color: 'white',\n                                border: 'none',\n                                borderRadius: '4px',\n                                fontSize: '16px',\n                                cursor: 'pointer'\n                            },\n                            children: \"â‰¡\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                            lineNumber: 1443,\n                            columnNumber: 15\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1437,\n                        columnNumber: 13\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        ref: previewAreaRef,\n                        className: \"camera-preview-area\",\n                        style: {\n                            height: showTopBar ? 'calc(100vh - 120px)' : '100vh',\n                            marginTop: backendStatus === 'disconnected' ? '32px' : '0',\n                            position: 'relative',\n                            backgroundColor: '#f5f5f5',\n                            overflow: 'hidden'\n                        },\n                        children: [\n                            !showCamera ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"camera-preview-message\",\n                                        style: {\n                                            padding: '20px',\n                                            textAlign: 'center',\n                                            position: showTopBar ? 'relative' : 'absolute',\n                                            width: '100%',\n                                            zIndex: 5\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \"Camera preview will appear here\"\n                                            }, void 0, false, {\n                                                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                                lineNumber: 1502,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"camera-size-indicator\",\n                                                children: [\n                                                    \"Current window: \",\n                                                    windowSize.percentage,\n                                                    \"% of screen width\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                                lineNumber: 1503,\n                                                columnNumber: 19\n                                            }, this),\n                                            isHydrated && showCameraPlaceholder && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"camera-placeholder-square\",\n                                                style: {\n                                                    width: '180px',\n                                                    height: '135px',\n                                                    margin: '20px auto',\n                                                    border: '2px dashed #666',\n                                                    borderRadius: '4px',\n                                                    backgroundColor: '#f5f5f5',\n                                                    display: 'flex',\n                                                    alignItems: 'center',\n                                                    justifyContent: 'center'\n                                                },\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    style: {\n                                                        fontSize: '1.5rem'\n                                                    },\n                                                    children: \"\\uD83D\\uDCF7\"\n                                                }, void 0, false, {\n                                                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                                    lineNumber: 1521,\n                                                    columnNumber: 23\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                                lineNumber: 1507,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1495,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"canvas-container\",\n                                        style: {\n                                            position: 'absolute',\n                                            top: 0,\n                                            left: 0,\n                                            width: '100%',\n                                            height: '100%',\n                                            backgroundColor: 'white',\n                                            overflow: 'hidden',\n                                            border: 'none',\n                                            zIndex: 10\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1527,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true) : null,\n                            isHydrated && showMetrics && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_displayResponse__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                width: metrics.width,\n                                height: metrics.height,\n                                distance: metrics.distance,\n                                isVisible: showMetrics\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1556,\n                                columnNumber: 15\n                            }, this),\n                            isHydrated && isClient && showCamera && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DynamicCameraAccess, {\n                                isShowing: showCamera,\n                                onClose: handleCameraClose,\n                                onCameraReady: handleCameraReady,\n                                showHeadPose: showHeadPose,\n                                showBoundingBox: showBoundingBox,\n                                showMask: showMask,\n                                showParameters: showParameters,\n                                videoRef: videoRef\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1566,\n                                columnNumber: 15\n                            }, this),\n                            isHydrated && isClient && showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"camera-permission-popup\",\n                                style: {\n                                    position: 'fixed',\n                                    top: 0,\n                                    left: 0,\n                                    width: '100%',\n                                    height: '100%',\n                                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                                    display: 'flex',\n                                    justifyContent: 'center',\n                                    alignItems: 'center',\n                                    zIndex: 2000\n                                },\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"camera-permission-dialog\",\n                                    style: {\n                                        width: '400px',\n                                        backgroundColor: 'white',\n                                        borderRadius: '8px',\n                                        padding: '20px',\n                                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"camera-permission-title\",\n                                            style: {\n                                                margin: '0 0 15px',\n                                                fontSize: '18px',\n                                                fontWeight: 'bold'\n                                            },\n                                            children: \"Camera Access Required\"\n                                        }, void 0, false, {\n                                            fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1599,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"camera-permission-message\",\n                                            style: {\n                                                margin: '0 0 20px',\n                                                fontSize: '14px',\n                                                lineHeight: '1.4'\n                                            },\n                                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                                        }, void 0, false, {\n                                            fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1604,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"camera-permission-buttons\",\n                                            style: {\n                                                display: 'flex',\n                                                justifyContent: 'flex-end',\n                                                gap: '10px'\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: handlePermissionDenied,\n                                                    className: \"camera-btn\",\n                                                    style: {\n                                                        padding: '8px 16px',\n                                                        backgroundColor: '#f0f0f0',\n                                                        border: 'none',\n                                                        borderRadius: '4px',\n                                                        cursor: 'pointer'\n                                                    },\n                                                    children: \"Cancel\"\n                                                }, void 0, false, {\n                                                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                                    lineNumber: 1617,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: handlePermissionAccepted,\n                                                    className: \"camera-btn\",\n                                                    style: {\n                                                        padding: '8px 16px',\n                                                        backgroundColor: '#0066cc',\n                                                        color: 'white',\n                                                        border: 'none',\n                                                        borderRadius: '4px',\n                                                        cursor: 'pointer'\n                                                    },\n                                                    children: \"Continue\"\n                                                }, void 0, false, {\n                                                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                                    lineNumber: 1630,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1612,\n                                            columnNumber: 19\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1592,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1580,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1463,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/index.js\",\n        lineNumber: 1369,\n        columnNumber: 5\n    }, this);\n}\n_s(CollectedDatasetPage, \"dPRoW5+9h6WED+2wlVkeXYK1P7Y=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_9__.useRouter,\n        _components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_8__.useConsent\n    ];\n});\n_c2 = CollectedDatasetPage;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"VideoProcessorComponent\");\n$RefreshReg$(_c1, \"DynamicCameraAccess\");\n$RefreshReg$(_c2, \"CollectedDatasetPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFEQUFxRDs7O0FBQ007QUFDOUI7QUFDTTtBQUNVO0FBQ2tCO0FBQ0c7QUFDcUc7QUFDdkssb0hBQW9IO0FBQy9DO0FBQzdCO0FBRXhDLHlFQUF5RTtBQUN6RSxNQUFNZ0IsMEJBQTBCWCxtREFBT0EsQ0FDckMsSUFBTSxrVkFBa0Q7Ozs7OztJQUN0RFksS0FBSzs7S0FGSEQ7QUFLTiw0REFBNEQ7QUFDNUQsTUFBTUUsc0JBQXNCYixtREFBT0EsQ0FDakMsSUFBTSxpVEFBdUM7Ozs7OztJQUUzQ1ksS0FBSztJQUNMRSxTQUFTLGtCQUNQLDhEQUFDQztZQUFJQyxPQUFPO2dCQUNWQyxVQUFVO2dCQUNWQyxLQUFLO2dCQUNMQyxNQUFNO2dCQUNOQyxXQUFXO2dCQUNYQyxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSQyxpQkFBaUI7Z0JBQ2pCQyxRQUFRO2dCQUNSQyxjQUFjO2dCQUNkQyxTQUFTO2dCQUNUQyxlQUFlO2dCQUNmQyxnQkFBZ0I7Z0JBQ2hCQyxZQUFZO2dCQUNaQyxXQUFXO2dCQUNYQyxRQUFRO1lBQ1Y7OzhCQUNFLDhEQUFDaEI7b0JBQUlDLE9BQU87d0JBQUVnQixVQUFVO3dCQUFRQyxjQUFjO29CQUFPOzhCQUFHOzs7Ozs7OEJBQ3hELDhEQUFDQztvQkFBRWxCLE9BQU87d0JBQUVnQixVQUFVO3dCQUFRRyxZQUFZO3dCQUFRQyxPQUFPO29CQUFVOzhCQUFHOzs7Ozs7Ozs7Ozs7O01BdkJ4RXZCO0FBK0JTLFNBQVN3Qjs7SUFDdEIsTUFBTUMsU0FBUzVCLHNEQUFTQTtJQUN4QixNQUFNLEVBQUU2QixRQUFRQyxhQUFhLEVBQUUsR0FBRy9CLDhFQUFVQTtJQUM1QyxNQUFNLENBQUNnQyxVQUFVQyxZQUFZLEdBQUc5QywrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUMrQyxX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Q0FBRTBNLFdBQVU7NENBQTRCNU4sT0FBTztnREFDOUNzUixRQUFRO2dEQUNSdFEsVUFBVTtnREFDVjJRLFlBQVk7NENBQ2Q7c0RBQUc7Ozs7OztzREFJSCw4REFBQzVSOzRDQUFJNk4sV0FBVTs0Q0FBNEI1TixPQUFPO2dEQUNoRFUsU0FBUztnREFDVEUsZ0JBQWdCO2dEQUNoQmdSLEtBQUs7NENBQ1A7OzhEQUNFLDhEQUFDYjtvREFDQ0MsU0FBUzdDO29EQUNUUCxXQUFVO29EQUNWNU4sT0FBTzt3REFDTG9RLFNBQVM7d0RBQ1Q3UCxpQkFBaUI7d0RBQ2pCQyxRQUFRO3dEQUNSQyxjQUFjO3dEQUNkeVEsUUFBUTtvREFDVjs4REFDRDs7Ozs7OzhEQUdELDhEQUFDSDtvREFDQ0MsU0FBUzlDO29EQUNUTixXQUFVO29EQUNWNU4sT0FBTzt3REFDTG9RLFNBQVM7d0RBQ1Q3UCxpQkFBaUI7d0RBQ2pCYSxPQUFPO3dEQUNQWixRQUFRO3dEQUNSQyxjQUFjO3dEQUNkeVEsUUFBUTtvREFDVjs4REFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlyQjtHQWxrRHdCN1A7O1FBQ1AzQixrREFBU0E7UUFDVUQsMEVBQVVBOzs7TUFGdEI0QiIsInNvdXJjZXMiOlsiL2FwcC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIE1vZGlmaWVkIGluZGV4LmpzIC0gRml4aW5nIGNhbnZhcyByZWZlcmVuY2UgaXNzdWVzXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEhlYWQgZnJvbSAnbmV4dC9oZWFkJztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5pbXBvcnQgVG9wQmFyIGZyb20gJy4vY29tcG9uZW50cy1ndWkvdG9wQmFyJztcbmltcG9ydCBEaXNwbGF5UmVzcG9uc2UgZnJvbSAnLi9jb21wb25lbnRzLWd1aS9kaXNwbGF5UmVzcG9uc2UnO1xuaW1wb3J0IHsgQWN0aW9uQnV0dG9uR3JvdXAgfSBmcm9tICcuL2NvbXBvbmVudHMtZ3VpL2FjdGlvbkJ1dHRvbic7XG5pbXBvcnQgeyBzaG93Q2FwdHVyZVByZXZpZXcsIGNhcHR1cmVJbWFnZXNBdFBvaW50LCBkcmF3UmVkRG90LCBnZXRSYW5kb21Qb3NpdGlvbiwgcnVuQ291bnRkb3duIH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnO1xuLy8gaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJztcbmltcG9ydCB7IHVzZUNvbnNlbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NvbnNlbnQvQ29uc2VudENvbnRleHQnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xuXG4vLyBEeW5hbWljYWxseSBsb2FkIHRoZSB2aWRlbyBwcm9jZXNzb3IgY29tcG9uZW50IChub3QgdGhlIGhvb2sgZGlyZWN0bHkpXG5jb25zdCBWaWRlb1Byb2Nlc3NvckNvbXBvbmVudCA9IGR5bmFtaWMoXG4gICgpID0+IGltcG9ydCgnLi9jb21wb25lbnRzLWd1aS9WaWRlb1Byb2Nlc3NvckNvbXBvbmVudCcpLFxuICB7IHNzcjogZmFsc2UgfVxuKTtcblxuLy8gRHluYW1pY2FsbHkgaW1wb3J0IHRoZSBjYW1lcmEgY29tcG9uZW50IHdpdGggU1NSIGRpc2FibGVkXG5jb25zdCBEeW5hbWljQ2FtZXJhQWNjZXNzID0gZHluYW1pYyhcbiAgKCkgPT4gaW1wb3J0KCcuL2NvbXBvbmVudHMtZ3VpL2NhbWVyYUFjY2VzcycpLFxuICB7IFxuICAgIHNzcjogZmFsc2UsXG4gICAgbG9hZGluZzogKCkgPT4gKFxuICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgIHdpZHRoOiAnNDgwcHgnLFxuICAgICAgICBoZWlnaHQ6ICczNjBweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmMGY4ZmYnLFxuICAgICAgICBib3JkZXI6ICcycHggc29saWQgIzAwNjZjYycsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIHpJbmRleDogOTk5XG4gICAgICB9fT5cbiAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogJzQ4cHgnLCBtYXJnaW5Cb3R0b206ICcxNXB4JyB9fT7wn5O3PC9kaXY+XG4gICAgICAgIDxwIHN0eWxlPXt7IGZvbnRTaXplOiAnMTZweCcsIGZvbnRXZWlnaHQ6ICdib2xkJywgY29sb3I6ICcjMDA2NmNjJyB9fT5cbiAgICAgICAgICBMb2FkaW5nIGNhbWVyYS4uLlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbGxlY3RlZERhdGFzZXRQYWdlKCkge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgeyB1c2VySWQ6IGNvbnNlbnRVc2VySWQgfSA9IHVzZUNvbnNlbnQoKTtcbiAgY29uc3QgW3VzZXJEYXRhLCBzZXRVc2VyRGF0YV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbaXNIeWRyYXRlZCwgc2V0SXNIeWRyYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtiYWNrZW5kU3RhdHVzLCBzZXRCYWNrZW5kU3RhdHVzXSA9IHVzZVN0YXRlKCdjaGVja2luZycpO1xuICBjb25zdCBbc2hvd1RvcEJhciwgc2V0U2hvd1RvcEJhcl0gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW3Nob3dXYXJuaW5nLCBzZXRTaG93V2FybmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt3YXJuaW5nTWVzc2FnZSwgc2V0V2FybmluZ01lc3NhZ2VdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbc3RhdHVzTWVzc2FnZSwgc2V0U3RhdHVzTWVzc2FnZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtvdXRwdXRUZXh0LCBzZXRPdXRwdXRUZXh0XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3Nob3dNZXRyaWNzLCBzZXRTaG93TWV0cmljc10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW3Nob3dQZXJtaXNzaW9uUG9wdXAsIHNldFNob3dQZXJtaXNzaW9uUG9wdXBdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY2FtZXJhUGVybWlzc2lvbkdyYW50ZWQsIHNldENhbWVyYVBlcm1pc3Npb25HcmFudGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dDYW1lcmEsIHNldFNob3dDYW1lcmFdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0NhbWVyYVBsYWNlaG9sZGVyLCBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0hlYWRQb3NlLCBzZXRTaG93SGVhZFBvc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0JvdW5kaW5nQm94LCBzZXRTaG93Qm91bmRpbmdCb3hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd01hc2ssIHNldFNob3dNYXNrXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQYXJhbWV0ZXJzLCBzZXRTaG93UGFyYW1ldGVyc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt3aW5kb3dTaXplLCBzZXRXaW5kb3dTaXplXSA9IHVzZVN0YXRlKHsgd2lkdGg6IDAsIGhlaWdodDogMCwgcGVyY2VudGFnZTogMTAwIH0pO1xuICBjb25zdCBbbWV0cmljcywgc2V0TWV0cmljc10gPSB1c2VTdGF0ZSh7IHdpZHRoOiAnLS0tJywgaGVpZ2h0OiAnLS0tJywgZGlzdGFuY2U6ICctLS0nIH0pO1xuICBjb25zdCBbY2FwdHVyZUNvdW50ZXIsIHNldENhcHR1cmVDb3VudGVyXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbY2FwdHVyZUZvbGRlciwgc2V0Q2FwdHVyZUZvbGRlcl0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCdkZWZhdWx0Jyk7XG4gIGNvbnN0IFtzaG93U2V0dGluZ3MsIHNldFNob3dTZXR0aW5nc10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gUmVmc1xuICBjb25zdCBwcmV2aWV3QXJlYVJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgYWN0aW9uQnV0dG9uR3JvdXBSZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gU2V0IGh5ZHJhdGVkIHN0YXRlIGFmdGVyIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0SXNIeWRyYXRlZCh0cnVlKTtcbiAgfSwgW10pO1xuXG4gIC8vIExvYWQgdXNlciBkYXRhXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9hZFVzZXJEYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFyb3V0ZXIuaXNSZWFkeSkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBpZiAocm91dGVyLnF1ZXJ5LnVzZXJEYXRhKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IEpTT04ucGFyc2Uocm91dGVyLnF1ZXJ5LnVzZXJEYXRhKTtcbiAgICAgICAgICBzZXRVc2VyRGF0YShwYXJzZWREYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm91dGVyLnF1ZXJ5LnVzZXJJZCkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC91c2VyLXByZWZlcmVuY2VzLyR7cm91dGVyLnF1ZXJ5LnVzZXJJZH1gLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggdXNlciBkYXRhJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgc2V0VXNlckRhdGEoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHVzZXIgZGF0YTonLCBlcnIpO1xuICAgICAgICBzZXRFcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBsb2FkVXNlckRhdGEoKTtcbiAgfSwgW3JvdXRlci5pc1JlYWR5LCByb3V0ZXIucXVlcnldKTtcblxuICAvLyBDaGVjayBiYWNrZW5kIGNvbm5lY3Rpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGVja0JhY2tlbmRDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGVjay1iYWNrZW5kLWNvbm5lY3Rpb24nKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2V0QmFja2VuZFN0YXR1cyhkYXRhLmNvbm5lY3RlZCA/ICdjb25uZWN0ZWQnIDogJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgYmFja2VuZCBjb25uZWN0aW9uOicsIGVycm9yKTtcbiAgICAgICAgc2V0QmFja2VuZFN0YXR1cygnZGlzY29ubmVjdGVkJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChpc0h5ZHJhdGVkKSB7XG4gICAgICBjaGVja0JhY2tlbmRDb25uZWN0aW9uKCk7XG4gICAgfVxuICB9LCBbaXNIeWRyYXRlZF0pO1xuXG4gIC8vIFVwZGF0ZSB3aW5kb3cgc2l6ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICBpZiAocHJldmlld0FyZWFSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHByZXZpZXdBcmVhUmVmLmN1cnJlbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHByZXZpZXdBcmVhUmVmLmN1cnJlbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY3JlZW5QZXJjZW50YWdlID0gKHdpbmRvdy5pbm5lcldpZHRoIC8gd2luZG93LnNjcmVlbi53aWR0aCkgKiAxMDA7XG4gICAgICAgIFxuICAgICAgICBzZXRNZXRyaWNzKHByZXYgPT4gKHsgLi4ucHJldiwgd2lkdGgsIGhlaWdodCB9KSk7XG4gICAgICAgIHNldFdpbmRvd1NpemUoe1xuICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICBwZXJjZW50YWdlOiBNYXRoLnJvdW5kKHNjcmVlblBlcmNlbnRhZ2UpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoaXNIeWRyYXRlZCkge1xuICAgICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICB9XG4gIH0sIFtpc0h5ZHJhdGVkXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBzZXR0aW5ncyBiYXNlZCBvbiB1c2VyIGRhdGFcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodXNlckRhdGEgJiYgY29uc2VudFVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBzZXR0aW5ncyBmb3IgdXNlcjonLCBjb25zZW50VXNlcklkLCB1c2VyRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgdXNlci1zcGVjaWZpYyBzZXR0aW5nc1xuICAgICAgaWYgKHVzZXJEYXRhLnByZWZlcmVuY2VzKSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZmVyZW5jZXMgfSA9IHVzZXJEYXRhO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGNhbWVyYSBzZXR0aW5ncyBpZiBhdmFpbGFibGVcbiAgICAgICAgaWYgKHByZWZlcmVuY2VzLmNhbWVyYVNldHRpbmdzKSB7XG4gICAgICAgICAgY29uc3QgeyBzaG93SGVhZFBvc2UsIHNob3dCb3VuZGluZ0JveCwgc2hvd01hc2ssIHNob3dQYXJhbWV0ZXJzIH0gPSBwcmVmZXJlbmNlcy5jYW1lcmFTZXR0aW5ncztcbiAgICAgICAgICBzZXRTaG93SGVhZFBvc2Uoc2hvd0hlYWRQb3NlIHx8IGZhbHNlKTtcbiAgICAgICAgICBzZXRTaG93Qm91bmRpbmdCb3goc2hvd0JvdW5kaW5nQm94IHx8IGZhbHNlKTtcbiAgICAgICAgICBzZXRTaG93TWFzayhzaG93TWFzayB8fCBmYWxzZSk7XG4gICAgICAgICAgc2V0U2hvd1BhcmFtZXRlcnMoc2hvd1BhcmFtZXRlcnMgfHwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgb3RoZXIgc2V0dGluZ3MgYXMgbmVlZGVkXG4gICAgICAgIGlmIChwcmVmZXJlbmNlcy5tZXRyaWNzKSB7XG4gICAgICAgICAgc2V0U2hvd01ldHJpY3MocHJlZmVyZW5jZXMubWV0cmljcy5zaG93IHx8IHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocHJlZmVyZW5jZXMudG9wQmFyKSB7XG4gICAgICAgICAgc2V0U2hvd1RvcEJhcihwcmVmZXJlbmNlcy50b3BCYXIuc2hvdyB8fCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3VzZXJEYXRhLCBjb25zZW50VXNlcklkXSk7XG5cbiAgLy8gSW1wcm92ZWQgZ2V0IGNhbnZhcyBmdW5jdGlvbiB0aGF0IHRyaWVzIG11bHRpcGxlIG1ldGhvZHNcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICAvLyBNZXRob2QgMTogQ2hlY2sgaWYgd2UgaGF2ZSBhIGRpcmVjdCByZWZlcmVuY2VcbiAgICBpZiAoY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZGlyZWN0IGNhbnZhc1JlZi5jdXJyZW50IHJlZmVyZW5jZVwiKTtcbiAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICB9XG4gICAgXG4gICAgLy8gTWV0aG9kIDI6IFRyeSB0byBnZXQgZ2xvYmFsIHJlZmVyZW5jZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZ2xvYmFsIHdoaXRlU2NyZWVuQ2FudmFzIHJlZmVyZW5jZVwiKTtcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gd2luZG93LndoaXRlU2NyZWVuQ2FudmFzOyAvLyBVcGRhdGUgb3VyIHJlZlxuICAgICAgcmV0dXJuIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICB9XG4gICAgXG4gICAgLy8gTWV0aG9kIDM6IFRyeSB0byBmaW5kIHZpYSBET01cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cmFja2luZy1jYW52YXMnKTtcbiAgICAgIGlmIChjYW52YXNFbGVtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgY2FudmFzIHZpYSBET00gc2VsZWN0b3JcIik7XG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzRWxlbWVudDsgLy8gVXBkYXRlIG91ciByZWZcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzRWxlbWVudDsgLy8gVXBkYXRlIGdsb2JhbCByZWYgdG9vXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCB2aWEgYW55IG1ldGhvZFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgXG4gIC8vIENoZWNrIGlmIHdlJ3JlIG9uIHRoZSBjbGllbnQgb3Igc2VydmVyXG4gIGNvbnN0IGlzQ2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gIFxuICAvLyBBZGQgZWZmZWN0IHRvIGluaXRpYWxpemUgY2FudmFzIGFuZCBtYWtlIGl0IGdsb2JhbGx5IGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICAvLyBEZWJ1ZyBpbmZvIHRvIHZlcmlmeSBjYW52YXMgc2l6ZSBhbmQgYXZhaWxhYmlsaXR5XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc29sZS5sb2coXCJJbmRleC5qczogQ2FudmFzIGluaXRpYWxpemVkXCIsIHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBjYW52YXMgRVhQTElDSVRMWSBhdmFpbGFibGUgZ2xvYmFsbHlcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgIFxuICAgICAgLy8gQWxzbyBzdG9yZSBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgd2luZG93LmNhbnZhc0RpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBub3QgYXZhaWxhYmxlIGR1cmluZyBpbml0aWFsaXphdGlvblwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRXhwb3NlIGNhbnZhcyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbiBnbG9iYWxseVxuICAgIHdpbmRvdy5pbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoIWNhbnZhcyB8fCAhcGFyZW50KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW2luaXRpYWxpemVDYW52YXNdIENhbnZhcyBvciBwYXJlbnQgaXMgbnVsbCcsIHsgY2FudmFzLCBwYXJlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHBhcmVudFxuICAgICAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXMgYW5kIHNldCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgaW5pdGlhbGl6ZWQgd2l0aCBkaW1lbnNpb25zOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCByZWZlcmVuY2VcbiAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgICAgICB3aW5kb3cuY2FudmFzRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbaW5pdGlhbGl6ZUNhbnZhc10gRXJyb3IgaW5pdGlhbGl6aW5nIGNhbnZhczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIENoZWNrIGNhbnZhcyB2aXNpYmlsaXR5IGFuZCBmb3JjZSBpbml0aWFsaXphdGlvbiBhZnRlciBhIGJyaWVmIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIGluaXRpYWwgdmlzaWJpbGl0eSBjaGVjazpcIiwge1xuICAgICAgICAgIGRpbWVuc2lvbnM6IGAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWAsXG4gICAgICAgICAgcmVjdFNpemU6IGAke3JlY3Qud2lkdGh9eCR7cmVjdC5oZWlnaHR9YCxcbiAgICAgICAgICBpc1Zpc2libGU6IChyZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDApXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yY2UgaW5pdGlhbGl6YXRpb24gaWYgbmVlZGVkXG4gICAgICAgIGFkanVzdENhbnZhc0RpbWVuc2lvbnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNhbnZhcyBub3QgZm91bmQgZHVyaW5nIHZpc2liaWxpdHkgY2hlY2tcIik7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVsZXRlIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzRGltZW5zaW9ucztcbiAgICAgIGRlbGV0ZSB3aW5kb3cuaW5pdGlhbGl6ZUNhbnZhcztcbiAgICB9O1xuICB9LCBbaXNIeWRyYXRlZF0pO1xuICAvLyBJbXByb3ZlZCBjYW52YXMgZGltZW5zaW9ucyBhZGp1c3RtZW50XG4gIGNvbnN0IGFkanVzdENhbnZhc0RpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCB8fCAhcHJldmlld0FyZWFSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gY2FudmFzIGZvdW5kIHRvIGFkanVzdCBkaW1lbnNpb25zXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjb250YWluZXIgPSBwcmV2aWV3QXJlYVJlZi5jdXJyZW50O1xuICAgIFxuICAgIC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgcHJldmlldyBhcmVhXG4gICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcHJvcGVyIGhlaWdodCBiYXNlZCBvbiB0b3AgYmFyIHZpc2liaWxpdHlcbiAgICBjb25zdCB0b3BCYXJIZWlnaHQgPSBzaG93VG9wQmFyID8gMTIwIDogMDsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYmFzZWQgb24geW91ciB0b3AgYmFyJ3MgYWN0dWFsIGhlaWdodFxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQWRqdXN0aW5nIGNhbnZhcyBkaW1lbnNpb25zXCIsIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoOiByZWN0LndpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIHRvcEJhclZpc2libGU6IHNob3dUb3BCYXIsXG4gICAgICBjYWxjdWxhdGVkSGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBjb250YWluZXIgc2l6ZSB3aXRoIHRvcCBiYXIgYWRqdXN0bWVudFxuICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgLy8gRmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ2FudmFzIGRpbWVuc2lvbnMgYWRqdXN0ZWQ6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGdsb2JhbCByZWZlcmVuY2Ugd2l0aCBjdXJyZW50IGRpbWVuc2lvbnNcbiAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG4gICAgd2luZG93LmNhbnZhc0RpbWVuc2lvbnMgPSB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBjYXB0dXJlIGZvbGRlciBvbiBjb21wb25lbnQgbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhcHR1cmVGb2xkZXIgJiYgaXNDbGllbnQgJiYgaXNIeWRyYXRlZCkge1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6XFwuXS9nLCAnLScpO1xuICAgICAgc2V0Q2FwdHVyZUZvbGRlcihgc2Vzc2lvbl8ke3RpbWVzdGFtcH1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGNhcHR1cmUgZm9sZGVyOiBzZXNzaW9uXyR7dGltZXN0YW1wfWApO1xuICAgIH1cbiAgfSwgW2NhcHR1cmVGb2xkZXIsIGlzQ2xpZW50LCBpc0h5ZHJhdGVkXSk7XG4gIFxuICAvLyBDaGVjayBiYWNrZW5kIGNvbm5lY3Rpb24gb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47IC8vIFNraXAgb24gc2VydmVyIG9yIGJlZm9yZSBoeWRyYXRpb25cbiAgICBcbiAgICBjb25zdCBjaGVja0JhY2tlbmRDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGVjay1iYWNrZW5kLWNvbm5lY3Rpb24nKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2V0QmFja2VuZFN0YXR1cyhkYXRhLmNvbm5lY3RlZCA/ICdjb25uZWN0ZWQnIDogJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQmFja2VuZCBjb25uZWN0aW9uOiAke2RhdGEuY29ubmVjdGVkID8gJ09LJyA6ICdGYWlsZWQnfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBzdGF0dXMgaW4gb3V0cHV0IHRleHRcbiAgICAgICAgc2V0T3V0cHV0VGV4dChgQmFja2VuZCAke2RhdGEuY29ubmVjdGVkID8gJ2Nvbm5lY3RlZCcgOiAnZGlzY29ubmVjdGVkIC0gdXNpbmcgbW9jayBtb2RlJ31gKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGJhY2tlbmQgY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgICAgIHNldEJhY2tlbmRTdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICBzZXRPdXRwdXRUZXh0KCdCYWNrZW5kIGRpc2Nvbm5lY3RlZCAtIHVzaW5nIG1vY2sgbW9kZScpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjaGVja0JhY2tlbmRDb25uZWN0aW9uKCk7XG4gICAgXG4gICAgLy8gV2VsY29tZSBtZXNzYWdlIGFmdGVyIGJhY2tlbmQgY2hlY2tcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldE91dHB1dFRleHQoJ0NhbWVyYSBzeXN0ZW0gcmVhZHkuIENsaWNrIFwiU2hvdyBQcmV2aWV3XCIgdG8gc3RhcnQgY2FtZXJhLicpO1xuICAgIH0sIDIwMDApO1xuICB9LCBbaXNIeWRyYXRlZF0pO1xuXG4gIC8vIEFkZCBzdHlsZXMgdG8gZG9jdW1lbnQgaGVhZCBmb3IgYnV0dG9uIGhpZ2hsaWdodGluZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzdHlsZSBlbGVtZW50XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxuICAgICAgQGtleWZyYW1lcyBwdWxzZSB7XG4gICAgICAgIDAlIHsgYm94LXNoYWRvdzogMCAwIDAgMCByZ2JhKDAsIDEwMiwgMjA0LCAwLjcpOyB9XG4gICAgICAgIDcwJSB7IGJveC1zaGFkb3c6IDAgMCAwIDEwcHggcmdiYSgwLCAxMDIsIDIwNCwgMCk7IH1cbiAgICAgICAgMTAwJSB7IGJveC1zaGFkb3c6IDAgMCAwIDAgcmdiYSgwLCAxMDIsIDIwNCwgMCk7IH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgQGtleWZyYW1lcyBmYWRlSW4ge1xuICAgICAgICBmcm9tIHsgb3BhY2l0eTogMDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KTsgfVxuICAgICAgICB0byB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAuYnRuLWhpZ2hsaWdodCB7XG4gICAgICAgIGFuaW1hdGlvbjogcHVsc2UgMS41cyBpbmZpbml0ZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwOTlmZiAhaW1wb3J0YW50O1xuICAgICAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLndhcm5pbmctYmFubmVyIHtcbiAgICAgICAgYW5pbWF0aW9uOiBmYWRlSW4gMC4zcyBlYXNlLWluLW91dDtcbiAgICAgIH1cbiAgICBgO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgIH07XG4gIH0sIFtpc0h5ZHJhdGVkXSk7XG4gIFxuICAvLyBNYWtlIHRvZ2dsZVRvcEJhciBmdW5jdGlvbiBhdmFpbGFibGUgZ2xvYmFsbHlcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gTWFrZSB0b2dnbGVUb3BCYXIgYXZhaWxhYmxlIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICB3aW5kb3cudG9nZ2xlVG9wQmFyID0gKHNob3cpID0+IHtcbiAgICAgIHNldFNob3dUb3BCYXIoc2hvdyk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gaGlkZSBtZXRyaWNzIHdoZW4gaGlkaW5nIHRoZSB0b3AgYmFyXG4gICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgc2V0U2hvd01ldHJpY3MoZmFsc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGp1c3QgY2FudmFzIGRpbWVuc2lvbnMgYWZ0ZXIgdG9nZ2xpbmdcbiAgICAgIHNldFRpbWVvdXQoYWRqdXN0Q2FudmFzRGltZW5zaW9ucywgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cFxuICAgICAgZGVsZXRlIHdpbmRvdy50b2dnbGVUb3BCYXI7XG4gICAgfTtcbiAgfSwgW2lzSHlkcmF0ZWRdKTtcblxuICAvLyBUb2dnbGUgY2FtZXJhIGZ1bmN0aW9uXG4gIGNvbnN0IHRvZ2dsZUNhbWVyYSA9IChzaG91bGRFbmFibGUpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgaWYgKHNob3VsZEVuYWJsZSkge1xuICAgICAgc2V0U2hvd0NhbWVyYSh0cnVlKTtcbiAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICBzZXRPdXRwdXRUZXh0KCdDYW1lcmEgcHJldmlldyBzdGFydGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNob3dDYW1lcmEoZmFsc2UpO1xuICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgIHNldE91dHB1dFRleHQoJ0NhbWVyYSBwcmV2aWV3IHN0b3BwZWQnKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBIYW5kbGVyIGZvciBhY3Rpb24gYnV0dG9uIGNsaWNrc1xuICBjb25zdCBoYW5kbGVBY3Rpb25CdXR0b25DbGljayA9IChhY3Rpb25UeXBlLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0b2dnbGluZyB0aGUgdG9wIGJhclxuICAgIGlmIChhY3Rpb25UeXBlID09PSAndG9nZ2xlVG9wQmFyJykge1xuICAgICAgLy8gY29uc3QgbmV3VG9wQmFyU3RhdGUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gISF2YWx1ZSA6ICFzaG93VG9wQmFyO1xuICAgICAgbGV0IG5ld1RvcEJhclN0YXRlO1xuICAgIFxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdib29sZWFuJykge1xuICAgICAgICBuZXdUb3BCYXJTdGF0ZSA9IHBhcmFtcztcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMudmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5ld1RvcEJhclN0YXRlID0gISFwYXJhbXMudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdUb3BCYXJTdGF0ZSA9ICFzaG93VG9wQmFyO1xuICAgICAgfVxuICAgICAgc2V0U2hvd1RvcEJhcihuZXdUb3BCYXJTdGF0ZSk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gaGlkZSBtZXRyaWNzIHdoZW4gaGlkaW5nIHRoZSB0b3AgYmFyXG4gICAgICBpZiAoIW5ld1RvcEJhclN0YXRlKSB7XG4gICAgICAgIHNldFNob3dNZXRyaWNzKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0T3V0cHV0VGV4dChgVG9wQmFyICR7bmV3VG9wQmFyU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9JHshbmV3VG9wQmFyU3RhdGUgPyAnLCBNZXRyaWNzIGhpZGRlbicgOiAnJ31gKTtcbiAgICAgIFxuICAgICAgLy8gQWRqdXN0IGNhbnZhcyBkaW1lbnNpb25zIGFmdGVyIHRvZ2dsaW5nXG4gICAgICBzZXRUaW1lb3V0KGFkanVzdENhbnZhc0RpbWVuc2lvbnMsIDEwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICBzZXRTaG93V2FybmluZyhmYWxzZSk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHdhcm5pbmdzXG4gICAgY29uc3Qgc2FmZVBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgXG4gICAgLy8gVXNlIHNhZmVQYXJhbXMgaW5zdGVhZCBvZiBjb250cm9sVmFsdWVzXG4gICAgY29uc3QgcmFuZG9tVGltZXMgPSBzYWZlUGFyYW1zLnJhbmRvbVRpbWVzIHx8IDE7XG4gICAgY29uc3QgZGVsYXlTZWNvbmRzID0gc2FmZVBhcmFtcy5kZWxheVNlY29uZHMgfHwgMztcblxuICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSAncHJldmlldyc6XG4gICAgICAgIC8vIFRvZ2dsZSBjYW1lcmEgc3RhdGVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEpIHtcbiAgICAgICAgICB0b2dnbGVDYW1lcmEoZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbWVyYVBlcm1pc3Npb25HcmFudGVkKSB7XG4gICAgICAgICAgdG9nZ2xlQ2FtZXJhKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBzaG93IHBlcm1pc3Npb24gcG9wdXBcbiAgICAgICAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpO1xuICAgICAgICAgIHNldE91dHB1dFRleHQoJ09wZW5pbmcgY2FtZXJhIHByZXZpZXcnKTtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgY2FzZSAnc2V0UmFuZG9tJzpcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnU3RhcnRpbmcgcmFuZG9tIHNlcXVlbmNlLi4uJyk7XG4gICAgICAgIHNldFNob3dUb3BCYXIoZmFsc2UpO1xuICAgICAgICBpZiAoc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHRvZ2dsZUNhbWVyYShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHRoZSBpbXBvcnRlZCBtb2R1bGUgYXBwcm9hY2ggLSBzaW1pbGFyIHRvIGNhbGlicmF0ZVxuICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldFJhbmRvbSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgcmVmZXJlbmNlIG1ldGhvZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgQWN0aW9uQnV0dG9uR3JvdXAgcmVmIG1ldGhvZCBmb3IgU2V0IFJhbmRvbScpO1xuICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQuaGFuZGxlU2V0UmFuZG9tKCk7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMgJiYgXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlU2V0UmFuZG9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZ2xvYmFsIG1ldGhvZFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBnbG9iYWwgYnJpZGdlIG1ldGhvZCBmb3IgU2V0IFJhbmRvbScpO1xuICAgICAgICAgIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlU2V0UmFuZG9tKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjYW52YXMgdG8gd29yayB3aXRoXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIG5vdCBmb3VuZCBmb3IgcmFuZG9tIHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChcIkVycm9yOiBDYW52YXMgbm90IGF2YWlsYWJsZSBmb3IgcmFuZG9tIHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IGNvbnRyb2wgdmFsdWVzIGZyb20gdGhlIFRvcEJhclxuICAgICAgICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkJyk7XG4gICAgICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb250cm9sLWlucHV0LWZpZWxkJylbMV07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgaWYgaW5wdXRzIGNhbid0IGJlIGZvdW5kXG4gICAgICAgICAgbGV0IHRpbWVzID0gMTtcbiAgICAgICAgICBsZXQgZGVsYXkgPSAzO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFBhcnNlIGlucHV0IHZhbHVlcyBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZFRpbWUpICYmIHBhcnNlZFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgIHRpbWVzID0gcGFyc2VkVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWREZWxheSkgJiYgcGFyc2VkRGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VkRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvYWQgYWxsIHJlcXVpcmVkIG1vZHVsZXMgZmlyc3QsIHRoZW4gcHJvY2VlZCB3aXRoIGV4ZWN1dGlvblxuICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnKSxcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZScpXG4gICAgICAgICAgXSkudGhlbihhc3luYyAoW1xuICAgICAgICAgICAgY291bnRTYXZlTW9kdWxlLFxuICAgICAgICAgICAgc2F2ZWZpbGVNb2R1bGVcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICAvLyBEZXN0cnVjdHVyZSB0aGUgaW1wb3J0ZWQgbW9kdWxlc1xuICAgICAgICAgICAgY29uc3QgeyBnZXRSYW5kb21Qb3NpdGlvbiwgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSA9IGNvdW50U2F2ZU1vZHVsZTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSA9IHNhdmVmaWxlTW9kdWxlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBQcm9jZXNzIGFsbCBjYXB0dXJlcyBzZXF1ZW50aWFsbHlcbiAgICAgICAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgICAgICAgIGxldCBjdXJyZW50Q2FwdHVyZSA9IDE7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudENhcHR1cmUgPD0gdGltZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYXB0dXJlICR7Y3VycmVudENhcHR1cmV9IG9mICR7dGltZXN9YCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgY2FudmFzIGJlZm9yZSBlYWNoIGNhcHR1cmVcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHBvc2l0aW9uIGZvciB0aGlzIGNhcHR1cmVcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhbmRvbVBvc2l0aW9uKGNhbnZhcywgMjApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSByZWRyYXdJbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICAgICAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFJ1biBjb3VudGRvd24gYW5kIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICBydW5Db3VudGRvd24oXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgVUkgYmFzZWQgb24gc3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYXB0dXJlICR7Y3VycmVudENhcHR1cmV9LyR7dGltZXN9OiAke3N0YXR1cy5wcm9jZXNzU3RhdHVzfWApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbCBhZnRlciBjb3VudGRvd25cbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGJyaWVmbHkgYWZ0ZXIgY291bnRkb3duXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyXG4gICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FwdHVyaW5nIHBvaW50ICR7Y3VycmVudENhcHR1cmV9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIGNhcHR1cmVzIGZvciB0aGUgc3BlY2lmaWVkIGRlbGF5IHRpbWVcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENhcHR1cmUgPCB0aW1lcykge1xuICAgICAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgV2FpdGluZyAke2RlbGF5fXMgYmVmb3JlIG5leHQgY2FwdHVyZS4uLmApO1xuICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5ICogMTAwMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIG5leHQgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDYXB0dXJlKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFNlcXVlbmNlIGNvbXBsZXRlXG4gICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYFJhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IGNhcHR1cmVzIHN1Y2Nlc3NmdWxgKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUmFuZG9tIHNlcXVlbmNlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYFJhbmRvbSBzZXF1ZW5jZSBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRTaG93VG9wQmFyKHRydWUpLCAyMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBtb2R1bGVzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmFuZG9tRG90JzpcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnUmFuZG9tIGRvdCBhY3Rpb24gdHJpZ2dlcmVkJyk7XG4gICAgICAgIHNldFNob3dUb3BCYXIoZmFsc2UpO1xuICAgICAgICBpZiAoc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHRvZ2dsZUNhbWVyYShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coJ0F0dGVtcHRpbmcgdG8gYWNjZXNzIFJhbmRvbSBEb3QgZnVuY3Rpb25hbGl0eScpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIHRoZSByYW5kb20gZG90IGZ1bmN0aW9uYWxpdHkgZnJvbSBhY3Rpb25CdXR0b24uanMgYnkgZGVsZWdhdGluZyB0byBBY3Rpb25CdXR0b25Hcm91cFxuICAgICAgICAvLyBUaGlzIGFzc3VtZXMgeW91IGhhdmUgYSByZWYgdG8gdGhlIEFjdGlvbkJ1dHRvbkdyb3VwIGNvbXBvbmVudFxuICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVJhbmRvbURvdCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyByZWYgbWV0aG9kJyk7XG4gICAgICAgICAgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC5oYW5kbGVSYW5kb21Eb3QoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zICYmIFxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zLmhhbmRsZVJhbmRvbURvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBnbG9iYWwgYnJpZGdlIG1ldGhvZCcpO1xuICAgICAgICAgIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlUmFuZG9tRG90KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRmFsbGJhY2sgaW1wbGVtZW50YXRpb25cbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgbm90IGZvdW5kIGZvciByYW5kb20gZG90IGFjdGlvblwiKTtcbiAgICAgICAgICAgIHNldE91dHB1dFRleHQoXCJFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGUgZm9yIHJhbmRvbSBkb3RcIik7XG4gICAgICAgICAgICBzZXRTaG93VG9wQmFyKHRydWUpOyAvLyBTaG93IFRvcEJhciBhZ2FpbiBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gcHJldmlld0FyZWFSZWYuY3VycmVudDtcbiAgICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlBhcmVudCBub3QgZm91bmQgZm9yIGNhbnZhc1wiKTtcbiAgICAgICAgICAgIHNldE91dHB1dFRleHQoXCJFcnJvcjogQ2FudmFzIHBhcmVudCBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJbml0aWFsaXplIGNhbnZhcyBleHBsaWNpdGx5XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgcmVhZHkgZm9yIHJhbmRvbSBkb3Q6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCByZWZlcmVuY2VcbiAgICAgICAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHBvc2l0aW9uXG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHRoZSBkb3QgdXNpbmcgdGhlIGltcG9ydGVkIGZ1bmN0aW9uXG4gICAgICAgICAgY29uc3QgZG90ID0gZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDgsIGZhbHNlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUmFuZG9tIGRvdCBkcmF3biBhdDogJHtwb3NpdGlvbi54fSwgJHtwb3NpdGlvbi55fWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFN0YXJ0IGEgY291bnRkb3duIGZvciBjYXB0dXJlXG4gICAgICAgICAgcnVuQ291bnRkb3duKFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBVSSBiYXNlZCBvbiBzdGF0dXNcbiAgICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChzdGF0dXMucHJvY2Vzc1N0YXR1cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEVuYWJsZSBjYW1lcmEgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgICAgICAgLy8gdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFdhaXQgYnJpZWZseSBmb3IgY2FtZXJhIHRvIGluaXRpYWxpemVcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBkaXJlY3RseSBpbXBvcnRlZCBjYXB0dXJlSW1hZ2VzQXRQb2ludCBmcm9tIHRoZSBIZWxwZXIvc2F2ZWZpbGUuanNcbiAgICAgICAgICAgICAgICBpbXBvcnQoJy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9IZWxwZXIvc2F2ZWZpbGUnKS50aGVuKCh7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRTaG93VG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMjAwKTtcbiAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgaW1hZ2VzOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW1wb3J0aW5nIHNhdmVmaWxlIG1vZHVsZTpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaGVhZFBvc2UnOlxuICAgICAgICBjb25zdCBuZXdIZWFkUG9zZVN0YXRlID0gIXNob3dIZWFkUG9zZTtcbiAgICAgICAgc2V0U2hvd0hlYWRQb3NlKG5ld0hlYWRQb3NlU3RhdGUpO1xuICAgICAgICBzZXRPdXRwdXRUZXh0KGBIZWFkIHBvc2UgdmlzdWFsaXphdGlvbiAke25ld0hlYWRQb3NlU3RhdGUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgICAgICBpZiAobmV3SGVhZFBvc2VTdGF0ZSAmJiAhc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghbmV3SGVhZFBvc2VTdGF0ZSAmJiAhc2hvd0JvdW5kaW5nQm94ICYmICFzaG93TWFzayAmJiAhc2hvd1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJvY2Vzc29yIG9wdGlvbnMgaWYgY2FtZXJhIGlzIGFjdGl2ZVxuICAgICAgICBpZiAoc2hvd0NhbWVyYSAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAuLi53aW5kb3cudmlkZW9Qcm9jZXNzb3Iub3B0aW9ucyxcbiAgICAgICAgICAgIHNob3dIZWFkUG9zZTogbmV3SGVhZFBvc2VTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ2JvdW5kaW5nQm94JzpcbiAgICAgICAgY29uc3QgbmV3Qm91bmRpbmdCb3hTdGF0ZSA9ICFzaG93Qm91bmRpbmdCb3g7XG4gICAgICAgIHNldFNob3dCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveFN0YXRlKTtcbiAgICAgICAgc2V0T3V0cHV0VGV4dChgQm91bmRpbmcgYm94ICR7bmV3Qm91bmRpbmdCb3hTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICAgICAgaWYgKG5ld0JvdW5kaW5nQm94U3RhdGUgJiYgIXNob3dDYW1lcmEpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld0JvdW5kaW5nQm94U3RhdGUgJiYgIXNob3dIZWFkUG9zZSAmJiAhc2hvd01hc2sgJiYgIXNob3dQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2Nlc3NvciBvcHRpb25zIGlmIGNhbWVyYSBpcyBhY3RpdmVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgLi4ud2luZG93LnZpZGVvUHJvY2Vzc29yLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3g6IG5ld0JvdW5kaW5nQm94U3RhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgY29uc3QgbmV3TWFza1N0YXRlID0gIXNob3dNYXNrO1xuICAgICAgICBzZXRTaG93TWFzayhuZXdNYXNrU3RhdGUpO1xuICAgICAgICBzZXRPdXRwdXRUZXh0KGBNYXNrICR7bmV3TWFza1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgICAgICBpZiAobmV3TWFza1N0YXRlICYmICFzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdNYXNrU3RhdGUgJiYgIXNob3dIZWFkUG9zZSAmJiAhc2hvd0JvdW5kaW5nQm94ICYmICFzaG93UGFyYW1ldGVycykge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9ucyBpZiBjYW1lcmEgaXMgYWN0aXZlXG4gICAgICAgIGlmIChzaG93Q2FtZXJhICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgIC4uLndpbmRvdy52aWRlb1Byb2Nlc3Nvci5vcHRpb25zLFxuICAgICAgICAgICAgc2hvd01hc2s6IG5ld01hc2tTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ3BhcmFtZXRlcnMnOlxuICAgICAgICBjb25zdCBuZXdQYXJhbWV0ZXJzU3RhdGUgPSAhc2hvd1BhcmFtZXRlcnM7XG4gICAgICAgIHNldFNob3dQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnNTdGF0ZSk7XG4gICAgICAgIHNldE91dHB1dFRleHQoYFBhcmFtZXRlcnMgJHtuZXdQYXJhbWV0ZXJzU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgICAgIGlmIChuZXdQYXJhbWV0ZXJzU3RhdGUgJiYgIXNob3dDYW1lcmEpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld1BhcmFtZXRlcnNTdGF0ZSAmJiAhc2hvd0hlYWRQb3NlICYmICFzaG93Qm91bmRpbmdCb3ggJiYgIXNob3dNYXNrKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2Nlc3NvciBvcHRpb25zIGlmIGNhbWVyYSBpcyBhY3RpdmVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgLi4ud2luZG93LnZpZGVvUHJvY2Vzc29yLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93UGFyYW1ldGVyczogbmV3UGFyYW1ldGVyc1N0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgLy8gRml4ZWQgY2FsaWJyYXRlIGNhc2UgaGFuZGxlciBpbiBpbmRleC5qc1xuICAgICAgY2FzZSAnY2FsaWJyYXRlJzpcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nKTtcbiAgICAgICAgc2V0U2hvd1RvcEJhcihmYWxzZSk7XG4gICAgICAgIGlmIChzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgdG9nZ2xlQ2FtZXJhKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldENhbGlicmF0ZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgcmVmZXJlbmNlIG1ldGhvZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgQWN0aW9uQnV0dG9uR3JvdXAgcmVmIG1ldGhvZCBmb3IgY2FsaWJyYXRpb24nKTtcbiAgICAgICAgICBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldENhbGlicmF0ZSgpO1xuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zICYmIFxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zLmhhbmRsZVNldENhbGlicmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGdsb2JhbCBtZXRob2RcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgZ2xvYmFsIGJyaWRnZSBtZXRob2QgZm9yIGNhbGlicmF0aW9uJyk7XG4gICAgICAgICAgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucy5oYW5kbGVTZXRDYWxpYnJhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNhbnZhcyB0byB3b3JrIHdpdGhcbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgbm90IGZvdW5kIGZvciBjYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICAgIHNldE91dHB1dFRleHQoXCJFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGUgZm9yIGNhbGlicmF0aW9uXCIpO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9hZCBhbGwgcmVxdWlyZWQgbW9kdWxlcyBmaXJzdCwgdGhlbiBwcm9jZWVkIHdpdGggZXhlY3V0aW9uXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cycpLFxuICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL2NvdW50U2F2ZScpLFxuICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJylcbiAgICAgICAgICBdKS50aGVuKGFzeW5jIChbXG4gICAgICAgICAgICBjYWxpYnJhdGVQb2ludHNNb2R1bGUsXG4gICAgICAgICAgICBjb3VudFNhdmVNb2R1bGUsXG4gICAgICAgICAgICBzYXZlZmlsZU1vZHVsZVxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIC8vIERlc3RydWN0dXJlIHRoZSBpbXBvcnRlZCBtb2R1bGVzXG4gICAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSA9IGNhbGlicmF0ZVBvaW50c01vZHVsZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSA9IGNvdW50U2F2ZU1vZHVsZTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSA9IHNhdmVmaWxlTW9kdWxlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgICAgICAgICByaWdodDogMTBweDtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCAxMnB4JztcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICAgICAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb246IEluaXRpYWxpemluZy4uLic7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFjY2VzcyB3ZWJjYW0gYmVmb3JlIHN0YXJ0aW5nIGNhbGlicmF0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXJDYW1lcmFBY2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUHJvY2VzcyBwb2ludHMgc2VxdWVudGlhbGx5XG4gICAgICAgICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgbmV3IHBvaW50XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBSdW4gY291bnRkb3duXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICBydW5Db3VudGRvd24oXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXc6IHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyXG4gICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FwdHVyaW5nIHBvaW50ICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgYSBkZWxheVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRTaG93VG9wQmFyKHRydWUpLCAyMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBtb2R1bGVzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdjbGVhckFsbCc6XG4gICAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgICAvLyBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgc2V0T3V0cHV0VGV4dCgnQ2FudmFzIGNsZWFyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZXRPdXRwdXRUZXh0KGBBY3Rpb24gdHJpZ2dlcmVkOiAke2FjdGlvblR5cGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cChmYWxzZSk7XG4gICAgc2V0Q2FtZXJhUGVybWlzc2lvbkdyYW50ZWQodHJ1ZSk7XG4gICAgdG9nZ2xlQ2FtZXJhKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25EZW5pZWQgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgc2V0T3V0cHV0VGV4dCgnQ2FtZXJhIHBlcm1pc3Npb24gZGVuaWVkJyk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2FtZXJhQ2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIHRvZ2dsZUNhbWVyYShmYWxzZSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2FtZXJhUmVhZHkgPSAoZGltZW5zaW9ucykgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICBzZXRNZXRyaWNzKHtcbiAgICAgIHdpZHRoOiBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkaW1lbnNpb25zLmhlaWdodCxcbiAgICAgIGRpc3RhbmNlOiBkaW1lbnNpb25zLmRpc3RhbmNlIHx8ICctLS0nXG4gICAgfSk7XG4gICAgc2V0T3V0cHV0VGV4dChgQ2FtZXJhIHJlYWR5OiAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIHRvcCBiYXIgZnVuY3Rpb25cbiAgY29uc3QgdG9nZ2xlVG9wQmFyID0gKHNob3cpID0+IHtcbiAgICBjb25zdCBuZXdUb3BCYXJTdGF0ZSA9IHNob3cgIT09IHVuZGVmaW5lZCA/IHNob3cgOiAhc2hvd1RvcEJhcjtcbiAgICBzZXRTaG93VG9wQmFyKG5ld1RvcEJhclN0YXRlKTtcbiAgICBcbiAgICAvLyBBbHNvIGhpZGUgbWV0cmljcyB3aGVuIGhpZGluZyB0aGUgdG9wIGJhclxuICAgIGlmICghbmV3VG9wQmFyU3RhdGUpIHtcbiAgICAgIHNldFNob3dNZXRyaWNzKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgc2V0T3V0cHV0VGV4dChgVG9wQmFyICR7bmV3VG9wQmFyU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9JHshbmV3VG9wQmFyU3RhdGUgPyAnLCBNZXRyaWNzIGhpZGRlbicgOiAnJ31gKTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBzdGF0ZSB1cGRhdGUgYW5kIERPTSBjaGFuZ2VzLCB0aGVuIGFkanVzdCBjYW52YXNcbiAgICBzZXRUaW1lb3V0KGFkanVzdENhbnZhc0RpbWVuc2lvbnMsIDEwMCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIG1ldHJpY3MgZnVuY3Rpb25cbiAgY29uc3QgdG9nZ2xlTWV0cmljcyA9ICgpID0+IHtcbiAgICBpZiAoc2hvd1RvcEJhcikge1xuICAgICAgc2V0U2hvd01ldHJpY3MocHJldiA9PiAhcHJldik7XG4gICAgICBzZXRPdXRwdXRUZXh0KGBNZXRyaWNzICR7IXNob3dNZXRyaWNzID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0b3BCYXIgaXMgaGlkZGVuLCB3ZSBjYW4ndCBzaG93IG1ldHJpY3NcbiAgICAgIHNldE91dHB1dFRleHQoJ0Nhbm5vdCBzaG93IG1ldHJpY3Mgd2hlbiBUb3BCYXIgaXMgaGlkZGVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHRyaWdnZXIgY2FtZXJhIGFjY2Vzc1xuICBjb25zdCB0cmlnZ2VyQ2FtZXJhQWNjZXNzID0gKGZvcmNlRW5hYmxlKSA9PiB7XG4gICAgaWYgKGZvcmNlRW5hYmxlKSB7XG4gICAgICAvLyBUcnkgdG8gZW5hYmxlIGNhbWVyYSBkaXJlY3RseVxuICAgICAgaWYgKHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICBzZXRTaG93Q2FtZXJhKHRydWUpO1xuICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgICBzZXRDYW1lcmFQZXJtaXNzaW9uR3JhbnRlZCh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHZpZGVvIHByb2Nlc3Npbmcgd2l0aCBjdXJyZW50IG9wdGlvbnNcbiAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnN0YXJ0VmlkZW9Qcm9jZXNzaW5nKHtcbiAgICAgICAgICBzaG93SGVhZFBvc2UsXG4gICAgICAgICAgc2hvd0JvdW5kaW5nQm94LFxuICAgICAgICAgIHNob3dNYXNrLFxuICAgICAgICAgIHNob3dQYXJhbWV0ZXJzLFxuICAgICAgICAgIHNob3dQcm9jZXNzZWRJbWFnZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBKdXN0IHRvZ2dsZSBjdXJyZW50IHN0YXRlIGlmIG5vdCBmb3JjaW5nXG4gICAgaWYgKGNhbWVyYVBlcm1pc3Npb25HcmFudGVkKSB7XG4gICAgICB0b2dnbGVDYW1lcmEoIXNob3dDYW1lcmEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIER5bmFtaWMgY2xhc3MgdG8gcmVmbGVjdCBjdXJyZW50IHdpbmRvdyBzaXplXG4gIGNvbnN0IGdldFNpemVDbGFzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBlcmNlbnRhZ2UgfSA9IHdpbmRvd1NpemU7XG4gICAgaWYgKHBlcmNlbnRhZ2UgPCAzNSkgcmV0dXJuICd3aW5kb3ctc2l6ZS10aW55JztcbiAgICBpZiAocGVyY2VudGFnZSA8IDUwKSByZXR1cm4gJ3dpbmRvdy1zaXplLXNtYWxsJztcbiAgICBpZiAocGVyY2VudGFnZSA8IDcwKSByZXR1cm4gJ3dpbmRvdy1zaXplLW1lZGl1bSc7XG4gICAgcmV0dXJuICd3aW5kb3ctc2l6ZS1sYXJnZSc7XG4gIH07XG5cbiAgLy8gQWRkIHRoaXMgZnVuY3Rpb24gdG8gaGFuZGxlIHNldHRpbmdzIHZpc2liaWxpdHlcbiAgY29uc3QgaGFuZGxlU2V0dGluZ3NWaXNpYmlsaXR5ID0gKGlzVmlzaWJsZSkgPT4ge1xuICAgIHNldFNob3dTZXR0aW5ncyhpc1Zpc2libGUpO1xuICB9O1xuXG4gIC8vIEFkZCB0aGlzIGVmZmVjdCB0byBsaXN0ZW4gZm9yIHNldHRpbmdzIHZpc2liaWxpdHkgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzTWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ1NIT1dfU0VUVElOR1MnKSB7XG4gICAgICAgIHNldFNob3dTZXR0aW5ncyhldmVudC5kYXRhLnNob3cpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVNldHRpbmdzTWVzc2FnZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlU2V0dGluZ3NNZXNzYWdlKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIHNldEN1cnJlbnRVc2VySWQoZXZlbnQuZGV0YWlsLnVzZXJJZCk7XG4gICAgICAgIC8vIERpc3BhdGNoIGV2ZW50IHRvIHVwZGF0ZSBzZXR0aW5ncyBmb3IgdGhlIG5ldyB1c2VyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICB0eXBlOiAnY2FwdHVyZVNldHRpbmdzJyxcbiAgICAgICAgICAgIHVzZXJJZDogZXZlbnQuZGV0YWlsLnVzZXJJZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBJbml0aWFsaXplIHNldHRpbmdzIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjb25zZW50VXNlcklkKSB7XG4gICAgICAvLyBTZXQgdGhlIGN1cnJlbnQgdXNlciBJRFxuICAgICAgc2V0Q3VycmVudFVzZXJJZChjb25zZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQgdG8gdXBkYXRlIHNldHRpbmdzIGZvciB0aGlzIHVzZXJcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHR5cGU6ICdjYXB0dXJlU2V0dGluZ3MnLFxuICAgICAgICAgIHVzZXJJZDogY29uc2VudFVzZXJJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9XG4gIH0sIFtjb25zZW50VXNlcklkXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGJhY2tlbmQgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbG9hZFNldHRpbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFjb25zZW50VXNlcklkKSByZXR1cm47XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvc2V0dGluZ3MvJHtjb25zZW50VXNlcklkfWApO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBzZXR0aW5ncycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvYWRlZFNldHRpbmdzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIGNvbXBvbmVudCB0byBiZSBtb3VudGVkIGFuZCByZWYgdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgY29uc3Qgd2FpdEZvclJlZiA9IChyZXRyaWVzID0gNSkgPT4ge1xuICAgICAgICAgIGlmIChhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50ICYmIHR5cGVvZiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LnVwZGF0ZVNldHRpbmdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHNldHRpbmdzIGZvciB0aGlzIHVzZXJcbiAgICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQudXBkYXRlU2V0dGluZ3MobG9hZGVkU2V0dGluZ3MpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBEaXNwYXRjaCBldmVudCB0byB1cGRhdGUgVUlcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCB7XG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdjYXB0dXJlU2V0dGluZ3MnLFxuICAgICAgICAgICAgICAgIHVzZXJJZDogY29uc2VudFVzZXJJZCxcbiAgICAgICAgICAgICAgICB0aW1lczogbG9hZGVkU2V0dGluZ3MudGltZXMsXG4gICAgICAgICAgICAgICAgZGVsYXk6IGxvYWRlZFNldHRpbmdzLmRlbGF5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmV0cmllcyA+IDApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gd2FpdEZvclJlZihyZXRyaWVzIC0gMSksIDUwMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQWN0aW9uQnV0dG9uR3JvdXAgcmVmIG5vdCBpbml0aWFsaXplZCBhZnRlciByZXRyaWVzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgd2FpdEZvclJlZigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgc2V0VGltZW91dChsb2FkU2V0dGluZ3MsIDEwMDApO1xuICB9LCBbY29uc2VudFVzZXJJZF0pO1xuXG4gIC8vIEFkZCBwb2xsaW5nIGZvciByZWFsLXRpbWUgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoVXBkYXRlcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghY29uc2VudFVzZXJJZCkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7Y29uc2VudFVzZXJJZH1gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggc2V0dGluZ3MnKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LnVwZGF0ZVNldHRpbmdzKSB7XG4gICAgICAgICAgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC51cGRhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBZb3UgY2FuIGFkZCBpbWFnZSBmZXRjaGluZyBsb2dpYyBoZXJlIGlmIG5lZWRlZFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXBkYXRlczonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWwgZmV0Y2hcbiAgICBmZXRjaFVwZGF0ZXMoKTtcblxuICAgIC8vIFNldCB1cCBwb2xsaW5nIGludGVydmFsXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmZXRjaFVwZGF0ZXMsIDMwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH07XG4gIH0sIFtjb25zZW50VXNlcklkXSk7XG5cbiAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyBmb3Igc2V0dGluZ3MgYW5kIGltYWdlIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbD8udHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycgJiYgZXZlbnQuZGV0YWlsPy51c2VySWQgPT09IGNvbnNlbnRVc2VySWQpIHtcbiAgICAgICAgY29uc3QgeyB0aW1lcywgZGVsYXkgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQgJiYgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC51cGRhdGVTZXR0aW5ncykge1xuICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQudXBkYXRlU2V0dGluZ3MoeyB0aW1lcywgZGVsYXkgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlSW1hZ2VVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWw/LnR5cGUgPT09ICdpbWFnZScgJiYgZXZlbnQuZGV0YWlsPy51c2VySWQgPT09IGNvbnNlbnRVc2VySWQpIHtcbiAgICAgICAgY29uc3QgeyBpbWFnZSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAvLyBVcGRhdGUgaW1hZ2UgaW4gdGhlIFVJIGlmIG5lZWRlZFxuICAgICAgICAvLyBZb3UgY2FuIGFkZCB5b3VyIGltYWdlIHVwZGF0ZSBsb2dpYyBoZXJlXG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ltYWdlVXBkYXRlJywgaGFuZGxlSW1hZ2VVcGRhdGUpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW1hZ2VVcGRhdGUnLCBoYW5kbGVJbWFnZVVwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2NvbnNlbnRVc2VySWRdKTtcblxuICAvLyBMb2FkIHNldHRpbmdzIGZvciBhIHNwZWNpZmljIHVzZXJcbiAgY29uc3QgbG9hZFNldHRpbmdzID0gYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnTG9hZGluZyBzZXR0aW5ncyBmb3IgdXNlcjonLCB1c2VySWQpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gKTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHNldHRpbmdzJyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHNldHRpbmdzOicsIHVzZXJTZXR0aW5ncyk7XG4gICAgICBcbiAgICAgIC8vIERpc3BhdGNoIHNldHRpbmdzIHVwZGF0ZSBldmVudFxuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdHlwZTogJ2NhcHR1cmVTZXR0aW5ncycsXG4gICAgICAgICAgdXNlcklkLFxuICAgICAgICAgIC4uLnVzZXJTZXR0aW5nc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhhbmRsZSB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29uc2VudFVzZXJJZCAmJiBjb25zZW50VXNlcklkICE9PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygnVXNlciBJRCBjaGFuZ2VkIGluIGluZGV4LmpzOicsIGNvbnNlbnRVc2VySWQpO1xuICAgICAgc2V0Q3VycmVudFVzZXJJZChjb25zZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQgdG8gbm90aWZ5IG90aGVyIGNvbXBvbmVudHNcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd1c2VySWRDaGFuZ2UnLCB7XG4gICAgICAgIGRldGFpbDogeyB1c2VySWQ6IGNvbnNlbnRVc2VySWQgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICBcbiAgICAgIC8vIExvYWQgc2V0dGluZ3MgZm9yIHRoZSBuZXcgdXNlclxuICAgICAgbG9hZFNldHRpbmdzKGNvbnNlbnRVc2VySWQpO1xuICAgIH1cbiAgfSwgW2NvbnNlbnRVc2VySWQsIGN1cnJlbnRVc2VySWRdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzLCBkZWxheSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAodXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXR0aW5ncyBmb3IgdGhpcyB1c2VyXG4gICAgICAgICAgaWYgKGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQgJiYgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC51cGRhdGVTZXR0aW5ncykge1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC51cGRhdGVTZXR0aW5ncyh7XG4gICAgICAgICAgICAgIHRpbWVzOiB0aW1lcyB8fCAxLFxuICAgICAgICAgICAgICBkZWxheTogZGVsYXkgfHwgM1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtgbWFpbi1jb250YWluZXIgJHtnZXRTaXplQ2xhc3MoKX1gfT5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+Q2FtZXJhIERhdGFzZXQgQ29sbGVjdGlvbjwvdGl0bGU+XG4gICAgICAgIDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiIC8+XG4gICAgICA8L0hlYWQ+XG4gICAgICBcbiAgICAgIHsvKiBCYWNrZW5kIGNvbm5lY3Rpb24gc3RhdHVzIGJhbm5lciAqL31cbiAgICAgIHtpc0h5ZHJhdGVkICYmIGJhY2tlbmRTdGF0dXMgPT09ICdkaXNjb25uZWN0ZWQnICYmIChcbiAgICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgcGFkZGluZzogJzZweCAwJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZlMGIyJyxcbiAgICAgICAgICBjb2xvcjogJyNlNjUxMDAnLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgekluZGV4OiAxMTAwXG4gICAgICAgIH19PlxuICAgICAgICAgIOKaoO+4jyBCYWNrZW5kIGRpc2Nvbm5lY3RlZC4gSHVycnkgdXAsIE1ha2UgT05MSU5FIHBsZWFzZSBhbmQgVXNpbmcgbW9jayBtb2RlXG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgey8qIFdhcm5pbmcgbWVzc2FnZSBiYW5uZXIgKi99XG4gICAgICB7aXNIeWRyYXRlZCAmJiBzaG93V2FybmluZyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwid2FybmluZy1iYW5uZXJcIiBzdHlsZT17e1xuICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgIHRvcDogc2hvd1RvcEJhciA/IChiYWNrZW5kU3RhdHVzID09PSAnZGlzY29ubmVjdGVkJyA/ICczMnB4JyA6ICc2MHB4JykgOiAnMCcsXG4gICAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZWIzYicsXG4gICAgICAgICAgY29sb3I6ICcjMzMzJyxcbiAgICAgICAgICBwYWRkaW5nOiAnMTBweCcsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICBib3hTaGFkb3c6ICcwIDJweCA0cHggcmdiYSgwLDAsMCwwLjIpJyxcbiAgICAgICAgICB6SW5kZXg6IDEwMTAsXG4gICAgICAgICAgYW5pbWF0aW9uOiAnZmFkZUluIDAuM3MgZWFzZS1pbi1vdXQnXG4gICAgICAgIH19PlxuICAgICAgICAgIDxzdHJvbmc+4pqg77iPIHt3YXJuaW5nTWVzc2FnZX08L3N0cm9uZz5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7aXNMb2FkaW5nID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxvYWRpbmctY29udGFpbmVyXCI+XG4gICAgICAgICAgPHA+TG9hZGluZyB1c2VyIHNldHRpbmdzLi4uPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgey8qIExvYWQgdGhlIHZpZGVvIHByb2Nlc3NvciBjb21wb25lbnQgKi99XG4gICAgICAgICAge2lzSHlkcmF0ZWQgJiYgaXNDbGllbnQgJiYgPFZpZGVvUHJvY2Vzc29yQ29tcG9uZW50IC8+fVxuICAgICAgICAgIFxuICAgICAgICAgIHsvKiBUb3BCYXIgY29tcG9uZW50IHdpdGggb25CdXR0b25DbGljayBoYW5kbGVyIC0gY29uZGl0aW9uYWxseSByZW5kZXJlZCAqL31cbiAgICAgICAgICB7c2hvd1RvcEJhciAmJiAoXG4gICAgICAgICAgICA8VG9wQmFyIFxuICAgICAgICAgICAgICBvbkJ1dHRvbkNsaWNrPXtoYW5kbGVBY3Rpb25CdXR0b25DbGlja31cbiAgICAgICAgICAgICAgb25DYW1lcmFBY2Nlc3M9eygpID0+IHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSl9XG4gICAgICAgICAgICAgIG91dHB1dFRleHQ9e3N0YXR1c01lc3NhZ2UgfHwgb3V0cHV0VGV4dH1cbiAgICAgICAgICAgICAgb25PdXRwdXRDaGFuZ2U9eyh0ZXh0KSA9PiBzZXRPdXRwdXRUZXh0KHRleHQpfVxuICAgICAgICAgICAgICBvblRvZ2dsZVRvcEJhcj17dG9nZ2xlVG9wQmFyfVxuICAgICAgICAgICAgICBvblRvZ2dsZU1ldHJpY3M9e3RvZ2dsZU1ldHJpY3N9XG4gICAgICAgICAgICAgIGNhbnZhc1JlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIFxuICAgICAgICAgIHsvKiBTaG93IHJlc3RvcmUgYnV0dG9uIHdoZW4gVG9wQmFyIGlzIGhpZGRlbiAtIHBvc2l0aW9uZWQgYXQgdG9wIHJpZ2h0ICovfVxuICAgICAgICAgIHshc2hvd1RvcEJhciAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlc3RvcmUtYnV0dG9uLWNvbnRhaW5lclwiIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgICB0b3A6ICcxMHB4JyxcbiAgICAgICAgICAgICAgcmlnaHQ6ICcxMHB4JyxcbiAgICAgICAgICAgICAgekluZGV4OiAxMDAwXG4gICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJyZXN0b3JlLWJ0blwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gdG9nZ2xlVG9wQmFyKHRydWUpfVxuICAgICAgICAgICAgICAgIHRpdGxlPVwiU2hvdyBUb3BCYXIgYW5kIE1ldHJpY3NcIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnNXB4IDEwcHgnLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogJyMwMDY2Y2MnLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAg4omhXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIHsvKiBNYWluIHByZXZpZXcgYXJlYSAqL31cbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgcmVmPXtwcmV2aWV3QXJlYVJlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wcmV2aWV3LWFyZWFcIlxuICAgICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICAgIGhlaWdodDogc2hvd1RvcEJhciA/ICdjYWxjKDEwMHZoIC0gMTIwcHgpJyA6ICcxMDB2aCcsXG4gICAgICAgICAgICAgIG1hcmdpblRvcDogYmFja2VuZFN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcgPyAnMzJweCcgOiAnMCcsXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjVmNWY1JyxcbiAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHsvKiBBY3Rpb24gYnV0dG9ucyBmb3IgY2FtZXJhIGNvbnRyb2wgLSBtb3ZlZCBvdXRzaWRlIGNvbmRpdGlvbmFsIHJlbmRlcmluZyAqL31cbiAgICAgICAgICAgIHsvKiA8ZGl2IGNsYXNzTmFtZT1cImNhbWVyYS1hY3Rpb24tYnV0dG9ucy1jb250YWluZXJcIiBzdHlsZT17eyBcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgIGJvdHRvbTogJzIwcHgnLFxuICAgICAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKScsXG4gICAgICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiAnNjAwcHgnLFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMCAyMHB4J1xuICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgIDxBY3Rpb25CdXR0b25Hcm91cFxuICAgICAgICAgICAgICAgIHJlZj17YWN0aW9uQnV0dG9uR3JvdXBSZWZ9XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcz17dHJpZ2dlckNhbWVyYUFjY2Vzc31cbiAgICAgICAgICAgICAgICBpc0NvbXBhY3RNb2RlPXt3aW5kb3dTaXplLndpZHRoIDwgNzY4fVxuICAgICAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2s9e2hhbmRsZUFjdGlvbkJ1dHRvbkNsaWNrfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+ICovfVxuXG4gICAgICAgICAgICB7IXNob3dDYW1lcmEgPyAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW1lcmEtcHJldmlldy1tZXNzYWdlXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbjogc2hvd1RvcEJhciA/ICdyZWxhdGl2ZScgOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgIHpJbmRleDogNVxuICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgPHA+Q2FtZXJhIHByZXZpZXcgd2lsbCBhcHBlYXIgaGVyZTwvcD5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImNhbWVyYS1zaXplLWluZGljYXRvclwiPkN1cnJlbnQgd2luZG93OiB7d2luZG93U2l6ZS5wZXJjZW50YWdlfSUgb2Ygc2NyZWVuIHdpZHRoPC9wPlxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICB7LyogQ2FtZXJhIHBsYWNlaG9sZGVyIHNxdWFyZSAtIHNtYWxsIHZlcnNpb24gKi99XG4gICAgICAgICAgICAgICAgICB7aXNIeWRyYXRlZCAmJiBzaG93Q2FtZXJhUGxhY2Vob2xkZXIgJiYgKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wbGFjZWhvbGRlci1zcXVhcmVcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzE4MHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEzNXB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzIwcHggYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICcycHggZGFzaGVkICM2NjYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmNWY1ZjUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogJzEuNXJlbScgfX0+8J+TtzwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgey8qIENhbnZhcyBmb3IgZXllIHRyYWNraW5nIGRvdHMgKi99XG4gICAgICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbnZhcy1jb250YWluZXJcIiBcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJywgXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleDogMTAgXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIHsvKiA8Y2FudmFzIFxuICAgICAgICAgICAgICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidHJhY2tpbmctY2FudmFzXCJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyBcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIC8+ICovfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB7LyogTWV0cmljcyBpbmZvIC0gY29uZGl0aW9uYWxseSByZW5kZXJlZCAqL31cbiAgICAgICAgICAgIHtpc0h5ZHJhdGVkICYmIHNob3dNZXRyaWNzICYmIChcbiAgICAgICAgICAgICAgPERpc3BsYXlSZXNwb25zZSBcbiAgICAgICAgICAgICAgICB3aWR0aD17bWV0cmljcy53aWR0aH0gXG4gICAgICAgICAgICAgICAgaGVpZ2h0PXttZXRyaWNzLmhlaWdodH0gXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U9e21ldHJpY3MuZGlzdGFuY2V9XG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlPXtzaG93TWV0cmljc31cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHsvKiBDYW1lcmEgY29tcG9uZW50IC0gdXNpbmcgY2xpZW50LW9ubHkgdmVyc2lvbiAqL31cbiAgICAgICAgICAgIHtpc0h5ZHJhdGVkICYmIGlzQ2xpZW50ICYmIHNob3dDYW1lcmEgJiYgKFxuICAgICAgICAgICAgICA8RHluYW1pY0NhbWVyYUFjY2Vzc1xuICAgICAgICAgICAgICAgIGlzU2hvd2luZz17c2hvd0NhbWVyYX0gXG4gICAgICAgICAgICAgICAgb25DbG9zZT17aGFuZGxlQ2FtZXJhQ2xvc2V9XG4gICAgICAgICAgICAgICAgb25DYW1lcmFSZWFkeT17aGFuZGxlQ2FtZXJhUmVhZHl9XG4gICAgICAgICAgICAgICAgc2hvd0hlYWRQb3NlPXtzaG93SGVhZFBvc2V9XG4gICAgICAgICAgICAgICAgc2hvd0JvdW5kaW5nQm94PXtzaG93Qm91bmRpbmdCb3h9XG4gICAgICAgICAgICAgICAgc2hvd01hc2s9e3Nob3dNYXNrfVxuICAgICAgICAgICAgICAgIHNob3dQYXJhbWV0ZXJzPXtzaG93UGFyYW1ldGVyc31cbiAgICAgICAgICAgICAgICB2aWRlb1JlZj17dmlkZW9SZWZ9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB7LyogQ2FtZXJhIHBlcm1pc3Npb24gcG9wdXAgKi99XG4gICAgICAgICAgICB7aXNIeWRyYXRlZCAmJiBpc0NsaWVudCAmJiBzaG93UGVybWlzc2lvblBvcHVwICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1wb3B1cFwiIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgekluZGV4OiAyMDAwXG4gICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tZGlhbG9nXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHdpZHRoOiAnNDAwcHgnLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMiknXG4gICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tdGl0bGVcIiBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMTVweCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuICAgICAgICAgICAgICAgICAgfX0+Q2FtZXJhIEFjY2VzcyBSZXF1aXJlZDwvaDM+XG4gICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1tZXNzYWdlXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDIwcHgnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMS40J1xuICAgICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBcbiAgICAgICAgICAgICAgICAgICAgV2hlbiBwcm9tcHRlZCBieSB5b3VyIGJyb3dzZXIsIHBsZWFzZSBjbGljayBcIkFsbG93XCIgdG8gZ3JhbnQgY2FtZXJhIGFjY2Vzcy5cbiAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgICAgICAgICAgICAgIGdhcDogJzEwcHgnXG4gICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uRGVuaWVkfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1idG5cIlxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2YwZjBmMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkfVxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1idG5cIlxuICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwNjZjYycsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIENvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiSGVhZCIsImR5bmFtaWMiLCJUb3BCYXIiLCJEaXNwbGF5UmVzcG9uc2UiLCJBY3Rpb25CdXR0b25Hcm91cCIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwicnVuQ291bnRkb3duIiwidXNlQ29uc2VudCIsInVzZVJvdXRlciIsIlZpZGVvUHJvY2Vzc29yQ29tcG9uZW50Iiwic3NyIiwiRHluYW1pY0NhbWVyYUFjY2VzcyIsImxvYWRpbmciLCJkaXYiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInRyYW5zZm9ybSIsIndpZHRoIiwiaGVpZ2h0IiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJ0ZXh0QWxpZ24iLCJ6SW5kZXgiLCJmb250U2l6ZSIsIm1hcmdpbkJvdHRvbSIsInAiLCJmb250V2VpZ2h0IiwiY29sb3IiLCJDb2xsZWN0ZWREYXRhc2V0UGFnZSIsInJvdXRlciIsInVzZXJJZCIsImNvbnNlbnRVc2VySWQiLCJ1c2VyRGF0YSIsInNldFVzZXJEYXRhIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsImlzSHlkcmF0ZWQiLCJzZXRJc0h5ZHJhdGVkIiwiYmFja2VuZFN0YXR1cyIsInNldEJhY2tlbmRTdGF0dXMiLCJzaG93VG9wQmFyIiwic2V0U2hvd1RvcEJhciIsInNob3dXYXJuaW5nIiwic2V0U2hvd1dhcm5pbmciLCJ3YXJuaW5nTWVzc2FnZSIsInNldFdhcm5pbmdNZXNzYWdlIiwic3RhdHVzTWVzc2FnZSIsInNldFN0YXR1c01lc3NhZ2UiLCJvdXRwdXRUZXh0Iiwic2V0T3V0cHV0VGV4dCIsInNob3dNZXRyaWNzIiwic2V0U2hvd01ldHJpY3MiLCJzaG93UGVybWlzc2lvblBvcHVwIiwic2V0U2hvd1Blcm1pc3Npb25Qb3B1cCIsImNhbWVyYVBlcm1pc3Npb25HcmFudGVkIiwic2V0Q2FtZXJhUGVybWlzc2lvbkdyYW50ZWQiLCJzaG93Q2FtZXJhIiwic2V0U2hvd0NhbWVyYSIsInNob3dDYW1lcmFQbGFjZWhvbGRlciIsInNldFNob3dDYW1lcmFQbGFjZWhvbGRlciIsInNob3dIZWFkUG9zZSIsInNldFNob3dIZWFkUG9zZSIsInNob3dCb3VuZGluZ0JveCIsInNldFNob3dCb3VuZGluZ0JveCIsInNob3dNYXNrIiwic2V0U2hvd01hc2siLCJzaG93UGFyYW1ldGVycyIsInNldFNob3dQYXJhbWV0ZXJzIiwid2luZG93U2l6ZSIsInNldFdpbmRvd1NpemUiLCJwZXJjZW50YWdlIiwibWV0cmljcyIsInNldE1ldHJpY3MiLCJkaXN0YW5jZSIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJjYXB0dXJlRm9sZGVyIiwic2V0Q2FwdHVyZUZvbGRlciIsImN1cnJlbnRVc2VySWQiLCJzZXRDdXJyZW50VXNlcklkIiwic2hvd1NldHRpbmdzIiwic2V0U2hvd1NldHRpbmdzIiwicHJldmlld0FyZWFSZWYiLCJjYW52YXNSZWYiLCJ2aWRlb1JlZiIsImFjdGlvbkJ1dHRvbkdyb3VwUmVmIiwibG9hZFVzZXJEYXRhIiwiaXNSZWFkeSIsInF1ZXJ5IiwicGFyc2VkRGF0YSIsIkpTT04iLCJwYXJzZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9LRVkiLCJvayIsIkVycm9yIiwiZGF0YSIsImpzb24iLCJlcnIiLCJjb25zb2xlIiwibWVzc2FnZSIsImNoZWNrQmFja2VuZENvbm5lY3Rpb24iLCJjb25uZWN0ZWQiLCJ1cGRhdGVEaW1lbnNpb25zIiwiY3VycmVudCIsIm9mZnNldFdpZHRoIiwib2Zmc2V0SGVpZ2h0Iiwic2NyZWVuUGVyY2VudGFnZSIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJzY3JlZW4iLCJwcmV2IiwiaW5uZXJIZWlnaHQiLCJNYXRoIiwicm91bmQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxvZyIsInByZWZlcmVuY2VzIiwiY2FtZXJhU2V0dGluZ3MiLCJzaG93IiwidG9wQmFyIiwiZ2V0TWFpbkNhbnZhcyIsIndoaXRlU2NyZWVuQ2FudmFzIiwiZG9jdW1lbnQiLCJjYW52YXNFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIndhcm4iLCJpc0NsaWVudCIsImNhbnZhcyIsImNhbnZhc0RpbWVuc2lvbnMiLCJpbml0aWFsaXplQ2FudmFzIiwicGFyZW50IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJzZXRUaW1lb3V0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImRpbWVuc2lvbnMiLCJyZWN0U2l6ZSIsImlzVmlzaWJsZSIsImFkanVzdENhbnZhc0RpbWVuc2lvbnMiLCJjb250YWluZXIiLCJ0b3BCYXJIZWlnaHQiLCJjb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsInRvcEJhclZpc2libGUiLCJjYWxjdWxhdGVkSGVpZ2h0IiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVwbGFjZSIsImNyZWF0ZUVsZW1lbnQiLCJ0ZXh0Q29udGVudCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwidG9nZ2xlVG9wQmFyIiwidG9nZ2xlQ2FtZXJhIiwic2hvdWxkRW5hYmxlIiwiaGFuZGxlQWN0aW9uQnV0dG9uQ2xpY2siLCJhY3Rpb25UeXBlIiwicGFyYW1zIiwibmV3VG9wQmFyU3RhdGUiLCJ2YWx1ZSIsInNhZmVQYXJhbXMiLCJyYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsImhhbmRsZVNldFJhbmRvbSIsImFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyIsInRpbWVJbnB1dCIsImRlbGF5SW5wdXQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGltZXMiLCJkZWxheSIsInBhcnNlZFRpbWUiLCJwYXJzZUludCIsImlzTmFOIiwicGFyc2VkRGVsYXkiLCJQcm9taXNlIiwiYWxsIiwidGhlbiIsImNvdW50U2F2ZU1vZHVsZSIsInNhdmVmaWxlTW9kdWxlIiwic3VjY2Vzc0NvdW50IiwiY3VycmVudENhcHR1cmUiLCJ4IiwieSIsInJlZHJhd0ludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJyZXNvbHZlIiwic3RhdHVzIiwicHJvY2Vzc1N0YXR1cyIsImNsZWFySW50ZXJ2YWwiLCJjYXB0dXJlUmVzdWx0IiwicG9pbnQiLCJjYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzY3JlZW5JbWFnZSIsInN1Y2Nlc3MiLCJjYXRjaCIsImhhbmRsZVJhbmRvbURvdCIsImRvdCIsIm5ld0hlYWRQb3NlU3RhdGUiLCJ2aWRlb1Byb2Nlc3NvciIsInVwZGF0ZU9wdGlvbnMiLCJvcHRpb25zIiwibmV3Qm91bmRpbmdCb3hTdGF0ZSIsIm5ld01hc2tTdGF0ZSIsIm5ld1BhcmFtZXRlcnNTdGF0ZSIsImhhbmRsZVNldENhbGlicmF0ZSIsImNhbGlicmF0ZVBvaW50c01vZHVsZSIsImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJwb2ludHMiLCJsZW5ndGgiLCJzdGF0dXNJbmRpY2F0b3IiLCJjbGFzc05hbWUiLCJjc3NUZXh0IiwiYm9keSIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpIiwicGFyZW50Tm9kZSIsImhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCIsImhhbmRsZVBlcm1pc3Npb25EZW5pZWQiLCJoYW5kbGVDYW1lcmFDbG9zZSIsImhhbmRsZUNhbWVyYVJlYWR5IiwidW5kZWZpbmVkIiwidG9nZ2xlTWV0cmljcyIsImZvcmNlRW5hYmxlIiwic3RhcnRWaWRlb1Byb2Nlc3NpbmciLCJzaG93UHJvY2Vzc2VkSW1hZ2UiLCJnZXRTaXplQ2xhc3MiLCJoYW5kbGVTZXR0aW5nc1Zpc2liaWxpdHkiLCJoYW5kbGVTZXR0aW5nc01lc3NhZ2UiLCJldmVudCIsInR5cGUiLCJoYW5kbGVVc2VySWRDaGFuZ2UiLCJkZXRhaWwiLCJDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJsb2FkU2V0dGluZ3MiLCJsb2FkZWRTZXR0aW5ncyIsIndhaXRGb3JSZWYiLCJyZXRyaWVzIiwidXBkYXRlU2V0dGluZ3MiLCJmZXRjaFVwZGF0ZXMiLCJzZXR0aW5ncyIsImludGVydmFsIiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJoYW5kbGVJbWFnZVVwZGF0ZSIsImltYWdlIiwidXNlclNldHRpbmdzIiwidGl0bGUiLCJtZXRhIiwibmFtZSIsImNvbnRlbnQiLCJwYWRkaW5nIiwiYm94U2hhZG93IiwiYW5pbWF0aW9uIiwic3Ryb25nIiwib25CdXR0b25DbGljayIsIm9uQ2FtZXJhQWNjZXNzIiwib25PdXRwdXRDaGFuZ2UiLCJ0ZXh0Iiwib25Ub2dnbGVUb3BCYXIiLCJvblRvZ2dsZU1ldHJpY3MiLCJyaWdodCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJiYWNrZ3JvdW5kIiwiY3Vyc29yIiwicmVmIiwibWFyZ2luVG9wIiwib3ZlcmZsb3ciLCJtYXJnaW4iLCJpc1Nob3dpbmciLCJvbkNsb3NlIiwib25DYW1lcmFSZWFkeSIsImgzIiwibGluZUhlaWdodCIsImdhcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/index.js\n"));

/***/ })

});