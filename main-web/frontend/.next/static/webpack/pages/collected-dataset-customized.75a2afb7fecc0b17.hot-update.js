"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/Settings.js":
/*!********************************!*\
  !*** ./components/Settings.js ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_zoom_pan_pinch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-zoom-pan-pinch */ \"(pages-dir-browser)/./node_modules/react-zoom-pan-pinch/dist/index.esm.js\");\n\nvar _s = $RefreshSig$();\n\n\nconst Settings = ()=>{\n    _s();\n    const [time, setTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [delay, setDelay] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [image, setImage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [canvasSize, setCanvasSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 800,\n        height: 600\n    });\n    const [zoom, setZoom] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const handleImageUpload = (event)=>{\n        const file = event.target.files[0];\n        if (file) {\n            const reader = new FileReader();\n            reader.onloadend = ()=>{\n                setImage(reader.result);\n            };\n            reader.readAsDataURL(file);\n        }\n    };\n    const handleRandomCanvasSize = ()=>{\n        const width = Math.floor(Math.random() * 500) + 500;\n        const height = Math.floor(Math.random() * 400) + 400;\n        setCanvasSize({\n            width,\n            height\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"p-4 space-y-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"block text-sm font-medium text-gray-700\",\n                    children: [\n                        \"Time (s):\",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"number\",\n                            value: time,\n                            onChange: (e)=>setTime(Number(e.target.value)),\n                            className: \"mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                            lineNumber: 33,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                    lineNumber: 31,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                lineNumber: 30,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"block text-sm font-medium text-gray-700\",\n                    children: [\n                        \"Delay (s):\",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"number\",\n                            value: delay,\n                            onChange: (e)=>setDelay(Number(e.target.value)),\n                            className: \"mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                            lineNumber: 45,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                lineNumber: 42,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                    className: \"block text-sm font-medium text-gray-700\",\n                    children: [\n                        \"Upload Image:\",\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                            type: \"file\",\n                            accept: \"image/*\",\n                            onChange: handleImageUpload,\n                            className: \"mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                            lineNumber: 57,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                    lineNumber: 55,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                lineNumber: 54,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"space-y-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: handleRandomCanvasSize,\n                    className: \"w-full bg-indigo-600 text-white py-2 px-4 rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2\",\n                    children: \"Random Canvas Size\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                    lineNumber: 72,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                lineNumber: 71,\n                columnNumber: 7\n            }, undefined),\n            image && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"border rounded-md p-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_zoom_pan_pinch__WEBPACK_IMPORTED_MODULE_2__.TransformWrapper, {\n                    initialScale: 1,\n                    minScale: 0.5,\n                    maxScale: 3,\n                    onZoomChange: (ref)=>setZoom(ref.state.scale),\n                    children: (param)=>{\n                        let { zoomIn, zoomOut, resetTransform } = param;\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex space-x-2 mb-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>zoomIn(),\n                                            className: \"bg-indigo-600 text-white py-1 px-3 rounded-md hover:bg-indigo-700\",\n                                            children: \"+\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                                            lineNumber: 91,\n                                            columnNumber: 19\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>zoomOut(),\n                                            className: \"bg-indigo-600 text-white py-1 px-3 rounded-md hover:bg-indigo-700\",\n                                            children: \"-\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                                            lineNumber: 97,\n                                            columnNumber: 19\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>resetTransform(),\n                                            className: \"bg-indigo-600 text-white py-1 px-3 rounded-md hover:bg-indigo-700\",\n                                            children: \"Reset\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                                            lineNumber: 103,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                                    lineNumber: 90,\n                                    columnNumber: 17\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_zoom_pan_pinch__WEBPACK_IMPORTED_MODULE_2__.TransformComponent, {\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                        src: image,\n                                        alt: \"Uploaded\",\n                                        style: {\n                                            width: canvasSize.width,\n                                            height: canvasSize.height,\n                                            objectFit: 'contain'\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                                        lineNumber: 111,\n                                        columnNumber: 19\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                                    lineNumber: 110,\n                                    columnNumber: 17\n                                }, undefined)\n                            ]\n                        }, void 0, true);\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                    lineNumber: 82,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n                lineNumber: 81,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/components/Settings.js\",\n        lineNumber: 29,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Settings, \"j/D0mUsEZsMo1LI6b5hz2MMq9sc=\");\n_c = Settings;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Settings);\nvar _c;\n$RefreshReg$(_c, \"Settings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvU2V0dGluZ3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0M7QUFDb0M7QUFFNUUsTUFBTUksV0FBVzs7SUFDZixNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR0wsK0NBQVFBLENBQUM7SUFDakMsTUFBTSxDQUFDTSxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ25DLE1BQU0sQ0FBQ1EsT0FBT0MsU0FBUyxHQUFHVCwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNLENBQUNVLFlBQVlDLGNBQWMsR0FBR1gsK0NBQVFBLENBQUM7UUFBRVksT0FBTztRQUFLQyxRQUFRO0lBQUk7SUFDdkUsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdmLCtDQUFRQSxDQUFDO0lBRWpDLE1BQU1nQixvQkFBb0IsQ0FBQ0M7UUFDekIsTUFBTUMsT0FBT0QsTUFBTUUsTUFBTSxDQUFDQyxLQUFLLENBQUMsRUFBRTtRQUNsQyxJQUFJRixNQUFNO1lBQ1IsTUFBTUcsU0FBUyxJQUFJQztZQUNuQkQsT0FBT0UsU0FBUyxHQUFHO2dCQUNqQmQsU0FBU1ksT0FBT0csTUFBTTtZQUN4QjtZQUNBSCxPQUFPSSxhQUFhLENBQUNQO1FBQ3ZCO0lBQ0Y7SUFFQSxNQUFNUSx5QkFBeUI7UUFDN0IsTUFBTWQsUUFBUWUsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssT0FBTztRQUNoRCxNQUFNaEIsU0FBU2MsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQUssT0FBTztRQUNqRGxCLGNBQWM7WUFBRUM7WUFBT0M7UUFBTztJQUNoQztJQUVBLHFCQUNFLDhEQUFDaUI7UUFBSUMsV0FBVTs7MEJBQ2IsOERBQUNEO2dCQUFJQyxXQUFVOzBCQUNiLDRFQUFDQztvQkFBTUQsV0FBVTs7d0JBQTBDO3NDQUV6RCw4REFBQ0U7NEJBQ0NDLE1BQUs7NEJBQ0xDLE9BQU8vQjs0QkFDUGdDLFVBQVUsQ0FBQ0MsSUFBTWhDLFFBQVFpQyxPQUFPRCxFQUFFbEIsTUFBTSxDQUFDZ0IsS0FBSzs0QkFDOUNKLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQUtoQiw4REFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUNDO29CQUFNRCxXQUFVOzt3QkFBMEM7c0NBRXpELDhEQUFDRTs0QkFDQ0MsTUFBSzs0QkFDTEMsT0FBTzdCOzRCQUNQOEIsVUFBVSxDQUFDQyxJQUFNOUIsU0FBUytCLE9BQU9ELEVBQUVsQixNQUFNLENBQUNnQixLQUFLOzRCQUMvQ0osV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBS2hCLDhEQUFDRDtnQkFBSUMsV0FBVTswQkFDYiw0RUFBQ0M7b0JBQU1ELFdBQVU7O3dCQUEwQztzQ0FFekQsOERBQUNFOzRCQUNDQyxNQUFLOzRCQUNMSyxRQUFPOzRCQUNQSCxVQUFVcEI7NEJBQ1ZlLFdBQVU7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQVVoQiw4REFBQ0Q7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUNTO29CQUNDQyxTQUFTZjtvQkFDVEssV0FBVTs4QkFDWDs7Ozs7Ozs7Ozs7WUFLRnZCLHVCQUNDLDhEQUFDc0I7Z0JBQUlDLFdBQVU7MEJBQ2IsNEVBQUM5QixrRUFBZ0JBO29CQUNmeUMsY0FBYztvQkFDZEMsVUFBVTtvQkFDVkMsVUFBVTtvQkFDVkMsY0FBYyxDQUFDQyxNQUFRL0IsUUFBUStCLElBQUlDLEtBQUssQ0FBQ0MsS0FBSzs4QkFFN0M7NEJBQUMsRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGNBQWMsRUFBRTs2Q0FDbkM7OzhDQUNFLDhEQUFDckI7b0NBQUlDLFdBQVU7O3NEQUNiLDhEQUFDUzs0Q0FDQ0MsU0FBUyxJQUFNUTs0Q0FDZmxCLFdBQVU7c0RBQ1g7Ozs7OztzREFHRCw4REFBQ1M7NENBQ0NDLFNBQVMsSUFBTVM7NENBQ2ZuQixXQUFVO3NEQUNYOzs7Ozs7c0RBR0QsOERBQUNTOzRDQUNDQyxTQUFTLElBQU1VOzRDQUNmcEIsV0FBVTtzREFDWDs7Ozs7Ozs7Ozs7OzhDQUlILDhEQUFDN0Isb0VBQWtCQTs4Q0FDakIsNEVBQUNrRDt3Q0FDQ0MsS0FBSzdDO3dDQUNMOEMsS0FBSTt3Q0FDSkMsT0FBTzs0Q0FDTDNDLE9BQU9GLFdBQVdFLEtBQUs7NENBQ3ZCQyxRQUFRSCxXQUFXRyxNQUFNOzRDQUN6QjJDLFdBQVc7d0NBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVVwQjtHQTVITXJEO0tBQUFBO0FBOEhOLGlFQUFlQSxRQUFRQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvY29tcG9uZW50cy9TZXR0aW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUcmFuc2Zvcm1XcmFwcGVyLCBUcmFuc2Zvcm1Db21wb25lbnQgfSBmcm9tICdyZWFjdC16b29tLXBhbi1waW5jaCc7XG5cbmNvbnN0IFNldHRpbmdzID0gKCkgPT4ge1xuICBjb25zdCBbdGltZSwgc2V0VGltZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2RlbGF5LCBzZXREZWxheV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2ltYWdlLCBzZXRJbWFnZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NhbnZhc1NpemUsIHNldENhbnZhc1NpemVdID0gdXNlU3RhdGUoeyB3aWR0aDogODAwLCBoZWlnaHQ6IDYwMCB9KTtcbiAgY29uc3QgW3pvb20sIHNldFpvb21dID0gdXNlU3RhdGUoMSk7XG5cbiAgY29uc3QgaGFuZGxlSW1hZ2VVcGxvYWQgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBmaWxlID0gZXZlbnQudGFyZ2V0LmZpbGVzWzBdO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgc2V0SW1hZ2UocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJhbmRvbUNhbnZhc1NpemUgPSAoKSA9PiB7XG4gICAgY29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA1MDApICsgNTAwO1xuICAgIGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQwMCkgKyA0MDA7XG4gICAgc2V0Q2FudmFzU2l6ZSh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInAtNCBzcGFjZS15LTRcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDBcIj5cbiAgICAgICAgICBUaW1lIChzKTpcbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgdmFsdWU9e3RpbWV9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFRpbWUoTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0xIGJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlci1ncmF5LTMwMCBzaGFkb3ctc20gZm9jdXM6Ym9yZGVyLWluZGlnby01MDAgZm9jdXM6cmluZy1pbmRpZ28tNTAwXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDBcIj5cbiAgICAgICAgICBEZWxheSAocyk6XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgIHZhbHVlPXtkZWxheX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0RGVsYXkoTnVtYmVyKGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0xIGJsb2NrIHctZnVsbCByb3VuZGVkLW1kIGJvcmRlci1ncmF5LTMwMCBzaGFkb3ctc20gZm9jdXM6Ym9yZGVyLWluZGlnby01MDAgZm9jdXM6cmluZy1pbmRpZ28tNTAwXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDBcIj5cbiAgICAgICAgICBVcGxvYWQgSW1hZ2U6XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICBhY2NlcHQ9XCJpbWFnZS8qXCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVJbWFnZVVwbG9hZH1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTEgYmxvY2sgdy1mdWxsIHRleHQtc20gdGV4dC1ncmF5LTUwMFxuICAgICAgICAgICAgICBmaWxlOm1yLTQgZmlsZTpweS0yIGZpbGU6cHgtNFxuICAgICAgICAgICAgICBmaWxlOnJvdW5kZWQtbWQgZmlsZTpib3JkZXItMFxuICAgICAgICAgICAgICBmaWxlOnRleHQtc20gZmlsZTpmb250LXNlbWlib2xkXG4gICAgICAgICAgICAgIGZpbGU6YmctaW5kaWdvLTUwIGZpbGU6dGV4dC1pbmRpZ28tNzAwXG4gICAgICAgICAgICAgIGhvdmVyOmZpbGU6YmctaW5kaWdvLTEwMFwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9sYWJlbD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMlwiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgb25DbGljaz17aGFuZGxlUmFuZG9tQ2FudmFzU2l6ZX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgYmctaW5kaWdvLTYwMCB0ZXh0LXdoaXRlIHB5LTIgcHgtNCByb3VuZGVkLW1kIGhvdmVyOmJnLWluZGlnby03MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWluZGlnby01MDAgZm9jdXM6cmluZy1vZmZzZXQtMlwiXG4gICAgICAgID5cbiAgICAgICAgICBSYW5kb20gQ2FudmFzIFNpemVcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cblxuICAgICAge2ltYWdlICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXIgcm91bmRlZC1tZCBwLTRcIj5cbiAgICAgICAgICA8VHJhbnNmb3JtV3JhcHBlclxuICAgICAgICAgICAgaW5pdGlhbFNjYWxlPXsxfVxuICAgICAgICAgICAgbWluU2NhbGU9ezAuNX1cbiAgICAgICAgICAgIG1heFNjYWxlPXszfVxuICAgICAgICAgICAgb25ab29tQ2hhbmdlPXsocmVmKSA9PiBzZXRab29tKHJlZi5zdGF0ZS5zY2FsZSl9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgeyh7IHpvb21Jbiwgem9vbU91dCwgcmVzZXRUcmFuc2Zvcm0gfSkgPT4gKFxuICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBzcGFjZS14LTIgbWItMlwiPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB6b29tSW4oKX1cbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctaW5kaWdvLTYwMCB0ZXh0LXdoaXRlIHB5LTEgcHgtMyByb3VuZGVkLW1kIGhvdmVyOmJnLWluZGlnby03MDBcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICArXG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gem9vbU91dCgpfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1pbmRpZ28tNjAwIHRleHQtd2hpdGUgcHktMSBweC0zIHJvdW5kZWQtbWQgaG92ZXI6YmctaW5kaWdvLTcwMFwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIC1cbiAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZXNldFRyYW5zZm9ybSgpfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1pbmRpZ28tNjAwIHRleHQtd2hpdGUgcHktMSBweC0zIHJvdW5kZWQtbWQgaG92ZXI6YmctaW5kaWdvLTcwMFwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIFJlc2V0XG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8VHJhbnNmb3JtQ29tcG9uZW50PlxuICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICBzcmM9e2ltYWdlfVxuICAgICAgICAgICAgICAgICAgICBhbHQ9XCJVcGxvYWRlZFwiXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNhbnZhc1NpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXNTaXplLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICBvYmplY3RGaXQ6ICdjb250YWluJyxcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9UcmFuc2Zvcm1Db21wb25lbnQ+XG4gICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L1RyYW5zZm9ybVdyYXBwZXI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNldHRpbmdzOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIlRyYW5zZm9ybVdyYXBwZXIiLCJUcmFuc2Zvcm1Db21wb25lbnQiLCJTZXR0aW5ncyIsInRpbWUiLCJzZXRUaW1lIiwiZGVsYXkiLCJzZXREZWxheSIsImltYWdlIiwic2V0SW1hZ2UiLCJjYW52YXNTaXplIiwic2V0Q2FudmFzU2l6ZSIsIndpZHRoIiwiaGVpZ2h0Iiwiem9vbSIsInNldFpvb20iLCJoYW5kbGVJbWFnZVVwbG9hZCIsImV2ZW50IiwiZmlsZSIsInRhcmdldCIsImZpbGVzIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJoYW5kbGVSYW5kb21DYW52YXNTaXplIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZGl2IiwiY2xhc3NOYW1lIiwibGFiZWwiLCJpbnB1dCIsInR5cGUiLCJ2YWx1ZSIsIm9uQ2hhbmdlIiwiZSIsIk51bWJlciIsImFjY2VwdCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJpbml0aWFsU2NhbGUiLCJtaW5TY2FsZSIsIm1heFNjYWxlIiwib25ab29tQ2hhbmdlIiwicmVmIiwic3RhdGUiLCJzY2FsZSIsInpvb21JbiIsInpvb21PdXQiLCJyZXNldFRyYW5zZm9ybSIsImltZyIsInNyYyIsImFsdCIsInN0eWxlIiwib2JqZWN0Rml0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/Settings.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/react-zoom-pan-pinch/dist/index.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-zoom-pan-pinch/dist/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Context: () => (/* binding */ Context),\n/* harmony export */   KeepScale: () => (/* binding */ KeepScale),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   TransformComponent: () => (/* binding */ TransformComponent),\n/* harmony export */   TransformWrapper: () => (/* binding */ TransformWrapper),\n/* harmony export */   getCenterPosition: () => (/* binding */ getCenterPosition),\n/* harmony export */   getMatrixTransformStyles: () => (/* binding */ getMatrixTransformStyles),\n/* harmony export */   getTransformStyles: () => (/* binding */ getTransformStyles),\n/* harmony export */   useControls: () => (/* binding */ useControls),\n/* harmony export */   useTransformComponent: () => (/* binding */ useTransformComponent),\n/* harmony export */   useTransformContext: () => (/* binding */ useTransformContext),\n/* harmony export */   useTransformEffect: () => (/* binding */ useTransformEffect),\n/* harmony export */   useTransformInit: () => (/* binding */ useTransformInit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Rounds number to given decimal\n * eg. roundNumber(2.34343, 1) => 2.3\n */\nvar roundNumber = function (num, decimal) {\n    return Number(num.toFixed(decimal));\n};\n/**\n * Checks if value is number, if not it returns default value\n * 1# eg. checkIsNumber(2, 30) => 2\n * 2# eg. checkIsNumber(null, 30) => 30\n */\nvar checkIsNumber = function (num, defaultValue) {\n    return typeof num === \"number\" ? num : defaultValue;\n};\n\nvar handleCallback = function (context, event, callback) {\n    if (callback && typeof callback === \"function\") {\n        callback(context, event);\n    }\n};\n\n/* eslint-disable no-plusplus */\n/* eslint-disable no-param-reassign */\n/**\n * Functions should return denominator of the target value, which is the next animation step.\n * t is a value from 0 to 1, reflecting the percentage of animation status.\n */\nvar easeOut = function (t) {\n    return -Math.cos(t * Math.PI) / 2 + 0.5;\n};\n// linear\nvar linear = function (t) {\n    return t;\n};\n// accelerating from zero velocity\nvar easeInQuad = function (t) {\n    return t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuad = function (t) {\n    return t * (2 - t);\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuad = function (t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n};\n// accelerating from zero velocity\nvar easeInCubic = function (t) {\n    return t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutCubic = function (t) {\n    return --t * t * t + 1;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutCubic = function (t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n};\n// accelerating from zero velocity\nvar easeInQuart = function (t) {\n    return t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuart = function (t) {\n    return 1 - --t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuart = function (t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n};\n// accelerating from zero velocity\nvar easeInQuint = function (t) {\n    return t * t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuint = function (t) {\n    return 1 + --t * t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuint = function (t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n};\nvar animations = {\n    easeOut: easeOut,\n    linear: linear,\n    easeInQuad: easeInQuad,\n    easeOutQuad: easeOutQuad,\n    easeInOutQuad: easeInOutQuad,\n    easeInCubic: easeInCubic,\n    easeOutCubic: easeOutCubic,\n    easeInOutCubic: easeInOutCubic,\n    easeInQuart: easeInQuart,\n    easeOutQuart: easeOutQuart,\n    easeInOutQuart: easeInOutQuart,\n    easeInQuint: easeInQuint,\n    easeOutQuint: easeOutQuint,\n    easeInOutQuint: easeInOutQuint,\n};\n\n/* eslint-disable no-param-reassign */\nvar handleCancelAnimationFrame = function (animation) {\n    if (typeof animation === \"number\") {\n        cancelAnimationFrame(animation);\n    }\n};\nvar handleCancelAnimation = function (contextInstance) {\n    if (!contextInstance.mounted)\n        return;\n    handleCancelAnimationFrame(contextInstance.animation);\n    // Clear animation state\n    contextInstance.animate = false;\n    contextInstance.animation = null;\n    contextInstance.velocity = null;\n};\nfunction handleSetupAnimation(contextInstance, animationName, animationTime, callback) {\n    if (!contextInstance.mounted)\n        return;\n    var startTime = new Date().getTime();\n    var lastStep = 1;\n    // if another animation is active\n    handleCancelAnimation(contextInstance);\n    // new animation\n    contextInstance.animation = function () {\n        if (!contextInstance.mounted) {\n            return handleCancelAnimationFrame(contextInstance.animation);\n        }\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / animationTime;\n        var animationType = animations[animationName];\n        var step = animationType(animationProgress);\n        if (frameTime >= animationTime) {\n            callback(lastStep);\n            contextInstance.animation = null;\n        }\n        else if (contextInstance.animation) {\n            callback(step);\n            requestAnimationFrame(contextInstance.animation);\n        }\n    };\n    requestAnimationFrame(contextInstance.animation);\n}\nfunction isValidTargetState(targetState) {\n    var scale = targetState.scale, positionX = targetState.positionX, positionY = targetState.positionY;\n    if (Number.isNaN(scale) ||\n        Number.isNaN(positionX) ||\n        Number.isNaN(positionY)) {\n        return false;\n    }\n    return true;\n}\nfunction animate(contextInstance, targetState, animationTime, animationName) {\n    var isValid = isValidTargetState(targetState);\n    if (!contextInstance.mounted || !isValid)\n        return;\n    var setTransformState = contextInstance.setTransformState;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDiff = targetState.scale - scale;\n    var positionXDiff = targetState.positionX - positionX;\n    var positionYDiff = targetState.positionY - positionY;\n    if (animationTime === 0) {\n        setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n    }\n    else {\n        // animation start timestamp\n        handleSetupAnimation(contextInstance, animationName, animationTime, function (step) {\n            var newScale = scale + scaleDiff * step;\n            var newPositionX = positionX + positionXDiff * step;\n            var newPositionY = positionY + positionYDiff * step;\n            setTransformState(newScale, newPositionX, newPositionY);\n        });\n    }\n}\n\n/* eslint-disable no-param-reassign */\nfunction getComponentsSizes(wrapperComponent, contentComponent, newScale) {\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var contentWidth = contentComponent.offsetWidth;\n    var contentHeight = contentComponent.offsetHeight;\n    var newContentWidth = contentWidth * newScale;\n    var newContentHeight = contentHeight * newScale;\n    var newDiffWidth = wrapperWidth - newContentWidth;\n    var newDiffHeight = wrapperHeight - newContentHeight;\n    return {\n        wrapperWidth: wrapperWidth,\n        wrapperHeight: wrapperHeight,\n        newContentWidth: newContentWidth,\n        newDiffWidth: newDiffWidth,\n        newContentHeight: newContentHeight,\n        newDiffHeight: newDiffHeight,\n    };\n}\nvar getBounds = function (wrapperWidth, newContentWidth, diffWidth, wrapperHeight, newContentHeight, diffHeight, centerZoomedOut) {\n    var scaleWidthFactor = wrapperWidth > newContentWidth\n        ? diffWidth * (centerZoomedOut ? 1 : 0.5)\n        : 0;\n    var scaleHeightFactor = wrapperHeight > newContentHeight\n        ? diffHeight * (centerZoomedOut ? 1 : 0.5)\n        : 0;\n    var minPositionX = wrapperWidth - newContentWidth - scaleWidthFactor;\n    var maxPositionX = scaleWidthFactor;\n    var minPositionY = wrapperHeight - newContentHeight - scaleHeightFactor;\n    var maxPositionY = scaleHeightFactor;\n    return { minPositionX: minPositionX, maxPositionX: maxPositionX, minPositionY: minPositionY, maxPositionY: maxPositionY };\n};\nvar calculateBounds = function (contextInstance, newScale) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n    var centerZoomedOut = contextInstance.setup.centerZoomedOut;\n    if (!wrapperComponent || !contentComponent) {\n        throw new Error(\"Components are not mounted\");\n    }\n    var _a = getComponentsSizes(wrapperComponent, contentComponent, newScale), wrapperWidth = _a.wrapperWidth, wrapperHeight = _a.wrapperHeight, newContentWidth = _a.newContentWidth, newDiffWidth = _a.newDiffWidth, newContentHeight = _a.newContentHeight, newDiffHeight = _a.newDiffHeight;\n    var bounds = getBounds(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, Boolean(centerZoomedOut));\n    return bounds;\n};\n/**\n * Keeps value between given bounds, used for limiting view to given boundaries\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\n */\nvar boundLimiter = function (value, minBound, maxBound, isActive) {\n    if (!isActive)\n        return roundNumber(value, 2);\n    if (value < minBound)\n        return roundNumber(minBound, 2);\n    if (value > maxBound)\n        return roundNumber(maxBound, 2);\n    return roundNumber(value, 2);\n};\nvar handleCalculateBounds = function (contextInstance, newScale) {\n    var bounds = calculateBounds(contextInstance, newScale);\n    // Save bounds\n    contextInstance.bounds = bounds;\n    return bounds;\n};\nfunction getMouseBoundedPosition(positionX, positionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent) {\n    var minPositionX = bounds.minPositionX, minPositionY = bounds.minPositionY, maxPositionX = bounds.maxPositionX, maxPositionY = bounds.maxPositionY;\n    var paddingX = 0;\n    var paddingY = 0;\n    if (wrapperComponent) {\n        paddingX = paddingValueX;\n        paddingY = paddingValueY;\n    }\n    var x = boundLimiter(positionX, minPositionX - paddingX, maxPositionX + paddingX, limitToBounds);\n    var y = boundLimiter(positionY, minPositionY - paddingY, maxPositionY + paddingY, limitToBounds);\n    return { x: x, y: y };\n}\n\nfunction handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds) {\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDifference = newScale - scale;\n    if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\") {\n        console.error(\"Mouse X and Y position were not provided!\");\n        return { x: positionX, y: positionY };\n    }\n    var calculatedPositionX = positionX - mouseX * scaleDifference;\n    var calculatedPositionY = positionY - mouseY * scaleDifference;\n    // do not limit to bounds when there is padding animation,\n    // it causes animation strange behaviour\n    var newPositions = getMouseBoundedPosition(calculatedPositionX, calculatedPositionY, bounds, limitToBounds, 0, 0, null);\n    return newPositions;\n}\nfunction checkZoomBounds(zoom, minScale, maxScale, zoomPadding, enablePadding) {\n    var scalePadding = enablePadding ? zoomPadding : 0;\n    var minScaleWithPadding = minScale - scalePadding;\n    if (!Number.isNaN(maxScale) && zoom >= maxScale)\n        return maxScale;\n    if (!Number.isNaN(minScale) && zoom <= minScaleWithPadding)\n        return minScaleWithPadding;\n    return zoom;\n}\n\nvar isPanningStartAllowed = function (contextInstance, event) {\n    var excluded = contextInstance.setup.panning.excluded;\n    var isInitialized = contextInstance.isInitialized, wrapperComponent = contextInstance.wrapperComponent;\n    var target = event.target;\n    var targetIsShadowDom = \"shadowRoot\" in target && \"composedPath\" in event;\n    var isWrapperChild = targetIsShadowDom\n        ? event.composedPath().some(function (el) {\n            if (!(el instanceof Element)) {\n                return false;\n            }\n            return wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(el);\n        })\n        : wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar isPanningAllowed = function (contextInstance) {\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning, setup = contextInstance.setup;\n    var disabled = setup.panning.disabled;\n    var isAllowed = isInitialized && isPanning && !disabled;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar handlePanningSetup = function (contextInstance, event) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with mouse\n    var x = event.clientX;\n    var y = event.clientY;\n    contextInstance.startCoords = { x: x - positionX, y: y - positionY };\n};\nvar handleTouchPanningSetup = function (contextInstance, event) {\n    var touches = event.touches;\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with touch\n    var oneFingerTouch = touches.length === 1;\n    if (oneFingerTouch) {\n        var x = touches[0].clientX;\n        var y = touches[0].clientY;\n        contextInstance.startCoords = { x: x - positionX, y: y - positionY };\n    }\n};\nfunction handlePanToBounds(contextInstance) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n    var _b = contextInstance.setup, disabled = _b.disabled, limitToBounds = _b.limitToBounds, centerZoomedOut = _b.centerZoomedOut;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    if (disabled || !wrapperComponent || !contextInstance.bounds)\n        return;\n    var _c = contextInstance.bounds, maxPositionX = _c.maxPositionX, minPositionX = _c.minPositionX, maxPositionY = _c.maxPositionY, minPositionY = _c.minPositionY;\n    var xChanged = positionX > maxPositionX || positionX < minPositionX;\n    var yChanged = positionY > maxPositionY || positionY < minPositionY;\n    var mousePosX = positionX > maxPositionX\n        ? wrapperComponent.offsetWidth\n        : contextInstance.setup.minPositionX || 0;\n    var mousePosY = positionY > maxPositionY\n        ? wrapperComponent.offsetHeight\n        : contextInstance.setup.minPositionY || 0;\n    var _d = handleCalculateZoomPositions(contextInstance, mousePosX, mousePosY, scale, contextInstance.bounds, limitToBounds || centerZoomedOut), x = _d.x, y = _d.y;\n    return {\n        scale: scale,\n        positionX: xChanged ? x : positionX,\n        positionY: yChanged ? y : positionY,\n    };\n}\nfunction handleNewPosition(contextInstance, newPositionX, newPositionY, paddingValueX, paddingValueY) {\n    var limitToBounds = contextInstance.setup.limitToBounds;\n    var wrapperComponent = contextInstance.wrapperComponent, bounds = contextInstance.bounds;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (wrapperComponent === null ||\n        bounds === null ||\n        (newPositionX === positionX && newPositionY === positionY)) {\n        return;\n    }\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent), x = _b.x, y = _b.y;\n    contextInstance.setTransformState(scale, x, y);\n}\nvar getPanningClientPosition = function (contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, transformState = contextInstance.transformState;\n    var panning = contextInstance.setup.panning;\n    var lockAxisX = panning.lockAxisX, lockAxisY = panning.lockAxisY;\n    var positionX = transformState.positionX, positionY = transformState.positionY;\n    if (!startCoords) {\n        return { x: positionX, y: positionY };\n    }\n    var mouseX = clientX - startCoords.x;\n    var mouseY = clientY - startCoords.y;\n    var newPositionX = lockAxisX ? positionX : mouseX;\n    var newPositionY = lockAxisY ? positionY : mouseY;\n    return { x: newPositionX, y: newPositionY };\n};\nvar getPaddingValue = function (contextInstance, size) {\n    var setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var minScale = setup.minScale, disablePadding = setup.disablePadding;\n    if (size > 0 && scale >= minScale && !disablePadding) {\n        return size;\n    }\n    return 0;\n};\n\nvar isVelocityCalculationAllowed = function (contextInstance) {\n    var mounted = contextInstance.mounted;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar isVelocityAllowed = function (contextInstance) {\n    var mounted = contextInstance.mounted, velocity = contextInstance.velocity, bounds = contextInstance.bounds;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed)\n        return false;\n    if (!velocity || !bounds)\n        return false;\n    return true;\n};\nfunction getVelocityMoveTime(contextInstance, velocity) {\n    var velocityAnimation = contextInstance.setup.velocityAnimation;\n    var equalToMove = velocityAnimation.equalToMove, animationTime = velocityAnimation.animationTime, sensitivity = velocityAnimation.sensitivity;\n    if (equalToMove) {\n        return animationTime * velocity * sensitivity;\n    }\n    return animationTime;\n}\nfunction getVelocityPosition(newPosition, startPosition, currentPosition, isLocked, limitToBounds, minPosition, maxPosition, minTarget, maxTarget, step) {\n    if (limitToBounds) {\n        if (startPosition > maxPosition && currentPosition > maxPosition) {\n            var calculatedPosition = maxPosition + (newPosition - maxPosition) * step;\n            if (calculatedPosition > maxTarget)\n                return maxTarget;\n            if (calculatedPosition < maxPosition)\n                return maxPosition;\n            return calculatedPosition;\n        }\n        if (startPosition < minPosition && currentPosition < minPosition) {\n            var calculatedPosition = minPosition + (newPosition - minPosition) * step;\n            if (calculatedPosition < minTarget)\n                return minTarget;\n            if (calculatedPosition > minPosition)\n                return minPosition;\n            return calculatedPosition;\n        }\n    }\n    if (isLocked)\n        return startPosition;\n    return boundLimiter(newPosition, minPosition, maxPosition, limitToBounds);\n}\n\nfunction getSizeMultiplier(wrapperComponent, equalToMove) {\n    var defaultMultiplier = 1;\n    if (equalToMove) {\n        return Math.min(defaultMultiplier, wrapperComponent.offsetWidth / window.innerWidth);\n    }\n    return defaultMultiplier;\n}\nfunction handleCalculateVelocity(contextInstance, position) {\n    var isAllowed = isVelocityCalculationAllowed(contextInstance);\n    if (!isAllowed) {\n        return;\n    }\n    var lastMousePosition = contextInstance.lastMousePosition, velocityTime = contextInstance.velocityTime, setup = contextInstance.setup;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var equalToMove = setup.velocityAnimation.equalToMove;\n    var now = Date.now();\n    if (lastMousePosition && velocityTime && wrapperComponent) {\n        var sizeMultiplier = getSizeMultiplier(wrapperComponent, equalToMove);\n        var distanceX = position.x - lastMousePosition.x;\n        var distanceY = position.y - lastMousePosition.y;\n        var velocityX = distanceX / sizeMultiplier;\n        var velocityY = distanceY / sizeMultiplier;\n        var interval = now - velocityTime;\n        var speed = distanceX * distanceX + distanceY * distanceY;\n        var velocity = Math.sqrt(speed) / interval;\n        contextInstance.velocity = { velocityX: velocityX, velocityY: velocityY, total: velocity };\n    }\n    contextInstance.lastMousePosition = position;\n    contextInstance.velocityTime = now;\n}\nfunction handleVelocityPanning(contextInstance) {\n    var velocity = contextInstance.velocity, bounds = contextInstance.bounds, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var isAllowed = isVelocityAllowed(contextInstance);\n    if (!isAllowed || !velocity || !bounds || !wrapperComponent) {\n        return;\n    }\n    var velocityX = velocity.velocityX, velocityY = velocity.velocityY, total = velocity.total;\n    var maxPositionX = bounds.maxPositionX, minPositionX = bounds.minPositionX, maxPositionY = bounds.maxPositionY, minPositionY = bounds.minPositionY;\n    var limitToBounds = setup.limitToBounds, alignmentAnimation = setup.alignmentAnimation;\n    var zoomAnimation = setup.zoomAnimation, panning = setup.panning;\n    var lockAxisY = panning.lockAxisY, lockAxisX = panning.lockAxisX;\n    var animationType = zoomAnimation.animationType;\n    var sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, velocityAlignmentTime = alignmentAnimation.velocityAlignmentTime;\n    var alignAnimationTime = velocityAlignmentTime;\n    var moveAnimationTime = getVelocityMoveTime(contextInstance, total);\n    var finalAnimationTime = Math.max(moveAnimationTime, alignAnimationTime);\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    var paddingX = (paddingValueX * wrapperComponent.offsetWidth) / 100;\n    var paddingY = (paddingValueY * wrapperComponent.offsetHeight) / 100;\n    var maxTargetX = maxPositionX + paddingX;\n    var minTargetX = minPositionX - paddingX;\n    var maxTargetY = maxPositionY + paddingY;\n    var minTargetY = minPositionY - paddingY;\n    var startState = contextInstance.transformState;\n    var startTime = new Date().getTime();\n    handleSetupAnimation(contextInstance, animationType, finalAnimationTime, function (step) {\n        var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / alignAnimationTime;\n        var alignAnimation = animations[alignmentAnimation.animationType];\n        var alignStep = 1 - alignAnimation(Math.min(1, animationProgress));\n        var customStep = 1 - step;\n        var newPositionX = positionX + velocityX * customStep;\n        var newPositionY = positionY + velocityY * customStep;\n        var currentPositionX = getVelocityPosition(newPositionX, startState.positionX, positionX, lockAxisX, limitToBounds, minPositionX, maxPositionX, minTargetX, maxTargetX, alignStep);\n        var currentPositionY = getVelocityPosition(newPositionY, startState.positionY, positionY, lockAxisY, limitToBounds, minPositionY, maxPositionY, minTargetY, maxTargetY, alignStep);\n        if (positionX !== newPositionX || positionY !== newPositionY) {\n            contextInstance.setTransformState(scale, currentPositionX, currentPositionY);\n        }\n    });\n}\n\nfunction handlePanningStart(contextInstance, event) {\n    var scale = contextInstance.transformState.scale;\n    handleCancelAnimation(contextInstance);\n    handleCalculateBounds(contextInstance, scale);\n    if (window.TouchEvent !== undefined && event instanceof TouchEvent) {\n        handleTouchPanningSetup(contextInstance, event);\n    }\n    else {\n        handlePanningSetup(contextInstance, event);\n    }\n}\nfunction handleAlignToBounds(contextInstance, customAnimationTime) {\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, minScale = _a.minScale, alignmentAnimation = _a.alignmentAnimation;\n    var disabled = alignmentAnimation.disabled, sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, animationTime = alignmentAnimation.animationTime, animationType = alignmentAnimation.animationType;\n    var isDisabled = disabled || scale < minScale || (!sizeX && !sizeY);\n    if (isDisabled)\n        return;\n    var targetState = handlePanToBounds(contextInstance);\n    if (targetState) {\n        animate(contextInstance, targetState, customAnimationTime !== null && customAnimationTime !== void 0 ? customAnimationTime : animationTime, animationType);\n    }\n}\nfunction handlePanning(contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, setup = contextInstance.setup;\n    var _a = setup.alignmentAnimation, sizeX = _a.sizeX, sizeY = _a.sizeY;\n    if (!startCoords)\n        return;\n    var _b = getPanningClientPosition(contextInstance, clientX, clientY), x = _b.x, y = _b.y;\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    handleCalculateVelocity(contextInstance, { x: x, y: y });\n    handleNewPosition(contextInstance, x, y, paddingValueX, paddingValueY);\n}\nfunction handlePanningEnd(contextInstance) {\n    if (contextInstance.isPanning) {\n        var velocityDisabled = contextInstance.setup.panning.velocityDisabled;\n        var velocity = contextInstance.velocity, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        contextInstance.isPanning = false;\n        contextInstance.animate = false;\n        contextInstance.animation = null;\n        var wrapperRect = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.getBoundingClientRect();\n        var contentRect = contentComponent === null || contentComponent === void 0 ? void 0 : contentComponent.getBoundingClientRect();\n        var wrapperWidth = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.width) || 0;\n        var wrapperHeight = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.height) || 0;\n        var contentWidth = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.width) || 0;\n        var contentHeight = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.height) || 0;\n        var isZoomed = wrapperWidth < contentWidth || wrapperHeight < contentHeight;\n        var shouldAnimate = !velocityDisabled && velocity && (velocity === null || velocity === void 0 ? void 0 : velocity.total) > 0.1 && isZoomed;\n        if (shouldAnimate) {\n            handleVelocityPanning(contextInstance);\n        }\n        else {\n            handleAlignToBounds(contextInstance);\n        }\n    }\n}\n\nfunction handleZoomToPoint(contextInstance, scale, mouseX, mouseY) {\n    var _a = contextInstance.setup, minScale = _a.minScale, maxScale = _a.maxScale, limitToBounds = _a.limitToBounds;\n    var newScale = checkZoomBounds(roundNumber(scale, 2), minScale, maxScale, 0, false);\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var _b = handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds), x = _b.x, y = _b.y;\n    return { scale: newScale, positionX: x, positionY: y };\n}\nfunction handleAlignToScaleBounds(contextInstance, mousePositionX, mousePositionY) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.setup, minScale = _a.minScale, limitToBounds = _a.limitToBounds, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, animationTime = zoomAnimation.animationTime, animationType = zoomAnimation.animationType;\n    var isDisabled = disabled || scale >= minScale;\n    if (scale >= 1 || limitToBounds) {\n        // fire fit to bounds animation\n        handleAlignToBounds(contextInstance);\n    }\n    if (isDisabled || !wrapperComponent || !contextInstance.mounted)\n        return;\n    var mouseX = mousePositionX || wrapperComponent.offsetWidth / 2;\n    var mouseY = mousePositionY || wrapperComponent.offsetHeight / 2;\n    var targetState = handleZoomToPoint(contextInstance, minScale, mouseX, mouseY);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nvar initialState = {\n    previousScale: 1,\n    scale: 1,\n    positionX: 0,\n    positionY: 0,\n};\nvar initialSetup = {\n    disabled: false,\n    minPositionX: null,\n    maxPositionX: null,\n    minPositionY: null,\n    maxPositionY: null,\n    minScale: 1,\n    maxScale: 8,\n    limitToBounds: true,\n    centerZoomedOut: false,\n    centerOnInit: false,\n    disablePadding: false,\n    smooth: true,\n    wheel: {\n        step: 0.2,\n        disabled: false,\n        smoothStep: 0.001,\n        wheelDisabled: false,\n        touchPadDisabled: false,\n        activationKeys: [],\n        excluded: [],\n    },\n    panning: {\n        disabled: false,\n        velocityDisabled: false,\n        lockAxisX: false,\n        lockAxisY: false,\n        allowLeftClickPan: true,\n        allowMiddleClickPan: true,\n        allowRightClickPan: true,\n        wheelPanning: false,\n        activationKeys: [],\n        excluded: [],\n    },\n    pinch: {\n        step: 5,\n        disabled: false,\n        excluded: [],\n    },\n    doubleClick: {\n        disabled: false,\n        step: 0.7,\n        mode: \"zoomIn\",\n        animationType: \"easeOut\",\n        animationTime: 200,\n        excluded: [],\n    },\n    zoomAnimation: {\n        disabled: false,\n        size: 0.4,\n        animationTime: 200,\n        animationType: \"easeOut\",\n    },\n    alignmentAnimation: {\n        disabled: false,\n        sizeX: 100,\n        sizeY: 100,\n        animationTime: 200,\n        velocityAlignmentTime: 400,\n        animationType: \"easeOut\",\n    },\n    velocityAnimation: {\n        disabled: false,\n        sensitivity: 1,\n        animationTime: 400,\n        animationType: \"easeOut\",\n        equalToMove: true,\n    },\n};\nvar baseClasses = {\n    wrapperClass: \"react-transform-wrapper\",\n    contentClass: \"react-transform-component\",\n};\n\nvar createState = function (props) {\n    var _a, _b, _c, _d;\n    return {\n        previousScale: (_a = props.initialScale) !== null && _a !== void 0 ? _a : initialState.scale,\n        scale: (_b = props.initialScale) !== null && _b !== void 0 ? _b : initialState.scale,\n        positionX: (_c = props.initialPositionX) !== null && _c !== void 0 ? _c : initialState.positionX,\n        positionY: (_d = props.initialPositionY) !== null && _d !== void 0 ? _d : initialState.positionY,\n    };\n};\nvar createSetup = function (props) {\n    var newSetup = __assign({}, initialSetup);\n    Object.keys(props).forEach(function (key) {\n        var validValue = typeof props[key] !== \"undefined\";\n        var validParameter = typeof initialSetup[key] !== \"undefined\";\n        if (validParameter && validValue) {\n            var dataType = Object.prototype.toString.call(initialSetup[key]);\n            var isObject = dataType === \"[object Object]\";\n            var isArray = dataType === \"[object Array]\";\n            if (isObject) {\n                newSetup[key] = __assign(__assign({}, initialSetup[key]), props[key]);\n            }\n            else if (isArray) {\n                newSetup[key] = __spreadArray(__spreadArray([], initialSetup[key], true), props[key], true);\n            }\n            else {\n                newSetup[key] = props[key];\n            }\n        }\n    });\n    return newSetup;\n};\n\nvar handleCalculateButtonZoom = function (contextInstance, delta, step) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, smooth = setup.smooth;\n    var size = zoomAnimation.size;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = smooth\n        ? scale * Math.exp(delta * step)\n        : scale + delta * step;\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, false);\n    return newScale;\n};\nfunction handleZoomToViewCenter(contextInstance, delta, step, animationTime, animationType) {\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent)\n        return console.error(\"No WrapperComponent found\");\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var mouseX = (wrapperWidth / 2 - positionX) / scale;\n    var mouseY = (wrapperHeight / 2 - positionY) / scale;\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mouseX, mouseY);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    animate(contextInstance, targetState, animationTime, animationType);\n}\nfunction resetTransformations(contextInstance, animationTime, animationType, onResetTransformation) {\n    var setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var limitToBounds = setup.limitToBounds;\n    var initialTransformation = createState(contextInstance.props);\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent)\n        return;\n    var newBounds = calculateBounds(contextInstance, initialTransformation.scale);\n    var boundedPositions = getMouseBoundedPosition(initialTransformation.positionX, initialTransformation.positionY, newBounds, limitToBounds, 0, 0, wrapperComponent);\n    var newState = {\n        scale: initialTransformation.scale,\n        positionX: boundedPositions.x,\n        positionY: boundedPositions.y,\n    };\n    if (scale === initialTransformation.scale &&\n        positionX === initialTransformation.positionX &&\n        positionY === initialTransformation.positionY) {\n        return;\n    }\n    onResetTransformation === null || onResetTransformation === void 0 ? void 0 : onResetTransformation();\n    animate(contextInstance, newState, animationTime, animationType);\n}\nfunction getOffset(element, wrapper, content, state) {\n    var offset = element.getBoundingClientRect();\n    var wrapperOffset = wrapper.getBoundingClientRect();\n    var contentOffset = content.getBoundingClientRect();\n    var xOff = wrapperOffset.x * state.scale;\n    var yOff = wrapperOffset.y * state.scale;\n    return {\n        x: (offset.x - contentOffset.x + xOff) / state.scale,\n        y: (offset.y - contentOffset.y + yOff) / state.scale,\n    };\n}\nfunction calculateZoomToNode(contextInstance, node, customZoom) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent, transformState = contextInstance.transformState;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, minScale = _a.minScale, maxScale = _a.maxScale;\n    if (!wrapperComponent || !contentComponent)\n        return transformState;\n    var wrapperRect = wrapperComponent.getBoundingClientRect();\n    var nodeRect = node.getBoundingClientRect();\n    var nodeOffset = getOffset(node, wrapperComponent, contentComponent, transformState);\n    var nodeLeft = nodeOffset.x;\n    var nodeTop = nodeOffset.y;\n    var nodeWidth = nodeRect.width / transformState.scale;\n    var nodeHeight = nodeRect.height / transformState.scale;\n    var scaleX = wrapperComponent.offsetWidth / nodeWidth;\n    var scaleY = wrapperComponent.offsetHeight / nodeHeight;\n    var newScale = checkZoomBounds(customZoom || Math.min(scaleX, scaleY), minScale, maxScale, 0, false);\n    var offsetX = (wrapperRect.width - nodeWidth * newScale) / 2;\n    var offsetY = (wrapperRect.height - nodeHeight * newScale) / 2;\n    var newPositionX = (wrapperRect.left - nodeLeft) * newScale + offsetX;\n    var newPositionY = (wrapperRect.top - nodeTop) * newScale + offsetY;\n    var bounds = calculateBounds(contextInstance, newScale);\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, 0, 0, wrapperComponent), x = _b.x, y = _b.y;\n    return { positionX: x, positionY: y, scale: newScale };\n}\n\nvar zoomIn = function (contextInstance) {\n    return function (step, animationTime, animationType) {\n        if (step === void 0) { step = 0.5; }\n        if (animationTime === void 0) { animationTime = 300; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        handleZoomToViewCenter(contextInstance, 1, step, animationTime, animationType);\n    };\n};\nvar zoomOut = function (contextInstance) {\n    return function (step, animationTime, animationType) {\n        if (step === void 0) { step = 0.5; }\n        if (animationTime === void 0) { animationTime = 300; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        handleZoomToViewCenter(contextInstance, -1, step, animationTime, animationType);\n    };\n};\nvar setTransform = function (contextInstance) {\n    return function (newPositionX, newPositionY, newScale, animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 300; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n        var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        var disabled = contextInstance.setup.disabled;\n        if (disabled || !wrapperComponent || !contentComponent)\n            return;\n        var targetState = {\n            positionX: Number.isNaN(newPositionX) ? positionX : newPositionX,\n            positionY: Number.isNaN(newPositionY) ? positionY : newPositionY,\n            scale: Number.isNaN(newScale) ? scale : newScale,\n        };\n        animate(contextInstance, targetState, animationTime, animationType);\n    };\n};\nvar resetTransform = function (contextInstance) {\n    return function (animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 200; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        resetTransformations(contextInstance, animationTime, animationType);\n    };\n};\nvar centerView = function (contextInstance) {\n    return function (scale, animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 200; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        var transformState = contextInstance.transformState, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        if (wrapperComponent && contentComponent) {\n            var targetState = getCenterPosition(scale || transformState.scale, wrapperComponent, contentComponent);\n            animate(contextInstance, targetState, animationTime, animationType);\n        }\n    };\n};\nvar zoomToElement = function (contextInstance) {\n    return function (node, scale, animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 600; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        handleCancelAnimation(contextInstance);\n        var wrapperComponent = contextInstance.wrapperComponent;\n        var target = typeof node === \"string\" ? document.getElementById(node) : node;\n        if (wrapperComponent && target && wrapperComponent.contains(target)) {\n            var targetState = calculateZoomToNode(contextInstance, target, scale);\n            animate(contextInstance, targetState, animationTime, animationType);\n        }\n    };\n};\n\nvar getControls = function (contextInstance) {\n    return {\n        instance: contextInstance,\n        zoomIn: zoomIn(contextInstance),\n        zoomOut: zoomOut(contextInstance),\n        setTransform: setTransform(contextInstance),\n        resetTransform: resetTransform(contextInstance),\n        centerView: centerView(contextInstance),\n        zoomToElement: zoomToElement(contextInstance),\n    };\n};\nvar getState = function (contextInstance) {\n    return {\n        instance: contextInstance,\n        state: contextInstance.transformState,\n    };\n};\nvar getContext = function (contextInstance) {\n    var ref = {};\n    Object.assign(ref, getState(contextInstance));\n    Object.assign(ref, getControls(contextInstance));\n    return ref;\n};\n\n// We want to make event listeners non-passive, and to do so have to check\n// that browsers support EventListenerOptions in the first place.\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nvar passiveSupported = false;\nfunction makePassiveEventOption() {\n    try {\n        var options = {\n            get passive() {\n                // This function will be called when the browser\n                //   attempts to access the passive property.\n                passiveSupported = true;\n                return false;\n            },\n        };\n        return options;\n    }\n    catch (err) {\n        passiveSupported = false;\n        return passiveSupported;\n    }\n}\n\nvar matchPrefix = \".\".concat(baseClasses.wrapperClass);\nvar isExcludedNode = function (node, excluded) {\n    return excluded.some(function (exclude) {\n        return node.matches(\"\".concat(matchPrefix, \" \").concat(exclude, \", \").concat(matchPrefix, \" .\").concat(exclude, \", \").concat(matchPrefix, \" \").concat(exclude, \" *, \").concat(matchPrefix, \" .\").concat(exclude, \" *\"));\n    });\n};\nvar cancelTimeout = function (timeout) {\n    if (timeout) {\n        clearTimeout(timeout);\n    }\n};\n\nvar getTransformStyles = function (x, y, scale) {\n    // Standard translate prevents blurry svg on the safari\n    return \"translate(\".concat(x, \"px, \").concat(y, \"px) scale(\").concat(scale, \")\");\n};\nvar getMatrixTransformStyles = function (x, y, scale) {\n    // The shorthand for matrix does not work for Safari hence the need to explicitly use matrix3d\n    // Refer to https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    var a = scale;\n    var b = 0;\n    var c = 0;\n    var d = scale;\n    var tx = x;\n    var ty = y;\n    return \"matrix3d(\".concat(a, \", \").concat(b, \", 0, 0, \").concat(c, \", \").concat(d, \", 0, 0, 0, 0, 1, 0, \").concat(tx, \", \").concat(ty, \", 0, 1)\");\n};\nvar getCenterPosition = function (scale, wrapperComponent, contentComponent) {\n    var contentWidth = contentComponent.offsetWidth * scale;\n    var contentHeight = contentComponent.offsetHeight * scale;\n    var centerPositionX = (wrapperComponent.offsetWidth - contentWidth) / 2;\n    var centerPositionY = (wrapperComponent.offsetHeight - contentHeight) / 2;\n    return {\n        scale: scale,\n        positionX: centerPositionX,\n        positionY: centerPositionY,\n    };\n};\n\nfunction mergeRefs(refs) {\n    return function (value) {\n        refs.forEach(function (ref) {\n            if (typeof ref === \"function\") {\n                ref(value);\n            }\n            else if (ref != null) {\n                ref.current = value;\n            }\n        });\n    };\n}\n\nvar isWheelAllowed = function (contextInstance, event) {\n    var _a = contextInstance.setup.wheel, disabled = _a.disabled, wheelDisabled = _a.wheelDisabled, touchPadDisabled = _a.touchPadDisabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning;\n    var target = event.target;\n    var isAllowed = isInitialized && !isPanning && !disabled && target;\n    if (!isAllowed)\n        return false;\n    // Event ctrlKey detects if touchpad action is executing wheel or pinch gesture\n    if (wheelDisabled && !event.ctrlKey)\n        return false;\n    if (touchPadDisabled && event.ctrlKey)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar getDeltaY = function (event) {\n    if (event) {\n        return event.deltaY < 0 ? 1 : -1;\n    }\n    return 0;\n};\nfunction getDelta(event, customDelta) {\n    var deltaY = getDeltaY(event);\n    var delta = checkIsNumber(customDelta, deltaY);\n    return delta;\n}\nfunction getMousePosition(event, contentComponent, scale) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var mouseX = 0;\n    var mouseY = 0;\n    if (\"clientX\" in event) {\n        // mouse position x, y over wrapper component\n        mouseX = (event.clientX - contentRect.left) / scale;\n        mouseY = (event.clientY - contentRect.top) / scale;\n    }\n    else {\n        var touch = event.touches[0];\n        mouseX = (touch.clientX - contentRect.left) / scale;\n        mouseY = (touch.clientY - contentRect.top) / scale;\n    }\n    if (Number.isNaN(mouseX) || Number.isNaN(mouseY))\n        console.error(\"No mouse or touch offset found\");\n    return {\n        x: mouseX,\n        y: mouseY,\n    };\n}\nvar handleCalculateWheelZoom = function (contextInstance, delta, step, disable, getTarget) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = scale + delta * step;\n    if (getTarget)\n        return targetScale;\n    var paddingEnabled = disable ? false : !disabled;\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, paddingEnabled && !disablePadding);\n    return newScale;\n};\nvar handleWheelZoomStop = function (contextInstance, event) {\n    var previousWheelEvent = contextInstance.previousWheelEvent;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, maxScale = _a.maxScale, minScale = _a.minScale;\n    if (!previousWheelEvent)\n        return false;\n    if (scale < maxScale || scale > minScale)\n        return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY))\n        return true;\n    if (previousWheelEvent.deltaY > 0 && previousWheelEvent.deltaY < event.deltaY)\n        return true;\n    if (previousWheelEvent.deltaY < 0 && previousWheelEvent.deltaY > event.deltaY)\n        return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY))\n        return true;\n    return false;\n};\n\nvar isPinchStartAllowed = function (contextInstance, event) {\n    var _a = contextInstance.setup.pinch, disabled = _a.disabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized;\n    var target = event.target;\n    var isAllowed = isInitialized && !disabled && target;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar isPinchAllowed = function (contextInstance) {\n    var disabled = contextInstance.setup.pinch.disabled;\n    var isInitialized = contextInstance.isInitialized, pinchStartDistance = contextInstance.pinchStartDistance;\n    var isAllowed = isInitialized && !disabled && pinchStartDistance;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar calculateTouchMidPoint = function (event, scale, contentComponent) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var touches = event.touches;\n    var firstPointX = roundNumber(touches[0].clientX - contentRect.left, 5);\n    var firstPointY = roundNumber(touches[0].clientY - contentRect.top, 5);\n    var secondPointX = roundNumber(touches[1].clientX - contentRect.left, 5);\n    var secondPointY = roundNumber(touches[1].clientY - contentRect.top, 5);\n    return {\n        x: (firstPointX + secondPointX) / 2 / scale,\n        y: (firstPointY + secondPointY) / 2 / scale,\n    };\n};\nvar getTouchDistance = function (event) {\n    return Math.sqrt(Math.pow((event.touches[0].pageX - event.touches[1].pageX), 2) +\n        Math.pow((event.touches[0].pageY - event.touches[1].pageY), 2));\n};\nvar calculatePinchZoom = function (contextInstance, currentDistance) {\n    var pinchStartScale = contextInstance.pinchStartScale, pinchStartDistance = contextInstance.pinchStartDistance, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!pinchStartScale || pinchStartDistance === null || !currentDistance) {\n        throw new Error(\"Pinch touches distance was not provided\");\n    }\n    if (currentDistance < 0) {\n        return contextInstance.transformState.scale;\n    }\n    var touchProportion = currentDistance / pinchStartDistance;\n    var scaleDifference = touchProportion * pinchStartScale;\n    return checkZoomBounds(roundNumber(scaleDifference, 2), minScale, maxScale, size, !disabled && !disablePadding);\n};\n\nvar wheelStopEventTime = 160;\nvar wheelAnimationTime = 100;\nvar handleWheelStart = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheelStart = _a.onWheelStart, onZoomStart = _a.onZoomStart;\n    if (!contextInstance.wheelStopEventTimer) {\n        handleCancelAnimation(contextInstance);\n        handleCallback(getContext(contextInstance), event, onWheelStart);\n        handleCallback(getContext(contextInstance), event, onZoomStart);\n    }\n};\nvar handleWheelZoom = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheel = _a.onWheel, onZoom = _a.onZoom;\n    var contentComponent = contextInstance.contentComponent, setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var limitToBounds = setup.limitToBounds, centerZoomedOut = setup.centerZoomedOut, zoomAnimation = setup.zoomAnimation, wheel = setup.wheel, disablePadding = setup.disablePadding, smooth = setup.smooth;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    var step = wheel.step, smoothStep = wheel.smoothStep;\n    if (!contentComponent) {\n        throw new Error(\"Component not mounted\");\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    var delta = getDelta(event, null);\n    var zoomStep = smooth ? smoothStep * Math.abs(event.deltaY) : step;\n    var newScale = handleCalculateWheelZoom(contextInstance, delta, zoomStep, !event.ctrlKey);\n    // if scale not change\n    if (scale === newScale)\n        return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut || disablePadding;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, mousePosition.x, mousePosition.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.previousWheelEvent = event;\n    contextInstance.setTransformState(newScale, x, y);\n    handleCallback(getContext(contextInstance), event, onWheel);\n    handleCallback(getContext(contextInstance), event, onZoom);\n};\nvar handleWheelStop = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheelStop = _a.onWheelStop, onZoomStop = _a.onZoomStop;\n    // fire animation\n    cancelTimeout(contextInstance.wheelAnimationTimer);\n    contextInstance.wheelAnimationTimer = setTimeout(function () {\n        if (!contextInstance.mounted)\n            return;\n        handleAlignToScaleBounds(contextInstance, event.x, event.y);\n        contextInstance.wheelAnimationTimer = null;\n    }, wheelAnimationTime);\n    // Wheel stop event\n    var hasStoppedZooming = handleWheelZoomStop(contextInstance, event);\n    if (hasStoppedZooming) {\n        cancelTimeout(contextInstance.wheelStopEventTimer);\n        contextInstance.wheelStopEventTimer = setTimeout(function () {\n            if (!contextInstance.mounted)\n                return;\n            contextInstance.wheelStopEventTimer = null;\n            handleCallback(getContext(contextInstance), event, onWheelStop);\n            handleCallback(getContext(contextInstance), event, onZoomStop);\n        }, wheelStopEventTime);\n    }\n};\n\nvar getTouchCenter = function (event) {\n    var totalX = 0;\n    var totalY = 0;\n    // Sum up the positions of all touches\n    for (var i = 0; i < 2; i += 1) {\n        totalX += event.touches[i].clientX;\n        totalY += event.touches[i].clientY;\n    }\n    // Calculate the average position\n    var x = totalX / 2;\n    var y = totalY / 2;\n    return { x: x, y: y };\n};\nvar handlePinchStart = function (contextInstance, event) {\n    var distance = getTouchDistance(event);\n    contextInstance.pinchStartDistance = distance;\n    contextInstance.lastDistance = distance;\n    contextInstance.pinchStartScale = contextInstance.transformState.scale;\n    contextInstance.isPanning = false;\n    var center = getTouchCenter(event);\n    contextInstance.pinchLastCenterX = center.x;\n    contextInstance.pinchLastCenterY = center.y;\n    handleCancelAnimation(contextInstance);\n};\nvar handlePinchZoom = function (contextInstance, event) {\n    var contentComponent = contextInstance.contentComponent, pinchStartDistance = contextInstance.pinchStartDistance, wrapperComponent = contextInstance.wrapperComponent;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, centerZoomedOut = _a.centerZoomedOut, zoomAnimation = _a.zoomAnimation, alignmentAnimation = _a.alignmentAnimation;\n    var disabled = zoomAnimation.disabled, size = zoomAnimation.size;\n    // if one finger starts from outside of wrapper\n    if (pinchStartDistance === null || !contentComponent)\n        return;\n    var midPoint = calculateTouchMidPoint(event, scale, contentComponent);\n    // if touches goes off of the wrapper element\n    if (!Number.isFinite(midPoint.x) || !Number.isFinite(midPoint.y))\n        return;\n    var currentDistance = getTouchDistance(event);\n    var newScale = calculatePinchZoom(contextInstance, currentDistance);\n    var center = getTouchCenter(event);\n    // pan should be scale invariant.\n    var panX = center.x - (contextInstance.pinchLastCenterX || 0);\n    var panY = center.y - (contextInstance.pinchLastCenterY || 0);\n    if (newScale === scale && panX === 0 && panY === 0)\n        return;\n    contextInstance.pinchLastCenterX = center.x;\n    contextInstance.pinchLastCenterY = center.y;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, midPoint.x, midPoint.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.pinchMidpoint = midPoint;\n    contextInstance.lastDistance = currentDistance;\n    var sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY;\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    var newPositionX = x + panX;\n    var newPositionY = y + panY;\n    var _c = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent), finalX = _c.x, finalY = _c.y;\n    contextInstance.setTransformState(newScale, finalX, finalY);\n};\nvar handlePinchStop = function (contextInstance) {\n    var pinchMidpoint = contextInstance.pinchMidpoint;\n    contextInstance.velocity = null;\n    contextInstance.lastDistance = null;\n    contextInstance.pinchMidpoint = null;\n    contextInstance.pinchStartScale = null;\n    contextInstance.pinchStartDistance = null;\n    handleAlignToScaleBounds(contextInstance, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.x, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.y);\n};\n\nvar handleDoubleClickStop = function (contextInstance, event) {\n    var onZoomStop = contextInstance.props.onZoomStop;\n    var animationTime = contextInstance.setup.doubleClick.animationTime;\n    cancelTimeout(contextInstance.doubleClickStopEventTimer);\n    contextInstance.doubleClickStopEventTimer = setTimeout(function () {\n        contextInstance.doubleClickStopEventTimer = null;\n        handleCallback(getContext(contextInstance), event, onZoomStop);\n    }, animationTime);\n};\nvar handleDoubleClickResetMode = function (contextInstance, event) {\n    var _a = contextInstance.props, onZoomStart = _a.onZoomStart, onZoom = _a.onZoom;\n    var _b = contextInstance.setup.doubleClick, animationTime = _b.animationTime, animationType = _b.animationType;\n    handleCallback(getContext(contextInstance), event, onZoomStart);\n    resetTransformations(contextInstance, animationTime, animationType, function () {\n        return handleCallback(getContext(contextInstance), event, onZoom);\n    });\n    handleDoubleClickStop(contextInstance, event);\n};\nfunction getDoubleClickScale(mode, scale) {\n    if (mode === \"toggle\") {\n        return scale === 1 ? 1 : -1;\n    }\n    return mode === \"zoomOut\" ? -1 : 1;\n}\nfunction handleDoubleClick(contextInstance, event) {\n    var setup = contextInstance.setup, doubleClickStopEventTimer = contextInstance.doubleClickStopEventTimer, transformState = contextInstance.transformState, contentComponent = contextInstance.contentComponent;\n    var scale = transformState.scale;\n    var _a = contextInstance.props, onZoomStart = _a.onZoomStart, onZoom = _a.onZoom;\n    var _b = setup.doubleClick, disabled = _b.disabled, mode = _b.mode, step = _b.step, animationTime = _b.animationTime, animationType = _b.animationType;\n    if (disabled)\n        return;\n    if (doubleClickStopEventTimer)\n        return;\n    if (mode === \"reset\") {\n        return handleDoubleClickResetMode(contextInstance, event);\n    }\n    if (!contentComponent)\n        return console.error(\"No ContentComponent found\");\n    var delta = getDoubleClickScale(mode, contextInstance.transformState.scale);\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    // stop execution when scale didn't change\n    if (scale === newScale)\n        return;\n    handleCallback(getContext(contextInstance), event, onZoomStart);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mousePosition.x, mousePosition.y);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    handleCallback(getContext(contextInstance), event, onZoom);\n    animate(contextInstance, targetState, animationTime, animationType);\n    handleDoubleClickStop(contextInstance, event);\n}\nvar isDoubleClickAllowed = function (contextInstance, event) {\n    var isInitialized = contextInstance.isInitialized, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var _a = setup.doubleClick, disabled = _a.disabled, excluded = _a.excluded;\n    var target = event.target;\n    var isWrapperChild = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild && !disabled;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\n\nvar ZoomPanPinch = /** @class */ (function () {\n    function ZoomPanPinch(props) {\n        var _this = this;\n        this.mounted = true;\n        this.pinchLastCenterX = null;\n        this.pinchLastCenterY = null;\n        this.onChangeCallbacks = new Set();\n        this.onInitCallbacks = new Set();\n        // Components\n        this.wrapperComponent = null;\n        this.contentComponent = null;\n        // Initialization\n        this.isInitialized = false;\n        this.bounds = null;\n        // wheel helpers\n        this.previousWheelEvent = null;\n        this.wheelStopEventTimer = null;\n        this.wheelAnimationTimer = null;\n        // panning helpers\n        this.isPanning = false;\n        this.isWheelPanning = false;\n        this.startCoords = null;\n        this.lastTouch = null;\n        // pinch helpers\n        this.distance = null;\n        this.lastDistance = null;\n        this.pinchStartDistance = null;\n        this.pinchStartScale = null;\n        this.pinchMidpoint = null;\n        // double click helpers\n        this.doubleClickStopEventTimer = null;\n        // velocity helpers\n        this.velocity = null;\n        this.velocityTime = null;\n        this.lastMousePosition = null;\n        // animations helpers\n        this.animate = false;\n        this.animation = null;\n        this.maxBounds = null;\n        // key press\n        this.pressedKeys = {};\n        this.mount = function () {\n            _this.initializeWindowEvents();\n        };\n        this.unmount = function () {\n            _this.cleanupWindowEvents();\n        };\n        this.update = function (newProps) {\n            _this.props = newProps;\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.setup = createSetup(newProps);\n        };\n        this.initializeWindowEvents = function () {\n            var _a, _b;\n            var passive = makePassiveEventOption();\n            var currentDocument = (_a = _this.wrapperComponent) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n            var currentWindow = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.defaultView;\n            (_b = _this.wrapperComponent) === null || _b === void 0 ? void 0 : _b.addEventListener(\"wheel\", _this.onWheelPanning, passive);\n            // Panning on window to allow panning when mouse is out of component wrapper\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mousedown\", _this.onPanningStart, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mousemove\", _this.onPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mouseup\", _this.onPanningStop, passive);\n            currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.addEventListener(\"mouseleave\", _this.clearPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"keyup\", _this.setKeyUnPressed, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"keydown\", _this.setKeyPressed, passive);\n        };\n        this.cleanupWindowEvents = function () {\n            var _a, _b;\n            var passive = makePassiveEventOption();\n            var currentDocument = (_a = _this.wrapperComponent) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n            var currentWindow = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.defaultView;\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mousedown\", _this.onPanningStart, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mousemove\", _this.onPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mouseup\", _this.onPanningStop, passive);\n            currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.removeEventListener(\"mouseleave\", _this.clearPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"keyup\", _this.setKeyUnPressed, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"keydown\", _this.setKeyPressed, passive);\n            document.removeEventListener(\"mouseleave\", _this.clearPanning, passive);\n            handleCancelAnimation(_this);\n            (_b = _this.observer) === null || _b === void 0 ? void 0 : _b.disconnect();\n        };\n        this.handleInitializeWrapperEvents = function (wrapper) {\n            // Zooming events on wrapper\n            var passive = makePassiveEventOption();\n            wrapper.addEventListener(\"wheel\", _this.onWheelZoom, passive);\n            wrapper.addEventListener(\"dblclick\", _this.onDoubleClick, passive);\n            wrapper.addEventListener(\"touchstart\", _this.onTouchPanningStart, passive);\n            wrapper.addEventListener(\"touchmove\", _this.onTouchPanning, passive);\n            wrapper.addEventListener(\"touchend\", _this.onTouchPanningStop, passive);\n        };\n        this.handleInitialize = function (wrapper, contentComponent) {\n            var isCentered = false;\n            var centerOnInit = _this.setup.centerOnInit;\n            var hasTarget = function (entries, target) {\n                // eslint-disable-next-line no-restricted-syntax\n                for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n                    var entry = entries_1[_i];\n                    if (entry.target === target) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            _this.applyTransformation();\n            _this.onInitCallbacks.forEach(function (callback) {\n                callback(getContext(_this));\n            });\n            _this.observer = new ResizeObserver(function (entries) {\n                if (hasTarget(entries, wrapper) || hasTarget(entries, contentComponent)) {\n                    if (centerOnInit && !isCentered) {\n                        var currentWidth = contentComponent.offsetWidth;\n                        var currentHeight = contentComponent.offsetHeight;\n                        if (currentWidth > 0 || currentHeight > 0) {\n                            isCentered = true;\n                            _this.setCenter();\n                        }\n                    }\n                    else {\n                        handleCancelAnimation(_this);\n                        handleCalculateBounds(_this, _this.transformState.scale);\n                        handleAlignToBounds(_this, 0);\n                    }\n                }\n            });\n            // Start observing the target node for configured mutations\n            _this.observer.observe(wrapper);\n            _this.observer.observe(contentComponent);\n        };\n        /// ///////\n        // Zoom\n        /// ///////\n        this.onWheelZoom = function (event) {\n            var disabled = _this.setup.disabled;\n            if (disabled)\n                return;\n            var isAllowed = isWheelAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.wheel.activationKeys);\n            if (!keysPressed)\n                return;\n            handleWheelStart(_this, event);\n            handleWheelZoom(_this, event);\n            handleWheelStop(_this, event);\n        };\n        /// ///////\n        // Pan\n        /// ///////\n        this.onWheelPanning = function (event) {\n            var _a = _this.setup, disabled = _a.disabled, wheel = _a.wheel, panning = _a.panning;\n            if (!_this.wrapperComponent ||\n                !_this.contentComponent ||\n                disabled ||\n                !wheel.wheelDisabled ||\n                panning.disabled ||\n                !panning.wheelPanning ||\n                event.ctrlKey) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            var _b = _this.transformState, positionX = _b.positionX, positionY = _b.positionY;\n            var mouseX = positionX - event.deltaX;\n            var mouseY = positionY - event.deltaY;\n            var newPositionX = panning.lockAxisX ? positionX : mouseX;\n            var newPositionY = panning.lockAxisY ? positionY : mouseY;\n            var _c = _this.setup.alignmentAnimation, sizeX = _c.sizeX, sizeY = _c.sizeY;\n            var paddingValueX = getPaddingValue(_this, sizeX);\n            var paddingValueY = getPaddingValue(_this, sizeY);\n            if (newPositionX === positionX && newPositionY === positionY)\n                return;\n            handleNewPosition(_this, newPositionX, newPositionY, paddingValueX, paddingValueY);\n        };\n        this.onPanningStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled)\n                return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed)\n                return;\n            if (event.button === 0 && !_this.setup.panning.allowLeftClickPan)\n                return;\n            if (event.button === 1 && !_this.setup.panning.allowMiddleClickPan)\n                return;\n            if (event.button === 2 && !_this.setup.panning.allowRightClickPan)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handleCancelAnimation(_this);\n            handlePanningStart(_this, event);\n            handleCallback(getContext(_this), event, onPanningStart);\n        };\n        this.onPanning = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (disabled)\n                return;\n            var isAllowed = isPanningAllowed(_this);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePanning(_this, event.clientX, event.clientY);\n            handleCallback(getContext(_this), event, onPanning);\n        };\n        this.onPanningStop = function (event) {\n            var onPanningStop = _this.props.onPanningStop;\n            if (_this.isPanning) {\n                handlePanningEnd(_this);\n                handleCallback(getContext(_this), event, onPanningStop);\n            }\n        };\n        /// ///////\n        // Pinch\n        /// ///////\n        this.onPinchStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinchingStart = _a.onPinchingStart, onZoomStart = _a.onZoomStart;\n            if (disabled)\n                return;\n            var isAllowed = isPinchStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            handlePinchStart(_this, event);\n            handleCancelAnimation(_this);\n            handleCallback(getContext(_this), event, onPinchingStart);\n            handleCallback(getContext(_this), event, onZoomStart);\n        };\n        this.onPinch = function (event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinching = _a.onPinching, onZoom = _a.onZoom;\n            if (disabled)\n                return;\n            var isAllowed = isPinchAllowed(_this);\n            if (!isAllowed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePinchZoom(_this, event);\n            handleCallback(getContext(_this), event, onPinching);\n            handleCallback(getContext(_this), event, onZoom);\n        };\n        this.onPinchStop = function (event) {\n            var _a = _this.props, onPinchingStop = _a.onPinchingStop, onZoomStop = _a.onZoomStop;\n            if (_this.pinchStartScale) {\n                handlePinchStop(_this);\n                handleCallback(getContext(_this), event, onPinchingStop);\n                handleCallback(getContext(_this), event, onZoomStop);\n            }\n        };\n        /// ///////\n        // Touch\n        /// ///////\n        this.onTouchPanningStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled)\n                return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var isDoubleTap = _this.lastTouch &&\n                +new Date() - _this.lastTouch < 200 &&\n                event.touches.length === 1;\n            if (!isDoubleTap) {\n                _this.lastTouch = +new Date();\n                handleCancelAnimation(_this);\n                var touches = event.touches;\n                var isPanningAction = touches.length === 1;\n                var isPinchAction = touches.length === 2;\n                if (isPanningAction) {\n                    handleCancelAnimation(_this);\n                    handlePanningStart(_this, event);\n                    handleCallback(getContext(_this), event, onPanningStart);\n                }\n                if (isPinchAction) {\n                    _this.onPinchStart(event);\n                }\n            }\n        };\n        this.onTouchPanning = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (_this.isPanning && event.touches.length === 1) {\n                if (disabled)\n                    return;\n                var isAllowed = isPanningAllowed(_this);\n                if (!isAllowed)\n                    return;\n                event.preventDefault();\n                event.stopPropagation();\n                var touch = event.touches[0];\n                handlePanning(_this, touch.clientX, touch.clientY);\n                handleCallback(getContext(_this), event, onPanning);\n            }\n            else if (event.touches.length > 1) {\n                _this.onPinch(event);\n            }\n        };\n        this.onTouchPanningStop = function (event) {\n            _this.onPanningStop(event);\n            _this.onPinchStop(event);\n        };\n        /// ///////\n        // Double Click\n        /// ///////\n        this.onDoubleClick = function (event) {\n            var disabled = _this.setup.disabled;\n            if (disabled)\n                return;\n            var isAllowed = isDoubleClickAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            handleDoubleClick(_this, event);\n        };\n        /// ///////\n        // Helpers\n        /// ///////\n        this.clearPanning = function (event) {\n            if (_this.isPanning) {\n                _this.onPanningStop(event);\n            }\n        };\n        this.setKeyPressed = function (e) {\n            _this.pressedKeys[e.key] = true;\n        };\n        this.setKeyUnPressed = function (e) {\n            _this.pressedKeys[e.key] = false;\n        };\n        this.isPressingKeys = function (keys) {\n            if (!keys.length) {\n                return true;\n            }\n            return Boolean(keys.find(function (key) { return _this.pressedKeys[key]; }));\n        };\n        this.setTransformState = function (scale, positionX, positionY) {\n            var onTransformed = _this.props.onTransformed;\n            if (!Number.isNaN(scale) &&\n                !Number.isNaN(positionX) &&\n                !Number.isNaN(positionY)) {\n                if (scale !== _this.transformState.scale) {\n                    _this.transformState.previousScale = _this.transformState.scale;\n                    _this.transformState.scale = scale;\n                }\n                _this.transformState.positionX = positionX;\n                _this.transformState.positionY = positionY;\n                _this.applyTransformation();\n                var ctx_1 = getContext(_this);\n                _this.onChangeCallbacks.forEach(function (callback) { return callback(ctx_1); });\n                handleCallback(ctx_1, { scale: scale, positionX: positionX, positionY: positionY }, onTransformed);\n            }\n            else {\n                console.error(\"Detected NaN set state values\");\n            }\n        };\n        this.setCenter = function () {\n            if (_this.wrapperComponent && _this.contentComponent) {\n                var targetState = getCenterPosition(_this.transformState.scale, _this.wrapperComponent, _this.contentComponent);\n                _this.setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n            }\n        };\n        this.handleTransformStyles = function (x, y, scale) {\n            if (_this.props.customTransform) {\n                return _this.props.customTransform(x, y, scale);\n            }\n            return getTransformStyles(x, y, scale);\n        };\n        this.applyTransformation = function () {\n            if (!_this.mounted || !_this.contentComponent)\n                return;\n            var _a = _this.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n            var transform = _this.handleTransformStyles(positionX, positionY, scale);\n            _this.contentComponent.style.transform = transform;\n        };\n        this.getContext = function () {\n            return getContext(_this);\n        };\n        /**\n         * Hooks\n         */\n        this.onChange = function (callback) {\n            if (!_this.onChangeCallbacks.has(callback)) {\n                _this.onChangeCallbacks.add(callback);\n            }\n            return function () {\n                _this.onChangeCallbacks.delete(callback);\n            };\n        };\n        this.onInit = function (callback) {\n            if (!_this.onInitCallbacks.has(callback)) {\n                _this.onInitCallbacks.add(callback);\n            }\n            return function () {\n                _this.onInitCallbacks.delete(callback);\n            };\n        };\n        /**\n         * Initialization\n         */\n        this.init = function (wrapperComponent, contentComponent) {\n            _this.cleanupWindowEvents();\n            _this.wrapperComponent = wrapperComponent;\n            _this.contentComponent = contentComponent;\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.handleInitializeWrapperEvents(wrapperComponent);\n            _this.handleInitialize(wrapperComponent, contentComponent);\n            _this.initializeWindowEvents();\n            _this.isInitialized = true;\n            var ctx = getContext(_this);\n            handleCallback(ctx, undefined, _this.props.onInit);\n        };\n        this.props = props;\n        this.setup = createSetup(this.props);\n        this.transformState = createState(this.props);\n    }\n    return ZoomPanPinch;\n}());\n\nvar Context = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getContent = function (children, ctx) {\n    if (typeof children === \"function\") {\n        return children(ctx);\n    }\n    return children;\n};\nvar TransformWrapper = react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n    var instance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new ZoomPanPinch(props)).current;\n    var content = getContent(props.children, getControls(instance));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () { return getControls(instance); }, [instance]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        instance.update(props);\n    }, [instance, props]);\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, { value: instance }, content);\n});\n\nvar KeepScale = react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function (props, ref) {\n    var localRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var instance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        return instance.onChange(function (ctx) {\n            if (localRef.current) {\n                var positionX = 0;\n                var positionY = 0;\n                localRef.current.style.transform = instance.handleTransformStyles(positionX, positionY, 1 / ctx.instance.transformState.scale);\n            }\n        });\n    }, [instance]);\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, props, { ref: mergeRefs([localRef, ref]) }));\n});\n\nvar initialElementRect = {\n    width: 0,\n    height: 0,\n    y: 0,\n    x: 0,\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n};\nvar useResize = function (ref, onResize, dependencies) {\n    var resizeObserverRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var rectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialElementRect);\n    var didUnmount = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(function () {\n        var _a;\n        didUnmount.current = false;\n        if (!(\"ResizeObserver\" in window)) {\n            return;\n        }\n        if (ref) {\n            resizeObserverRef.current = new ResizeObserver(function (entries) {\n                var newSize = ref.getBoundingClientRect();\n                if (!Array.isArray(entries) ||\n                    !entries.length ||\n                    didUnmount.current ||\n                    (newSize.width === rectRef.current.width &&\n                        newSize.height === rectRef.current.height))\n                    return;\n                onResize(newSize, ref);\n                rectRef.current = newSize;\n            });\n            (_a = resizeObserverRef.current) === null || _a === void 0 ? void 0 : _a.observe(ref);\n        }\n        return function () {\n            var _a;\n            didUnmount.current = true;\n            if (ref) {\n                (_a = resizeObserverRef.current) === null || _a === void 0 ? void 0 : _a.unobserve(ref);\n            }\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, __spreadArray([onResize, ref], dependencies, true));\n};\n\nvar previewStyles = {\n    position: \"absolute\",\n    zIndex: 2,\n    top: \"0px\",\n    left: \"0px\",\n    boxSizing: \"border-box\",\n    border: \"3px solid red\",\n    transformOrigin: \"0% 0%\",\n    boxShadow: \"rgba(0,0,0,0.2) 0 0 0 10000000px\",\n};\nvar MiniMap = function (_a) {\n    var _b = _a.width, width = _b === void 0 ? 200 : _b, _c = _a.height, height = _c === void 0 ? 200 : _c, _d = _a.borderColor, borderColor = _d === void 0 ? \"red\" : _d, children = _a.children, rest = __rest(_a, [\"width\", \"height\", \"borderColor\", \"children\"]);\n    var _e = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), initialized = _e[0], setInitialized = _e[1];\n    var instance = useTransformContext();\n    var miniMapInstance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var mainRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var previewRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var getViewportSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n        if (instance.wrapperComponent) {\n            var rect = instance.wrapperComponent.getBoundingClientRect();\n            return {\n                width: rect.width,\n                height: rect.height,\n            };\n        }\n        return {\n            width: 0,\n            height: 0,\n        };\n    }, [instance.wrapperComponent]);\n    var getContentSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n        if (instance.contentComponent) {\n            var rect = instance.contentComponent.getBoundingClientRect();\n            return {\n                width: rect.width / instance.transformState.scale,\n                height: rect.height / instance.transformState.scale,\n            };\n        }\n        return {\n            width: 0,\n            height: 0,\n        };\n    }, [instance.contentComponent, instance.transformState.scale]);\n    var computeMiniMapScale = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function () {\n        var contentSize = getContentSize();\n        var scaleX = width / contentSize.width;\n        var scaleY = height / contentSize.height;\n        var scale = scaleY > scaleX ? scaleX : scaleY;\n        return scale;\n    }, [getContentSize, height, width]);\n    var computeMiniMapSize = function () {\n        var contentSize = getContentSize();\n        var scaleX = width / contentSize.width;\n        var scaleY = height / contentSize.height;\n        if (scaleY > scaleX) {\n            return { width: width, height: contentSize.height * scaleX };\n        }\n        return { width: contentSize.width * scaleY, height: height };\n    };\n    var computeMiniMapStyle = function () {\n        var scale = computeMiniMapScale();\n        var style = {\n            transform: \"scale(\".concat(scale || 1, \")\"),\n            transformOrigin: \"0% 0%\",\n            position: \"absolute\",\n            boxSizing: \"border-box\",\n            zIndex: 1,\n            overflow: \"hidden\",\n        };\n        Object.keys(style).forEach(function (key) {\n            if (wrapperRef.current) {\n                wrapperRef.current.style[key] = style[key];\n            }\n        });\n    };\n    var transformMiniMap = function () {\n        computeMiniMapStyle();\n        var miniSize = computeMiniMapSize();\n        var wrapSize = getContentSize();\n        if (wrapperRef.current) {\n            wrapperRef.current.style.width = \"\".concat(wrapSize.width, \"px\");\n            wrapperRef.current.style.height = \"\".concat(wrapSize.height, \"px\");\n        }\n        if (mainRef.current) {\n            mainRef.current.style.width = \"\".concat(miniSize.width, \"px\");\n            mainRef.current.style.height = \"\".concat(miniSize.height, \"px\");\n        }\n        if (previewRef.current) {\n            var size = getViewportSize();\n            var scale = computeMiniMapScale();\n            var previewScale = scale * (1 / instance.transformState.scale);\n            var transform = instance.handleTransformStyles(-instance.transformState.positionX * previewScale, -instance.transformState.positionY * previewScale, 1);\n            previewRef.current.style.transform = transform;\n            previewRef.current.style.width = \"\".concat(size.width * previewScale, \"px\");\n            previewRef.current.style.height = \"\".concat(size.height * previewScale, \"px\");\n        }\n    };\n    var initialize = function () {\n        transformMiniMap();\n    };\n    useTransformEffect(function () {\n        transformMiniMap();\n    });\n    useTransformInit(function () {\n        initialize();\n        setInitialized(true);\n    });\n    useResize(instance.contentComponent, initialize, [initialized]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        return instance.onChange(function (zpp) {\n            var scale = computeMiniMapScale();\n            if (miniMapInstance.current) {\n                miniMapInstance.current.instance.transformState.scale =\n                    zpp.instance.transformState.scale;\n                miniMapInstance.current.instance.transformState.positionX =\n                    zpp.instance.transformState.positionX * scale;\n                miniMapInstance.current.instance.transformState.positionY =\n                    zpp.instance.transformState.positionY * scale;\n            }\n        });\n    }, [computeMiniMapScale, instance, miniMapInstance]);\n    var wrapperStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n        return {\n            position: \"relative\",\n            zIndex: 2,\n            overflow: \"hidden\",\n        };\n    }, []);\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, rest, { ref: mainRef, style: wrapperStyle, className: \"rzpp-mini-map \".concat(rest.className || \"\") }),\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, rest, { ref: wrapperRef, className: \"rzpp-wrapper\" }), children),\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { className: \"rzpp-preview\", ref: previewRef, style: __assign(__assign({}, previewStyles), { borderColor: borderColor }) })));\n};\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".transform-component-module_wrapper__SPB86 {\\n  position: relative;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n  transform: translate3d(0, 0, 0);\\n}\\n.transform-component-module_content__FBWxo {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  margin: 0;\\n  padding: 0;\\n  transform-origin: 0% 0%;\\n}\\n.transform-component-module_content__FBWxo img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\"wrapper\":\"transform-component-module_wrapper__SPB86\",\"content\":\"transform-component-module_content__FBWxo\"};\nstyleInject(css_248z);\n\nvar TransformComponent = function (_a) {\n    var children = _a.children, _b = _a.wrapperClass, wrapperClass = _b === void 0 ? \"\" : _b, _c = _a.contentClass, contentClass = _c === void 0 ? \"\" : _c, wrapperStyle = _a.wrapperStyle, contentStyle = _a.contentStyle, _d = _a.wrapperProps, wrapperProps = _d === void 0 ? {} : _d, _e = _a.contentProps, contentProps = _e === void 0 ? {} : _e;\n    var _f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context), init = _f.init, cleanupWindowEvents = _f.cleanupWindowEvents;\n    var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        var wrapper = wrapperRef.current;\n        var content = contentRef.current;\n        if (wrapper !== null && content !== null && init) {\n            init === null || init === void 0 ? void 0 : init(wrapper, content);\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        return function () {\n            cleanupWindowEvents === null || cleanupWindowEvents === void 0 ? void 0 : cleanupWindowEvents();\n        };\n    }, []);\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, wrapperProps, { ref: wrapperRef, className: \"\".concat(baseClasses.wrapperClass, \" \").concat(styles.wrapper, \" \").concat(wrapperClass), style: wrapperStyle }),\n        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, contentProps, { ref: contentRef, className: \"\".concat(baseClasses.contentClass, \" \").concat(styles.content, \" \").concat(contentClass), style: contentStyle }), children)));\n};\n\nvar useTransformContext = function () {\n    var libraryContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    if (!libraryContext) {\n        throw new Error(\"Transform context must be placed inside TransformWrapper\");\n    }\n    return libraryContext;\n};\n\nvar useControls = function () {\n    var libraryContext = useTransformContext();\n    return getControls(libraryContext);\n};\n\nvar useTransformInit = function (callback) {\n    var libraryContext = useTransformContext();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        var unmountCallback;\n        var unmount;\n        if (libraryContext.contentComponent && libraryContext.wrapperComponent) {\n            unmountCallback = callback(getState(libraryContext));\n        }\n        else {\n            unmount = libraryContext.onInit(function (ref) {\n                unmountCallback = callback(getState(ref.instance));\n            });\n        }\n        return function () {\n            unmount === null || unmount === void 0 ? void 0 : unmount();\n            unmountCallback === null || unmountCallback === void 0 ? void 0 : unmountCallback();\n        };\n    }, []);\n};\n\nvar useTransformEffect = function (callback) {\n    var libraryContext = useTransformContext();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        var unmountCallback;\n        var unmount = libraryContext.onChange(function (ref) {\n            unmountCallback = callback(getState(ref.instance));\n        });\n        return function () {\n            unmount();\n            unmountCallback === null || unmountCallback === void 0 ? void 0 : unmountCallback();\n        };\n    }, [callback, libraryContext]);\n};\n\nfunction useTransformComponent(callback) {\n    var libraryContext = useTransformContext();\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(callback(getState(libraryContext))), transformRender = _a[0], setTransformRender = _a[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        var mounted = true;\n        var unmount = libraryContext.onChange(function (ref) {\n            if (mounted) {\n                setTransformRender(callback(getState(ref.instance)));\n            }\n        });\n        return function () {\n            unmount();\n            mounted = false;\n        };\n    }, [callback, libraryContext]);\n    return transformRender;\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC16b29tLXBhbi1waW5jaC9kaXN0L2luZGV4LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUk7O0FBRW5JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0Isd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCx1QkFBdUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdDQUFnQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHlCQUF5QjtBQUMvRix3Q0FBd0MsMERBQTBEO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBRUE7QUFDQTtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsK0NBQVE7QUFDckIsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFNk87QUFDN08iLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9ub2RlX21vZHVsZXMvcmVhY3Qtem9vbS1wYW4tcGluY2gvZGlzdC9pbmRleC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0LCB1c2VDb250ZXh0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBSb3VuZHMgbnVtYmVyIHRvIGdpdmVuIGRlY2ltYWxcbiAqIGVnLiByb3VuZE51bWJlcigyLjM0MzQzLCAxKSA9PiAyLjNcbiAqL1xudmFyIHJvdW5kTnVtYmVyID0gZnVuY3Rpb24gKG51bSwgZGVjaW1hbCkge1xuICAgIHJldHVybiBOdW1iZXIobnVtLnRvRml4ZWQoZGVjaW1hbCkpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIHZhbHVlIGlzIG51bWJlciwgaWYgbm90IGl0IHJldHVybnMgZGVmYXVsdCB2YWx1ZVxuICogMSMgZWcuIGNoZWNrSXNOdW1iZXIoMiwgMzApID0+IDJcbiAqIDIjIGVnLiBjaGVja0lzTnVtYmVyKG51bGwsIDMwKSA9PiAzMFxuICovXG52YXIgY2hlY2tJc051bWJlciA9IGZ1bmN0aW9uIChudW0sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgbnVtID09PSBcIm51bWJlclwiID8gbnVtIDogZGVmYXVsdFZhbHVlO1xufTtcblxudmFyIGhhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gKGNvbnRleHQsIGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayhjb250ZXh0LCBldmVudCk7XG4gICAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGx1c3BsdXMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG4vKipcbiAqIEZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGRlbm9taW5hdG9yIG9mIHRoZSB0YXJnZXQgdmFsdWUsIHdoaWNoIGlzIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGVwLlxuICogdCBpcyBhIHZhbHVlIGZyb20gMCB0byAxLCByZWZsZWN0aW5nIHRoZSBwZXJjZW50YWdlIG9mIGFuaW1hdGlvbiBzdGF0dXMuXG4gKi9cbnZhciBlYXNlT3V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gLU1hdGguY29zKHQgKiBNYXRoLlBJKSAvIDIgKyAwLjU7XG59O1xuLy8gbGluZWFyXG52YXIgbGluZWFyID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdDtcbn07XG4vLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZUluUXVhZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0O1xufTtcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZU91dFF1YWQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogKDIgLSB0KTtcbn07XG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbnZhciBlYXNlSW5PdXRRdWFkID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDIgKiB0ICogdCA6IC0xICsgKDQgLSAyICogdCkgKiB0O1xufTtcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlSW5DdWJpYyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdDtcbn07XG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VPdXRDdWJpYyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn07XG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbnZhciBlYXNlSW5PdXRDdWJpYyA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xufTtcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlSW5RdWFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG59O1xuLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlT3V0UXVhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAxIC0gLS10ICogdCAqIHQgKiB0O1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dFF1YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJblF1aW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG59O1xuLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlT3V0UXVpbnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAxICsgLS10ICogdCAqIHQgKiB0ICogdDtcbn07XG4vLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cbnZhciBlYXNlSW5PdXRRdWludCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgPCAwLjUgPyAxNiAqIHQgKiB0ICogdCAqIHQgKiB0IDogMSArIDE2ICogLS10ICogdCAqIHQgKiB0ICogdDtcbn07XG52YXIgYW5pbWF0aW9ucyA9IHtcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGxpbmVhcjogbGluZWFyLFxuICAgIGVhc2VJblF1YWQ6IGVhc2VJblF1YWQsXG4gICAgZWFzZU91dFF1YWQ6IGVhc2VPdXRRdWFkLFxuICAgIGVhc2VJbk91dFF1YWQ6IGVhc2VJbk91dFF1YWQsXG4gICAgZWFzZUluQ3ViaWM6IGVhc2VJbkN1YmljLFxuICAgIGVhc2VPdXRDdWJpYzogZWFzZU91dEN1YmljLFxuICAgIGVhc2VJbk91dEN1YmljOiBlYXNlSW5PdXRDdWJpYyxcbiAgICBlYXNlSW5RdWFydDogZWFzZUluUXVhcnQsXG4gICAgZWFzZU91dFF1YXJ0OiBlYXNlT3V0UXVhcnQsXG4gICAgZWFzZUluT3V0UXVhcnQ6IGVhc2VJbk91dFF1YXJ0LFxuICAgIGVhc2VJblF1aW50OiBlYXNlSW5RdWludCxcbiAgICBlYXNlT3V0UXVpbnQ6IGVhc2VPdXRRdWludCxcbiAgICBlYXNlSW5PdXRRdWludDogZWFzZUluT3V0UXVpbnQsXG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xudmFyIGhhbmRsZUNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGFuaW1hdGlvbikge1xuICAgIGlmICh0eXBlb2YgYW5pbWF0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbik7XG4gICAgfVxufTtcbnZhciBoYW5kbGVDYW5jZWxBbmltYXRpb24gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbkZyYW1lKGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24pO1xuICAgIC8vIENsZWFyIGFuaW1hdGlvbiBzdGF0ZVxuICAgIGNvbnRleHRJbnN0YW5jZS5hbmltYXRlID0gZmFsc2U7XG4gICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLnZlbG9jaXR5ID0gbnVsbDtcbn07XG5mdW5jdGlvbiBoYW5kbGVTZXR1cEFuaW1hdGlvbihjb250ZXh0SW5zdGFuY2UsIGFuaW1hdGlvbk5hbWUsIGFuaW1hdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB2YXIgbGFzdFN0ZXAgPSAxO1xuICAgIC8vIGlmIGFub3RoZXIgYW5pbWF0aW9uIGlzIGFjdGl2ZVxuICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihjb250ZXh0SW5zdGFuY2UpO1xuICAgIC8vIG5ldyBhbmltYXRpb25cbiAgICBjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS5tb3VudGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2FuY2VsQW5pbWF0aW9uRnJhbWUoY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZyYW1lVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lO1xuICAgICAgICB2YXIgYW5pbWF0aW9uUHJvZ3Jlc3MgPSBmcmFtZVRpbWUgLyBhbmltYXRpb25UaW1lO1xuICAgICAgICB2YXIgYW5pbWF0aW9uVHlwZSA9IGFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV07XG4gICAgICAgIHZhciBzdGVwID0gYW5pbWF0aW9uVHlwZShhbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgICAgIGlmIChmcmFtZVRpbWUgPj0gYW5pbWF0aW9uVGltZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobGFzdFN0ZXApO1xuICAgICAgICAgICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RlcCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRUYXJnZXRTdGF0ZSh0YXJnZXRTdGF0ZSkge1xuICAgIHZhciBzY2FsZSA9IHRhcmdldFN0YXRlLnNjYWxlLCBwb3NpdGlvblggPSB0YXJnZXRTdGF0ZS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IHRhcmdldFN0YXRlLnBvc2l0aW9uWTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHNjYWxlKSB8fFxuICAgICAgICBOdW1iZXIuaXNOYU4ocG9zaXRpb25YKSB8fFxuICAgICAgICBOdW1iZXIuaXNOYU4ocG9zaXRpb25ZKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25OYW1lKSB7XG4gICAgdmFyIGlzVmFsaWQgPSBpc1ZhbGlkVGFyZ2V0U3RhdGUodGFyZ2V0U3RhdGUpO1xuICAgIGlmICghY29udGV4dEluc3RhbmNlLm1vdW50ZWQgfHwgIWlzVmFsaWQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgc2V0VHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2Uuc2V0VHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBzY2FsZSA9IF9hLnNjYWxlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICB2YXIgc2NhbGVEaWZmID0gdGFyZ2V0U3RhdGUuc2NhbGUgLSBzY2FsZTtcbiAgICB2YXIgcG9zaXRpb25YRGlmZiA9IHRhcmdldFN0YXRlLnBvc2l0aW9uWCAtIHBvc2l0aW9uWDtcbiAgICB2YXIgcG9zaXRpb25ZRGlmZiA9IHRhcmdldFN0YXRlLnBvc2l0aW9uWSAtIHBvc2l0aW9uWTtcbiAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gMCkge1xuICAgICAgICBzZXRUcmFuc2Zvcm1TdGF0ZSh0YXJnZXRTdGF0ZS5zY2FsZSwgdGFyZ2V0U3RhdGUucG9zaXRpb25YLCB0YXJnZXRTdGF0ZS5wb3NpdGlvblkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYW5pbWF0aW9uIHN0YXJ0IHRpbWVzdGFtcFxuICAgICAgICBoYW5kbGVTZXR1cEFuaW1hdGlvbihjb250ZXh0SW5zdGFuY2UsIGFuaW1hdGlvbk5hbWUsIGFuaW1hdGlvblRpbWUsIGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2NhbGUgPSBzY2FsZSArIHNjYWxlRGlmZiAqIHN0ZXA7XG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb25YID0gcG9zaXRpb25YICsgcG9zaXRpb25YRGlmZiAqIHN0ZXA7XG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb25ZID0gcG9zaXRpb25ZICsgcG9zaXRpb25ZRGlmZiAqIHN0ZXA7XG4gICAgICAgICAgICBzZXRUcmFuc2Zvcm1TdGF0ZShuZXdTY2FsZSwgbmV3UG9zaXRpb25YLCBuZXdQb3NpdGlvblkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRzU2l6ZXMod3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCwgbmV3U2NhbGUpIHtcbiAgICB2YXIgd3JhcHBlcldpZHRoID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgd3JhcHBlckhlaWdodCA9IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0O1xuICAgIHZhciBjb250ZW50V2lkdGggPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciBjb250ZW50SGVpZ2h0ID0gY29udGVudENvbXBvbmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG5ld0NvbnRlbnRXaWR0aCA9IGNvbnRlbnRXaWR0aCAqIG5ld1NjYWxlO1xuICAgIHZhciBuZXdDb250ZW50SGVpZ2h0ID0gY29udGVudEhlaWdodCAqIG5ld1NjYWxlO1xuICAgIHZhciBuZXdEaWZmV2lkdGggPSB3cmFwcGVyV2lkdGggLSBuZXdDb250ZW50V2lkdGg7XG4gICAgdmFyIG5ld0RpZmZIZWlnaHQgPSB3cmFwcGVySGVpZ2h0IC0gbmV3Q29udGVudEhlaWdodDtcbiAgICByZXR1cm4ge1xuICAgICAgICB3cmFwcGVyV2lkdGg6IHdyYXBwZXJXaWR0aCxcbiAgICAgICAgd3JhcHBlckhlaWdodDogd3JhcHBlckhlaWdodCxcbiAgICAgICAgbmV3Q29udGVudFdpZHRoOiBuZXdDb250ZW50V2lkdGgsXG4gICAgICAgIG5ld0RpZmZXaWR0aDogbmV3RGlmZldpZHRoLFxuICAgICAgICBuZXdDb250ZW50SGVpZ2h0OiBuZXdDb250ZW50SGVpZ2h0LFxuICAgICAgICBuZXdEaWZmSGVpZ2h0OiBuZXdEaWZmSGVpZ2h0LFxuICAgIH07XG59XG52YXIgZ2V0Qm91bmRzID0gZnVuY3Rpb24gKHdyYXBwZXJXaWR0aCwgbmV3Q29udGVudFdpZHRoLCBkaWZmV2lkdGgsIHdyYXBwZXJIZWlnaHQsIG5ld0NvbnRlbnRIZWlnaHQsIGRpZmZIZWlnaHQsIGNlbnRlclpvb21lZE91dCkge1xuICAgIHZhciBzY2FsZVdpZHRoRmFjdG9yID0gd3JhcHBlcldpZHRoID4gbmV3Q29udGVudFdpZHRoXG4gICAgICAgID8gZGlmZldpZHRoICogKGNlbnRlclpvb21lZE91dCA/IDEgOiAwLjUpXG4gICAgICAgIDogMDtcbiAgICB2YXIgc2NhbGVIZWlnaHRGYWN0b3IgPSB3cmFwcGVySGVpZ2h0ID4gbmV3Q29udGVudEhlaWdodFxuICAgICAgICA/IGRpZmZIZWlnaHQgKiAoY2VudGVyWm9vbWVkT3V0ID8gMSA6IDAuNSlcbiAgICAgICAgOiAwO1xuICAgIHZhciBtaW5Qb3NpdGlvblggPSB3cmFwcGVyV2lkdGggLSBuZXdDb250ZW50V2lkdGggLSBzY2FsZVdpZHRoRmFjdG9yO1xuICAgIHZhciBtYXhQb3NpdGlvblggPSBzY2FsZVdpZHRoRmFjdG9yO1xuICAgIHZhciBtaW5Qb3NpdGlvblkgPSB3cmFwcGVySGVpZ2h0IC0gbmV3Q29udGVudEhlaWdodCAtIHNjYWxlSGVpZ2h0RmFjdG9yO1xuICAgIHZhciBtYXhQb3NpdGlvblkgPSBzY2FsZUhlaWdodEZhY3RvcjtcbiAgICByZXR1cm4geyBtaW5Qb3NpdGlvblg6IG1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25YOiBtYXhQb3NpdGlvblgsIG1pblBvc2l0aW9uWTogbWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblk6IG1heFBvc2l0aW9uWSB9O1xufTtcbnZhciBjYWxjdWxhdGVCb3VuZHMgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSkge1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICB2YXIgY2VudGVyWm9vbWVkT3V0ID0gY29udGV4dEluc3RhbmNlLnNldHVwLmNlbnRlclpvb21lZE91dDtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50cyBhcmUgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIHZhciBfYSA9IGdldENvbXBvbmVudHNTaXplcyh3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50LCBuZXdTY2FsZSksIHdyYXBwZXJXaWR0aCA9IF9hLndyYXBwZXJXaWR0aCwgd3JhcHBlckhlaWdodCA9IF9hLndyYXBwZXJIZWlnaHQsIG5ld0NvbnRlbnRXaWR0aCA9IF9hLm5ld0NvbnRlbnRXaWR0aCwgbmV3RGlmZldpZHRoID0gX2EubmV3RGlmZldpZHRoLCBuZXdDb250ZW50SGVpZ2h0ID0gX2EubmV3Q29udGVudEhlaWdodCwgbmV3RGlmZkhlaWdodCA9IF9hLm5ld0RpZmZIZWlnaHQ7XG4gICAgdmFyIGJvdW5kcyA9IGdldEJvdW5kcyh3cmFwcGVyV2lkdGgsIG5ld0NvbnRlbnRXaWR0aCwgbmV3RGlmZldpZHRoLCB3cmFwcGVySGVpZ2h0LCBuZXdDb250ZW50SGVpZ2h0LCBuZXdEaWZmSGVpZ2h0LCBCb29sZWFuKGNlbnRlclpvb21lZE91dCkpO1xuICAgIHJldHVybiBib3VuZHM7XG59O1xuLyoqXG4gKiBLZWVwcyB2YWx1ZSBiZXR3ZWVuIGdpdmVuIGJvdW5kcywgdXNlZCBmb3IgbGltaXRpbmcgdmlldyB0byBnaXZlbiBib3VuZGFyaWVzXG4gKiAxIyBlZy4gYm91bmRMaW1pdGVyKDIsIDAsIDMsIHRydWUpID0+IDJcbiAqIDIjIGVnLiBib3VuZExpbWl0ZXIoNCwgMCwgMywgdHJ1ZSkgPT4gM1xuICogMyMgZWcuIGJvdW5kTGltaXRlcigtMiwgMCwgMywgdHJ1ZSkgPT4gMFxuICogNCMgZWcuIGJvdW5kTGltaXRlcigxMCwgMCwgMywgZmFsc2UpID0+IDEwXG4gKi9cbnZhciBib3VuZExpbWl0ZXIgPSBmdW5jdGlvbiAodmFsdWUsIG1pbkJvdW5kLCBtYXhCb3VuZCwgaXNBY3RpdmUpIHtcbiAgICBpZiAoIWlzQWN0aXZlKVxuICAgICAgICByZXR1cm4gcm91bmROdW1iZXIodmFsdWUsIDIpO1xuICAgIGlmICh2YWx1ZSA8IG1pbkJvdW5kKVxuICAgICAgICByZXR1cm4gcm91bmROdW1iZXIobWluQm91bmQsIDIpO1xuICAgIGlmICh2YWx1ZSA+IG1heEJvdW5kKVxuICAgICAgICByZXR1cm4gcm91bmROdW1iZXIobWF4Qm91bmQsIDIpO1xuICAgIHJldHVybiByb3VuZE51bWJlcih2YWx1ZSwgMik7XG59O1xudmFyIGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKSB7XG4gICAgdmFyIGJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICAvLyBTYXZlIGJvdW5kc1xuICAgIGNvbnRleHRJbnN0YW5jZS5ib3VuZHMgPSBib3VuZHM7XG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG5mdW5jdGlvbiBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihwb3NpdGlvblgsIHBvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWVYLCBwYWRkaW5nVmFsdWVZLCB3cmFwcGVyQ29tcG9uZW50KSB7XG4gICAgdmFyIG1pblBvc2l0aW9uWCA9IGJvdW5kcy5taW5Qb3NpdGlvblgsIG1pblBvc2l0aW9uWSA9IGJvdW5kcy5taW5Qb3NpdGlvblksIG1heFBvc2l0aW9uWCA9IGJvdW5kcy5tYXhQb3NpdGlvblgsIG1heFBvc2l0aW9uWSA9IGJvdW5kcy5tYXhQb3NpdGlvblk7XG4gICAgdmFyIHBhZGRpbmdYID0gMDtcbiAgICB2YXIgcGFkZGluZ1kgPSAwO1xuICAgIGlmICh3cmFwcGVyQ29tcG9uZW50KSB7XG4gICAgICAgIHBhZGRpbmdYID0gcGFkZGluZ1ZhbHVlWDtcbiAgICAgICAgcGFkZGluZ1kgPSBwYWRkaW5nVmFsdWVZO1xuICAgIH1cbiAgICB2YXIgeCA9IGJvdW5kTGltaXRlcihwb3NpdGlvblgsIG1pblBvc2l0aW9uWCAtIHBhZGRpbmdYLCBtYXhQb3NpdGlvblggKyBwYWRkaW5nWCwgbGltaXRUb0JvdW5kcyk7XG4gICAgdmFyIHkgPSBib3VuZExpbWl0ZXIocG9zaXRpb25ZLCBtaW5Qb3NpdGlvblkgLSBwYWRkaW5nWSwgbWF4UG9zaXRpb25ZICsgcGFkZGluZ1ksIGxpbWl0VG9Cb3VuZHMpO1xuICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2FsY3VsYXRlWm9vbVBvc2l0aW9ucyhjb250ZXh0SW5zdGFuY2UsIG1vdXNlWCwgbW91c2VZLCBuZXdTY2FsZSwgYm91bmRzLCBsaW1pdFRvQm91bmRzKSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBzY2FsZSA9IF9hLnNjYWxlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICB2YXIgc2NhbGVEaWZmZXJlbmNlID0gbmV3U2NhbGUgLSBzY2FsZTtcbiAgICBpZiAodHlwZW9mIG1vdXNlWCAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgbW91c2VZICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNb3VzZSBYIGFuZCBZIHBvc2l0aW9uIHdlcmUgbm90IHByb3ZpZGVkIVwiKTtcbiAgICAgICAgcmV0dXJuIHsgeDogcG9zaXRpb25YLCB5OiBwb3NpdGlvblkgfTtcbiAgICB9XG4gICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvblggPSBwb3NpdGlvblggLSBtb3VzZVggKiBzY2FsZURpZmZlcmVuY2U7XG4gICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvblkgPSBwb3NpdGlvblkgLSBtb3VzZVkgKiBzY2FsZURpZmZlcmVuY2U7XG4gICAgLy8gZG8gbm90IGxpbWl0IHRvIGJvdW5kcyB3aGVuIHRoZXJlIGlzIHBhZGRpbmcgYW5pbWF0aW9uLFxuICAgIC8vIGl0IGNhdXNlcyBhbmltYXRpb24gc3RyYW5nZSBiZWhhdmlvdXJcbiAgICB2YXIgbmV3UG9zaXRpb25zID0gZ2V0TW91c2VCb3VuZGVkUG9zaXRpb24oY2FsY3VsYXRlZFBvc2l0aW9uWCwgY2FsY3VsYXRlZFBvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCAwLCAwLCBudWxsKTtcbiAgICByZXR1cm4gbmV3UG9zaXRpb25zO1xufVxuZnVuY3Rpb24gY2hlY2tab29tQm91bmRzKHpvb20sIG1pblNjYWxlLCBtYXhTY2FsZSwgem9vbVBhZGRpbmcsIGVuYWJsZVBhZGRpbmcpIHtcbiAgICB2YXIgc2NhbGVQYWRkaW5nID0gZW5hYmxlUGFkZGluZyA/IHpvb21QYWRkaW5nIDogMDtcbiAgICB2YXIgbWluU2NhbGVXaXRoUGFkZGluZyA9IG1pblNjYWxlIC0gc2NhbGVQYWRkaW5nO1xuICAgIGlmICghTnVtYmVyLmlzTmFOKG1heFNjYWxlKSAmJiB6b29tID49IG1heFNjYWxlKVxuICAgICAgICByZXR1cm4gbWF4U2NhbGU7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obWluU2NhbGUpICYmIHpvb20gPD0gbWluU2NhbGVXaXRoUGFkZGluZylcbiAgICAgICAgcmV0dXJuIG1pblNjYWxlV2l0aFBhZGRpbmc7XG4gICAgcmV0dXJuIHpvb207XG59XG5cbnZhciBpc1Bhbm5pbmdTdGFydEFsbG93ZWQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBleGNsdWRlZCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5wYW5uaW5nLmV4Y2x1ZGVkO1xuICAgIHZhciBpc0luaXRpYWxpemVkID0gY29udGV4dEluc3RhbmNlLmlzSW5pdGlhbGl6ZWQsIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciB0YXJnZXRJc1NoYWRvd0RvbSA9IFwic2hhZG93Um9vdFwiIGluIHRhcmdldCAmJiBcImNvbXBvc2VkUGF0aFwiIGluIGV2ZW50O1xuICAgIHZhciBpc1dyYXBwZXJDaGlsZCA9IHRhcmdldElzU2hhZG93RG9tXG4gICAgICAgID8gZXZlbnQuY29tcG9zZWRQYXRoKCkuc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICghKGVsIGluc3RhbmNlb2YgRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fCB3cmFwcGVyQ29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyQ29tcG9uZW50LmNvbnRhaW5zKGVsKTtcbiAgICAgICAgfSlcbiAgICAgICAgOiB3cmFwcGVyQ29tcG9uZW50ID09PSBudWxsIHx8IHdyYXBwZXJDb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdyYXBwZXJDb21wb25lbnQuY29udGFpbnModGFyZ2V0KTtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNJbml0aWFsaXplZCAmJiB0YXJnZXQgJiYgaXNXcmFwcGVyQ2hpbGQ7XG4gICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaXNFeGNsdWRlZCA9IGlzRXhjbHVkZWROb2RlKHRhcmdldCwgZXhjbHVkZWQpO1xuICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzUGFubmluZ0FsbG93ZWQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgdmFyIGlzSW5pdGlhbGl6ZWQgPSBjb250ZXh0SW5zdGFuY2UuaXNJbml0aWFsaXplZCwgaXNQYW5uaW5nID0gY29udGV4dEluc3RhbmNlLmlzUGFubmluZywgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXA7XG4gICAgdmFyIGRpc2FibGVkID0gc2V0dXAucGFubmluZy5kaXNhYmxlZDtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNJbml0aWFsaXplZCAmJiBpc1Bhbm5pbmcgJiYgIWRpc2FibGVkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGhhbmRsZVBhbm5pbmdTZXR1cCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nID0gdHJ1ZTtcbiAgICAvLyBQYW5uaW5nIHdpdGggbW91c2VcbiAgICB2YXIgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgdmFyIHkgPSBldmVudC5jbGllbnRZO1xuICAgIGNvbnRleHRJbnN0YW5jZS5zdGFydENvb3JkcyA9IHsgeDogeCAtIHBvc2l0aW9uWCwgeTogeSAtIHBvc2l0aW9uWSB9O1xufTtcbnZhciBoYW5kbGVUb3VjaFBhbm5pbmdTZXR1cCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgY29udGV4dEluc3RhbmNlLmlzUGFubmluZyA9IHRydWU7XG4gICAgLy8gUGFubmluZyB3aXRoIHRvdWNoXG4gICAgdmFyIG9uZUZpbmdlclRvdWNoID0gdG91Y2hlcy5sZW5ndGggPT09IDE7XG4gICAgaWYgKG9uZUZpbmdlclRvdWNoKSB7XG4gICAgICAgIHZhciB4ID0gdG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB2YXIgeSA9IHRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLnN0YXJ0Q29vcmRzID0geyB4OiB4IC0gcG9zaXRpb25YLCB5OiB5IC0gcG9zaXRpb25ZIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIGhhbmRsZVBhblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblksIHNjYWxlID0gX2Euc2NhbGU7XG4gICAgdmFyIF9iID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBsaW1pdFRvQm91bmRzID0gX2IubGltaXRUb0JvdW5kcywgY2VudGVyWm9vbWVkT3V0ID0gX2IuY2VudGVyWm9vbWVkT3V0O1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF3cmFwcGVyQ29tcG9uZW50IHx8ICFjb250ZXh0SW5zdGFuY2UuYm91bmRzKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIF9jID0gY29udGV4dEluc3RhbmNlLmJvdW5kcywgbWF4UG9zaXRpb25YID0gX2MubWF4UG9zaXRpb25YLCBtaW5Qb3NpdGlvblggPSBfYy5taW5Qb3NpdGlvblgsIG1heFBvc2l0aW9uWSA9IF9jLm1heFBvc2l0aW9uWSwgbWluUG9zaXRpb25ZID0gX2MubWluUG9zaXRpb25ZO1xuICAgIHZhciB4Q2hhbmdlZCA9IHBvc2l0aW9uWCA+IG1heFBvc2l0aW9uWCB8fCBwb3NpdGlvblggPCBtaW5Qb3NpdGlvblg7XG4gICAgdmFyIHlDaGFuZ2VkID0gcG9zaXRpb25ZID4gbWF4UG9zaXRpb25ZIHx8IHBvc2l0aW9uWSA8IG1pblBvc2l0aW9uWTtcbiAgICB2YXIgbW91c2VQb3NYID0gcG9zaXRpb25YID4gbWF4UG9zaXRpb25YXG4gICAgICAgID8gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aFxuICAgICAgICA6IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5taW5Qb3NpdGlvblggfHwgMDtcbiAgICB2YXIgbW91c2VQb3NZID0gcG9zaXRpb25ZID4gbWF4UG9zaXRpb25ZXG4gICAgICAgID8gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHRcbiAgICAgICAgOiBjb250ZXh0SW5zdGFuY2Uuc2V0dXAubWluUG9zaXRpb25ZIHx8IDA7XG4gICAgdmFyIF9kID0gaGFuZGxlQ2FsY3VsYXRlWm9vbVBvc2l0aW9ucyhjb250ZXh0SW5zdGFuY2UsIG1vdXNlUG9zWCwgbW91c2VQb3NZLCBzY2FsZSwgY29udGV4dEluc3RhbmNlLmJvdW5kcywgbGltaXRUb0JvdW5kcyB8fCBjZW50ZXJab29tZWRPdXQpLCB4ID0gX2QueCwgeSA9IF9kLnk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICBwb3NpdGlvblg6IHhDaGFuZ2VkID8geCA6IHBvc2l0aW9uWCxcbiAgICAgICAgcG9zaXRpb25ZOiB5Q2hhbmdlZCA/IHkgOiBwb3NpdGlvblksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU5ld1Bvc2l0aW9uKGNvbnRleHRJbnN0YW5jZSwgbmV3UG9zaXRpb25YLCBuZXdQb3NpdGlvblksIHBhZGRpbmdWYWx1ZVgsIHBhZGRpbmdWYWx1ZVkpIHtcbiAgICB2YXIgbGltaXRUb0JvdW5kcyA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5saW1pdFRvQm91bmRzO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGJvdW5kcyA9IGNvbnRleHRJbnN0YW5jZS5ib3VuZHM7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBzY2FsZSA9IF9hLnNjYWxlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICBpZiAod3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fFxuICAgICAgICBib3VuZHMgPT09IG51bGwgfHxcbiAgICAgICAgKG5ld1Bvc2l0aW9uWCA9PT0gcG9zaXRpb25YICYmIG5ld1Bvc2l0aW9uWSA9PT0gcG9zaXRpb25ZKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfYiA9IGdldE1vdXNlQm91bmRlZFBvc2l0aW9uKG5ld1Bvc2l0aW9uWCwgbmV3UG9zaXRpb25ZLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMsIHBhZGRpbmdWYWx1ZVgsIHBhZGRpbmdWYWx1ZVksIHdyYXBwZXJDb21wb25lbnQpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgY29udGV4dEluc3RhbmNlLnNldFRyYW5zZm9ybVN0YXRlKHNjYWxlLCB4LCB5KTtcbn1cbnZhciBnZXRQYW5uaW5nQ2xpZW50UG9zaXRpb24gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIHN0YXJ0Q29vcmRzID0gY29udGV4dEluc3RhbmNlLnN0YXJ0Q29vcmRzLCB0cmFuc2Zvcm1TdGF0ZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgcGFubmluZyA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5wYW5uaW5nO1xuICAgIHZhciBsb2NrQXhpc1ggPSBwYW5uaW5nLmxvY2tBeGlzWCwgbG9ja0F4aXNZID0gcGFubmluZy5sb2NrQXhpc1k7XG4gICAgdmFyIHBvc2l0aW9uWCA9IHRyYW5zZm9ybVN0YXRlLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gdHJhbnNmb3JtU3RhdGUucG9zaXRpb25ZO1xuICAgIGlmICghc3RhcnRDb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogcG9zaXRpb25YLCB5OiBwb3NpdGlvblkgfTtcbiAgICB9XG4gICAgdmFyIG1vdXNlWCA9IGNsaWVudFggLSBzdGFydENvb3Jkcy54O1xuICAgIHZhciBtb3VzZVkgPSBjbGllbnRZIC0gc3RhcnRDb29yZHMueTtcbiAgICB2YXIgbmV3UG9zaXRpb25YID0gbG9ja0F4aXNYID8gcG9zaXRpb25YIDogbW91c2VYO1xuICAgIHZhciBuZXdQb3NpdGlvblkgPSBsb2NrQXhpc1kgPyBwb3NpdGlvblkgOiBtb3VzZVk7XG4gICAgcmV0dXJuIHsgeDogbmV3UG9zaXRpb25YLCB5OiBuZXdQb3NpdGlvblkgfTtcbn07XG52YXIgZ2V0UGFkZGluZ1ZhbHVlID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgc2l6ZSkge1xuICAgIHZhciBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIHNjYWxlID0gdHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIG1pblNjYWxlID0gc2V0dXAubWluU2NhbGUsIGRpc2FibGVQYWRkaW5nID0gc2V0dXAuZGlzYWJsZVBhZGRpbmc7XG4gICAgaWYgKHNpemUgPiAwICYmIHNjYWxlID49IG1pblNjYWxlICYmICFkaXNhYmxlUGFkZGluZykge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG52YXIgaXNWZWxvY2l0eUNhbGN1bGF0aW9uQWxsb3dlZCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgbW91bnRlZCA9IGNvbnRleHRJbnN0YW5jZS5tb3VudGVkO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgdmVsb2NpdHlBbmltYXRpb24gPSBfYS52ZWxvY2l0eUFuaW1hdGlvbjtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGRpc2FibGVkVmVsb2NpdHkgPSB2ZWxvY2l0eUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICB2YXIgaXNBbGxvd2VkID0gIWRpc2FibGVkVmVsb2NpdHkgfHwgc2NhbGUgPiAxIHx8ICFkaXNhYmxlZCB8fCBtb3VudGVkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzVmVsb2NpdHlBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBtb3VudGVkID0gY29udGV4dEluc3RhbmNlLm1vdW50ZWQsIHZlbG9jaXR5ID0gY29udGV4dEluc3RhbmNlLnZlbG9jaXR5LCBib3VuZHMgPSBjb250ZXh0SW5zdGFuY2UuYm91bmRzO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgdmVsb2NpdHlBbmltYXRpb24gPSBfYS52ZWxvY2l0eUFuaW1hdGlvbjtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGRpc2FibGVkVmVsb2NpdHkgPSB2ZWxvY2l0eUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICB2YXIgaXNBbGxvd2VkID0gIWRpc2FibGVkVmVsb2NpdHkgfHwgc2NhbGUgPiAxIHx8ICFkaXNhYmxlZCB8fCBtb3VudGVkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2ZWxvY2l0eSB8fCAhYm91bmRzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZ2V0VmVsb2NpdHlNb3ZlVGltZShjb250ZXh0SW5zdGFuY2UsIHZlbG9jaXR5KSB7XG4gICAgdmFyIHZlbG9jaXR5QW5pbWF0aW9uID0gY29udGV4dEluc3RhbmNlLnNldHVwLnZlbG9jaXR5QW5pbWF0aW9uO1xuICAgIHZhciBlcXVhbFRvTW92ZSA9IHZlbG9jaXR5QW5pbWF0aW9uLmVxdWFsVG9Nb3ZlLCBhbmltYXRpb25UaW1lID0gdmVsb2NpdHlBbmltYXRpb24uYW5pbWF0aW9uVGltZSwgc2Vuc2l0aXZpdHkgPSB2ZWxvY2l0eUFuaW1hdGlvbi5zZW5zaXRpdml0eTtcbiAgICBpZiAoZXF1YWxUb01vdmUpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvblRpbWUgKiB2ZWxvY2l0eSAqIHNlbnNpdGl2aXR5O1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uVGltZTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5UG9zaXRpb24obmV3UG9zaXRpb24sIHN0YXJ0UG9zaXRpb24sIGN1cnJlbnRQb3NpdGlvbiwgaXNMb2NrZWQsIGxpbWl0VG9Cb3VuZHMsIG1pblBvc2l0aW9uLCBtYXhQb3NpdGlvbiwgbWluVGFyZ2V0LCBtYXhUYXJnZXQsIHN0ZXApIHtcbiAgICBpZiAobGltaXRUb0JvdW5kcykge1xuICAgICAgICBpZiAoc3RhcnRQb3NpdGlvbiA+IG1heFBvc2l0aW9uICYmIGN1cnJlbnRQb3NpdGlvbiA+IG1heFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZFBvc2l0aW9uID0gbWF4UG9zaXRpb24gKyAobmV3UG9zaXRpb24gLSBtYXhQb3NpdGlvbikgKiBzdGVwO1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRQb3NpdGlvbiA+IG1heFRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4VGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGNhbGN1bGF0ZWRQb3NpdGlvbiA8IG1heFBvc2l0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBtYXhQb3NpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBtaW5Qb3NpdGlvbiAmJiBjdXJyZW50UG9zaXRpb24gPCBtaW5Qb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvbiA9IG1pblBvc2l0aW9uICsgKG5ld1Bvc2l0aW9uIC0gbWluUG9zaXRpb24pICogc3RlcDtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkUG9zaXRpb24gPCBtaW5UYXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pblRhcmdldDtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkUG9zaXRpb24gPiBtaW5Qb3NpdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbWluUG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0xvY2tlZClcbiAgICAgICAgcmV0dXJuIHN0YXJ0UG9zaXRpb247XG4gICAgcmV0dXJuIGJvdW5kTGltaXRlcihuZXdQb3NpdGlvbiwgbWluUG9zaXRpb24sIG1heFBvc2l0aW9uLCBsaW1pdFRvQm91bmRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZU11bHRpcGxpZXIod3JhcHBlckNvbXBvbmVudCwgZXF1YWxUb01vdmUpIHtcbiAgICB2YXIgZGVmYXVsdE11bHRpcGxpZXIgPSAxO1xuICAgIGlmIChlcXVhbFRvTW92ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oZGVmYXVsdE11bHRpcGxpZXIsIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGggLyB3aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0TXVsdGlwbGllcjtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNhbGN1bGF0ZVZlbG9jaXR5KGNvbnRleHRJbnN0YW5jZSwgcG9zaXRpb24pIHtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNWZWxvY2l0eUNhbGN1bGF0aW9uQWxsb3dlZChjb250ZXh0SW5zdGFuY2UpO1xuICAgIGlmICghaXNBbGxvd2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhc3RNb3VzZVBvc2l0aW9uID0gY29udGV4dEluc3RhbmNlLmxhc3RNb3VzZVBvc2l0aW9uLCB2ZWxvY2l0eVRpbWUgPSBjb250ZXh0SW5zdGFuY2UudmVsb2NpdHlUaW1lLCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cDtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBlcXVhbFRvTW92ZSA9IHNldHVwLnZlbG9jaXR5QW5pbWF0aW9uLmVxdWFsVG9Nb3ZlO1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChsYXN0TW91c2VQb3NpdGlvbiAmJiB2ZWxvY2l0eVRpbWUgJiYgd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICB2YXIgc2l6ZU11bHRpcGxpZXIgPSBnZXRTaXplTXVsdGlwbGllcih3cmFwcGVyQ29tcG9uZW50LCBlcXVhbFRvTW92ZSk7XG4gICAgICAgIHZhciBkaXN0YW5jZVggPSBwb3NpdGlvbi54IC0gbGFzdE1vdXNlUG9zaXRpb24ueDtcbiAgICAgICAgdmFyIGRpc3RhbmNlWSA9IHBvc2l0aW9uLnkgLSBsYXN0TW91c2VQb3NpdGlvbi55O1xuICAgICAgICB2YXIgdmVsb2NpdHlYID0gZGlzdGFuY2VYIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgICAgIHZhciB2ZWxvY2l0eVkgPSBkaXN0YW5jZVkgLyBzaXplTXVsdGlwbGllcjtcbiAgICAgICAgdmFyIGludGVydmFsID0gbm93IC0gdmVsb2NpdHlUaW1lO1xuICAgICAgICB2YXIgc3BlZWQgPSBkaXN0YW5jZVggKiBkaXN0YW5jZVggKyBkaXN0YW5jZVkgKiBkaXN0YW5jZVk7XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IE1hdGguc3FydChzcGVlZCkgLyBpbnRlcnZhbDtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLnZlbG9jaXR5ID0geyB2ZWxvY2l0eVg6IHZlbG9jaXR5WCwgdmVsb2NpdHlZOiB2ZWxvY2l0eVksIHRvdGFsOiB2ZWxvY2l0eSB9O1xuICAgIH1cbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdE1vdXNlUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBjb250ZXh0SW5zdGFuY2UudmVsb2NpdHlUaW1lID0gbm93O1xufVxuZnVuY3Rpb24gaGFuZGxlVmVsb2NpdHlQYW5uaW5nKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciB2ZWxvY2l0eSA9IGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSwgYm91bmRzID0gY29udGV4dEluc3RhbmNlLmJvdW5kcywgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgaXNBbGxvd2VkID0gaXNWZWxvY2l0eUFsbG93ZWQoY29udGV4dEluc3RhbmNlKTtcbiAgICBpZiAoIWlzQWxsb3dlZCB8fCAhdmVsb2NpdHkgfHwgIWJvdW5kcyB8fCAhd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2ZWxvY2l0eVggPSB2ZWxvY2l0eS52ZWxvY2l0eVgsIHZlbG9jaXR5WSA9IHZlbG9jaXR5LnZlbG9jaXR5WSwgdG90YWwgPSB2ZWxvY2l0eS50b3RhbDtcbiAgICB2YXIgbWF4UG9zaXRpb25YID0gYm91bmRzLm1heFBvc2l0aW9uWCwgbWluUG9zaXRpb25YID0gYm91bmRzLm1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25ZID0gYm91bmRzLm1heFBvc2l0aW9uWSwgbWluUG9zaXRpb25ZID0gYm91bmRzLm1pblBvc2l0aW9uWTtcbiAgICB2YXIgbGltaXRUb0JvdW5kcyA9IHNldHVwLmxpbWl0VG9Cb3VuZHMsIGFsaWdubWVudEFuaW1hdGlvbiA9IHNldHVwLmFsaWdubWVudEFuaW1hdGlvbjtcbiAgICB2YXIgem9vbUFuaW1hdGlvbiA9IHNldHVwLnpvb21BbmltYXRpb24sIHBhbm5pbmcgPSBzZXR1cC5wYW5uaW5nO1xuICAgIHZhciBsb2NrQXhpc1kgPSBwYW5uaW5nLmxvY2tBeGlzWSwgbG9ja0F4aXNYID0gcGFubmluZy5sb2NrQXhpc1g7XG4gICAgdmFyIGFuaW1hdGlvblR5cGUgPSB6b29tQW5pbWF0aW9uLmFuaW1hdGlvblR5cGU7XG4gICAgdmFyIHNpemVYID0gYWxpZ25tZW50QW5pbWF0aW9uLnNpemVYLCBzaXplWSA9IGFsaWdubWVudEFuaW1hdGlvbi5zaXplWSwgdmVsb2NpdHlBbGlnbm1lbnRUaW1lID0gYWxpZ25tZW50QW5pbWF0aW9uLnZlbG9jaXR5QWxpZ25tZW50VGltZTtcbiAgICB2YXIgYWxpZ25BbmltYXRpb25UaW1lID0gdmVsb2NpdHlBbGlnbm1lbnRUaW1lO1xuICAgIHZhciBtb3ZlQW5pbWF0aW9uVGltZSA9IGdldFZlbG9jaXR5TW92ZVRpbWUoY29udGV4dEluc3RhbmNlLCB0b3RhbCk7XG4gICAgdmFyIGZpbmFsQW5pbWF0aW9uVGltZSA9IE1hdGgubWF4KG1vdmVBbmltYXRpb25UaW1lLCBhbGlnbkFuaW1hdGlvblRpbWUpO1xuICAgIHZhciBwYWRkaW5nVmFsdWVYID0gZ2V0UGFkZGluZ1ZhbHVlKGNvbnRleHRJbnN0YW5jZSwgc2l6ZVgpO1xuICAgIHZhciBwYWRkaW5nVmFsdWVZID0gZ2V0UGFkZGluZ1ZhbHVlKGNvbnRleHRJbnN0YW5jZSwgc2l6ZVkpO1xuICAgIHZhciBwYWRkaW5nWCA9IChwYWRkaW5nVmFsdWVYICogd3JhcHBlckNvbXBvbmVudC5vZmZzZXRXaWR0aCkgLyAxMDA7XG4gICAgdmFyIHBhZGRpbmdZID0gKHBhZGRpbmdWYWx1ZVkgKiB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCkgLyAxMDA7XG4gICAgdmFyIG1heFRhcmdldFggPSBtYXhQb3NpdGlvblggKyBwYWRkaW5nWDtcbiAgICB2YXIgbWluVGFyZ2V0WCA9IG1pblBvc2l0aW9uWCAtIHBhZGRpbmdYO1xuICAgIHZhciBtYXhUYXJnZXRZID0gbWF4UG9zaXRpb25ZICsgcGFkZGluZ1k7XG4gICAgdmFyIG1pblRhcmdldFkgPSBtaW5Qb3NpdGlvblkgLSBwYWRkaW5nWTtcbiAgICB2YXIgc3RhcnRTdGF0ZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaGFuZGxlU2V0dXBBbmltYXRpb24oY29udGV4dEluc3RhbmNlLCBhbmltYXRpb25UeXBlLCBmaW5hbEFuaW1hdGlvblRpbWUsIGZ1bmN0aW9uIChzdGVwKSB7XG4gICAgICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgICAgIHZhciBmcmFtZVRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcbiAgICAgICAgdmFyIGFuaW1hdGlvblByb2dyZXNzID0gZnJhbWVUaW1lIC8gYWxpZ25BbmltYXRpb25UaW1lO1xuICAgICAgICB2YXIgYWxpZ25BbmltYXRpb24gPSBhbmltYXRpb25zW2FsaWdubWVudEFuaW1hdGlvbi5hbmltYXRpb25UeXBlXTtcbiAgICAgICAgdmFyIGFsaWduU3RlcCA9IDEgLSBhbGlnbkFuaW1hdGlvbihNYXRoLm1pbigxLCBhbmltYXRpb25Qcm9ncmVzcykpO1xuICAgICAgICB2YXIgY3VzdG9tU3RlcCA9IDEgLSBzdGVwO1xuICAgICAgICB2YXIgbmV3UG9zaXRpb25YID0gcG9zaXRpb25YICsgdmVsb2NpdHlYICogY3VzdG9tU3RlcDtcbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9uWSA9IHBvc2l0aW9uWSArIHZlbG9jaXR5WSAqIGN1c3RvbVN0ZXA7XG4gICAgICAgIHZhciBjdXJyZW50UG9zaXRpb25YID0gZ2V0VmVsb2NpdHlQb3NpdGlvbihuZXdQb3NpdGlvblgsIHN0YXJ0U3RhdGUucG9zaXRpb25YLCBwb3NpdGlvblgsIGxvY2tBeGlzWCwgbGltaXRUb0JvdW5kcywgbWluUG9zaXRpb25YLCBtYXhQb3NpdGlvblgsIG1pblRhcmdldFgsIG1heFRhcmdldFgsIGFsaWduU3RlcCk7XG4gICAgICAgIHZhciBjdXJyZW50UG9zaXRpb25ZID0gZ2V0VmVsb2NpdHlQb3NpdGlvbihuZXdQb3NpdGlvblksIHN0YXJ0U3RhdGUucG9zaXRpb25ZLCBwb3NpdGlvblksIGxvY2tBeGlzWSwgbGltaXRUb0JvdW5kcywgbWluUG9zaXRpb25ZLCBtYXhQb3NpdGlvblksIG1pblRhcmdldFksIG1heFRhcmdldFksIGFsaWduU3RlcCk7XG4gICAgICAgIGlmIChwb3NpdGlvblggIT09IG5ld1Bvc2l0aW9uWCB8fCBwb3NpdGlvblkgIT09IG5ld1Bvc2l0aW9uWSkge1xuICAgICAgICAgICAgY29udGV4dEluc3RhbmNlLnNldFRyYW5zZm9ybVN0YXRlKHNjYWxlLCBjdXJyZW50UG9zaXRpb25YLCBjdXJyZW50UG9zaXRpb25ZKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVQYW5uaW5nU3RhcnQoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oY29udGV4dEluc3RhbmNlKTtcbiAgICBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBzY2FsZSk7XG4gICAgaWYgKHdpbmRvdy5Ub3VjaEV2ZW50ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgIGhhbmRsZVRvdWNoUGFubmluZ1NldHVwKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaGFuZGxlUGFubmluZ1NldHVwKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUFsaWduVG9Cb3VuZHMoY29udGV4dEluc3RhbmNlLCBjdXN0b21BbmltYXRpb25UaW1lKSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgbWluU2NhbGUgPSBfYS5taW5TY2FsZSwgYWxpZ25tZW50QW5pbWF0aW9uID0gX2EuYWxpZ25tZW50QW5pbWF0aW9uO1xuICAgIHZhciBkaXNhYmxlZCA9IGFsaWdubWVudEFuaW1hdGlvbi5kaXNhYmxlZCwgc2l6ZVggPSBhbGlnbm1lbnRBbmltYXRpb24uc2l6ZVgsIHNpemVZID0gYWxpZ25tZW50QW5pbWF0aW9uLnNpemVZLCBhbmltYXRpb25UaW1lID0gYWxpZ25tZW50QW5pbWF0aW9uLmFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUgPSBhbGlnbm1lbnRBbmltYXRpb24uYW5pbWF0aW9uVHlwZTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8IHNjYWxlIDwgbWluU2NhbGUgfHwgKCFzaXplWCAmJiAhc2l6ZVkpO1xuICAgIGlmIChpc0Rpc2FibGVkKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHRhcmdldFN0YXRlID0gaGFuZGxlUGFuVG9Cb3VuZHMoY29udGV4dEluc3RhbmNlKTtcbiAgICBpZiAodGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBjdXN0b21BbmltYXRpb25UaW1lICE9PSBudWxsICYmIGN1c3RvbUFuaW1hdGlvblRpbWUgIT09IHZvaWQgMCA/IGN1c3RvbUFuaW1hdGlvblRpbWUgOiBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVQYW5uaW5nKGNvbnRleHRJbnN0YW5jZSwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciBzdGFydENvb3JkcyA9IGNvbnRleHRJbnN0YW5jZS5zdGFydENvb3Jkcywgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXA7XG4gICAgdmFyIF9hID0gc2V0dXAuYWxpZ25tZW50QW5pbWF0aW9uLCBzaXplWCA9IF9hLnNpemVYLCBzaXplWSA9IF9hLnNpemVZO1xuICAgIGlmICghc3RhcnRDb29yZHMpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgX2IgPSBnZXRQYW5uaW5nQ2xpZW50UG9zaXRpb24oY29udGV4dEluc3RhbmNlLCBjbGllbnRYLCBjbGllbnRZKSwgeCA9IF9iLngsIHkgPSBfYi55O1xuICAgIHZhciBwYWRkaW5nVmFsdWVYID0gZ2V0UGFkZGluZ1ZhbHVlKGNvbnRleHRJbnN0YW5jZSwgc2l6ZVgpO1xuICAgIHZhciBwYWRkaW5nVmFsdWVZID0gZ2V0UGFkZGluZ1ZhbHVlKGNvbnRleHRJbnN0YW5jZSwgc2l6ZVkpO1xuICAgIGhhbmRsZUNhbGN1bGF0ZVZlbG9jaXR5KGNvbnRleHRJbnN0YW5jZSwgeyB4OiB4LCB5OiB5IH0pO1xuICAgIGhhbmRsZU5ld1Bvc2l0aW9uKGNvbnRleHRJbnN0YW5jZSwgeCwgeSwgcGFkZGluZ1ZhbHVlWCwgcGFkZGluZ1ZhbHVlWSk7XG59XG5mdW5jdGlvbiBoYW5kbGVQYW5uaW5nRW5kKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIGlmIChjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nKSB7XG4gICAgICAgIHZhciB2ZWxvY2l0eURpc2FibGVkID0gY29udGV4dEluc3RhbmNlLnNldHVwLnBhbm5pbmcudmVsb2NpdHlEaXNhYmxlZDtcbiAgICAgICAgdmFyIHZlbG9jaXR5ID0gY29udGV4dEluc3RhbmNlLnZlbG9jaXR5LCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLmlzUGFubmluZyA9IGZhbHNlO1xuICAgICAgICBjb250ZXh0SW5zdGFuY2UuYW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICBjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdmFyIHdyYXBwZXJSZWN0ID0gd3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fCB3cmFwcGVyQ29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyQ29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50Q29tcG9uZW50ID09PSBudWxsIHx8IGNvbnRlbnRDb21wb25lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRDb21wb25lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB3cmFwcGVyV2lkdGggPSAod3JhcHBlclJlY3QgPT09IG51bGwgfHwgd3JhcHBlclJlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdyYXBwZXJSZWN0LndpZHRoKSB8fCAwO1xuICAgICAgICB2YXIgd3JhcHBlckhlaWdodCA9ICh3cmFwcGVyUmVjdCA9PT0gbnVsbCB8fCB3cmFwcGVyUmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd3JhcHBlclJlY3QuaGVpZ2h0KSB8fCAwO1xuICAgICAgICB2YXIgY29udGVudFdpZHRoID0gKGNvbnRlbnRSZWN0ID09PSBudWxsIHx8IGNvbnRlbnRSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50UmVjdC53aWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIGNvbnRlbnRIZWlnaHQgPSAoY29udGVudFJlY3QgPT09IG51bGwgfHwgY29udGVudFJlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRlbnRSZWN0LmhlaWdodCkgfHwgMDtcbiAgICAgICAgdmFyIGlzWm9vbWVkID0gd3JhcHBlcldpZHRoIDwgY29udGVudFdpZHRoIHx8IHdyYXBwZXJIZWlnaHQgPCBjb250ZW50SGVpZ2h0O1xuICAgICAgICB2YXIgc2hvdWxkQW5pbWF0ZSA9ICF2ZWxvY2l0eURpc2FibGVkICYmIHZlbG9jaXR5ICYmICh2ZWxvY2l0eSA9PT0gbnVsbCB8fCB2ZWxvY2l0eSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmVsb2NpdHkudG90YWwpID4gMC4xICYmIGlzWm9vbWVkO1xuICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZSkge1xuICAgICAgICAgICAgaGFuZGxlVmVsb2NpdHlQYW5uaW5nKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVBbGlnblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgc2NhbGUsIG1vdXNlWCwgbW91c2VZKSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBtaW5TY2FsZSA9IF9hLm1pblNjYWxlLCBtYXhTY2FsZSA9IF9hLm1heFNjYWxlLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcztcbiAgICB2YXIgbmV3U2NhbGUgPSBjaGVja1pvb21Cb3VuZHMocm91bmROdW1iZXIoc2NhbGUsIDIpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIDAsIGZhbHNlKTtcbiAgICB2YXIgYm91bmRzID0gaGFuZGxlQ2FsY3VsYXRlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUpO1xuICAgIHZhciBfYiA9IGhhbmRsZUNhbGN1bGF0ZVpvb21Qb3NpdGlvbnMoY29udGV4dEluc3RhbmNlLCBtb3VzZVgsIG1vdXNlWSwgbmV3U2NhbGUsIGJvdW5kcywgbGltaXRUb0JvdW5kcyksIHggPSBfYi54LCB5ID0gX2IueTtcbiAgICByZXR1cm4geyBzY2FsZTogbmV3U2NhbGUsIHBvc2l0aW9uWDogeCwgcG9zaXRpb25ZOiB5IH07XG59XG5mdW5jdGlvbiBoYW5kbGVBbGlnblRvU2NhbGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBtb3VzZVBvc2l0aW9uWCwgbW91c2VQb3NpdGlvblkpIHtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIG1pblNjYWxlID0gX2EubWluU2NhbGUsIGxpbWl0VG9Cb3VuZHMgPSBfYS5saW1pdFRvQm91bmRzLCB6b29tQW5pbWF0aW9uID0gX2Euem9vbUFuaW1hdGlvbjtcbiAgICB2YXIgZGlzYWJsZWQgPSB6b29tQW5pbWF0aW9uLmRpc2FibGVkLCBhbmltYXRpb25UaW1lID0gem9vbUFuaW1hdGlvbi5hbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlID0gem9vbUFuaW1hdGlvbi5hbmltYXRpb25UeXBlO1xuICAgIHZhciBpc0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgc2NhbGUgPj0gbWluU2NhbGU7XG4gICAgaWYgKHNjYWxlID49IDEgfHwgbGltaXRUb0JvdW5kcykge1xuICAgICAgICAvLyBmaXJlIGZpdCB0byBib3VuZHMgYW5pbWF0aW9uXG4gICAgICAgIGhhbmRsZUFsaWduVG9Cb3VuZHMoY29udGV4dEluc3RhbmNlKTtcbiAgICB9XG4gICAgaWYgKGlzRGlzYWJsZWQgfHwgIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRleHRJbnN0YW5jZS5tb3VudGVkKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG1vdXNlWCA9IG1vdXNlUG9zaXRpb25YIHx8IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgIHZhciBtb3VzZVkgPSBtb3VzZVBvc2l0aW9uWSB8fCB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCAvIDI7XG4gICAgdmFyIHRhcmdldFN0YXRlID0gaGFuZGxlWm9vbVRvUG9pbnQoY29udGV4dEluc3RhbmNlLCBtaW5TY2FsZSwgbW91c2VYLCBtb3VzZVkpO1xuICAgIGlmICh0YXJnZXRTdGF0ZSkge1xuICAgICAgICBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBwcmV2aW91c1NjYWxlOiAxLFxuICAgIHNjYWxlOiAxLFxuICAgIHBvc2l0aW9uWDogMCxcbiAgICBwb3NpdGlvblk6IDAsXG59O1xudmFyIGluaXRpYWxTZXR1cCA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgbWluUG9zaXRpb25YOiBudWxsLFxuICAgIG1heFBvc2l0aW9uWDogbnVsbCxcbiAgICBtaW5Qb3NpdGlvblk6IG51bGwsXG4gICAgbWF4UG9zaXRpb25ZOiBudWxsLFxuICAgIG1pblNjYWxlOiAxLFxuICAgIG1heFNjYWxlOiA4LFxuICAgIGxpbWl0VG9Cb3VuZHM6IHRydWUsXG4gICAgY2VudGVyWm9vbWVkT3V0OiBmYWxzZSxcbiAgICBjZW50ZXJPbkluaXQ6IGZhbHNlLFxuICAgIGRpc2FibGVQYWRkaW5nOiBmYWxzZSxcbiAgICBzbW9vdGg6IHRydWUsXG4gICAgd2hlZWw6IHtcbiAgICAgICAgc3RlcDogMC4yLFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHNtb290aFN0ZXA6IDAuMDAxLFxuICAgICAgICB3aGVlbERpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgdG91Y2hQYWREaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGFjdGl2YXRpb25LZXlzOiBbXSxcbiAgICAgICAgZXhjbHVkZWQ6IFtdLFxuICAgIH0sXG4gICAgcGFubmluZzoge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHZlbG9jaXR5RGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBsb2NrQXhpc1g6IGZhbHNlLFxuICAgICAgICBsb2NrQXhpc1k6IGZhbHNlLFxuICAgICAgICBhbGxvd0xlZnRDbGlja1BhbjogdHJ1ZSxcbiAgICAgICAgYWxsb3dNaWRkbGVDbGlja1BhbjogdHJ1ZSxcbiAgICAgICAgYWxsb3dSaWdodENsaWNrUGFuOiB0cnVlLFxuICAgICAgICB3aGVlbFBhbm5pbmc6IGZhbHNlLFxuICAgICAgICBhY3RpdmF0aW9uS2V5czogW10sXG4gICAgICAgIGV4Y2x1ZGVkOiBbXSxcbiAgICB9LFxuICAgIHBpbmNoOiB7XG4gICAgICAgIHN0ZXA6IDUsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZXhjbHVkZWQ6IFtdLFxuICAgIH0sXG4gICAgZG91YmxlQ2xpY2s6IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzdGVwOiAwLjcsXG4gICAgICAgIG1vZGU6IFwiem9vbUluXCIsXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IFwiZWFzZU91dFwiLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAyMDAsXG4gICAgICAgIGV4Y2x1ZGVkOiBbXSxcbiAgICB9LFxuICAgIHpvb21BbmltYXRpb246IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzaXplOiAwLjQsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDIwMCxcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogXCJlYXNlT3V0XCIsXG4gICAgfSxcbiAgICBhbGlnbm1lbnRBbmltYXRpb246IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzaXplWDogMTAwLFxuICAgICAgICBzaXplWTogMTAwLFxuICAgICAgICBhbmltYXRpb25UaW1lOiAyMDAsXG4gICAgICAgIHZlbG9jaXR5QWxpZ25tZW50VGltZTogNDAwLFxuICAgICAgICBhbmltYXRpb25UeXBlOiBcImVhc2VPdXRcIixcbiAgICB9LFxuICAgIHZlbG9jaXR5QW5pbWF0aW9uOiB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc2Vuc2l0aXZpdHk6IDEsXG4gICAgICAgIGFuaW1hdGlvblRpbWU6IDQwMCxcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogXCJlYXNlT3V0XCIsXG4gICAgICAgIGVxdWFsVG9Nb3ZlOiB0cnVlLFxuICAgIH0sXG59O1xudmFyIGJhc2VDbGFzc2VzID0ge1xuICAgIHdyYXBwZXJDbGFzczogXCJyZWFjdC10cmFuc2Zvcm0td3JhcHBlclwiLFxuICAgIGNvbnRlbnRDbGFzczogXCJyZWFjdC10cmFuc2Zvcm0tY29tcG9uZW50XCIsXG59O1xuXG52YXIgY3JlYXRlU3RhdGUgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJldmlvdXNTY2FsZTogKF9hID0gcHJvcHMuaW5pdGlhbFNjYWxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbml0aWFsU3RhdGUuc2NhbGUsXG4gICAgICAgIHNjYWxlOiAoX2IgPSBwcm9wcy5pbml0aWFsU2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGluaXRpYWxTdGF0ZS5zY2FsZSxcbiAgICAgICAgcG9zaXRpb25YOiAoX2MgPSBwcm9wcy5pbml0aWFsUG9zaXRpb25YKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBpbml0aWFsU3RhdGUucG9zaXRpb25YLFxuICAgICAgICBwb3NpdGlvblk6IChfZCA9IHByb3BzLmluaXRpYWxQb3NpdGlvblkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGluaXRpYWxTdGF0ZS5wb3NpdGlvblksXG4gICAgfTtcbn07XG52YXIgY3JlYXRlU2V0dXAgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB2YXIgbmV3U2V0dXAgPSBfX2Fzc2lnbih7fSwgaW5pdGlhbFNldHVwKTtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB2YWxpZFZhbHVlID0gdHlwZW9mIHByb3BzW2tleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIHZhciB2YWxpZFBhcmFtZXRlciA9IHR5cGVvZiBpbml0aWFsU2V0dXBba2V5XSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgaWYgKHZhbGlkUGFyYW1ldGVyICYmIHZhbGlkVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhVHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbml0aWFsU2V0dXBba2V5XSk7XG4gICAgICAgICAgICB2YXIgaXNPYmplY3QgPSBkYXRhVHlwZSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gZGF0YVR5cGUgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCkge1xuICAgICAgICAgICAgICAgIG5ld1NldHVwW2tleV0gPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaW5pdGlhbFNldHVwW2tleV0pLCBwcm9wc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXR1cFtrZXldID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBpbml0aWFsU2V0dXBba2V5XSwgdHJ1ZSksIHByb3BzW2tleV0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2V0dXBba2V5XSA9IHByb3BzW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3U2V0dXA7XG59O1xuXG52YXIgaGFuZGxlQ2FsY3VsYXRlQnV0dG9uWm9vbSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwKSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBtYXhTY2FsZSA9IHNldHVwLm1heFNjYWxlLCBtaW5TY2FsZSA9IHNldHVwLm1pblNjYWxlLCB6b29tQW5pbWF0aW9uID0gc2V0dXAuem9vbUFuaW1hdGlvbiwgc21vb3RoID0gc2V0dXAuc21vb3RoO1xuICAgIHZhciBzaXplID0gem9vbUFuaW1hdGlvbi5zaXplO1xuICAgIGlmICghd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcmFwcGVyIGlzIG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0U2NhbGUgPSBzbW9vdGhcbiAgICAgICAgPyBzY2FsZSAqIE1hdGguZXhwKGRlbHRhICogc3RlcClcbiAgICAgICAgOiBzY2FsZSArIGRlbHRhICogc3RlcDtcbiAgICB2YXIgbmV3U2NhbGUgPSBjaGVja1pvb21Cb3VuZHMocm91bmROdW1iZXIodGFyZ2V0U2NhbGUsIDMpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIHNpemUsIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3U2NhbGU7XG59O1xuZnVuY3Rpb24gaGFuZGxlWm9vbVRvVmlld0NlbnRlcihjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKSB7XG4gICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHNjYWxlID0gX2Euc2NhbGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgIGlmICghd3JhcHBlckNvbXBvbmVudClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJObyBXcmFwcGVyQ29tcG9uZW50IGZvdW5kXCIpO1xuICAgIHZhciB3cmFwcGVyV2lkdGggPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciB3cmFwcGVySGVpZ2h0ID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG1vdXNlWCA9ICh3cmFwcGVyV2lkdGggLyAyIC0gcG9zaXRpb25YKSAvIHNjYWxlO1xuICAgIHZhciBtb3VzZVkgPSAod3JhcHBlckhlaWdodCAvIDIgLSBwb3NpdGlvblkpIC8gc2NhbGU7XG4gICAgdmFyIG5ld1NjYWxlID0gaGFuZGxlQ2FsY3VsYXRlQnV0dG9uWm9vbShjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwKTtcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSBoYW5kbGVab29tVG9Qb2ludChjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlLCBtb3VzZVgsIG1vdXNlWSk7XG4gICAgaWYgKCF0YXJnZXRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyB6b29tIGV2ZW50LiBOZXcgdHJhbnNmb3JtYXRpb24gc3RhdGUgd2FzIG5vdCBjYWxjdWxhdGVkLlwiKTtcbiAgICB9XG4gICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtYXRpb25zKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSwgb25SZXNldFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgdmFyIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBzZXR1cC5saW1pdFRvQm91bmRzO1xuICAgIHZhciBpbml0aWFsVHJhbnNmb3JtYXRpb24gPSBjcmVhdGVTdGF0ZShjb250ZXh0SW5zdGFuY2UucHJvcHMpO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgaWYgKCF3cmFwcGVyQ29tcG9uZW50KVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG5ld0JvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIGluaXRpYWxUcmFuc2Zvcm1hdGlvbi5zY2FsZSk7XG4gICAgdmFyIGJvdW5kZWRQb3NpdGlvbnMgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25YLCBpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25ZLCBuZXdCb3VuZHMsIGxpbWl0VG9Cb3VuZHMsIDAsIDAsIHdyYXBwZXJDb21wb25lbnQpO1xuICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgc2NhbGU6IGluaXRpYWxUcmFuc2Zvcm1hdGlvbi5zY2FsZSxcbiAgICAgICAgcG9zaXRpb25YOiBib3VuZGVkUG9zaXRpb25zLngsXG4gICAgICAgIHBvc2l0aW9uWTogYm91bmRlZFBvc2l0aW9ucy55LFxuICAgIH07XG4gICAgaWYgKHNjYWxlID09PSBpbml0aWFsVHJhbnNmb3JtYXRpb24uc2NhbGUgJiZcbiAgICAgICAgcG9zaXRpb25YID09PSBpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25YICYmXG4gICAgICAgIHBvc2l0aW9uWSA9PT0gaW5pdGlhbFRyYW5zZm9ybWF0aW9uLnBvc2l0aW9uWSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uUmVzZXRUcmFuc2Zvcm1hdGlvbiA9PT0gbnVsbCB8fCBvblJlc2V0VHJhbnNmb3JtYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUmVzZXRUcmFuc2Zvcm1hdGlvbigpO1xuICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCBuZXdTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCwgd3JhcHBlciwgY29udGVudCwgc3RhdGUpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgd3JhcHBlck9mZnNldCA9IHdyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNvbnRlbnRPZmZzZXQgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciB4T2ZmID0gd3JhcHBlck9mZnNldC54ICogc3RhdGUuc2NhbGU7XG4gICAgdmFyIHlPZmYgPSB3cmFwcGVyT2Zmc2V0LnkgKiBzdGF0ZS5zY2FsZTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAob2Zmc2V0LnggLSBjb250ZW50T2Zmc2V0LnggKyB4T2ZmKSAvIHN0YXRlLnNjYWxlLFxuICAgICAgICB5OiAob2Zmc2V0LnkgLSBjb250ZW50T2Zmc2V0LnkgKyB5T2ZmKSAvIHN0YXRlLnNjYWxlLFxuICAgIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVab29tVG9Ob2RlKGNvbnRleHRJbnN0YW5jZSwgbm9kZSwgY3VzdG9tWm9vbSkge1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudCwgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcywgbWluU2NhbGUgPSBfYS5taW5TY2FsZSwgbWF4U2NhbGUgPSBfYS5tYXhTY2FsZTtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgd3JhcHBlclJlY3QgPSB3cmFwcGVyQ29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIG5vZGVPZmZzZXQgPSBnZXRPZmZzZXQobm9kZSwgd3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCwgdHJhbnNmb3JtU3RhdGUpO1xuICAgIHZhciBub2RlTGVmdCA9IG5vZGVPZmZzZXQueDtcbiAgICB2YXIgbm9kZVRvcCA9IG5vZGVPZmZzZXQueTtcbiAgICB2YXIgbm9kZVdpZHRoID0gbm9kZVJlY3Qud2lkdGggLyB0cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IG5vZGVSZWN0LmhlaWdodCAvIHRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBzY2FsZVggPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC8gbm9kZVdpZHRoO1xuICAgIHZhciBzY2FsZVkgPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCAvIG5vZGVIZWlnaHQ7XG4gICAgdmFyIG5ld1NjYWxlID0gY2hlY2tab29tQm91bmRzKGN1c3RvbVpvb20gfHwgTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIDAsIGZhbHNlKTtcbiAgICB2YXIgb2Zmc2V0WCA9ICh3cmFwcGVyUmVjdC53aWR0aCAtIG5vZGVXaWR0aCAqIG5ld1NjYWxlKSAvIDI7XG4gICAgdmFyIG9mZnNldFkgPSAod3JhcHBlclJlY3QuaGVpZ2h0IC0gbm9kZUhlaWdodCAqIG5ld1NjYWxlKSAvIDI7XG4gICAgdmFyIG5ld1Bvc2l0aW9uWCA9ICh3cmFwcGVyUmVjdC5sZWZ0IC0gbm9kZUxlZnQpICogbmV3U2NhbGUgKyBvZmZzZXRYO1xuICAgIHZhciBuZXdQb3NpdGlvblkgPSAod3JhcHBlclJlY3QudG9wIC0gbm9kZVRvcCkgKiBuZXdTY2FsZSArIG9mZnNldFk7XG4gICAgdmFyIGJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICB2YXIgX2IgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCAwLCAwLCB3cmFwcGVyQ29tcG9uZW50KSwgeCA9IF9iLngsIHkgPSBfYi55O1xuICAgIHJldHVybiB7IHBvc2l0aW9uWDogeCwgcG9zaXRpb25ZOiB5LCBzY2FsZTogbmV3U2NhbGUgfTtcbn1cblxudmFyIHpvb21JbiA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC41OyB9XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDMwMDsgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgICAgICBoYW5kbGVab29tVG9WaWV3Q2VudGVyKGNvbnRleHRJbnN0YW5jZSwgMSwgc3RlcCwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgfTtcbn07XG52YXIgem9vbU91dCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC41OyB9XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDMwMDsgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgICAgICBoYW5kbGVab29tVG9WaWV3Q2VudGVyKGNvbnRleHRJbnN0YW5jZSwgLTEsIHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH07XG59O1xudmFyIHNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5ld1Bvc2l0aW9uWCwgbmV3UG9zaXRpb25ZLCBuZXdTY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSAzMDA7IH1cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICAgICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWSwgc2NhbGUgPSBfYS5zY2FsZTtcbiAgICAgICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50O1xuICAgICAgICB2YXIgZGlzYWJsZWQgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgIGlmIChkaXNhYmxlZCB8fCAhd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGVudENvbXBvbmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldFN0YXRlID0ge1xuICAgICAgICAgICAgcG9zaXRpb25YOiBOdW1iZXIuaXNOYU4obmV3UG9zaXRpb25YKSA/IHBvc2l0aW9uWCA6IG5ld1Bvc2l0aW9uWCxcbiAgICAgICAgICAgIHBvc2l0aW9uWTogTnVtYmVyLmlzTmFOKG5ld1Bvc2l0aW9uWSkgPyBwb3NpdGlvblkgOiBuZXdQb3NpdGlvblksXG4gICAgICAgICAgICBzY2FsZTogTnVtYmVyLmlzTmFOKG5ld1NjYWxlKSA/IHNjYWxlIDogbmV3U2NhbGUsXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCB0YXJnZXRTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgfTtcbn07XG52YXIgcmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDIwMDsgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgICAgICByZXNldFRyYW5zZm9ybWF0aW9ucyhjb250ZXh0SW5zdGFuY2UsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH07XG59O1xudmFyIGNlbnRlclZpZXcgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSAyMDA7IH1cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICAgICAgdmFyIHRyYW5zZm9ybVN0YXRlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICAgICAgaWYgKHdyYXBwZXJDb21wb25lbnQgJiYgY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gZ2V0Q2VudGVyUG9zaXRpb24oc2NhbGUgfHwgdHJhbnNmb3JtU3RhdGUuc2NhbGUsIHdyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xudmFyIHpvb21Ub0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSA2MDA7IH1cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICAgICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUpIDogbm9kZTtcbiAgICAgICAgaWYgKHdyYXBwZXJDb21wb25lbnQgJiYgdGFyZ2V0ICYmIHdyYXBwZXJDb21wb25lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gY2FsY3VsYXRlWm9vbVRvTm9kZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldCwgc2NhbGUpO1xuICAgICAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgZ2V0Q29udHJvbHMgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2U6IGNvbnRleHRJbnN0YW5jZSxcbiAgICAgICAgem9vbUluOiB6b29tSW4oY29udGV4dEluc3RhbmNlKSxcbiAgICAgICAgem9vbU91dDogem9vbU91dChjb250ZXh0SW5zdGFuY2UpLFxuICAgICAgICBzZXRUcmFuc2Zvcm06IHNldFRyYW5zZm9ybShjb250ZXh0SW5zdGFuY2UpLFxuICAgICAgICByZXNldFRyYW5zZm9ybTogcmVzZXRUcmFuc2Zvcm0oY29udGV4dEluc3RhbmNlKSxcbiAgICAgICAgY2VudGVyVmlldzogY2VudGVyVmlldyhjb250ZXh0SW5zdGFuY2UpLFxuICAgICAgICB6b29tVG9FbGVtZW50OiB6b29tVG9FbGVtZW50KGNvbnRleHRJbnN0YW5jZSksXG4gICAgfTtcbn07XG52YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2U6IGNvbnRleHRJbnN0YW5jZSxcbiAgICAgICAgc3RhdGU6IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSxcbiAgICB9O1xufTtcbnZhciBnZXRDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciByZWYgPSB7fTtcbiAgICBPYmplY3QuYXNzaWduKHJlZiwgZ2V0U3RhdGUoY29udGV4dEluc3RhbmNlKSk7XG4gICAgT2JqZWN0LmFzc2lnbihyZWYsIGdldENvbnRyb2xzKGNvbnRleHRJbnN0YW5jZSkpO1xuICAgIHJldHVybiByZWY7XG59O1xuXG4vLyBXZSB3YW50IHRvIG1ha2UgZXZlbnQgbGlzdGVuZXJzIG5vbi1wYXNzaXZlLCBhbmQgdG8gZG8gc28gaGF2ZSB0byBjaGVja1xuLy8gdGhhdCBicm93c2VycyBzdXBwb3J0IEV2ZW50TGlzdGVuZXJPcHRpb25zIGluIHRoZSBmaXJzdCBwbGFjZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FdmVudFRhcmdldC9hZGRFdmVudExpc3RlbmVyI1NhZmVseV9kZXRlY3Rpbmdfb3B0aW9uX3N1cHBvcnRcbnZhciBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG5mdW5jdGlvbiBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gICBhdHRlbXB0cyB0byBhY2Nlc3MgdGhlIHBhc3NpdmUgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbiAgICB9XG59XG5cbnZhciBtYXRjaFByZWZpeCA9IFwiLlwiLmNvbmNhdChiYXNlQ2xhc3Nlcy53cmFwcGVyQ2xhc3MpO1xudmFyIGlzRXhjbHVkZWROb2RlID0gZnVuY3Rpb24gKG5vZGUsIGV4Y2x1ZGVkKSB7XG4gICAgcmV0dXJuIGV4Y2x1ZGVkLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUubWF0Y2hlcyhcIlwiLmNvbmNhdChtYXRjaFByZWZpeCwgXCIgXCIpLmNvbmNhdChleGNsdWRlLCBcIiwgXCIpLmNvbmNhdChtYXRjaFByZWZpeCwgXCIgLlwiKS5jb25jYXQoZXhjbHVkZSwgXCIsIFwiKS5jb25jYXQobWF0Y2hQcmVmaXgsIFwiIFwiKS5jb25jYXQoZXhjbHVkZSwgXCIgKiwgXCIpLmNvbmNhdChtYXRjaFByZWZpeCwgXCIgLlwiKS5jb25jYXQoZXhjbHVkZSwgXCIgKlwiKSk7XG4gICAgfSk7XG59O1xudmFyIGNhbmNlbFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG59O1xuXG52YXIgZ2V0VHJhbnNmb3JtU3R5bGVzID0gZnVuY3Rpb24gKHgsIHksIHNjYWxlKSB7XG4gICAgLy8gU3RhbmRhcmQgdHJhbnNsYXRlIHByZXZlbnRzIGJsdXJyeSBzdmcgb24gdGhlIHNhZmFyaVxuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQoeCwgXCJweCwgXCIpLmNvbmNhdCh5LCBcInB4KSBzY2FsZShcIikuY29uY2F0KHNjYWxlLCBcIilcIik7XG59O1xudmFyIGdldE1hdHJpeFRyYW5zZm9ybVN0eWxlcyA9IGZ1bmN0aW9uICh4LCB5LCBzY2FsZSkge1xuICAgIC8vIFRoZSBzaG9ydGhhbmQgZm9yIG1hdHJpeCBkb2VzIG5vdCB3b3JrIGZvciBTYWZhcmkgaGVuY2UgdGhlIG5lZWQgdG8gZXhwbGljaXRseSB1c2UgbWF0cml4M2RcbiAgICAvLyBSZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtLWZ1bmN0aW9uL21hdHJpeFxuICAgIHZhciBhID0gc2NhbGU7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgZCA9IHNjYWxlO1xuICAgIHZhciB0eCA9IHg7XG4gICAgdmFyIHR5ID0geTtcbiAgICByZXR1cm4gXCJtYXRyaXgzZChcIi5jb25jYXQoYSwgXCIsIFwiKS5jb25jYXQoYiwgXCIsIDAsIDAsIFwiKS5jb25jYXQoYywgXCIsIFwiKS5jb25jYXQoZCwgXCIsIDAsIDAsIDAsIDAsIDEsIDAsIFwiKS5jb25jYXQodHgsIFwiLCBcIikuY29uY2F0KHR5LCBcIiwgMCwgMSlcIik7XG59O1xudmFyIGdldENlbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHNjYWxlLCB3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50KSB7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0V2lkdGggKiBzY2FsZTtcbiAgICB2YXIgY29udGVudEhlaWdodCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0SGVpZ2h0ICogc2NhbGU7XG4gICAgdmFyIGNlbnRlclBvc2l0aW9uWCA9ICh3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDI7XG4gICAgdmFyIGNlbnRlclBvc2l0aW9uWSA9ICh3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCAtIGNvbnRlbnRIZWlnaHQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHBvc2l0aW9uWDogY2VudGVyUG9zaXRpb25YLFxuICAgICAgICBwb3NpdGlvblk6IGNlbnRlclBvc2l0aW9uWSxcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gbWVyZ2VSZWZzKHJlZnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxudmFyIGlzV2hlZWxBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAud2hlZWwsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHdoZWVsRGlzYWJsZWQgPSBfYS53aGVlbERpc2FibGVkLCB0b3VjaFBhZERpc2FibGVkID0gX2EudG91Y2hQYWREaXNhYmxlZCwgZXhjbHVkZWQgPSBfYS5leGNsdWRlZDtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBpc1Bhbm5pbmcgPSBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWlzUGFubmluZyAmJiAhZGlzYWJsZWQgJiYgdGFyZ2V0O1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gRXZlbnQgY3RybEtleSBkZXRlY3RzIGlmIHRvdWNocGFkIGFjdGlvbiBpcyBleGVjdXRpbmcgd2hlZWwgb3IgcGluY2ggZ2VzdHVyZVxuICAgIGlmICh3aGVlbERpc2FibGVkICYmICFldmVudC5jdHJsS2V5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRvdWNoUGFkRGlzYWJsZWQgJiYgZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZ2V0RGVsdGFZID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5kZWx0YVkgPCAwID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5mdW5jdGlvbiBnZXREZWx0YShldmVudCwgY3VzdG9tRGVsdGEpIHtcbiAgICB2YXIgZGVsdGFZID0gZ2V0RGVsdGFZKGV2ZW50KTtcbiAgICB2YXIgZGVsdGEgPSBjaGVja0lzTnVtYmVyKGN1c3RvbURlbHRhLCBkZWx0YVkpO1xuICAgIHJldHVybiBkZWx0YTtcbn1cbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNvbnRlbnRDb21wb25lbnQsIHNjYWxlKSB7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudENvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbW91c2VYID0gMDtcbiAgICB2YXIgbW91c2VZID0gMDtcbiAgICBpZiAoXCJjbGllbnRYXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gbW91c2UgcG9zaXRpb24geCwgeSBvdmVyIHdyYXBwZXIgY29tcG9uZW50XG4gICAgICAgIG1vdXNlWCA9IChldmVudC5jbGllbnRYIC0gY29udGVudFJlY3QubGVmdCkgLyBzY2FsZTtcbiAgICAgICAgbW91c2VZID0gKGV2ZW50LmNsaWVudFkgLSBjb250ZW50UmVjdC50b3ApIC8gc2NhbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICBtb3VzZVggPSAodG91Y2guY2xpZW50WCAtIGNvbnRlbnRSZWN0LmxlZnQpIC8gc2NhbGU7XG4gICAgICAgIG1vdXNlWSA9ICh0b3VjaC5jbGllbnRZIC0gY29udGVudFJlY3QudG9wKSAvIHNjYWxlO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzTmFOKG1vdXNlWCkgfHwgTnVtYmVyLmlzTmFOKG1vdXNlWSkpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBtb3VzZSBvciB0b3VjaCBvZmZzZXQgZm91bmRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbW91c2VYLFxuICAgICAgICB5OiBtb3VzZVksXG4gICAgfTtcbn1cbnZhciBoYW5kbGVDYWxjdWxhdGVXaGVlbFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBkZWx0YSwgc3RlcCwgZGlzYWJsZSwgZ2V0VGFyZ2V0KSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBtYXhTY2FsZSA9IHNldHVwLm1heFNjYWxlLCBtaW5TY2FsZSA9IHNldHVwLm1pblNjYWxlLCB6b29tQW5pbWF0aW9uID0gc2V0dXAuem9vbUFuaW1hdGlvbiwgZGlzYWJsZVBhZGRpbmcgPSBzZXR1cC5kaXNhYmxlUGFkZGluZztcbiAgICB2YXIgc2l6ZSA9IHpvb21BbmltYXRpb24uc2l6ZSwgZGlzYWJsZWQgPSB6b29tQW5pbWF0aW9uLmRpc2FibGVkO1xuICAgIGlmICghd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcmFwcGVyIGlzIG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0U2NhbGUgPSBzY2FsZSArIGRlbHRhICogc3RlcDtcbiAgICBpZiAoZ2V0VGFyZ2V0KVxuICAgICAgICByZXR1cm4gdGFyZ2V0U2NhbGU7XG4gICAgdmFyIHBhZGRpbmdFbmFibGVkID0gZGlzYWJsZSA/IGZhbHNlIDogIWRpc2FibGVkO1xuICAgIHZhciBuZXdTY2FsZSA9IGNoZWNrWm9vbUJvdW5kcyhyb3VuZE51bWJlcih0YXJnZXRTY2FsZSwgMyksIG1pblNjYWxlLCBtYXhTY2FsZSwgc2l6ZSwgcGFkZGluZ0VuYWJsZWQgJiYgIWRpc2FibGVQYWRkaW5nKTtcbiAgICByZXR1cm4gbmV3U2NhbGU7XG59O1xudmFyIGhhbmRsZVdoZWVsWm9vbVN0b3AgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBwcmV2aW91c1doZWVsRXZlbnQgPSBjb250ZXh0SW5zdGFuY2UucHJldmlvdXNXaGVlbEV2ZW50O1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIG1heFNjYWxlID0gX2EubWF4U2NhbGUsIG1pblNjYWxlID0gX2EubWluU2NhbGU7XG4gICAgaWYgKCFwcmV2aW91c1doZWVsRXZlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc2NhbGUgPCBtYXhTY2FsZSB8fCBzY2FsZSA+IG1pblNjYWxlKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoTWF0aC5zaWduKHByZXZpb3VzV2hlZWxFdmVudC5kZWx0YVkpICE9PSBNYXRoLnNpZ24oZXZlbnQuZGVsdGFZKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHByZXZpb3VzV2hlZWxFdmVudC5kZWx0YVkgPiAwICYmIHByZXZpb3VzV2hlZWxFdmVudC5kZWx0YVkgPCBldmVudC5kZWx0YVkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChwcmV2aW91c1doZWVsRXZlbnQuZGVsdGFZIDwgMCAmJiBwcmV2aW91c1doZWVsRXZlbnQuZGVsdGFZID4gZXZlbnQuZGVsdGFZKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoTWF0aC5zaWduKHByZXZpb3VzV2hlZWxFdmVudC5kZWx0YVkpICE9PSBNYXRoLnNpZ24oZXZlbnQuZGVsdGFZKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGlzUGluY2hTdGFydEFsbG93ZWQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5waW5jaCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgZXhjbHVkZWQgPSBfYS5leGNsdWRlZDtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWRpc2FibGVkICYmIHRhcmdldDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaXNQaW5jaEFsbG93ZWQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgdmFyIGRpc2FibGVkID0gY29udGV4dEluc3RhbmNlLnNldHVwLnBpbmNoLmRpc2FibGVkO1xuICAgIHZhciBpc0luaXRpYWxpemVkID0gY29udGV4dEluc3RhbmNlLmlzSW5pdGlhbGl6ZWQsIHBpbmNoU3RhcnREaXN0YW5jZSA9IGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0RGlzdGFuY2U7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWRpc2FibGVkICYmIHBpbmNoU3RhcnREaXN0YW5jZTtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBjYWxjdWxhdGVUb3VjaE1pZFBvaW50ID0gZnVuY3Rpb24gKGV2ZW50LCBzY2FsZSwgY29udGVudENvbXBvbmVudCkge1xuICAgIHZhciBjb250ZW50UmVjdCA9IGNvbnRlbnRDb21wb25lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgIHZhciBmaXJzdFBvaW50WCA9IHJvdW5kTnVtYmVyKHRvdWNoZXNbMF0uY2xpZW50WCAtIGNvbnRlbnRSZWN0LmxlZnQsIDUpO1xuICAgIHZhciBmaXJzdFBvaW50WSA9IHJvdW5kTnVtYmVyKHRvdWNoZXNbMF0uY2xpZW50WSAtIGNvbnRlbnRSZWN0LnRvcCwgNSk7XG4gICAgdmFyIHNlY29uZFBvaW50WCA9IHJvdW5kTnVtYmVyKHRvdWNoZXNbMV0uY2xpZW50WCAtIGNvbnRlbnRSZWN0LmxlZnQsIDUpO1xuICAgIHZhciBzZWNvbmRQb2ludFkgPSByb3VuZE51bWJlcih0b3VjaGVzWzFdLmNsaWVudFkgLSBjb250ZW50UmVjdC50b3AsIDUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IChmaXJzdFBvaW50WCArIHNlY29uZFBvaW50WCkgLyAyIC8gc2NhbGUsXG4gICAgICAgIHk6IChmaXJzdFBvaW50WSArIHNlY29uZFBvaW50WSkgLyAyIC8gc2NhbGUsXG4gICAgfTtcbn07XG52YXIgZ2V0VG91Y2hEaXN0YW5jZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVggLSBldmVudC50b3VjaGVzWzFdLnBhZ2VYKSwgMikgK1xuICAgICAgICBNYXRoLnBvdygoZXZlbnQudG91Y2hlc1swXS5wYWdlWSAtIGV2ZW50LnRvdWNoZXNbMV0ucGFnZVkpLCAyKSk7XG59O1xudmFyIGNhbGN1bGF0ZVBpbmNoWm9vbSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGN1cnJlbnREaXN0YW5jZSkge1xuICAgIHZhciBwaW5jaFN0YXJ0U2NhbGUgPSBjb250ZXh0SW5zdGFuY2UucGluY2hTdGFydFNjYWxlLCBwaW5jaFN0YXJ0RGlzdGFuY2UgPSBjb250ZXh0SW5zdGFuY2UucGluY2hTdGFydERpc3RhbmNlLCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cDtcbiAgICB2YXIgbWF4U2NhbGUgPSBzZXR1cC5tYXhTY2FsZSwgbWluU2NhbGUgPSBzZXR1cC5taW5TY2FsZSwgem9vbUFuaW1hdGlvbiA9IHNldHVwLnpvb21BbmltYXRpb24sIGRpc2FibGVQYWRkaW5nID0gc2V0dXAuZGlzYWJsZVBhZGRpbmc7XG4gICAgdmFyIHNpemUgPSB6b29tQW5pbWF0aW9uLnNpemUsIGRpc2FibGVkID0gem9vbUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICBpZiAoIXBpbmNoU3RhcnRTY2FsZSB8fCBwaW5jaFN0YXJ0RGlzdGFuY2UgPT09IG51bGwgfHwgIWN1cnJlbnREaXN0YW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQaW5jaCB0b3VjaGVzIGRpc3RhbmNlIHdhcyBub3QgcHJvdmlkZWRcIik7XG4gICAgfVxuICAgIGlmIChjdXJyZW50RGlzdGFuY2UgPCAwKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgfVxuICAgIHZhciB0b3VjaFByb3BvcnRpb24gPSBjdXJyZW50RGlzdGFuY2UgLyBwaW5jaFN0YXJ0RGlzdGFuY2U7XG4gICAgdmFyIHNjYWxlRGlmZmVyZW5jZSA9IHRvdWNoUHJvcG9ydGlvbiAqIHBpbmNoU3RhcnRTY2FsZTtcbiAgICByZXR1cm4gY2hlY2tab29tQm91bmRzKHJvdW5kTnVtYmVyKHNjYWxlRGlmZmVyZW5jZSwgMiksIG1pblNjYWxlLCBtYXhTY2FsZSwgc2l6ZSwgIWRpc2FibGVkICYmICFkaXNhYmxlUGFkZGluZyk7XG59O1xuXG52YXIgd2hlZWxTdG9wRXZlbnRUaW1lID0gMTYwO1xudmFyIHdoZWVsQW5pbWF0aW9uVGltZSA9IDEwMDtcbnZhciBoYW5kbGVXaGVlbFN0YXJ0ID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UucHJvcHMsIG9uV2hlZWxTdGFydCA9IF9hLm9uV2hlZWxTdGFydCwgb25ab29tU3RhcnQgPSBfYS5vblpvb21TdGFydDtcbiAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS53aGVlbFN0b3BFdmVudFRpbWVyKSB7XG4gICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihjb250ZXh0SW5zdGFuY2UpO1xuICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvbldoZWVsU3RhcnQpO1xuICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb21TdGFydCk7XG4gICAgfVxufTtcbnZhciBoYW5kbGVXaGVlbFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5wcm9wcywgb25XaGVlbCA9IF9hLm9uV2hlZWwsIG9uWm9vbSA9IF9hLm9uWm9vbTtcbiAgICB2YXIgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50LCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIHNjYWxlID0gdHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBzZXR1cC5saW1pdFRvQm91bmRzLCBjZW50ZXJab29tZWRPdXQgPSBzZXR1cC5jZW50ZXJab29tZWRPdXQsIHpvb21BbmltYXRpb24gPSBzZXR1cC56b29tQW5pbWF0aW9uLCB3aGVlbCA9IHNldHVwLndoZWVsLCBkaXNhYmxlUGFkZGluZyA9IHNldHVwLmRpc2FibGVQYWRkaW5nLCBzbW9vdGggPSBzZXR1cC5zbW9vdGg7XG4gICAgdmFyIHNpemUgPSB6b29tQW5pbWF0aW9uLnNpemUsIGRpc2FibGVkID0gem9vbUFuaW1hdGlvbi5kaXNhYmxlZDtcbiAgICB2YXIgc3RlcCA9IHdoZWVsLnN0ZXAsIHNtb290aFN0ZXAgPSB3aGVlbC5zbW9vdGhTdGVwO1xuICAgIGlmICghY29udGVudENvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnQgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdmFyIGRlbHRhID0gZ2V0RGVsdGEoZXZlbnQsIG51bGwpO1xuICAgIHZhciB6b29tU3RlcCA9IHNtb290aCA/IHNtb290aFN0ZXAgKiBNYXRoLmFicyhldmVudC5kZWx0YVkpIDogc3RlcDtcbiAgICB2YXIgbmV3U2NhbGUgPSBoYW5kbGVDYWxjdWxhdGVXaGVlbFpvb20oY29udGV4dEluc3RhbmNlLCBkZWx0YSwgem9vbVN0ZXAsICFldmVudC5jdHJsS2V5KTtcbiAgICAvLyBpZiBzY2FsZSBub3QgY2hhbmdlXG4gICAgaWYgKHNjYWxlID09PSBuZXdTY2FsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBib3VuZHMgPSBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSk7XG4gICAgdmFyIG1vdXNlUG9zaXRpb24gPSBnZXRNb3VzZVBvc2l0aW9uKGV2ZW50LCBjb250ZW50Q29tcG9uZW50LCBzY2FsZSk7XG4gICAgdmFyIGlzUGFkZGluZ0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgc2l6ZSA9PT0gMCB8fCBjZW50ZXJab29tZWRPdXQgfHwgZGlzYWJsZVBhZGRpbmc7XG4gICAgdmFyIGlzTGltaXRlZFRvQm91bmRzID0gbGltaXRUb0JvdW5kcyAmJiBpc1BhZGRpbmdEaXNhYmxlZDtcbiAgICB2YXIgX2IgPSBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbW91c2VQb3NpdGlvbi54LCBtb3VzZVBvc2l0aW9uLnksIG5ld1NjYWxlLCBib3VuZHMsIGlzTGltaXRlZFRvQm91bmRzKSwgeCA9IF9iLngsIHkgPSBfYi55O1xuICAgIGNvbnRleHRJbnN0YW5jZS5wcmV2aW91c1doZWVsRXZlbnQgPSBldmVudDtcbiAgICBjb250ZXh0SW5zdGFuY2Uuc2V0VHJhbnNmb3JtU3RhdGUobmV3U2NhbGUsIHgsIHkpO1xuICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uV2hlZWwpO1xuICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uWm9vbSk7XG59O1xudmFyIGhhbmRsZVdoZWVsU3RvcCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnByb3BzLCBvbldoZWVsU3RvcCA9IF9hLm9uV2hlZWxTdG9wLCBvblpvb21TdG9wID0gX2Eub25ab29tU3RvcDtcbiAgICAvLyBmaXJlIGFuaW1hdGlvblxuICAgIGNhbmNlbFRpbWVvdXQoY29udGV4dEluc3RhbmNlLndoZWVsQW5pbWF0aW9uVGltZXIpO1xuICAgIGNvbnRleHRJbnN0YW5jZS53aGVlbEFuaW1hdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY29udGV4dEluc3RhbmNlLm1vdW50ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGhhbmRsZUFsaWduVG9TY2FsZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIGV2ZW50LngsIGV2ZW50LnkpO1xuICAgICAgICBjb250ZXh0SW5zdGFuY2Uud2hlZWxBbmltYXRpb25UaW1lciA9IG51bGw7XG4gICAgfSwgd2hlZWxBbmltYXRpb25UaW1lKTtcbiAgICAvLyBXaGVlbCBzdG9wIGV2ZW50XG4gICAgdmFyIGhhc1N0b3BwZWRab29taW5nID0gaGFuZGxlV2hlZWxab29tU3RvcChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KTtcbiAgICBpZiAoaGFzU3RvcHBlZFpvb21pbmcpIHtcbiAgICAgICAgY2FuY2VsVGltZW91dChjb250ZXh0SW5zdGFuY2Uud2hlZWxTdG9wRXZlbnRUaW1lcik7XG4gICAgICAgIGNvbnRleHRJbnN0YW5jZS53aGVlbFN0b3BFdmVudFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS5tb3VudGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnRleHRJbnN0YW5jZS53aGVlbFN0b3BFdmVudFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uV2hlZWxTdG9wKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uWm9vbVN0b3ApO1xuICAgICAgICB9LCB3aGVlbFN0b3BFdmVudFRpbWUpO1xuICAgIH1cbn07XG5cbnZhciBnZXRUb3VjaENlbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB0b3RhbFggPSAwO1xuICAgIHZhciB0b3RhbFkgPSAwO1xuICAgIC8vIFN1bSB1cCB0aGUgcG9zaXRpb25zIG9mIGFsbCB0b3VjaGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpICs9IDEpIHtcbiAgICAgICAgdG90YWxYICs9IGV2ZW50LnRvdWNoZXNbaV0uY2xpZW50WDtcbiAgICAgICAgdG90YWxZICs9IGV2ZW50LnRvdWNoZXNbaV0uY2xpZW50WTtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBhdmVyYWdlIHBvc2l0aW9uXG4gICAgdmFyIHggPSB0b3RhbFggLyAyO1xuICAgIHZhciB5ID0gdG90YWxZIC8gMjtcbiAgICByZXR1cm4geyB4OiB4LCB5OiB5IH07XG59O1xudmFyIGhhbmRsZVBpbmNoU3RhcnQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBkaXN0YW5jZSA9IGdldFRvdWNoRGlzdGFuY2UoZXZlbnQpO1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnRTY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgdmFyIGNlbnRlciA9IGdldFRvdWNoQ2VudGVyKGV2ZW50KTtcbiAgICBjb250ZXh0SW5zdGFuY2UucGluY2hMYXN0Q2VudGVyWCA9IGNlbnRlci54O1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaExhc3RDZW50ZXJZID0gY2VudGVyLnk7XG4gICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSk7XG59O1xudmFyIGhhbmRsZVBpbmNoWm9vbSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudCwgcGluY2hTdGFydERpc3RhbmNlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZSwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIGxpbWl0VG9Cb3VuZHMgPSBfYS5saW1pdFRvQm91bmRzLCBjZW50ZXJab29tZWRPdXQgPSBfYS5jZW50ZXJab29tZWRPdXQsIHpvb21BbmltYXRpb24gPSBfYS56b29tQW5pbWF0aW9uLCBhbGlnbm1lbnRBbmltYXRpb24gPSBfYS5hbGlnbm1lbnRBbmltYXRpb247XG4gICAgdmFyIGRpc2FibGVkID0gem9vbUFuaW1hdGlvbi5kaXNhYmxlZCwgc2l6ZSA9IHpvb21BbmltYXRpb24uc2l6ZTtcbiAgICAvLyBpZiBvbmUgZmluZ2VyIHN0YXJ0cyBmcm9tIG91dHNpZGUgb2Ygd3JhcHBlclxuICAgIGlmIChwaW5jaFN0YXJ0RGlzdGFuY2UgPT09IG51bGwgfHwgIWNvbnRlbnRDb21wb25lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgbWlkUG9pbnQgPSBjYWxjdWxhdGVUb3VjaE1pZFBvaW50KGV2ZW50LCBzY2FsZSwgY29udGVudENvbXBvbmVudCk7XG4gICAgLy8gaWYgdG91Y2hlcyBnb2VzIG9mZiBvZiB0aGUgd3JhcHBlciBlbGVtZW50XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWlkUG9pbnQueCkgfHwgIU51bWJlci5pc0Zpbml0ZShtaWRQb2ludC55KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBjdXJyZW50RGlzdGFuY2UgPSBnZXRUb3VjaERpc3RhbmNlKGV2ZW50KTtcbiAgICB2YXIgbmV3U2NhbGUgPSBjYWxjdWxhdGVQaW5jaFpvb20oY29udGV4dEluc3RhbmNlLCBjdXJyZW50RGlzdGFuY2UpO1xuICAgIHZhciBjZW50ZXIgPSBnZXRUb3VjaENlbnRlcihldmVudCk7XG4gICAgLy8gcGFuIHNob3VsZCBiZSBzY2FsZSBpbnZhcmlhbnQuXG4gICAgdmFyIHBhblggPSBjZW50ZXIueCAtIChjb250ZXh0SW5zdGFuY2UucGluY2hMYXN0Q2VudGVyWCB8fCAwKTtcbiAgICB2YXIgcGFuWSA9IGNlbnRlci55IC0gKGNvbnRleHRJbnN0YW5jZS5waW5jaExhc3RDZW50ZXJZIHx8IDApO1xuICAgIGlmIChuZXdTY2FsZSA9PT0gc2NhbGUgJiYgcGFuWCA9PT0gMCAmJiBwYW5ZID09PSAwKVxuICAgICAgICByZXR1cm47XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoTGFzdENlbnRlclggPSBjZW50ZXIueDtcbiAgICBjb250ZXh0SW5zdGFuY2UucGluY2hMYXN0Q2VudGVyWSA9IGNlbnRlci55O1xuICAgIHZhciBib3VuZHMgPSBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSk7XG4gICAgdmFyIGlzUGFkZGluZ0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgc2l6ZSA9PT0gMCB8fCBjZW50ZXJab29tZWRPdXQ7XG4gICAgdmFyIGlzTGltaXRlZFRvQm91bmRzID0gbGltaXRUb0JvdW5kcyAmJiBpc1BhZGRpbmdEaXNhYmxlZDtcbiAgICB2YXIgX2IgPSBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSwgbmV3U2NhbGUsIGJvdW5kcywgaXNMaW1pdGVkVG9Cb3VuZHMpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoTWlkcG9pbnQgPSBtaWRQb2ludDtcbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdERpc3RhbmNlID0gY3VycmVudERpc3RhbmNlO1xuICAgIHZhciBzaXplWCA9IGFsaWdubWVudEFuaW1hdGlvbi5zaXplWCwgc2l6ZVkgPSBhbGlnbm1lbnRBbmltYXRpb24uc2l6ZVk7XG4gICAgdmFyIHBhZGRpbmdWYWx1ZVggPSBnZXRQYWRkaW5nVmFsdWUoY29udGV4dEluc3RhbmNlLCBzaXplWCk7XG4gICAgdmFyIHBhZGRpbmdWYWx1ZVkgPSBnZXRQYWRkaW5nVmFsdWUoY29udGV4dEluc3RhbmNlLCBzaXplWSk7XG4gICAgdmFyIG5ld1Bvc2l0aW9uWCA9IHggKyBwYW5YO1xuICAgIHZhciBuZXdQb3NpdGlvblkgPSB5ICsgcGFuWTtcbiAgICB2YXIgX2MgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWVYLCBwYWRkaW5nVmFsdWVZLCB3cmFwcGVyQ29tcG9uZW50KSwgZmluYWxYID0gX2MueCwgZmluYWxZID0gX2MueTtcbiAgICBjb250ZXh0SW5zdGFuY2Uuc2V0VHJhbnNmb3JtU3RhdGUobmV3U2NhbGUsIGZpbmFsWCwgZmluYWxZKTtcbn07XG52YXIgaGFuZGxlUGluY2hTdG9wID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBwaW5jaE1pZHBvaW50ID0gY29udGV4dEluc3RhbmNlLnBpbmNoTWlkcG9pbnQ7XG4gICAgY29udGV4dEluc3RhbmNlLnZlbG9jaXR5ID0gbnVsbDtcbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdERpc3RhbmNlID0gbnVsbDtcbiAgICBjb250ZXh0SW5zdGFuY2UucGluY2hNaWRwb2ludCA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnRTY2FsZSA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZSA9IG51bGw7XG4gICAgaGFuZGxlQWxpZ25Ub1NjYWxlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgcGluY2hNaWRwb2ludCA9PT0gbnVsbCB8fCBwaW5jaE1pZHBvaW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwaW5jaE1pZHBvaW50LngsIHBpbmNoTWlkcG9pbnQgPT09IG51bGwgfHwgcGluY2hNaWRwb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGluY2hNaWRwb2ludC55KTtcbn07XG5cbnZhciBoYW5kbGVEb3VibGVDbGlja1N0b3AgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBvblpvb21TdG9wID0gY29udGV4dEluc3RhbmNlLnByb3BzLm9uWm9vbVN0b3A7XG4gICAgdmFyIGFuaW1hdGlvblRpbWUgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAuZG91YmxlQ2xpY2suYW5pbWF0aW9uVGltZTtcbiAgICBjYW5jZWxUaW1lb3V0KGNvbnRleHRJbnN0YW5jZS5kb3VibGVDbGlja1N0b3BFdmVudFRpbWVyKTtcbiAgICBjb250ZXh0SW5zdGFuY2UuZG91YmxlQ2xpY2tTdG9wRXZlbnRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZXh0SW5zdGFuY2UuZG91YmxlQ2xpY2tTdG9wRXZlbnRUaW1lciA9IG51bGw7XG4gICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uWm9vbVN0b3ApO1xuICAgIH0sIGFuaW1hdGlvblRpbWUpO1xufTtcbnZhciBoYW5kbGVEb3VibGVDbGlja1Jlc2V0TW9kZSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnByb3BzLCBvblpvb21TdGFydCA9IF9hLm9uWm9vbVN0YXJ0LCBvblpvb20gPSBfYS5vblpvb207XG4gICAgdmFyIF9iID0gY29udGV4dEluc3RhbmNlLnNldHVwLmRvdWJsZUNsaWNrLCBhbmltYXRpb25UaW1lID0gX2IuYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSA9IF9iLmFuaW1hdGlvblR5cGU7XG4gICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tU3RhcnQpO1xuICAgIHJlc2V0VHJhbnNmb3JtYXRpb25zKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tKTtcbiAgICB9KTtcbiAgICBoYW5kbGVEb3VibGVDbGlja1N0b3AoY29udGV4dEluc3RhbmNlLCBldmVudCk7XG59O1xuZnVuY3Rpb24gZ2V0RG91YmxlQ2xpY2tTY2FsZShtb2RlLCBzY2FsZSkge1xuICAgIGlmIChtb2RlID09PSBcInRvZ2dsZVwiKSB7XG4gICAgICAgIHJldHVybiBzY2FsZSA9PT0gMSA/IDEgOiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGUgPT09IFwiem9vbU91dFwiID8gLTEgOiAxO1xufVxuZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2soY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgZG91YmxlQ2xpY2tTdG9wRXZlbnRUaW1lciA9IGNvbnRleHRJbnN0YW5jZS5kb3VibGVDbGlja1N0b3BFdmVudFRpbWVyLCB0cmFuc2Zvcm1TdGF0ZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50O1xuICAgIHZhciBzY2FsZSA9IHRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5wcm9wcywgb25ab29tU3RhcnQgPSBfYS5vblpvb21TdGFydCwgb25ab29tID0gX2Eub25ab29tO1xuICAgIHZhciBfYiA9IHNldHVwLmRvdWJsZUNsaWNrLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBtb2RlID0gX2IubW9kZSwgc3RlcCA9IF9iLnN0ZXAsIGFuaW1hdGlvblRpbWUgPSBfYi5hbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlID0gX2IuYW5pbWF0aW9uVHlwZTtcbiAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZG91YmxlQ2xpY2tTdG9wRXZlbnRUaW1lcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChtb2RlID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZURvdWJsZUNsaWNrUmVzZXRNb2RlKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRlbnRDb21wb25lbnQpXG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiTm8gQ29udGVudENvbXBvbmVudCBmb3VuZFwiKTtcbiAgICB2YXIgZGVsdGEgPSBnZXREb3VibGVDbGlja1NjYWxlKG1vZGUsIGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZSk7XG4gICAgdmFyIG5ld1NjYWxlID0gaGFuZGxlQ2FsY3VsYXRlQnV0dG9uWm9vbShjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwKTtcbiAgICAvLyBzdG9wIGV4ZWN1dGlvbiB3aGVuIHNjYWxlIGRpZG4ndCBjaGFuZ2VcbiAgICBpZiAoc2NhbGUgPT09IG5ld1NjYWxlKVxuICAgICAgICByZXR1cm47XG4gICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tU3RhcnQpO1xuICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY29udGVudENvbXBvbmVudCwgc2NhbGUpO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUsIG1vdXNlUG9zaXRpb24ueCwgbW91c2VQb3NpdGlvbi55KTtcbiAgICBpZiAoIXRhcmdldFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHpvb20gZXZlbnQuIE5ldyB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSB3YXMgbm90IGNhbGN1bGF0ZWQuXCIpO1xuICAgIH1cbiAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb20pO1xuICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCB0YXJnZXRTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgaGFuZGxlRG91YmxlQ2xpY2tTdG9wKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xufVxudmFyIGlzRG91YmxlQ2xpY2tBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBfYSA9IHNldHVwLmRvdWJsZUNsaWNrLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBleGNsdWRlZCA9IF9hLmV4Y2x1ZGVkO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzV3JhcHBlckNoaWxkID0gd3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fCB3cmFwcGVyQ29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyQ29tcG9uZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgdGFyZ2V0ICYmIGlzV3JhcHBlckNoaWxkICYmICFkaXNhYmxlZDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBab29tUGFuUGluY2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWm9vbVBhblBpbmNoKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucGluY2hMYXN0Q2VudGVyWCA9IG51bGw7XG4gICAgICAgIHRoaXMucGluY2hMYXN0Q2VudGVyWSA9IG51bGw7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMub25Jbml0Q2FsbGJhY2tzID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBDb21wb25lbnRzXG4gICAgICAgIHRoaXMud3JhcHBlckNvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIC8vIEluaXRpYWxpemF0aW9uXG4gICAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG51bGw7XG4gICAgICAgIC8vIHdoZWVsIGhlbHBlcnNcbiAgICAgICAgdGhpcy5wcmV2aW91c1doZWVsRXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLndoZWVsU3RvcEV2ZW50VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLndoZWVsQW5pbWF0aW9uVGltZXIgPSBudWxsO1xuICAgICAgICAvLyBwYW5uaW5nIGhlbHBlcnNcbiAgICAgICAgdGhpcy5pc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1doZWVsUGFubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0Q29vcmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSBudWxsO1xuICAgICAgICAvLyBwaW5jaCBoZWxwZXJzXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3REaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGluY2hTdGFydERpc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5waW5jaFN0YXJ0U2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmNoTWlkcG9pbnQgPSBudWxsO1xuICAgICAgICAvLyBkb3VibGUgY2xpY2sgaGVscGVyc1xuICAgICAgICB0aGlzLmRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIgPSBudWxsO1xuICAgICAgICAvLyB2ZWxvY2l0eSBoZWxwZXJzXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSBudWxsO1xuICAgICAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAvLyBhbmltYXRpb25zIGhlbHBlcnNcbiAgICAgICAgdGhpcy5hbmltYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXhCb3VuZHMgPSBudWxsO1xuICAgICAgICAvLyBrZXkgcHJlc3NcbiAgICAgICAgdGhpcy5wcmVzc2VkS2V5cyA9IHt9O1xuICAgICAgICB0aGlzLm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZVdpbmRvd0V2ZW50cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhbnVwV2luZG93RXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcyA9IG5ld1Byb3BzO1xuICAgICAgICAgICAgaGFuZGxlQ2FsY3VsYXRlQm91bmRzKF90aGlzLCBfdGhpcy50cmFuc2Zvcm1TdGF0ZS5zY2FsZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXR1cCA9IGNyZWF0ZVNldHVwKG5ld1Byb3BzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplV2luZG93RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBwYXNzaXZlID0gbWFrZVBhc3NpdmVFdmVudE9wdGlvbigpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnREb2N1bWVudCA9IChfYSA9IF90aGlzLndyYXBwZXJDb21wb25lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRXaW5kb3cgPSBjdXJyZW50RG9jdW1lbnQgPT09IG51bGwgfHwgY3VycmVudERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICAoX2IgPSBfdGhpcy53cmFwcGVyQ29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIF90aGlzLm9uV2hlZWxQYW5uaW5nLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIC8vIFBhbm5pbmcgb24gd2luZG93IHRvIGFsbG93IHBhbm5pbmcgd2hlbiBtb3VzZSBpcyBvdXQgb2YgY29tcG9uZW50IHdyYXBwZXJcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF90aGlzLm9uUGFubmluZ1N0YXJ0LCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLm9uUGFubmluZywgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50V2luZG93ID09PSBudWxsIHx8IGN1cnJlbnRXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMub25QYW5uaW5nU3RvcCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50RG9jdW1lbnQgPT09IG51bGwgfHwgY3VycmVudERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgX3RoaXMuY2xlYXJQYW5uaW5nLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX3RoaXMuc2V0S2V5VW5QcmVzc2VkLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfdGhpcy5zZXRLZXlQcmVzc2VkLCBwYXNzaXZlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwV2luZG93RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBwYXNzaXZlID0gbWFrZVBhc3NpdmVFdmVudE9wdGlvbigpO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnREb2N1bWVudCA9IChfYSA9IF90aGlzLndyYXBwZXJDb21wb25lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vd25lckRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRXaW5kb3cgPSBjdXJyZW50RG9jdW1lbnQgPT09IG51bGwgfHwgY3VycmVudERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICBjdXJyZW50V2luZG93ID09PSBudWxsIHx8IGN1cnJlbnRXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfdGhpcy5vblBhbm5pbmdTdGFydCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50V2luZG93ID09PSBudWxsIHx8IGN1cnJlbnRXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5vblBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdyA9PT0gbnVsbCB8fCBjdXJyZW50V2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50V2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF90aGlzLm9uUGFubmluZ1N0b3AsIHBhc3NpdmUpO1xuICAgICAgICAgICAgY3VycmVudERvY3VtZW50ID09PSBudWxsIHx8IGN1cnJlbnREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIF90aGlzLmNsZWFyUGFubmluZywgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50V2luZG93ID09PSBudWxsIHx8IGN1cnJlbnRXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIF90aGlzLnNldEtleVVuUHJlc3NlZCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50V2luZG93ID09PSBudWxsIHx8IGN1cnJlbnRXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgX3RoaXMuc2V0S2V5UHJlc3NlZCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBfdGhpcy5jbGVhclBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKF90aGlzKTtcbiAgICAgICAgICAgIChfYiA9IF90aGlzLm9ic2VydmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUluaXRpYWxpemVXcmFwcGVyRXZlbnRzID0gZnVuY3Rpb24gKHdyYXBwZXIpIHtcbiAgICAgICAgICAgIC8vIFpvb21pbmcgZXZlbnRzIG9uIHdyYXBwZXJcbiAgICAgICAgICAgIHZhciBwYXNzaXZlID0gbWFrZVBhc3NpdmVFdmVudE9wdGlvbigpO1xuICAgICAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgX3RoaXMub25XaGVlbFpvb20sIHBhc3NpdmUpO1xuICAgICAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgX3RoaXMub25Eb3VibGVDbGljaywgcGFzc2l2ZSk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLm9uVG91Y2hQYW5uaW5nU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLm9uVG91Y2hQYW5uaW5nLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIF90aGlzLm9uVG91Y2hQYW5uaW5nU3RvcCwgcGFzc2l2ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3cmFwcGVyLCBjb250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaXNDZW50ZXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNlbnRlck9uSW5pdCA9IF90aGlzLnNldHVwLmNlbnRlck9uSW5pdDtcbiAgICAgICAgICAgIHZhciBoYXNUYXJnZXQgPSBmdW5jdGlvbiAoZW50cmllcywgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBlbnRyaWVzXzEgPSBlbnRyaWVzOyBfaSA8IGVudHJpZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVudHJ5LnRhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbigpO1xuICAgICAgICAgICAgX3RoaXMub25Jbml0Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmIChoYXNUYXJnZXQoZW50cmllcywgd3JhcHBlcikgfHwgaGFzVGFyZ2V0KGVudHJpZXMsIGNvbnRlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZW50ZXJPbkluaXQgJiYgIWlzQ2VudGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50V2lkdGggPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRIZWlnaHQgPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggPiAwIHx8IGN1cnJlbnRIZWlnaHQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDZW50ZXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2FsY3VsYXRlQm91bmRzKF90aGlzLCBfdGhpcy50cmFuc2Zvcm1TdGF0ZS5zY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVBbGlnblRvQm91bmRzKF90aGlzLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gU3RhcnQgb2JzZXJ2aW5nIHRoZSB0YXJnZXQgbm9kZSBmb3IgY29uZmlndXJlZCBtdXRhdGlvbnNcbiAgICAgICAgICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUod3JhcHBlcik7XG4gICAgICAgICAgICBfdGhpcy5vYnNlcnZlci5vYnNlcnZlKGNvbnRlbnRDb21wb25lbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLy8gLy8vLy8vL1xuICAgICAgICAvLyBab29tXG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIHRoaXMub25XaGVlbFpvb20gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc1doZWVsQWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGtleXNQcmVzc2VkID0gX3RoaXMuaXNQcmVzc2luZ0tleXMoX3RoaXMuc2V0dXAud2hlZWwuYWN0aXZhdGlvbktleXMpO1xuICAgICAgICAgICAgaWYgKCFrZXlzUHJlc3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVXaGVlbFN0YXJ0KF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICBoYW5kbGVXaGVlbFpvb20oX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZVdoZWVsU3RvcChfdGhpcywgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLy8gLy8vLy8vL1xuICAgICAgICAvLyBQYW5cbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgdGhpcy5vbldoZWVsUGFubmluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuc2V0dXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHdoZWVsID0gX2Eud2hlZWwsIHBhbm5pbmcgPSBfYS5wYW5uaW5nO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy53cmFwcGVyQ29tcG9uZW50IHx8XG4gICAgICAgICAgICAgICAgIV90aGlzLmNvbnRlbnRDb21wb25lbnQgfHxcbiAgICAgICAgICAgICAgICBkaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICF3aGVlbC53aGVlbERpc2FibGVkIHx8XG4gICAgICAgICAgICAgICAgcGFubmluZy5kaXNhYmxlZCB8fFxuICAgICAgICAgICAgICAgICFwYW5uaW5nLndoZWVsUGFubmluZyB8fFxuICAgICAgICAgICAgICAgIGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy50cmFuc2Zvcm1TdGF0ZSwgcG9zaXRpb25YID0gX2IucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYi5wb3NpdGlvblk7XG4gICAgICAgICAgICB2YXIgbW91c2VYID0gcG9zaXRpb25YIC0gZXZlbnQuZGVsdGFYO1xuICAgICAgICAgICAgdmFyIG1vdXNlWSA9IHBvc2l0aW9uWSAtIGV2ZW50LmRlbHRhWTtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblggPSBwYW5uaW5nLmxvY2tBeGlzWCA/IHBvc2l0aW9uWCA6IG1vdXNlWDtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblkgPSBwYW5uaW5nLmxvY2tBeGlzWSA/IHBvc2l0aW9uWSA6IG1vdXNlWTtcbiAgICAgICAgICAgIHZhciBfYyA9IF90aGlzLnNldHVwLmFsaWdubWVudEFuaW1hdGlvbiwgc2l6ZVggPSBfYy5zaXplWCwgc2l6ZVkgPSBfYy5zaXplWTtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nVmFsdWVYID0gZ2V0UGFkZGluZ1ZhbHVlKF90aGlzLCBzaXplWCk7XG4gICAgICAgICAgICB2YXIgcGFkZGluZ1ZhbHVlWSA9IGdldFBhZGRpbmdWYWx1ZShfdGhpcywgc2l6ZVkpO1xuICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uWCA9PT0gcG9zaXRpb25YICYmIG5ld1Bvc2l0aW9uWSA9PT0gcG9zaXRpb25ZKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZU5ld1Bvc2l0aW9uKF90aGlzLCBuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgcGFkZGluZ1ZhbHVlWCwgcGFkZGluZ1ZhbHVlWSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25QYW5uaW5nU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIG9uUGFubmluZ1N0YXJ0ID0gX3RoaXMucHJvcHMub25QYW5uaW5nU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGFubmluZ1N0YXJ0QWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGtleXNQcmVzc2VkID0gX3RoaXMuaXNQcmVzc2luZ0tleXMoX3RoaXMuc2V0dXAucGFubmluZy5hY3RpdmF0aW9uS2V5cyk7XG4gICAgICAgICAgICBpZiAoIWtleXNQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDAgJiYgIV90aGlzLnNldHVwLnBhbm5pbmcuYWxsb3dMZWZ0Q2xpY2tQYW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSAmJiAhX3RoaXMuc2V0dXAucGFubmluZy5hbGxvd01pZGRsZUNsaWNrUGFuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChldmVudC5idXR0b24gPT09IDIgJiYgIV90aGlzLnNldHVwLnBhbm5pbmcuYWxsb3dSaWdodENsaWNrUGFuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihfdGhpcyk7XG4gICAgICAgICAgICBoYW5kbGVQYW5uaW5nU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nU3RhcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUGFubmluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgICAgICB2YXIgb25QYW5uaW5nID0gX3RoaXMucHJvcHMub25QYW5uaW5nO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc1Bhbm5pbmdBbGxvd2VkKF90aGlzKTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBrZXlzUHJlc3NlZCA9IF90aGlzLmlzUHJlc3NpbmdLZXlzKF90aGlzLnNldHVwLnBhbm5pbmcuYWN0aXZhdGlvbktleXMpO1xuICAgICAgICAgICAgaWYgKCFrZXlzUHJlc3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBoYW5kbGVQYW5uaW5nKF90aGlzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBhbm5pbmdTdG9wID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgb25QYW5uaW5nU3RvcCA9IF90aGlzLnByb3BzLm9uUGFubmluZ1N0b3A7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNQYW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUGFubmluZ0VuZChfdGhpcyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblBhbm5pbmdTdG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgLy8gUGluY2hcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgdGhpcy5vblBpbmNoU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG9uUGluY2hpbmdTdGFydCA9IF9hLm9uUGluY2hpbmdTdGFydCwgb25ab29tU3RhcnQgPSBfYS5vblpvb21TdGFydDtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gaXNQaW5jaFN0YXJ0QWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlUGluY2hTdGFydChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKF90aGlzKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QaW5jaGluZ1N0YXJ0KTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25ab29tU3RhcnQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUGluY2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG9uUGluY2hpbmcgPSBfYS5vblBpbmNoaW5nLCBvblpvb20gPSBfYS5vblpvb207XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGluY2hBbGxvd2VkKF90aGlzKTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGhhbmRsZVBpbmNoWm9vbShfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblBpbmNoaW5nKTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25ab29tKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBpbmNoU3RvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG9uUGluY2hpbmdTdG9wID0gX2Eub25QaW5jaGluZ1N0b3AsIG9uWm9vbVN0b3AgPSBfYS5vblpvb21TdG9wO1xuICAgICAgICAgICAgaWYgKF90aGlzLnBpbmNoU3RhcnRTY2FsZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZVBpbmNoU3RvcChfdGhpcyk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblBpbmNoaW5nU3RvcCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblpvb21TdG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgLy8gVG91Y2hcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgdGhpcy5vblRvdWNoUGFubmluZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBvblBhbm5pbmdTdGFydCA9IF90aGlzLnByb3BzLm9uUGFubmluZ1N0YXJ0O1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc1Bhbm5pbmdTdGFydEFsbG93ZWQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0RvdWJsZVRhcCA9IF90aGlzLmxhc3RUb3VjaCAmJlxuICAgICAgICAgICAgICAgICtuZXcgRGF0ZSgpIC0gX3RoaXMubGFzdFRvdWNoIDwgMjAwICYmXG4gICAgICAgICAgICAgICAgZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDE7XG4gICAgICAgICAgICBpZiAoIWlzRG91YmxlVGFwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFRvdWNoID0gK25ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKF90aGlzKTtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2hlcyA9IGV2ZW50LnRvdWNoZXM7XG4gICAgICAgICAgICAgICAgdmFyIGlzUGFubmluZ0FjdGlvbiA9IHRvdWNoZXMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgICAgIHZhciBpc1BpbmNoQWN0aW9uID0gdG91Y2hlcy5sZW5ndGggPT09IDI7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFubmluZ0FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYW5uaW5nU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChfdGhpcyksIGV2ZW50LCBvblBhbm5pbmdTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1BpbmNoQWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uUGluY2hTdGFydChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uVG91Y2hQYW5uaW5nID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBvblBhbm5pbmcgPSBfdGhpcy5wcm9wcy5vblBhbm5pbmc7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNQYW5uaW5nICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGFubmluZ0FsbG93ZWQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgIGhhbmRsZVBhbm5pbmcoX3RoaXMsIHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uUGluY2goZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uVG91Y2hQYW5uaW5nU3RvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMub25QYW5uaW5nU3RvcChldmVudCk7XG4gICAgICAgICAgICBfdGhpcy5vblBpbmNoU3RvcChldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIC8vIERvdWJsZSBDbGlja1xuICAgICAgICAvLy8gLy8vLy8vL1xuICAgICAgICB0aGlzLm9uRG91YmxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc0RvdWJsZUNsaWNrQWxsb3dlZChfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlRG91YmxlQ2xpY2soX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgLy8gSGVscGVyc1xuICAgICAgICAvLy8gLy8vLy8vL1xuICAgICAgICB0aGlzLmNsZWFyUGFubmluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzUGFubmluZykge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uUGFubmluZ1N0b3AoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNldEtleVByZXNzZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMucHJlc3NlZEtleXNbZS5rZXldID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRLZXlVblByZXNzZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMucHJlc3NlZEtleXNbZS5rZXldID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNQcmVzc2luZ0tleXMgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oa2V5cy5maW5kKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIF90aGlzLnByZXNzZWRLZXlzW2tleV07IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1TdGF0ZSA9IGZ1bmN0aW9uIChzY2FsZSwgcG9zaXRpb25YLCBwb3NpdGlvblkpIHtcbiAgICAgICAgICAgIHZhciBvblRyYW5zZm9ybWVkID0gX3RoaXMucHJvcHMub25UcmFuc2Zvcm1lZDtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHNjYWxlKSAmJlxuICAgICAgICAgICAgICAgICFOdW1iZXIuaXNOYU4ocG9zaXRpb25YKSAmJlxuICAgICAgICAgICAgICAgICFOdW1iZXIuaXNOYU4ocG9zaXRpb25ZKSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gX3RoaXMudHJhbnNmb3JtU3RhdGUuc2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtU3RhdGUucHJldmlvdXNTY2FsZSA9IF90aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2Zvcm1TdGF0ZS5zY2FsZSA9IHNjYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy50cmFuc2Zvcm1TdGF0ZS5wb3NpdGlvblggPSBwb3NpdGlvblg7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtU3RhdGUucG9zaXRpb25ZID0gcG9zaXRpb25ZO1xuICAgICAgICAgICAgICAgIF90aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24oKTtcbiAgICAgICAgICAgICAgICB2YXIgY3R4XzEgPSBnZXRDb250ZXh0KF90aGlzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNoYW5nZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gY2FsbGJhY2soY3R4XzEpOyB9KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhjdHhfMSwgeyBzY2FsZTogc2NhbGUsIHBvc2l0aW9uWDogcG9zaXRpb25YLCBwb3NpdGlvblk6IHBvc2l0aW9uWSB9LCBvblRyYW5zZm9ybWVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZXRlY3RlZCBOYU4gc2V0IHN0YXRlIHZhbHVlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMud3JhcHBlckNvbXBvbmVudCAmJiBfdGhpcy5jb250ZW50Q29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gZ2V0Q2VudGVyUG9zaXRpb24oX3RoaXMudHJhbnNmb3JtU3RhdGUuc2NhbGUsIF90aGlzLndyYXBwZXJDb21wb25lbnQsIF90aGlzLmNvbnRlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFRyYW5zZm9ybVN0YXRlKHRhcmdldFN0YXRlLnNjYWxlLCB0YXJnZXRTdGF0ZS5wb3NpdGlvblgsIHRhcmdldFN0YXRlLnBvc2l0aW9uWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNmb3JtU3R5bGVzID0gZnVuY3Rpb24gKHgsIHksIHNjYWxlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuY3VzdG9tVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLmN1c3RvbVRyYW5zZm9ybSh4LCB5LCBzY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHJhbnNmb3JtU3R5bGVzKHgsIHksIHNjYWxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5tb3VudGVkIHx8ICFfdGhpcy5jb250ZW50Q29tcG9uZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnRyYW5zZm9ybVN0YXRlLCBzY2FsZSA9IF9hLnNjYWxlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSBfdGhpcy5oYW5kbGVUcmFuc2Zvcm1TdHlsZXMocG9zaXRpb25YLCBwb3NpdGlvblksIHNjYWxlKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRlbnRDb21wb25lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dChfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb29rc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5vbkNoYW5nZUNhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2VDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2VDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Jbml0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm9uSW5pdENhbGxiYWNrcy5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25Jbml0Q2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm9uSW5pdENhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAod3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cFdpbmRvd0V2ZW50cygpO1xuICAgICAgICAgICAgX3RoaXMud3JhcHBlckNvbXBvbmVudCA9IHdyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50Q29tcG9uZW50ID0gY29udGVudENvbXBvbmVudDtcbiAgICAgICAgICAgIGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyhfdGhpcywgX3RoaXMudHJhbnNmb3JtU3RhdGUuc2NhbGUpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlSW5pdGlhbGl6ZVdyYXBwZXJFdmVudHMod3JhcHBlckNvbXBvbmVudCk7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVJbml0aWFsaXplKHdyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZVdpbmRvd0V2ZW50cygpO1xuICAgICAgICAgICAgX3RoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgY3R4ID0gZ2V0Q29udGV4dChfdGhpcyk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhjdHgsIHVuZGVmaW5lZCwgX3RoaXMucHJvcHMub25Jbml0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnNldHVwID0gY3JlYXRlU2V0dXAodGhpcy5wcm9wcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtU3RhdGUgPSBjcmVhdGVTdGF0ZSh0aGlzLnByb3BzKTtcbiAgICB9XG4gICAgcmV0dXJuIFpvb21QYW5QaW5jaDtcbn0oKSk7XG5cbnZhciBDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBnZXRDb250ZW50ID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjdHgpIHtcbiAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuKGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbn07XG52YXIgVHJhbnNmb3JtV3JhcHBlciA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB1c2VSZWYobmV3IFpvb21QYW5QaW5jaChwcm9wcykpLmN1cnJlbnQ7XG4gICAgdmFyIGNvbnRlbnQgPSBnZXRDb250ZW50KHByb3BzLmNoaWxkcmVuLCBnZXRDb250cm9scyhpbnN0YW5jZSkpO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb250cm9scyhpbnN0YW5jZSk7IH0sIFtpbnN0YW5jZV0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZShwcm9wcyk7XG4gICAgfSwgW2luc3RhbmNlLCBwcm9wc10pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGluc3RhbmNlIH0sIGNvbnRlbnQpO1xufSk7XG5cbnZhciBLZWVwU2NhbGUgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gICAgdmFyIGxvY2FsUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciBpbnN0YW5jZSA9IHVzZUNvbnRleHQoQ29udGV4dCk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm9uQ2hhbmdlKGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgIGlmIChsb2NhbFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uWCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHBvc2l0aW9uWSA9IDA7XG4gICAgICAgICAgICAgICAgbG9jYWxSZWYuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSBpbnN0YW5jZS5oYW5kbGVUcmFuc2Zvcm1TdHlsZXMocG9zaXRpb25YLCBwb3NpdGlvblksIDEgLyBjdHguaW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbaW5zdGFuY2VdKTtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgcmVmOiBtZXJnZVJlZnMoW2xvY2FsUmVmLCByZWZdKSB9KSk7XG59KTtcblxudmFyIGluaXRpYWxFbGVtZW50UmVjdCA9IHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgeTogMCxcbiAgICB4OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbn07XG52YXIgdXNlUmVzaXplID0gZnVuY3Rpb24gKHJlZiwgb25SZXNpemUsIGRlcGVuZGVuY2llcykge1xuICAgIHZhciByZXNpemVPYnNlcnZlclJlZiA9IHVzZVJlZigpO1xuICAgIHZhciByZWN0UmVmID0gdXNlUmVmKGluaXRpYWxFbGVtZW50UmVjdCk7XG4gICAgdmFyIGRpZFVubW91bnQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgZGlkVW5tb3VudC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGlmICghKFwiUmVzaXplT2JzZXJ2ZXJcIiBpbiB3aW5kb3cpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCA9IG5ldyBSZXNpemVPYnNlcnZlcihmdW5jdGlvbiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaXplID0gcmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSB8fFxuICAgICAgICAgICAgICAgICAgICAhZW50cmllcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgZGlkVW5tb3VudC5jdXJyZW50IHx8XG4gICAgICAgICAgICAgICAgICAgIChuZXdTaXplLndpZHRoID09PSByZWN0UmVmLmN1cnJlbnQud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NpemUuaGVpZ2h0ID09PSByZWN0UmVmLmN1cnJlbnQuaGVpZ2h0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG9uUmVzaXplKG5ld1NpemUsIHJlZik7XG4gICAgICAgICAgICAgICAgcmVjdFJlZi5jdXJyZW50ID0gbmV3U2l6ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKF9hID0gcmVzaXplT2JzZXJ2ZXJSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9ic2VydmUocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgZGlkVW5tb3VudC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSByZXNpemVPYnNlcnZlclJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5vYnNlcnZlKHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBfX3NwcmVhZEFycmF5KFtvblJlc2l6ZSwgcmVmXSwgZGVwZW5kZW5jaWVzLCB0cnVlKSk7XG59O1xuXG52YXIgcHJldmlld1N0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHpJbmRleDogMixcbiAgICB0b3A6IFwiMHB4XCIsXG4gICAgbGVmdDogXCIwcHhcIixcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIGJvcmRlcjogXCIzcHggc29saWQgcmVkXCIsXG4gICAgdHJhbnNmb3JtT3JpZ2luOiBcIjAlIDAlXCIsXG4gICAgYm94U2hhZG93OiBcInJnYmEoMCwwLDAsMC4yKSAwIDAgMCAxMDAwMDAwMHB4XCIsXG59O1xudmFyIE1pbmlNYXAgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgX2IgPSBfYS53aWR0aCwgd2lkdGggPSBfYiA9PT0gdm9pZCAwID8gMjAwIDogX2IsIF9jID0gX2EuaGVpZ2h0LCBoZWlnaHQgPSBfYyA9PT0gdm9pZCAwID8gMjAwIDogX2MsIF9kID0gX2EuYm9yZGVyQ29sb3IsIGJvcmRlckNvbG9yID0gX2QgPT09IHZvaWQgMCA/IFwicmVkXCIgOiBfZCwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgcmVzdCA9IF9fcmVzdChfYSwgW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJib3JkZXJDb2xvclwiLCBcImNoaWxkcmVuXCJdKTtcbiAgICB2YXIgX2UgPSB1c2VTdGF0ZShmYWxzZSksIGluaXRpYWxpemVkID0gX2VbMF0sIHNldEluaXRpYWxpemVkID0gX2VbMV07XG4gICAgdmFyIGluc3RhbmNlID0gdXNlVHJhbnNmb3JtQ29udGV4dCgpO1xuICAgIHZhciBtaW5pTWFwSW5zdGFuY2UgPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIG1haW5SZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIHdyYXBwZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIHByZXZpZXdSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIGdldFZpZXdwb3J0U2l6ZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLndyYXBwZXJDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gaW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgIH0sIFtpbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50XSk7XG4gICAgdmFyIGdldENvbnRlbnRTaXplID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UuY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBpbnN0YW5jZS5jb250ZW50Q29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVjdC53aWR0aCAvIGluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyBpbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgIH0sIFtpbnN0YW5jZS5jb250ZW50Q29tcG9uZW50LCBpbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZV0pO1xuICAgIHZhciBjb21wdXRlTWluaU1hcFNjYWxlID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29udGVudFNpemUgPSBnZXRDb250ZW50U2l6ZSgpO1xuICAgICAgICB2YXIgc2NhbGVYID0gd2lkdGggLyBjb250ZW50U2l6ZS53aWR0aDtcbiAgICAgICAgdmFyIHNjYWxlWSA9IGhlaWdodCAvIGNvbnRlbnRTaXplLmhlaWdodDtcbiAgICAgICAgdmFyIHNjYWxlID0gc2NhbGVZID4gc2NhbGVYID8gc2NhbGVYIDogc2NhbGVZO1xuICAgICAgICByZXR1cm4gc2NhbGU7XG4gICAgfSwgW2dldENvbnRlbnRTaXplLCBoZWlnaHQsIHdpZHRoXSk7XG4gICAgdmFyIGNvbXB1dGVNaW5pTWFwU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRlbnRTaXplID0gZ2V0Q29udGVudFNpemUoKTtcbiAgICAgICAgdmFyIHNjYWxlWCA9IHdpZHRoIC8gY29udGVudFNpemUud2lkdGg7XG4gICAgICAgIHZhciBzY2FsZVkgPSBoZWlnaHQgLyBjb250ZW50U2l6ZS5oZWlnaHQ7XG4gICAgICAgIGlmIChzY2FsZVkgPiBzY2FsZVgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBjb250ZW50U2l6ZS5oZWlnaHQgKiBzY2FsZVggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB3aWR0aDogY29udGVudFNpemUud2lkdGggKiBzY2FsZVksIGhlaWdodDogaGVpZ2h0IH07XG4gICAgfTtcbiAgICB2YXIgY29tcHV0ZU1pbmlNYXBTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gY29tcHV0ZU1pbmlNYXBTY2FsZSgpO1xuICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwic2NhbGUoXCIuY29uY2F0KHNjYWxlIHx8IDEsIFwiKVwiKSxcbiAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogXCIwJSAwJVwiLFxuICAgICAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICB6SW5kZXg6IDEsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgfTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHdyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZXJSZWYuY3VycmVudC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtTWluaU1hcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tcHV0ZU1pbmlNYXBTdHlsZSgpO1xuICAgICAgICB2YXIgbWluaVNpemUgPSBjb21wdXRlTWluaU1hcFNpemUoKTtcbiAgICAgICAgdmFyIHdyYXBTaXplID0gZ2V0Q29udGVudFNpemUoKTtcbiAgICAgICAgaWYgKHdyYXBwZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgd3JhcHBlclJlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gXCJcIi5jb25jYXQod3JhcFNpemUud2lkdGgsIFwicHhcIik7XG4gICAgICAgICAgICB3cmFwcGVyUmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQod3JhcFNpemUuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYWluUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG1haW5SZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KG1pbmlTaXplLndpZHRoLCBcInB4XCIpO1xuICAgICAgICAgICAgbWFpblJlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KG1pbmlTaXplLmhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlld1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gY29tcHV0ZU1pbmlNYXBTY2FsZSgpO1xuICAgICAgICAgICAgdmFyIHByZXZpZXdTY2FsZSA9IHNjYWxlICogKDEgLyBpbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZSk7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gaW5zdGFuY2UuaGFuZGxlVHJhbnNmb3JtU3R5bGVzKC1pbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5wb3NpdGlvblggKiBwcmV2aWV3U2NhbGUsIC1pbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5wb3NpdGlvblkgKiBwcmV2aWV3U2NhbGUsIDEpO1xuICAgICAgICAgICAgcHJldmlld1JlZi5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgICAgIHByZXZpZXdSZWYuY3VycmVudC5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KHNpemUud2lkdGggKiBwcmV2aWV3U2NhbGUsIFwicHhcIik7XG4gICAgICAgICAgICBwcmV2aWV3UmVmLmN1cnJlbnQuc3R5bGUuaGVpZ2h0ID0gXCJcIi5jb25jYXQoc2l6ZS5oZWlnaHQgKiBwcmV2aWV3U2NhbGUsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFuc2Zvcm1NaW5pTWFwKCk7XG4gICAgfTtcbiAgICB1c2VUcmFuc2Zvcm1FZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cmFuc2Zvcm1NaW5pTWFwKCk7XG4gICAgfSk7XG4gICAgdXNlVHJhbnNmb3JtSW5pdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluaXRpYWxpemUoKTtcbiAgICAgICAgc2V0SW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgfSk7XG4gICAgdXNlUmVzaXplKGluc3RhbmNlLmNvbnRlbnRDb21wb25lbnQsIGluaXRpYWxpemUsIFtpbml0aWFsaXplZF0pO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5vbkNoYW5nZShmdW5jdGlvbiAoenBwKSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSBjb21wdXRlTWluaU1hcFNjYWxlKCk7XG4gICAgICAgICAgICBpZiAobWluaU1hcEluc3RhbmNlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBtaW5pTWFwSW5zdGFuY2UuY3VycmVudC5pbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZSA9XG4gICAgICAgICAgICAgICAgICAgIHpwcC5pbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICAgICAgICAgICAgICBtaW5pTWFwSW5zdGFuY2UuY3VycmVudC5pbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5wb3NpdGlvblggPVxuICAgICAgICAgICAgICAgICAgICB6cHAuaW5zdGFuY2UudHJhbnNmb3JtU3RhdGUucG9zaXRpb25YICogc2NhbGU7XG4gICAgICAgICAgICAgICAgbWluaU1hcEluc3RhbmNlLmN1cnJlbnQuaW5zdGFuY2UudHJhbnNmb3JtU3RhdGUucG9zaXRpb25ZID1cbiAgICAgICAgICAgICAgICAgICAgenBwLmluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnBvc2l0aW9uWSAqIHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBbY29tcHV0ZU1pbmlNYXBTY2FsZSwgaW5zdGFuY2UsIG1pbmlNYXBJbnN0YW5jZV0pO1xuICAgIHZhciB3cmFwcGVyU3R5bGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCByZXN0LCB7IHJlZjogbWFpblJlZiwgc3R5bGU6IHdyYXBwZXJTdHlsZSwgY2xhc3NOYW1lOiBcInJ6cHAtbWluaS1tYXAgXCIuY29uY2F0KHJlc3QuY2xhc3NOYW1lIHx8IFwiXCIpIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCByZXN0LCB7IHJlZjogd3JhcHBlclJlZiwgY2xhc3NOYW1lOiBcInJ6cHAtd3JhcHBlclwiIH0pLCBjaGlsZHJlbiksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicnpwcC1wcmV2aWV3XCIsIHJlZjogcHJldmlld1JlZiwgc3R5bGU6IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2aWV3U3R5bGVzKSwgeyBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IgfSkgfSkpKTtcbn07XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIudHJhbnNmb3JtLWNvbXBvbmVudC1tb2R1bGVfd3JhcHBlcl9fU1BCODYge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XFxuICB3aWR0aDogZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEtvbnF1ZXJvciBIVE1MICovXFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxufVxcbi50cmFuc2Zvcm0tY29tcG9uZW50LW1vZHVsZV9jb250ZW50X19GQld4byB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC13cmFwOiB3cmFwO1xcbiAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XFxuICB3aWR0aDogZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIHRyYW5zZm9ybS1vcmlnaW46IDAlIDAlO1xcbn1cXG4udHJhbnNmb3JtLWNvbXBvbmVudC1tb2R1bGVfY29udGVudF9fRkJXeG8gaW1nIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cIjtcbnZhciBzdHlsZXMgPSB7XCJ3cmFwcGVyXCI6XCJ0cmFuc2Zvcm0tY29tcG9uZW50LW1vZHVsZV93cmFwcGVyX19TUEI4NlwiLFwiY29udGVudFwiOlwidHJhbnNmb3JtLWNvbXBvbmVudC1tb2R1bGVfY29udGVudF9fRkJXeG9cIn07XG5zdHlsZUluamVjdChjc3NfMjQ4eik7XG5cbnZhciBUcmFuc2Zvcm1Db21wb25lbnQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgX2IgPSBfYS53cmFwcGVyQ2xhc3MsIHdyYXBwZXJDbGFzcyA9IF9iID09PSB2b2lkIDAgPyBcIlwiIDogX2IsIF9jID0gX2EuY29udGVudENsYXNzLCBjb250ZW50Q2xhc3MgPSBfYyA9PT0gdm9pZCAwID8gXCJcIiA6IF9jLCB3cmFwcGVyU3R5bGUgPSBfYS53cmFwcGVyU3R5bGUsIGNvbnRlbnRTdHlsZSA9IF9hLmNvbnRlbnRTdHlsZSwgX2QgPSBfYS53cmFwcGVyUHJvcHMsIHdyYXBwZXJQcm9wcyA9IF9kID09PSB2b2lkIDAgPyB7fSA6IF9kLCBfZSA9IF9hLmNvbnRlbnRQcm9wcywgY29udGVudFByb3BzID0gX2UgPT09IHZvaWQgMCA/IHt9IDogX2U7XG4gICAgdmFyIF9mID0gdXNlQ29udGV4dChDb250ZXh0KSwgaW5pdCA9IF9mLmluaXQsIGNsZWFudXBXaW5kb3dFdmVudHMgPSBfZi5jbGVhbnVwV2luZG93RXZlbnRzO1xuICAgIHZhciB3cmFwcGVyUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciBjb250ZW50UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0gd3JhcHBlclJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgY29udGVudCA9IGNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHdyYXBwZXIgIT09IG51bGwgJiYgY29udGVudCAhPT0gbnVsbCAmJiBpbml0KSB7XG4gICAgICAgICAgICBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQod3JhcHBlciwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xlYW51cFdpbmRvd0V2ZW50cyA9PT0gbnVsbCB8fCBjbGVhbnVwV2luZG93RXZlbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGVhbnVwV2luZG93RXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgd3JhcHBlclByb3BzLCB7IHJlZjogd3JhcHBlclJlZiwgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChiYXNlQ2xhc3Nlcy53cmFwcGVyQ2xhc3MsIFwiIFwiKS5jb25jYXQoc3R5bGVzLndyYXBwZXIsIFwiIFwiKS5jb25jYXQod3JhcHBlckNsYXNzKSwgc3R5bGU6IHdyYXBwZXJTdHlsZSB9KSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgY29udGVudFByb3BzLCB7IHJlZjogY29udGVudFJlZiwgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChiYXNlQ2xhc3Nlcy5jb250ZW50Q2xhc3MsIFwiIFwiKS5jb25jYXQoc3R5bGVzLmNvbnRlbnQsIFwiIFwiKS5jb25jYXQoY29udGVudENsYXNzKSwgc3R5bGU6IGNvbnRlbnRTdHlsZSB9KSwgY2hpbGRyZW4pKSk7XG59O1xuXG52YXIgdXNlVHJhbnNmb3JtQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlicmFyeUNvbnRleHQgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAgIGlmICghbGlicmFyeUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmb3JtIGNvbnRleHQgbXVzdCBiZSBwbGFjZWQgaW5zaWRlIFRyYW5zZm9ybVdyYXBwZXJcIik7XG4gICAgfVxuICAgIHJldHVybiBsaWJyYXJ5Q29udGV4dDtcbn07XG5cbnZhciB1c2VDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlicmFyeUNvbnRleHQgPSB1c2VUcmFuc2Zvcm1Db250ZXh0KCk7XG4gICAgcmV0dXJuIGdldENvbnRyb2xzKGxpYnJhcnlDb250ZXh0KTtcbn07XG5cbnZhciB1c2VUcmFuc2Zvcm1Jbml0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpYnJhcnlDb250ZXh0ID0gdXNlVHJhbnNmb3JtQ29udGV4dCgpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bm1vdW50Q2FsbGJhY2s7XG4gICAgICAgIHZhciB1bm1vdW50O1xuICAgICAgICBpZiAobGlicmFyeUNvbnRleHQuY29udGVudENvbXBvbmVudCAmJiBsaWJyYXJ5Q29udGV4dC53cmFwcGVyQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB1bm1vdW50Q2FsbGJhY2sgPSBjYWxsYmFjayhnZXRTdGF0ZShsaWJyYXJ5Q29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5tb3VudCA9IGxpYnJhcnlDb250ZXh0Lm9uSW5pdChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICAgICAgdW5tb3VudENhbGxiYWNrID0gY2FsbGJhY2soZ2V0U3RhdGUocmVmLmluc3RhbmNlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW5tb3VudCA9PT0gbnVsbCB8fCB1bm1vdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bm1vdW50KCk7XG4gICAgICAgICAgICB1bm1vdW50Q2FsbGJhY2sgPT09IG51bGwgfHwgdW5tb3VudENhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1bm1vdW50Q2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG59O1xuXG52YXIgdXNlVHJhbnNmb3JtRWZmZWN0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpYnJhcnlDb250ZXh0ID0gdXNlVHJhbnNmb3JtQ29udGV4dCgpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1bm1vdW50Q2FsbGJhY2s7XG4gICAgICAgIHZhciB1bm1vdW50ID0gbGlicmFyeUNvbnRleHQub25DaGFuZ2UoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgdW5tb3VudENhbGxiYWNrID0gY2FsbGJhY2soZ2V0U3RhdGUocmVmLmluc3RhbmNlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICAgICAgdW5tb3VudENhbGxiYWNrID09PSBudWxsIHx8IHVubW91bnRDYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5tb3VudENhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGxiYWNrLCBsaWJyYXJ5Q29udGV4dF0pO1xufTtcblxuZnVuY3Rpb24gdXNlVHJhbnNmb3JtQ29tcG9uZW50KGNhbGxiYWNrKSB7XG4gICAgdmFyIGxpYnJhcnlDb250ZXh0ID0gdXNlVHJhbnNmb3JtQ29udGV4dCgpO1xuICAgIHZhciBfYSA9IHVzZVN0YXRlKGNhbGxiYWNrKGdldFN0YXRlKGxpYnJhcnlDb250ZXh0KSkpLCB0cmFuc2Zvcm1SZW5kZXIgPSBfYVswXSwgc2V0VHJhbnNmb3JtUmVuZGVyID0gX2FbMV07XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdW5tb3VudCA9IGxpYnJhcnlDb250ZXh0Lm9uQ2hhbmdlKGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgc2V0VHJhbnNmb3JtUmVuZGVyKGNhbGxiYWNrKGdldFN0YXRlKHJlZi5pbnN0YW5jZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB1bm1vdW50KCk7XG4gICAgICAgICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW2NhbGxiYWNrLCBsaWJyYXJ5Q29udGV4dF0pO1xuICAgIHJldHVybiB0cmFuc2Zvcm1SZW5kZXI7XG59XG5cbmV4cG9ydCB7IENvbnRleHQsIEtlZXBTY2FsZSwgTWluaU1hcCwgVHJhbnNmb3JtQ29tcG9uZW50LCBUcmFuc2Zvcm1XcmFwcGVyLCBnZXRDZW50ZXJQb3NpdGlvbiwgZ2V0TWF0cml4VHJhbnNmb3JtU3R5bGVzLCBnZXRUcmFuc2Zvcm1TdHlsZXMsIHVzZUNvbnRyb2xzLCB1c2VUcmFuc2Zvcm1Db21wb25lbnQsIHVzZVRyYW5zZm9ybUNvbnRleHQsIHVzZVRyYW5zZm9ybUVmZmVjdCwgdXNlVHJhbnNmb3JtSW5pdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/react-zoom-pan-pinch/dist/index.esm.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/index.js":
/*!*****************************************************!*\
  !*** ./pages/collected-dataset-customized/index.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollectedDatasetPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"(pages-dir-browser)/./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_gui_topBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components-gui/topBar */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/topBar.js\");\n/* harmony import */ var _components_gui_displayResponse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components-gui/displayResponse */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/displayResponse.js\");\n/* harmony import */ var _components_gui_actionButton__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components-gui/actionButton */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\");\n/* harmony import */ var _components_Settings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/Settings */ \"(pages-dir-browser)/./components/Settings.js\");\n/* harmony import */ var _components_gui_Action_countSave__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components-gui/Action/countSave */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Action/countSave.js\");\n/* harmony import */ var _components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../components/consent/ConsentContext */ \"(pages-dir-browser)/./components/consent/ConsentContext.js\");\n// Modified index.js - Fixing canvas reference issues\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// import StatusIndicator from './components-gui/StatusIndicator';\n\n\n// Dynamically load the video processor component (not the hook directly)\nconst VideoProcessorComponent = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_pages_collected-dataset-customized_components-gui_VideoProcessorComponent_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/VideoProcessorComponent */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/VideoProcessorComponent.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"pages/collected-dataset-customized/index.js -> \" + \"./components-gui/VideoProcessorComponent\"\n        ]\n    },\n    ssr: false\n});\n_c = VideoProcessorComponent;\n// Dynamically import the camera component with SSR disabled\nconst DynamicCameraAccess = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_pages_collected-dataset-customized_components-gui_cameraAccess_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/cameraAccess */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/cameraAccess.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"pages/collected-dataset-customized/index.js -> \" + \"./components-gui/cameraAccess\"\n        ]\n    },\n    ssr: false,\n    loading: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                position: 'absolute',\n                top: '50%',\n                left: '50%',\n                transform: 'translate(-50%, -50%)',\n                width: '480px',\n                height: '360px',\n                backgroundColor: '#f0f8ff',\n                border: '2px solid #0066cc',\n                borderRadius: '8px',\n                display: 'flex',\n                flexDirection: 'column',\n                justifyContent: 'center',\n                alignItems: 'center',\n                textAlign: 'center',\n                zIndex: 999\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        fontSize: '48px',\n                        marginBottom: '15px'\n                    },\n                    children: \"\\uD83D\\uDCF7\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 42,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    style: {\n                        fontSize: '16px',\n                        fontWeight: 'bold',\n                        color: '#0066cc'\n                    },\n                    children: \"Loading camera...\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n            lineNumber: 25,\n            columnNumber: 7\n        }, undefined)\n});\n_c1 = DynamicCameraAccess;\nfunction CollectedDatasetPage() {\n    _s();\n    // State for hydration detection\n    const [isHydrated, setIsHydrated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // State for camera management\n    const [showCamera, setShowCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showTopBar, setShowTopBar] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showMetrics, setShowMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [outputText, setOutputText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [metrics, setMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: '---',\n        height: '---',\n        distance: '---'\n    });\n    const [windowSize, setWindowSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0,\n        percentage: 100\n    });\n    // References and other state\n    const previewAreaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // State for capture tracking\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [captureFolder, setCaptureFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // State for camera processing options\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // State to track if camera square should be shown\n    const [showCameraPlaceholder, setShowCameraPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // To store the camera permission state\n    const [cameraPermissionGranted, setCameraPermissionGranted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // State for warning message\n    const [showWarning, setShowWarning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [warningMessage, setWarningMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Backend connection status\n    const [backendStatus, setBackendStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('checking');\n    const actionButtonGroupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [statusMessage, setStatusMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // State for settings visibility\n    const [showSettings, setShowSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Improved get canvas function that tries multiple methods\n    const getMainCanvas = ()=>{\n        // Method 1: Check if we have a direct reference\n        if (canvasRef.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef.current;\n        }\n        // Method 2: Try to get global reference\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef.current = window.whiteScreenCanvas; // Update our ref\n            return window.whiteScreenCanvas;\n        }\n        // Method 3: Try to find via DOM\n        if (typeof document !== 'undefined') {\n            const canvasElement = document.querySelector('.tracking-canvas');\n            if (canvasElement) {\n                console.log(\"Found canvas via DOM selector\");\n                canvasRef.current = canvasElement; // Update our ref\n                if (true) {\n                    window.whiteScreenCanvas = canvasElement; // Update global ref too\n                }\n                return canvasElement;\n            }\n        }\n        console.warn(\"No canvas found via any method\");\n        return null;\n    };\n    // Check if we're on the client or server\n    const isClient = \"object\" !== 'undefined';\n    // Add effect to initialize canvas and make it globally available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Debug info to verify canvas size and availability\n            const canvas = canvasRef.current;\n            if (canvas) {\n                console.log(\"Index.js: Canvas initialized\", {\n                    width: canvas.width,\n                    height: canvas.height\n                });\n                // Make canvas EXPLICITLY available globally\n                window.whiteScreenCanvas = canvas;\n                // Also store canvas dimensions\n                window.canvasDimensions = {\n                    width: canvas.width,\n                    height: canvas.height\n                };\n            } else {\n                console.warn(\"Canvas reference is not available during initialization\");\n            }\n            // Expose canvas initialization function globally\n            window.initializeCanvas = ({\n                \"CollectedDatasetPage.useEffect\": (canvas, parent)=>{\n                    if (!canvas || !parent) {\n                        console.warn('[initializeCanvas] Canvas or parent is null', {\n                            canvas,\n                            parent\n                        });\n                        return false;\n                    }\n                    try {\n                        // Set canvas dimensions to match parent\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                        // Clear canvas and set white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        console.log(\"Canvas initialized with dimensions: \".concat(canvas.width, \"x\").concat(canvas.height));\n                        // Update global reference\n                        window.whiteScreenCanvas = canvas;\n                        window.canvasDimensions = {\n                            width: canvas.width,\n                            height: canvas.height\n                        };\n                        return true;\n                    } catch (error) {\n                        console.error('[initializeCanvas] Error initializing canvas:', error);\n                        return false;\n                    }\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n            // Check canvas visibility and force initialization after a brief delay\n            setTimeout({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    const canvas = getMainCanvas();\n                    if (canvas) {\n                        const rect = canvas.getBoundingClientRect();\n                        console.log(\"Canvas initial visibility check:\", {\n                            dimensions: \"\".concat(canvas.width, \"x\").concat(canvas.height),\n                            rectSize: \"\".concat(rect.width, \"x\").concat(rect.height),\n                            isVisible: rect.width > 0 && rect.height > 0\n                        });\n                        // Force initialization if needed\n                        adjustCanvasDimensions();\n                    } else {\n                        console.warn(\"Canvas not found during visibility check\");\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect\"], 500);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    delete window.whiteScreenCanvas;\n                    delete window.canvasDimensions;\n                    delete window.initializeCanvas;\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Improved canvas dimensions adjustment\n    const adjustCanvasDimensions = ()=>{\n        if (!isClient || !isHydrated || !previewAreaRef.current) return;\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found to adjust dimensions\");\n            return;\n        }\n        const container = previewAreaRef.current;\n        // Get the size of the preview area\n        const rect = container.getBoundingClientRect();\n        // Calculate proper height based on top bar visibility\n        const topBarHeight = showTopBar ? 120 : 0; // Adjust this value based on your top bar's actual height\n        console.log(\"Adjusting canvas dimensions\", {\n            containerWidth: rect.width,\n            containerHeight: rect.height,\n            topBarVisible: showTopBar,\n            calculatedHeight: rect.height\n        });\n        // Set canvas dimensions to match container size with top bar adjustment\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n        // Clear the canvas\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Fill with white background\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas dimensions adjusted: \".concat(canvas.width, \"x\").concat(canvas.height));\n        // Update global reference with current dimensions\n        window.whiteScreenCanvas = canvas;\n        window.canvasDimensions = {\n            width: canvas.width,\n            height: canvas.height\n        };\n    };\n    // Create a capture folder on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!captureFolder && isClient && isHydrated) {\n                const timestamp = new Date().toISOString().replace(/[:\\.]/g, '-');\n                setCaptureFolder(\"session_\".concat(timestamp));\n                console.log(\"Created capture folder: session_\".concat(timestamp));\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        captureFolder,\n        isClient,\n        isHydrated\n    ]);\n    // Set hydrated state after mount to prevent hydration mismatch\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            setIsHydrated(true);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Check backend connection on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return; // Skip on server or before hydration\n            const checkBackendConnection = {\n                \"CollectedDatasetPage.useEffect.checkBackendConnection\": async ()=>{\n                    try {\n                        const response = await fetch('/api/check-backend-connection');\n                        const data = await response.json();\n                        setBackendStatus(data.connected ? 'connected' : 'disconnected');\n                        console.log(\"Backend connection: \".concat(data.connected ? 'OK' : 'Failed'));\n                        // Show status in output text\n                        setOutputText(\"Backend \".concat(data.connected ? 'connected' : 'disconnected - using mock mode'));\n                    } catch (error) {\n                        console.error('Error checking backend connection:', error);\n                        setBackendStatus('disconnected');\n                        setOutputText('Backend disconnected - using mock mode');\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.checkBackendConnection\"];\n            checkBackendConnection();\n            // Welcome message after backend check\n            setTimeout({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    setOutputText('Camera system ready. Click \"Show Preview\" to start camera.');\n                }\n            }[\"CollectedDatasetPage.useEffect\"], 2000);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Update metrics and window size when component mounts and on window resize\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return; // Skip on server or before hydration\n            const updateDimensions = {\n                \"CollectedDatasetPage.useEffect.updateDimensions\": ()=>{\n                    if (previewAreaRef.current) {\n                        const width = previewAreaRef.current.offsetWidth;\n                        const height = previewAreaRef.current.offsetHeight;\n                        // Calculate what percentage of the screen we're using\n                        const screenPercentage = window.innerWidth / window.screen.width * 100;\n                        setMetrics({\n                            \"CollectedDatasetPage.useEffect.updateDimensions\": (prev)=>({\n                                    ...prev,\n                                    width,\n                                    height\n                                })\n                        }[\"CollectedDatasetPage.useEffect.updateDimensions\"]);\n                        setWindowSize({\n                            width: window.innerWidth,\n                            height: window.innerHeight,\n                            percentage: Math.round(screenPercentage)\n                        });\n                        // Update canvas dimensions\n                        adjustCanvasDimensions();\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.updateDimensions\"];\n            // Initial calculation\n            updateDimensions();\n            window.addEventListener('resize', updateDimensions);\n            // Clean up\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('resize', updateDimensions);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Add effect to update canvas when dimensions change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (isClient && isHydrated) {\n                adjustCanvasDimensions();\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        windowSize,\n        showTopBar,\n        isHydrated\n    ]);\n    // Add styles to document head for button highlighting\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Create a style element\n            const style = document.createElement('style');\n            style.textContent = \"\\n      @keyframes pulse {\\n        0% { box-shadow: 0 0 0 0 rgba(0, 102, 204, 0.7); }\\n        70% { box-shadow: 0 0 0 10px rgba(0, 102, 204, 0); }\\n        100% { box-shadow: 0 0 0 0 rgba(0, 102, 204, 0); }\\n      }\\n      \\n      @keyframes fadeIn {\\n        from { opacity: 0; transform: translateY(-10px); }\\n        to { opacity: 1; transform: translateY(0); }\\n      }\\n      \\n      .btn-highlight {\\n        animation: pulse 1.5s infinite;\\n        background-color: #0099ff !important;\\n        color: white !important;\\n        transform: scale(1.05);\\n        transition: all 0.3s ease;\\n      }\\n      \\n      .warning-banner {\\n        animation: fadeIn 0.3s ease-in-out;\\n      }\\n    \";\n            document.head.appendChild(style);\n            // Clean up\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    document.head.removeChild(style);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Make toggleTopBar function available globally\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Make toggleTopBar available to other components\n            window.toggleTopBar = ({\n                \"CollectedDatasetPage.useEffect\": (show)=>{\n                    setShowTopBar(show);\n                    // Also hide metrics when hiding the top bar\n                    if (!show) {\n                        setShowMetrics(false);\n                    }\n                    // Adjust canvas dimensions after toggling\n                    setTimeout(adjustCanvasDimensions, 100);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    // Clean up\n                    delete window.toggleTopBar;\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Toggle camera function\n    const toggleCamera = (shouldEnable)=>{\n        if (!isClient || !isHydrated) return;\n        if (shouldEnable) {\n            setShowCamera(true);\n            setShowCameraPlaceholder(false);\n            setOutputText('Camera preview started');\n        } else {\n            setShowCamera(false);\n            setShowCameraPlaceholder(false);\n            setOutputText('Camera preview stopped');\n        }\n    };\n    // Handler for action button clicks\n    const handleActionButtonClick = (actionType, params)=>{\n        if (!isClient || !isHydrated) return;\n        // Special case for toggling the top bar\n        if (actionType === 'toggleTopBar') {\n            // const newTopBarState = value !== undefined ? !!value : !showTopBar;\n            let newTopBarState;\n            if (typeof params === 'boolean') {\n                newTopBarState = params;\n            } else if (params && typeof params.value !== 'undefined') {\n                newTopBarState = !!params.value;\n            } else {\n                newTopBarState = !showTopBar;\n            }\n            setShowTopBar(newTopBarState);\n            // Also hide metrics when hiding the top bar\n            if (!newTopBarState) {\n                setShowMetrics(false);\n            }\n            setOutputText(\"TopBar \".concat(newTopBarState ? 'shown' : 'hidden').concat(!newTopBarState ? ', Metrics hidden' : ''));\n            // Adjust canvas dimensions after toggling\n            setTimeout(adjustCanvasDimensions, 100);\n            return;\n        }\n        const canvas = getMainCanvas();\n        setShowWarning(false);\n        // Clear any existing warnings\n        const safeParams = params || {};\n        // Use safeParams instead of controlValues\n        const randomTimes = safeParams.randomTimes || 1;\n        const delaySeconds = safeParams.delaySeconds || 3;\n        switch(actionType){\n            case 'preview':\n                // Toggle camera state\n                if (showCamera) {\n                    toggleCamera(false);\n                } else if (cameraPermissionGranted) {\n                    toggleCamera(true);\n                } else {\n                    // Otherwise show permission popup\n                    setShowPermissionPopup(true);\n                    setOutputText('Opening camera preview');\n                    setShowCameraPlaceholder(true);\n                }\n                break;\n            case 'setRandom':\n                setOutputText('Starting random sequence...');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                // Use the imported module approach - similar to calibrate\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleSetRandom) {\n                    // Use the reference method if available\n                    console.log('Using ActionButtonGroup ref method for Set Random');\n                    actionButtonGroupRef.current.handleSetRandom();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleSetRandom === 'function') {\n                    // Fallback to global method\n                    console.log('Using global bridge method for Set Random');\n                    window.actionButtonFunctions.handleSetRandom();\n                } else {\n                    // Make sure we have a canvas to work with\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for random sequence\");\n                        setOutputText(\"Error: Canvas not available for random sequence\");\n                        setShowTopBar(true);\n                        return;\n                    }\n                    // Get control values from the TopBar\n                    const timeInput = document.querySelector('.control-input-field');\n                    const delayInput = document.querySelectorAll('.control-input-field')[1];\n                    // Default values if inputs can't be found\n                    let times = 1;\n                    let delay = 3;\n                    // Parse input values if available\n                    if (timeInput) {\n                        const parsedTime = parseInt(timeInput.value, 10);\n                        if (!isNaN(parsedTime) && parsedTime > 0) {\n                            times = parsedTime;\n                        }\n                    }\n                    if (delayInput) {\n                        const parsedDelay = parseInt(delayInput.value, 10);\n                        if (!isNaN(parsedDelay) && parsedDelay > 0) {\n                            delay = parsedDelay;\n                        }\n                    }\n                    // Load all required modules first, then proceed with execution\n                    Promise.all([\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/Action/countSave */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Action/countSave.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/Helper/savefile */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Helper/savefile.js\"))\n                    ]).then(async (param)=>{\n                        let [countSaveModule, savefileModule] = param;\n                        // Destructure the imported modules\n                        const { getRandomPosition, drawRedDot, runCountdown, showCapturePreview } = countSaveModule;\n                        const { captureImagesAtPoint } = savefileModule;\n                        try {\n                            // Process all captures sequentially\n                            let successCount = 0;\n                            let currentCapture = 1;\n                            while(currentCapture <= times){\n                                // Update status for current capture\n                                setOutputText(\"Capture \".concat(currentCapture, \" of \").concat(times));\n                                // Clear canvas before each capture\n                                const ctx = canvas.getContext('2d');\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                // Generate random position for this capture\n                                const position = getRandomPosition(canvas, 20);\n                                // Draw the dot\n                                drawRedDot(ctx, position.x, position.y);\n                                // Create a redrawInterval to ensure dot stays visible\n                                let redrawInterval = setInterval(()=>{\n                                    drawRedDot(ctx, position.x, position.y, 12, false);\n                                }, 200);\n                                // Run countdown and wait for it to complete\n                                await new Promise((resolve)=>{\n                                    runCountdown(position, canvas, (status)=>{\n                                        // Update UI based on status\n                                        if (status.processStatus) {\n                                            setOutputText(\"Capture \".concat(currentCapture, \"/\").concat(times, \": \").concat(status.processStatus));\n                                        }\n                                    }, resolve // This will be called when countdown completes\n                                    );\n                                });\n                                // Clear redrawInterval after countdown\n                                clearInterval(redrawInterval);\n                                // Wait briefly after countdown\n                                await new Promise((resolve)=>setTimeout(resolve, 500));\n                                // Capture images at this point\n                                try {\n                                    const captureResult = await captureImagesAtPoint({\n                                        point: position,\n                                        captureCount: captureCounter,\n                                        canvasRef: {\n                                            current: canvas\n                                        },\n                                        setCaptureCount: setCaptureCounter,\n                                        showCapturePreview\n                                    });\n                                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                        successCount++;\n                                    }\n                                    // Increment counter\n                                    setCaptureCounter((prev)=>prev + 1);\n                                } catch (error) {\n                                    console.error(\"Error capturing point \".concat(currentCapture, \":\"), error);\n                                }\n                                // Wait between captures for the specified delay time\n                                if (currentCapture < times) {\n                                    setOutputText(\"Waiting \".concat(delay, \"s before next capture...\"));\n                                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                                }\n                                // Move to next capture\n                                currentCapture++;\n                            }\n                            // Sequence complete\n                            setOutputText(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n                        } catch (error) {\n                            console.error(\"Random sequence error:\", error);\n                            setOutputText(\"Random sequence error: \".concat(error.message));\n                        } finally{\n                            // Show TopBar again\n                            setTimeout(()=>setShowTopBar(true), 2000);\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to import required modules:\", error);\n                        setOutputText(\"Error: \".concat(error.message));\n                        setShowTopBar(true);\n                    });\n                }\n                break;\n            case 'randomDot':\n                setOutputText('Random dot action triggered');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                console.log('Attempting to access Random Dot functionality');\n                // Use the random dot functionality from actionButton.js by delegating to ActionButtonGroup\n                // This assumes you have a ref to the ActionButtonGroup component\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleRandomDot) {\n                    console.log('Using ref method');\n                    actionButtonGroupRef.current.handleRandomDot();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleRandomDot === 'function') {\n                    console.log('Using global bridge method');\n                    window.actionButtonFunctions.handleRandomDot();\n                } else {\n                    // Fallback implementation\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for random dot action\");\n                        setOutputText(\"Error: Canvas not available for random dot\");\n                        setShowTopBar(true); // Show TopBar again if there's an error\n                        break;\n                    }\n                    const parent = previewAreaRef.current;\n                    if (!parent) {\n                        console.error(\"Parent not found for canvas\");\n                        setOutputText(\"Error: Canvas parent not available\");\n                        setShowTopBar(true);\n                        break;\n                    }\n                    // Initialize canvas explicitly\n                    canvas.width = parent.clientWidth || 800;\n                    canvas.height = parent.clientHeight || 600;\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas ready for random dot: \".concat(canvas.width, \"x\").concat(canvas.height));\n                    // Update global reference\n                    window.whiteScreenCanvas = canvas;\n                    // Generate random position\n                    const position = (0,_components_gui_Action_countSave__WEBPACK_IMPORTED_MODULE_8__.getRandomPosition)(canvas, 20);\n                    // Draw the dot using the imported function\n                    const dot = (0,_components_gui_Action_countSave__WEBPACK_IMPORTED_MODULE_8__.drawRedDot)(ctx, position.x, position.y, 8, false);\n                    console.log(\"Random dot drawn at: \".concat(position.x, \", \").concat(position.y));\n                    // Start a countdown for capture\n                    (0,_components_gui_Action_countSave__WEBPACK_IMPORTED_MODULE_8__.runCountdown)(position, canvas, (status)=>{\n                        // Update UI based on status\n                        if (status.processStatus) {\n                            setOutputText(status.processStatus);\n                        }\n                    }, ()=>{\n                        // Enable camera before capture\n                        // triggerCameraAccess(true);\n                        // Wait briefly for camera to initialize\n                        setTimeout(()=>{\n                            // Use the directly imported captureImagesAtPoint from the Helper/savefile.js\n                            Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/Helper/savefile */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Helper/savefile.js\")).then((param)=>{\n                                let { captureImagesAtPoint } = param;\n                                captureImagesAtPoint({\n                                    point: position,\n                                    captureCount: captureCounter,\n                                    canvasRef: {\n                                        current: canvas\n                                    },\n                                    setCaptureCount: setCaptureCounter,\n                                    showCapturePreview: _components_gui_Action_countSave__WEBPACK_IMPORTED_MODULE_8__.showCapturePreview\n                                }).then(()=>{\n                                    setCaptureCounter((prev)=>prev + 1);\n                                    // Show TopBar again after capture\n                                    setTimeout(()=>{\n                                        setShowTopBar(true);\n                                    }, 2200);\n                                }).catch((err)=>{\n                                    console.error(\"Error capturing images:\", err);\n                                    setOutputText(\"Error: \".concat(err.message));\n                                    setShowTopBar(true);\n                                });\n                            }).catch((err)=>{\n                                console.error(\"Error importing savefile module:\", err);\n                                setOutputText(\"Error: \".concat(err.message));\n                                setShowTopBar(true);\n                            });\n                        }, 500);\n                    });\n                }\n                break;\n            case 'headPose':\n                const newHeadPoseState = !showHeadPose;\n                setShowHeadPose(newHeadPoseState);\n                setOutputText(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n                if (newHeadPoseState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newHeadPoseState && !showBoundingBox && !showMask && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showHeadPose: newHeadPoseState\n                    });\n                }\n                break;\n            case 'boundingBox':\n                const newBoundingBoxState = !showBoundingBox;\n                setShowBoundingBox(newBoundingBoxState);\n                setOutputText(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n                if (newBoundingBoxState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newBoundingBoxState && !showHeadPose && !showMask && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showBoundingBox: newBoundingBoxState\n                    });\n                }\n                break;\n            case 'mask':\n                const newMaskState = !showMask;\n                setShowMask(newMaskState);\n                setOutputText(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n                if (newMaskState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newMaskState && !showHeadPose && !showBoundingBox && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showMask: newMaskState\n                    });\n                }\n                break;\n            case 'parameters':\n                const newParametersState = !showParameters;\n                setShowParameters(newParametersState);\n                setOutputText(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n                if (newParametersState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newParametersState && !showHeadPose && !showBoundingBox && !showMask) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showParameters: newParametersState\n                    });\n                }\n                break;\n            // Fixed calibrate case handler in index.js\n            case 'calibrate':\n                setOutputText('Starting calibration sequence...');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleSetCalibrate) {\n                    // Use the reference method if available\n                    console.log('Using ActionButtonGroup ref method for calibration');\n                    actionButtonGroupRef.current.handleSetCalibrate();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleSetCalibrate === 'function') {\n                    // Fallback to global method\n                    console.log('Using global bridge method for calibration');\n                    window.actionButtonFunctions.handleSetCalibrate();\n                } else {\n                    // Make sure we have a canvas to work with\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for calibration\");\n                        setOutputText(\"Error: Canvas not available for calibration\");\n                        setShowTopBar(true);\n                        return;\n                    }\n                    // Load all required modules first, then proceed with execution\n                    Promise.all([\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/Action/CalibratePoints */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Action/CalibratePoints.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/Action/countSave */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Action/countSave.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/Helper/savefile */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/Helper/savefile.js\"))\n                    ]).then(async (param)=>{\n                        let [calibratePointsModule, countSaveModule, savefileModule] = param;\n                        // Destructure the imported modules\n                        const { generateCalibrationPoints } = calibratePointsModule;\n                        const { drawRedDot, runCountdown, showCapturePreview } = countSaveModule;\n                        const { captureImagesAtPoint } = savefileModule;\n                        try {\n                            // Generate calibration points\n                            const points = generateCalibrationPoints(canvas.width, canvas.height);\n                            if (!points || points.length === 0) {\n                                throw new Error(\"Failed to generate calibration points\");\n                            }\n                            // Create status indicator\n                            const statusIndicator = document.createElement('div');\n                            statusIndicator.className = 'calibrate-status-indicator';\n                            statusIndicator.style.cssText = \"\\n                position: fixed;\\n                top: 10px;\\n                right: 10px;\\n                background-color: rgba(0, 102, 204, 0.9);\\n                color: white;\\n                font-size: 14px;\\n                font-weight: bold;\\n                padding: '8px 12px';\\n                border-radius: 6px;\\n                z-index: 9999;\\n                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n              \";\n                            statusIndicator.textContent = 'Calibration: Initializing...';\n                            document.body.appendChild(statusIndicator);\n                            // Access webcam before starting calibration if available\n                            if (typeof triggerCameraAccess === 'function') {\n                                triggerCameraAccess(true);\n                                await new Promise((resolve)=>setTimeout(resolve, 500));\n                            }\n                            // Process points sequentially\n                            let successCount = 0;\n                            for(let i = 0; i < points.length; i++){\n                                const point = points[i];\n                                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                                setOutputText(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                                // Clear the canvas before drawing new point\n                                const ctx = canvas.getContext('2d');\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                // Draw the dot\n                                drawRedDot(ctx, point.x, point.y);\n                                // Run countdown\n                                await new Promise((resolve)=>{\n                                    runCountdown(point, canvas, (status)=>{\n                                        if (status.processStatus) {\n                                            setOutputText(status.processStatus);\n                                        }\n                                    }, resolve // This will be called when countdown completes\n                                    );\n                                });\n                                // Capture images at this point\n                                try {\n                                    const captureResult = await captureImagesAtPoint({\n                                        point: point,\n                                        captureCount: captureCounter,\n                                        canvasRef: {\n                                            current: canvas\n                                        },\n                                        setCaptureCount: setCaptureCounter,\n                                        showCapturePreview: showCapturePreview\n                                    });\n                                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                        successCount++;\n                                    }\n                                    // Increment counter\n                                    setCaptureCounter((prev)=>prev + 1);\n                                } catch (error) {\n                                    console.error(\"Error capturing point \".concat(i + 1, \":\"), error);\n                                }\n                                // Wait between points\n                                await new Promise((resolve)=>setTimeout(resolve, 1200));\n                            }\n                            // Calibration complete\n                            statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                            setOutputText(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                            // Remove the status indicator after a delay\n                            setTimeout(()=>{\n                                if (statusIndicator.parentNode) {\n                                    statusIndicator.parentNode.removeChild(statusIndicator);\n                                }\n                            }, 3000);\n                        } catch (error) {\n                            console.error(\"Calibration error:\", error);\n                            setOutputText(\"Calibration error: \".concat(error.message));\n                        } finally{\n                            // Show TopBar again\n                            setTimeout(()=>setShowTopBar(true), 2000);\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to import required modules:\", error);\n                        setOutputText(\"Calibration error: \".concat(error.message));\n                        setShowTopBar(true);\n                    });\n                }\n                break;\n            case 'clearAll':\n                // Clear canvas\n                // const canvas = getMainCanvas();\n                if (canvas) {\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    setOutputText('Canvas cleared');\n                }\n                break;\n            default:\n                setOutputText(\"Action triggered: \".concat(actionType));\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        if (!isClient || !isHydrated) return;\n        setShowPermissionPopup(false);\n        setCameraPermissionGranted(true);\n        toggleCamera(true);\n    };\n    const handlePermissionDenied = ()=>{\n        if (!isClient || !isHydrated) return;\n        setShowPermissionPopup(false);\n        setShowCameraPlaceholder(false);\n        setOutputText('Camera permission denied');\n    };\n    const handleCameraClose = ()=>{\n        if (!isClient || !isHydrated) return;\n        toggleCamera(false);\n    };\n    const handleCameraReady = (dimensions)=>{\n        if (!isClient || !isHydrated) return;\n        setMetrics({\n            width: dimensions.width,\n            height: dimensions.height,\n            distance: dimensions.distance || '---'\n        });\n        setOutputText(\"Camera ready: \".concat(dimensions.width, \"x\").concat(dimensions.height));\n    };\n    // Toggle top bar function\n    const toggleTopBar = (show)=>{\n        const newTopBarState = show !== undefined ? show : !showTopBar;\n        setShowTopBar(newTopBarState);\n        // Also hide metrics when hiding the top bar\n        if (!newTopBarState) {\n            setShowMetrics(false);\n        }\n        setOutputText(\"TopBar \".concat(newTopBarState ? 'shown' : 'hidden').concat(!newTopBarState ? ', Metrics hidden' : ''));\n        // Wait for state update and DOM changes, then adjust canvas\n        setTimeout(adjustCanvasDimensions, 100);\n    };\n    // Toggle metrics function\n    const toggleMetrics = ()=>{\n        if (showTopBar) {\n            setShowMetrics((prev)=>!prev);\n            setOutputText(\"Metrics \".concat(!showMetrics ? 'shown' : 'hidden'));\n        } else {\n            // If topBar is hidden, we can't show metrics\n            setOutputText('Cannot show metrics when TopBar is hidden');\n        }\n    };\n    // Function to trigger camera access\n    const triggerCameraAccess = (forceEnable)=>{\n        if (forceEnable) {\n            // Try to enable camera directly\n            if (window.videoProcessor) {\n                setShowCamera(true);\n                setShowCameraPlaceholder(false);\n                setCameraPermissionGranted(true);\n                // Start video processing with current options\n                window.videoProcessor.startVideoProcessing({\n                    showHeadPose,\n                    showBoundingBox,\n                    showMask,\n                    showParameters,\n                    showProcessedImage: true\n                });\n                return true;\n            }\n            return false;\n        }\n        // Just toggle current state if not forcing\n        if (cameraPermissionGranted) {\n            toggleCamera(!showCamera);\n            return true;\n        } else {\n            setShowPermissionPopup(true);\n            return false;\n        }\n    };\n    // Dynamic class to reflect current window size\n    const getSizeClass = ()=>{\n        const { percentage } = windowSize;\n        if (percentage < 35) return 'window-size-tiny';\n        if (percentage < 50) return 'window-size-small';\n        if (percentage < 70) return 'window-size-medium';\n        return 'window-size-large';\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"main-container \".concat(getSizeClass()),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Camera Dataset Collection\"\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1102,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1103,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1101,\n                columnNumber: 7\n            }, this),\n            isHydrated && isClient && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(VideoProcessorComponent, {}, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1107,\n                columnNumber: 34\n            }, this),\n            isHydrated && backendStatus === 'disconnected' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    padding: '6px 0',\n                    backgroundColor: '#ffe0b2',\n                    color: '#e65100',\n                    textAlign: 'center',\n                    fontSize: '14px',\n                    fontWeight: 'bold',\n                    zIndex: 1100\n                },\n                children: \" Backend disconnected. Hurry up, Make ONLINE please and Using mock mode\"\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1111,\n                columnNumber: 9\n            }, this),\n            showTopBar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_topBar__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                onButtonClick: handleActionButtonClick,\n                onCameraAccess: ()=>setShowPermissionPopup(true),\n                outputText: statusMessage || outputText,\n                onOutputChange: (text)=>setOutputText(text),\n                onToggleTopBar: toggleTopBar,\n                onToggleMetrics: toggleMetrics,\n                canvasRef: canvasRef\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1130,\n                columnNumber: 9\n            }, this),\n            !showTopBar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"restore-button-container\",\n                style: {\n                    position: 'fixed',\n                    top: '10px',\n                    right: '10px',\n                    zIndex: 1000\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    className: \"restore-btn\",\n                    onClick: ()=>toggleTopBar(true),\n                    title: \"Show TopBar and Metrics\",\n                    style: {\n                        padding: '5px 10px',\n                        background: '#0066cc',\n                        color: 'white',\n                        border: 'none',\n                        borderRadius: '4px',\n                        fontSize: '16px',\n                        cursor: 'pointer'\n                    },\n                    children: \"\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 1149,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1143,\n                columnNumber: 9\n            }, this),\n            isHydrated && showWarning && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"warning-banner\",\n                style: {\n                    position: 'fixed',\n                    top: showTopBar ? backendStatus === 'disconnected' ? '32px' : '60px' : '0',\n                    left: '0',\n                    width: '100%',\n                    backgroundColor: '#ffeb3b',\n                    color: '#333',\n                    padding: '10px',\n                    textAlign: 'center',\n                    boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n                    zIndex: 1010,\n                    animation: 'fadeIn 0.3s ease-in-out'\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                    children: [\n                        \" \",\n                        warningMessage\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 1183,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1170,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                ref: previewAreaRef,\n                className: \"camera-preview-area\",\n                style: {\n                    height: showTopBar ? 'calc(100vh - 120px)' : '100vh',\n                    marginTop: backendStatus === 'disconnected' ? '32px' : '0',\n                    position: 'relative',\n                    backgroundColor: '#f5f5f5',\n                    overflow: 'hidden'\n                },\n                children: [\n                    !showCamera ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"camera-preview-message\",\n                                style: {\n                                    padding: '20px',\n                                    textAlign: 'center',\n                                    position: showTopBar ? 'relative' : 'absolute',\n                                    width: '100%',\n                                    zIndex: 5\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        children: \"Camera preview will appear here\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1208,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                        className: \"camera-size-indicator\",\n                                        children: [\n                                            \"Current window: \",\n                                            windowSize.percentage,\n                                            \"% of screen width\"\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1209,\n                                        columnNumber: 15\n                                    }, this),\n                                    isHydrated && showCameraPlaceholder && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"camera-placeholder-square\",\n                                        style: {\n                                            width: '180px',\n                                            height: '135px',\n                                            margin: '20px auto',\n                                            border: '2px dashed #666',\n                                            borderRadius: '4px',\n                                            backgroundColor: '#f5f5f5',\n                                            display: 'flex',\n                                            alignItems: 'center',\n                                            justifyContent: 'center'\n                                        },\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            style: {\n                                                fontSize: '1.5rem'\n                                            },\n                                            children: \"\\uD83D\\uDCF7\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1227,\n                                            columnNumber: 19\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1213,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"camera-action-buttons-container\",\n                                        style: {\n                                            marginTop: '30px',\n                                            maxWidth: '600px',\n                                            margin: '30px auto'\n                                        },\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_actionButton__WEBPACK_IMPORTED_MODULE_6__.ActionButtonGroup, {\n                                            ref: actionButtonGroupRef,\n                                            triggerCameraAccess: triggerCameraAccess,\n                                            isCompactMode: windowSize.width < 768,\n                                            onActionClick: handleActionButtonClick,\n                                            showHeadPose: showHeadPose,\n                                            showBoundingBox: showBoundingBox,\n                                            showMask: showMask,\n                                            showParameters: showParameters\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1237,\n                                            columnNumber: 17\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1232,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1201,\n                                columnNumber: 13\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"canvas-container\",\n                                style: {\n                                    position: 'absolute',\n                                    top: 0,\n                                    left: 0,\n                                    width: '100%',\n                                    height: '100%',\n                                    backgroundColor: 'white',\n                                    overflow: 'hidden',\n                                    border: 'none',\n                                    zIndex: 10\n                                },\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                                    ref: canvasRef,\n                                    className: \"tracking-canvas\",\n                                    style: {\n                                        width: '100%',\n                                        height: '100%',\n                                        display: 'block'\n                                    }\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1265,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1251,\n                                columnNumber: 13\n                            }, this)\n                        ]\n                    }, void 0, true) : null,\n                    isHydrated && showMetrics && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_displayResponse__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                        width: metrics.width,\n                        height: metrics.height,\n                        distance: metrics.distance,\n                        isVisible: showMetrics\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1280,\n                        columnNumber: 11\n                    }, this),\n                    isHydrated && isClient && showCamera && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DynamicCameraAccess, {\n                        isShowing: showCamera,\n                        onClose: handleCameraClose,\n                        onCameraReady: handleCameraReady,\n                        showHeadPose: showHeadPose,\n                        showBoundingBox: showBoundingBox,\n                        showMask: showMask,\n                        showParameters: showParameters,\n                        videoRef: videoRef\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1290,\n                        columnNumber: 11\n                    }, this),\n                    isHydrated && isClient && showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"camera-permission-popup\",\n                        style: {\n                            position: 'fixed',\n                            top: 0,\n                            left: 0,\n                            width: '100%',\n                            height: '100%',\n                            backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                            display: 'flex',\n                            justifyContent: 'center',\n                            alignItems: 'center',\n                            zIndex: 2000\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-dialog\",\n                            style: {\n                                width: '400px',\n                                backgroundColor: 'white',\n                                borderRadius: '8px',\n                                padding: '20px',\n                                boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                    className: \"camera-permission-title\",\n                                    style: {\n                                        margin: '0 0 15px',\n                                        fontSize: '18px',\n                                        fontWeight: 'bold'\n                                    },\n                                    children: \"Camera Access Required\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1323,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"camera-permission-message\",\n                                    style: {\n                                        margin: '0 0 20px',\n                                        fontSize: '14px',\n                                        lineHeight: '1.4'\n                                    },\n                                    children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1328,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"camera-permission-buttons\",\n                                    style: {\n                                        display: 'flex',\n                                        justifyContent: 'flex-end',\n                                        gap: '10px'\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: handlePermissionDenied,\n                                            className: \"camera-btn\",\n                                            style: {\n                                                padding: '8px 16px',\n                                                backgroundColor: '#f0f0f0',\n                                                border: 'none',\n                                                borderRadius: '4px',\n                                                cursor: 'pointer'\n                                            },\n                                            children: \"Cancel\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1341,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: handlePermissionAccepted,\n                                            className: \"camera-btn\",\n                                            style: {\n                                                padding: '8px 16px',\n                                                backgroundColor: '#0066cc',\n                                                color: 'white',\n                                                border: 'none',\n                                                borderRadius: '4px',\n                                                cursor: 'pointer'\n                                            },\n                                            children: \"Continue\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1354,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1336,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                            lineNumber: 1316,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1304,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1188,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n        lineNumber: 1100,\n        columnNumber: 5\n    }, this);\n}\n_s(CollectedDatasetPage, \"kBpjorT3d2Kd1VPZ1xnC2bHu53g=\");\n_c2 = CollectedDatasetPage;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"VideoProcessorComponent\");\n$RefreshReg$(_c1, \"DynamicCameraAccess\");\n$RefreshReg$(_c2, \"CollectedDatasetPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEscURBQXFEOzs7QUFDTTtBQUM5QjtBQUNNO0FBQ1U7QUFDa0I7QUFDRztBQUNqQjtBQUNqRCxrRUFBa0U7QUFDd0U7QUFDckU7QUFFckUseUVBQXlFO0FBQ3pFLE1BQU1nQiwwQkFBMEJYLG1EQUFPQSxDQUNyQyxJQUFNLGtWQUFrRDs7Ozs7O0lBQ3REWSxLQUFLOztLQUZIRDtBQUtOLDREQUE0RDtBQUM1RCxNQUFNRSxzQkFBc0JiLG1EQUFPQSxDQUNqQyxJQUFNLGlUQUF1Qzs7Ozs7O0lBRTNDWSxLQUFLO0lBQ0xFLFNBQVMsa0JBQ1AsOERBQUNDO1lBQUlDLE9BQU87Z0JBQ1ZDLFVBQVU7Z0JBQ1ZDLEtBQUs7Z0JBQ0xDLE1BQU07Z0JBQ05DLFdBQVc7Z0JBQ1hDLE9BQU87Z0JBQ1BDLFFBQVE7Z0JBQ1JDLGlCQUFpQjtnQkFDakJDLFFBQVE7Z0JBQ1JDLGNBQWM7Z0JBQ2RDLFNBQVM7Z0JBQ1RDLGVBQWU7Z0JBQ2ZDLGdCQUFnQjtnQkFDaEJDLFlBQVk7Z0JBQ1pDLFdBQVc7Z0JBQ1hDLFFBQVE7WUFDVjs7OEJBQ0UsOERBQUNoQjtvQkFBSUMsT0FBTzt3QkFBRWdCLFVBQVU7d0JBQVFDLGNBQWM7b0JBQU87OEJBQUc7Ozs7Ozs4QkFDeEQsOERBQUNDO29CQUFFbEIsT0FBTzt3QkFBRWdCLFVBQVU7d0JBQVFHLFlBQVk7d0JBQVFDLE9BQU87b0JBQVU7OEJBQUc7Ozs7Ozs7Ozs7Ozs7TUF2QnhFdkI7QUErQlMsU0FBU3dCOztJQUN0QixnQ0FBZ0M7SUFDaEMsTUFBTSxDQUFDQyxZQUFZQyxjQUFjLEdBQUczQywrQ0FBUUEsQ0FBQztJQUU3Qyw4QkFBOEI7SUFDOUIsTUFBTSxDQUFDNEMsWUFBWUMsY0FBYyxHQUFHN0MsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDOEMscUJB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVakI7R0E1eUN3QjlNO01BQUFBIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb2RpZmllZCBpbmRleC5qcyAtIEZpeGluZyBjYW52YXMgcmVmZXJlbmNlIGlzc3Vlc1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IFRvcEJhciBmcm9tICcuL2NvbXBvbmVudHMtZ3VpL3RvcEJhcic7XG5pbXBvcnQgRGlzcGxheVJlc3BvbnNlIGZyb20gJy4vY29tcG9uZW50cy1ndWkvZGlzcGxheVJlc3BvbnNlJztcbmltcG9ydCB7IEFjdGlvbkJ1dHRvbkdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzLWd1aS9hY3Rpb25CdXR0b24nO1xuaW1wb3J0IFNldHRpbmdzIGZyb20gJy4uLy4uL2NvbXBvbmVudHMvU2V0dGluZ3MnO1xuLy8gaW1wb3J0IFN0YXR1c0luZGljYXRvciBmcm9tICcuL2NvbXBvbmVudHMtZ3VpL1N0YXR1c0luZGljYXRvcic7XG5pbXBvcnQgeyBzaG93Q2FwdHVyZVByZXZpZXcsIGNhcHR1cmVJbWFnZXNBdFBvaW50LCBkcmF3UmVkRG90LCBnZXRSYW5kb21Qb3NpdGlvbiwgcnVuQ291bnRkb3duIH0gZnJvbSAnLi9jb21wb25lbnRzLWd1aS9BY3Rpb24vY291bnRTYXZlJztcbmltcG9ydCB7IHVzZUNvbnNlbnQgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NvbnNlbnQvQ29uc2VudENvbnRleHQnO1xuXG4vLyBEeW5hbWljYWxseSBsb2FkIHRoZSB2aWRlbyBwcm9jZXNzb3IgY29tcG9uZW50IChub3QgdGhlIGhvb2sgZGlyZWN0bHkpXG5jb25zdCBWaWRlb1Byb2Nlc3NvckNvbXBvbmVudCA9IGR5bmFtaWMoXG4gICgpID0+IGltcG9ydCgnLi9jb21wb25lbnRzLWd1aS9WaWRlb1Byb2Nlc3NvckNvbXBvbmVudCcpLFxuICB7IHNzcjogZmFsc2UgfVxuKTtcblxuLy8gRHluYW1pY2FsbHkgaW1wb3J0IHRoZSBjYW1lcmEgY29tcG9uZW50IHdpdGggU1NSIGRpc2FibGVkXG5jb25zdCBEeW5hbWljQ2FtZXJhQWNjZXNzID0gZHluYW1pYyhcbiAgKCkgPT4gaW1wb3J0KCcuL2NvbXBvbmVudHMtZ3VpL2NhbWVyYUFjY2VzcycpLFxuICB7IFxuICAgIHNzcjogZmFsc2UsXG4gICAgbG9hZGluZzogKCkgPT4gKFxuICAgICAgPGRpdiBzdHlsZT17e1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgIHdpZHRoOiAnNDgwcHgnLFxuICAgICAgICBoZWlnaHQ6ICczNjBweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmMGY4ZmYnLFxuICAgICAgICBib3JkZXI6ICcycHggc29saWQgIzAwNjZjYycsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIHpJbmRleDogOTk5XG4gICAgICB9fT5cbiAgICAgICAgPGRpdiBzdHlsZT17eyBmb250U2l6ZTogJzQ4cHgnLCBtYXJnaW5Cb3R0b206ICcxNXB4JyB9fT7wn5O3PC9kaXY+XG4gICAgICAgIDxwIHN0eWxlPXt7IGZvbnRTaXplOiAnMTZweCcsIGZvbnRXZWlnaHQ6ICdib2xkJywgY29sb3I6ICcjMDA2NmNjJyB9fT5cbiAgICAgICAgICBMb2FkaW5nIGNhbWVyYS4uLlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbik7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbGxlY3RlZERhdGFzZXRQYWdlKCkge1xuICAvLyBTdGF0ZSBmb3IgaHlkcmF0aW9uIGRldGVjdGlvblxuICBjb25zdCBbaXNIeWRyYXRlZCwgc2V0SXNIeWRyYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBTdGF0ZSBmb3IgY2FtZXJhIG1hbmFnZW1lbnRcbiAgY29uc3QgW3Nob3dDYW1lcmEsIHNldFNob3dDYW1lcmFdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1Blcm1pc3Npb25Qb3B1cCwgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93VG9wQmFyLCBzZXRTaG93VG9wQmFyXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbc2hvd01ldHJpY3MsIHNldFNob3dNZXRyaWNzXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbb3V0cHV0VGV4dCwgc2V0T3V0cHV0VGV4dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFttZXRyaWNzLCBzZXRNZXRyaWNzXSA9IHVzZVN0YXRlKHtcbiAgICB3aWR0aDogJy0tLScsXG4gICAgaGVpZ2h0OiAnLS0tJyxcbiAgICBkaXN0YW5jZTogJy0tLSdcbiAgfSk7XG4gIGNvbnN0IFt3aW5kb3dTaXplLCBzZXRXaW5kb3dTaXplXSA9IHVzZVN0YXRlKHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgcGVyY2VudGFnZTogMTAwXG4gIH0pO1xuICBcbiAgLy8gUmVmZXJlbmNlcyBhbmQgb3RoZXIgc3RhdGVcbiAgY29uc3QgcHJldmlld0FyZWFSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYobnVsbCk7XG4gIFxuICAvLyBTdGF0ZSBmb3IgY2FwdHVyZSB0cmFja2luZ1xuICBjb25zdCBbY2FwdHVyZUNvdW50ZXIsIHNldENhcHR1cmVDb3VudGVyXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbY2FwdHVyZUZvbGRlciwgc2V0Q2FwdHVyZUZvbGRlcl0gPSB1c2VTdGF0ZSgnJyk7XG4gIFxuICAvLyBTdGF0ZSBmb3IgY2FtZXJhIHByb2Nlc3Npbmcgb3B0aW9uc1xuICBjb25zdCBbc2hvd0hlYWRQb3NlLCBzZXRTaG93SGVhZFBvc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0JvdW5kaW5nQm94LCBzZXRTaG93Qm91bmRpbmdCb3hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd01hc2ssIHNldFNob3dNYXNrXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQYXJhbWV0ZXJzLCBzZXRTaG93UGFyYW1ldGVyc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBTdGF0ZSB0byB0cmFjayBpZiBjYW1lcmEgc3F1YXJlIHNob3VsZCBiZSBzaG93blxuICBjb25zdCBbc2hvd0NhbWVyYVBsYWNlaG9sZGVyLCBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gVG8gc3RvcmUgdGhlIGNhbWVyYSBwZXJtaXNzaW9uIHN0YXRlXG4gIGNvbnN0IFtjYW1lcmFQZXJtaXNzaW9uR3JhbnRlZCwgc2V0Q2FtZXJhUGVybWlzc2lvbkdyYW50ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gU3RhdGUgZm9yIHdhcm5pbmcgbWVzc2FnZVxuICBjb25zdCBbc2hvd1dhcm5pbmcsIHNldFNob3dXYXJuaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3dhcm5pbmdNZXNzYWdlLCBzZXRXYXJuaW5nTWVzc2FnZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIFxuICAvLyBCYWNrZW5kIGNvbm5lY3Rpb24gc3RhdHVzXG4gIGNvbnN0IFtiYWNrZW5kU3RhdHVzLCBzZXRCYWNrZW5kU3RhdHVzXSA9IHVzZVN0YXRlKCdjaGVja2luZycpO1xuXG4gIGNvbnN0IGFjdGlvbkJ1dHRvbkdyb3VwUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbc3RhdHVzTWVzc2FnZSwgc2V0U3RhdHVzTWVzc2FnZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIFxuICAvLyBTdGF0ZSBmb3Igc2V0dGluZ3MgdmlzaWJpbGl0eVxuICBjb25zdCBbc2hvd1NldHRpbmdzLCBzZXRTaG93U2V0dGluZ3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gSW1wcm92ZWQgZ2V0IGNhbnZhcyBmdW5jdGlvbiB0aGF0IHRyaWVzIG11bHRpcGxlIG1ldGhvZHNcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICAvLyBNZXRob2QgMTogQ2hlY2sgaWYgd2UgaGF2ZSBhIGRpcmVjdCByZWZlcmVuY2VcbiAgICBpZiAoY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZGlyZWN0IGNhbnZhc1JlZi5jdXJyZW50IHJlZmVyZW5jZVwiKTtcbiAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICB9XG4gICAgXG4gICAgLy8gTWV0aG9kIDI6IFRyeSB0byBnZXQgZ2xvYmFsIHJlZmVyZW5jZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZ2xvYmFsIHdoaXRlU2NyZWVuQ2FudmFzIHJlZmVyZW5jZVwiKTtcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gd2luZG93LndoaXRlU2NyZWVuQ2FudmFzOyAvLyBVcGRhdGUgb3VyIHJlZlxuICAgICAgcmV0dXJuIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICB9XG4gICAgXG4gICAgLy8gTWV0aG9kIDM6IFRyeSB0byBmaW5kIHZpYSBET01cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cmFja2luZy1jYW52YXMnKTtcbiAgICAgIGlmIChjYW52YXNFbGVtZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRm91bmQgY2FudmFzIHZpYSBET00gc2VsZWN0b3JcIik7XG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzRWxlbWVudDsgLy8gVXBkYXRlIG91ciByZWZcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzRWxlbWVudDsgLy8gVXBkYXRlIGdsb2JhbCByZWYgdG9vXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCB2aWEgYW55IG1ldGhvZFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgXG4gIC8vIENoZWNrIGlmIHdlJ3JlIG9uIHRoZSBjbGllbnQgb3Igc2VydmVyXG4gIGNvbnN0IGlzQ2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gIFxuICAvLyBBZGQgZWZmZWN0IHRvIGluaXRpYWxpemUgY2FudmFzIGFuZCBtYWtlIGl0IGdsb2JhbGx5IGF2YWlsYWJsZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICAvLyBEZWJ1ZyBpbmZvIHRvIHZlcmlmeSBjYW52YXMgc2l6ZSBhbmQgYXZhaWxhYmlsaXR5XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc29sZS5sb2coXCJJbmRleC5qczogQ2FudmFzIGluaXRpYWxpemVkXCIsIHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBjYW52YXMgRVhQTElDSVRMWSBhdmFpbGFibGUgZ2xvYmFsbHlcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgIFxuICAgICAgLy8gQWxzbyBzdG9yZSBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgd2luZG93LmNhbnZhc0RpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBub3QgYXZhaWxhYmxlIGR1cmluZyBpbml0aWFsaXphdGlvblwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRXhwb3NlIGNhbnZhcyBpbml0aWFsaXphdGlvbiBmdW5jdGlvbiBnbG9iYWxseVxuICAgIHdpbmRvdy5pbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgICBpZiAoIWNhbnZhcyB8fCAhcGFyZW50KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW2luaXRpYWxpemVDYW52YXNdIENhbnZhcyBvciBwYXJlbnQgaXMgbnVsbCcsIHsgY2FudmFzLCBwYXJlbnQgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHBhcmVudFxuICAgICAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXMgYW5kIHNldCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgaW5pdGlhbGl6ZWQgd2l0aCBkaW1lbnNpb25zOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGdsb2JhbCByZWZlcmVuY2VcbiAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgICAgICB3aW5kb3cuY2FudmFzRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbaW5pdGlhbGl6ZUNhbnZhc10gRXJyb3IgaW5pdGlhbGl6aW5nIGNhbnZhczonLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIENoZWNrIGNhbnZhcyB2aXNpYmlsaXR5IGFuZCBmb3JjZSBpbml0aWFsaXphdGlvbiBhZnRlciBhIGJyaWVmIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIGluaXRpYWwgdmlzaWJpbGl0eSBjaGVjazpcIiwge1xuICAgICAgICAgIGRpbWVuc2lvbnM6IGAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWAsXG4gICAgICAgICAgcmVjdFNpemU6IGAke3JlY3Qud2lkdGh9eCR7cmVjdC5oZWlnaHR9YCxcbiAgICAgICAgICBpc1Zpc2libGU6IChyZWN0LndpZHRoID4gMCAmJiByZWN0LmhlaWdodCA+IDApXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gRm9yY2UgaW5pdGlhbGl6YXRpb24gaWYgbmVlZGVkXG4gICAgICAgIGFkanVzdENhbnZhc0RpbWVuc2lvbnMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNhbnZhcyBub3QgZm91bmQgZHVyaW5nIHZpc2liaWxpdHkgY2hlY2tcIik7XG4gICAgICB9XG4gICAgfSwgNTAwKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZGVsZXRlIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzRGltZW5zaW9ucztcbiAgICAgIGRlbGV0ZSB3aW5kb3cuaW5pdGlhbGl6ZUNhbnZhcztcbiAgICB9O1xuICB9LCBbaXNIeWRyYXRlZF0pO1xuICAvLyBJbXByb3ZlZCBjYW52YXMgZGltZW5zaW9ucyBhZGp1c3RtZW50XG4gIGNvbnN0IGFkanVzdENhbnZhc0RpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCB8fCAhcHJldmlld0FyZWFSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gY2FudmFzIGZvdW5kIHRvIGFkanVzdCBkaW1lbnNpb25zXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjb250YWluZXIgPSBwcmV2aWV3QXJlYVJlZi5jdXJyZW50O1xuICAgIFxuICAgIC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgcHJldmlldyBhcmVhXG4gICAgY29uc3QgcmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcHJvcGVyIGhlaWdodCBiYXNlZCBvbiB0b3AgYmFyIHZpc2liaWxpdHlcbiAgICBjb25zdCB0b3BCYXJIZWlnaHQgPSBzaG93VG9wQmFyID8gMTIwIDogMDsgLy8gQWRqdXN0IHRoaXMgdmFsdWUgYmFzZWQgb24geW91ciB0b3AgYmFyJ3MgYWN0dWFsIGhlaWdodFxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQWRqdXN0aW5nIGNhbnZhcyBkaW1lbnNpb25zXCIsIHtcbiAgICAgIGNvbnRhaW5lcldpZHRoOiByZWN0LndpZHRoLFxuICAgICAgY29udGFpbmVySGVpZ2h0OiByZWN0LmhlaWdodCxcbiAgICAgIHRvcEJhclZpc2libGU6IHNob3dUb3BCYXIsXG4gICAgICBjYWxjdWxhdGVkSGVpZ2h0OiByZWN0LmhlaWdodFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBjb250YWluZXIgc2l6ZSB3aXRoIHRvcCBiYXIgYWRqdXN0bWVudFxuICAgIGNhbnZhcy53aWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgLy8gRmlsbCB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ2FudmFzIGRpbWVuc2lvbnMgYWRqdXN0ZWQ6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgXG4gICAgLy8gVXBkYXRlIGdsb2JhbCByZWZlcmVuY2Ugd2l0aCBjdXJyZW50IGRpbWVuc2lvbnNcbiAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG4gICAgd2luZG93LmNhbnZhc0RpbWVuc2lvbnMgPSB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBjYXB0dXJlIGZvbGRlciBvbiBjb21wb25lbnQgbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWNhcHR1cmVGb2xkZXIgJiYgaXNDbGllbnQgJiYgaXNIeWRyYXRlZCkge1xuICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1s6XFwuXS9nLCAnLScpO1xuICAgICAgc2V0Q2FwdHVyZUZvbGRlcihgc2Vzc2lvbl8ke3RpbWVzdGFtcH1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGNhcHR1cmUgZm9sZGVyOiBzZXNzaW9uXyR7dGltZXN0YW1wfWApO1xuICAgIH1cbiAgfSwgW2NhcHR1cmVGb2xkZXIsIGlzQ2xpZW50LCBpc0h5ZHJhdGVkXSk7XG4gIFxuICAvLyBTZXQgaHlkcmF0ZWQgc3RhdGUgYWZ0ZXIgbW91bnQgdG8gcHJldmVudCBoeWRyYXRpb24gbWlzbWF0Y2hcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0h5ZHJhdGVkKHRydWUpO1xuICB9LCBbXSk7XG5cbiAgLy8gQ2hlY2sgYmFja2VuZCBjb25uZWN0aW9uIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuOyAvLyBTa2lwIG9uIHNlcnZlciBvciBiZWZvcmUgaHlkcmF0aW9uXG4gICAgXG4gICAgY29uc3QgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hlY2stYmFja2VuZC1jb25uZWN0aW9uJyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNldEJhY2tlbmRTdGF0dXMoZGF0YS5jb25uZWN0ZWQgPyAnY29ubmVjdGVkJyA6ICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY29uc29sZS5sb2coYEJhY2tlbmQgY29ubmVjdGlvbjogJHtkYXRhLmNvbm5lY3RlZCA/ICdPSycgOiAnRmFpbGVkJ31gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgc3RhdHVzIGluIG91dHB1dCB0ZXh0XG4gICAgICAgIHNldE91dHB1dFRleHQoYEJhY2tlbmQgJHtkYXRhLmNvbm5lY3RlZCA/ICdjb25uZWN0ZWQnIDogJ2Rpc2Nvbm5lY3RlZCAtIHVzaW5nIG1vY2sgbW9kZSd9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBiYWNrZW5kIGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgICBzZXRCYWNrZW5kU3RhdHVzKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnQmFja2VuZCBkaXNjb25uZWN0ZWQgLSB1c2luZyBtb2NrIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbigpO1xuICAgIFxuICAgIC8vIFdlbGNvbWUgbWVzc2FnZSBhZnRlciBiYWNrZW5kIGNoZWNrXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRPdXRwdXRUZXh0KCdDYW1lcmEgc3lzdGVtIHJlYWR5LiBDbGljayBcIlNob3cgUHJldmlld1wiIHRvIHN0YXJ0IGNhbWVyYS4nKTtcbiAgICB9LCAyMDAwKTtcbiAgfSwgW2lzSHlkcmF0ZWRdKTtcblxuICAvLyBVcGRhdGUgbWV0cmljcyBhbmQgd2luZG93IHNpemUgd2hlbiBjb21wb25lbnQgbW91bnRzIGFuZCBvbiB3aW5kb3cgcmVzaXplXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuOyAvLyBTa2lwIG9uIHNlcnZlciBvciBiZWZvcmUgaHlkcmF0aW9uXG4gICAgXG4gICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgIGlmIChwcmV2aWV3QXJlYVJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcHJldmlld0FyZWFSZWYuY3VycmVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcHJldmlld0FyZWFSZWYuY3VycmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hhdCBwZXJjZW50YWdlIG9mIHRoZSBzY3JlZW4gd2UncmUgdXNpbmdcbiAgICAgICAgY29uc3Qgc2NyZWVuUGVyY2VudGFnZSA9ICh3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5zY3JlZW4ud2lkdGgpICogMTAwO1xuICAgICAgICBcbiAgICAgICAgc2V0TWV0cmljcyhwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSkpO1xuICAgICAgICBcbiAgICAgICAgc2V0V2luZG93U2l6ZSh7XG4gICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgIHBlcmNlbnRhZ2U6IE1hdGgucm91bmQoc2NyZWVuUGVyY2VudGFnZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICAgIGFkanVzdENhbnZhc0RpbWVuc2lvbnMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbCBjYWxjdWxhdGlvblxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgIH07XG4gIH0sIFtpc0h5ZHJhdGVkXSk7XG5cbiAgLy8gQWRkIGVmZmVjdCB0byB1cGRhdGUgY2FudmFzIHdoZW4gZGltZW5zaW9ucyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNDbGllbnQgJiYgaXNIeWRyYXRlZCkge1xuICAgICAgYWRqdXN0Q2FudmFzRGltZW5zaW9ucygpO1xuICAgIH1cbiAgfSwgW3dpbmRvd1NpemUsIHNob3dUb3BCYXIsIGlzSHlkcmF0ZWRdKTtcbiAgXG4gIC8vIEFkZCBzdHlsZXMgdG8gZG9jdW1lbnQgaGVhZCBmb3IgYnV0dG9uIGhpZ2hsaWdodGluZ1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBzdHlsZSBlbGVtZW50XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxuICAgICAgQGtleWZyYW1lcyBwdWxzZSB7XG4gICAgICAgIDAlIHsgYm94LXNoYWRvdzogMCAwIDAgMCByZ2JhKDAsIDEwMiwgMjA0LCAwLjcpOyB9XG4gICAgICAgIDcwJSB7IGJveC1zaGFkb3c6IDAgMCAwIDEwcHggcmdiYSgwLCAxMDIsIDIwNCwgMCk7IH1cbiAgICAgICAgMTAwJSB7IGJveC1zaGFkb3c6IDAgMCAwIDAgcmdiYSgwLCAxMDIsIDIwNCwgMCk7IH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgQGtleWZyYW1lcyBmYWRlSW4ge1xuICAgICAgICBmcm9tIHsgb3BhY2l0eTogMDsgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0xMHB4KTsgfVxuICAgICAgICB0byB7IG9wYWNpdHk6IDE7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgwKTsgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAuYnRuLWhpZ2hsaWdodCB7XG4gICAgICAgIGFuaW1hdGlvbjogcHVsc2UgMS41cyBpbmZpbml0ZTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzAwOTlmZiAhaW1wb3J0YW50O1xuICAgICAgICBjb2xvcjogd2hpdGUgIWltcG9ydGFudDtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLndhcm5pbmctYmFubmVyIHtcbiAgICAgICAgYW5pbWF0aW9uOiBmYWRlSW4gMC4zcyBlYXNlLWluLW91dDtcbiAgICAgIH1cbiAgICBgO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgIH07XG4gIH0sIFtpc0h5ZHJhdGVkXSk7XG4gIFxuICAvLyBNYWtlIHRvZ2dsZVRvcEJhciBmdW5jdGlvbiBhdmFpbGFibGUgZ2xvYmFsbHlcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gTWFrZSB0b2dnbGVUb3BCYXIgYXZhaWxhYmxlIHRvIG90aGVyIGNvbXBvbmVudHNcbiAgICB3aW5kb3cudG9nZ2xlVG9wQmFyID0gKHNob3cpID0+IHtcbiAgICAgIHNldFNob3dUb3BCYXIoc2hvdyk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gaGlkZSBtZXRyaWNzIHdoZW4gaGlkaW5nIHRoZSB0b3AgYmFyXG4gICAgICBpZiAoIXNob3cpIHtcbiAgICAgICAgc2V0U2hvd01ldHJpY3MoZmFsc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGp1c3QgY2FudmFzIGRpbWVuc2lvbnMgYWZ0ZXIgdG9nZ2xpbmdcbiAgICAgIHNldFRpbWVvdXQoYWRqdXN0Q2FudmFzRGltZW5zaW9ucywgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cFxuICAgICAgZGVsZXRlIHdpbmRvdy50b2dnbGVUb3BCYXI7XG4gICAgfTtcbiAgfSwgW2lzSHlkcmF0ZWRdKTtcblxuICAvLyBUb2dnbGUgY2FtZXJhIGZ1bmN0aW9uXG4gIGNvbnN0IHRvZ2dsZUNhbWVyYSA9IChzaG91bGRFbmFibGUpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgaWYgKHNob3VsZEVuYWJsZSkge1xuICAgICAgc2V0U2hvd0NhbWVyYSh0cnVlKTtcbiAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICBzZXRPdXRwdXRUZXh0KCdDYW1lcmEgcHJldmlldyBzdGFydGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNob3dDYW1lcmEoZmFsc2UpO1xuICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgIHNldE91dHB1dFRleHQoJ0NhbWVyYSBwcmV2aWV3IHN0b3BwZWQnKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBIYW5kbGVyIGZvciBhY3Rpb24gYnV0dG9uIGNsaWNrc1xuICBjb25zdCBoYW5kbGVBY3Rpb25CdXR0b25DbGljayA9IChhY3Rpb25UeXBlLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0b2dnbGluZyB0aGUgdG9wIGJhclxuICAgIGlmIChhY3Rpb25UeXBlID09PSAndG9nZ2xlVG9wQmFyJykge1xuICAgICAgLy8gY29uc3QgbmV3VG9wQmFyU3RhdGUgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gISF2YWx1ZSA6ICFzaG93VG9wQmFyO1xuICAgICAgbGV0IG5ld1RvcEJhclN0YXRlO1xuICAgIFxuICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdib29sZWFuJykge1xuICAgICAgICBuZXdUb3BCYXJTdGF0ZSA9IHBhcmFtcztcbiAgICAgIH0gZWxzZSBpZiAocGFyYW1zICYmIHR5cGVvZiBwYXJhbXMudmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG5ld1RvcEJhclN0YXRlID0gISFwYXJhbXMudmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdUb3BCYXJTdGF0ZSA9ICFzaG93VG9wQmFyO1xuICAgICAgfVxuICAgICAgc2V0U2hvd1RvcEJhcihuZXdUb3BCYXJTdGF0ZSk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gaGlkZSBtZXRyaWNzIHdoZW4gaGlkaW5nIHRoZSB0b3AgYmFyXG4gICAgICBpZiAoIW5ld1RvcEJhclN0YXRlKSB7XG4gICAgICAgIHNldFNob3dNZXRyaWNzKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0T3V0cHV0VGV4dChgVG9wQmFyICR7bmV3VG9wQmFyU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9JHshbmV3VG9wQmFyU3RhdGUgPyAnLCBNZXRyaWNzIGhpZGRlbicgOiAnJ31gKTtcbiAgICAgIFxuICAgICAgLy8gQWRqdXN0IGNhbnZhcyBkaW1lbnNpb25zIGFmdGVyIHRvZ2dsaW5nXG4gICAgICBzZXRUaW1lb3V0KGFkanVzdENhbnZhc0RpbWVuc2lvbnMsIDEwMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICBzZXRTaG93V2FybmluZyhmYWxzZSk7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHdhcm5pbmdzXG4gICAgY29uc3Qgc2FmZVBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgXG4gICAgLy8gVXNlIHNhZmVQYXJhbXMgaW5zdGVhZCBvZiBjb250cm9sVmFsdWVzXG4gICAgY29uc3QgcmFuZG9tVGltZXMgPSBzYWZlUGFyYW1zLnJhbmRvbVRpbWVzIHx8IDE7XG4gICAgY29uc3QgZGVsYXlTZWNvbmRzID0gc2FmZVBhcmFtcy5kZWxheVNlY29uZHMgfHwgMztcblxuICAgIHN3aXRjaCAoYWN0aW9uVHlwZSkge1xuICAgICAgY2FzZSAncHJldmlldyc6XG4gICAgICAgIC8vIFRvZ2dsZSBjYW1lcmEgc3RhdGVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEpIHtcbiAgICAgICAgICB0b2dnbGVDYW1lcmEoZmFsc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKGNhbWVyYVBlcm1pc3Npb25HcmFudGVkKSB7XG4gICAgICAgICAgdG9nZ2xlQ2FtZXJhKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBzaG93IHBlcm1pc3Npb24gcG9wdXBcbiAgICAgICAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpO1xuICAgICAgICAgIHNldE91dHB1dFRleHQoJ09wZW5pbmcgY2FtZXJhIHByZXZpZXcnKTtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgY2FzZSAnc2V0UmFuZG9tJzpcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnU3RhcnRpbmcgcmFuZG9tIHNlcXVlbmNlLi4uJyk7XG4gICAgICAgIHNldFNob3dUb3BCYXIoZmFsc2UpO1xuICAgICAgICBpZiAoc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHRvZ2dsZUNhbWVyYShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHRoZSBpbXBvcnRlZCBtb2R1bGUgYXBwcm9hY2ggLSBzaW1pbGFyIHRvIGNhbGlicmF0ZVxuICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldFJhbmRvbSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgcmVmZXJlbmNlIG1ldGhvZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgQWN0aW9uQnV0dG9uR3JvdXAgcmVmIG1ldGhvZCBmb3IgU2V0IFJhbmRvbScpO1xuICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQuaGFuZGxlU2V0UmFuZG9tKCk7XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMgJiYgXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlU2V0UmFuZG9tID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gZ2xvYmFsIG1ldGhvZFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBnbG9iYWwgYnJpZGdlIG1ldGhvZCBmb3IgU2V0IFJhbmRvbScpO1xuICAgICAgICAgIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlU2V0UmFuZG9tKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjYW52YXMgdG8gd29yayB3aXRoXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIG5vdCBmb3VuZCBmb3IgcmFuZG9tIHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChcIkVycm9yOiBDYW52YXMgbm90IGF2YWlsYWJsZSBmb3IgcmFuZG9tIHNlcXVlbmNlXCIpO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IGNvbnRyb2wgdmFsdWVzIGZyb20gdGhlIFRvcEJhclxuICAgICAgICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkJyk7XG4gICAgICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb250cm9sLWlucHV0LWZpZWxkJylbMV07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgaWYgaW5wdXRzIGNhbid0IGJlIGZvdW5kXG4gICAgICAgICAgbGV0IHRpbWVzID0gMTtcbiAgICAgICAgICBsZXQgZGVsYXkgPSAzO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFBhcnNlIGlucHV0IHZhbHVlcyBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZFRpbWUpICYmIHBhcnNlZFRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgIHRpbWVzID0gcGFyc2VkVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWREZWxheSkgJiYgcGFyc2VkRGVsYXkgPiAwKSB7XG4gICAgICAgICAgICAgIGRlbGF5ID0gcGFyc2VkRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvYWQgYWxsIHJlcXVpcmVkIG1vZHVsZXMgZmlyc3QsIHRoZW4gcHJvY2VlZCB3aXRoIGV4ZWN1dGlvblxuICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGltcG9ydCgnLi9jb21wb25lbnRzLWd1aS9BY3Rpb24vY291bnRTYXZlJyksXG4gICAgICAgICAgICBpbXBvcnQoJy4vY29tcG9uZW50cy1ndWkvSGVscGVyL3NhdmVmaWxlJylcbiAgICAgICAgICBdKS50aGVuKGFzeW5jIChbXG4gICAgICAgICAgICBjb3VudFNhdmVNb2R1bGUsXG4gICAgICAgICAgICBzYXZlZmlsZU1vZHVsZVxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIC8vIERlc3RydWN0dXJlIHRoZSBpbXBvcnRlZCBtb2R1bGVzXG4gICAgICAgICAgICBjb25zdCB7IGdldFJhbmRvbVBvc2l0aW9uLCBkcmF3UmVkRG90LCBydW5Db3VudGRvd24sIHNob3dDYXB0dXJlUHJldmlldyB9ID0gY291bnRTYXZlTW9kdWxlO1xuICAgICAgICAgICAgY29uc3QgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9ID0gc2F2ZWZpbGVNb2R1bGU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIFByb2Nlc3MgYWxsIGNhcHR1cmVzIHNlcXVlbnRpYWxseVxuICAgICAgICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDYXB0dXJlID0gMTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Q2FwdHVyZSA8PSB0aW1lcykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZm9yIGN1cnJlbnQgY2FwdHVyZVxuICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDbGVhciBjYW52YXMgYmVmb3JlIGVhY2ggY2FwdHVyZVxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb24gZm9yIHRoaXMgY2FwdHVyZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgZG90XG4gICAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHJlZHJhd0ludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgIGxldCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAxMiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUnVuIGNvdW50ZG93biBhbmQgd2FpdCBmb3IgaXQgdG8gY29tcGxldGVcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgICAgICAgIHJ1bkNvdW50ZG93bihcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgICAgICAgICAgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBVSSBiYXNlZCBvbiBzdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0vJHt0aW1lc306ICR7c3RhdHVzLnByb2Nlc3NTdGF0dXN9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHJlZHJhd0ludGVydmFsIGFmdGVyIGNvdW50ZG93blxuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYnJpZWZseSBhZnRlciBjb3VudGRvd25cbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVSZXN1bHQgJiYgKGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgY2FwdHVyZVJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYXB0dXJpbmcgcG9pbnQgJHtjdXJyZW50Q2FwdHVyZX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgZm9yIHRoZSBzcGVjaWZpZWQgZGVsYXkgdGltZVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2FwdHVyZSA8IHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgY3VycmVudENhcHR1cmUrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gU2VxdWVuY2UgY29tcGxldGVcbiAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgUmFuZG9tIGNhcHR1cmUgc2VxdWVuY2UgY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gY2FwdHVyZXMgc3VjY2Vzc2Z1bGApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYW5kb20gc2VxdWVuY2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgUmFuZG9tIHNlcXVlbmNlIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNldFNob3dUb3BCYXIodHJ1ZSksIDIwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gaW1wb3J0IHJlcXVpcmVkIG1vZHVsZXM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIHNldE91dHB1dFRleHQoYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBzZXRTaG93VG9wQmFyKHRydWUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyYW5kb21Eb3QnOlxuICAgICAgICBzZXRPdXRwdXRUZXh0KCdSYW5kb20gZG90IGFjdGlvbiB0cmlnZ2VyZWQnKTtcbiAgICAgICAgc2V0U2hvd1RvcEJhcihmYWxzZSk7XG4gICAgICAgIGlmIChzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgdG9nZ2xlQ2FtZXJhKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byBhY2Nlc3MgUmFuZG9tIERvdCBmdW5jdGlvbmFsaXR5Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgdGhlIHJhbmRvbSBkb3QgZnVuY3Rpb25hbGl0eSBmcm9tIGFjdGlvbkJ1dHRvbi5qcyBieSBkZWxlZ2F0aW5nIHRvIEFjdGlvbkJ1dHRvbkdyb3VwXG4gICAgICAgIC8vIFRoaXMgYXNzdW1lcyB5b3UgaGF2ZSBhIHJlZiB0byB0aGUgQWN0aW9uQnV0dG9uR3JvdXAgY29tcG9uZW50XG4gICAgICAgIGlmIChhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50ICYmIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQuaGFuZGxlUmFuZG9tRG90KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIHJlZiBtZXRob2QnKTtcbiAgICAgICAgICBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVJhbmRvbURvdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMgJiYgXG4gICAgICAgICAgdHlwZW9mIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlUmFuZG9tRG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGdsb2JhbCBicmlkZ2UgbWV0aG9kJyk7XG4gICAgICAgICAgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucy5oYW5kbGVSYW5kb21Eb3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyBub3QgZm91bmQgZm9yIHJhbmRvbSBkb3QgYWN0aW9uXCIpO1xuICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChcIkVycm9yOiBDYW52YXMgbm90IGF2YWlsYWJsZSBmb3IgcmFuZG9tIGRvdFwiKTtcbiAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7IC8vIFNob3cgVG9wQmFyIGFnYWluIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBwcmV2aWV3QXJlYVJlZi5jdXJyZW50O1xuICAgICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUGFyZW50IG5vdCBmb3VuZCBmb3IgY2FudmFzXCIpO1xuICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChcIkVycm9yOiBDYW52YXMgcGFyZW50IG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgICAgICBzZXRTaG93VG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEluaXRpYWxpemUgY2FudmFzIGV4cGxpY2l0bHlcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYENhbnZhcyByZWFkeSBmb3IgcmFuZG9tIGRvdDogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgZ2xvYmFsIHJlZmVyZW5jZVxuICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb25cbiAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhbmRvbVBvc2l0aW9uKGNhbnZhcywgMjApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERyYXcgdGhlIGRvdCB1c2luZyB0aGUgaW1wb3J0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBjb25zdCBkb3QgPSBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgOCwgZmFsc2UpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBSYW5kb20gZG90IGRyYXduIGF0OiAke3Bvc2l0aW9uLnh9LCAke3Bvc2l0aW9uLnl9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU3RhcnQgYSBjb3VudGRvd24gZm9yIGNhcHR1cmVcbiAgICAgICAgICBydW5Db3VudGRvd24oXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGNhbnZhcyxcbiAgICAgICAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgLy8gVXBkYXRlIFVJIGJhc2VkIG9uIHN0YXR1c1xuICAgICAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgLy8gRW5hYmxlIGNhbWVyYSBiZWZvcmUgY2FwdHVyZVxuICAgICAgICAgICAgICAvLyB0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gV2FpdCBicmllZmx5IGZvciBjYW1lcmEgdG8gaW5pdGlhbGl6ZVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRpcmVjdGx5IGltcG9ydGVkIGNhcHR1cmVJbWFnZXNBdFBvaW50IGZyb20gdGhlIEhlbHBlci9zYXZlZmlsZS5qc1xuICAgICAgICAgICAgICAgIGltcG9ydCgnLi9jb21wb25lbnRzLWd1aS9IZWxwZXIvc2F2ZWZpbGUnKS50aGVuKCh7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgIGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgY2FwdHVyZVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBzZXRTaG93VG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMjAwKTtcbiAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgaW1hZ2VzOlwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW1wb3J0aW5nIHNhdmVmaWxlIG1vZHVsZTpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaGVhZFBvc2UnOlxuICAgICAgICBjb25zdCBuZXdIZWFkUG9zZVN0YXRlID0gIXNob3dIZWFkUG9zZTtcbiAgICAgICAgc2V0U2hvd0hlYWRQb3NlKG5ld0hlYWRQb3NlU3RhdGUpO1xuICAgICAgICBzZXRPdXRwdXRUZXh0KGBIZWFkIHBvc2UgdmlzdWFsaXphdGlvbiAke25ld0hlYWRQb3NlU3RhdGUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgICAgICBpZiAobmV3SGVhZFBvc2VTdGF0ZSAmJiAhc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghbmV3SGVhZFBvc2VTdGF0ZSAmJiAhc2hvd0JvdW5kaW5nQm94ICYmICFzaG93TWFzayAmJiAhc2hvd1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJvY2Vzc29yIG9wdGlvbnMgaWYgY2FtZXJhIGlzIGFjdGl2ZVxuICAgICAgICBpZiAoc2hvd0NhbWVyYSAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAuLi53aW5kb3cudmlkZW9Qcm9jZXNzb3Iub3B0aW9ucyxcbiAgICAgICAgICAgIHNob3dIZWFkUG9zZTogbmV3SGVhZFBvc2VTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ2JvdW5kaW5nQm94JzpcbiAgICAgICAgY29uc3QgbmV3Qm91bmRpbmdCb3hTdGF0ZSA9ICFzaG93Qm91bmRpbmdCb3g7XG4gICAgICAgIHNldFNob3dCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveFN0YXRlKTtcbiAgICAgICAgc2V0T3V0cHV0VGV4dChgQm91bmRpbmcgYm94ICR7bmV3Qm91bmRpbmdCb3hTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICAgICAgaWYgKG5ld0JvdW5kaW5nQm94U3RhdGUgJiYgIXNob3dDYW1lcmEpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld0JvdW5kaW5nQm94U3RhdGUgJiYgIXNob3dIZWFkUG9zZSAmJiAhc2hvd01hc2sgJiYgIXNob3dQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2Nlc3NvciBvcHRpb25zIGlmIGNhbWVyYSBpcyBhY3RpdmVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgLi4ud2luZG93LnZpZGVvUHJvY2Vzc29yLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3g6IG5ld0JvdW5kaW5nQm94U3RhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgY29uc3QgbmV3TWFza1N0YXRlID0gIXNob3dNYXNrO1xuICAgICAgICBzZXRTaG93TWFzayhuZXdNYXNrU3RhdGUpO1xuICAgICAgICBzZXRPdXRwdXRUZXh0KGBNYXNrICR7bmV3TWFza1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgICAgICBpZiAobmV3TWFza1N0YXRlICYmICFzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdNYXNrU3RhdGUgJiYgIXNob3dIZWFkUG9zZSAmJiAhc2hvd0JvdW5kaW5nQm94ICYmICFzaG93UGFyYW1ldGVycykge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9ucyBpZiBjYW1lcmEgaXMgYWN0aXZlXG4gICAgICAgIGlmIChzaG93Q2FtZXJhICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgIC4uLndpbmRvdy52aWRlb1Byb2Nlc3Nvci5vcHRpb25zLFxuICAgICAgICAgICAgc2hvd01hc2s6IG5ld01hc2tTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ3BhcmFtZXRlcnMnOlxuICAgICAgICBjb25zdCBuZXdQYXJhbWV0ZXJzU3RhdGUgPSAhc2hvd1BhcmFtZXRlcnM7XG4gICAgICAgIHNldFNob3dQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnNTdGF0ZSk7XG4gICAgICAgIHNldE91dHB1dFRleHQoYFBhcmFtZXRlcnMgJHtuZXdQYXJhbWV0ZXJzU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgICAgIGlmIChuZXdQYXJhbWV0ZXJzU3RhdGUgJiYgIXNob3dDYW1lcmEpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld1BhcmFtZXRlcnNTdGF0ZSAmJiAhc2hvd0hlYWRQb3NlICYmICFzaG93Qm91bmRpbmdCb3ggJiYgIXNob3dNYXNrKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2Nlc3NvciBvcHRpb25zIGlmIGNhbWVyYSBpcyBhY3RpdmVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgLi4ud2luZG93LnZpZGVvUHJvY2Vzc29yLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93UGFyYW1ldGVyczogbmV3UGFyYW1ldGVyc1N0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgLy8gRml4ZWQgY2FsaWJyYXRlIGNhc2UgaGFuZGxlciBpbiBpbmRleC5qc1xuICAgICAgY2FzZSAnY2FsaWJyYXRlJzpcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nKTtcbiAgICAgICAgc2V0U2hvd1RvcEJhcihmYWxzZSk7XG4gICAgICAgIGlmIChzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgdG9nZ2xlQ2FtZXJhKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldENhbGlicmF0ZSkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgcmVmZXJlbmNlIG1ldGhvZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgQWN0aW9uQnV0dG9uR3JvdXAgcmVmIG1ldGhvZCBmb3IgY2FsaWJyYXRpb24nKTtcbiAgICAgICAgICBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldENhbGlicmF0ZSgpO1xuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zICYmIFxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zLmhhbmRsZVNldENhbGlicmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGdsb2JhbCBtZXRob2RcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgZ2xvYmFsIGJyaWRnZSBtZXRob2QgZm9yIGNhbGlicmF0aW9uJyk7XG4gICAgICAgICAgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucy5oYW5kbGVTZXRDYWxpYnJhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIGNhbnZhcyB0byB3b3JrIHdpdGhcbiAgICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgbm90IGZvdW5kIGZvciBjYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICAgIHNldE91dHB1dFRleHQoXCJFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGUgZm9yIGNhbGlicmF0aW9uXCIpO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTG9hZCBhbGwgcmVxdWlyZWQgbW9kdWxlcyBmaXJzdCwgdGhlbiBwcm9jZWVkIHdpdGggZXhlY3V0aW9uXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgaW1wb3J0KCcuL2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnKSxcbiAgICAgICAgICAgIGltcG9ydCgnLi9jb21wb25lbnRzLWd1aS9BY3Rpb24vY291bnRTYXZlJyksXG4gICAgICAgICAgICBpbXBvcnQoJy4vY29tcG9uZW50cy1ndWkvSGVscGVyL3NhdmVmaWxlJylcbiAgICAgICAgICBdKS50aGVuKGFzeW5jIChbXG4gICAgICAgICAgICBjYWxpYnJhdGVQb2ludHNNb2R1bGUsXG4gICAgICAgICAgICBjb3VudFNhdmVNb2R1bGUsXG4gICAgICAgICAgICBzYXZlZmlsZU1vZHVsZVxuICAgICAgICAgIF0pID0+IHtcbiAgICAgICAgICAgIC8vIERlc3RydWN0dXJlIHRoZSBpbXBvcnRlZCBtb2R1bGVzXG4gICAgICAgICAgICBjb25zdCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSA9IGNhbGlicmF0ZVBvaW50c01vZHVsZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSA9IGNvdW50U2F2ZU1vZHVsZTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSA9IHNhdmVmaWxlTW9kdWxlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcbiAgICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgICAgICAgICByaWdodDogMTBweDtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCAxMnB4JztcbiAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICAgICAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgICAgICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICAgICAgICBgO1xuICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb246IEluaXRpYWxpemluZy4uLic7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFjY2VzcyB3ZWJjYW0gYmVmb3JlIHN0YXJ0aW5nIGNhbGlicmF0aW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXJDYW1lcmFBY2Nlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUHJvY2VzcyBwb2ludHMgc2VxdWVudGlhbGx5XG4gICAgICAgICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgbmV3IHBvaW50XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBSdW4gY291bnRkb3duXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgICBydW5Db3VudGRvd24oXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXc6IHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBjb3VudGVyXG4gICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FwdHVyaW5nIHBvaW50ICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgYSBkZWxheVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRTaG93VG9wQmFyKHRydWUpLCAyMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGltcG9ydCByZXF1aXJlZCBtb2R1bGVzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdjbGVhckFsbCc6XG4gICAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgICAvLyBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgc2V0T3V0cHV0VGV4dCgnQ2FudmFzIGNsZWFyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzZXRPdXRwdXRUZXh0KGBBY3Rpb24gdHJpZ2dlcmVkOiAke2FjdGlvblR5cGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cChmYWxzZSk7XG4gICAgc2V0Q2FtZXJhUGVybWlzc2lvbkdyYW50ZWQodHJ1ZSk7XG4gICAgdG9nZ2xlQ2FtZXJhKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25EZW5pZWQgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgc2V0T3V0cHV0VGV4dCgnQ2FtZXJhIHBlcm1pc3Npb24gZGVuaWVkJyk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2FtZXJhQ2xvc2UgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIHRvZ2dsZUNhbWVyYShmYWxzZSk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2FtZXJhUmVhZHkgPSAoZGltZW5zaW9ucykgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICBzZXRNZXRyaWNzKHtcbiAgICAgIHdpZHRoOiBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkaW1lbnNpb25zLmhlaWdodCxcbiAgICAgIGRpc3RhbmNlOiBkaW1lbnNpb25zLmRpc3RhbmNlIHx8ICctLS0nXG4gICAgfSk7XG4gICAgc2V0T3V0cHV0VGV4dChgQ2FtZXJhIHJlYWR5OiAke2RpbWVuc2lvbnMud2lkdGh9eCR7ZGltZW5zaW9ucy5oZWlnaHR9YCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIHRvcCBiYXIgZnVuY3Rpb25cbiAgY29uc3QgdG9nZ2xlVG9wQmFyID0gKHNob3cpID0+IHtcbiAgICBjb25zdCBuZXdUb3BCYXJTdGF0ZSA9IHNob3cgIT09IHVuZGVmaW5lZCA/IHNob3cgOiAhc2hvd1RvcEJhcjtcbiAgICBzZXRTaG93VG9wQmFyKG5ld1RvcEJhclN0YXRlKTtcbiAgICBcbiAgICAvLyBBbHNvIGhpZGUgbWV0cmljcyB3aGVuIGhpZGluZyB0aGUgdG9wIGJhclxuICAgIGlmICghbmV3VG9wQmFyU3RhdGUpIHtcbiAgICAgIHNldFNob3dNZXRyaWNzKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgc2V0T3V0cHV0VGV4dChgVG9wQmFyICR7bmV3VG9wQmFyU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9JHshbmV3VG9wQmFyU3RhdGUgPyAnLCBNZXRyaWNzIGhpZGRlbicgOiAnJ31gKTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBzdGF0ZSB1cGRhdGUgYW5kIERPTSBjaGFuZ2VzLCB0aGVuIGFkanVzdCBjYW52YXNcbiAgICBzZXRUaW1lb3V0KGFkanVzdENhbnZhc0RpbWVuc2lvbnMsIDEwMCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIG1ldHJpY3MgZnVuY3Rpb25cbiAgY29uc3QgdG9nZ2xlTWV0cmljcyA9ICgpID0+IHtcbiAgICBpZiAoc2hvd1RvcEJhcikge1xuICAgICAgc2V0U2hvd01ldHJpY3MocHJldiA9PiAhcHJldik7XG4gICAgICBzZXRPdXRwdXRUZXh0KGBNZXRyaWNzICR7IXNob3dNZXRyaWNzID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0b3BCYXIgaXMgaGlkZGVuLCB3ZSBjYW4ndCBzaG93IG1ldHJpY3NcbiAgICAgIHNldE91dHB1dFRleHQoJ0Nhbm5vdCBzaG93IG1ldHJpY3Mgd2hlbiBUb3BCYXIgaXMgaGlkZGVuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIHRvIHRyaWdnZXIgY2FtZXJhIGFjY2Vzc1xuICBjb25zdCB0cmlnZ2VyQ2FtZXJhQWNjZXNzID0gKGZvcmNlRW5hYmxlKSA9PiB7XG4gICAgaWYgKGZvcmNlRW5hYmxlKSB7XG4gICAgICAvLyBUcnkgdG8gZW5hYmxlIGNhbWVyYSBkaXJlY3RseVxuICAgICAgaWYgKHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICBzZXRTaG93Q2FtZXJhKHRydWUpO1xuICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgICBzZXRDYW1lcmFQZXJtaXNzaW9uR3JhbnRlZCh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHZpZGVvIHByb2Nlc3Npbmcgd2l0aCBjdXJyZW50IG9wdGlvbnNcbiAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnN0YXJ0VmlkZW9Qcm9jZXNzaW5nKHtcbiAgICAgICAgICBzaG93SGVhZFBvc2UsXG4gICAgICAgICAgc2hvd0JvdW5kaW5nQm94LFxuICAgICAgICAgIHNob3dNYXNrLFxuICAgICAgICAgIHNob3dQYXJhbWV0ZXJzLFxuICAgICAgICAgIHNob3dQcm9jZXNzZWRJbWFnZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBKdXN0IHRvZ2dsZSBjdXJyZW50IHN0YXRlIGlmIG5vdCBmb3JjaW5nXG4gICAgaWYgKGNhbWVyYVBlcm1pc3Npb25HcmFudGVkKSB7XG4gICAgICB0b2dnbGVDYW1lcmEoIXNob3dDYW1lcmEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIER5bmFtaWMgY2xhc3MgdG8gcmVmbGVjdCBjdXJyZW50IHdpbmRvdyBzaXplXG4gIGNvbnN0IGdldFNpemVDbGFzcyA9ICgpID0+IHtcbiAgICBjb25zdCB7IHBlcmNlbnRhZ2UgfSA9IHdpbmRvd1NpemU7XG4gICAgaWYgKHBlcmNlbnRhZ2UgPCAzNSkgcmV0dXJuICd3aW5kb3ctc2l6ZS10aW55JztcbiAgICBpZiAocGVyY2VudGFnZSA8IDUwKSByZXR1cm4gJ3dpbmRvdy1zaXplLXNtYWxsJztcbiAgICBpZiAocGVyY2VudGFnZSA8IDcwKSByZXR1cm4gJ3dpbmRvdy1zaXplLW1lZGl1bSc7XG4gICAgcmV0dXJuICd3aW5kb3ctc2l6ZS1sYXJnZSc7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YG1haW4tY29udGFpbmVyICR7Z2V0U2l6ZUNsYXNzKCl9YH0+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPkNhbWVyYSBEYXRhc2V0IENvbGxlY3Rpb248L3RpdGxlPlxuICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcIiAvPlxuICAgICAgPC9IZWFkPlxuICAgICAgXG4gICAgICB7LyogTG9hZCB0aGUgdmlkZW8gcHJvY2Vzc29yIGNvbXBvbmVudCAqL31cbiAgICAgIHtpc0h5ZHJhdGVkICYmIGlzQ2xpZW50ICYmIDxWaWRlb1Byb2Nlc3NvckNvbXBvbmVudCAvPn1cbiAgICAgIFxuICAgICAgey8qIEJhY2tlbmQgY29ubmVjdGlvbiBzdGF0dXMgYmFubmVyICovfVxuICAgICAge2lzSHlkcmF0ZWQgJiYgYmFja2VuZFN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgKFxuICAgICAgICA8ZGl2IHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBwYWRkaW5nOiAnNnB4IDAnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmUwYjInLFxuICAgICAgICAgIGNvbG9yOiAnI2U2NTEwMCcsXG4gICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICB6SW5kZXg6IDExMDBcbiAgICAgICAgfX0+XG4gICAgICAgICAg4pqg77iPIEJhY2tlbmQgZGlzY29ubmVjdGVkLiBIdXJyeSB1cCwgTWFrZSBPTkxJTkUgcGxlYXNlIGFuZCBVc2luZyBtb2NrIG1vZGVcbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgXG4gICAgICB7LyogVG9wQmFyIGNvbXBvbmVudCB3aXRoIG9uQnV0dG9uQ2xpY2sgaGFuZGxlciAtIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgKi99XG4gICAgICB7c2hvd1RvcEJhciAmJiAoXG4gICAgICAgIDxUb3BCYXIgXG4gICAgICAgICAgb25CdXR0b25DbGljaz17aGFuZGxlQWN0aW9uQnV0dG9uQ2xpY2t9XG4gICAgICAgICAgb25DYW1lcmFBY2Nlc3M9eygpID0+IHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSl9XG4gICAgICAgICAgb3V0cHV0VGV4dD17c3RhdHVzTWVzc2FnZSB8fCBvdXRwdXRUZXh0fVxuICAgICAgICAgIG9uT3V0cHV0Q2hhbmdlPXsodGV4dCkgPT4gc2V0T3V0cHV0VGV4dCh0ZXh0KX1cbiAgICAgICAgICBvblRvZ2dsZVRvcEJhcj17dG9nZ2xlVG9wQmFyfVxuICAgICAgICAgIG9uVG9nZ2xlTWV0cmljcz17dG9nZ2xlTWV0cmljc31cbiAgICAgICAgICBjYW52YXNSZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIHsvKiBTaG93IHJlc3RvcmUgYnV0dG9uIHdoZW4gVG9wQmFyIGlzIGhpZGRlbiAtIHBvc2l0aW9uZWQgYXQgdG9wIHJpZ2h0ICovfVxuICAgICAgeyFzaG93VG9wQmFyICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZXN0b3JlLWJ1dHRvbi1jb250YWluZXJcIiBzdHlsZT17e1xuICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgIHRvcDogJzEwcHgnLFxuICAgICAgICAgIHJpZ2h0OiAnMTBweCcsXG4gICAgICAgICAgekluZGV4OiAxMDAwXG4gICAgICAgIH19PlxuICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJyZXN0b3JlLWJ0blwiXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB0b2dnbGVUb3BCYXIodHJ1ZSl9XG4gICAgICAgICAgICB0aXRsZT1cIlNob3cgVG9wQmFyIGFuZCBNZXRyaWNzXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICDiiaFcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgXG4gICAgICB7LyogV2FybmluZyBtZXNzYWdlIGJhbm5lciAqL31cbiAgICAgIHtpc0h5ZHJhdGVkICYmIHNob3dXYXJuaW5nICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3YXJuaW5nLWJhbm5lclwiIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgdG9wOiBzaG93VG9wQmFyID8gKGJhY2tlbmRTdGF0dXMgPT09ICdkaXNjb25uZWN0ZWQnID8gJzMycHgnIDogJzYwcHgnKSA6ICcwJyxcbiAgICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmZlYjNiJyxcbiAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgIHBhZGRpbmc6ICcxMHB4JyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGJveFNoYWRvdzogJzAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMiknLFxuICAgICAgICAgIHpJbmRleDogMTAxMCxcbiAgICAgICAgICBhbmltYXRpb246ICdmYWRlSW4gMC4zcyBlYXNlLWluLW91dCdcbiAgICAgICAgfX0+XG4gICAgICAgICAgPHN0cm9uZz7imqDvuI8ge3dhcm5pbmdNZXNzYWdlfTwvc3Ryb25nPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBNYWluIHByZXZpZXcgYXJlYSAqL31cbiAgICAgIDxkaXYgXG4gICAgICAgIHJlZj17cHJldmlld0FyZWFSZWZ9XG4gICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wcmV2aWV3LWFyZWFcIlxuICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICBoZWlnaHQ6IHNob3dUb3BCYXIgPyAnY2FsYygxMDB2aCAtIDEyMHB4KScgOiAnMTAwdmgnLFxuICAgICAgICAgIG1hcmdpblRvcDogYmFja2VuZFN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcgPyAnMzJweCcgOiAnMCcsXG4gICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2Y1ZjVmNScsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIHshc2hvd0NhbWVyYSA/IChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW1lcmEtcHJldmlldy1tZXNzYWdlXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogc2hvd1RvcEJhciA/ICdyZWxhdGl2ZScgOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICB6SW5kZXg6IDVcbiAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICA8cD5DYW1lcmEgcHJldmlldyB3aWxsIGFwcGVhciBoZXJlPC9wPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJjYW1lcmEtc2l6ZS1pbmRpY2F0b3JcIj5DdXJyZW50IHdpbmRvdzoge3dpbmRvd1NpemUucGVyY2VudGFnZX0lIG9mIHNjcmVlbiB3aWR0aDwvcD5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHsvKiBDYW1lcmEgcGxhY2Vob2xkZXIgc3F1YXJlIC0gc21hbGwgdmVyc2lvbiAqL31cbiAgICAgICAgICAgICAge2lzSHlkcmF0ZWQgJiYgc2hvd0NhbWVyYVBsYWNlaG9sZGVyICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBsYWNlaG9sZGVyLXNxdWFyZVwiXG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzE4MHB4JyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTM1cHgnLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcyMHB4IGF1dG8nLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICcycHggZGFzaGVkICM2NjYnLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjVmNWY1JyxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFNpemU6ICcxLjVyZW0nIH19PvCfk7c8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHsvKiBBY3Rpb24gYnV0dG9ucyBmb3IgY2FtZXJhIGNvbnRyb2wgKi99XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FtZXJhLWFjdGlvbi1idXR0b25zLWNvbnRhaW5lclwiIHN0eWxlPXt7IFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogJzMwcHgnLCBcbiAgICAgICAgICAgICAgICBtYXhXaWR0aDogJzYwMHB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW46ICczMHB4IGF1dG8nXG4gICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgIDxBY3Rpb25CdXR0b25Hcm91cFxuICAgICAgICAgICAgICAgICAgcmVmPXthY3Rpb25CdXR0b25Hcm91cFJlZn1cbiAgICAgICAgICAgICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3M9e3RyaWdnZXJDYW1lcmFBY2Nlc3N9XG4gICAgICAgICAgICAgICAgICBpc0NvbXBhY3RNb2RlPXt3aW5kb3dTaXplLndpZHRoIDwgNzY4fVxuICAgICAgICAgICAgICAgICAgb25BY3Rpb25DbGljaz17aGFuZGxlQWN0aW9uQnV0dG9uQ2xpY2t9XG4gICAgICAgICAgICAgICAgICBzaG93SGVhZFBvc2U9e3Nob3dIZWFkUG9zZX1cbiAgICAgICAgICAgICAgICAgIHNob3dCb3VuZGluZ0JveD17c2hvd0JvdW5kaW5nQm94fVxuICAgICAgICAgICAgICAgICAgc2hvd01hc2s9e3Nob3dNYXNrfVxuICAgICAgICAgICAgICAgICAgc2hvd1BhcmFtZXRlcnM9e3Nob3dQYXJhbWV0ZXJzfVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHsvKiBDYW52YXMgZm9yIGV5ZSB0cmFja2luZyBkb3RzICovfVxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FudmFzLWNvbnRhaW5lclwiIFxuICAgICAgICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJywgXG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwIFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Y2FudmFzIFxuICAgICAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRyYWNraW5nLWNhbnZhc1wiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyBcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC8+XG4gICAgICAgICkgOiBudWxsfVxuICAgICAgICAgICAgICBcbiAgICAgICAgey8qIE1ldHJpY3MgaW5mbyAtIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgKi99XG4gICAgICAgIHtpc0h5ZHJhdGVkICYmIHNob3dNZXRyaWNzICYmIChcbiAgICAgICAgICA8RGlzcGxheVJlc3BvbnNlIFxuICAgICAgICAgICAgd2lkdGg9e21ldHJpY3Mud2lkdGh9IFxuICAgICAgICAgICAgaGVpZ2h0PXttZXRyaWNzLmhlaWdodH0gXG4gICAgICAgICAgICBkaXN0YW5jZT17bWV0cmljcy5kaXN0YW5jZX1cbiAgICAgICAgICAgIGlzVmlzaWJsZT17c2hvd01ldHJpY3N9XG4gICAgICAgICAgLz5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBDYW1lcmEgY29tcG9uZW50IC0gdXNpbmcgY2xpZW50LW9ubHkgdmVyc2lvbiAqL31cbiAgICAgICAge2lzSHlkcmF0ZWQgJiYgaXNDbGllbnQgJiYgc2hvd0NhbWVyYSAmJiAoXG4gICAgICAgICAgPER5bmFtaWNDYW1lcmFBY2Nlc3NcbiAgICAgICAgICAgIGlzU2hvd2luZz17c2hvd0NhbWVyYX0gXG4gICAgICAgICAgICBvbkNsb3NlPXtoYW5kbGVDYW1lcmFDbG9zZX1cbiAgICAgICAgICAgIG9uQ2FtZXJhUmVhZHk9e2hhbmRsZUNhbWVyYVJlYWR5fVxuICAgICAgICAgICAgc2hvd0hlYWRQb3NlPXtzaG93SGVhZFBvc2V9XG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3g9e3Nob3dCb3VuZGluZ0JveH1cbiAgICAgICAgICAgIHNob3dNYXNrPXtzaG93TWFza31cbiAgICAgICAgICAgIHNob3dQYXJhbWV0ZXJzPXtzaG93UGFyYW1ldGVyc31cbiAgICAgICAgICAgIHZpZGVvUmVmPXt2aWRlb1JlZn1cbiAgICAgICAgICAvPlxuICAgICAgICApfVxuICAgICAgICBcbiAgICAgICAgey8qIENhbWVyYSBwZXJtaXNzaW9uIHBvcHVwICovfVxuICAgICAgICB7aXNIeWRyYXRlZCAmJiBpc0NsaWVudCAmJiBzaG93UGVybWlzc2lvblBvcHVwICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMjAwMFxuICAgICAgICAgIH19PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1kaWFsb2dcIiBzdHlsZT17e1xuICAgICAgICAgICAgICB3aWR0aDogJzQwMHB4JyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMjBweCcsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMiknXG4gICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMTVweCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgICAgICAgfX0+Q2FtZXJhIEFjY2VzcyBSZXF1aXJlZDwvaDM+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLW1lc3NhZ2VcIiBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBcbiAgICAgICAgICAgICAgICBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgICAgICAgICAgIGdhcDogJzEwcHgnXG4gICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uRGVuaWVkfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtYnRuXCJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMwMDY2Y2MnLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENvbnRpbnVlXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn0iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsIkhlYWQiLCJkeW5hbWljIiwiVG9wQmFyIiwiRGlzcGxheVJlc3BvbnNlIiwiQWN0aW9uQnV0dG9uR3JvdXAiLCJTZXR0aW5ncyIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwicnVuQ291bnRkb3duIiwidXNlQ29uc2VudCIsIlZpZGVvUHJvY2Vzc29yQ29tcG9uZW50Iiwic3NyIiwiRHluYW1pY0NhbWVyYUFjY2VzcyIsImxvYWRpbmciLCJkaXYiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInRyYW5zZm9ybSIsIndpZHRoIiwiaGVpZ2h0IiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiYm9yZGVyUmFkaXVzIiwiZGlzcGxheSIsImZsZXhEaXJlY3Rpb24iLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJ0ZXh0QWxpZ24iLCJ6SW5kZXgiLCJmb250U2l6ZSIsIm1hcmdpbkJvdHRvbSIsInAiLCJmb250V2VpZ2h0IiwiY29sb3IiLCJDb2xsZWN0ZWREYXRhc2V0UGFnZSIsImlzSHlkcmF0ZWQiLCJzZXRJc0h5ZHJhdGVkIiwic2hvd0NhbWVyYSIsInNldFNob3dDYW1lcmEiLCJzaG93UGVybWlzc2lvblBvcHVwIiwic2V0U2hvd1Blcm1pc3Npb25Qb3B1cCIsInNob3dUb3BCYXIiLCJzZXRTaG93VG9wQmFyIiwic2hvd01ldHJpY3MiLCJzZXRTaG93TWV0cmljcyIsIm91dHB1dFRleHQiLCJzZXRPdXRwdXRUZXh0IiwibWV0cmljcyIsInNldE1ldHJpY3MiLCJkaXN0YW5jZSIsIndpbmRvd1NpemUiLCJzZXRXaW5kb3dTaXplIiwicGVyY2VudGFnZSIsInByZXZpZXdBcmVhUmVmIiwiY2FudmFzUmVmIiwidmlkZW9SZWYiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsInNldENhcHR1cmVGb2xkZXIiLCJzaG93SGVhZFBvc2UiLCJzZXRTaG93SGVhZFBvc2UiLCJzaG93Qm91bmRpbmdCb3giLCJzZXRTaG93Qm91bmRpbmdCb3giLCJzaG93TWFzayIsInNldFNob3dNYXNrIiwic2hvd1BhcmFtZXRlcnMiLCJzZXRTaG93UGFyYW1ldGVycyIsInNob3dDYW1lcmFQbGFjZWhvbGRlciIsInNldFNob3dDYW1lcmFQbGFjZWhvbGRlciIsImNhbWVyYVBlcm1pc3Npb25HcmFudGVkIiwic2V0Q2FtZXJhUGVybWlzc2lvbkdyYW50ZWQiLCJzaG93V2FybmluZyIsInNldFNob3dXYXJuaW5nIiwid2FybmluZ01lc3NhZ2UiLCJzZXRXYXJuaW5nTWVzc2FnZSIsImJhY2tlbmRTdGF0dXMiLCJzZXRCYWNrZW5kU3RhdHVzIiwiYWN0aW9uQnV0dG9uR3JvdXBSZWYiLCJzdGF0dXNNZXNzYWdlIiwic2V0U3RhdHVzTWVzc2FnZSIsInNob3dTZXR0aW5ncyIsInNldFNob3dTZXR0aW5ncyIsImdldE1haW5DYW52YXMiLCJjdXJyZW50IiwiY29uc29sZSIsImxvZyIsIndpbmRvdyIsIndoaXRlU2NyZWVuQ2FudmFzIiwiZG9jdW1lbnQiLCJjYW52YXNFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsIndhcm4iLCJpc0NsaWVudCIsImNhbnZhcyIsImNhbnZhc0RpbWVuc2lvbnMiLCJpbml0aWFsaXplQ2FudmFzIiwicGFyZW50IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJlcnJvciIsInNldFRpbWVvdXQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZGltZW5zaW9ucyIsInJlY3RTaXplIiwiaXNWaXNpYmxlIiwiYWRqdXN0Q2FudmFzRGltZW5zaW9ucyIsImNvbnRhaW5lciIsInRvcEJhckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwidG9wQmFyVmlzaWJsZSIsImNhbGN1bGF0ZWRIZWlnaHQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsImNvbm5lY3RlZCIsInVwZGF0ZURpbWVuc2lvbnMiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsInNjcmVlblBlcmNlbnRhZ2UiLCJpbm5lcldpZHRoIiwic2NyZWVuIiwicHJldiIsImlubmVySGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjcmVhdGVFbGVtZW50IiwidGV4dENvbnRlbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsInRvZ2dsZVRvcEJhciIsInNob3ciLCJ0b2dnbGVDYW1lcmEiLCJzaG91bGRFbmFibGUiLCJoYW5kbGVBY3Rpb25CdXR0b25DbGljayIsImFjdGlvblR5cGUiLCJwYXJhbXMiLCJuZXdUb3BCYXJTdGF0ZSIsInZhbHVlIiwic2FmZVBhcmFtcyIsInJhbmRvbVRpbWVzIiwiZGVsYXlTZWNvbmRzIiwiaGFuZGxlU2V0UmFuZG9tIiwiYWN0aW9uQnV0dG9uRnVuY3Rpb25zIiwidGltZUlucHV0IiwiZGVsYXlJbnB1dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0aW1lcyIsImRlbGF5IiwicGFyc2VkVGltZSIsInBhcnNlSW50IiwiaXNOYU4iLCJwYXJzZWREZWxheSIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwiY291bnRTYXZlTW9kdWxlIiwic2F2ZWZpbGVNb2R1bGUiLCJzdWNjZXNzQ291bnQiLCJjdXJyZW50Q2FwdHVyZSIsIngiLCJ5IiwicmVkcmF3SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInJlc29sdmUiLCJzdGF0dXMiLCJwcm9jZXNzU3RhdHVzIiwiY2xlYXJJbnRlcnZhbCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJjYXRjaCIsImhhbmRsZVJhbmRvbURvdCIsImRvdCIsImVyciIsIm5ld0hlYWRQb3NlU3RhdGUiLCJ2aWRlb1Byb2Nlc3NvciIsInVwZGF0ZU9wdGlvbnMiLCJvcHRpb25zIiwibmV3Qm91bmRpbmdCb3hTdGF0ZSIsIm5ld01hc2tTdGF0ZSIsIm5ld1BhcmFtZXRlcnNTdGF0ZSIsImhhbmRsZVNldENhbGlicmF0ZSIsImNhbGlicmF0ZVBvaW50c01vZHVsZSIsImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJwb2ludHMiLCJsZW5ndGgiLCJFcnJvciIsInN0YXR1c0luZGljYXRvciIsImNsYXNzTmFtZSIsImNzc1RleHQiLCJib2R5IiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsImkiLCJwYXJlbnROb2RlIiwiaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkIiwiaGFuZGxlUGVybWlzc2lvbkRlbmllZCIsImhhbmRsZUNhbWVyYUNsb3NlIiwiaGFuZGxlQ2FtZXJhUmVhZHkiLCJ1bmRlZmluZWQiLCJ0b2dnbGVNZXRyaWNzIiwiZm9yY2VFbmFibGUiLCJzdGFydFZpZGVvUHJvY2Vzc2luZyIsInNob3dQcm9jZXNzZWRJbWFnZSIsImdldFNpemVDbGFzcyIsInRpdGxlIiwibWV0YSIsIm5hbWUiLCJjb250ZW50IiwicGFkZGluZyIsIm9uQnV0dG9uQ2xpY2siLCJvbkNhbWVyYUFjY2VzcyIsIm9uT3V0cHV0Q2hhbmdlIiwidGV4dCIsIm9uVG9nZ2xlVG9wQmFyIiwib25Ub2dnbGVNZXRyaWNzIiwicmlnaHQiLCJidXR0b24iLCJvbkNsaWNrIiwiYmFja2dyb3VuZCIsImN1cnNvciIsImJveFNoYWRvdyIsImFuaW1hdGlvbiIsInN0cm9uZyIsInJlZiIsIm1hcmdpblRvcCIsIm92ZXJmbG93IiwibWFyZ2luIiwibWF4V2lkdGgiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsImlzU2hvd2luZyIsIm9uQ2xvc2UiLCJvbkNhbWVyYVJlYWR5IiwiaDMiLCJsaW5lSGVpZ2h0IiwiZ2FwIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/index.js\n"));

/***/ })

});