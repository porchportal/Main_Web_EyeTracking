"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useAdminSettings.useState\": ()=>{\n            // Initialize from localStorage on mount\n            return localStorage.getItem('currentUserId');\n        }\n    }[\"useAdminSettings.useState\"]);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [lastUpdateTime, setLastUpdateTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const POLLING_INTERVAL = 10000; // Increase to 10 seconds\n    const MIN_UPDATE_INTERVAL = 2000; // Minimum time between updates\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    // Debug logging for settings changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            console.log('AdminSettings - Current Settings:', settings);\n            console.log('AdminSettings - Current User ID:', currentUserId);\n            console.log('AdminSettings - Is TopBar Updated:', isTopBarUpdated);\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId,\n        isTopBarUpdated\n    ]);\n    // Helper: Fetch settings for a user from backend with caching\n    const fetchSettingsForUser = async (userId)=>{\n        console.log('[AdminSettings] fetchSettingsForUser - userId:', userId);\n        if (!userId) return;\n        // Check cache first\n        const cachedSettings = settingsCache.current.get(userId);\n        const lastUpdate = lastSettingsUpdate.current.get(userId);\n        const now = Date.now();\n        // If we have cached settings and they're recent enough, use them\n        if (cachedSettings && lastUpdate && now - lastUpdate < POLLING_INTERVAL) {\n            console.log('[AdminSettings] Using cached settings for user:', userId);\n            return cachedSettings;\n        }\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to fetch settings');\n            }\n            const result = await response.json();\n            console.log('[AdminSettings] fetchSettingsForUser - Received settings:', result.data);\n            const newSettings = result.data || {};\n            // Only update if settings have actually changed\n            if (!isEqual(settings[userId], newSettings)) {\n                setSettings((prev)=>({\n                        ...prev,\n                        [userId]: newSettings\n                    }));\n                setCurrentSettings(newSettings);\n                // Update cache\n                settingsCache.current.set(userId, newSettings);\n                lastSettingsUpdate.current.set(userId, now);\n                // Update TopBar if ref provided\n                if (ref && ref.current && ref.current.setCaptureSettings) {\n                    console.log('[AdminSettings] Updating TopBar with settings:', newSettings);\n                    ref.current.setCaptureSettings(newSettings);\n                    setIsTopBarUpdated(true);\n                }\n            } else {\n                console.log('[AdminSettings] Settings unchanged, skipping update');\n            }\n            setError(null);\n            return newSettings;\n        } catch (error) {\n            console.error('[AdminSettings] Error fetching settings:', error);\n            setError(error.message);\n            return null;\n        }\n    };\n    // Polling for settings updates with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (!currentUserId) return;\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    const now = Date.now();\n                    if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                        return;\n                    }\n                    try {\n                        const newSettings = await fetchSettingsForUser(currentUserId);\n                        if (newSettings) {\n                            setLastUpdateTime(now);\n                        }\n                    } catch (error) {\n                        console.error('[AdminSettings] Polling error:', error);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            fetchSettings();\n            pollingInterval.current = setInterval(fetchSettings, POLLING_INTERVAL);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref,\n        lastUpdateTime\n    ]);\n    // Listen for userId changes (from index.js navigation)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        console.log('[handleUserIdChange] userId:', event.detail.userId);\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        localStorage.setItem('currentUserId', newUserId);\n                        fetchSettingsForUser(newUserId);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Initial settings fetch on mount if we have a user ID\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (currentUserId && !initialized.current) {\n                fetchSettingsForUser(currentUserId);\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId\n    ]);\n    // Effect to handle index.js update after TopBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount (optional, fallback)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n            // Ignore\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {}\n            } else {\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('[settings useEffect] currentUserId:', currentUserId); // Debug log\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                // Optionally update UI elements if needed\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page (captureSettingsUpdate event)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        console.log('[handleSettingsUpdate] userId:', userId, 'currentUserId:', currentUserId); // Debug log\n                        if (userId === currentUserId) {\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            updateSettings(newSettings, userId);\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    // Update settings for a user with optimization\n    const updateSettings = async (newSettings, userId)=>{\n        console.log('[updateSettings] userId:', userId);\n        if (!userId) return;\n        const now = Date.now();\n        if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n            console.log('[updateSettings] Skipping update - too soon after last update');\n            return;\n        }\n        const updatedSettings = {\n            ...settings[userId],\n            ...newSettings\n        };\n        // Check if settings have actually changed\n        if (isEqual(settings[userId], updatedSettings)) {\n            console.log('[updateSettings] Settings unchanged, skipping update');\n            return;\n        }\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify(updatedSettings)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to save settings');\n            }\n            const result = await response.json();\n            const finalSettings = result.data || updatedSettings;\n            // Update state and cache\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: finalSettings\n                }));\n            setCurrentSettings(finalSettings);\n            settingsCache.current.set(userId, finalSettings);\n            lastSettingsUpdate.current.set(userId, now);\n            setLastUpdateTime(now);\n            setError(null);\n        } catch (error) {\n            setError(error.message);\n        }\n    };\n    // Upload and update image for a user\n    const updateImage = async (userId, base64Image)=>{\n        console.log('[updateImage] userId:', userId); // Debug log\n        if (!userId || !base64Image) return;\n        try {\n            const response = await fetch(\"/api/data-center/image?user_id=\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify({\n                    image: base64Image\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to upload image');\n            }\n            // Optionally, fetch settings again to get updated image info\n            await fetchSettingsForUser(userId);\n            setError(null);\n            return true;\n        } catch (error) {\n            setError(error.message);\n            return false;\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        updateImage,\n        error\n    };\n};\n_s(useAdminSettings, \"Hlm6/5fN62/rwQN5zOCHqniFzLc=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFFcEQsOEJBQThCO0FBQzlCLE1BQU1HLFVBQVUsQ0FBQ0MsTUFBTUM7SUFDckIsSUFBSUQsU0FBU0MsTUFBTSxPQUFPO0lBQzFCLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9DLFNBQVMsVUFBVSxPQUFPO0lBQ2pFLElBQUlELFNBQVMsUUFBUUMsU0FBUyxNQUFNLE9BQU87SUFFM0MsTUFBTUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSjtJQUMxQixNQUFNSyxRQUFRRixPQUFPQyxJQUFJLENBQUNIO0lBRTFCLElBQUlDLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFLE9BQU87SUFFMUMsT0FBT0osTUFBTUssS0FBSyxDQUFDQyxDQUFBQSxNQUNqQkgsTUFBTUksUUFBUSxDQUFDRCxRQUFRVCxRQUFRQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO0FBRXZEO0FBRU8sTUFBTUUsbUJBQW1CLENBQUNDOztJQUMvQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR2YsK0NBQVFBLENBQUMsQ0FBQztJQUMxQyxNQUFNLENBQUNnQixlQUFlQyxpQkFBaUIsR0FBR2pCLCtDQUFRQTtxQ0FBQztZQUNqRCx3Q0FBd0M7WUFDeEMsT0FBT2tCLGFBQWFDLE9BQU8sQ0FBQztRQUM5Qjs7SUFDQSxNQUFNLENBQUNDLGlCQUFpQkMsbUJBQW1CLEdBQUdyQiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUNzQixPQUFPQyxTQUFTLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNd0IsY0FBY3pCLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU0wQixrQkFBa0IxQiw2Q0FBTUEsQ0FBQztJQUMvQixNQUFNLENBQUMyQixpQkFBaUJDLG1CQUFt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O0lBQ0Y7SUFFQSxxQ0FBcUM7SUFDckMsTUFBTThCLGNBQWMsT0FBT3ZELFFBQVF3RDtRQUNqQzNELFFBQVFDLEdBQUcsQ0FBQyx5QkFBeUJFLFNBQVMsWUFBWTtRQUMxRCxJQUFJLENBQUNBLFVBQVUsQ0FBQ3dELGFBQWE7UUFDN0IsSUFBSTtZQUNGLE1BQU1qRCxXQUFXLE1BQU1DLE1BQU0sa0NBQXlDLE9BQVBSLFNBQVU7Z0JBQ3ZFb0QsUUFBUTtnQkFDUjNDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixhQUFhQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO2dCQUNsRDtnQkFDQXlDLE1BQU1aLEtBQUtFLFNBQVMsQ0FBQztvQkFBRWMsT0FBT0Q7Z0JBQVk7WUFDNUM7WUFDQSxJQUFJLENBQUNqRCxTQUFTTSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVAsU0FBU1EsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlDLE1BQU1ILFVBQVVJLE1BQU0sSUFBSTtZQUN0QztZQUNBLDZEQUE2RDtZQUM3RCxNQUFNbkIscUJBQXFCQztZQUMzQmYsU0FBUztZQUNULE9BQU87UUFDVCxFQUFFLE9BQU9ELE9BQU87WUFDZEMsU0FBU0QsTUFBTXlDLE9BQU87WUFDdEIsT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPO1FBQUVqRDtRQUFVMEU7UUFBZ0JLO1FBQWF2RTtJQUFNO0FBQ3hELEVBQUU7R0ExU1dWO0FBNFNiLCtCQUErQjtBQUNoQixTQUFTb0Y7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtLQUZ3QkEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FkbWluU2V0dGluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuZXhwb3J0IGNvbnN0IHVzZUFkbWluU2V0dGluZ3MgPSAocmVmKSA9PiB7XG4gIGNvbnN0IFtzZXR0aW5ncywgc2V0U2V0dGluZ3NdID0gdXNlU3RhdGUoe30pO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY3VycmVudFVzZXJJZCcpO1xuICB9KTtcbiAgY29uc3QgW2lzVG9wQmFyVXBkYXRlZCwgc2V0SXNUb3BCYXJVcGRhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50U2V0dGluZ3MsIHNldEN1cnJlbnRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtsYXN0VXBkYXRlVGltZSwgc2V0TGFzdFVwZGF0ZVRpbWVdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFBPTExJTkdfSU5URVJWQUwgPSAxMDAwMDsgLy8gSW5jcmVhc2UgdG8gMTAgc2Vjb25kc1xuICBjb25zdCBNSU5fVVBEQVRFX0lOVEVSVkFMID0gMjAwMDsgLy8gTWluaW11bSB0aW1lIGJldHdlZW4gdXBkYXRlc1xuICBcbiAgLy8gQWRkIGNhY2hlIGZvciBzZXR0aW5nc1xuICBjb25zdCBzZXR0aW5nc0NhY2hlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IGxhc3RTZXR0aW5nc1VwZGF0ZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuXG4gIC8vIERlYnVnIGxvZ2dpbmcgZm9yIHNldHRpbmdzIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQWRtaW5TZXR0aW5ncyAtIEN1cnJlbnQgU2V0dGluZ3M6Jywgc2V0dGluZ3MpO1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gQ3VycmVudCBVc2VyIElEOicsIGN1cnJlbnRVc2VySWQpO1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gSXMgVG9wQmFyIFVwZGF0ZWQ6JywgaXNUb3BCYXJVcGRhdGVkKTtcbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkLCBpc1RvcEJhclVwZGF0ZWRdKTtcblxuICAvLyBIZWxwZXI6IEZldGNoIHNldHRpbmdzIGZvciBhIHVzZXIgZnJvbSBiYWNrZW5kIHdpdGggY2FjaGluZ1xuICBjb25zdCBmZXRjaFNldHRpbmdzRm9yVXNlciA9IGFzeW5jICh1c2VySWQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIGZldGNoU2V0dGluZ3NGb3JVc2VyIC0gdXNlcklkOicsIHVzZXJJZCk7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcblxuICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgY29uc3QgY2FjaGVkU2V0dGluZ3MgPSBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuZ2V0KHVzZXJJZCk7XG4gICAgY29uc3QgbGFzdFVwZGF0ZSA9IGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LmdldCh1c2VySWQpO1xuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGNhY2hlZCBzZXR0aW5ncyBhbmQgdGhleSdyZSByZWNlbnQgZW5vdWdoLCB1c2UgdGhlbVxuICAgIGlmIChjYWNoZWRTZXR0aW5ncyAmJiBsYXN0VXBkYXRlICYmIChub3cgLSBsYXN0VXBkYXRlIDwgUE9MTElOR19JTlRFUlZBTCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQWRtaW5TZXR0aW5nc10gVXNpbmcgY2FjaGVkIHNldHRpbmdzIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgICByZXR1cm4gY2FjaGVkU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvc2V0dGluZ3MvJHt1c2VySWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBmZXRjaCBzZXR0aW5ncycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIGZldGNoU2V0dGluZ3NGb3JVc2VyIC0gUmVjZWl2ZWQgc2V0dGluZ3M6JywgcmVzdWx0LmRhdGEpO1xuICAgICAgXG4gICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IHJlc3VsdC5kYXRhIHx8IHt9O1xuICAgICAgXG4gICAgICAvLyBPbmx5IHVwZGF0ZSBpZiBzZXR0aW5ncyBoYXZlIGFjdHVhbGx5IGNoYW5nZWRcbiAgICAgIGlmICghaXNFcXVhbChzZXR0aW5nc1t1c2VySWRdLCBuZXdTZXR0aW5ncykpIHtcbiAgICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgW3VzZXJJZF06IG5ld1NldHRpbmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KHVzZXJJZCwgbmV3U2V0dGluZ3MpO1xuICAgICAgICBsYXN0U2V0dGluZ3NVcGRhdGUuY3VycmVudC5zZXQodXNlcklkLCBub3cpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIFRvcEJhciBpZiByZWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCAmJiByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIFVwZGF0aW5nIFRvcEJhciB3aXRoIHNldHRpbmdzOicsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgICByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgICAgIHNldElzVG9wQmFyVXBkYXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBTZXR0aW5ncyB1bmNoYW5nZWQsIHNraXBwaW5nIHVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIHJldHVybiBuZXdTZXR0aW5ncztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0FkbWluU2V0dGluZ3NdIEVycm9yIGZldGNoaW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBvbGxpbmcgZm9yIHNldHRpbmdzIHVwZGF0ZXMgd2l0aCBvcHRpbWl6YXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRVc2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBmZXRjaFNldHRpbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IGF3YWl0IGZldGNoU2V0dGluZ3NGb3JVc2VyKGN1cnJlbnRVc2VySWQpO1xuICAgICAgICBpZiAobmV3U2V0dGluZ3MpIHtcbiAgICAgICAgICBzZXRMYXN0VXBkYXRlVGltZShub3cpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQWRtaW5TZXR0aW5nc10gUG9sbGluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZldGNoU2V0dGluZ3MoKTtcbiAgICBwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCA9IHNldEludGVydmFsKGZldGNoU2V0dGluZ3MsIFBPTExJTkdfSU5URVJWQUwpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocG9sbGluZ0ludGVydmFsLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWQsIHJlZiwgbGFzdFVwZGF0ZVRpbWVdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHVzZXJJZCBjaGFuZ2VzIChmcm9tIGluZGV4LmpzIG5hdmlnYXRpb24pXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC51c2VySWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVVc2VySWRDaGFuZ2VdIHVzZXJJZDonLCBldmVudC5kZXRhaWwudXNlcklkKTtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgc2V0Q3VycmVudFVzZXJJZChuZXdVc2VySWQpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY3VycmVudFVzZXJJZCcsIG5ld1VzZXJJZCk7XG4gICAgICAgIGZldGNoU2V0dGluZ3NGb3JVc2VyKG5ld1VzZXJJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gIH0sIFtyZWZdKTtcblxuICAvLyBJbml0aWFsIHNldHRpbmdzIGZldGNoIG9uIG1vdW50IGlmIHdlIGhhdmUgYSB1c2VyIElEXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRVc2VySWQgJiYgIWluaXRpYWxpemVkLmN1cnJlbnQpIHtcbiAgICAgIGZldGNoU2V0dGluZ3NGb3JVc2VyKGN1cnJlbnRVc2VySWQpO1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgaW5kZXguanMgdXBkYXRlIGFmdGVyIFRvcEJhciBpcyB1cGRhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzVG9wQmFyVXBkYXRlZCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NldHRpbmdzVXBkYXRlZCcsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdHlwZTogJ3NldHRpbmdzJyxcbiAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtpc1RvcEJhclVwZGF0ZWQsIGN1cnJlbnRVc2VySWQsIHNldHRpbmdzXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudCAob3B0aW9uYWwsIGZhbGxiYWNrKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FkbWluU2V0dGluZ3MnKTtcbiAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFNldHRpbmdzID0gSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKTtcbiAgICAgICAgc2V0U2V0dGluZ3MocGFyc2VkU2V0dGluZ3MpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZSB3aGVuIHRoZXkgY2hhbmdlIChvcHRpb25hbClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FkbWluU2V0dGluZ3MnLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gVXBkYXRlIHNldHRpbmdzIHdoZW4gdGhleSBjaGFuZ2UgaW4gdGhlIGNvbnRleHRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2V0dGluZ3MgJiYgY3VycmVudFVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tzZXR0aW5ncyB1c2VFZmZlY3RdIGN1cnJlbnRVc2VySWQ6JywgY3VycmVudFVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbY3VycmVudFVzZXJJZF07XG4gICAgICBpZiAodXNlclNldHRpbmdzKSB7XG4gICAgICAgIHNldEN1cnJlbnRTZXR0aW5ncyh1c2VyU2V0dGluZ3MpO1xuICAgICAgICAvLyBPcHRpb25hbGx5IHVwZGF0ZSBVSSBlbGVtZW50cyBpZiBuZWVkZWRcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlcyBmcm9tIGFkbWluIHBhZ2UgKGNhcHR1cmVTZXR0aW5nc1VwZGF0ZSBldmVudClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzLCBkZWxheSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVNldHRpbmdzVXBkYXRlXSB1c2VySWQ6JywgdXNlcklkLCAnY3VycmVudFVzZXJJZDonLCBjdXJyZW50VXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgICAgIGlmICh1c2VySWQgPT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnRTZXR0aW5ncyxcbiAgICAgICAgICAgIHRpbWVzOiB0aW1lcyAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKHRpbWVzKSA6IGN1cnJlbnRTZXR0aW5ncy50aW1lcyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKGRlbGF5KSA6IGN1cnJlbnRTZXR0aW5ncy5kZWxheVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBuZXdTZXR0aW5ncyB9KSk7XG4gICAgICAgICAgdXBkYXRlU2V0dGluZ3MobmV3U2V0dGluZ3MsIHVzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gIH0sIFtjdXJyZW50VXNlcklkLCBjdXJyZW50U2V0dGluZ3NdKTtcblxuICAvLyBVcGRhdGUgc2V0dGluZ3MgZm9yIGEgdXNlciB3aXRoIG9wdGltaXphdGlvblxuICBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IGFzeW5jIChuZXdTZXR0aW5ncywgdXNlcklkKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1cGRhdGVTZXR0aW5nc10gdXNlcklkOicsIHVzZXJJZCk7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlU2V0dGluZ3NdIFNraXBwaW5nIHVwZGF0ZSAtIHRvbyBzb29uIGFmdGVyIGxhc3QgdXBkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3NbdXNlcklkXSxcbiAgICAgIC4uLm5ld1NldHRpbmdzXG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIHNldHRpbmdzIGhhdmUgYWN0dWFsbHkgY2hhbmdlZFxuICAgIGlmIChpc0VxdWFsKHNldHRpbmdzW3VzZXJJZF0sIHVwZGF0ZWRTZXR0aW5ncykpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlU2V0dGluZ3NdIFNldHRpbmdzIHVuY2hhbmdlZCwgc2tpcHBpbmcgdXBkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvc2V0dGluZ3MvJHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkodXBkYXRlZFNldHRpbmdzKVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIHNhdmUgc2V0dGluZ3MnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc3QgZmluYWxTZXR0aW5ncyA9IHJlc3VsdC5kYXRhIHx8IHVwZGF0ZWRTZXR0aW5ncztcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXRlIGFuZCBjYWNoZVxuICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogZmluYWxTZXR0aW5ncyB9KSk7XG4gICAgICBzZXRDdXJyZW50U2V0dGluZ3MoZmluYWxTZXR0aW5ncyk7XG4gICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KHVzZXJJZCwgZmluYWxTZXR0aW5ncyk7XG4gICAgICBsYXN0U2V0dGluZ3NVcGRhdGUuY3VycmVudC5zZXQodXNlcklkLCBub3cpO1xuICAgICAgc2V0TGFzdFVwZGF0ZVRpbWUobm93KTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXBsb2FkIGFuZCB1cGRhdGUgaW1hZ2UgZm9yIGEgdXNlclxuICBjb25zdCB1cGRhdGVJbWFnZSA9IGFzeW5jICh1c2VySWQsIGJhc2U2NEltYWdlKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1cGRhdGVJbWFnZV0gdXNlcklkOicsIHVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgIGlmICghdXNlcklkIHx8ICFiYXNlNjRJbWFnZSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL2ltYWdlP3VzZXJfaWQ9JHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbWFnZTogYmFzZTY0SW1hZ2UgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gdXBsb2FkIGltYWdlJyk7XG4gICAgICB9XG4gICAgICAvLyBPcHRpb25hbGx5LCBmZXRjaCBzZXR0aW5ncyBhZ2FpbiB0byBnZXQgdXBkYXRlZCBpbWFnZSBpbmZvXG4gICAgICBhd2FpdCBmZXRjaFNldHRpbmdzRm9yVXNlcih1c2VySWQpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncywgdXBkYXRlSW1hZ2UsIGVycm9yIH07XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBZG1pblNldHRpbmdzKCkge1xuICByZXR1cm4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJrZXlzMSIsIk9iamVjdCIsImtleXMiLCJrZXlzMiIsImxlbmd0aCIsImV2ZXJ5Iiwia2V5IiwiaW5jbHVkZXMiLCJ1c2VBZG1pblNldHRpbmdzIiwicmVmIiwic2V0dGluZ3MiLCJzZXRTZXR0aW5ncyIsImN1cnJlbnRVc2VySWQiLCJzZXRDdXJyZW50VXNlcklkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImlzVG9wQmFyVXBkYXRlZCIsInNldElzVG9wQmFyVXBkYXRlZCIsImVycm9yIiwic2V0RXJyb3IiLCJpbml0aWFsaXplZCIsInBvbGxpbmdJbnRlcnZhbCIsImN1cnJlbnRTZXR0aW5ncyIsInNldEN1cnJlbnRTZXR0aW5ncyIsImxhc3RVcGRhdGVUaW1lIiwic2V0TGFzdFVwZGF0ZVRpbWUiLCJQT0xMSU5HX0lOVEVSVkFMIiwiTUlOX1VQREFURV9JTlRFUlZBTCIsInNldHRpbmdzQ2FjaGUiLCJNYXAiLCJsYXN0U2V0dGluZ3NVcGRhdGUiLCJjb25zb2xlIiwibG9nIiwiZmV0Y2hTZXR0aW5nc0ZvclVzZXIiLCJ1c2VySWQiLCJjYWNoZWRTZXR0aW5ncyIsImN1cnJlbnQiLCJnZXQiLCJsYXN0VXBkYXRlIiwibm93IiwiRGF0ZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJoZWFkZXJzIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9LRVkiLCJvayIsImVycm9yRGF0YSIsImpzb24iLCJjYXRjaCIsIkVycm9yIiwiZGV0YWlsIiwicmVzdWx0IiwiZGF0YSIsIm5ld1NldHRpbmdzIiwicHJldiIsInNldCIsInNldENhcHR1cmVTZXR0aW5ncyIsIm1lc3NhZ2UiLCJmZXRjaFNldHRpbmdzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJuZXdVc2VySWQiLCJzZXRJdGVtIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJDdXN0b21FdmVudCIsInR5cGUiLCJkaXNwYXRjaEV2ZW50Iiwic2F2ZWRTZXR0aW5ncyIsInBhcnNlZFNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwidXNlclNldHRpbmdzIiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJ0aW1lcyIsImRlbGF5IiwidW5kZWZpbmVkIiwiTnVtYmVyIiwidXBkYXRlU2V0dGluZ3MiLCJ1cGRhdGVkU2V0dGluZ3MiLCJtZXRob2QiLCJib2R5IiwiZmluYWxTZXR0aW5ncyIsInVwZGF0ZUltYWdlIiwiYmFzZTY0SW1hZ2UiLCJpbWFnZSIsIkFkbWluU2V0dGluZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});