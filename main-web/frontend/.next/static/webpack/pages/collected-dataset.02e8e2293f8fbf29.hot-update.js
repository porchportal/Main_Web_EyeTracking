"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Helper/savefile.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureImagesAtPoint: () => (/* binding */ captureImagesAtPoint),\n/* harmony export */   saveCSVToServer: () => (/* binding */ saveCSVToServer),\n/* harmony export */   saveImageToServer: () => (/* binding */ saveImageToServer)\n/* harmony export */ });\n// Helper/savefile.js - Added highest resolution webcam capture\n/**\n * Resize an image to fit within a certain size limit\n * @param {string} imageDataUrl - Base64 encoded image data\n * @param {number} maxWidth - Maximum width of the resized image\n * @param {number} maxHeight - Maximum height of the resized image\n * @param {number} quality - JPEG quality (0-1)\n * @returns {Promise<string>} - Resized image data URL\n */ const resizeImage = async function(imageDataUrl) {\n    let maxWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 800, maxHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 600, quality = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85;\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = new Image();\n            img.onload = ()=>{\n                // Calculate new dimensions while maintaining aspect ratio\n                let width = img.width;\n                let height = img.height;\n                if (width > maxWidth) {\n                    height = Math.round(height * (maxWidth / width));\n                    width = maxWidth;\n                }\n                if (height > maxHeight) {\n                    width = Math.round(width * (maxHeight / height));\n                    height = maxHeight;\n                }\n                // Create canvas for resizing\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                // Draw and resize image on canvas\n                const ctx = canvas.getContext('2d');\n                ctx.drawImage(img, 0, 0, width, height);\n                // Convert to JPEG with specified quality\n                const resizedDataUrl = canvas.toDataURL('image/jpeg', quality);\n                resolve(resizedDataUrl);\n            };\n            img.onerror = (err)=>reject(err);\n            img.src = imageDataUrl;\n        } catch (err) {\n            reject(err);\n        }\n    });\n};\n/**\n * Save an image or data to the server with group ID to ensure consistent numbering\n * @param {string} imageData - Base64 encoded image data\n * @param {string} filename - Filename pattern to save as\n * @param {string} type - Type of file (screen, webcam, parameters)\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveImageToServer = async function(imageData, filename, type) {\n    let folder = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'eye_tracking_captures', captureGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    try {\n        const response = await fetch('/api/save-capture', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                imageData,\n                filename,\n                type,\n                folder,\n                captureGroup\n            })\n        });\n        if (!response.ok) {\n            console.error(\"Server returned \".concat(response.status, \" for \").concat(type));\n            // If the error is 413 (payload too large) and it's an image, try resizing\n            if (response.status === 413 && type !== 'parameters') {\n                console.warn(\"Image too large for server (413 error), will resize and retry\");\n                // Start with higher quality and progressively reduce quality/size until it fits\n                const sizes = [\n                    {\n                        width: 1920,\n                        height: 1080,\n                        quality: 0.9\n                    },\n                    {\n                        width: 1280,\n                        height: 720,\n                        quality: 0.85\n                    },\n                    {\n                        width: 800,\n                        height: 600,\n                        quality: 0.8\n                    },\n                    {\n                        width: 640,\n                        height: 480,\n                        quality: 0.75\n                    }\n                ];\n                for (const { width, height, quality } of sizes){\n                    const resizedImage = await resizeImage(imageData, width, height, quality);\n                    try {\n                        const retryResponse = await fetch('/api/save-capture', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify({\n                                imageData: resizedImage,\n                                filename,\n                                type,\n                                folder,\n                                captureGroup\n                            })\n                        });\n                        if (retryResponse.ok) {\n                            console.log(\"Successfully saved resized \".concat(type, \" at \").concat(width, \"x\").concat(height, \", quality \").concat(quality));\n                            return await retryResponse.json();\n                        }\n                    } catch (retryError) {\n                        console.error(\"Error during retry for \".concat(type, \":\"), retryError);\n                    }\n                }\n                return {\n                    success: false,\n                    error: \"Failed to save image even after resizing\"\n                };\n            }\n            return {\n                success: false,\n                error: \"Server returned \".concat(response.status)\n            };\n        }\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error(\"Error saving \".concat(type, \":\"), error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Save CSV data to the server\n * @param {string} csvData - CSV data\n * @param {string} filename - Filename pattern to save as\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveCSVToServer = async function(csvData, filename) {\n    let folder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'eye_tracking_captures', captureGroup = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        const csvBlob = new Blob([\n            csvData\n        ], {\n            type: 'text/csv'\n        });\n        const reader = new FileReader();\n        const csvDataUrl = await new Promise((resolve)=>{\n            reader.onloadend = ()=>resolve(reader.result);\n            reader.readAsDataURL(csvBlob);\n        });\n        const result = await saveImageToServer(csvDataUrl, filename, 'parameters', folder, captureGroup);\n        return result;\n    } catch (error) {\n        console.error('Error saving CSV:', error);\n        return null;\n    }\n};\n/**\n * Get the highest resolution camera constraints supported by the device\n * @returns {Promise<MediaStreamConstraints>} - Camera constraints with highest resolution\n */ const getHighestResolutionConstraints = async ()=>{\n    // Try to get all available camera capabilities first\n    try {\n        var _videoTrack_getCapabilities;\n        // Get a temporary access to the camera\n        const tempStream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        const videoTrack = tempStream.getVideoTracks()[0];\n        // Get capabilities\n        const capabilities = (_videoTrack_getCapabilities = videoTrack.getCapabilities) === null || _videoTrack_getCapabilities === void 0 ? void 0 : _videoTrack_getCapabilities.call(videoTrack);\n        console.log(\"Camera capabilities:\", capabilities);\n        // Stop the temporary stream\n        videoTrack.stop();\n        if (capabilities && capabilities.width && capabilities.height) {\n            // Use the max width and height from device capabilities\n            return {\n                video: {\n                    width: {\n                        ideal: capabilities.width.max\n                    },\n                    height: {\n                        ideal: capabilities.height.max\n                    }\n                }\n            };\n        }\n    } catch (err) {\n        console.log(\"Could not get camera capabilities:\", err);\n    }\n    // Fallback: try standard resolutions in order\n    const resolutions = [\n        {\n            width: {\n                ideal: 4096\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 3840\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 2560\n            },\n            height: {\n                ideal: 1440\n            }\n        },\n        {\n            width: {\n                ideal: 1920\n            },\n            height: {\n                ideal: 1080\n            }\n        },\n        {\n            width: {\n                ideal: 1280\n            },\n            height: {\n                ideal: 720\n            }\n        },\n        {\n            width: {\n                ideal: 640\n            },\n            height: {\n                ideal: 480\n            }\n        },\n        {} // Default - let browser decide\n    ];\n    // Try the resolutions in order until one works\n    for (const resolution of resolutions){\n        try {\n            const constraints = {\n                video: {\n                    ...resolution,\n                    facingMode: \"user\"\n                }\n            };\n            // Test if this resolution is supported\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n            // Get the actual dimensions\n            const videoTrack = stream.getVideoTracks()[0];\n            const settings = videoTrack.getSettings();\n            console.log(\"Supported resolution:\", settings.width, \"x\", settings.height);\n            // Stop the test stream immediately\n            stream.getTracks().forEach((track)=>track.stop());\n            return constraints;\n        } catch (err) {\n            console.log(\"Resolution not supported: \".concat(JSON.stringify(resolution)));\n        // Continue to next resolution\n        }\n    }\n    // If nothing worked, return basic constraints\n    return {\n        video: true\n    };\n};\n/**\n * Capture and save images at a specific point with consistent numbering\n * @param {Object} options - Capture options\n * @returns {Promise<Object>} - Capture results\n */ const captureImagesAtPoint = async (param)=>{\n    let { point, captureCount = 1, canvasRef, setCaptureCount, showCapturePreview } = param;\n    try {\n        const folder = 'eye_tracking_captures';\n        // Create a unique ID for this capture group\n        const captureGroupId = \"capture-\".concat(Date.now());\n        console.log(\"Generated capture group ID: \".concat(captureGroupId));\n        // File patterns for saving\n        const screenFilename = 'screen_001.jpg'; // Pattern only - server will assign number\n        const webcamFilename = 'webcam_001.jpg'; // Pattern only - server will assign number\n        const parameterFilename = 'parameter_001.csv'; // Pattern only - server will assign number\n        // For logging\n        console.log(\"Starting capture with group ID:\", captureGroupId);\n        const canvas = canvasRef.current;\n        let screenImage = null;\n        let webcamImage = null;\n        let captureNumber = null;\n        // Variables to store webcam resolution\n        let webcamWidth = 0;\n        let webcamHeight = 0;\n        // 1. Prepare all data first\n        // 1.1 Canvas/screen image\n        if (canvas) {\n            screenImage = canvas.toDataURL('image/png');\n        }\n        // 1.2 Webcam image - Try to get the highest resolution available \n        // with device's native capabilities instead of fixed values\n        let webcamImagePreview = null; // Separate lower-resolution version for preview\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            try {\n                // Use existing video element if available\n                // First check if videoTrack has settings info\n                let trackSettings = null;\n                if (videoElement.srcObject) {\n                    const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                    if (videoTrack) {\n                        trackSettings = videoTrack.getSettings();\n                        console.log(\"Video track settings:\", trackSettings);\n                    }\n                }\n                // Get dimensions from track if available, otherwise from element\n                if (trackSettings && trackSettings.width && trackSettings.height) {\n                    webcamWidth = trackSettings.width;\n                    webcamHeight = trackSettings.height;\n                    console.log(\"Using track settings dimensions: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                    const settings = videoTrack.getSettings();\n                    webcamWidth = settings.width || 0;\n                    webcamHeight = settings.height || 0;\n                    console.log(\"Using track.getSettings(): \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Sanity check - if both dimensions are the same, double-check\n                if (webcamWidth === webcamHeight && webcamWidth > 100) {\n                    console.warn(\"Suspicious square aspect ratio detected, double-checking dimensions\");\n                    // Try to get more reliable info\n                    if (videoElement.srcObject) {\n                        const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                        if (videoTrack) {\n                            const constraints = videoTrack.getConstraints();\n                            console.log(\"Video constraints:\", constraints);\n                            // If constraints have width/height, use those\n                            if (constraints.width && constraints.height) {\n                                if (typeof constraints.width.exact === 'number') {\n                                    webcamWidth = constraints.width.exact;\n                                } else if (typeof constraints.width.ideal === 'number') {\n                                    webcamWidth = constraints.width.ideal;\n                                }\n                                if (typeof constraints.height.exact === 'number') {\n                                    webcamHeight = constraints.height.exact;\n                                } else if (typeof constraints.height.ideal === 'number') {\n                                    webcamHeight = constraints.height.ideal;\n                                }\n                                console.log(\"Updated dimensions from constraints: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            }\n                        }\n                    }\n                }\n                // Final reality check - make sure dimensions are reasonable\n                if (webcamWidth <= 0 || webcamHeight <= 0) {\n                    console.warn(\"Invalid webcam dimensions, using defaults\");\n                    webcamWidth = 640;\n                    webcamHeight = 480;\n                }\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = webcamWidth;\n                tempCanvas.height = webcamHeight;\n                tempCanvas.getContext('2d').drawImage(videoElement, 0, 0, webcamWidth, webcamHeight);\n                // Create high-resolution version for saving\n                webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                // Create lower-resolution version for preview\n                webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                console.log(\"Webcam capture complete at resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n            } catch (err) {\n                console.error(\"Error capturing from existing video element:\", err);\n                webcamWidth = videoElement.videoWidth || 640;\n                webcamHeight = videoElement.videoHeight || 480;\n            }\n        } else {\n            try {\n                // Get highest resolution constraints for this device\n                const constraints = await getHighestResolutionConstraints();\n                console.log(\"Using camera constraints:\", constraints);\n                // Try to get stream with highest resolution\n                const stream = await navigator.mediaDevices.getUserMedia(constraints);\n                // Get the actual dimensions from the track first\n                const videoTrack = stream.getVideoTracks()[0];\n                const trackSettings = videoTrack.getSettings();\n                console.log(\"Actual camera settings:\", trackSettings);\n                // Create temporary video element to get the stream\n                const tempVideo = document.createElement('video');\n                tempVideo.srcObject = stream;\n                tempVideo.muted = true;\n                tempVideo.playsInline = true;\n                tempVideo.autoplay = true;\n                document.body.appendChild(tempVideo);\n                // Need to wait for video to be initialized\n                await new Promise((resolve)=>{\n                    tempVideo.onloadedmetadata = ()=>{\n                        tempVideo.play();\n                        resolve();\n                    };\n                    // Fallback if onloadedmetadata doesn't fire\n                    setTimeout(resolve, 1000);\n                });\n                // Wait a bit longer for the video to actually start playing\n                await new Promise((res)=>setTimeout(res, 500));\n                // Store webcam resolution - prioritize track settings over video element\n                if (trackSettings && trackSettings.width && trackSettings.height) {\n                    webcamWidth = trackSettings.width;\n                    webcamHeight = trackSettings.height;\n                    console.log(\"Using track settings for resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    webcamWidth = tempVideo.videoWidth || 0;\n                    webcamHeight = tempVideo.videoHeight || 0;\n                    console.log(\"Using video element for resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Reality check on dimensions\n                if (webcamWidth <= 0 || webcamHeight <= 0) {\n                    console.warn(\"Invalid webcam dimensions, trying to get from constraints\");\n                    if (constraints.video && typeof constraints.video === 'object') {\n                        if (constraints.video.width && constraints.video.width.ideal) {\n                            webcamWidth = constraints.video.width.ideal;\n                        }\n                        if (constraints.video.height && constraints.video.height.ideal) {\n                            webcamHeight = constraints.video.height.ideal;\n                        }\n                    }\n                    if (webcamWidth <= 0 || webcamHeight <= 0) {\n                        console.warn(\"Still invalid dimensions, using defaults\");\n                        webcamWidth = 640;\n                        webcamHeight = 480;\n                    }\n                }\n                // Final check for square aspect ratio which is usually incorrect\n                if (webcamWidth === webcamHeight && webcamWidth > 100) {\n                    var _videoTrack_getCapabilities;\n                    console.warn(\"Square aspect ratio detected, may be incorrect\");\n                    // Try to get more reliable dimensions\n                    const capabilities = (_videoTrack_getCapabilities = videoTrack.getCapabilities) === null || _videoTrack_getCapabilities === void 0 ? void 0 : _videoTrack_getCapabilities.call(videoTrack);\n                    if (capabilities && capabilities.width && capabilities.height) {\n                        if (capabilities.width.max && capabilities.height.max) {\n                            // Assume the maximum capabilities have the correct aspect ratio\n                            const aspectRatio = capabilities.width.max / capabilities.height.max;\n                            if (Math.abs(aspectRatio - 1.33) < 0.1) {\n                                webcamHeight = Math.round(webcamWidth / 1.33);\n                                console.log(\"Corrected to 4:3 aspect ratio: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            } else if (Math.abs(aspectRatio - 1.78) < 0.1) {\n                                webcamHeight = Math.round(webcamWidth / 1.78);\n                                console.log(\"Corrected to 16:9 aspect ratio: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            }\n                        }\n                    }\n                }\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = webcamWidth;\n                tempCanvas.height = webcamHeight;\n                tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0, webcamWidth, webcamHeight);\n                // Create high-resolution version for saving\n                webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                // Create lower-resolution version for preview\n                webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                console.log(\"High-resolution webcam capture complete: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                // Clean up\n                stream.getTracks().forEach((t)=>t.stop());\n                tempVideo.remove();\n            } catch (err) {\n                console.warn(\"High-resolution webcam capture failed:\", err);\n                // Try one more time with basic constraints\n                try {\n                    const stream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const videoTrack = stream.getVideoTracks()[0];\n                    const trackSettings = videoTrack.getSettings();\n                    const tempVideo = document.createElement('video');\n                    tempVideo.srcObject = stream;\n                    tempVideo.muted = true;\n                    tempVideo.playsInline = true;\n                    document.body.appendChild(tempVideo);\n                    await tempVideo.play();\n                    await new Promise((res)=>setTimeout(res, 300));\n                    // Get dimensions from track settings if available\n                    if (trackSettings && trackSettings.width && trackSettings.height) {\n                        webcamWidth = trackSettings.width;\n                        webcamHeight = trackSettings.height;\n                    } else {\n                        webcamWidth = tempVideo.videoWidth || 0;\n                        webcamHeight = tempVideo.videoHeight || 0;\n                    }\n                    // Final check for invalid dimensions\n                    if (webcamWidth <= 0 || webcamHeight <= 0) {\n                        webcamWidth = 640;\n                        webcamHeight = 480;\n                    }\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0, webcamWidth, webcamHeight);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.9);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.8);\n                    console.log(\"Basic webcam resolution captured: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                    stream.getTracks().forEach((t)=>t.stop());\n                    tempVideo.remove();\n                } catch (fallbackErr) {\n                    console.error(\"All webcam capture methods failed:\", fallbackErr);\n                    webcamWidth = 640;\n                    webcamHeight = 480;\n                }\n            }\n        }\n        // 1.3 Parameter data - Now including webcam resolution\n        const csvData = [\n            \"name,value\",\n            \"dot_x,\".concat(point.x),\n            \"dot_y,\".concat(point.y),\n            \"canvas_width,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.width) || 0),\n            \"canvas_height,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.height) || 0),\n            \"window_width,\".concat(window.innerWidth),\n            \"window_height,\".concat(window.innerHeight),\n            \"webcam_resolution_width,\".concat(webcamWidth),\n            \"webcam_resolution_height,\".concat(webcamHeight),\n            \"timestamp,\".concat(new Date().toISOString()),\n            \"group_id,\".concat(captureGroupId)\n        ].join('\\n');\n        // 2. Save all files with the same group ID so they get the same number\n        // 2.1 Save parameter file\n        const paramResult = await saveCSVToServer(csvData, parameterFilename, folder, captureGroupId);\n        if (paramResult && paramResult.success) {\n            captureNumber = paramResult.number;\n            console.log(\"Server assigned capture number: \".concat(captureNumber, \" for group: \").concat(captureGroupId));\n        }\n        // 2.2 Save screen image if available\n        let screenResult = null;\n        if (screenImage) {\n            screenResult = await saveImageToServer(screenImage, screenFilename, 'screen', folder, captureGroupId);\n        }\n        // 2.3 Save webcam image if available\n        let webcamResult = null;\n        if (webcamImage) {\n            webcamResult = await saveImageToServer(webcamImage, webcamFilename, 'webcam', folder, captureGroupId);\n        }\n        // 3. Show preview if needed - use the lower resolution version for preview\n        if (showCapturePreview && typeof showCapturePreview === 'function') {\n            showCapturePreview(screenImage, webcamImagePreview || webcamImage, point);\n        }\n        // 4. Increment counter for next capture\n        if (setCaptureCount && typeof setCaptureCount === 'function') {\n            setCaptureCount((prevCount)=>prevCount + 1);\n        }\n        // 5. Return results - now including webcam resolution\n        return {\n            screenImage,\n            webcamImage,\n            success: true,\n            point,\n            captureNumber,\n            groupId: captureGroupId,\n            webcamWidth,\n            webcamHeight\n        };\n    } catch (err) {\n        console.error(\"captureImagesAtPoint failed:\", err);\n        return {\n            success: false,\n            error: err.message,\n            screenImage: null,\n            webcamImage: null,\n            webcamWidth: 0,\n            webcamHeight: 0\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0hlbHBlci9zYXZlZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrREFBK0Q7QUFFL0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLGNBQWMsZUFBT0M7UUFBY0MsNEVBQVcsS0FBS0MsNkVBQVksS0FBS0MsMkVBQVU7SUFDbEYsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCLElBQUk7WUFDRixNQUFNQyxNQUFNLElBQUlDO1lBQ2hCRCxJQUFJRSxNQUFNLEdBQUc7Z0JBQ1gsMERBQTBEO2dCQUMxRCxJQUFJQyxRQUFRSCxJQUFJRyxLQUFLO2dCQUNyQixJQUFJQyxTQUFTSixJQUFJSSxNQUFNO2dCQUV2QixJQUFJRCxRQUFRVCxVQUFVO29CQUNwQlUsU0FBU0MsS0FBS0MsS0FBSyxDQUFDRixTQUFVVixDQUFBQSxXQUFXUyxLQUFJO29CQUM3Q0EsUUFBUVQ7Z0JBQ1Y7Z0JBRUEsSUFBSVUsU0FBU1QsV0FBVztvQkFDdEJRLFFBQVFFLEtBQUtDLEtBQUssQ0FBQ0gsUUFBU1IsQ0FBQUEsWUFBWVMsTUFBSztvQkFDN0NBLFNBQVNUO2dCQUNYO2dCQUVBLDZCQUE2QjtnQkFDN0IsTUFBTVksU0FBU0MsU0FBU0MsYUFBYSxDQUFDO2dCQUN0Q0YsT0FBT0osS0FBSyxHQUFHQTtnQkFDZkksT0FBT0gsTUFBTSxHQUFHQTtnQkFFaEIsa0NBQWtDO2dCQUNsQyxNQUFNTSxNQUFNSCxPQUFPSSxVQUFVLENBQUM7Z0JBQzlCRCxJQUFJRSxTQUFTLENBQUNaLEtBQUssR0FBRyxHQUFHRyxPQUFPQztnQkFFaEMseUNBQXlDO2dCQUN6QyxNQUFNUyxpQkFBaUJOLE9BQU9PLFNBQVMsQ0FBQyxjQUFjbEI7Z0JBQ3RERSxRQUFRZTtZQUNWO1lBRUFiLElBQUllLE9BQU8sR0FBRyxDQUFDQyxNQUFRakIsT0FBT2lCO1lBQzlCaEIsSUFBSWlCLEdBQUcsR0FB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QUFjLGdCQUE2QixPQUFmVDtRQUM3RTtRQUVBLHFDQUFxQztRQUNyQyxJQUFJNkMsZUFBZTtRQUNuQixJQUFJdEMsYUFBYTtZQUNmc0MsZUFBZSxNQUFNOUcsa0JBQWtCd0UsYUFBYUosZ0JBQWdCLFVBQVVoRSxRQUFRNkQ7UUFDeEY7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSThDLGVBQWU7UUFDbkIsSUFBSXRDLGFBQWE7WUFDZnNDLGVBQWUsTUFBTS9HLGtCQUFrQnlFLGFBQWFKLGdCQUFnQixVQUFVakUsUUFBUTZEO1FBQ3hGO1FBRUEsMkVBQTJFO1FBQzNFLElBQUlELHNCQUFzQixPQUFPQSx1QkFBdUIsWUFBWTtZQUNsRUEsbUJBQW1CUSxhQUFhSyxzQkFBc0JKLGFBQWFiO1FBQ3JFO1FBRUEsd0NBQXdDO1FBQ3hDLElBQUlHLG1CQUFtQixPQUFPQSxvQkFBb0IsWUFBWTtZQUM1REEsZ0JBQWdCaUQsQ0FBQUEsWUFBYUEsWUFBWTtRQUMzQztRQUVBLHNEQUFzRDtRQUN0RCxPQUFPO1lBQ0x4QztZQUNBQztZQUNBakQsU0FBUztZQUNUb0M7WUFDQWM7WUFDQXVDLFNBQVNoRDtZQUNUVTtZQUNBQztRQUNGO0lBQ0YsRUFBRSxPQUFPOUUsS0FBSztRQUNaZ0IsUUFBUUMsS0FBSyxDQUFDLGdDQUFnQ2pCO1FBQzlDLE9BQU87WUFDTDBCLFNBQVM7WUFDVFQsT0FBT2pCLElBQUk0QixPQUFPO1lBQ2xCOEMsYUFBYTtZQUNiQyxhQUFhO1lBQ2JFLGFBQWE7WUFDYkMsY0FBYztRQUNoQjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0hlbHBlci9zYXZlZmlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWxwZXIvc2F2ZWZpbGUuanMgLSBBZGRlZCBoaWdoZXN0IHJlc29sdXRpb24gd2ViY2FtIGNhcHR1cmVcblxuLyoqXG4gKiBSZXNpemUgYW4gaW1hZ2UgdG8gZml0IHdpdGhpbiBhIGNlcnRhaW4gc2l6ZSBsaW1pdFxuICogQHBhcmFtIHtzdHJpbmd9IGltYWdlRGF0YVVybCAtIEJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIE1heGltdW0gd2lkdGggb2YgdGhlIHJlc2l6ZWQgaW1hZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSBNYXhpbXVtIGhlaWdodCBvZiB0aGUgcmVzaXplZCBpbWFnZVxuICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHkgLSBKUEVHIHF1YWxpdHkgKDAtMSlcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gUmVzaXplZCBpbWFnZSBkYXRhIFVSTFxuICovXG5jb25zdCByZXNpemVJbWFnZSA9IGFzeW5jIChpbWFnZURhdGFVcmwsIG1heFdpZHRoID0gODAwLCBtYXhIZWlnaHQgPSA2MDAsIHF1YWxpdHkgPSAwLjg1KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBkaW1lbnNpb25zIHdoaWxlIG1haW50YWluaW5nIGFzcGVjdCByYXRpb1xuICAgICAgICBsZXQgd2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAqIChtYXhXaWR0aCAvIHdpZHRoKSk7XG4gICAgICAgICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAqIChtYXhIZWlnaHQgLyBoZWlnaHQpKTtcbiAgICAgICAgICBoZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjYW52YXMgZm9yIHJlc2l6aW5nXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgYW5kIHJlc2l6ZSBpbWFnZSBvbiBjYW52YXNcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgdG8gSlBFRyB3aXRoIHNwZWNpZmllZCBxdWFsaXR5XG4gICAgICAgIGNvbnN0IHJlc2l6ZWREYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkpO1xuICAgICAgICByZXNvbHZlKHJlc2l6ZWREYXRhVXJsKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGltZy5vbmVycm9yID0gKGVycikgPT4gcmVqZWN0KGVycik7XG4gICAgICBpbWcuc3JjID0gaW1hZ2VEYXRhVXJsO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogU2F2ZSBhbiBpbWFnZSBvciBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2l0aCBncm91cCBJRCB0byBlbnN1cmUgY29uc2lzdGVudCBudW1iZXJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGEgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBGaWxlbmFtZSBwYXR0ZXJuIHRvIHNhdmUgYXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBmaWxlIChzY3JlZW4sIHdlYmNhbSwgcGFyYW1ldGVycylcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBpblxuICogQHBhcmFtIHtzdHJpbmd9IGNhcHR1cmVHcm91cCAtIFVuaXF1ZSBJRCBmb3IgZ3JvdXBpbmcgZmlsZXMgZnJvbSB0aGUgc2FtZSBjYXB0dXJlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFNlcnZlciByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3Qgc2F2ZUltYWdlVG9TZXJ2ZXIgPSBhc3luYyAoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgdHlwZSwgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsIGNhcHR1cmVHcm91cCA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgaW1hZ2VEYXRhLCBcbiAgICAgICAgZmlsZW5hbWUsIFxuICAgICAgICB0eXBlLCBcbiAgICAgICAgZm9sZGVyLFxuICAgICAgICBjYXB0dXJlR3JvdXAgLy8gSW5jbHVkZSB0aGUgY2FwdHVyZSBncm91cCBJRFxuICAgICAgfSlcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9IGZvciAke3R5cGV9YCk7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZSBlcnJvciBpcyA0MTMgKHBheWxvYWQgdG9vIGxhcmdlKSBhbmQgaXQncyBhbiBpbWFnZSwgdHJ5IHJlc2l6aW5nXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MTMgJiYgdHlwZSAhPT0gJ3BhcmFtZXRlcnMnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW1hZ2UgdG9vIGxhcmdlIGZvciBzZXJ2ZXIgKDQxMyBlcnJvciksIHdpbGwgcmVzaXplIGFuZCByZXRyeWApO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBoaWdoZXIgcXVhbGl0eSBhbmQgcHJvZ3Jlc3NpdmVseSByZWR1Y2UgcXVhbGl0eS9zaXplIHVudGlsIGl0IGZpdHNcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBbXG4gICAgICAgICAgeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwLCBxdWFsaXR5OiAwLjkgfSxcbiAgICAgICAgICB7IHdpZHRoOiAxMjgwLCBoZWlnaHQ6IDcyMCwgcXVhbGl0eTogMC44NSB9LFxuICAgICAgICAgIHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAsIHF1YWxpdHk6IDAuOCB9LFxuICAgICAgICAgIHsgd2lkdGg6IDY0MCwgaGVpZ2h0OiA0ODAsIHF1YWxpdHk6IDAuNzUgfVxuICAgICAgICBdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkgfSBvZiBzaXplcykge1xuICAgICAgICAgIGNvbnN0IHJlc2l6ZWRJbWFnZSA9IGF3YWl0IHJlc2l6ZUltYWdlKGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YTogcmVzaXplZEltYWdlLCBcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSwgXG4gICAgICAgICAgICAgICAgdHlwZSwgXG4gICAgICAgICAgICAgICAgZm9sZGVyLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVHcm91cFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZXRyeVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgc2F2ZWQgcmVzaXplZCAke3R5cGV9IGF0ICR7d2lkdGh9eCR7aGVpZ2h0fSwgcXVhbGl0eSAke3F1YWxpdHl9YCk7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXRyeVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChyZXRyeUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgcmV0cnkgZm9yICR7dHlwZX06YCwgcmV0cnlFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiRmFpbGVkIHRvIHNhdmUgaW1hZ2UgZXZlbiBhZnRlciByZXNpemluZ1wiIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c31gIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyAke3R5cGV9OmAsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBTYXZlIENTViBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3ZEYXRhIC0gQ1NWIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIEZpbGVuYW1lIHBhdHRlcm4gdG8gc2F2ZSBhc1xuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIEZvbGRlciB0byBzYXZlIGluXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FwdHVyZUdyb3VwIC0gVW5pcXVlIElEIGZvciBncm91cGluZyBmaWxlcyBmcm9tIHRoZSBzYW1lIGNhcHR1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gU2VydmVyIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBzYXZlQ1NWVG9TZXJ2ZXIgPSBhc3luYyAoY3N2RGF0YSwgZmlsZW5hbWUsIGZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLCBjYXB0dXJlR3JvdXAgPSBudWxsKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoY3N2RGF0YVVybCwgZmlsZW5hbWUsICdwYXJhbWV0ZXJzJywgZm9sZGVyLCBjYXB0dXJlR3JvdXApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIENTVjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBoaWdoZXN0IHJlc29sdXRpb24gY2FtZXJhIGNvbnN0cmFpbnRzIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPn0gLSBDYW1lcmEgY29uc3RyYWludHMgd2l0aCBoaWdoZXN0IHJlc29sdXRpb25cbiAqL1xuY29uc3QgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cyA9IGFzeW5jICgpID0+IHtcbiAgLy8gVHJ5IHRvIGdldCBhbGwgYXZhaWxhYmxlIGNhbWVyYSBjYXBhYmlsaXRpZXMgZmlyc3RcbiAgdHJ5IHtcbiAgICAvLyBHZXQgYSB0ZW1wb3JhcnkgYWNjZXNzIHRvIHRoZSBjYW1lcmFcbiAgICBjb25zdCB0ZW1wU3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gdGVtcFN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgIFxuICAgIC8vIEdldCBjYXBhYmlsaXRpZXNcbiAgICBjb25zdCBjYXBhYmlsaXRpZXMgPSB2aWRlb1RyYWNrLmdldENhcGFiaWxpdGllcz8uKCk7XG4gICAgY29uc29sZS5sb2coXCJDYW1lcmEgY2FwYWJpbGl0aWVzOlwiLCBjYXBhYmlsaXRpZXMpO1xuICAgIFxuICAgIC8vIFN0b3AgdGhlIHRlbXBvcmFyeSBzdHJlYW1cbiAgICB2aWRlb1RyYWNrLnN0b3AoKTtcbiAgICBcbiAgICBpZiAoY2FwYWJpbGl0aWVzICYmIGNhcGFiaWxpdGllcy53aWR0aCAmJiBjYXBhYmlsaXRpZXMuaGVpZ2h0KSB7XG4gICAgICAvLyBVc2UgdGhlIG1heCB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gZGV2aWNlIGNhcGFiaWxpdGllc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICB3aWR0aDogeyBpZGVhbDogY2FwYWJpbGl0aWVzLndpZHRoLm1heCB9LFxuICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogY2FwYWJpbGl0aWVzLmhlaWdodC5tYXggfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5sb2coXCJDb3VsZCBub3QgZ2V0IGNhbWVyYSBjYXBhYmlsaXRpZXM6XCIsIGVycik7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrOiB0cnkgc3RhbmRhcmQgcmVzb2x1dGlvbnMgaW4gb3JkZXJcbiAgY29uc3QgcmVzb2x1dGlvbnMgPSBbXG4gICAgeyB3aWR0aDogeyBpZGVhbDogNDA5NiB9LCBoZWlnaHQ6IHsgaWRlYWw6IDIxNjAgfSB9LCAvLyA0S1xuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDM4NDAgfSwgaGVpZ2h0OiB7IGlkZWFsOiAyMTYwIH0gfSwgLy8gNEsgVUhEXG4gICAgeyB3aWR0aDogeyBpZGVhbDogMjU2MCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDE0NDAgfSB9LCAvLyAySyBRSERcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiAxOTIwIH0sIGhlaWdodDogeyBpZGVhbDogMTA4MCB9IH0sIC8vIEZ1bGwgSERcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiAxMjgwIH0sIGhlaWdodDogeyBpZGVhbDogNzIwIH0gfSwgIC8vIEhEXG4gICAgeyB3aWR0aDogeyBpZGVhbDogNjQwIH0sIGhlaWdodDogeyBpZGVhbDogNDgwIH0gfSwgICAvLyBWR0FcbiAgICB7fSAgLy8gRGVmYXVsdCAtIGxldCBicm93c2VyIGRlY2lkZVxuICBdO1xuXG4gIC8vIFRyeSB0aGUgcmVzb2x1dGlvbnMgaW4gb3JkZXIgdW50aWwgb25lIHdvcmtzXG4gIGZvciAoY29uc3QgcmVzb2x1dGlvbiBvZiByZXNvbHV0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHtcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAuLi5yZXNvbHV0aW9uLFxuICAgICAgICAgIGZhY2luZ01vZGU6IFwidXNlclwiXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFRlc3QgaWYgdGhpcyByZXNvbHV0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGFjdHVhbCBkaW1lbnNpb25zXG4gICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3VwcG9ydGVkIHJlc29sdXRpb246XCIsIHNldHRpbmdzLndpZHRoLCBcInhcIiwgc2V0dGluZ3MuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gU3RvcCB0aGUgdGVzdCBzdHJlYW0gaW1tZWRpYXRlbHlcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICBcbiAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBSZXNvbHV0aW9uIG5vdCBzdXBwb3J0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x1dGlvbil9YCk7XG4gICAgICAvLyBDb250aW51ZSB0byBuZXh0IHJlc29sdXRpb25cbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIG5vdGhpbmcgd29ya2VkLCByZXR1cm4gYmFzaWMgY29uc3RyYWludHNcbiAgcmV0dXJuIHsgdmlkZW86IHRydWUgfTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZSBhbmQgc2F2ZSBpbWFnZXMgYXQgYSBzcGVjaWZpYyBwb2ludCB3aXRoIGNvbnNpc3RlbnQgbnVtYmVyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENhcHR1cmUgb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBDYXB0dXJlIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcHR1cmVJbWFnZXNBdFBvaW50ID0gYXN5bmMgKHsgcG9pbnQsIGNhcHR1cmVDb3VudCA9IDEsIGNhbnZhc1JlZiwgc2V0Q2FwdHVyZUNvdW50LCBzaG93Q2FwdHVyZVByZXZpZXcgfSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBjYXB0dXJlIGdyb3VwXG4gICAgY29uc3QgY2FwdHVyZUdyb3VwSWQgPSBgY2FwdHVyZS0ke0RhdGUubm93KCl9YDtcbiAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGVkIGNhcHR1cmUgZ3JvdXAgSUQ6ICR7Y2FwdHVyZUdyb3VwSWR9YCk7XG4gICAgXG4gICAgLy8gRmlsZSBwYXR0ZXJucyBmb3Igc2F2aW5nXG4gICAgY29uc3Qgc2NyZWVuRmlsZW5hbWUgPSAnc2NyZWVuXzAwMS5qcGcnOyAgLy8gUGF0dGVybiBvbmx5IC0gc2VydmVyIHdpbGwgYXNzaWduIG51bWJlclxuICAgIGNvbnN0IHdlYmNhbUZpbGVuYW1lID0gJ3dlYmNhbV8wMDEuanBnJzsgIC8vIFBhdHRlcm4gb25seSAtIHNlcnZlciB3aWxsIGFzc2lnbiBudW1iZXJcbiAgICBjb25zdCBwYXJhbWV0ZXJGaWxlbmFtZSA9ICdwYXJhbWV0ZXJfMDAxLmNzdic7ICAvLyBQYXR0ZXJuIG9ubHkgLSBzZXJ2ZXIgd2lsbCBhc3NpZ24gbnVtYmVyXG4gICAgXG4gICAgLy8gRm9yIGxvZ2dpbmdcbiAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGNhcHR1cmUgd2l0aCBncm91cCBJRDpcIiwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGxldCBzY3JlZW5JbWFnZSA9IG51bGw7XG4gICAgbGV0IHdlYmNhbUltYWdlID0gbnVsbDtcbiAgICBsZXQgY2FwdHVyZU51bWJlciA9IG51bGw7XG4gICAgXG4gICAgLy8gVmFyaWFibGVzIHRvIHN0b3JlIHdlYmNhbSByZXNvbHV0aW9uXG4gICAgbGV0IHdlYmNhbVdpZHRoID0gMDtcbiAgICBsZXQgd2ViY2FtSGVpZ2h0ID0gMDtcbiAgICBcbiAgICAvLyAxLiBQcmVwYXJlIGFsbCBkYXRhIGZpcnN0XG4gICAgXG4gICAgLy8gMS4xIENhbnZhcy9zY3JlZW4gaW1hZ2VcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBzY3JlZW5JbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgIH1cblxuICAgIC8vIDEuMiBXZWJjYW0gaW1hZ2UgLSBUcnkgdG8gZ2V0IHRoZSBoaWdoZXN0IHJlc29sdXRpb24gYXZhaWxhYmxlIFxuICAgIC8vIHdpdGggZGV2aWNlJ3MgbmF0aXZlIGNhcGFiaWxpdGllcyBpbnN0ZWFkIG9mIGZpeGVkIHZhbHVlc1xuICAgIGxldCB3ZWJjYW1JbWFnZVByZXZpZXcgPSBudWxsOyAvLyBTZXBhcmF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB3aW5kb3cudmlkZW9FbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgXG4gICAgaWYgKHZpZGVvRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVXNlIGV4aXN0aW5nIHZpZGVvIGVsZW1lbnQgaWYgYXZhaWxhYmxlXG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHZpZGVvVHJhY2sgaGFzIHNldHRpbmdzIGluZm9cbiAgICAgICAgbGV0IHRyYWNrU2V0dGluZ3MgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5zcmNPYmplY3QpIHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdmlkZW9FbGVtZW50LnNyY09iamVjdC5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0cmFja1NldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyB0cmFjayBzZXR0aW5nczpcIiwgdHJhY2tTZXR0aW5ncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgZGltZW5zaW9ucyBmcm9tIHRyYWNrIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZyb20gZWxlbWVudFxuICAgICAgICBpZiAodHJhY2tTZXR0aW5ncyAmJiB0cmFja1NldHRpbmdzLndpZHRoICYmIHRyYWNrU2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSB0cmFja1NldHRpbmdzLndpZHRoO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IHRyYWNrU2V0dGluZ3MuaGVpZ2h0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyB0cmFjayBzZXR0aW5ncyBkaW1lbnNpb25zOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdmlkZW9FbGVtZW50LnNyY09iamVjdC5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICAgIGNvbnN0IHNldHRpbmdzICAgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgd2ViY2FtV2lkdGggID0gc2V0dGluZ3Mud2lkdGggIHx8IDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gc2V0dGluZ3MuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHRyYWNrLmdldFNldHRpbmdzKCk6ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTYW5pdHkgY2hlY2sgLSBpZiBib3RoIGRpbWVuc2lvbnMgYXJlIHRoZSBzYW1lLCBkb3VibGUtY2hlY2tcbiAgICAgICAgaWYgKHdlYmNhbVdpZHRoID09PSB3ZWJjYW1IZWlnaHQgJiYgd2ViY2FtV2lkdGggPiAxMDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTdXNwaWNpb3VzIHNxdWFyZSBhc3BlY3QgcmF0aW8gZGV0ZWN0ZWQsIGRvdWJsZS1jaGVja2luZyBkaW1lbnNpb25zXCIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSB0byBnZXQgbW9yZSByZWxpYWJsZSBpbmZvXG4gICAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5zcmNPYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgICBpZiAodmlkZW9UcmFjaykge1xuICAgICAgICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHZpZGVvVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyBjb25zdHJhaW50czpcIiwgY29uc3RyYWludHMpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gSWYgY29uc3RyYWludHMgaGF2ZSB3aWR0aC9oZWlnaHQsIHVzZSB0aG9zZVxuICAgICAgICAgICAgICBpZiAoY29uc3RyYWludHMud2lkdGggJiYgY29uc3RyYWludHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zdHJhaW50cy53aWR0aC5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gY29uc3RyYWludHMud2lkdGguZXhhY3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29uc3RyYWludHMud2lkdGguaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICB3ZWJjYW1XaWR0aCA9IGNvbnN0cmFpbnRzLndpZHRoLmlkZWFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLmhlaWdodC5leGFjdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHdlYmNhbUhlaWdodCA9IGNvbnN0cmFpbnRzLmhlaWdodC5leGFjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJhaW50cy5oZWlnaHQuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBjb25zdHJhaW50cy5oZWlnaHQuaWRlYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIGRpbWVuc2lvbnMgZnJvbSBjb25zdHJhaW50czogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmFsIHJlYWxpdHkgY2hlY2sgLSBtYWtlIHN1cmUgZGltZW5zaW9ucyBhcmUgcmVhc29uYWJsZVxuICAgICAgICBpZiAod2ViY2FtV2lkdGggPD0gMCB8fCB3ZWJjYW1IZWlnaHQgPD0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgd2ViY2FtIGRpbWVuc2lvbnMsIHVzaW5nIGRlZmF1bHRzXCIpO1xuICAgICAgICAgIHdlYmNhbVdpZHRoID0gNjQwO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IDQ4MDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2ViY2FtV2lkdGg7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gd2ViY2FtSGVpZ2h0O1xuICAgICAgICB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHZpZGVvRWxlbWVudCwgMCwgMCwgd2ViY2FtV2lkdGgsIHdlYmNhbUhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgaGlnaC1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHNhdmluZ1xuICAgICAgICB3ZWJjYW1JbWFnZSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC45NSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgbG93ZXItcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgICAgIHdlYmNhbUltYWdlUHJldmlldyA9IGF3YWl0IHJlc2l6ZUltYWdlKHdlYmNhbUltYWdlLCA2NDAsIDQ4MCwgMC44NSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgV2ViY2FtIGNhcHR1cmUgY29tcGxldGUgYXQgcmVzb2x1dGlvbjogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhcHR1cmluZyBmcm9tIGV4aXN0aW5nIHZpZGVvIGVsZW1lbnQ6XCIsIGVycik7XG4gICAgICAgIHdlYmNhbVdpZHRoID0gdmlkZW9FbGVtZW50LnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICB3ZWJjYW1IZWlnaHQgPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBHZXQgaGlnaGVzdCByZXNvbHV0aW9uIGNvbnN0cmFpbnRzIGZvciB0aGlzIGRldmljZVxuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IGdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBjYW1lcmEgY29uc3RyYWludHM6XCIsIGNvbnN0cmFpbnRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSB0byBnZXQgc3RyZWFtIHdpdGggaGlnaGVzdCByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgYWN0dWFsIGRpbWVuc2lvbnMgZnJvbSB0aGUgdHJhY2sgZmlyc3RcbiAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICBjb25zdCB0cmFja1NldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkFjdHVhbCBjYW1lcmEgc2V0dGluZ3M6XCIsIHRyYWNrU2V0dGluZ3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHRlbXBvcmFyeSB2aWRlbyBlbGVtZW50IHRvIGdldCB0aGUgc3RyZWFtXG4gICAgICAgIGNvbnN0IHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIHRlbXBWaWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE5lZWQgdG8gd2FpdCBmb3IgdmlkZW8gdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkbWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICB0ZW1wVmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gRmFsbGJhY2sgaWYgb25sb2FkZWRtZXRhZGF0YSBkb2Vzbid0IGZpcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSBiaXQgbG9uZ2VyIGZvciB0aGUgdmlkZW8gdG8gYWN0dWFsbHkgc3RhcnQgcGxheWluZ1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgd2ViY2FtIHJlc29sdXRpb24gLSBwcmlvcml0aXplIHRyYWNrIHNldHRpbmdzIG92ZXIgdmlkZW8gZWxlbWVudFxuICAgICAgICBpZiAodHJhY2tTZXR0aW5ncyAmJiB0cmFja1NldHRpbmdzLndpZHRoICYmIHRyYWNrU2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSB0cmFja1NldHRpbmdzLndpZHRoO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IHRyYWNrU2V0dGluZ3MuaGVpZ2h0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyB0cmFjayBzZXR0aW5ncyBmb3IgcmVzb2x1dGlvbjogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCAwO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCAwO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyB2aWRlbyBlbGVtZW50IGZvciByZXNvbHV0aW9uOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUmVhbGl0eSBjaGVjayBvbiBkaW1lbnNpb25zXG4gICAgICAgIGlmICh3ZWJjYW1XaWR0aCA8PSAwIHx8IHdlYmNhbUhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCB3ZWJjYW0gZGltZW5zaW9ucywgdHJ5aW5nIHRvIGdldCBmcm9tIGNvbnN0cmFpbnRzXCIpO1xuICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlbyAmJiB0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludHMudmlkZW8ud2lkdGggJiYgY29uc3RyYWludHMudmlkZW8ud2lkdGguaWRlYWwpIHtcbiAgICAgICAgICAgICAgd2ViY2FtV2lkdGggPSBjb25zdHJhaW50cy52aWRlby53aWR0aC5pZGVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlby5oZWlnaHQgJiYgY29uc3RyYWludHMudmlkZW8uaGVpZ2h0LmlkZWFsKSB7XG4gICAgICAgICAgICAgIHdlYmNhbUhlaWdodCA9IGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodC5pZGVhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHdlYmNhbVdpZHRoIDw9IDAgfHwgd2ViY2FtSGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0aWxsIGludmFsaWQgZGltZW5zaW9ucywgdXNpbmcgZGVmYXVsdHNcIik7XG4gICAgICAgICAgICB3ZWJjYW1XaWR0aCA9IDY0MDtcbiAgICAgICAgICAgIHdlYmNhbUhlaWdodCA9IDQ4MDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEZpbmFsIGNoZWNrIGZvciBzcXVhcmUgYXNwZWN0IHJhdGlvIHdoaWNoIGlzIHVzdWFsbHkgaW5jb3JyZWN0XG4gICAgICAgIGlmICh3ZWJjYW1XaWR0aCA9PT0gd2ViY2FtSGVpZ2h0ICYmIHdlYmNhbVdpZHRoID4gMTAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiU3F1YXJlIGFzcGVjdCByYXRpbyBkZXRlY3RlZCwgbWF5IGJlIGluY29ycmVjdFwiKTtcbiAgICAgICAgICAvLyBUcnkgdG8gZ2V0IG1vcmUgcmVsaWFibGUgZGltZW5zaW9uc1xuICAgICAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHZpZGVvVHJhY2suZ2V0Q2FwYWJpbGl0aWVzPy4oKTtcbiAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzICYmIGNhcGFiaWxpdGllcy53aWR0aCAmJiBjYXBhYmlsaXRpZXMuaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLndpZHRoLm1heCAmJiBjYXBhYmlsaXRpZXMuaGVpZ2h0Lm1heCkge1xuICAgICAgICAgICAgICAvLyBBc3N1bWUgdGhlIG1heGltdW0gY2FwYWJpbGl0aWVzIGhhdmUgdGhlIGNvcnJlY3QgYXNwZWN0IHJhdGlvXG4gICAgICAgICAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gY2FwYWJpbGl0aWVzLndpZHRoLm1heCAvIGNhcGFiaWxpdGllcy5oZWlnaHQubWF4O1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGFzcGVjdFJhdGlvIC0gMS4zMykgPCAwLjEpIHsgLy8gQ2xvc2UgdG8gNDozXG4gICAgICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gTWF0aC5yb3VuZCh3ZWJjYW1XaWR0aCAvIDEuMzMpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb3JyZWN0ZWQgdG8gNDozIGFzcGVjdCByYXRpbzogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoTWF0aC5hYnMoYXNwZWN0UmF0aW8gLSAxLjc4KSA8IDAuMSkgeyAvLyBDbG9zZSB0byAxNjo5XG4gICAgICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gTWF0aC5yb3VuZCh3ZWJjYW1XaWR0aCAvIDEuNzgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb3JyZWN0ZWQgdG8gMTY6OSBhc3BlY3QgcmF0aW86ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3ZWJjYW1XaWR0aDtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwLCB3ZWJjYW1XaWR0aCwgd2ViY2FtSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgICAgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gYXdhaXQgcmVzaXplSW1hZ2Uod2ViY2FtSW1hZ2UsIDY0MCwgNDgwLCAwLjg1KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBIaWdoLXJlc29sdXRpb24gd2ViY2FtIGNhcHR1cmUgY29tcGxldGU6ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XG4gICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJIaWdoLXJlc29sdXRpb24gd2ViY2FtIGNhcHR1cmUgZmFpbGVkOlwiLCBlcnIpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IG9uZSBtb3JlIHRpbWUgd2l0aCBiYXNpYyBjb25zdHJhaW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSk7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICAgIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgIHRlbXBWaWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgICAgYXdhaXQgdGVtcFZpZGVvLnBsYXkoKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDMwMCkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBkaW1lbnNpb25zIGZyb20gdHJhY2sgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKHRyYWNrU2V0dGluZ3MgJiYgdHJhY2tTZXR0aW5ncy53aWR0aCAmJiB0cmFja1NldHRpbmdzLmhlaWdodCkge1xuICAgICAgICAgICAgd2ViY2FtV2lkdGggPSB0cmFja1NldHRpbmdzLndpZHRoO1xuICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdHJhY2tTZXR0aW5ncy5oZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgMDtcbiAgICAgICAgICAgIHdlYmNhbUhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBGaW5hbCBjaGVjayBmb3IgaW52YWxpZCBkaW1lbnNpb25zXG4gICAgICAgICAgaWYgKHdlYmNhbVdpZHRoIDw9IDAgfHwgd2ViY2FtSGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gNjQwO1xuICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdlYmNhbVdpZHRoO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gd2ViY2FtSGVpZ2h0O1xuICAgICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwLCB3ZWJjYW1XaWR0aCwgd2ViY2FtSGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgaGlnaC1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHNhdmluZ1xuICAgICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgICAgICB3ZWJjYW1JbWFnZVByZXZpZXcgPSBhd2FpdCByZXNpemVJbWFnZSh3ZWJjYW1JbWFnZSwgNjQwLCA0ODAsIDAuOCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYEJhc2ljIHdlYmNhbSByZXNvbHV0aW9uIGNhcHR1cmVkOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgICB0ZW1wVmlkZW8ucmVtb3ZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGZhbGxiYWNrRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkFsbCB3ZWJjYW0gY2FwdHVyZSBtZXRob2RzIGZhaWxlZDpcIiwgZmFsbGJhY2tFcnIpO1xuICAgICAgICAgIHdlYmNhbVdpZHRoID0gNjQwO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IDQ4MDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEuMyBQYXJhbWV0ZXIgZGF0YSAtIE5vdyBpbmNsdWRpbmcgd2ViY2FtIHJlc29sdXRpb25cbiAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICBgZG90X3gsJHtwb2ludC54fWAsXG4gICAgICBgZG90X3ksJHtwb2ludC55fWAsXG4gICAgICBgY2FudmFzX3dpZHRoLCR7Y2FudmFzPy53aWR0aCB8fCAwfWAsXG4gICAgICBgY2FudmFzX2hlaWdodCwke2NhbnZhcz8uaGVpZ2h0IHx8IDB9YCxcbiAgICAgIGB3aW5kb3dfd2lkdGgsJHt3aW5kb3cuaW5uZXJXaWR0aH1gLFxuICAgICAgYHdpbmRvd19oZWlnaHQsJHt3aW5kb3cuaW5uZXJIZWlnaHR9YCxcbiAgICAgIGB3ZWJjYW1fcmVzb2x1dGlvbl93aWR0aCwke3dlYmNhbVdpZHRofWAsXG4gICAgICBgd2ViY2FtX3Jlc29sdXRpb25faGVpZ2h0LCR7d2ViY2FtSGVpZ2h0fWAsXG4gICAgICBgdGltZXN0YW1wLCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXG4gICAgICBgZ3JvdXBfaWQsJHtjYXB0dXJlR3JvdXBJZH1gXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgICBcbiAgICAvLyAyLiBTYXZlIGFsbCBmaWxlcyB3aXRoIHRoZSBzYW1lIGdyb3VwIElEIHNvIHRoZXkgZ2V0IHRoZSBzYW1lIG51bWJlclxuICAgIFxuICAgIC8vIDIuMSBTYXZlIHBhcmFtZXRlciBmaWxlXG4gICAgY29uc3QgcGFyYW1SZXN1bHQgPSBhd2FpdCBzYXZlQ1NWVG9TZXJ2ZXIoY3N2RGF0YSwgcGFyYW1ldGVyRmlsZW5hbWUsIGZvbGRlciwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIFxuICAgIGlmIChwYXJhbVJlc3VsdCAmJiBwYXJhbVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBjYXB0dXJlTnVtYmVyID0gcGFyYW1SZXN1bHQubnVtYmVyO1xuICAgICAgY29uc29sZS5sb2coYFNlcnZlciBhc3NpZ25lZCBjYXB0dXJlIG51bWJlcjogJHtjYXB0dXJlTnVtYmVyfSBmb3IgZ3JvdXA6ICR7Y2FwdHVyZUdyb3VwSWR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDIuMiBTYXZlIHNjcmVlbiBpbWFnZSBpZiBhdmFpbGFibGVcbiAgICBsZXQgc2NyZWVuUmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICAgIHNjcmVlblJlc3VsdCA9IGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKHNjcmVlbkltYWdlLCBzY3JlZW5GaWxlbmFtZSwgJ3NjcmVlbicsIGZvbGRlciwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyAyLjMgU2F2ZSB3ZWJjYW0gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gICAgbGV0IHdlYmNhbVJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICB3ZWJjYW1SZXN1bHQgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcih3ZWJjYW1JbWFnZSwgd2ViY2FtRmlsZW5hbWUsICd3ZWJjYW0nLCBmb2xkZXIsIGNhcHR1cmVHcm91cElkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gMy4gU2hvdyBwcmV2aWV3IGlmIG5lZWRlZCAtIHVzZSB0aGUgbG93ZXIgcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgaWYgKHNob3dDYXB0dXJlUHJldmlldyAmJiB0eXBlb2Ygc2hvd0NhcHR1cmVQcmV2aWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlUHJldmlldyB8fCB3ZWJjYW1JbWFnZSwgcG9pbnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyA0LiBJbmNyZW1lbnQgY291bnRlciBmb3IgbmV4dCBjYXB0dXJlXG4gICAgaWYgKHNldENhcHR1cmVDb3VudCAmJiB0eXBlb2Ygc2V0Q2FwdHVyZUNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXRDYXB0dXJlQ291bnQocHJldkNvdW50ID0+IHByZXZDb3VudCArIDEpO1xuICAgIH1cbiAgICBcbiAgICAvLyA1LiBSZXR1cm4gcmVzdWx0cyAtIG5vdyBpbmNsdWRpbmcgd2ViY2FtIHJlc29sdXRpb25cbiAgICByZXR1cm4ge1xuICAgICAgc2NyZWVuSW1hZ2UsXG4gICAgICB3ZWJjYW1JbWFnZSxcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBwb2ludCxcbiAgICAgIGNhcHR1cmVOdW1iZXIsXG4gICAgICBncm91cElkOiBjYXB0dXJlR3JvdXBJZCxcbiAgICAgIHdlYmNhbVdpZHRoLFxuICAgICAgd2ViY2FtSGVpZ2h0XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcImNhcHR1cmVJbWFnZXNBdFBvaW50IGZhaWxlZDpcIiwgZXJyKTtcbiAgICByZXR1cm4geyBcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgIGVycm9yOiBlcnIubWVzc2FnZSxcbiAgICAgIHNjcmVlbkltYWdlOiBudWxsLFxuICAgICAgd2ViY2FtSW1hZ2U6IG51bGwsXG4gICAgICB3ZWJjYW1XaWR0aDogMCxcbiAgICAgIHdlYmNhbUhlaWdodDogMFxuICAgIH07XG4gIH1cbn07Il0sIm5hbWVzIjpbInJlc2l6ZUltYWdlIiwiaW1hZ2VEYXRhVXJsIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJxdWFsaXR5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsIndpZHRoIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInJlc2l6ZWREYXRhVXJsIiwidG9EYXRhVVJMIiwib25lcnJvciIsImVyciIsInNyYyIsInNhdmVJbWFnZVRvU2VydmVyIiwiaW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ0eXBlIiwiZm9sZGVyIiwiY2FwdHVyZUdyb3VwIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiY29uc29sZSIsImVycm9yIiwic3RhdHVzIiwid2FybiIsInNpemVzIiwicmVzaXplZEltYWdlIiwicmV0cnlSZXNwb25zZSIsImxvZyIsImpzb24iLCJyZXRyeUVycm9yIiwic3VjY2VzcyIsInJlc3VsdCIsIm1lc3NhZ2UiLCJzYXZlQ1NWVG9TZXJ2ZXIiLCJjc3ZEYXRhIiwiY3N2QmxvYiIsIkJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlYWRBc0RhdGFVUkwiLCJnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzIiwidmlkZW9UcmFjayIsInRlbXBTdHJlYW0iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsImdldFZpZGVvVHJhY2tzIiwiY2FwYWJpbGl0aWVzIiwiZ2V0Q2FwYWJpbGl0aWVzIiwic3RvcCIsImlkZWFsIiwibWF4IiwicmVzb2x1dGlvbnMiLCJyZXNvbHV0aW9uIiwiY29uc3RyYWludHMiLCJmYWNpbmdNb2RlIiwic3RyZWFtIiwic2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwicG9pbnQiLCJjYXB0dXJlQ291bnQiLCJjYW52YXNSZWYiLCJzZXRDYXB0dXJlQ291bnQiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJjYXB0dXJlR3JvdXBJZCIsIkRhdGUiLCJub3ciLCJzY3JlZW5GaWxlbmFtZSIsIndlYmNhbUZpbGVuYW1lIiwicGFyYW1ldGVyRmlsZW5hbWUiLCJjdXJyZW50Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImNhcHR1cmVOdW1iZXIiLCJ3ZWJjYW1XaWR0aCIsIndlYmNhbUhlaWdodCIsIndlYmNhbUltYWdlUHJldmlldyIsInZpZGVvRWxlbWVudCIsIndpbmRvdyIsInF1ZXJ5U2VsZWN0b3IiLCJ0cmFja1NldHRpbmdzIiwic3JjT2JqZWN0IiwiZ2V0Q29uc3RyYWludHMiLCJleGFjdCIsInRlbXBDYW52YXMiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJ0ZW1wVmlkZW8iLCJtdXRlZCIsInBsYXlzSW5saW5lIiwiYXV0b3BsYXkiLCJhcHBlbmRDaGlsZCIsIm9ubG9hZGVkbWV0YWRhdGEiLCJwbGF5Iiwic2V0VGltZW91dCIsInJlcyIsImFzcGVjdFJhdGlvIiwiYWJzIiwidCIsInJlbW92ZSIsImZhbGxiYWNrRXJyIiwieCIsInkiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJwYXJhbVJlc3VsdCIsIm51bWJlciIsInNjcmVlblJlc3VsdCIsIndlYmNhbVJlc3VsdCIsInByZXZDb3VudCIsImdyb3VwSWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\n"));

/***/ })

});