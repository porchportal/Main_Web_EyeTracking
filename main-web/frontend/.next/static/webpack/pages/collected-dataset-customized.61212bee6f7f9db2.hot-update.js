"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Only initialize if canvas doesn't exist\n            if (!document.querySelector('#tracking-canvas')) {\n                const canvas = getMainCanvas();\n                console.log('Canvas initialized:', canvas ? 'success' : 'failed');\n            }\n            // Cleanup function\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    // Don't remove canvas on cleanup to prevent recreation issues\n                    console.log('ActionButton cleanup - canvas preserved');\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Initialize canvas on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const initializeCanvas = {\n                \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                    // Remove any existing canvas\n                    const existingCanvas = document.querySelector('.tracking-canvas');\n                    if (existingCanvas) {\n                        existingCanvas.remove();\n                    }\n                    // Create new canvas\n                    const canvas = document.createElement('canvas');\n                    canvas.className = 'tracking-canvas';\n                    canvas.id = 'tracking-canvas';\n                    canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        opacity: 0;\\n        pointer-events: none;\\n        z-index: 5;\\n      \";\n                    // Set canvas dimensions\n                    canvas.width = window.innerWidth;\n                    canvas.height = window.innerHeight;\n                    // Add canvas to body\n                    document.body.appendChild(canvas);\n                    // Store reference\n                    canvasRef.current = canvas;\n                    if (true) {\n                        window.whiteScreenCanvas = canvas;\n                    }\n                    // Initialize with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Add resize handler\n                    const handleResize = {\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\": ()=>{\n                            canvas.width = window.innerWidth;\n                            canvas.height = window.innerHeight;\n                            ctx.fillStyle = 'white';\n                            ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        }\n                    }[\"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\"];\n                    window.addEventListener('resize', handleResize);\n                    return ({\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                            window.removeEventListener('resize', handleResize);\n                            if (canvas.parentNode) {\n                                canvas.parentNode.removeChild(canvas);\n                            }\n                        }\n                    })[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n                }\n            }[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n            const cleanup = initializeCanvas();\n            return cleanup;\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas = ()=>{\n        // First check if we have a valid canvas reference\n        if (canvasRef.current && document.contains(canvasRef.current)) {\n            return canvasRef.current;\n        }\n        // Try to find existing canvas in DOM\n        let existingCanvas = document.querySelector('#tracking-canvas');\n        if (existingCanvas && document.contains(existingCanvas)) {\n            canvasRef.current = existingCanvas;\n            window.whiteScreenCanvas = existingCanvas;\n            return existingCanvas;\n        }\n        // Create new canvas only if none exists\n        console.log('Creating new canvas...');\n        const canvas = document.createElement('canvas');\n        canvas.className = 'tracking-canvas';\n        canvas.id = 'tracking-canvas';\n        // Set initial dimensions and style\n        canvas.width = 800;\n        canvas.height = 400;\n        canvas.style.cssText = \"\\n      position: relative;\\n      width: 100%;\\n      height: 400px;\\n      background-color: white;\\n      border: 1px solid #ccc;\\n      display: block;\\n    \";\n        // Initialize with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Find container and append\n        const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n        container.appendChild(canvas);\n        // Store references\n        canvasRef.current = canvas;\n        window.whiteScreenCanvas = canvas;\n        return canvas;\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas)=>{\n        if (!canvas || !canvas._originalState) return;\n        const original = canvas._originalState;\n        try {\n            // Restore to original parent\n            if (original.parent && document.contains(original.parent)) {\n                original.parent.appendChild(canvas);\n            } else {\n                // Fallback to a container if original parent is gone\n                const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n                container.appendChild(canvas);\n            }\n            // Restore styles\n            canvas.style.position = original.position || 'relative';\n            canvas.style.top = original.top || '';\n            canvas.style.left = original.left || '';\n            canvas.style.width = original.width || '100%';\n            canvas.style.height = original.height || '400px';\n            canvas.style.zIndex = original.zIndex || '';\n            canvas.style.backgroundColor = 'white';\n            // Restore dimensions\n            canvas.width = original.canvasWidth || 800;\n            canvas.height = original.canvasHeight || 400;\n            // Clear with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Clear the saved state\n            delete canvas._originalState;\n        } catch (error) {\n            console.error('Error restoring canvas:', error);\n            // Fallback: just clear the canvas\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ const ensureCanvasExists = ()=>{\n        let canvas = document.querySelector('#tracking-canvas');\n        if (!canvas) {\n            // Create canvas with window dimensions\n            canvas = document.createElement('canvas');\n            canvas.className = 'tracking-canvas';\n            canvas.id = 'tracking-canvas';\n            // Set canvas dimensions to match window size\n            const windowWidth = window.innerWidth;\n            const windowHeight = window.innerHeight;\n            canvas.width = windowWidth;\n            canvas.height = windowHeight;\n            // Set CSS to match window size\n            canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        background-color: white;\\n        border: none;\\n        display: block;\\n        z-index: 5;\\n      \";\n            // Initialize with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Append directly to body for fullscreen\n            document.body.appendChild(canvas);\n            // Store global reference\n            window.whiteScreenCanvas = canvas;\n            // Add resize handler to update canvas size\n            const handleResize = ()=>{\n                canvas.width = window.innerWidth;\n                canvas.height = window.innerHeight;\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            };\n            window.addEventListener('resize', handleResize);\n            // Store resize handler for cleanup\n            canvas._resizeHandler = handleResize;\n            console.log(\"Canvas created with window size: \".concat(windowWidth, \"x\").concat(windowHeight));\n        }\n        return canvas;\n    };\n    // Cleanup function to remove canvas and its properties\n    const cleanupCanvas = ()=>{\n        const canvas = document.querySelector('#tracking-canvas');\n        if (canvas) {\n            // Remove resize event listener if it exists\n            if (canvas._resizeHandler) {\n                window.removeEventListener('resize', canvas._resizeHandler);\n                delete canvas._resizeHandler;\n            }\n            // Remove canvas from DOM\n            if (canvas.parentNode) {\n                canvas.parentNode.removeChild(canvas);\n            }\n            // Clear global references\n            if (window.whiteScreenCanvas === canvas) {\n                delete window.whiteScreenCanvas;\n            }\n            console.log('Canvas cleaned up and removed');\n        }\n    };\n    // Modified canvas restore function for temporary operations\n    const restoreCanvasToContainer = (canvas)=>{\n        if (!canvas) return;\n        // Remove resize handler\n        if (canvas._resizeHandler) {\n            window.removeEventListener('resize', canvas._resizeHandler);\n            delete canvas._resizeHandler;\n        }\n        // Find appropriate container\n        const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n        // Move canvas to container\n        container.appendChild(canvas);\n        // Reset to container-friendly dimensions\n        const containerWidth = container.clientWidth || 800;\n        const containerHeight = container.clientHeight || 600;\n        canvas.width = containerWidth;\n        canvas.height = containerHeight;\n        // Reset CSS for container mode\n        canvas.style.cssText = \"\\n      position: relative;\\n      width: 100%;\\n      height: 400px;\\n      background-color: white;\\n      border: 1px solid #ccc;\\n      display: block;\\n      z-index: auto;\\n    \";\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas restored to container: \".concat(containerWidth, \"x\").concat(containerHeight));\n    };\n    // Modified handleDotProcess function with improved dot and countdown alignment\n    // Complete handleDotProcess function with proper canvas management\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        let canvas = null;\n        let keepDotVisibleInterval = null;\n        let countdownElement = null;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Use ensureCanvasExists to get or create canvas\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                throw new Error(\"Failed to create or find canvas\");\n            }\n            // Canvas is already set to fullscreen by ensureCanvasExists\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n            // Get context and clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(dotPosition.x, \"px;\\n      top: \").concat(dotPosition.y, \"px;\\n      transform: translate(-50%, -50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 10000;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement && countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        } finally{\n            // Clear redraw interval first\n            if (keepDotVisibleInterval) {\n                clearInterval(keepDotVisibleInterval);\n                keepDotVisibleInterval = null;\n            }\n            // Remove countdown element if it still exists\n            if (countdownElement && countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Remove any remaining countdown elements\n            const remainingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            remainingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Use restoreCanvasToContainer to properly restore canvas\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for calibration');\n                return;\n            }\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"✓\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for set random');\n                return;\n            }\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            const canvas = document.querySelector('#tracking-canvas');\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for random dot');\n                return;\n            }\n            // Use the consolidated function with random position\n            await handleDotProcess({\n                useRandomPosition: true,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                },\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                triggerCameraAccess,\n                setIsCapturing,\n                captureCount,\n                setCaptureCount: setCaptureCount,\n                postCountdownDelay: 1000\n            });\n        } catch (error) {\n            console.error('Random dot error:', error);\n        } finally{\n            // Clean up canvas after process completes\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 2000); // Wait 2 seconds before cleanup\n        }\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        if (!canvas) return null;\n        // Save original state if not already saved\n        if (!canvas._originalState) {\n            canvas._originalState = {\n                parent: canvas.parentElement,\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex,\n                canvasWidth: canvas.width,\n                canvasHeight: canvas.height\n            };\n        }\n        // Move to body and make fullscreen\n        document.body.appendChild(canvas);\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '10';\n        canvas.style.backgroundColor = 'white';\n        // Set canvas dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        return canvas;\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        // Clear canvas content\n        const canvas = document.querySelector('#tracking-canvas');\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Restore canvas to container mode\n            restoreCanvasToContainer(canvas);\n        }\n        // Reset states\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n        setCurrentDot(null);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1539,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1538,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1543,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1542,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1574,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1584,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1602,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1615,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1594,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1564,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1549,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1536,\n        columnNumber: 5\n    }, undefined);\n}, \"l311k0juR60uxpHVRV/MyFvStaI=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1637,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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bnRzLWd1aS9hY3Rpb25CdXR0b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgXG4gIHNob3dDYXB0dXJlUHJldmlldywgXG4gIGRyYXdSZWREb3QsIFxuICBnZXRSYW5kb21Qb3NpdGlvbixcbiAgY3JlYXRlQ291bnRkb3duRWxlbWVudCxcbiAgcnVuQ291bnRkb3duXG59IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZSc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG5pbXBvcnQgeyB1c2VBZG1pblNldHRpbmdzIH0gZnJvbSAnLi9hZG1pblNldHRpbmdzJztcblxuLy8gQWRkIGRlZXAgY29tcGFyaXNvbiB1dGlsaXR5XG5jb25zdCBpc0VxdWFsID0gKG9iajEsIG9iajIpID0+IHtcbiAgaWYgKG9iajEgPT09IG9iajIpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iajEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmoyICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSA9PT0gbnVsbCB8fCBvYmoyID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIFxuICByZXR1cm4ga2V5czEuZXZlcnkoa2V5ID0+IFxuICAgIGtleXMyLmluY2x1ZGVzKGtleSkgJiYgaXNFcXVhbChvYmoxW2tleV0sIG9iajJba2V5XSlcbiAgKTtcbn07XG5cbi8vIENyZWF0ZSBhIGJhc2ljIEFjdGlvbkJ1dHRvbiBjb21wb25lbnQgd2l0aCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbiA9ICh7IHRleHQsIGFiYnJldmlhdGVkVGV4dCwgb25DbGljaywgY3VzdG9tQ2xhc3MgPSAnJywgZGlzYWJsZWQgPSBmYWxzZSwgYWN0aXZlID0gZmFsc2UgfSkgPT4ge1xuICBjb25zdCBbaXNBYmJyZXZpYXRlZCwgc2V0SXNBYmJyZXZpYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MoKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnRlciwgc2V0Q2FwdHVyZUNvdW50ZXJdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtwcm9jZXNzU3RhdHVzLCBzZXRQcm9jZXNzU3RhdHVzXSA9IHVzZVN0YXRlKCcnKTtcblxuICAvLyBNZW1vaXplIGJ1dHRvbiBwcm9wcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcbiAgY29uc3QgYnV0dG9uUHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2xhc3NOYW1lOiBgYWN0aW9uLWJ1dHRvbiAke2N1c3RvbUNsYXNzfSAke2lzQWJicmV2aWF0ZWQgPyAnYWJicmV2aWF0ZWQnIDogJyd9ICR7YWN0aXZlID8gJ2FjdGl2ZScgOiAnJ31gLFxuICAgIG9uQ2xpY2ssXG4gICAgZGlzYWJsZWQsXG4gICAgdGl0bGU6IHRleHRcbiAgfSksIFtjdXN0b21DbGFzcywgaXNBYmJyZXZpYXRlZCwgYWN0aXZlLCBvbkNsaWNrLCBkaXNhYmxlZCwgdGV4dF0pO1xuXG4gIC8vIENoZWNrIHdpbmRvdyBzaXplIGFuZCBzZXQgYWJicmV2aWF0ZWQgbW9kZSB3aXRoIGRlYm91bmNlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBzZXRJc0FiYnJldmlhdGVkKHdpZHRoIDwgNzY4KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfTtcbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICBoYW5kbGVSZXNpemUoKTsgLy8gSW5pdGlhbCBjYWxsXG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEFkZCBlZmZlY3QgdG8gbGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXMgd2l0aCBvcHRpbWl6YXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIGlmIChuZXdVc2VySWQgIT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIHsuLi5idXR0b25Qcm9wc30+XG4gICAgICB7aXNBYmJyZXZpYXRlZCA/IGFiYnJldmlhdGVkVGV4dCA6IHRleHR9XG4gICAgICB7cHJvY2Vzc1N0YXR1cyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvY2Vzcy1zdGF0dXNcIj5cbiAgICAgICAgICB7cHJvY2Vzc1N0YXR1c31cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBBY3Rpb25CdXR0b25Hcm91cCBjb21wb25lbnQgd2l0aCBjbGllbnQtc2lkZSBvbmx5IHJlbmRlcmluZyBhbmQgb3B0aW1pemF0aW9uXG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cElubmVyID0gZm9yd2FyZFJlZigoeyB0cmlnZ2VyQ2FtZXJhQWNjZXNzLCBpc0NvbXBhY3RNb2RlLCBvbkFjdGlvbkNsaWNrIH0sIHJlZikgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MocmVmKTtcbiAgXG4gIC8vIFN0YXRlIGZvciBidXR0b24gYWN0aW9uc1xuICBjb25zdCBbcmFuZG9tVGltZXMsIHNldFJhbmRvbVRpbWVzXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbZGVsYXlTZWNvbmRzLCBzZXREZWxheVNlY29uZHNdID0gdXNlU3RhdGUoMyk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbY291bnRkb3duVmFsdWUsIHNldENvdW50ZG93blZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY3VycmVudERvdCwgc2V0Q3VycmVudERvdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NhbGlicmF0aW9uUG9pbnRzLCBzZXRDYWxpYnJhdGlvblBvaW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtyZW1haW5pbmdDYXB0dXJlcywgc2V0UmVtYWluaW5nQ2FwdHVyZXNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtzaG93Q2FudmFzLCBzZXRTaG93Q2FudmFzXSA9IHVzZVN0YXRlKHRydWUpO1xuICBcbiAgLy8gVHJhY2sgdGhlIGNhcHR1cmUgY291bnRcbiAgY29uc3QgW2NhbGlicmF0aW9uSGFuZGxlciwgc2V0Q2FsaWJyYXRpb25IYW5kbGVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FwdHVyZUNvdW50LCBzZXRDYXB0dXJlQ291bnRdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gVG9nZ2xlIHN0YXRlc1xuICBjb25zdCBbc2hvd0hlYWRQb3NlLCBzZXRTaG93SGVhZFBvc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0JvdW5kaW5nQm94LCBzZXRTaG93Qm91bmRpbmdCb3hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd01hc2ssIHNldFNob3dNYXNrXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQYXJhbWV0ZXJzLCBzZXRTaG93UGFyYW1ldGVyc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0NhbWVyYUFjdGl2ZSwgc2V0SXNDYW1lcmFBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1Blcm1pc3Npb25Qb3B1cCwgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCdkZWZhdWx0Jyk7XG5cbiAgLy8gQWRkIGNhY2hlIGZvciBzZXR0aW5nc1xuICBjb25zdCBzZXR0aW5nc0NhY2hlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IGxhc3RTZXR0aW5nc1VwZGF0ZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuXG4gIFxuICAvLyBPcHRpbWl6ZSBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNldHRpbmdzICYmIGN1cnJlbnRVc2VySWQgJiYgc2V0dGluZ3NbY3VycmVudFVzZXJJZF0pIHtcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdO1xuICAgICAgY29uc3QgY2FjaGVkU2V0dGluZ3MgPSBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuZ2V0KGN1cnJlbnRVc2VySWQpO1xuICAgICAgXG4gICAgICBpZiAoIWlzRXF1YWwoY2FjaGVkU2V0dGluZ3MsIHVzZXJTZXR0aW5ncykpIHtcbiAgICAgICAgc2V0UmFuZG9tVGltZXMoTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCAxKTtcbiAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIHNldHRpbmdzQ2FjaGUuY3VycmVudC5zZXQoY3VycmVudFVzZXJJZCwgdXNlclNldHRpbmdzKTtcbiAgICAgICAgbGFzdFNldHRpbmdzVXBkYXRlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgLy8gVXBkYXRlIHNldHRpbmdzIGZvciBuZXcgdXNlclxuICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3NbbmV3VXNlcklkXSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW25ld1VzZXJJZF07XG4gICAgICAgICAgc2V0UmFuZG9tVGltZXMoTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCAxKTtcbiAgICAgICAgICBzZXREZWxheVNlY29uZHMoTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheV9zZXRfcmFuZG9tKSB8fCAzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtzZXR0aW5nc10pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAnY2FwdHVyZVNldHRpbmdzJykge1xuICAgICAgICBjb25zdCB7IHVzZXJJZCwgdGltZXNfc2V0X3JhbmRvbSwgZGVsYXlfc2V0X3JhbmRvbSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAodXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgaWYgKHRpbWVzX3NldF9yYW5kb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3VGltZXMgPSBOdW1iZXIodGltZXNfc2V0X3JhbmRvbSkgfHwgMTtcbiAgICAgICAgICAgIHNldFJhbmRvbVRpbWVzKG5ld1RpbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlbGF5X3NldF9yYW5kb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3RGVsYXkgPSBOdW1iZXIoZGVsYXlfc2V0X3JhbmRvbSkgfHwgMztcbiAgICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhuZXdEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBnbG9iYWxseSBhY2Nlc3NpYmxlIGFzIGEgZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMgPSB7XG4gICAgICAgIGhhbmRsZVJhbmRvbURvdCxcbiAgICAgICAgaGFuZGxlU2V0UmFuZG9tLFxuICAgICAgICBoYW5kbGVTZXRDYWxpYnJhdGUsXG4gICAgICAgIGhhbmRsZUNsZWFyQWxsXG4gICAgICB9O1xuICAgICAgLy8gY29uc29sZS5sb2coJ0FjdGlvbiBidXR0b24gZnVuY3Rpb25zIGV4cG9zZWQgdG8gd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucycpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBPbmx5IGluaXRpYWxpemUgaWYgY2FudmFzIGRvZXNuJ3QgZXhpc3RcbiAgICBpZiAoIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKSkge1xuICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgY29uc29sZS5sb2coJ0NhbnZhcyBpbml0aWFsaXplZDonLCBjYW52YXMgPyAnc3VjY2VzcycgOiAnZmFpbGVkJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFudXAgZnVuY3Rpb25cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gRG9uJ3QgcmVtb3ZlIGNhbnZhcyBvbiBjbGVhbnVwIHRvIHByZXZlbnQgcmVjcmVhdGlvbiBpc3N1ZXNcbiAgICAgIGNvbnNvbGUubG9nKCdBY3Rpb25CdXR0b24gY2xlYW51cCAtIGNhbnZhcyBwcmVzZXJ2ZWQnKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGdldCBjb250cm9sIHZhbHVlcyBmcm9tIFRvcEJhclxuICAgIGNvbnN0IHVwZGF0ZUNvbnRyb2xWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIHRpbWUgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSBwYXJzZUludCh0aW1lSW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTih0aW1lVmFsdWUpICYmIHRpbWVWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgcmFuZG9tVGltZXMgdG86JywgdGltZVZhbHVlKTtcbiAgICAgICAgICBzZXRSYW5kb21UaW1lcyh0aW1lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgZGVsYXkgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBjb25zdCBkZWxheVZhbHVlID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKGRlbGF5VmFsdWUpICYmIGRlbGF5VmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGRlbGF5U2Vjb25kcyB0bzonLCBkZWxheVZhbHVlKTtcbiAgICAgICAgICBzZXREZWxheVNlY29uZHMoZGVsYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGNvbnRyb2wgaW5wdXRzXG4gICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgIFxuICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIC8vIEluaXRpYWwgdXBkYXRlXG4gICAgdXBkYXRlQ29udHJvbFZhbHVlcygpO1xuICAgIFxuICAgIC8vIENsZWFudXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBJbml0aWFsaXplIGNhbnZhcyBvbiBjb21wb25lbnQgbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKCkgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjYW52YXNcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRyYWNraW5nLWNhbnZhcycpO1xuICAgICAgaWYgKGV4aXN0aW5nQ2FudmFzKSB7XG4gICAgICAgIGV4aXN0aW5nQ2FudmFzLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IGNhbnZhc1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICBjYW52YXMuaWQgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICAgIGNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgei1pbmRleDogNTtcbiAgICAgIGA7XG5cbiAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAvLyBBZGQgY2FudmFzIHRvIGJvZHlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlXG4gICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhcztcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIC8vIEFkZCByZXNpemUgaGFuZGxlclxuICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgICBpZiAoY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBjbGVhbnVwID0gaW5pdGlhbGl6ZUNhbnZhcygpO1xuICAgIHJldHVybiBjbGVhbnVwO1xuICB9LCBbXSk7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWFpbiBjYW52YXMgLSBpbXByb3ZlZCB0byBiZSBtb3JlIHJlbGlhYmxlXG4gIGNvbnN0IGdldE1haW5DYW52YXMgPSAoKSA9PiB7XG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgd2UgaGF2ZSBhIHZhbGlkIGNhbnZhcyByZWZlcmVuY2VcbiAgICBpZiAoY2FudmFzUmVmLmN1cnJlbnQgJiYgZG9jdW1lbnQuY29udGFpbnMoY2FudmFzUmVmLmN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBmaW5kIGV4aXN0aW5nIGNhbnZhcyBpbiBET01cbiAgICBsZXQgZXhpc3RpbmdDYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgXG4gICAgaWYgKGV4aXN0aW5nQ2FudmFzICYmIGRvY3VtZW50LmNvbnRhaW5zKGV4aXN0aW5nQ2FudmFzKSkge1xuICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSBleGlzdGluZ0NhbnZhcztcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGV4aXN0aW5nQ2FudmFzO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FudmFzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgY2FudmFzIG9ubHkgaWYgbm9uZSBleGlzdHNcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IGNhbnZhcy4uLicpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5jbGFzc05hbWUgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICBjYW52YXMuaWQgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICBcbiAgICAvLyBTZXQgaW5pdGlhbCBkaW1lbnNpb25zIGFuZCBzdHlsZVxuICAgIGNhbnZhcy53aWR0aCA9IDgwMDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gNDAwO1xuICAgIGNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDQwMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgYDtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIEZpbmQgY29udGFpbmVyIGFuZCBhcHBlbmRcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluLWNvbnRlbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgXG4gICAgLy8gU3RvcmUgcmVmZXJlbmNlc1xuICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzO1xuICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICBcbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBpZiAodHJpZ2dlckNhbWVyYUFjY2Vzcykge1xuICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlciB0byBjYW5jZWwgcGVybWlzc2lvbiBwb3B1cFxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uRGVuaWVkID0gKCkgPT4ge1xuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byByZXN0b3JlIHRoZSBjYW52YXMgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGluZ1xuICBjb25zdCByZXN0b3JlQ2FudmFzID0gKGNhbnZhcykgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFjYW52YXMuX29yaWdpbmFsU3RhdGUpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBvcmlnaW5hbCA9IGNhbnZhcy5fb3JpZ2luYWxTdGF0ZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gUmVzdG9yZSB0byBvcmlnaW5hbCBwYXJlbnRcbiAgICAgIGlmIChvcmlnaW5hbC5wYXJlbnQgJiYgZG9jdW1lbnQuY29udGFpbnMob3JpZ2luYWwucGFyZW50KSkge1xuICAgICAgICBvcmlnaW5hbC5wYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGEgY29udGFpbmVyIGlmIG9yaWdpbmFsIHBhcmVudCBpcyBnb25lXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIHN0eWxlc1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWwucG9zaXRpb24gfHwgJ3JlbGF0aXZlJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbC50b3AgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsLmxlZnQgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbC53aWR0aCB8fCAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWwuaGVpZ2h0IHx8ICc0MDBweCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gb3JpZ2luYWwuekluZGV4IHx8ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgZGltZW5zaW9uc1xuICAgICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWwuY2FudmFzV2lkdGggfHwgODAwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IG9yaWdpbmFsLmNhbnZhc0hlaWdodCB8fCA0MDA7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciB0aGUgc2F2ZWQgc3RhdGVcbiAgICAgIGRlbGV0ZSBjYW52YXMuX29yaWdpbmFsU3RhdGU7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzdG9yaW5nIGNhbnZhczonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjazoganVzdCBjbGVhciB0aGUgY2FudmFzXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICBjb25zdCBjbGVhckNhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCBmb3IgY2xlYXJpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICB9O1xuICAvLyBBZGQgdGhpcyBmdW5jdGlvbiB0byBhY3Rpb25CdXR0b24uanNcblxuICAvKipcbiAgICogQ29uc29saWRhdGVkIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgZW50aXJlIGRvdCBwcm9jZXNzOiBkcmF3aW5nLCBjb3VudGRvd24sIGNhcHR1cmUsIGFuZCBwcmV2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IGNvb3JkaW5hdGVzIHdoZXJlIHRvIGRyYXcgdGhlIGRvdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU3RhdHVzVXBkYXRlIC0gQ2FsbGJhY2sgZm9yIHN0YXR1cyB1cGRhdGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRyaWdnZXJDYW1lcmFBY2Nlc3MgLSBGdW5jdGlvbiB0byBlbnN1cmUgY2FtZXJhIGlzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldElzQ2FwdHVyaW5nIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmluZyBzdGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnQgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudCAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy51c2VSYW5kb21Qb3NpdGlvbiAtIFdoZXRoZXIgdG8gZ2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZSBkYXRhXG4gICAqL1xuXG4gIGNvbnN0IGVuc3VyZUNhbnZhc0V4aXN0cyA9ICgpID0+IHtcbiAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICAvLyBDcmVhdGUgY2FudmFzIHdpdGggd2luZG93IGRpbWVuc2lvbnNcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgY2FudmFzLmlkID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICBcbiAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3cgc2l6ZVxuICAgICAgY29uc3Qgd2luZG93V2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvd1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvd0hlaWdodDtcbiAgICAgIFxuICAgICAgLy8gU2V0IENTUyB0byBtYXRjaCB3aW5kb3cgc2l6ZVxuICAgICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwdnc7XG4gICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICB6LWluZGV4OiA1O1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gQXBwZW5kIGRpcmVjdGx5IHRvIGJvZHkgZm9yIGZ1bGxzY3JlZW5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgZ2xvYmFsIHJlZmVyZW5jZVxuICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgICAgXG4gICAgICAvLyBBZGQgcmVzaXplIGhhbmRsZXIgdG8gdXBkYXRlIGNhbnZhcyBzaXplXG4gICAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHJlc2l6ZSBoYW5kbGVyIGZvciBjbGVhbnVwXG4gICAgICBjYW52YXMuX3Jlc2l6ZUhhbmRsZXIgPSBoYW5kbGVSZXNpemU7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgY3JlYXRlZCB3aXRoIHdpbmRvdyBzaXplOiAke3dpbmRvd1dpZHRofXgke3dpbmRvd0hlaWdodH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfTtcblxuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIHRvIHJlbW92ZSBjYW52YXMgYW5kIGl0cyBwcm9wZXJ0aWVzXG4gIGNvbnN0IGNsZWFudXBDYW52YXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoY2FudmFzLl9yZXNpemVIYW5kbGVyKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjYW52YXMuX3Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgY2FudmFzLl9yZXNpemVIYW5kbGVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY2FudmFzIGZyb20gRE9NXG4gICAgICBpZiAoY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgZ2xvYmFsIHJlZmVyZW5jZXNcbiAgICAgIGlmICh3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPT09IGNhbnZhcykge1xuICAgICAgICBkZWxldGUgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ2FudmFzIGNsZWFuZWQgdXAgYW5kIHJlbW92ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gTW9kaWZpZWQgY2FudmFzIHJlc3RvcmUgZnVuY3Rpb24gZm9yIHRlbXBvcmFyeSBvcGVyYXRpb25zXG4gIGNvbnN0IHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lciA9IChjYW52YXMpID0+IHtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlbW92ZSByZXNpemUgaGFuZGxlclxuICAgIGlmIChjYW52YXMuX3Jlc2l6ZUhhbmRsZXIpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBjYW52YXMuX3Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgZGVsZXRlIGNhbnZhcy5fcmVzaXplSGFuZGxlcjtcbiAgICB9XG4gICAgXG4gICAgLy8gRmluZCBhcHByb3ByaWF0ZSBjb250YWluZXJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluLWNvbnRlbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgXG4gICAgLy8gTW92ZSBjYW52YXMgdG8gY29udGFpbmVyXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgXG4gICAgLy8gUmVzZXQgdG8gY29udGFpbmVyLWZyaWVuZGx5IGRpbWVuc2lvbnNcbiAgICBjb25zdCBjb250YWluZXJXaWR0aCA9IGNvbnRhaW5lci5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgXG4gICAgY2FudmFzLndpZHRoID0gY29udGFpbmVyV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGNvbnRhaW5lckhlaWdodDtcbiAgICBcbiAgICAvLyBSZXNldCBDU1MgZm9yIGNvbnRhaW5lciBtb2RlXG4gICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogNDAwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIHotaW5kZXg6IGF1dG87XG4gICAgYDtcbiAgICBcbiAgICAvLyBDbGVhciB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHJlc3RvcmVkIHRvIGNvbnRhaW5lcjogJHtjb250YWluZXJXaWR0aH14JHtjb250YWluZXJIZWlnaHR9YCk7XG4gIH07XG4gIFxuICAvLyBNb2RpZmllZCBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggaW1wcm92ZWQgZG90IGFuZCBjb3VudGRvd24gYWxpZ25tZW50XG4gIC8vIENvbXBsZXRlIGhhbmRsZURvdFByb2Nlc3MgZnVuY3Rpb24gd2l0aCBwcm9wZXIgY2FudmFzIG1hbmFnZW1lbnRcbmNvbnN0IGhhbmRsZURvdFByb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgcG9zaXRpb24sXG4gICAgb25TdGF0dXNVcGRhdGUsXG4gICAgdG9nZ2xlVG9wQmFyLFxuICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgY2FwdHVyZUNvdW50LFxuICAgIHNldENhcHR1cmVDb3VudCxcbiAgICB1c2VSYW5kb21Qb3NpdGlvbiA9IGZhbHNlLFxuICAgIHBvc3RDb3VudGRvd25EZWxheSA9IDUwMCBcbiAgfSA9IG9wdGlvbnM7XG4gIFxuICBsZXQgY2FudmFzID0gbnVsbDtcbiAgbGV0IGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBudWxsO1xuICBsZXQgY291bnRkb3duRWxlbWVudCA9IG51bGw7XG4gIFxuICB0cnkge1xuICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyB0aGUgZG90XG4gICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZVxuICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgIHByb2Nlc3NTdGF0dXM6IHVzZVJhbmRvbVBvc2l0aW9uID8gJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicgOiAnU3RhcnRpbmcgZG90IHByb2Nlc3MuLi4nLFxuICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgIFxuICAgIC8vIFVzZSBlbnN1cmVDYW52YXNFeGlzdHMgdG8gZ2V0IG9yIGNyZWF0ZSBjYW52YXNcbiAgICBjYW52YXMgPSBlbnN1cmVDYW52YXNFeGlzdHMoKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBvciBmaW5kIGNhbnZhc1wiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2FudmFzIGlzIGFscmVhZHkgc2V0IHRvIGZ1bGxzY3JlZW4gYnkgZW5zdXJlQ2FudmFzRXhpc3RzXG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICBcbiAgICAvLyBHZXQgY29udGV4dCBhbmQgY2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgIFxuICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgIGNvbnN0IGRvdFBvc2l0aW9uID0gdXNlUmFuZG9tUG9zaXRpb24gXG4gICAgICA/IGdldFJhbmRvbVBvc2l0aW9uKGNhbnZhcywgMjApIFxuICAgICAgOiBwb3NpdGlvbjtcbiAgICBcbiAgICBpZiAoIWRvdFBvc2l0aW9uIHx8IHR5cGVvZiBkb3RQb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZG90UG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICBjb25zdCBkb3RSYWRpdXMgPSAxMjtcbiAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgIGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgfSwgNTApOyAgLy8gTW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJpbGl0eVxuICAgIFxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IG9uIHRvcCBvZiB0aGUgZG90XG4gICAgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIGxlZnQ6ICR7ZG90UG9zaXRpb24ueH1weDtcbiAgICAgIHRvcDogJHtkb3RQb3NpdGlvbi55fXB4O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNTBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgIFxuICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gUmVkcmF3IHRoZSBkb3QgZm9yIHJlbGlhYmlsaXR5XG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgIFxuICAgICAgLy8gQWRkaXRpb25hbCByZWRyYXcgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICBcbiAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSwgMzAwKTtcbiAgICBcbiAgICAvLyBXYWl0IGFmdGVyIGNvdW50ZG93biBjb21wbGV0ZXNcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9zdENvdW50ZG93bkRlbGF5KSk7XG4gICAgXG4gICAgLy8gRW5zdXJlIHRoZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICBcbiAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgIHBvaW50OiBkb3RQb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50LFxuICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICB9KTtcbiAgICBcbiAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyZSBjb21wbGV0ZWQnLFxuICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBwb3NpdGlvbjogZG90UG9zaXRpb24sXG4gICAgICBjYXB0dXJlUmVzdWx0XG4gICAgfTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlRG90UHJvY2VzczpcIiwgZXJyb3IpO1xuICAgIFxuICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgcHJvY2Vzc1N0YXR1czogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgICBcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWwgZmlyc3RcbiAgICBpZiAoa2VlcERvdFZpc2libGVJbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChrZWVwRG90VmlzaWJsZUludGVydmFsKTtcbiAgICAgIGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgaWYgKGNvdW50ZG93bkVsZW1lbnQgJiYgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgIGNvbnN0IHJlbWFpbmluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICByZW1haW5pbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFVzZSByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgdG8gcHJvcGVybHkgcmVzdG9yZSBjYW52YXNcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICByZXN0b3JlQ2FudmFzVG9Db250YWluZXIoY2FudmFzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgYSBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgMTAwMCk7XG4gIH1cbn07XG4gIFxuICBjb25zdCBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgLy8gRGVjbGFyZSB0aGVzZSB2YXJpYWJsZXMgT1VUU0lERSB0aGUgdHJ5IGJsb2NrXG4gICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgbGV0IG9yaWdpbmFsQ2FudmFzUGFyZW50ID0gbnVsbDtcbiAgICBsZXQgb3JpZ2luYWxDYW52YXNTdHlsZSA9IHt9O1xuICAgIGxldCBzdGF0dXNJbmRpY2F0b3IgPSBudWxsO1xuICAgIGxldCBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNhbnZhcyA9IGVuc3VyZUNhbnZhc0V4aXN0cygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgZm9yIGNhbGlicmF0aW9uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEhpZGUgVG9wQmFyXG4gICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFNob3dDYW52YXModHJ1ZSk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKFwiU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIFVJIHVwZGF0ZXMgdG8gdGFrZSBlZmZlY3RcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhcyByZWZlcmVuY2VcbiAgICAgIGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoXCJFcnJvcjogQ2FudmFzIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNhdmUgb3JpZ2luYWwgcGFyZW50IGFuZCBzdHlsZVxuICAgICAgb3JpZ2luYWxDYW52YXNQYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgIG9yaWdpbmFsQ2FudmFzU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogY2FudmFzLnN0eWxlLmxlZnQsXG4gICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiBjYW52YXMuc3R5bGUuekluZGV4XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBNb3ZlIGNhbnZhcyB0byBib2R5IGZvciBtYXhpbXVtIHJlbGlhYmlsaXR5XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBcbiAgICAgIC8vIE1ha2UgY2FudmFzIGZ1bGxzY3JlZW4gd2l0aCBmaXhlZCBwb3NpdGlvbmluZ1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgXG4gICAgICAvLyBTZXQgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3cgZXhhY3RseVxuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYENhbnZhcyBzZXQgdG8gZnVsbHNjcmVlbjogJHtjYW52YXNXaWR0aH14JHtjYW52YXNIZWlnaHR9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjb250ZXh0XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gdGhlIGNhbnZhcyBzaXplXG4gICAgICBjb25zdCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnKTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgc3RhdHVzIGluZGljYXRvclxuICAgICAgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgcGFkZGluZzogMTBweCAxNXB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb246IEluaXRpYWxpemluZy4uLic7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgaWYgKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGRpc3BsYXlzXG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbjogUG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgY2FudmFzIGlmIGRpbWVuc2lvbnMgY2hhbmdlZFxuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhbnZhcyBkaW1lbnNpb25zIGNoYW5nZWQuIFJlc2V0dGluZyB0byAke2NhbnZhc1dpZHRofXgke2NhbnZhc0hlaWdodH1gKTtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGJvZHkgYW5kIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IDE0OyAvLyBTbGlnaHRseSBsYXJnZXIgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSByZWRyYXcgZnVuY3Rpb24gZm9yIHRoaXMgcG9pbnRcbiAgICAgICAgY29uc3QgcmVkcmF3Q3VycmVudERvdCA9ICgpID0+IHtcbiAgICAgICAgICAvLyBWZXJpZnkgY2FudmFzIGRpbWVuc2lvbnMgYW5kIHBhcmVudFxuICAgICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYm9keVxuICAgICAgICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZWRyYXcgZG90IHdpdGhvdXQgY2xlYXJpbmdcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCByZWRyYXcgaW50ZXJ2YWwgLSBtb3JlIGZyZXF1ZW50IHVwZGF0ZXMgZm9yIHJlbGlhYmxlIGRvdCB2aXNpYmlsaXR5XG4gICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKHJlZHJhd0N1cnJlbnREb3QsIDUwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjdXN0b20gY291bnRkb3duIGVsZW1lbnRcbiAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJzsgLy8gQ29uc2lzdGVudCBjbGFzcyBuYW1lXG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgbGVmdDogJHtwb2ludC54fXB4O1xuICAgICAgICAgIHRvcDogJHtwb2ludC55IC0gNjB9cHg7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH06IENvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3JjZSByZWRyYXcgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlZHJhdyBhZ2FpbiBoYWxmd2F5IHRocm91Z2ggdGhlIHdhaXQgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG5cbiAgICAgICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtwb2ludC54fSwgJHtwb2ludC55fSlgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYW51YWwgZm9yY2UgcmVkcmF3IG9uZSBtb3JlIHRpbWUganVzdCBiZWZvcmUgY2FwdHVyZVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIENsZWFuIHVwIGNvdW50ZG93biBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgIH1cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbGlicmF0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCByZWRyYXcgaW50ZXJ2YWxcbiAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZW1vdmUgc3RhdHVzIGluZGljYXRvciBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IgJiYgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhbnVwQ2FudmFzKCk7XG4gICAgICB9LCAzMDAwKTtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTZXRSYW5kb20gPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGVuc3VyZUNhbnZhc0V4aXN0cygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgZm9yIHNldCByYW5kb20nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gQWx3YXlzIGdldCB0aGUgbGF0ZXN0IHNldHRpbmdzIGZyb20gY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgdXNlclxuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3MgJiYgc2V0dGluZ3NbY3VycmVudFVzZXJJZF0gPyBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSA6IHt9O1xuICAgICAgY29uc3QgdGltZXMgPSBOdW1iZXIodXNlclNldHRpbmdzLnRpbWVzX3NldF9yYW5kb20pIHx8IE51bWJlcihyYW5kb21UaW1lcykgfHwgMTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheV9zZXRfcmFuZG9tKSB8fCBOdW1iZXIoZGVsYXlTZWNvbmRzKSB8fCAzO1xuXG4gICAgICAvLyBMb2cgY3VycmVudCBzZXR0aW5ncyBiZWZvcmUgc3RhcnRpbmdcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBTZXQgUmFuZG9tIHdpdGggc2V0dGluZ3M6Jywge1xuICAgICAgICByYW5kb21UaW1lcyxcbiAgICAgICAgZGVsYXlTZWNvbmRzLFxuICAgICAgICBjdXJyZW50VXNlcklkLFxuICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgdXNlclNldHRpbmdzLFxuICAgICAgICB0aW1lcyxcbiAgICAgICAgZGVsYXlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIFRvcEJhclxuICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyh0aW1lcyk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBTdGFydGluZyAke3RpbWVzfSByYW5kb20gY2FwdHVyZXMgd2l0aCAke2RlbGF5fXMgZGVsYXkuLi5gKTtcblxuICAgICAgLy8gUHJvY2VzcyBhbGwgY2FwdHVyZXMgaW4gc2VxdWVuY2VcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBjdXJyZW50SW5kZXggPSAxOyBjdXJyZW50SW5kZXggPD0gdGltZXM7IGN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZm9yIGN1cnJlbnQgY2FwdHVyZVxuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fSBvZiAke3RpbWVzfWApO1xuICAgICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyh0aW1lcyAtIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG9mICR7dGltZXN9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgaGFuZGxlRG90UHJvY2VzcyBmb3IgZWFjaCBjYXB0dXJlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZURvdFByb2Nlc3Moe1xuICAgICAgICAgIHVzZVJhbmRvbVBvc2l0aW9uOiB0cnVlLFxuICAgICAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0vJHt0aW1lc306ICR7c3RhdHVzLnByb2Nlc3NTdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHNob3cgVG9wQmFyIGFmdGVyIHRoZSBsYXN0IGNhcHR1cmVcbiAgICAgICAgICAgIGlmIChzaG93ICYmIGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3Qgc2hvdyB5ZXQgZm9yIGludGVybWVkaWF0ZSBjYXB0dXJlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgc2hvdyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihzaG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICAgICAgc2V0SXNDYXB0dXJpbmc6IChjYXB0dXJpbmcpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2V0IGNhcHR1cmluZyB0byBmYWxzZSBhZnRlciBhbGwgY2FwdHVyZXNcbiAgICAgICAgICAgIGlmICghY2FwdHVyaW5nICYmIGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy8gU3RheSBpbiBjYXB0dXJpbmcgc3RhdGUgYmV0d2VlbiBkb3RzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhjYXB0dXJpbmcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgICBwb3N0Q291bnRkb3duRGVsYXk6IDgwMFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBjYXB0dXJlICR7Y3VycmVudEluZGV4fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0gbWF5IGhhdmUgZmFpbGVkOmAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYmV0d2VlbiBjYXB0dXJlcyAtIGJ1dCBvbmx5IGlmIHRoZXJlIGFyZSBtb3JlIGNhcHR1cmVzIHRvIGdvXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyAke2RlbGF5fXMgYmVmb3JlIG5leHQgY2FwdHVyZS4uLmApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSAqIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wbGV0aW9uIG5vdGlmaWNhdGlvblxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUmFuZG9tIGNhcHR1cmUgc2VxdWVuY2UgY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gY2FwdHVyZXMgc3VjY2Vzc2Z1bGApO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBjb25zb2xlLmxvZyhgQ29tcGxldGVkIGFsbCBjYXB0dXJlczogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IHN1Y2Nlc3NmdWxgKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUmFuZG9tIHNlcXVlbmNlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBSYW5kb20gc2VxdWVuY2UgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhbnVwQ2FudmFzKCk7XG4gICAgICB9LCAzMDAwKTtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKTtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVSYW5kb21Eb3QgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gZW5zdXJlQ2FudmFzRXhpc3RzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyBmb3IgcmFuZG9tIGRvdCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVzZSB0aGUgY29uc29saWRhdGVkIGZ1bmN0aW9uIHdpdGggcmFuZG9tIHBvc2l0aW9uXG4gICAgICBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgICAgdXNlUmFuZG9tUG9zaXRpb246IHRydWUsXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgICBpZiAoc3RhdHVzLmlzQ2FwdHVyaW5nICE9PSB1bmRlZmluZWQpIHNldElzQ2FwdHVyaW5nKHN0YXR1cy5pc0NhcHR1cmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgIHBvc3RDb3VudGRvd25EZWxheTogMTAwMFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSYW5kb20gZG90IGVycm9yOicsIGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQ2xlYW4gdXAgY2FudmFzIGFmdGVyIHByb2Nlc3MgY29tcGxldGVzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cENhbnZhcygpO1xuICAgICAgfSwgMjAwMCk7IC8vIFdhaXQgMiBzZWNvbmRzIGJlZm9yZSBjbGVhbnVwXG4gICAgfVxuICAgIFxuICB9O1xuICBjb25zdCBtYWtlQ2FudmFzRnVsbHNjcmVlbiA9IChjYW52YXMpID0+IHtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZSBpZiBub3QgYWxyZWFkeSBzYXZlZFxuICAgIGlmICghY2FudmFzLl9vcmlnaW5hbFN0YXRlKSB7XG4gICAgICBjYW52YXMuX29yaWdpbmFsU3RhdGUgPSB7XG4gICAgICAgIHBhcmVudDogY2FudmFzLnBhcmVudEVsZW1lbnQsXG4gICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogY2FudmFzLnN0eWxlLmxlZnQsXG4gICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiBjYW52YXMuc3R5bGUuekluZGV4LFxuICAgICAgICBjYW52YXNXaWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBjYW52YXNIZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIE1vdmUgdG8gYm9keSBhbmQgbWFrZSBmdWxsc2NyZWVuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGUnO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3dcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG4gIFxuXG4gIC8vIExvYWQgY2FsaWJyYXRpb24gc2V0dXBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIGNvbnN0IHNldHVwQ2FsaWJyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IENhbGlicmF0ZUhhbmRsZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyJyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW52YXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgc2V0dXBDYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIG1ha2VDYW52YXNGdWxsc2NyZWVuKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhcyBzaXplOicsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0dlbmVyYXRlZCBjYWxpYnJhdGlvbiBwb2ludHM6JywgcG9pbnRzKTtcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25Qb2ludHMocG9pbnRzKTtcbiAgICBcbiAgICAgICAgY29uc3QgY2FsaWJyYXRlSGFuZGxlciA9IG5ldyBDYWxpYnJhdGVIYW5kbGVyKHtcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgY2FsaWJyYXRpb25Qb2ludHM6IHBvaW50cyxcbiAgICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiBvbkFjdGlvbkNsaWNrPy4oJ3RvZ2dsZVRvcEJhcicsIHNob3cpLFxuICAgICAgICAgIHNldE91dHB1dFRleHQ6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudGVyOiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0NvdW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KHByZXYgPT4gbmV3Q291bnRlcihwcmV2KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQobmV3Q291bnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBzZXRDYWxpYnJhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgIGhhbmRsZUFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbi4uLicpO1xuICAgICAgICAgICAgYXdhaXQgY2FsaWJyYXRlSGFuZGxlci5zdGFydENhbGlicmF0aW9uKCk7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIHJlc3RvcmVDYW52YXNTaXplKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY2FsaWJyYXRpb246JywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0dXBDYWxpYnJhdGlvbigpO1xuICB9LCBbY2FwdHVyZUNvdW50LCBvbkFjdGlvbkNsaWNrXSk7XG4gIFxuICAvLyBDbGVhciBBbGwgQnV0dG9uIC0gUmVzZXQgZXZlcnl0aGluZ1xuICBjb25zdCBoYW5kbGVDbGVhckFsbCA9ICgpID0+IHtcbiAgICAvLyBDbGVhciBjYW52YXMgY29udGVudFxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgY2FudmFzIHRvIGNvbnRhaW5lciBtb2RlXG4gICAgICByZXN0b3JlQ2FudmFzVG9Db250YWluZXIoY2FudmFzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVzZXQgc3RhdGVzXG4gICAgc2V0UHJvY2Vzc1N0YXR1cygnJyk7XG4gICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgIHNldENvdW50ZG93blZhbHVlKG51bGwpO1xuICAgIHNldFNob3dDYW52YXModHJ1ZSk7XG4gICAgc2V0Q3VycmVudERvdChudWxsKTtcbiAgfTtcblxuICAvLyBUb2dnbGUgSGVhZCBQb3NlIHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlSGVhZFBvc2UgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3SGVhZFBvc2VTdGF0ZSA9ICFzaG93SGVhZFBvc2U7XG4gICAgc2V0U2hvd0hlYWRQb3NlKG5ld0hlYWRQb3NlU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYEhlYWQgcG9zZSB2aXN1YWxpemF0aW9uICR7bmV3SGVhZFBvc2VTdGF0ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ2hlYWRQb3NlJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd0hlYWRQb3NlOiBuZXdIZWFkUG9zZVN0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgaGVhZCBwb3NlOiAke25ld0hlYWRQb3NlU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBCb3VuZGluZyBCb3ggdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVCb3VuZGluZ0JveCA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdCb3VuZGluZ0JveFN0YXRlID0gIXNob3dCb3VuZGluZ0JveDtcbiAgICBzZXRTaG93Qm91bmRpbmdCb3gobmV3Qm91bmRpbmdCb3hTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgQm91bmRpbmcgYm94ICR7bmV3Qm91bmRpbmdCb3hTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnYm91bmRpbmdCb3gnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93Qm91bmRpbmdCb3g6IG5ld0JvdW5kaW5nQm94U3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBib3VuZGluZyBib3g6ICR7bmV3Qm91bmRpbmdCb3hTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIE1hc2sgdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVNYXNrID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld01hc2tTdGF0ZSA9ICFzaG93TWFzaztcbiAgICBzZXRTaG93TWFzayhuZXdNYXNrU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYE1hc2sgJHtuZXdNYXNrU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ21hc2snKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93TWFzazogbmV3TWFza1N0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgbWFzazogJHtuZXdNYXNrU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBQYXJhbWV0ZXJzIGRpc3BsYXlcbiAgY29uc3QgaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdQYXJhbWV0ZXJzU3RhdGUgPSAhc2hvd1BhcmFtZXRlcnM7XG4gICAgc2V0U2hvd1BhcmFtZXRlcnMobmV3UGFyYW1ldGVyc1N0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBQYXJhbWV0ZXJzICR7bmV3UGFyYW1ldGVyc1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd1BhcmFtZXRlcnM6IG5ld1BhcmFtZXRlcnNTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIHBhcmFtZXRlcnM6ICR7bmV3UGFyYW1ldGVyc1N0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgY2FtZXJhIHByZXZpZXdcbiAgY29uc3QgaGFuZGxlVG9nZ2xlQ2FtZXJhID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0NhbWVyYVN0YXRlID0gIWlzQ2FtZXJhQWN0aXZlO1xuICAgIHNldElzQ2FtZXJhQWN0aXZlKG5ld0NhbWVyYVN0YXRlKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB3aXRoICdwcmV2aWV3JyBhY3Rpb25cbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygncHJldmlldycsIG5ld0NhbWVyYVN0YXRlKTsgLy8gUGFzcyB0aGUgbmV3IHN0YXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCB0cmlnZ2VyIGlmIG5vIGFjdGlvbiBoYW5kbGVyXG4gICAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0dXJuaW5nIG9uIGNhbWVyYSwgZW5zdXJlIHdlIGFwcGx5IGN1cnJlbnQgdmlzdWFsaXphdGlvbiBzZXR0aW5nc1xuICAgIGlmIChuZXdDYW1lcmFTdGF0ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIC8vIFdhaXQgYSBzaG9ydCBtb21lbnQgdG8gZW5zdXJlIHRoZSB2aWRlbyBlbGVtZW50IGlzIHJlYWR5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgIHNob3dIZWFkUG9zZSxcbiAgICAgICAgICAgIHNob3dCb3VuZGluZ0JveCxcbiAgICAgICAgICAgIHNob3dNYXNrLFxuICAgICAgICAgICAgc2hvd1BhcmFtZXRlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGJhY2sgYnV0dG9uIGhhbmRsZXJcbiAgY29uc3QgaGFuZGxlR29CYWNrID0gKCkgPT4ge1xuICAgIHJvdXRlci5wdXNoKCcvJyk7XG4gIH07XG5cbiAgLy8gTW9iaWxlIGxheW91dCAtIDJ4NSBncmlkXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIHtpc0NvbXBhY3RNb2RlID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTIgbWItNFwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yXCI+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7LyogQ2FtZXJhIFBlcm1pc3Npb24gUG9wdXAgKi99XG4gICAgICB7c2hvd1Blcm1pc3Npb25Qb3B1cCAmJiAoXG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tcG9wdXBcIiBcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgekluZGV4OiAxNVxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tZGlhbG9nXCIgXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICB3aWR0aDogJzQwMHB4JyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMjBweCcsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMiknXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxoMyBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tdGl0bGVcIiBcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMTVweCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgQ2FtZXJhIEFjY2VzcyBSZXF1aXJlZFxuICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgIDxwIFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1tZXNzYWdlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDIwcHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogJzEuNCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVGhpcyBhcHBsaWNhdGlvbiBuZWVkcyBhY2Nlc3MgdG8geW91ciBjYW1lcmEgdG8gZnVuY3Rpb24gcHJvcGVybHkuIFdoZW4gcHJvbXB0ZWQgYnkgeW91ciBicm93c2VyLCBwbGVhc2UgY2xpY2sgXCJBbGxvd1wiIHRvIGdyYW50IGNhbWVyYSBhY2Nlc3MuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1idXR0b25zXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgICAgICAgICAgIGdhcDogJzEwcHgnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUGVybWlzc2lvbkRlbmllZH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtYnRuXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCAxNnB4JyxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmMGYwZjAnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ2FuY2VsXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25BY2NlcHRlZH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtYnRuXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCAxNnB4JyxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMwMDY2Y2MnLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBDb250aW51ZVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59KTtcbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoXG4gIGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IDxBY3Rpb25CdXR0b25Hcm91cElubmVyIHsuLi5wcm9wc30gcmVmPXtyZWZ9IC8+KVxuKSwgeyBzc3I6IGZhbHNlIH0pO1xuLy8gQ3JlYXRlIGEgY2xpZW50LW9ubHkgdmVyc2lvbiBvZiBBY3Rpb25CdXR0b25Hcm91cFxuLy8gY29uc3QgQWN0aW9uQnV0dG9uR3JvdXAgPSBkeW5hbWljKCgpID0+IFByb21pc2UucmVzb2x2ZShBY3Rpb25CdXR0b25Hcm91cElubmVyKSwgeyBzc3I6IGZhbHNlIH0pO1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBY3Rpb25CdXR0b25QYWdlKCkge1xuICByZXR1cm4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcbn1cblxuZXhwb3J0IHsgQWN0aW9uQnV0dG9uLCBBY3Rpb25CdXR0b25Hcm91cCB9OyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiZm9yd2FyZFJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VNZW1vIiwiZHluYW1pYyIsImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJkcmF3UmVkRG90IiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJjcmVhdGVDb3VudGRvd25FbGVtZW50IiwicnVuQ291bnRkb3duIiwiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJ1c2VSb3V0ZXIiLCJ1c2VBZG1pblNldHRpbmdzIiwiaXNFcXVhbCIsIm9iajEiLCJvYmoyIiwia2V5czEiLCJPYmplY3QiLCJrZXlzIiwia2V5czIiLCJsZW5ndGgiLCJldmVyeSIsImtleSIsImluY2x1ZGVzIiwiQWN0aW9uQnV0dG9uIiwidGV4dCIsImFiYnJldmlhdGVkVGV4dCIsIm9uQ2xpY2siLCJjdXN0b21DbGFzcyIsImRpc2FibGVkIiwiYWN0aXZlIiwiaXNBYmJyZXZpYXRlZCIsInNldElzQWJicmV2aWF0ZWQiLCJzZXR0aW5ncyIsImN1cnJlbnRVc2VySWQiLCJzZXRDdXJyZW50VXNlcklkIiwiaXNDYXB0dXJpbmciLCJzZXRJc0NhcHR1cmluZyIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJwcm9jZXNzU3RhdHVzIiwic2V0UHJvY2Vzc1N0YXR1cyIsImJ1dHRvblByb3BzIiwiY2xhc3NOYW1lIiwidGl0bGUiLCJ0aW1lb3V0SWQiLCJoYW5kbGVSZXNpemUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0Iiwid2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVVc2VySWRDaGFuZ2UiLCJldmVudCIsImRldGFpbCIsInR5cGUiLCJuZXdVc2VySWQiLCJ1c2VySWQiLCJidXR0b24iLCJkaXYiLCJBY3Rpb25CdXR0b25Hcm91cElubmVyIiwicmVmIiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsImlzQ29tcGFjdE1vZGUiLCJvbkFjdGlvbkNsaWNrIiwicm91dGVyIiwidXBkYXRlU2V0dGluZ3MiLCJyYW5kb21UaW1lcyIsInNldFJhbmRvbVRpbWVzIiwiZGVsYXlTZWNvbmRzIiwic2V0RGVsYXlTZWNvbmRzIiwiY2FudmFzUmVmIiwiY291bnRkb3duVmFsdWUiLCJzZXRDb3VudGRvd25WYWx1ZSIsImN1cnJlbnREb3QiLCJzZXRDdXJyZW50RG90IiwiY2FsaWJyYXRpb25Qb2ludHMiLCJzZXRDYWxpYnJhdGlvblBvaW50cyIsInJlbWFpbmluZ0NhcHR1cmVzIiwic2V0UmVtYWluaW5nQ2FwdHVyZXMiLCJzaG93Q2FudmFzIiwic2V0U2hvd0NhbnZhcyIsImNhbGlicmF0aW9uSGFuZGxlciIsInNldENhbGlicmF0aW9uSGFuZGxlciIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsInNob3dIZWFkUG9zZSIsInNldFNob3dIZWFkUG9zZSIsInNob3dCb3VuZGluZ0JveCIsInNldFNob3dCb3VuZGluZ0JveCIsInNob3dNYXNrIiwic2V0U2hvd01hc2siLCJzaG93UGFyYW1ldGVycyIsInNldFNob3dQYXJhbWV0ZXJzIiwiaXNDYW1lcmFBY3RpdmUiLCJzZXRJc0NhbWVyYUFjdGl2ZSIsInNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXRTaG93UGVybWlzc2lvblBvcHVwIiwic2V0dGluZ3NDYWNoZSIsIk1hcCIsImxhc3RTZXR0aW5nc1VwZGF0ZSIsInVzZXJTZXR0aW5ncyIsImNhY2hlZFNldHRpbmdzIiwiY3VycmVudCIsImdldCIsIk51bWJlciIsInRpbWVzX3NldF9yYW5kb20iLCJkZWxheV9zZXRfcmFuZG9tIiwic2V0IiwiRGF0ZSIsIm5vdyIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidW5kZWZpbmVkIiwibmV3VGltZXMiLCJuZXdEZWxheSIsImFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyIsImhhbmRsZVJhbmRvbURvdCIsImhhbmRsZVNldFJhbmRvbSIsImhhbmRsZVNldENhbGlicmF0ZSIsImhhbmRsZUNsZWFyQWxsIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiY2FudmFzIiwiZ2V0TWFpbkNhbnZhcyIsImNvbnNvbGUiLCJsb2ciLCJ1cGRhdGVDb250cm9sVmFsdWVzIiwidGltZUlucHV0IiwidGltZVZhbHVlIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImlzTmFOIiwiZGVsYXlJbnB1dCIsImRlbGF5VmFsdWUiLCJpbml0aWFsaXplQ2FudmFzIiwiZXhpc3RpbmdDYW52YXMiLCJyZW1vdmUiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJzdHlsZSIsImNzc1RleHQiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIndoaXRlU2NyZWVuQ2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2xlYW51cCIsImNvbnRhaW5zIiwiY29udGFpbmVyIiwiaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkIiwiaGFuZGxlUGVybWlzc2lvbkRlbmllZCIsInJlc3RvcmVDYW52YXMiLCJfb3JpZ2luYWxTdGF0ZSIsIm9yaWdpbmFsIiwicGFyZW50IiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiekluZGV4IiwiYmFja2dyb3VuZENvbG9yIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJlcnJvciIsImNsZWFyQ2FudmFzIiwid2FybiIsImNsZWFyUmVjdCIsImVuc3VyZUNhbnZhc0V4aXN0cyIsIndpbmRvd1dpZHRoIiwid2luZG93SGVpZ2h0IiwiX3Jlc2l6ZUhhbmRsZXIiLCJjbGVhbnVwQ2FudmFzIiwicmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyIiwiY29udGFpbmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImhhbmRsZURvdFByb2Nlc3MiLCJvcHRpb25zIiwib25TdGF0dXNVcGRhdGUiLCJ0b2dnbGVUb3BCYXIiLCJ1c2VSYW5kb21Qb3NpdGlvbiIsInBvc3RDb3VudGRvd25EZWxheSIsImtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwiLCJjb3VudGRvd25FbGVtZW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJFcnJvciIsImRvdFBvc2l0aW9uIiwieCIsInkiLCJkb3RSYWRpdXMiLCJzZXRJbnRlcnZhbCIsImV4aXN0aW5nQ291bnRkb3ducyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJjb3VudCIsInRleHRDb250ZW50IiwiY2FwdHVyZVJlc3VsdCIsInBvaW50Iiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJjbGVhckludGVydmFsIiwicmVtYWluaW5nQ291bnRkb3ducyIsIm9yaWdpbmFsQ2FudmFzUGFyZW50Iiwib3JpZ2luYWxDYW52YXNTdHlsZSIsInN0YXR1c0luZGljYXRvciIsImN1cnJlbnRSZWRyYXdJbnRlcnZhbCIsInBhcmVudEVsZW1lbnQiLCJwb2ludHMiLCJzdWNjZXNzQ291bnQiLCJpIiwicmFkaXVzIiwicmVkcmF3Q3VycmVudERvdCIsInNjcmVlbkltYWdlIiwidGltZXMiLCJkZWxheSIsImN1cnJlbnRJbmRleCIsInJlc3VsdCIsInN0YXR1cyIsInNob3ciLCJjYXB0dXJpbmciLCJtYWtlQ2FudmFzRnVsbHNjcmVlbiIsInNldHVwQ2FsaWJyYXRpb24iLCJkZWZhdWx0IiwiQ2FsaWJyYXRlSGFuZGxlciIsImNhbGlicmF0ZUhhbmRsZXIiLCJzZXRPdXRwdXRUZXh0IiwibmV3Q291bnRlciIsInByZXYiLCJjYXB0dXJlRm9sZGVyIiwib25Db21wbGV0ZSIsImhhbmRsZUFjdGlvbiIsInN0YXJ0Q2FsaWJyYXRpb24iLCJyZXN0b3JlQ2FudmFzU2l6ZSIsImVyciIsImhhbmRsZVRvZ2dsZUhlYWRQb3NlIiwibmV3SGVhZFBvc2VTdGF0ZSIsInZpZGVvUHJvY2Vzc29yIiwidXBkYXRlT3B0aW9ucyIsImhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94IiwibmV3Qm91bmRpbmdCb3hTdGF0ZSIsImhhbmRsZVRvZ2dsZU1hc2siLCJuZXdNYXNrU3RhdGUiLCJoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzIiwibmV3UGFyYW1ldGVyc1N0YXRlIiwiaGFuZGxlVG9nZ2xlQ2FtZXJhIiwibmV3Q2FtZXJhU3RhdGUiLCJoYW5kbGVHb0JhY2siLCJwdXNoIiwiZGlzcGxheSIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJoMyIsIm1hcmdpbiIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiYm9yZGVyIiwiY3Vyc29yIiwiY29sb3IiLCJBY3Rpb25CdXR0b25Hcm91cCIsInByb3BzIiwic3NyIiwiQWN0aW9uQnV0dG9uUGFnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});