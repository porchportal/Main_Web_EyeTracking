"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js":
/*!********************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/countSave.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calibrationCapture: () => (/* binding */ calibrationCapture),\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\");\n// Fixed countSave.js - Resolving redrawInterval reference error\n// Shared functionality for countdown and image capture processes\n\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(absoluteX, \"px;\\n    top: \").concat(absoluteY - 60, \"px;\\n    transform: translateX(-50%);\\n    color: red;\\n    font-size: 36px;\\n    font-weight: bold;\\n    text-shadow: 0 0 10px white, 0 0 20px white;\\n    z-index: 9999;\\n    background-color: rgba(255, 255, 255, 0.8);\\n    border: 2px solid red;\\n    border-radius: 50%;\\n    width: 50px;\\n    height: 50px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n  \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Display a preview of the captured images\n * @param {string} screenImage - Data URL of the screen image\n * @param {string} webcamImage - Data URL of the webcam image\n * @param {Object} point - {x, y} position of the dot\n */ const showCapturePreview = (screenImage, webcamImage, point)=>{\n    if (!screenImage && !webcamImage) return;\n    // Remove any existing previews\n    const existingPreviews = document.querySelectorAll('.capture-preview-container');\n    existingPreviews.forEach((preview)=>{\n        if (preview.parentNode) {\n            preview.parentNode.removeChild(preview);\n        }\n    });\n    // Create preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    display: flex;\\n    gap: 20px;\\n    background-color: rgba(0, 0, 0, 0.85);\\n    padding: 20px;\\n    border-radius: 12px;\\n    z-index: 999999;\\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n  \";\n    // Add screen image if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.alt = 'Screen Capture';\n        screenImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam image if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.alt = 'Webcam Capture';\n        webcamImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add point info\n    if (point) {\n        const pointInfo = document.createElement('div');\n        pointInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Point: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n        pointInfo.style.cssText = \"\\n      color: #ffcc00;\\n      font-size: 14px;\\n      position: absolute;\\n      top: -40px;\\n      left: 0;\\n      width: 100%;\\n      text-align: center;\\n    \";\n        previewContainer.appendChild(pointInfo);\n    }\n    // Add timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n    position: absolute;\\n    bottom: -25px;\\n    right: 20px;\\n    color: white;\\n    font-size: 12px;\\n    background-color: rgba(0, 0, 0, 0.7);\\n    padding: 3px 8px;\\n    border-radius: 4px;\\n  \";\n    previewContainer.appendChild(timerElement);\n    // Add to document\n    document.body.appendChild(previewContainer);\n    // Countdown\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            previewContainer.style.opacity = '0';\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    // Create redrawInterval for keeping dot visible during countdown\n    let redrawInterval = setInterval(()=>{\n        drawRedDot(ctx, position.x, position.y, 12, false);\n    }, 200);\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    drawRedDot(ctx, position.x, position.y, 12, false);\n                    // Clear the redrawInterval we defined above\n                    if (redrawInterval) {\n                        clearInterval(redrawInterval);\n                    }\n                    if (onComplete) {\n                        drawRedDot(ctx, position.x, position.y, 12, false);\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n * Draw a red dot on the canvas\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n * @returns {Object} - {x, y} position\n */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'whoite';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * @param {Object} options - Capture options\n * @returns {Promise} - Promise that resolves with the capture result\n */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[captureImages] Invalid position object:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid capture position');\n        return null;\n    }\n    try {\n        // Call the captureImagesAtPoint from savefile.js\n        const result = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_0__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        return {\n            screenImage: (result === null || result === void 0 ? void 0 : result.screenImage) || '',\n            webcamImage: (result === null || result === void 0 ? void 0 : result.webcamImage) || '',\n            success: true\n        };\n    } catch (err) {\n        console.error('[captureImages] Unexpected error:', err);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: err.message\n        };\n    }\n};\n/**\n * Generate a random dot position within the canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} padding - Padding from the edges\n * @returns {Object} - {x, y} position\n */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n * Special calibration capture function that avoids problematic code paths\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ /**\n * Special calibration capture function that behaves like random dot capture\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ const calibrationCapture = async (options)=>{\n    const { canvasRef, point, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures', pointIndex, totalPoints } = options;\n    try {\n        console.log(\"Starting calibration capture for point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Get canvas\n        const canvas = canvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas reference is null in calibrationCapture\");\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: Canvas not available\");\n            return {\n                success: false\n            };\n        }\n        // Use the exact same drawing method as random dots\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, point.x, point.y);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Calibration point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Use the same countdown element creation method\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = createCountdownElement(point, canvasRect);\n        if (!countdownElement) {\n            console.error(\"Failed to create countdown element\");\n            return {\n                success: false\n            };\n        }\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, point.x, point.y, 12, false);\n        }, 200);\n        // Run the same countdown as random dot\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Point \".concat(pointIndex + 1, \"/\").concat(totalPoints, \" - countdown \").concat(count));\n            // Redraw the dot at each step to ensure it remains visible\n            drawRedDot(ctx, point.x, point.y, 12, false);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show checkmark\n        countdownElement.textContent = \"✓\";\n        // Remove countdown element\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Clear redrawInterval\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureAndPreviewProcess instead of directly calling captureImagesAtPoint\n        const captureResult = await captureAndPreviewProcess({\n            canvasRef,\n            position: point,\n            captureCounter,\n            setCaptureCounter,\n            setProcessStatus: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            captureFolder\n        });\n        // Ensure proper return even if captureResult is null\n        const safeResult = captureResult && typeof captureResult === 'object' ? captureResult : {\n            screenImage: '',\n            webcamImage: '',\n            success: false\n        };\n        return {\n            screenImage: safeResult.screenImage || '',\n            webcamImage: safeResult.webcamImage || '',\n            success: true,\n            point\n        };\n    } catch (error) {\n        console.error(\"Error in calibrationCapture:\", error);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(error.message));\n        // Always return a valid object with default values\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Complete capture and preview process\n * @param {Object} options - Process options\n */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder } = options;\n    try {\n        const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;\n        if (!canvas) {\n            console.error(\"[captureAndPreviewProcess] Canvas reference is null\");\n            if (setProcessStatus) setProcessStatus('Error: Canvas is not available');\n            return null;\n        }\n        // Draw the dot\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, position.x, position.y);\n        // Countdown before capture\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Starting countdown...',\n                isCapturing: true\n            });\n        }\n        // Create a custom countdown element\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = document.createElement('div');\n        countdownElement.className = 'calibrate-countdown';\n        countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(canvasRect.left + position.x, \"px;\\n      top: \").concat(canvasRect.top + position.y - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n        document.body.appendChild(countdownElement);\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y, 12, false);\n        }, 200);\n        // Manual countdown\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n            // Redraw dot to ensure it's visible\n            drawRedDot(ctx, position.x, position.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Change to checkmark\n        countdownElement.textContent = \"✓\";\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capturing images...',\n                countdownValue: \"Capturing...\",\n                isCapturing: true\n            });\n        }\n        // Remove countdown element and clear redrawInterval\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureImagesAtPoint from savefile.js\n        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_0__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured dot at x=\".concat(Math.round(position.x), \", y=\").concat(Math.round(position.y)));\n        }\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capture complete',\n                isCapturing: false\n            });\n        }\n        // Show TopBar again with delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"[captureAndPreviewProcess] Fatal error:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Fatal error: \".concat(error.message));\n        }\n        // Ensure TopBar is shown even on error\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        // Return a minimal valid object to prevent null reference errors\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsZ0VBQWdFO0FBQ2hFLGlFQUFpRTtBQUNQO0FBRTFEOzs7OztDQUtDLEdBQ00sTUFBTUMseUJBQXlCLENBQUNDLFVBQVVDO0lBQy9DLElBQUksQ0FBQ0QsWUFBWSxPQUFPQSxTQUFTRSxDQUFDLEtBQUssWUFBWSxPQUFPRixTQUFTRyxDQUFDLEtBQUssVUFBVTtRQUNqRkMsUUFBUUMsSUFBSSxDQUFDLDhDQUE4Q0w7UUFDM0QsT0FBTztJQUNUO0lBRUEsTUFBTU0scUJBQXFCQyxTQUFTQyxnQkFBZ0IsQ0FBQztJQUNyREYsbUJBQW1CRyxPQUFPLENBQUNDLENBQUFBLEtBQU1BLEdBQUdDLE1BQU07SUFFMUMsTUFBTUMsWUFBWVgsV0FBV1ksSUFBSSxHQUFHYixTQUFTRSxDQUFDO0lBQzlDLE1BQU1ZLFlBQVliLFdBQVdjLEdBQUcsR0FBR2YsU0FBU0csQ0FBQztJQUU3QyxNQUFNYSxtQkFBbUJULFNBQVNVLGFBQWEsQ0FBQztJQUNoREQsaUJBQWlCRSxTQUFTLEdBQUc7SUFDN0JGLGlCQUFpQkcsS0FBSyxDQUFDQyxPQUFPLEdBQUcscUNBR3hCTixPQURDRixXQUFVLGtCQUNJLE9BQWZFLFlBQVksSUFBRztJQWtCeEJQLFNBQVNjLElBQUksQ0FBQ0MsV0FBVyxDQUFDTjtJQUMxQixPQUFPQTtBQUNULEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNNLE1BQU1PLHFCQUFxQixDQUFDQyxhQUFhQyxhQUFhQztJQUMzRCxJQUFJLENBQUNGLGVBQWUsQ0FBQ0MsYUFBYTtJQUVsQywrQkFBK0I7SUFDL0IsTUFBTUUsbUJBQW1CcEIsU0FBU0MsZ0JBQWdCLENBQUM7SUFDbkRtQixpQkFBaUJsQixPQUFPLENBQUNtQixDQUFBQTtRQUN2QixJQUFJQSxRQUFRQyxVQUFVLEVBQUU7WUFD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QkEsQ0FBQztZQUMvQzRCLE9BQU8xQjtZQUNQNkYsY0FBY047WUFDZEQ7WUFDQVEsaUJBQWlCTjtZQUNqQmpFO1FBQ0Y7UUFFQSxJQUFJa0Usa0JBQWtCO1lBQ3BCQSxpQkFBaUIscUJBQWtEOUMsT0FBN0JBLEtBQUtDLEtBQUssQ0FBQzVDLFNBQVNFLENBQUMsR0FBRSxRQUE2QixPQUF2QnlDLEtBQUtDLEtBQUssQ0FBQzVDLFNBQVNHLENBQUM7UUFDMUY7UUFFQSxJQUFJcUQsZ0JBQWdCO1lBQ2xCQSxlQUFlO2dCQUNiRSxlQUFlO2dCQUNmRSxhQUFhO1lBQ2Y7UUFDRjtRQUVBLCtCQUErQjtRQUMvQlIsV0FBVztZQUNULElBQUksT0FBT3NDLGlCQUFpQixZQUFZO2dCQUN0Q0EsYUFBYTtZQUNmLE9BQU8sSUFBSSxLQUE2QixJQUFJc0IsT0FBT3RCLFlBQVksRUFBRTtnQkFDL0RzQixPQUFPdEIsWUFBWSxDQUFDO1lBQ3RCO1FBQ0YsR0FBRztRQUVILE9BQU9rQjtJQUVULEVBQUUsT0FBT1gsT0FBTztRQUNkN0YsUUFBUTZGLEtBQUssQ0FBQywyQ0FBMkNBO1FBRXpELElBQUlSLGtCQUFrQjtZQUNwQkEsaUJBQWlCLGdCQUE4QixPQUFkUSxNQUFNQyxPQUFPO1FBQ2hEO1FBRUEsdUNBQXVDO1FBQ3ZDOUMsV0FBVztZQUNULElBQUksT0FBT3NDLGlCQUFpQixZQUFZO2dCQUN0Q0EsYUFBYTtZQUNmLE9BQU8sSUFBSSxLQUE2QixJQUFJc0IsT0FBT3RCLFlBQVksRUFBRTtnQkFDL0RzQixPQUFPdEIsWUFBWSxDQUFDO1lBQ3RCO1FBQ0YsR0FBRztRQUVILGlFQUFpRTtRQUNqRSxPQUFPO1lBQ0xsRSxhQUFhO1lBQ2JDLGFBQWE7WUFDYnNFLFNBQVM7WUFDVEUsT0FBT0EsTUFBTUMsT0FBTztRQUN0QjtJQUNGO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRml4ZWQgY291bnRTYXZlLmpzIC0gUmVzb2x2aW5nIHJlZHJhd0ludGVydmFsIHJlZmVyZW5jZSBlcnJvclxuLy8gU2hhcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGNvdW50ZG93biBhbmQgaW1hZ2UgY2FwdHVyZSBwcm9jZXNzZXNcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vSGVscGVyL3NhdmVmaWxlJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBkaXNwbGF5cyBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIGEgZG90IHBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtET01SZWN0fSBjYW52YXNSZWN0IC0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgb2YgdGhlIGNhbnZhc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBjcmVhdGVkIGNvdW50ZG93biBlbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDb3VudGRvd25FbGVtZW50ID0gKHBvc2l0aW9uLCBjYW52YXNSZWN0KSA9PiB7XG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUNvdW50ZG93bkVsZW1lbnRdIEludmFsaWQgcG9zaXRpb246JywgcG9zaXRpb24pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1jb3VudGRvd24sIC5mb3JjZWQtY291bnRkb3duLCAuY2VudGVyLWNvdW50ZG93bi1iYWNrdXAnKTtcbiAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuXG4gIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLng7XG4gIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcblxuICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgIHRvcDogJHthYnNvbHV0ZVkgLSA2MH1weDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgY29sb3I6IHJlZDtcbiAgICBmb250LXNpemU6IDM2cHg7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICB6LWluZGV4OiA5OTk5O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIHdpZHRoOiA1MHB4O1xuICAgIGhlaWdodDogNTBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICBgO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gIHJldHVybiBjb3VudGRvd25FbGVtZW50O1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IGEgcHJldmlldyBvZiB0aGUgY2FwdHVyZWQgaW1hZ2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyZWVuSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgc2NyZWVuIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViY2FtSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgd2ViY2FtIGltYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICovXG5leHBvcnQgY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgcG9pbnQpID0+IHtcbiAgaWYgKCFzY3JlZW5JbWFnZSAmJiAhd2ViY2FtSW1hZ2UpIHJldHVybjtcbiAgXG4gIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlld3NcbiAgY29uc3QgZXhpc3RpbmdQcmV2aWV3cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXB0dXJlLXByZXZpZXctY29udGFpbmVyJyk7XG4gIGV4aXN0aW5nUHJldmlld3MuZm9yRWFjaChwcmV2aWV3ID0+IHtcbiAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICBwcmV2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlldyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIENyZWF0ZSBwcmV2aWV3IGNvbnRhaW5lclxuICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByZXZpZXdDb250YWluZXIuY2xhc3NOYW1lID0gJ2NhcHR1cmUtcHJldmlldy1jb250YWluZXInO1xuICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gIGA7XG4gIFxuICAvLyBBZGQgc2NyZWVuIGltYWdlIGlmIGF2YWlsYWJsZVxuICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2NyZWVuUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgc2NyZWVuSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgc2NyZWVuSW1nLnNyYyA9IHNjcmVlbkltYWdlO1xuICAgIHNjcmVlbkltZy5hbHQgPSAnU2NyZWVuIENhcHR1cmUnO1xuICAgIHNjcmVlbkltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgc2NyZWVuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgc2NyZWVuTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBgO1xuICAgIFxuICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuSW1nKTtcbiAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHNjcmVlblByZXZpZXcpO1xuICB9XG4gIFxuICAvLyBBZGQgd2ViY2FtIGltYWdlIGlmIGF2YWlsYWJsZVxuICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd2ViY2FtUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgd2ViY2FtSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgd2ViY2FtSW1nLnNyYyA9IHdlYmNhbUltYWdlO1xuICAgIHdlYmNhbUltZy5hbHQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgIHdlYmNhbUltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgd2ViY2FtTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3ZWJjYW1MYWJlbC50ZXh0Q29udGVudCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgd2ViY2FtTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBgO1xuICAgIFxuICAgIHdlYmNhbVByZXZpZXcuYXBwZW5kQ2hpbGQod2ViY2FtSW1nKTtcbiAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUxhYmVsKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICB9XG4gIFxuICAvLyBBZGQgcG9pbnQgaW5mb1xuICBpZiAocG9pbnQpIHtcbiAgICBjb25zdCBwb2ludEluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb2ludEluZm8udGV4dENvbnRlbnQgPSBwb2ludC5sYWJlbCA/IFxuICAgICAgYCR7cG9pbnQubGFiZWx9OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWAgOlxuICAgICAgYFBvaW50OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWA7XG4gICAgICBcbiAgICBwb2ludEluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAtNDBweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBgO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9pbnRJbmZvKTtcbiAgfVxuICBcbiAgLy8gQWRkIHRpbWVyXG4gIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IC0yNXB4O1xuICAgIHJpZ2h0OiAyMHB4O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBgO1xuICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gIFxuICAvLyBBZGQgdG8gZG9jdW1lbnRcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgXG4gIC8vIENvdW50ZG93blxuICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwLjNzIGVhc2UnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgfVxuICB9LCAxMDApO1xuICBcbiAgLy8gU2FmZXR5IGNsZWFudXBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIH1cbiAgfSwgNTAwMCk7XG59O1xuXG4vKipcbiAqIFJ1bnMgYSBjb3VudGRvd24gcHJvY2VzcyB0aGF0IGRpc3BsYXlzIDMtMi0xIGFib3ZlIGEgZG90XG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgZG90XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblN0YXR1c1VwZGF0ZSAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdGF0dXMgbWVzc2FnZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGUgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICovXG5leHBvcnQgY29uc3QgcnVuQ291bnRkb3duID0gYXN5bmMgKHBvc2l0aW9uLCBjYW52YXMsIG9uU3RhdHVzVXBkYXRlLCBvbkNvbXBsZXRlKSA9PiB7XG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICBwcm9jZXNzU3RhdHVzOiBcIkludmFsaWQgZG90IHBvc2l0aW9uXCIsXG4gICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvc2l0aW9uLCBjYW52YXNSZWN0KTtcbiAgXG4gIGlmICghY291bnRkb3duRWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gQ291bnRkb3duIGVsZW1lbnQgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICBsZXQgY291bnQgPSAzO1xuICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG5cbiAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIGRvdCB2aXNpYmxlIGR1cmluZyBjb3VudGRvd25cbiAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAxMiwgZmFsc2UpO1xuICB9LCAyMDApO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ZG93bkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY291bnQtLTtcblxuICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudGRvd25JbnRlcnZhbCk7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ2FwdHVyaW5nIGltYWdlLi4uXCIsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcblxuICAgICAgICAgIC8vIENsZWFyIHRoZSByZWRyYXdJbnRlcnZhbCB3ZSBkZWZpbmVkIGFib3ZlXG4gICAgICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcblxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkNvdW50ZG93blwiLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCA4MDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhc1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQ2FudmFzIC0gV2hldGhlciB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIChkZWZhdWx0OiB0cnVlKVxuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYXdSZWREb3QgPSAoY3R4LCB4LCB5LCByYWRpdXMgPSAxMiwgY2xlYXJDYW52YXMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gIFxuICAvLyBDbGVhciB0aGUgY2FudmFzIGlmIHJlcXVlc3RlZCAoZGVmYXVsdCBiZWhhdmlvcilcbiAgaWYgKGNsZWFyQ2FudmFzKSB7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hvaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfVxuICBcbiAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICBjdHguZmlsbCgpO1xuICBcbiAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICBjdHgubGluZVdpZHRoID0gMztcbiAgY3R4LnN0cm9rZSgpO1xuICBcbiAgLy8gQWRkIGEgc2Vjb25kIGxhcmdlciBnbG93IGZvciBldmVuIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4zKSc7XG4gIGN0eC5saW5lV2lkdGggPSAyO1xuICBjdHguc3Ryb2tlKCk7XG4gIFxuICByZXR1cm4geyB4LCB5IH07XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY2FwdHVyZSByZXN1bHRcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcHR1cmVJbWFnZXMgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgY2FudmFzUmVmLFxuICAgIHBvc2l0aW9uLFxuICAgIGNhcHR1cmVDb3VudGVyLFxuICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgdG9nZ2xlVG9wQmFyLFxuICAgIGNhcHR1cmVGb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJ1xuICB9ID0gb3B0aW9ucztcblxuICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tjYXB0dXJlSW1hZ2VzXSBJbnZhbGlkIHBvc2l0aW9uIG9iamVjdDonLCBwb3NpdGlvbik7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cz8uKCdFcnJvcjogSW52YWxpZCBjYXB0dXJlIHBvc2l0aW9uJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIENhbGwgdGhlIGNhcHR1cmVJbWFnZXNBdFBvaW50IGZyb20gc2F2ZWZpbGUuanNcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgY2FudmFzUmVmLCBcbiAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICBzY3JlZW5JbWFnZTogcmVzdWx0Py5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgIHdlYmNhbUltYWdlOiByZXN1bHQ/LndlYmNhbUltYWdlIHx8ICcnLFxuICAgICAgc3VjY2VzczogdHJ1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tjYXB0dXJlSW1hZ2VzXSBVbmV4cGVjdGVkIGVycm9yOicsIGVycik7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICByZXR1cm4ge1xuICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgd2ViY2FtSW1hZ2U6ICcnLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGRvdCBwb3NpdGlvbiB3aXRoaW4gdGhlIGNhbnZhc1xuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gUGFkZGluZyBmcm9tIHRoZSBlZGdlc1xuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gIGlmICghY2FudmFzKSByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICBcbiAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IHx8IDMwMDsgLy8gRmFsbGJhY2sgaWYgaGVpZ2h0IGlzIDBcbiAgXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdpZHRoIC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmcsXG4gICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nXG4gIH07XG59O1xuXG4vKipcbiAqIFNwZWNpYWwgY2FsaWJyYXRpb24gY2FwdHVyZSBmdW5jdGlvbiB0aGF0IGF2b2lkcyBwcm9ibGVtYXRpYyBjb2RlIHBhdGhzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFsbCB0aGUgY2FsaWJyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUmVzdWx0IG9iamVjdCB3aXRoIGNhcHR1cmVkIGRhdGFcbiAqL1xuLyoqXG4gKiBTcGVjaWFsIGNhbGlicmF0aW9uIGNhcHR1cmUgZnVuY3Rpb24gdGhhdCBiZWhhdmVzIGxpa2UgcmFuZG9tIGRvdCBjYXB0dXJlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFsbCB0aGUgY2FsaWJyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUmVzdWx0IG9iamVjdCB3aXRoIGNhcHR1cmVkIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGlicmF0aW9uQ2FwdHVyZSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9pbnQsXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIGNhcHR1cmVGb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyxcbiAgICAgIHBvaW50SW5kZXgsXG4gICAgICB0b3RhbFBvaW50c1xuICAgIH0gPSBvcHRpb25zO1xuICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhbGlicmF0aW9uIGNhcHR1cmUgZm9yIHBvaW50ICR7cG9pbnRJbmRleCArIDF9LyR7dG90YWxQb2ludHN9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXNcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbCBpbiBjYWxpYnJhdGlvbkNhcHR1cmVcIik7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6IENhbnZhcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gVXNlIHRoZSBleGFjdCBzYW1lIGRyYXdpbmcgbWV0aG9kIGFzIHJhbmRvbSBkb3RzXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYENhbGlicmF0aW9uIHBvaW50ICR7cG9pbnRJbmRleCArIDF9LyR7dG90YWxQb2ludHN9YCk7XG4gIFxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGNvdW50ZG93biBlbGVtZW50IGNyZWF0aW9uIG1ldGhvZFxuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvaW50LCBjYW52YXNSZWN0KTtcbiAgICAgIFxuICAgICAgaWYgKCFjb3VudGRvd25FbGVtZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNvdW50ZG93biBlbGVtZW50XCIpO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgICAgfVxuICBcbiAgICAgIC8vIENyZWF0ZSBhIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIHRoZSBkb3QgdmlzaWJsZVxuICAgICAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgMTIsIGZhbHNlKTtcbiAgICAgIH0sIDIwMCk7XG4gIFxuICAgICAgLy8gUnVuIHRoZSBzYW1lIGNvdW50ZG93biBhcyByYW5kb20gZG90XG4gICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgUG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c30gLSBjb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgZG90IGF0IGVhY2ggc3RlcCB0byBlbnN1cmUgaXQgcmVtYWlucyB2aXNpYmxlXG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCAxMiwgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgfVxuICBcbiAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgcmVkcmF3SW50ZXJ2YWxcbiAgICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gIFxuICAgICAgLy8gVXNlIGNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyBpbnN0ZWFkIG9mIGRpcmVjdGx5IGNhbGxpbmcgY2FwdHVyZUltYWdlc0F0UG9pbnRcbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgICBjYW52YXNSZWYsXG4gICAgICAgIHBvc2l0aW9uOiBwb2ludCxcbiAgICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyAmJiB0eXBlb2Ygc3RhdHVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cy5wcm9jZXNzU3RhdHVzIHx8ICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzLnByb2Nlc3NTdGF0dXMgfHwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgfSk7XG4gIFxuICAgICAgLy8gRW5zdXJlIHByb3BlciByZXR1cm4gZXZlbiBpZiBjYXB0dXJlUmVzdWx0IGlzIG51bGxcbiAgICAgIGNvbnN0IHNhZmVSZXN1bHQgPSBjYXB0dXJlUmVzdWx0ICYmIHR5cGVvZiBjYXB0dXJlUmVzdWx0ID09PSAnb2JqZWN0JyBcbiAgICAgICAgPyBjYXB0dXJlUmVzdWx0IFxuICAgICAgICA6IHsgc2NyZWVuSW1hZ2U6ICcnLCB3ZWJjYW1JbWFnZTogJycsIHN1Y2Nlc3M6IGZhbHNlIH07XG4gIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6IHNhZmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiBzYWZlUmVzdWx0LndlYmNhbUltYWdlIHx8ICcnLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBwb2ludFxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FsaWJyYXRpb25DYXB0dXJlOlwiLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBcbiAgICAgIC8vIEFsd2F5cyByZXR1cm4gYSB2YWxpZCBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQ29tcGxldGUgY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFByb2Nlc3Mgb3B0aW9uc1xuICovXG5leHBvcnQgY29uc3QgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgY29uc3Qge1xuICAgIGNhbnZhc1JlZixcbiAgICBwb3NpdGlvbixcbiAgICBjYXB0dXJlQ291bnRlcixcbiAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgIHRvZ2dsZVRvcEJhcixcbiAgICBvblN0YXR1c1VwZGF0ZSxcbiAgICBjYXB0dXJlRm9sZGVyXG4gIH0gPSBvcHRpb25zO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmPy5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW2NhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc10gQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsXCIpO1xuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiBDYW52YXMgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRHJhdyB0aGUgZG90XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuXG4gICAgLy8gQ291bnRkb3duIGJlZm9yZSBjYXB0dXJlXG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdTdGFydGluZyBjb3VudGRvd24uLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLWNvdW50ZG93bic7XG4gICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogJHtjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54fXB4O1xuICAgICAgdG9wOiAke2NhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueSAtIDYwfXB4O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgY29sb3I6IHJlZDtcbiAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNTBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuXG4gICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgZm9yIGtlZXBpbmcgdGhlIGRvdCB2aXNpYmxlXG4gICAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgfSwgMjAwKTtcblxuICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBgQ291bnRkb3duOiAke2NvdW50fWAsXG4gICAgICAgICAgY291bnRkb3duVmFsdWU6IGNvdW50LFxuICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gUmVkcmF3IGRvdCB0byBlbnN1cmUgaXQncyB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgfVxuXG4gICAgLy8gQ2hhbmdlIHRvIGNoZWNrbWFya1xuICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyaW5nIGltYWdlcy4uLicsXG4gICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGFuZCBjbGVhciByZWRyYXdJbnRlcnZhbFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChyZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9LCAzMDApO1xuXG4gICAgLy8gVXNlIGNhcHR1cmVJbWFnZXNBdFBvaW50IGZyb20gc2F2ZWZpbGUuanNcbiAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgIGNhbnZhc1JlZixcbiAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICB9KTtcblxuICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlZCBkb3QgYXQgeD0ke01hdGgucm91bmQocG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChwb3NpdGlvbi55KX1gKTtcbiAgICB9XG5cbiAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0NhcHR1cmUgY29tcGxldGUnLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIHdpdGggZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgIH0sIDI1MDApO1xuXG4gICAgcmV0dXJuIGNhcHR1cmVSZXN1bHQ7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2NhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc10gRmF0YWwgZXJyb3I6XCIsIGVycm9yKTtcbiAgICBcbiAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRmF0YWwgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIFRvcEJhciBpcyBzaG93biBldmVuIG9uIGVycm9yXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICB9LCAxNTAwKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gYSBtaW5pbWFsIHZhbGlkIG9iamVjdCB0byBwcmV2ZW50IG51bGwgcmVmZXJlbmNlIGVycm9yc1xuICAgIHJldHVybiB7XG4gICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTsiXSwibmFtZXMiOlsiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJjcmVhdGVDb3VudGRvd25FbGVtZW50IiwicG9zaXRpb24iLCJjYW52YXNSZWN0IiwieCIsInkiLCJjb25zb2xlIiwid2FybiIsImV4aXN0aW5nQ291bnRkb3ducyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInJlbW92ZSIsImFic29sdXRlWCIsImxlZnQiLCJhYnNvbHV0ZVkiLCJ0b3AiLCJjb3VudGRvd25FbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInNob3dDYXB0dXJlUHJldmlldyIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJwb2ludCIsImV4aXN0aW5nUHJldmlld3MiLCJwcmV2aWV3IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwicHJldmlld0NvbnRhaW5lciIsInNjcmVlblByZXZpZXciLCJzY3JlZW5JbWciLCJzcmMiLCJhbHQiLCJzY3JlZW5MYWJlbCIsInRleHRDb250ZW50Iiwid2ViY2FtUHJldmlldyIsIndlYmNhbUltZyIsIndlYmNhbUxhYmVsIiwicG9pbnRJbmZvIiwibGFiZWwiLCJNYXRoIiwicm91bmQiLCJ0aW1lckVsZW1lbnQiLCJ0aW1lTGVmdCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwib3BhY2l0eSIsInRyYW5zaXRpb24iLCJzZXRUaW1lb3V0IiwidG9GaXhlZCIsInJ1bkNvdW50ZG93biIsImNhbnZhcyIsIm9uU3RhdHVzVXBkYXRlIiwib25Db21wbGV0ZSIsInByb2Nlc3NTdGF0dXMiLCJjb3VudGRvd25WYWx1ZSIsImlzQ2FwdHVyaW5nIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdSZWREb3QiLCJjb3VudCIsInJlZHJhd0ludGVydmFsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjb3VudGRvd25JbnRlcnZhbCIsInJhZGl1cyIsImNsZWFyQ2FudmFzIiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiY2FwdHVyZUltYWdlcyIsIm9wdGlvbnMiLCJjYW52YXNSZWYiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVGb2xkZXIiLCJyZXN1bHQiLCJjYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzdWNjZXNzIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxpYnJhdGlvbkNhcHR1cmUiLCJwb2ludEluZGV4IiwidG90YWxQb2ludHMiLCJsb2ciLCJjdXJyZW50IiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsInN0YXR1cyIsInNhZmVSZXN1bHQiLCJ3aW5kb3ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js\n"));

/***/ })

});