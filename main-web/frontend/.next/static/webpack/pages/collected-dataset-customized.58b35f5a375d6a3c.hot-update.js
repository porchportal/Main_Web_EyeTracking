"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Initialize polling for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    if (!currentUserId) return;\n                    try {\n                        console.log('Polling settings for user:', currentUserId);\n                        const response = await fetch(\"/api/data-center/settings/\".concat(currentUserId), {\n                            headers: {\n                                'Accept': 'application/json',\n                                'Content-Type': 'application/json',\n                                'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                            }\n                        });\n                        if (!response.ok) {\n                            const errorData = await response.json();\n                            throw new Error(errorData.detail || 'Failed to fetch settings');\n                        }\n                        const newSettings = await response.json();\n                        console.log('Fetched settings for user:', currentUserId, newSettings);\n                        // Only update if settings have changed\n                        const currentUserSettings = settings[currentUserId];\n                        if (JSON.stringify(currentUserSettings) !== JSON.stringify(newSettings)) {\n                            setSettings({\n                                \"useAdminSettings.useEffect.fetchSettings\": (prev)=>({\n                                        ...prev,\n                                        [currentUserId]: {\n                                            ...newSettings,\n                                            times: newSettings.times,\n                                            delay: newSettings.delay // Preserve the exact delay value\n                                        }\n                                    })\n                            }[\"useAdminSettings.useEffect.fetchSettings\"]);\n                            // Update topBar through ref\n                            if (ref && ref.current) {\n                                if (ref.current.setCaptureSettings) {\n                                    ref.current.setCaptureSettings(newSettings);\n                                    setIsTopBarUpdated(true);\n                                }\n                            }\n                        }\n                        setError(null);\n                    } catch (error) {\n                        console.error('Error fetching settings:', error);\n                        setError(error.message);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            // Initial fetch\n            fetchSettings();\n            // Set up polling interval\n            pollingInterval.current = setInterval(fetchSettings, 3000);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref,\n        settings\n    ]);\n    // Effect to handle index.js update after topBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                // Dispatch event to update index.js\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n                console.error('Error loading settings from localStorage:', error);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {\n                    console.error('Error saving settings to localStorage:', error);\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        setCurrentUserId(event.detail.userId);\n                        // Trigger immediate settings fetch for new user\n                        const fetchSettings = {\n                            \"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\": async ()=>{\n                                try {\n                                    const response = await fetch(\"/api/data-center/settings/\".concat(event.detail.userId));\n                                    if (!response.ok) throw new Error('Failed to fetch settings');\n                                    const newSettings = await response.json();\n                                    console.log('Fetched settings for new user:', newSettings);\n                                    setSettings({\n                                        \"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\": (prev)=>({\n                                                ...prev,\n                                                [event.detail.userId]: newSettings\n                                            })\n                                    }[\"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\"]);\n                                    if (ref && ref.current && ref.current.setCaptureSettings) {\n                                        ref.current.setCaptureSettings(newSettings);\n                                        setIsTopBarUpdated(true);\n                                    }\n                                } catch (error) {\n                                    console.error('Error fetching settings for new user:', error);\n                                }\n                            }\n                        }[\"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\"];\n                        fetchSettings();\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('Settings context updated for user:', currentUserId, settings[currentUserId]);\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                    // Update UI elements if they exist\n                    const timeInput = document.querySelector('[data-control=\"time\"]');\n                    const delayInput = document.querySelector('[data-control=\"delay\"]');\n                    if (timeInput && typeof userSettings.times === 'number') {\n                        timeInput.value = userSettings.times;\n                    }\n                    if (delayInput && typeof userSettings.delay === 'number') {\n                        delayInput.value = userSettings.delay;\n                    }\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        if (userId === currentUserId) {\n                            console.log('Received settings update:', {\n                                userId,\n                                times,\n                                delay\n                            });\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            // Update UI elements\n                            const timeInput = document.querySelector('[data-control=\"time\"]');\n                            const delayInput = document.querySelector('[data-control=\"delay\"]');\n                            if (timeInput && typeof newSettings.times === 'number') {\n                                timeInput.value = newSettings.times;\n                            }\n                            if (delayInput && typeof newSettings.delay === 'number') {\n                                delayInput.value = newSettings.delay;\n                            }\n                            // Save to backend\n                            const saveToBackend = {\n                                \"useAdminSettings.useEffect.handleSettingsUpdate.saveToBackend\": async ()=>{\n                                    try {\n                                        const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                                            method: 'POST',\n                                            headers: {\n                                                'Content-Type': 'application/json',\n                                                'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                                            },\n                                            body: JSON.stringify(newSettings)\n                                        });\n                                        if (!response.ok) {\n                                            throw new Error('Failed to save settings to backend');\n                                        }\n                                        console.log('Settings saved to backend:', newSettings);\n                                    } catch (error) {\n                                        console.error('Error saving settings to backend:', error);\n                                    }\n                                }\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate.saveToBackend\"];\n                            saveToBackend();\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    const updateSettings = async (newSettings, userId)=>{\n        var _settings_userId, _settings_userId1;\n        if (!userId) {\n            console.error('No user ID provided for settings update');\n            return;\n        }\n        // Create a clean settings object for this user\n        const updatedSettings = {\n            ...settings[userId],\n            ...newSettings,\n            // Ensure times and delay are preserved exactly as provided\n            times: newSettings.times !== undefined ? newSettings.times : (_settings_userId = settings[userId]) === null || _settings_userId === void 0 ? void 0 : _settings_userId.times,\n            delay: newSettings.delay !== undefined ? newSettings.delay : (_settings_userId1 = settings[userId]) === null || _settings_userId1 === void 0 ? void 0 : _settings_userId1.delay\n        };\n        console.log(\"Updating settings for user \".concat(userId, \":\"), updatedSettings);\n        // Update local state\n        setSettings((prev)=>({\n                ...prev,\n                [userId]: updatedSettings\n            }));\n        // Save to backend using REST API\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify(updatedSettings)\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.detail || 'Failed to save settings');\n            }\n            const savedSettings = await response.json();\n            console.log('Settings saved successfully:', savedSettings);\n            // Update local state with the saved settings\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: savedSettings\n                }));\n        } catch (error) {\n            console.error('Error saving settings:', error);\n            setError(error.message);\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        error\n    };\n};\n_s(useAdminSettings, \"Pa1ccxuHXyKzm3UqydzYSy2ETpE=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFFN0MsTUFBTUcsbUJBQW1CLENBQUNDOztJQUMvQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR0osK0NBQVFBLENBQUMsQ0FBQztJQUMxQyxNQUFNLENBQUNLLGVBQWVDLGlCQUFpQixHQUFHTiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNPLGlCQUFpQkMsbUJBQW1CLEdBQUdSLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ1MsT0FBT0MsU0FBUyxHQUFHViwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNVyxjQUFjWiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNYSxrQkFBa0JiLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ2MsaUJBQWlCQyxtQkFBbUIsR0FBR2QsK0NBQVFBLENBQUMsQ0FBQztJQUV4RCwwQ0FBMEM7SUFDMUNGLGdEQUFTQTtzQ0FBQztZQUNSLE1BQU1pQjs0REFBZ0I7b0JBQ3BCLElBQUksQ0FBQ1YsZUFBZTtvQkFFcEIsSUFBSTt3QkFDRlcsUUFBUUMsR0FBRyxDQUFDLDhCQUE4Qlo7d0JBQzFDLE1BQU1hLFdBQVcsTUFBTUMsTUFBTSw2QkFBMkMsT0FBZGQsZ0JBQWlCOzRCQUN6RWUsU0FBUztnQ0FDUCxVQUFVO2dDQUNWLGdCQUFnQjtnQ0FDaEIsYUFBYUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTs0QkFDbEQ7d0JBQ0Y7d0JBRUEsSUFBSSxDQUFDTCxTQUFTTSxFQUFFLEVBQUU7NEJBQ2hCLE1BQU1DLFlBQVksTUFBTVAsU0FBU1EsSUFBSTs0QkFDckMsTUFBTSxJQUFJQyxNQUFNRixVQUFVRyxNQUFNLElBQUk7d0JBQ3RDO3dCQUVBLE1BQU1DLGNBQWMsTUFBTVgsU0FBU1EsSUFBSTt3QkFDdkNWLFFB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RXJELHFCQUFxQjtRQUNyQmpFLFlBQVk2QixDQUFBQSxPQUFTO2dCQUNuQixHQUFHQSxJQUFJO2dCQUNQLENBQUNXLE9BQU8sRUFBRXlCO1lBQ1o7UUFFQSxpQ0FBaUM7UUFDakMsSUFBSTtZQUNGLE1BQU1uRCxXQUFXLE1BQU1DLE1BQU0sNkJBQW9DLE9BQVB5QixTQUFVO2dCQUNsRXNCLFFBQVE7Z0JBQ1I5QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsYUFBYUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtnQkFDbEQ7Z0JBQ0E0QyxNQUFNcEMsS0FBS0MsU0FBUyxDQUFDcUM7WUFDdkI7WUFFQSxJQUFJLENBQUNuRCxTQUFTTSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVAsU0FBU1EsSUFBSTtnQkFDckMsTUFBTSxJQUFJQyxNQUFNRixVQUFVRyxNQUFNLElBQUk7WUFDdEM7WUFFQSxNQUFNbUIsZ0JBQWdCLE1BQU03QixTQUFTUSxJQUFJO1lBQ3pDVixRQUFRQyxHQUFHLENBQUMsZ0NBQWdDOEI7WUFFNUMsNkNBQTZDO1lBQzdDM0MsWUFBWTZCLENBQUFBLE9BQVM7b0JBQ25CLEdBQUdBLElBQUk7b0JBQ1AsQ0FBQ1csT0FBTyxFQUFFRztnQkFDWjtRQUNGLEVBQUUsT0FBT3RDLE9BQU87WUFDZE8sUUFBUVAsS0FBSyxDQUFDLDBCQUEwQkE7WUFDeENDLFNBQVNELE1BQU02QixPQUFPO1FBQ3hCO0lBQ0Y7SUFFQSxPQUFPO1FBQUVuQztRQUFVaUU7UUFBZ0IzRDtJQUFNO0FBQzNDLEVBQUU7R0ExUldSO0FBNFJiLCtCQUErQjtBQUNoQixTQUFTcUU7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtLQUZ3QkEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FkbWluU2V0dGluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgY29uc3QgdXNlQWRtaW5TZXR0aW5ncyA9IChyZWYpID0+IHtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbaXNUb3BCYXJVcGRhdGVkLCBzZXRJc1RvcEJhclVwZGF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRTZXR0aW5ncywgc2V0Q3VycmVudFNldHRpbmdzXSA9IHVzZVN0YXRlKHt9KTtcblxuICAvLyBJbml0aWFsaXplIHBvbGxpbmcgZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaFNldHRpbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKCFjdXJyZW50VXNlcklkKSByZXR1cm47XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQb2xsaW5nIHNldHRpbmdzIGZvciB1c2VyOicsIGN1cnJlbnRVc2VySWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7Y3VycmVudFVzZXJJZH1gLCB7XG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZmV0Y2ggc2V0dGluZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHNldHRpbmdzIGZvciB1c2VyOicsIGN1cnJlbnRVc2VySWQsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHNldHRpbmdzIGhhdmUgY2hhbmdlZFxuICAgICAgICBjb25zdCBjdXJyZW50VXNlclNldHRpbmdzID0gc2V0dGluZ3NbY3VycmVudFVzZXJJZF07XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShjdXJyZW50VXNlclNldHRpbmdzKSAhPT0gSlNPTi5zdHJpbmdpZnkobmV3U2V0dGluZ3MpKSB7XG4gICAgICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgIFtjdXJyZW50VXNlcklkXToge1xuICAgICAgICAgICAgICAuLi5uZXdTZXR0aW5ncywgIC8vIFVzZSB0aGUgZXhhY3Qgc2V0dGluZ3MgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgIHRpbWVzOiBuZXdTZXR0aW5ncy50aW1lcywgIC8vIFByZXNlcnZlIHRoZSBleGFjdCB0aW1lcyB2YWx1ZVxuICAgICAgICAgICAgICBkZWxheTogbmV3U2V0dGluZ3MuZGVsYXkgICAvLyBQcmVzZXJ2ZSB0aGUgZXhhY3QgZGVsYXkgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHRvcEJhciB0aHJvdWdoIHJlZlxuICAgICAgICAgIGlmIChyZWYgJiYgcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChyZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgcmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbml0aWFsIGZldGNoXG4gICAgZmV0Y2hTZXR0aW5ncygpO1xuXG4gICAgLy8gU2V0IHVwIHBvbGxpbmcgaW50ZXJ2YWxcbiAgICBwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCA9IHNldEludGVydmFsKGZldGNoU2V0dGluZ3MsIDMwMDApO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZCwgcmVmLCBzZXR0aW5nc10pO1xuXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgaW5kZXguanMgdXBkYXRlIGFmdGVyIHRvcEJhciBpcyB1cGRhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzVG9wQmFyVXBkYXRlZCkge1xuICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQgdG8gdXBkYXRlIGluZGV4LmpzXG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2V0dGluZ3NVcGRhdGVkJywge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICB0eXBlOiAnc2V0dGluZ3MnLFxuICAgICAgICAgIHVzZXJJZDogY3VycmVudFVzZXJJZCxcbiAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3NbY3VycmVudFVzZXJJZF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICBzZXRJc1RvcEJhclVwZGF0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2lzVG9wQmFyVXBkYXRlZCwgY3VycmVudFVzZXJJZCwgc2V0dGluZ3NdKTtcblxuICAvLyBMb2FkIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5TZXR0aW5ncycpO1xuICAgICAgaWYgKHNhdmVkU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkU2V0dGluZ3MgPSBKU09OLnBhcnNlKHNhdmVkU2V0dGluZ3MpO1xuICAgICAgICBzZXRTZXR0aW5ncyhwYXJzZWRTZXR0aW5ncyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlIHdoZW4gdGhleSBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FkbWluU2V0dGluZ3MnLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudXNlcklkKSB7XG4gICAgICAgIHNldEN1cnJlbnRVc2VySWQoZXZlbnQuZGV0YWlsLnVzZXJJZCk7XG4gICAgICAgIC8vIFRyaWdnZXIgaW1tZWRpYXRlIHNldHRpbmdzIGZldGNoIGZvciBuZXcgdXNlclxuICAgICAgICBjb25zdCBmZXRjaFNldHRpbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7ZXZlbnQuZGV0YWlsLnVzZXJJZH1gKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHNldHRpbmdzJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZldGNoZWQgc2V0dGluZ3MgZm9yIG5ldyB1c2VyOicsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHtcbiAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgW2V2ZW50LmRldGFpbC51c2VySWRdOiBuZXdTZXR0aW5nc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVmICYmIHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncykge1xuICAgICAgICAgICAgICByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgICAgICAgICBzZXRJc1RvcEJhclVwZGF0ZWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNldHRpbmdzIGZvciBuZXcgdXNlcjonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmZXRjaFNldHRpbmdzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbcmVmXSk7XG5cbiAgLy8gVXBkYXRlIHNldHRpbmdzIHdoZW4gdGhleSBjaGFuZ2UgaW4gdGhlIGNvbnRleHRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2V0dGluZ3MgJiYgY3VycmVudFVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIGNvbnRleHQgdXBkYXRlZCBmb3IgdXNlcjonLCBjdXJyZW50VXNlcklkLCBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSk7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGlmICh1c2VyU2V0dGluZ3MpIHtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgVUkgZWxlbWVudHMgaWYgdGhleSBleGlzdFxuICAgICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGltZUlucHV0ICYmIHR5cGVvZiB1c2VyU2V0dGluZ3MudGltZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGltZUlucHV0LnZhbHVlID0gdXNlclNldHRpbmdzLnRpbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWxheUlucHV0ICYmIHR5cGVvZiB1c2VyU2V0dGluZ3MuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGVsYXlJbnB1dC52YWx1ZSA9IHVzZXJTZXR0aW5ncy5kZWxheTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzIGZyb20gYWRtaW4gcGFnZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAnY2FwdHVyZVNldHRpbmdzJykge1xuICAgICAgICBjb25zdCB7IHVzZXJJZCwgdGltZXMsIGRlbGF5IH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGlmICh1c2VySWQgPT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgc2V0dGluZ3MgdXBkYXRlOicsIHsgdXNlcklkLCB0aW1lcywgZGVsYXkgfSk7XG4gICAgICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAuLi5jdXJyZW50U2V0dGluZ3MsXG4gICAgICAgICAgICB0aW1lczogdGltZXMgIT09IHVuZGVmaW5lZCA/IE51bWJlcih0aW1lcykgOiBjdXJyZW50U2V0dGluZ3MudGltZXMsXG4gICAgICAgICAgICBkZWxheTogZGVsYXkgIT09IHVuZGVmaW5lZCA/IE51bWJlcihkZWxheSkgOiBjdXJyZW50U2V0dGluZ3MuZGVsYXlcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIHNldEN1cnJlbnRTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIFVJIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICAgICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRpbWVJbnB1dCAmJiB0eXBlb2YgbmV3U2V0dGluZ3MudGltZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aW1lSW5wdXQudmFsdWUgPSBuZXdTZXR0aW5ncy50aW1lcztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlbGF5SW5wdXQgJiYgdHlwZW9mIG5ld1NldHRpbmdzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGVsYXlJbnB1dC52YWx1ZSA9IG5ld1NldHRpbmdzLmRlbGF5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIHRvIGJhY2tlbmRcbiAgICAgICAgICBjb25zdCBzYXZlVG9CYWNrZW5kID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShuZXdTZXR0aW5ncylcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgc2V0dGluZ3MgdG8gYmFja2VuZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTZXR0aW5ncyBzYXZlZCB0byBiYWNrZW5kOicsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5ncyB0byBiYWNrZW5kOicsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHNhdmVUb0JhY2tlbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkLCBjdXJyZW50U2V0dGluZ3NdKTtcblxuICBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IGFzeW5jIChuZXdTZXR0aW5ncywgdXNlcklkKSA9PiB7XG4gICAgaWYgKCF1c2VySWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIHVzZXIgSUQgcHJvdmlkZWQgZm9yIHNldHRpbmdzIHVwZGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIGNsZWFuIHNldHRpbmdzIG9iamVjdCBmb3IgdGhpcyB1c2VyXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3NbdXNlcklkXSxcbiAgICAgIC4uLm5ld1NldHRpbmdzLFxuICAgICAgLy8gRW5zdXJlIHRpbWVzIGFuZCBkZWxheSBhcmUgcHJlc2VydmVkIGV4YWN0bHkgYXMgcHJvdmlkZWRcbiAgICAgIHRpbWVzOiBuZXdTZXR0aW5ncy50aW1lcyAhPT0gdW5kZWZpbmVkID8gbmV3U2V0dGluZ3MudGltZXMgOiBzZXR0aW5nc1t1c2VySWRdPy50aW1lcyxcbiAgICAgIGRlbGF5OiBuZXdTZXR0aW5ncy5kZWxheSAhPT0gdW5kZWZpbmVkID8gbmV3U2V0dGluZ3MuZGVsYXkgOiBzZXR0aW5nc1t1c2VySWRdPy5kZWxheVxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgc2V0dGluZ3MgZm9yIHVzZXIgJHt1c2VySWR9OmAsIHVwZGF0ZWRTZXR0aW5ncyk7XG5cbiAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGVcbiAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW3VzZXJJZF06IHVwZGF0ZWRTZXR0aW5nc1xuICAgIH0pKTtcblxuICAgIC8vIFNhdmUgdG8gYmFja2VuZCB1c2luZyBSRVNUIEFQSVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRTZXR0aW5ncylcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBzYXZlIHNldHRpbmdzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQgc3VjY2Vzc2Z1bGx5OicsIHNhdmVkU2V0dGluZ3MpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGUgd2l0aCB0aGUgc2F2ZWQgc2V0dGluZ3NcbiAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW3VzZXJJZF06IHNhdmVkU2V0dGluZ3NcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MsIGVycm9yIH07XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBZG1pblNldHRpbmdzKCkge1xuICByZXR1cm4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VBZG1pblNldHRpbmdzIiwicmVmIiwic2V0dGluZ3MiLCJzZXRTZXR0aW5ncyIsImN1cnJlbnRVc2VySWQiLCJzZXRDdXJyZW50VXNlcklkIiwiaXNUb3BCYXJVcGRhdGVkIiwic2V0SXNUb3BCYXJVcGRhdGVkIiwiZXJyb3IiLCJzZXRFcnJvciIsImluaXRpYWxpemVkIiwicG9sbGluZ0ludGVydmFsIiwiY3VycmVudFNldHRpbmdzIiwic2V0Q3VycmVudFNldHRpbmdzIiwiZmV0Y2hTZXR0aW5ncyIsImNvbnNvbGUiLCJsb2ciLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfS0VZIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiRXJyb3IiLCJkZXRhaWwiLCJuZXdTZXR0aW5ncyIsImN1cnJlbnRVc2VyU2V0dGluZ3MiLCJKU09OIiwic3RyaW5naWZ5IiwicHJldiIsInRpbWVzIiwiZGVsYXkiLCJjdXJyZW50Iiwic2V0Q2FwdHVyZVNldHRpbmdzIiwibWVzc2FnZSIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImV2ZW50IiwiQ3VzdG9tRXZlbnQiLCJ0eXBlIiwidXNlcklkIiwid2luZG93IiwiZGlzcGF0Y2hFdmVudCIsInNhdmVkU2V0dGluZ3MiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicGFyc2VkU2V0dGluZ3MiLCJwYXJzZSIsInNldEl0ZW0iLCJoYW5kbGVVc2VySWRDaGFuZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZXJTZXR0aW5ncyIsInRpbWVJbnB1dCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImRlbGF5SW5wdXQiLCJ2YWx1ZSIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidW5kZWZpbmVkIiwiTnVtYmVyIiwic2F2ZVRvQmFja2VuZCIsIm1ldGhvZCIsImJvZHkiLCJ1cGRhdGVTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsIkFkbWluU2V0dGluZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});