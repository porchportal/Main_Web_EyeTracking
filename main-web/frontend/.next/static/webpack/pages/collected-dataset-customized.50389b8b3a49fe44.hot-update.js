"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Memoize button configurations\n    const buttons = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[buttons]\": ()=>[\n                {\n                    text: \"Set Random\",\n                    abbreviatedText: \"SRandom\",\n                    onClick: handleSetRandom,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"Random Dot\",\n                    abbreviatedText: \"Random\",\n                    onClick: handleRandomDot,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"Set Calibrate\",\n                    abbreviatedText: \"Calibrate\",\n                    onClick: handleSetCalibrate,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"Clear All\",\n                    abbreviatedText: \"Clear\",\n                    onClick: handleClearAll\n                },\n                {\n                    divider: true\n                },\n                {\n                    text: \"Draw Head pose\",\n                    abbreviatedText: \"Head pose\",\n                    onClick: handleToggleHeadPose,\n                    active: showHeadPose\n                },\n                {\n                    text: \"Show Bounding Box\",\n                    abbreviatedText: \"☐ Box\",\n                    onClick: handleToggleBoundingBox,\n                    active: showBoundingBox\n                },\n                {\n                    text: isCameraActive ? \"Stop Camera\" : \"Show Preview\",\n                    abbreviatedText: isCameraActive ? \"Stop\" : \"Preview\",\n                    onClick: {\n                        \"ActionButtonGroupInner.useMemo[buttons]\": ()=>{\n                            if (!isCameraActive && !triggerCameraAccess(true)) {\n                                setShowPermissionPopup(true);\n                            } else {\n                                handleToggleCamera();\n                            }\n                        }\n                    }[\"ActionButtonGroupInner.useMemo[buttons]\"],\n                    active: isCameraActive,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"😷 Show Mask\",\n                    abbreviatedText: \"😷 Mask\",\n                    onClick: handleToggleMask,\n                    active: showMask\n                },\n                {\n                    text: \"Parameters\",\n                    abbreviatedText: \"Values\",\n                    onClick: handleToggleParameters,\n                    active: showParameters\n                }\n            ]\n    }[\"ActionButtonGroupInner.useMemo[buttons]\"], [\n        isCapturing,\n        showHeadPose,\n        showBoundingBox,\n        isCameraActive,\n        showMask,\n        showParameters\n    ]);\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    const initializeCanvas = (canvas, parent)=>{\n        if (!canvas || !parent) {\n            // console.warn('[initializeCanvas] Canvas or parent is null', { canvas, parent });\n            return false;\n        }\n        try {\n            // Set canvas dimensions to match parent\n            canvas.width = parent.clientWidth || 800;\n            canvas.height = parent.clientHeight || 600;\n            // Clear canvas and set white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // console.log(`Canvas initialized with dimensions: ${canvas.width}x${canvas.height}`);\n            return true;\n        } catch (error) {\n            console.error('[initializeCanvas] Error initializing canvas:', error);\n            return false;\n        }\n    };\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas = ()=>{\n        // Try multiple methods to find the canvas\n        if (canvasRef.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef.current;\n        }\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef.current = window.whiteScreenCanvas;\n            return window.whiteScreenCanvas;\n        }\n        if (typeof document !== 'undefined') {\n            // Try multiple selectors to find the canvas\n            const selectors = [\n                '.tracking-canvas',\n                'canvas',\n                '#tracking-canvas'\n            ];\n            for (const selector of selectors){\n                const canvasElement = document.querySelector(selector);\n                if (canvasElement) {\n                    console.log(\"Found canvas via selector: \".concat(selector));\n                    canvasRef.current = canvasElement;\n                    if (true) {\n                        window.whiteScreenCanvas = canvasElement;\n                    }\n                    return canvasElement;\n                }\n            }\n        }\n        console.error(\"No canvas found through any method\");\n        return null;\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        // First initialize with parent dimensions\n        const parent = canvas.parentElement || document.body;\n        initializeCanvas(canvas, parent);\n        // Then force fullscreen styling\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '5';\n        // Force dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear and prepare canvas again\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas set to fullscreen: \".concat(canvas.width, \"x\").concat(canvas.height));\n    };\n    const restoreCanvasSize = (canvas)=>{\n        // Restore original canvas styling\n        canvas.style.position = '';\n        canvas.style.top = '';\n        canvas.style.left = '';\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n        canvas.style.zIndex = '';\n        // Restore original dimensions\n        if (canvas.parentElement) {\n            initializeCanvas(canvas, canvas.parentElement);\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas, originalParent, originalStyle)=>{\n        if (!canvas || !originalParent) return;\n        // Append the canvas back to its original parent if needed\n        if (canvas.parentElement !== originalParent) {\n            originalParent.appendChild(canvas);\n        }\n        // Restore the inline styles saved earlier\n        canvas.style.position = originalStyle.position;\n        canvas.style.top = originalStyle.top;\n        canvas.style.left = originalStyle.left;\n        canvas.style.width = originalStyle.width;\n        canvas.style.height = originalStyle.height;\n        canvas.style.zIndex = originalStyle.zIndex;\n        // Reset the dimensions based on the parent element's size or fallback defaults\n        canvas.width = originalParent.clientWidth || 800;\n        canvas.height = originalParent.clientHeight || 600;\n        // Clear the canvas and fill with a white background\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ // Modified handleDotProcess function with improved dot and countdown alignment\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get canvas reference with retries\n            let canvas = null;\n            let retryCount = 0;\n            const maxRetries = 3;\n            while(!canvas && retryCount < maxRetries){\n                canvas = getMainCanvas();\n                if (!canvas) {\n                    console.warn(\"Canvas not found, retry \".concat(retryCount + 1, \"/\").concat(maxRetries));\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    retryCount++;\n                }\n            }\n            if (!canvas) {\n                throw new Error(\"Canvas not available after multiple retries\");\n            }\n            // Save original state for restoration\n            const originalParent = canvas.parentElement;\n            const originalStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Prepare canvas for fullscreen display\n            document.body.appendChild(canvas);\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            // Clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            let keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            // Important: Position the countdown centered directly over the dot\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Clear redraw interval\n            clearInterval(keepDotVisibleInterval);\n            // Restore canvas to original state\n            if (originalParent && canvas.parentElement !== originalParent) {\n                originalParent.appendChild(canvas);\n            }\n            canvas.style.position = originalStyle.position || '';\n            canvas.style.top = originalStyle.top || '';\n            canvas.style.left = originalStyle.left || '';\n            canvas.style.width = originalStyle.width || '100%';\n            canvas.style.height = originalStyle.height || '100%';\n            canvas.style.zIndex = originalStyle.zIndex || '';\n            // Reset dimensions\n            if (originalParent) {\n                canvas.width = originalParent.clientWidth || 800;\n                canvas.height = originalParent.clientHeight || 600;\n            }\n            // Clear canvas\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2000);\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            // Show TopBar again if there's an error\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"✓\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            // Restore canvas to original parent and styling - Only if canvas was successfully initialized\n            if (canvas) {\n                try {\n                    // Try to find original parent\n                    if (originalCanvasParent && canvas.parentElement !== originalCanvasParent) {\n                        originalCanvasParent.appendChild(canvas);\n                    } else if (!originalCanvasParent) {\n                        // Fallback to looking for a container element\n                        const possibleParent = document.querySelector('.canvas-container');\n                        if (possibleParent && canvas.parentElement !== possibleParent) {\n                            possibleParent.appendChild(canvas);\n                        }\n                    }\n                    // Restore styling\n                    canvas.style.position = originalCanvasStyle.position || '';\n                    canvas.style.top = originalCanvasStyle.top || '';\n                    canvas.style.left = originalCanvasStyle.left || '';\n                    canvas.style.width = originalCanvasStyle.width || '100%';\n                    canvas.style.height = originalCanvasStyle.height || '100%';\n                    canvas.style.zIndex = originalCanvasStyle.zIndex || '';\n                    // Reset dimensions based on parent\n                    const parent = canvas.parentElement;\n                    if (parent) {\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                    } else {\n                        canvas.width = 800;\n                        canvas.height = 600;\n                    }\n                    // Clear canvas with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas restored to original state\");\n                } catch (e) {\n                    console.error(\"Error restoring canvas:\", e);\n                }\n            }\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        // Use the consolidated function with random position\n        await handleDotProcess({\n            useRandomPosition: true,\n            onStatusUpdate: (status)=>{\n                if (status.processStatus) setProcessStatus(status.processStatus);\n                if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n            },\n            toggleTopBar: (show)=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', show);\n                }\n            },\n            triggerCameraAccess,\n            setIsCapturing,\n            captureCount,\n            setCaptureCount: setCaptureCount,\n            postCountdownDelay: 1000\n        });\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        clearCanvas();\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1421,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1420,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1425,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1424,\n                columnNumber: 9\n            }, undefined),\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"ActionButtonGroupInner.useMemo\": ()=>(processStatus || remainingCaptures > 0 || countdownValue) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"status-display mt-4 p-2 bg-blue-50 rounded-md\",\n                        children: [\n                            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-blue-800\",\n                                children: processStatus\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1434,\n                                columnNumber: 15\n                            }, undefined),\n                            remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-yellow-600\",\n                                children: [\n                                    \"Remaining: \",\n                                    remainingCaptures\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1437,\n                                columnNumber: 15\n                            }, undefined),\n                            countdownValue && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-2xl font-bold text-red-600\",\n                                children: countdownValue\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1440,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1432,\n                        columnNumber: 11\n                    }, undefined)\n            }[\"ActionButtonGroupInner.useMemo\"], [\n                processStatus,\n                remainingCaptures,\n                countdownValue\n            ]),\n            showCanvas && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"canvas-container mt-4\",\n                style: {\n                    position: 'relative',\n                    width: '100%',\n                    height: '40vh',\n                    minHeight: '300px',\n                    border: '1px solid #e0e0e0',\n                    backgroundColor: 'white',\n                    borderRadius: '4px',\n                    overflow: 'hidden'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                        ref: (canvas)=>{\n                            if (canvas) {\n                                canvasRef.current = canvas;\n                                if (true) {\n                                    window.whiteScreenCanvas = canvas;\n                                }\n                                // Initialize canvas dimensions\n                                const parent = canvas.parentElement;\n                                if (parent) {\n                                    canvas.width = parent.clientWidth || 800;\n                                    canvas.height = parent.clientHeight || 600;\n                                    // Initialize with white background\n                                    const ctx = canvas.getContext('2d');\n                                    ctx.fillStyle = 'white';\n                                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                }\n                            }\n                        },\n                        className: \"tracking-canvas\",\n                        style: {\n                            width: '100%',\n                            height: '100%',\n                            display: 'block'\n                        }\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1461,\n                        columnNumber: 11\n                    }, undefined),\n                    countdownValue && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"dot-countdown\",\n                        style: {\n                            position: 'absolute',\n                            left: \"\".concat(currentDot.x - 15, \"px\"),\n                            top: \"\".concat(currentDot.y - 40, \"px\"),\n                            color: 'red',\n                            fontSize: '28px',\n                            fontWeight: 'bold'\n                        },\n                        children: countdownValue\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1491,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1448,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1535,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1545,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1563,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1576,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1555,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1525,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1510,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1418,\n        columnNumber: 5\n    }, undefined);\n}, \"Ns1C2Zu4YEn8CGqdNt7gJxrbOrQ=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1598,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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O0FBQzdFO01BRndCQTtBQUltQiIsInNvdXJjZXMiOlsiL2FwcC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FjdGlvbkJ1dHRvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBcbiAgc2hvd0NhcHR1cmVQcmV2aWV3LCBcbiAgZHJhd1JlZERvdCwgXG4gIGdldFJhbmRvbVBvc2l0aW9uLFxuICBjcmVhdGVDb3VudGRvd25FbGVtZW50LFxuICBydW5Db3VudGRvd25cbn0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCB7IHVzZUFkbWluU2V0dGluZ3MgfSBmcm9tICcuL2FkbWluU2V0dGluZ3MnO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuLy8gQ3JlYXRlIGEgYmFzaWMgQWN0aW9uQnV0dG9uIGNvbXBvbmVudCB3aXRoIG9wdGltaXphdGlvblxuY29uc3QgQWN0aW9uQnV0dG9uID0gKHsgdGV4dCwgYWJicmV2aWF0ZWRUZXh0LCBvbkNsaWNrLCBjdXN0b21DbGFzcyA9ICcnLCBkaXNhYmxlZCA9IGZhbHNlLCBhY3RpdmUgPSBmYWxzZSB9KSA9PiB7XG4gIGNvbnN0IFtpc0FiYnJldmlhdGVkLCBzZXRJc0FiYnJldmlhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncygpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIHByb3BzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICBjb25zdCBidXR0b25Qcm9wcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjbGFzc05hbWU6IGBhY3Rpb24tYnV0dG9uICR7Y3VzdG9tQ2xhc3N9ICR7aXNBYmJyZXZpYXRlZCA/ICdhYmJyZXZpYXRlZCcgOiAnJ30gJHthY3RpdmUgPyAnYWN0aXZlJyA6ICcnfWAsXG4gICAgb25DbGljayxcbiAgICBkaXNhYmxlZCxcbiAgICB0aXRsZTogdGV4dFxuICB9KSwgW2N1c3RvbUNsYXNzLCBpc0FiYnJldmlhdGVkLCBhY3RpdmUsIG9uQ2xpY2ssIGRpc2FibGVkLCB0ZXh0XSk7XG5cbiAgLy8gQ2hlY2sgd2luZG93IHNpemUgYW5kIHNldCBhYmJyZXZpYXRlZCBtb2RlIHdpdGggZGVib3VuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHNldElzQWJicmV2aWF0ZWQod2lkdGggPCA3NjgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIGhhbmRsZVJlc2l6ZSgpOyAvLyBJbml0aWFsIGNhbGxcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQWRkIGVmZmVjdCB0byBsaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlcyB3aXRoIG9wdGltaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgaWYgKG5ld1VzZXJJZCAhPT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxidXR0b24gey4uLmJ1dHRvblByb3BzfT5cbiAgICAgIHtpc0FiYnJldmlhdGVkID8gYWJicmV2aWF0ZWRUZXh0IDogdGV4dH1cbiAgICAgIHtwcm9jZXNzU3RhdHVzICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9jZXNzLXN0YXR1c1wiPlxuICAgICAgICAgIHtwcm9jZXNzU3RhdHVzfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIEFjdGlvbkJ1dHRvbkdyb3VwIGNvbXBvbmVudCB3aXRoIGNsaWVudC1zaWRlIG9ubHkgcmVuZGVyaW5nIGFuZCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgPSBmb3J3YXJkUmVmKCh7IHRyaWdnZXJDYW1lcmFBY2Nlc3MsIGlzQ29tcGFjdE1vZGUsIG9uQWN0aW9uQ2xpY2sgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncyhyZWYpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGJ1dHRvbiBhY3Rpb25zXG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtjb3VudGRvd25WYWx1ZSwgc2V0Q291bnRkb3duVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50RG90LCBzZXRDdXJyZW50RG90XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FsaWJyYXRpb25Qb2ludHMsIHNldENhbGlicmF0aW9uUG9pbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW2N1cnJlbnRDYWxpYnJhdGlvbkluZGV4LCBzZXRDdXJyZW50Q2FsaWJyYXRpb25JbmRleF0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3JlbWFpbmluZ0NhcHR1cmVzLCBzZXRSZW1haW5pbmdDYXB0dXJlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Nob3dDYW52YXMsIHNldFNob3dDYW52YXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIFxuICAvLyBUcmFjayB0aGUgY2FwdHVyZSBjb3VudFxuICBjb25zdCBbY2FsaWJyYXRpb25IYW5kbGVyLCBzZXRDYWxpYnJhdGlvbkhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnQsIHNldENhcHR1cmVDb3VudF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBUb2dnbGUgc3RhdGVzXG4gIGNvbnN0IFtzaG93SGVhZFBvc2UsIHNldFNob3dIZWFkUG9zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93Qm91bmRpbmdCb3gsIHNldFNob3dCb3VuZGluZ0JveF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TWFzaywgc2V0U2hvd01hc2tdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1BhcmFtZXRlcnMsIHNldFNob3dQYXJhbWV0ZXJzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ2FtZXJhQWN0aXZlLCBzZXRJc0NhbWVyYUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGVybWlzc2lvblBvcHVwLCBzZXRTaG93UGVybWlzc2lvblBvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcblxuICAvLyBBZGQgY2FjaGUgZm9yIHNldHRpbmdzXG4gIGNvbnN0IHNldHRpbmdzQ2FjaGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgbGFzdFNldHRpbmdzVXBkYXRlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG5cbiAgLy8gTWVtb2l6ZSBidXR0b24gY29uZmlndXJhdGlvbnNcbiAgY29uc3QgYnV0dG9ucyA9IHVzZU1lbW8oKCkgPT4gW1xuICAgIHsgXG4gICAgICB0ZXh0OiBcIlNldCBSYW5kb21cIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiU1JhbmRvbVwiLCBcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZVNldFJhbmRvbSxcbiAgICAgIGRpc2FibGVkOiBpc0NhcHR1cmluZ1xuICAgIH0sXG4gICAgeyBcbiAgICAgIHRleHQ6IFwiUmFuZG9tIERvdFwiLCBcbiAgICAgIGFiYnJldmlhdGVkVGV4dDogXCJSYW5kb21cIiwgXG4gICAgICBvbkNsaWNrOiBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmcgXG4gICAgfSxcbiAgICB7IFxuICAgICAgdGV4dDogXCJTZXQgQ2FsaWJyYXRlXCIsIFxuICAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIkNhbGlicmF0ZVwiLCBcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZVNldENhbGlicmF0ZSxcbiAgICAgIGRpc2FibGVkOiBpc0NhcHR1cmluZyBcbiAgICB9LFxuICAgIHsgXG4gICAgICB0ZXh0OiBcIkNsZWFyIEFsbFwiLCBcbiAgICAgIGFiYnJldmlhdGVkVGV4dDogXCJDbGVhclwiLCBcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZUNsZWFyQWxsXG4gICAgfSxcbiAgICB7IGRpdmlkZXI6IHRydWUgfSxcbiAgICB7IFxuICAgICAgdGV4dDogXCJEcmF3IEhlYWQgcG9zZVwiLCBcbiAgICAgIGFiYnJldmlhdGVkVGV4dDogXCJIZWFkIHBvc2VcIiwgXG4gICAgICBvbkNsaWNrOiBoYW5kbGVUb2dnbGVIZWFkUG9zZSxcbiAgICAgIGFjdGl2ZTogc2hvd0hlYWRQb3NlXG4gICAgfSxcbiAgICB7IFxuICAgICAgdGV4dDogXCJTaG93IEJvdW5kaW5nIEJveFwiLCBcbiAgICAgIGFiYnJldmlhdGVkVGV4dDogXCLimJAgQm94XCIsIFxuICAgICAgb25DbGljazogaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3gsXG4gICAgICBhY3RpdmU6IHNob3dCb3VuZGluZ0JveFxuICAgIH0sXG4gICAgeyBcbiAgICAgIHRleHQ6IGlzQ2FtZXJhQWN0aXZlID8gXCJTdG9wIENhbWVyYVwiIDogXCJTaG93IFByZXZpZXdcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IGlzQ2FtZXJhQWN0aXZlID8gXCJTdG9wXCIgOiBcIlByZXZpZXdcIiwgXG4gICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgIGlmICghaXNDYW1lcmFBY3RpdmUgJiYgIXRyaWdnZXJDYW1lcmFBY2Nlc3ModHJ1ZSkpIHtcbiAgICAgICAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZVRvZ2dsZUNhbWVyYSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWN0aXZlOiBpc0NhbWVyYUFjdGl2ZSxcbiAgICAgIGRpc2FibGVkOiBpc0NhcHR1cmluZ1xuICAgIH0sXG4gICAgeyBcbiAgICAgIHRleHQ6IFwi8J+YtyBTaG93IE1hc2tcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwi8J+YtyBNYXNrXCIsIFxuICAgICAgb25DbGljazogaGFuZGxlVG9nZ2xlTWFzayxcbiAgICAgIGFjdGl2ZTogc2hvd01hc2tcbiAgICB9LFxuICAgIHsgXG4gICAgICB0ZXh0OiBcIlBhcmFtZXRlcnNcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiVmFsdWVzXCIsIFxuICAgICAgb25DbGljazogaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyxcbiAgICAgIGFjdGl2ZTogc2hvd1BhcmFtZXRlcnNcbiAgICB9XG4gIF0sIFtpc0NhcHR1cmluZywgc2hvd0hlYWRQb3NlLCBzaG93Qm91bmRpbmdCb3gsIGlzQ2FtZXJhQWN0aXZlLCBzaG93TWFzaywgc2hvd1BhcmFtZXRlcnNdKTtcblxuICAvLyBPcHRpbWl6ZSBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNldHRpbmdzICYmIGN1cnJlbnRVc2VySWQgJiYgc2V0dGluZ3NbY3VycmVudFVzZXJJZF0pIHtcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdO1xuICAgICAgY29uc3QgY2FjaGVkU2V0dGluZ3MgPSBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuZ2V0KGN1cnJlbnRVc2VySWQpO1xuICAgICAgXG4gICAgICBpZiAoIWlzRXF1YWwoY2FjaGVkU2V0dGluZ3MsIHVzZXJTZXR0aW5ncykpIHtcbiAgICAgICAgc2V0UmFuZG9tVGltZXMoTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCAxKTtcbiAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIHNldHRpbmdzQ2FjaGUuY3VycmVudC5zZXQoY3VycmVudFVzZXJJZCwgdXNlclNldHRpbmdzKTtcbiAgICAgICAgbGFzdFNldHRpbmdzVXBkYXRlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgLy8gVXBkYXRlIHNldHRpbmdzIGZvciBuZXcgdXNlclxuICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3NbbmV3VXNlcklkXSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW25ld1VzZXJJZF07XG4gICAgICAgICAgc2V0UmFuZG9tVGltZXMoTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCAxKTtcbiAgICAgICAgICBzZXREZWxheVNlY29uZHMoTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheV9zZXRfcmFuZG9tKSB8fCAzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtzZXR0aW5nc10pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAnY2FwdHVyZVNldHRpbmdzJykge1xuICAgICAgICBjb25zdCB7IHVzZXJJZCwgdGltZXNfc2V0X3JhbmRvbSwgZGVsYXlfc2V0X3JhbmRvbSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAodXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgaWYgKHRpbWVzX3NldF9yYW5kb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3VGltZXMgPSBOdW1iZXIodGltZXNfc2V0X3JhbmRvbSkgfHwgMTtcbiAgICAgICAgICAgIHNldFJhbmRvbVRpbWVzKG5ld1RpbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlbGF5X3NldF9yYW5kb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3RGVsYXkgPSBOdW1iZXIoZGVsYXlfc2V0X3JhbmRvbSkgfHwgMztcbiAgICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhuZXdEZWxheSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBnbG9iYWxseSBhY2Nlc3NpYmxlIGFzIGEgZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMgPSB7XG4gICAgICAgIGhhbmRsZVJhbmRvbURvdCxcbiAgICAgICAgaGFuZGxlU2V0UmFuZG9tLFxuICAgICAgICBoYW5kbGVTZXRDYWxpYnJhdGUsXG4gICAgICAgIGhhbmRsZUNsZWFyQWxsXG4gICAgICB9O1xuICAgICAgLy8gY29uc29sZS5sb2coJ0FjdGlvbiBidXR0b24gZnVuY3Rpb25zIGV4cG9zZWQgdG8gd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucycpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gZ2V0IGNvbnRyb2wgdmFsdWVzIGZyb20gVG9wQmFyXG4gICAgY29uc3QgdXBkYXRlQ29udHJvbFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIC8vIEdldCB0aGUgdGltZSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IHBhcnNlSW50KHRpbWVJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHRpbWVWYWx1ZSkgJiYgdGltZVZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyByYW5kb21UaW1lcyB0bzonLCB0aW1lVmFsdWUpO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKHRpbWVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBkZWxheSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRlbGF5VmFsdWUgPSBwYXJzZUludChkZWxheUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4oZGVsYXlWYWx1ZSkgJiYgZGVsYXlWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgZGVsYXlTZWNvbmRzIHRvOicsIGRlbGF5VmFsdWUpO1xuICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhkZWxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgY29udHJvbCBpbnB1dHNcbiAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgXG4gICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgdGltZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgdGltZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7IC8vIEFsc28gbGlzdGVuIGZvciBpbnB1dCBldmVudHNcbiAgICB9XG4gICAgXG4gICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgIGRlbGF5SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7IC8vIEFsc28gbGlzdGVuIGZvciBpbnB1dCBldmVudHNcbiAgICB9XG4gICAgXG4gICAgLy8gSW5pdGlhbCB1cGRhdGVcbiAgICB1cGRhdGVDb250cm9sVmFsdWVzKCk7XG4gICAgXG4gICAgLy8gQ2xlYW51cCBldmVudCBsaXN0ZW5lcnNcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICAgIHRpbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBkZWxheUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICBkZWxheUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGluaXRpYWxpemVDYW52YXMgPSAoY2FudmFzLCBwYXJlbnQpID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhcGFyZW50KSB7XG4gICAgICAvLyBjb25zb2xlLndhcm4oJ1tpbml0aWFsaXplQ2FudmFzXSBDYW52YXMgb3IgcGFyZW50IGlzIG51bGwnLCB7IGNhbnZhcywgcGFyZW50IH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHBhcmVudFxuICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzIGFuZCBzZXQgd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBjb25zb2xlLmxvZyhgQ2FudmFzIGluaXRpYWxpemVkIHdpdGggZGltZW5zaW9uczogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbaW5pdGlhbGl6ZUNhbnZhc10gRXJyb3IgaW5pdGlhbGl6aW5nIGNhbnZhczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIG1haW4gY2FudmFzIC0gaW1wcm92ZWQgdG8gYmUgbW9yZSByZWxpYWJsZVxuICBjb25zdCBnZXRNYWluQ2FudmFzID0gKCkgPT4ge1xuICAgIC8vIFRyeSBtdWx0aXBsZSBtZXRob2RzIHRvIGZpbmQgdGhlIGNhbnZhc1xuICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBkaXJlY3QgY2FudmFzUmVmLmN1cnJlbnQgcmVmZXJlbmNlXCIpO1xuICAgICAgcmV0dXJuIGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGdsb2JhbCB3aGl0ZVNjcmVlbkNhbnZhcyByZWZlcmVuY2VcIik7XG4gICAgICBjYW52YXNSZWYuY3VycmVudCA9IHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICAgIHJldHVybiB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFRyeSBtdWx0aXBsZSBzZWxlY3RvcnMgdG8gZmluZCB0aGUgY2FudmFzXG4gICAgICBjb25zdCBzZWxlY3RvcnMgPSBbJy50cmFja2luZy1jYW52YXMnLCAnY2FudmFzJywgJyN0cmFja2luZy1jYW52YXMnXTtcbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2Ygc2VsZWN0b3JzKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKGNhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgY2FudmFzIHZpYSBzZWxlY3RvcjogJHtzZWxlY3Rvcn1gKTtcbiAgICAgICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXNFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FudmFzRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmVycm9yKFwiTm8gY2FudmFzIGZvdW5kIHRocm91Z2ggYW55IG1ldGhvZFwiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgbWFrZUNhbnZhc0Z1bGxzY3JlZW4gPSAoY2FudmFzKSA9PiB7XG4gICAgLy8gRmlyc3QgaW5pdGlhbGl6ZSB3aXRoIHBhcmVudCBkaW1lbnNpb25zXG4gICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICBpbml0aWFsaXplQ2FudmFzKGNhbnZhcywgcGFyZW50KTtcbiAgICBcbiAgICAvLyBUaGVuIGZvcmNlIGZ1bGxzY3JlZW4gc3R5bGluZ1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnNSc7XG4gICAgXG4gICAgLy8gRm9yY2UgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3dcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIGFuZCBwcmVwYXJlIGNhbnZhcyBhZ2FpblxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHNldCB0byBmdWxsc2NyZWVuOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICB9O1xuICBjb25zdCByZXN0b3JlQ2FudmFzU2l6ZSA9IChjYW52YXMpID0+IHtcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGNhbnZhcyBzdHlsaW5nXG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICcnO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcnO1xuICAgIFxuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZGltZW5zaW9uc1xuICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCkge1xuICAgICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXMsIGNhbnZhcy5wYXJlbnRFbGVtZW50KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkID0gKCkgPT4ge1xuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICAgIGlmICh0cmlnZ2VyQ2FtZXJhQWNjZXNzKSB7XG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIYW5kbGVyIHRvIGNhbmNlbCBwZXJtaXNzaW9uIHBvcHVwXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25EZW5pZWQgPSAoKSA9PiB7XG4gICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cChmYWxzZSk7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlc3RvcmUgdGhlIGNhbnZhcyB0byBpdHMgb3JpZ2luYWwgcGFyZW50IGFuZCBzdHlsaW5nXG4gIGNvbnN0IHJlc3RvcmVDYW52YXMgPSAoY2FudmFzLCBvcmlnaW5hbFBhcmVudCwgb3JpZ2luYWxTdHlsZSkgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFvcmlnaW5hbFBhcmVudCkgcmV0dXJuO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBjYW52YXMgYmFjayB0byBpdHMgb3JpZ2luYWwgcGFyZW50IGlmIG5lZWRlZFxuICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCAhPT0gb3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgIG9yaWdpbmFsUGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc3RvcmUgdGhlIGlubGluZSBzdHlsZXMgc2F2ZWQgZWFybGllclxuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsU3R5bGUucG9zaXRpb247XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9IG9yaWdpbmFsU3R5bGUudG9wO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gb3JpZ2luYWxTdHlsZS5sZWZ0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9yaWdpbmFsU3R5bGUud2lkdGg7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsU3R5bGUuaGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBvcmlnaW5hbFN0eWxlLnpJbmRleDtcbiAgICBcbiAgICAvLyBSZXNldCB0aGUgZGltZW5zaW9ucyBiYXNlZCBvbiB0aGUgcGFyZW50IGVsZW1lbnQncyBzaXplIG9yIGZhbGxiYWNrIGRlZmF1bHRzXG4gICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcmlnaW5hbFBhcmVudC5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBjYW52YXMgYW5kIGZpbGwgd2l0aCBhIHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH07XG5cblxuICAvLyBDbGVhciB0aGUgY2FudmFzXG4gIGNvbnN0IGNsZWFyQ2FudmFzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gY2FudmFzIGZvdW5kIGZvciBjbGVhcmluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHNldEN1cnJlbnREb3QobnVsbCk7XG4gIH07XG4gIC8vIEFkZCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGlvbkJ1dHRvbi5qc1xuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZWQgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRoZSBlbnRpcmUgZG90IHByb2Nlc3M6IGRyYXdpbmcsIGNvdW50ZG93biwgY2FwdHVyZSwgYW5kIHByZXZpZXdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB7eCwgeX0gY29vcmRpbmF0ZXMgd2hlcmUgdG8gZHJhdyB0aGUgZG90XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdGF0dXNVcGRhdGUgLSBDYWxsYmFjayBmb3Igc3RhdHVzIHVwZGF0ZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50b2dnbGVUb3BCYXIgLSBGdW5jdGlvbiB0byB0b2dnbGUgdG9wIGJhciB2aXNpYmlsaXR5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudHJpZ2dlckNhbWVyYUFjY2VzcyAtIEZ1bmN0aW9uIHRvIGVuc3VyZSBjYW1lcmEgaXMgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2V0SXNDYXB0dXJpbmcgLSBGdW5jdGlvbiB0byB1cGRhdGUgY2FwdHVyaW5nIHN0YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmNhcHR1cmVDb3VudCAtIEN1cnJlbnQgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2V0Q2FwdHVyZUNvdW50IC0gRnVuY3Rpb24gdG8gdXBkYXRlIHRoZSBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnVzZVJhbmRvbVBvc2l0aW9uIC0gV2hldGhlciB0byBnZW5lcmF0ZSBhIHJhbmRvbSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFJlc3VsdCBvYmplY3Qgd2l0aCBjYXB0dXJlIGRhdGFcbiAgICovXG4gIC8vIE1vZGlmaWVkIGhhbmRsZURvdFByb2Nlc3MgZnVuY3Rpb24gd2l0aCBpbXByb3ZlZCBkb3QgYW5kIGNvdW50ZG93biBhbGlnbm1lbnRcbiAgY29uc3QgaGFuZGxlRG90UHJvY2VzcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvblN0YXR1c1VwZGF0ZSxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgIHNldENhcHR1cmVDb3VudCxcbiAgICAgIHVzZVJhbmRvbVBvc2l0aW9uID0gZmFsc2UsXG4gICAgICBwb3N0Q291bnRkb3duRGVsYXkgPSA1MDAgXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyB0aGUgZG90XG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXQgY2FwdHVyaW5nIHN0YXRlXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6IHVzZVJhbmRvbVBvc2l0aW9uID8gJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicgOiAnU3RhcnRpbmcgZG90IHByb2Nlc3MuLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIFVJIHVwZGF0ZXMgdG8gdGFrZSBlZmZlY3RcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhcyByZWZlcmVuY2Ugd2l0aCByZXRyaWVzXG4gICAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgIGNvbnN0IG1heFJldHJpZXMgPSAzO1xuICAgICAgXG4gICAgICB3aGlsZSAoIWNhbnZhcyAmJiByZXRyeUNvdW50IDwgbWF4UmV0cmllcykge1xuICAgICAgICBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYW52YXMgbm90IGZvdW5kLCByZXRyeSAke3JldHJ5Q291bnQgKyAxfS8ke21heFJldHJpZXN9YCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZSBhZnRlciBtdWx0aXBsZSByZXRyaWVzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHN0YXRlIGZvciByZXN0b3JhdGlvblxuICAgICAgY29uc3Qgb3JpZ2luYWxQYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgIGNvbnN0IG9yaWdpbmFsU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogY2FudmFzLnN0eWxlLmxlZnQsXG4gICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiBjYW52YXMuc3R5bGUuekluZGV4XG4gICAgICB9O1xuXG4gICAgICAvLyBQcmVwYXJlIGNhbnZhcyBmb3IgZnVsbHNjcmVlbiBkaXNwbGF5XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgICBcbiAgICAgIC8vIFNldCBkaW1lbnNpb25zIHRvIG1hdGNoIHdpbmRvdyBleGFjdGx5XG4gICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHBvc2l0aW9uIGZvciB0aGUgZG90IC0gZWl0aGVyIHVzZSBwcm92aWRlZCBwb3NpdGlvbiBvciBnZW5lcmF0ZSByYW5kb20gb25lXG4gICAgICBjb25zdCBkb3RQb3NpdGlvbiA9IHVzZVJhbmRvbVBvc2l0aW9uIFxuICAgICAgICA/IGdldFJhbmRvbVBvc2l0aW9uKGNhbnZhcywgMjApIFxuICAgICAgICA6IHBvc2l0aW9uO1xuICAgICAgXG4gICAgICBpZiAoIWRvdFBvc2l0aW9uIHx8IHR5cGVvZiBkb3RQb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgZG90UG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkb3QgcG9zaXRpb25cIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgY29uc3QgZG90UmFkaXVzID0gMTI7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHJlZHJhdyBpbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgIGxldCBrZWVwRG90VmlzaWJsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9LCA1MCk7ICAvLyBNb3JlIGZyZXF1ZW50IHVwZGF0ZXMgZm9yIHJlbGlhYmlsaXR5XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IG9uIHRvcCBvZiB0aGUgZG90XG4gICAgICAvLyBJbXBvcnRhbnQ6IFBvc2l0aW9uIHRoZSBjb3VudGRvd24gY2VudGVyZWQgZGlyZWN0bHkgb3ZlciB0aGUgZG90XG4gICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBsZWZ0OiAke2RvdFBvc2l0aW9uLnh9cHg7XG4gICAgICAgIHRvcDogJHtkb3RQb3NpdGlvbi55fXB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICBcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgZG90IGZvciByZWxpYWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGRpdGlvbmFsIHJlZHJhdyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgXG4gICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGFmdGVyIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBhZnRlciBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9zdENvdW50ZG93bkRlbGF5KSk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgcG9pbnQ6IGRvdFBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgcmVkcmF3IGludGVydmFsXG4gICAgICBjbGVhckludGVydmFsKGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIGNhbnZhcyB0byBvcmlnaW5hbCBzdGF0ZVxuICAgICAgaWYgKG9yaWdpbmFsUGFyZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBvcmlnaW5hbFBhcmVudCkge1xuICAgICAgICBvcmlnaW5hbFBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbFN0eWxlLnBvc2l0aW9uIHx8ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IG9yaWdpbmFsU3R5bGUudG9wIHx8ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBvcmlnaW5hbFN0eWxlLmxlZnQgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbFN0eWxlLndpZHRoIHx8ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbFN0eWxlLmhlaWdodCB8fCAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gb3JpZ2luYWxTdHlsZS56SW5kZXggfHwgJyc7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0IGRpbWVuc2lvbnNcbiAgICAgIGlmIChvcmlnaW5hbFBhcmVudCkge1xuICAgICAgICBjYW52YXMud2lkdGggPSBvcmlnaW5hbFBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvcmlnaW5hbFBhcmVudC5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyZSBjb21wbGV0ZWQnLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDIwMDApO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogZG90UG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVSZXN1bHRcbiAgICAgIH07XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGhhbmRsZURvdFByb2Nlc3M6XCIsIGVycm9yKTtcbiAgICAgIFxuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgLy8gRGVjbGFyZSB0aGVzZSB2YXJpYWJsZXMgT1VUU0lERSB0aGUgdHJ5IGJsb2NrXG4gICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgbGV0IG9yaWdpbmFsQ2FudmFzUGFyZW50ID0gbnVsbDtcbiAgICBsZXQgb3JpZ2luYWxDYW52YXNTdHlsZSA9IHt9O1xuICAgIGxldCBzdGF0dXNJbmRpY2F0b3IgPSBudWxsO1xuICAgIGxldCBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEhpZGUgVG9wQmFyXG4gICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFNob3dDYW52YXModHJ1ZSk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKFwiU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi5cIik7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIFVJIHVwZGF0ZXMgdG8gdGFrZSBlZmZlY3RcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDApKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhcyByZWZlcmVuY2VcbiAgICAgIGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoXCJFcnJvcjogQ2FudmFzIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNhdmUgb3JpZ2luYWwgcGFyZW50IGFuZCBzdHlsZVxuICAgICAgb3JpZ2luYWxDYW52YXNQYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgIG9yaWdpbmFsQ2FudmFzU3R5bGUgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogY2FudmFzLnN0eWxlLmxlZnQsXG4gICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiBjYW52YXMuc3R5bGUuekluZGV4XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBNb3ZlIGNhbnZhcyB0byBib2R5IGZvciBtYXhpbXVtIHJlbGlhYmlsaXR5XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBcbiAgICAgIC8vIE1ha2UgY2FudmFzIGZ1bGxzY3JlZW4gd2l0aCBmaXhlZCBwb3NpdGlvbmluZ1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgXG4gICAgICAvLyBTZXQgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3cgZXhhY3RseVxuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYENhbnZhcyBzZXQgdG8gZnVsbHNjcmVlbjogJHtjYW52YXNXaWR0aH14JHtjYW52YXNIZWlnaHR9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjb250ZXh0XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gdGhlIGNhbnZhcyBzaXplXG4gICAgICBjb25zdCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnKTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgc3RhdHVzIGluZGljYXRvclxuICAgICAgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgcGFkZGluZzogMTBweCAxNXB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb246IEluaXRpYWxpemluZy4uLic7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgaWYgKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGRpc3BsYXlzXG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbjogUG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzZXQgY2FudmFzIGlmIGRpbWVuc2lvbnMgY2hhbmdlZFxuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhbnZhcyBkaW1lbnNpb25zIGNoYW5nZWQuIFJlc2V0dGluZyB0byAke2NhbnZhc1dpZHRofXgke2NhbnZhc0hlaWdodH1gKTtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGJvZHkgYW5kIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IDE0OyAvLyBTbGlnaHRseSBsYXJnZXIgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSByZWRyYXcgZnVuY3Rpb24gZm9yIHRoaXMgcG9pbnRcbiAgICAgICAgY29uc3QgcmVkcmF3Q3VycmVudERvdCA9ICgpID0+IHtcbiAgICAgICAgICAvLyBWZXJpZnkgY2FudmFzIGRpbWVuc2lvbnMgYW5kIHBhcmVudFxuICAgICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYm9keVxuICAgICAgICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZWRyYXcgZG90IHdpdGhvdXQgY2xlYXJpbmdcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCByZWRyYXcgaW50ZXJ2YWwgLSBtb3JlIGZyZXF1ZW50IHVwZGF0ZXMgZm9yIHJlbGlhYmxlIGRvdCB2aXNpYmlsaXR5XG4gICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKHJlZHJhd0N1cnJlbnREb3QsIDUwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjdXN0b20gY291bnRkb3duIGVsZW1lbnRcbiAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJzsgLy8gQ29uc2lzdGVudCBjbGFzcyBuYW1lXG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgbGVmdDogJHtwb2ludC54fXB4O1xuICAgICAgICAgIHRvcDogJHtwb2ludC55IC0gNjB9cHg7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH06IENvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGb3JjZSByZWRyYXcgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlZHJhdyBhZ2FpbiBoYWxmd2F5IHRocm91Z2ggdGhlIHdhaXQgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG5cbiAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FwdHVyaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9IGF0ICgke3BvaW50Lnh9LCAke3BvaW50Lnl9KWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1hbnVhbCBmb3JjZSByZWRyYXcgb25lIG1vcmUgdGltZSBqdXN0IGJlZm9yZSBjYXB0dXJlXG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgIFxuICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50LFxuICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNhcHR1cmVSZXN1bHQgJiYgKGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgY2FwdHVyZVJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEyMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQ2xlYW4gdXAgY291bnRkb3duIGlmIGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgcmVkcmF3IGludGVydmFsXG4gICAgICAgICAgaWYgKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgfVxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FsaWJyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgaWYgKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGlmIGl0IGV4aXN0c1xuICAgICAgaWYgKHN0YXR1c0luZGljYXRvciAmJiBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBjYW52YXMgdG8gb3JpZ2luYWwgcGFyZW50IGFuZCBzdHlsaW5nIC0gT25seSBpZiBjYW52YXMgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZFxuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIG9yaWdpbmFsIHBhcmVudFxuICAgICAgICAgIGlmIChvcmlnaW5hbENhbnZhc1BhcmVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCAhPT0gb3JpZ2luYWxDYW52YXNQYXJlbnQpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsQ2FudmFzUGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgfSBlbHNlIGlmICghb3JpZ2luYWxDYW52YXNQYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGxvb2tpbmcgZm9yIGEgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKTtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZVBhcmVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCAhPT0gcG9zc2libGVQYXJlbnQpIHtcbiAgICAgICAgICAgICAgcG9zc2libGVQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVzdG9yZSBzdHlsaW5nXG4gICAgICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxDYW52YXNTdHlsZS5wb3NpdGlvbiB8fCAnJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gb3JpZ2luYWxDYW52YXNTdHlsZS50b3AgfHwgJyc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBvcmlnaW5hbENhbnZhc1N0eWxlLmxlZnQgfHwgJyc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gb3JpZ2luYWxDYW52YXNTdHlsZS53aWR0aCB8fCAnMTAwJSc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUuaGVpZ2h0IHx8ICcxMDAlJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gb3JpZ2luYWxDYW52YXNTdHlsZS56SW5kZXggfHwgJyc7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVzZXQgZGltZW5zaW9ucyBiYXNlZCBvbiBwYXJlbnRcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSA4MDA7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gNjAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIHJlc3RvcmVkIHRvIG9yaWdpbmFsIHN0YXRlXCIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHJlc3RvcmluZyBjYW52YXM6XCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNldFJhbmRvbSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQWx3YXlzIGdldCB0aGUgbGF0ZXN0IHNldHRpbmdzIGZyb20gY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgdXNlclxuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3MgJiYgc2V0dGluZ3NbY3VycmVudFVzZXJJZF0gPyBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSA6IHt9O1xuICAgICAgY29uc3QgdGltZXMgPSBOdW1iZXIodXNlclNldHRpbmdzLnRpbWVzX3NldF9yYW5kb20pIHx8IE51bWJlcihyYW5kb21UaW1lcykgfHwgMTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheV9zZXRfcmFuZG9tKSB8fCBOdW1iZXIoZGVsYXlTZWNvbmRzKSB8fCAzO1xuXG4gICAgICAvLyBMb2cgY3VycmVudCBzZXR0aW5ncyBiZWZvcmUgc3RhcnRpbmdcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBTZXQgUmFuZG9tIHdpdGggc2V0dGluZ3M6Jywge1xuICAgICAgICByYW5kb21UaW1lcyxcbiAgICAgICAgZGVsYXlTZWNvbmRzLFxuICAgICAgICBjdXJyZW50VXNlcklkLFxuICAgICAgICBzZXR0aW5ncyxcbiAgICAgICAgdXNlclNldHRpbmdzLFxuICAgICAgICB0aW1lcyxcbiAgICAgICAgZGVsYXlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIaWRlIFRvcEJhclxuICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyh0aW1lcyk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBTdGFydGluZyAke3RpbWVzfSByYW5kb20gY2FwdHVyZXMgd2l0aCAke2RlbGF5fXMgZGVsYXkuLi5gKTtcblxuICAgICAgLy8gUHJvY2VzcyBhbGwgY2FwdHVyZXMgaW4gc2VxdWVuY2VcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBjdXJyZW50SW5kZXggPSAxOyBjdXJyZW50SW5kZXggPD0gdGltZXM7IGN1cnJlbnRJbmRleCsrKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZm9yIGN1cnJlbnQgY2FwdHVyZVxuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fSBvZiAke3RpbWVzfWApO1xuICAgICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyh0aW1lcyAtIGN1cnJlbnRJbmRleCArIDEpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG9mICR7dGltZXN9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVc2UgaGFuZGxlRG90UHJvY2VzcyBmb3IgZWFjaCBjYXB0dXJlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZURvdFByb2Nlc3Moe1xuICAgICAgICAgIHVzZVJhbmRvbVBvc2l0aW9uOiB0cnVlLFxuICAgICAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0vJHt0aW1lc306ICR7c3RhdHVzLnByb2Nlc3NTdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHNob3cgVG9wQmFyIGFmdGVyIHRoZSBsYXN0IGNhcHR1cmVcbiAgICAgICAgICAgIGlmIChzaG93ICYmIGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3Qgc2hvdyB5ZXQgZm9yIGludGVybWVkaWF0ZSBjYXB0dXJlc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgc2hvdyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihzaG93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICAgICAgc2V0SXNDYXB0dXJpbmc6IChjYXB0dXJpbmcpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2V0IGNhcHR1cmluZyB0byBmYWxzZSBhZnRlciBhbGwgY2FwdHVyZXNcbiAgICAgICAgICAgIGlmICghY2FwdHVyaW5nICYmIGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgICAgIHJldHVybjsgLy8gU3RheSBpbiBjYXB0dXJpbmcgc3RhdGUgYmV0d2VlbiBkb3RzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhjYXB0dXJpbmcpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgICBwb3N0Q291bnRkb3duRGVsYXk6IDgwMFxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCBjYXB0dXJlICR7Y3VycmVudEluZGV4fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0gbWF5IGhhdmUgZmFpbGVkOmAsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYmV0d2VlbiBjYXB0dXJlcyAtIGJ1dCBvbmx5IGlmIHRoZXJlIGFyZSBtb3JlIGNhcHR1cmVzIHRvIGdvXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyAke2RlbGF5fXMgYmVmb3JlIG5leHQgY2FwdHVyZS4uLmApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSAqIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wbGV0aW9uIG5vdGlmaWNhdGlvblxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUmFuZG9tIGNhcHR1cmUgc2VxdWVuY2UgY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gY2FwdHVyZXMgc3VjY2Vzc2Z1bGApO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBjb25zb2xlLmxvZyhgQ29tcGxldGVkIGFsbCBjYXB0dXJlczogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IHN1Y2Nlc3NmdWxgKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUmFuZG9tIHNlcXVlbmNlIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBSYW5kb20gc2VxdWVuY2UgZmFpbGVkOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaGFuZGxlUmFuZG9tRG90ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIFVzZSB0aGUgY29uc29saWRhdGVkIGZ1bmN0aW9uIHdpdGggcmFuZG9tIHBvc2l0aW9uXG4gICAgYXdhaXQgaGFuZGxlRG90UHJvY2Vzcyh7XG4gICAgICB1c2VSYW5kb21Qb3NpdGlvbjogdHJ1ZSxcbiAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXMucHJvY2Vzc1N0YXR1cyk7XG4gICAgICAgIGlmIChzdGF0dXMuaXNDYXB0dXJpbmcgIT09IHVuZGVmaW5lZCkgc2V0SXNDYXB0dXJpbmcoc3RhdHVzLmlzQ2FwdHVyaW5nKTtcbiAgICAgIH0sXG4gICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgIHNldElzQ2FwdHVyaW5nLFxuICAgICAgY2FwdHVyZUNvdW50LFxuICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICBwb3N0Q291bnRkb3duRGVsYXk6IDEwMDBcbiAgICB9KTtcbiAgfTtcbiAgXG5cbiAgLy8gTG9hZCBjYWxpYnJhdGlvbiBzZXR1cFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2V0dXBDYWxpYnJhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdDogQ2FsaWJyYXRlSGFuZGxlciB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXInKTtcbiAgICBcbiAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbnZhcyBub3QgYXZhaWxhYmxlIGR1cmluZyBzZXR1cENhbGlicmF0aW9uXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgbWFrZUNhbnZhc0Z1bGxzY3JlZW4oY2FudmFzKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzIHNpemU6JywgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnR2VuZXJhdGVkIGNhbGlicmF0aW9uIHBvaW50czonLCBwb2ludHMpO1xuICAgICAgICBzZXRDYWxpYnJhdGlvblBvaW50cyhwb2ludHMpO1xuICAgIFxuICAgICAgICBjb25zdCBjYWxpYnJhdGVIYW5kbGVyID0gbmV3IENhbGlicmF0ZUhhbmRsZXIoe1xuICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICBjYWxpYnJhdGlvblBvaW50czogcG9pbnRzLFxuICAgICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IG9uQWN0aW9uQ2xpY2s/LigndG9nZ2xlVG9wQmFyJywgc2hvdyksXG4gICAgICAgICAgc2V0T3V0cHV0VGV4dDogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUNvdW50ZXI6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcjogKG5ld0NvdW50ZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q291bnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQocHJldiA9PiBuZXdDb3VudGVyKHByZXYpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudChuZXdDb3VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLFxuICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHNldENhbGlicmF0aW9uSGFuZGxlcih7XG4gICAgICAgICAgaGFuZGxlQWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ1N0YXJ0aW5nIGNhbGlicmF0aW9uLi4uJyk7XG4gICAgICAgICAgICBhd2FpdCBjYWxpYnJhdGVIYW5kbGVyLnN0YXJ0Q2FsaWJyYXRpb24oKTtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgcmVzdG9yZUNhbnZhc1NpemUoY2FudmFzKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBjYWxpYnJhdGlvbjonLCBlcnIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXR1cENhbGlicmF0aW9uKCk7XG4gIH0sIFtjYXB0dXJlQ291bnQsIG9uQWN0aW9uQ2xpY2tdKTtcbiAgXG4gIC8vIENsZWFyIEFsbCBCdXR0b24gLSBSZXNldCBldmVyeXRoaW5nXG4gIGNvbnN0IGhhbmRsZUNsZWFyQWxsID0gKCkgPT4ge1xuICAgIGNsZWFyQ2FudmFzKCk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cygnJyk7XG4gICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgIHNldENvdW50ZG93blZhbHVlKG51bGwpO1xuICAgIHNldFNob3dDYW52YXModHJ1ZSk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEhlYWQgUG9zZSB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUhlYWRQb3NlID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0hlYWRQb3NlU3RhdGUgPSAhc2hvd0hlYWRQb3NlO1xuICAgIHNldFNob3dIZWFkUG9zZShuZXdIZWFkUG9zZVN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBIZWFkIHBvc2UgdmlzdWFsaXphdGlvbiAke25ld0hlYWRQb3NlU3RhdGUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdoZWFkUG9zZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dIZWFkUG9zZTogbmV3SGVhZFBvc2VTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGhlYWQgcG9zZTogJHtuZXdIZWFkUG9zZVN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgQm91bmRpbmcgQm94IHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3ggPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Qm91bmRpbmdCb3hTdGF0ZSA9ICFzaG93Qm91bmRpbmdCb3g7XG4gICAgc2V0U2hvd0JvdW5kaW5nQm94KG5ld0JvdW5kaW5nQm94U3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYEJvdW5kaW5nIGJveCAke25ld0JvdW5kaW5nQm94U3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ2JvdW5kaW5nQm94Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd0JvdW5kaW5nQm94OiBuZXdCb3VuZGluZ0JveFN0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgYm91bmRpbmcgYm94OiAke25ld0JvdW5kaW5nQm94U3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBNYXNrIHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlTWFzayA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdNYXNrU3RhdGUgPSAhc2hvd01hc2s7XG4gICAgc2V0U2hvd01hc2sobmV3TWFza1N0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBNYXNrICR7bmV3TWFza1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdtYXNrJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd01hc2s6IG5ld01hc2tTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIG1hc2s6ICR7bmV3TWFza1N0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgUGFyYW1ldGVycyBkaXNwbGF5XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3UGFyYW1ldGVyc1N0YXRlID0gIXNob3dQYXJhbWV0ZXJzO1xuICAgIHNldFNob3dQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnNTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgUGFyYW1ldGVycyAke25ld1BhcmFtZXRlcnNTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygncGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dQYXJhbWV0ZXJzOiBuZXdQYXJhbWV0ZXJzU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBwYXJhbWV0ZXJzOiAke25ld1BhcmFtZXRlcnNTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIGNhbWVyYSBwcmV2aWV3XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUNhbWVyYSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdDYW1lcmFTdGF0ZSA9ICFpc0NhbWVyYUFjdGl2ZTtcbiAgICBzZXRJc0NhbWVyYUFjdGl2ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgd2l0aCAncHJldmlldycgYWN0aW9uXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3ByZXZpZXcnLCBuZXdDYW1lcmFTdGF0ZSk7IC8vIFBhc3MgdGhlIG5ldyBzdGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgdHJpZ2dlciBpZiBubyBhY3Rpb24gaGFuZGxlclxuICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgdHVybmluZyBvbiBjYW1lcmEsIGVuc3VyZSB3ZSBhcHBseSBjdXJyZW50IHZpc3VhbGl6YXRpb24gc2V0dGluZ3NcbiAgICBpZiAobmV3Q2FtZXJhU3RhdGUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAvLyBXYWl0IGEgc2hvcnQgbW9tZW50IHRvIGVuc3VyZSB0aGUgdmlkZW8gZWxlbWVudCBpcyByZWFkeVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICBzaG93SGVhZFBvc2UsXG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3gsXG4gICAgICAgICAgICBzaG93TWFzayxcbiAgICAgICAgICAgIHNob3dQYXJhbWV0ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBiYWNrIGJ1dHRvbiBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZUdvQmFjayA9ICgpID0+IHtcbiAgICByb3V0ZXIucHVzaCgnLycpO1xuICB9O1xuXG4gIC8vIE1vYmlsZSBsYXlvdXQgLSAyeDUgZ3JpZFxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICB7aXNDb21wYWN0TW9kZSA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yIG1iLTRcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMlwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgey8qIFN0YXR1cyBkaXNwbGF5IHdpdGggbWVtb2l6YXRpb24gKi99XG4gICAgICB7dXNlTWVtbygoKSA9PiAoXG4gICAgICAgIChwcm9jZXNzU3RhdHVzIHx8IHJlbWFpbmluZ0NhcHR1cmVzID4gMCB8fCBjb3VudGRvd25WYWx1ZSkgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3RhdHVzLWRpc3BsYXkgbXQtNCBwLTIgYmctYmx1ZS01MCByb3VuZGVkLW1kXCI+XG4gICAgICAgICAgICB7cHJvY2Vzc1N0YXR1cyAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWJsdWUtODAwXCI+e3Byb2Nlc3NTdGF0dXN9PC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge3JlbWFpbmluZ0NhcHR1cmVzID4gMCAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LXllbGxvdy02MDBcIj5SZW1haW5pbmc6IHtyZW1haW5pbmdDYXB0dXJlc308L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7Y291bnRkb3duVmFsdWUgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXJlZC02MDBcIj57Y291bnRkb3duVmFsdWV9PC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApXG4gICAgICApLCBbcHJvY2Vzc1N0YXR1cywgcmVtYWluaW5nQ2FwdHVyZXMsIGNvdW50ZG93blZhbHVlXSl9XG4gICAgICBcbiAgICAgIHsvKiBDYW52YXMgZm9yIGRyYXdpbmcgZG90cyAqL31cbiAgICAgIHtzaG93Q2FudmFzICYmIChcbiAgICAgICAgPGRpdiBcbiAgICAgICAgICBjbGFzc05hbWU9XCJjYW52YXMtY29udGFpbmVyIG10LTRcIiBcbiAgICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogJzQwdmgnLFxuICAgICAgICAgICAgbWluSGVpZ2h0OiAnMzAwcHgnLFxuICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNlMGUwZTAnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8Y2FudmFzIFxuICAgICAgICAgICAgcmVmPXsoY2FudmFzKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidHJhY2tpbmctY2FudmFzXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogT3ZlcmxheSBmb3IgY291bnRkb3duIG9uIGRvdCAqL31cbiAgICAgICAgICB7Y291bnRkb3duVmFsdWUgJiYgY3VycmVudERvdCAmJiAoXG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkb3QtY291bnRkb3duXCJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtjdXJyZW50RG90LnggLSAxNX1weGAsXG4gICAgICAgICAgICAgICAgdG9wOiBgJHtjdXJyZW50RG90LnkgLSA0MH1weGAsXG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMjhweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgey8qIENhbWVyYSBQZXJtaXNzaW9uIFBvcHVwICovfVxuICAgICAge3Nob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMTVcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWRpYWxvZ1wiIFxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aDMgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDE1cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENhbWVyYSBBY2Nlc3MgUmVxdWlyZWRcbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tbWVzc2FnZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICBnYXA6ICcxMHB4J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7XG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFxuICBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiA8QWN0aW9uQnV0dG9uR3JvdXBJbm5lciB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPilcbiksIHsgc3NyOiBmYWxzZSB9KTtcbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgQWN0aW9uQnV0dG9uR3JvdXBcbi8vIGNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoQWN0aW9uQnV0dG9uR3JvdXBJbm5lciksIHsgc3NyOiBmYWxzZSB9KTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWN0aW9uQnV0dG9uUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59XG5cbmV4cG9ydCB7IEFjdGlvbkJ1dHRvbiwgQWN0aW9uQnV0dG9uR3JvdXAgfTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImR5bmFtaWMiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInJ1bkNvdW50ZG93biIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwidXNlUm91dGVyIiwidXNlQWRtaW5TZXR0aW5ncyIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsIkFjdGlvbkJ1dHRvbiIsInRleHQiLCJhYmJyZXZpYXRlZFRleHQiLCJvbkNsaWNrIiwiY3VzdG9tQ2xhc3MiLCJkaXNhYmxlZCIsImFjdGl2ZSIsImlzQWJicmV2aWF0ZWQiLCJzZXRJc0FiYnJldmlhdGVkIiwic2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJidXR0b25Qcm9wcyIsImNsYXNzTmFtZSIsInRpdGxlIiwidGltZW91dElkIiwiaGFuZGxlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJ0eXBlIiwibmV3VXNlcklkIiwidXNlcklkIiwiYnV0dG9uIiwiZGl2IiwiQWN0aW9uQnV0dG9uR3JvdXBJbm5lciIsInJlZiIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsInJvdXRlciIsInVwZGF0ZVNldHRpbmdzIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbnZhc1JlZiIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJjdXJyZW50Q2FsaWJyYXRpb25JbmRleCIsInNldEN1cnJlbnRDYWxpYnJhdGlvbkluZGV4IiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzZXRSZW1haW5pbmdDYXB0dXJlcyIsInNob3dDYW52YXMiLCJzZXRTaG93Q2FudmFzIiwiY2FsaWJyYXRpb25IYW5kbGVyIiwic2V0Q2FsaWJyYXRpb25IYW5kbGVyIiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0hlYWRQb3NlIiwic2V0U2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2V0U2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzZXRTaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2V0U2hvd1BhcmFtZXRlcnMiLCJpc0NhbWVyYUFjdGl2ZSIsInNldElzQ2FtZXJhQWN0aXZlIiwic2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldFNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXR0aW5nc0NhY2hlIiwiTWFwIiwibGFzdFNldHRpbmdzVXBkYXRlIiwiYnV0dG9ucyIsImhhbmRsZVNldFJhbmRvbSIsImhhbmRsZVJhbmRvbURvdCIsImhhbmRsZVNldENhbGlicmF0ZSIsImhhbmRsZUNsZWFyQWxsIiwiZGl2aWRlciIsImhhbmRsZVRvZ2dsZUhlYWRQb3NlIiwiaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3giLCJoYW5kbGVUb2dnbGVDYW1lcmEiLCJoYW5kbGVUb2dnbGVNYXNrIiwiaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyIsInVzZXJTZXR0aW5ncyIsImNhY2hlZFNldHRpbmdzIiwiY3VycmVudCIsImdldCIsIk51bWJlciIsInRpbWVzX3NldF9yYW5kb20iLCJkZWxheV9zZXRfcmFuZG9tIiwic2V0IiwiRGF0ZSIsIm5vdyIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidW5kZWZpbmVkIiwibmV3VGltZXMiLCJuZXdEZWxheSIsImFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyIsInVwZGF0ZUNvbnRyb2xWYWx1ZXMiLCJ0aW1lSW5wdXQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ0aW1lVmFsdWUiLCJwYXJzZUludCIsInZhbHVlIiwiaXNOYU4iLCJjb25zb2xlIiwibG9nIiwiZGVsYXlJbnB1dCIsImRlbGF5VmFsdWUiLCJpbml0aWFsaXplQ2FudmFzIiwiY2FudmFzIiwicGFyZW50IiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJlcnJvciIsImdldE1haW5DYW52YXMiLCJ3aGl0ZVNjcmVlbkNhbnZhcyIsInNlbGVjdG9ycyIsInNlbGVjdG9yIiwiY2FudmFzRWxlbWVudCIsIm1ha2VDYW52YXNGdWxsc2NyZWVuIiwicGFyZW50RWxlbWVudCIsImJvZHkiLCJzdHlsZSIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInpJbmRleCIsImlubmVySGVpZ2h0IiwicmVzdG9yZUNhbnZhc1NpemUiLCJoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWQiLCJoYW5kbGVQZXJtaXNzaW9uRGVuaWVkIiwicmVzdG9yZUNhbnZhcyIsIm9yaWdpbmFsUGFyZW50Iiwib3JpZ2luYWxTdHlsZSIsImFwcGVuZENoaWxkIiwiY2xlYXJDYW52YXMiLCJ3YXJuIiwiaGFuZGxlRG90UHJvY2VzcyIsIm9wdGlvbnMiLCJvblN0YXR1c1VwZGF0ZSIsInRvZ2dsZVRvcEJhciIsInVzZVJhbmRvbVBvc2l0aW9uIiwicG9zdENvdW50ZG93bkRlbGF5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXRyeUNvdW50IiwibWF4UmV0cmllcyIsIkVycm9yIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJkb3RQb3NpdGlvbiIsIngiLCJ5IiwiZG90UmFkaXVzIiwia2VlcERvdFZpc2libGVJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvdW50ZG93bkVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3NzVGV4dCIsImNvdW50IiwidGV4dENvbnRlbnQiLCJjYXB0dXJlUmVzdWx0IiwicG9pbnQiLCJjbGVhckludGVydmFsIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJvcmlnaW5hbENhbnZhc1BhcmVudCIsIm9yaWdpbmFsQ2FudmFzU3R5bGUiLCJzdGF0dXNJbmRpY2F0b3IiLCJjdXJyZW50UmVkcmF3SW50ZXJ2YWwiLCJwb2ludHMiLCJzdWNjZXNzQ291bnQiLCJpIiwicmFkaXVzIiwicmVkcmF3Q3VycmVudERvdCIsInNjcmVlbkltYWdlIiwicG9zc2libGVQYXJlbnQiLCJlIiwidGltZXMiLCJkZWxheSIsImN1cnJlbnRJbmRleCIsInJlc3VsdCIsInN0YXR1cyIsInNob3ciLCJjYXB0dXJpbmciLCJzZXR1cENhbGlicmF0aW9uIiwiZGVmYXVsdCIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjYWxpYnJhdGVIYW5kbGVyIiwic2V0T3V0cHV0VGV4dCIsIm5ld0NvdW50ZXIiLCJwcmV2IiwiY2FwdHVyZUZvbGRlciIsIm9uQ29tcGxldGUiLCJoYW5kbGVBY3Rpb24iLCJzdGFydENhbGlicmF0aW9uIiwiZXJyIiwibmV3SGVhZFBvc2VTdGF0ZSIsInZpZGVvUHJvY2Vzc29yIiwidXBkYXRlT3B0aW9ucyIsIm5ld0JvdW5kaW5nQm94U3RhdGUiLCJuZXdNYXNrU3RhdGUiLCJuZXdQYXJhbWV0ZXJzU3RhdGUiLCJuZXdDYW1lcmFTdGF0ZSIsImhhbmRsZUdvQmFjayIsInB1c2giLCJtaW5IZWlnaHQiLCJib3JkZXIiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJSYWRpdXMiLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJjb2xvciIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJoMyIsIm1hcmdpbiIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiY3Vyc29yIiwiQWN0aW9uQnV0dG9uR3JvdXAiLCJwcm9wcyIsInNzciIsIkFjdGlvbkJ1dHRvblBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});