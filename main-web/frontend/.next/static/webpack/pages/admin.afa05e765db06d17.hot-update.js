"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Add debounce utility\nconst debounce = (func, wait)=>{\n    let timeout;\n    return function executedFunction() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const later = ()=>{\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n};\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useAdminSettings.useState\": ()=>{\n            // Initialize from localStorage on mount\n            return localStorage.getItem('currentUserId');\n        }\n    }[\"useAdminSettings.useState\"]);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [lastUpdateTime, setLastUpdateTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Increase intervals to reduce API calls\n    const POLLING_INTERVAL = 30000; // 30 seconds\n    const MIN_UPDATE_INTERVAL = 5000; // 5 seconds\n    const CACHE_DURATION = 60000; // 1 minute\n    // Add cache for settings with timestamp\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const pendingUpdates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const isUpdating = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Debug logging for settings changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            console.log('AdminSettings - Current Settings:', settings);\n            console.log('AdminSettings - Current User ID:', currentUserId);\n            console.log('AdminSettings - Is TopBar Updated:', isTopBarUpdated);\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId,\n        isTopBarUpdated\n    ]);\n    // Helper: Fetch settings for a user from backend with enhanced caching\n    const fetchSettingsForUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAdminSettings.useCallback[fetchSettingsForUser]\": async (userId)=>{\n            if (!userId) return;\n            // Check cache first\n            const cachedSettings = settingsCache.current.get(userId);\n            const lastUpdate = lastSettingsUpdate.current.get(userId);\n            const now = Date.now();\n            // If we have cached settings and they're recent enough, use them\n            if (cachedSettings && lastUpdate && now - lastUpdate < CACHE_DURATION) {\n                console.log('[AdminSettings] Using cached settings for user:', userId);\n                return cachedSettings;\n            }\n            // If there's already a pending update, return the cached value\n            if (pendingUpdates.current.has(userId)) {\n                console.log('[AdminSettings] Pending update exists, using cached value');\n                return cachedSettings;\n            }\n            // If an update is in progress, return the cached value\n            if (isUpdating.current) {\n                console.log('[AdminSettings] Update in progress, using cached value');\n                return cachedSettings;\n            }\n            try {\n                isUpdating.current = true;\n                pendingUpdates.current.set(userId, true);\n                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json',\n                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch({\n                        \"useAdminSettings.useCallback[fetchSettingsForUser]\": ()=>({})\n                    }[\"useAdminSettings.useCallback[fetchSettingsForUser]\"]);\n                    throw new Error(errorData.detail || 'Failed to fetch settings');\n                }\n                const result = await response.json();\n                const newSettings = result.data || {};\n                // Only update if settings have actually changed\n                if (!isEqual(settings[userId], newSettings)) {\n                    setSettings({\n                        \"useAdminSettings.useCallback[fetchSettingsForUser]\": (prev)=>({\n                                ...prev,\n                                [userId]: newSettings\n                            })\n                    }[\"useAdminSettings.useCallback[fetchSettingsForUser]\"]);\n                    setCurrentSettings(newSettings);\n                    // Update cache\n                    settingsCache.current.set(userId, newSettings);\n                    lastSettingsUpdate.current.set(userId, now);\n                    // Update TopBar if ref provided\n                    if (ref && ref.current && ref.current.setCaptureSettings) {\n                        ref.current.setCaptureSettings(newSettings);\n                        setIsTopBarUpdated(true);\n                    }\n                }\n                setError(null);\n                return newSettings;\n            } catch (error) {\n                console.error('[AdminSettings] Error fetching settings:', error);\n                setError(error.message);\n                return cachedSettings; // Return cached settings on error\n            } finally{\n                isUpdating.current = false;\n                pendingUpdates.current.delete(userId);\n            }\n        }\n    }[\"useAdminSettings.useCallback[fetchSettingsForUser]\"], [\n        ref,\n        settings\n    ]);\n    // Debounced version of fetchSettingsForUser\n    const debouncedFetchSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(debounce({\n        \"useAdminSettings.useCallback[debouncedFetchSettings]\": (userId)=>{\n            fetchSettingsForUser(userId);\n        }\n    }[\"useAdminSettings.useCallback[debouncedFetchSettings]\"], 1000), [\n        fetchSettingsForUser\n    ]);\n    // Polling for settings updates with enhanced optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (!currentUserId) return;\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    const now = Date.now();\n                    if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                        return;\n                    }\n                    try {\n                        await debouncedFetchSettings(currentUserId);\n                        setLastUpdateTime(now);\n                    } catch (error) {\n                        console.error('[AdminSettings] Polling error:', error);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            // Initial fetch\n            fetchSettings();\n            // Set up polling with increased interval\n            pollingInterval.current = setInterval(fetchSettings, POLLING_INTERVAL);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        lastUpdateTime,\n        debouncedFetchSettings\n    ]);\n    // Listen for userId changes (from index.js navigation)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        console.log('[handleUserIdChange] userId:', event.detail.userId);\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        localStorage.setItem('currentUserId', newUserId);\n                        fetchSettingsForUser(newUserId);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Initial settings fetch on mount if we have a user ID\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (currentUserId && !initialized.current) {\n                fetchSettingsForUser(currentUserId);\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId\n    ]);\n    // Effect to handle index.js update after TopBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount (optional, fallback)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n            // Ignore\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {}\n            } else {\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('[settings useEffect] currentUserId:', currentUserId); // Debug log\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                // Optionally update UI elements if needed\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page (captureSettingsUpdate event)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        console.log('[handleSettingsUpdate] userId:', userId, 'currentUserId:', currentUserId); // Debug log\n                        if (userId === currentUserId) {\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            updateSettings(newSettings, userId);\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    // Update settings for a user with enhanced optimization\n    const updateSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAdminSettings.useCallback[updateSettings]\": async (newSettings, userId)=>{\n            if (!userId) return;\n            const now = Date.now();\n            if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                console.log('[updateSettings] Skipping update - too soon after last update');\n                return;\n            }\n            const updatedSettings = {\n                ...settings[userId],\n                ...newSettings\n            };\n            // Check if settings have actually changed\n            if (isEqual(settings[userId], updatedSettings)) {\n                console.log('[updateSettings] Settings unchanged, skipping update');\n                return;\n            }\n            try {\n                isUpdating.current = true;\n                pendingUpdates.current.set(userId, true);\n                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                    },\n                    body: JSON.stringify(updatedSettings)\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch({\n                        \"useAdminSettings.useCallback[updateSettings]\": ()=>({})\n                    }[\"useAdminSettings.useCallback[updateSettings]\"]);\n                    throw new Error(errorData.detail || 'Failed to save settings');\n                }\n                const result = await response.json();\n                const finalSettings = result.data || updatedSettings;\n                // Update state and cache\n                setSettings({\n                    \"useAdminSettings.useCallback[updateSettings]\": (prev)=>({\n                            ...prev,\n                            [userId]: finalSettings\n                        })\n                }[\"useAdminSettings.useCallback[updateSettings]\"]);\n                setCurrentSettings(finalSettings);\n                settingsCache.current.set(userId, finalSettings);\n                lastSettingsUpdate.current.set(userId, now);\n                setLastUpdateTime(now);\n                setError(null);\n            } catch (error) {\n                setError(error.message);\n            } finally{\n                isUpdating.current = false;\n                pendingUpdates.current.delete(userId);\n            }\n        }\n    }[\"useAdminSettings.useCallback[updateSettings]\"], [\n        settings,\n        lastUpdateTime\n    ]);\n    // Upload and update image for a user\n    const updateImage = async (userId, base64Image)=>{\n        console.log('[updateImage] userId:', userId); // Debug log\n        if (!userId || !base64Image) return;\n        try {\n            const response = await fetch(\"/api/data-center/image?user_id=\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify({\n                    image: base64Image\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to upload image');\n            }\n            // Optionally, fetch settings again to get updated image info\n            await fetchSettingsForUser(userId);\n            setError(null);\n            return true;\n        } catch (error) {\n            setError(error.message);\n            return false;\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        updateImage,\n        error\n    };\n};\n_s(useAdminSettings, \"GznULPzZw5L7amYZqnjPJZ+0kzE=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFFakUsOEJBQThCO0FBQzlCLE1BQU1JLFVBQVUsQ0FBQ0MsTUFBTUM7SUFDckIsSUFBSUQsU0FBU0MsTUFBTSxPQUFPO0lBQzFCLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9DLFNBQVMsVUFBVSxPQUFPO0lBQ2pFLElBQUlELFNBQVMsUUFBUUMsU0FBUyxNQUFNLE9BQU87SUFFM0MsTUFBTUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSjtJQUMxQixNQUFNSyxRQUFRRixPQUFPQyxJQUFJLENBQUNIO0lBRTFCLElBQUlDLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFLE9BQU87SUFFMUMsT0FBT0osTUFBTUssS0FBSyxDQUFDQyxDQUFBQSxNQUNqQkgsTUFBTUksUUFBUSxDQUFDRCxRQUFRVCxRQUFRQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO0FBRXZEO0FBRUEsdUJBQXVCO0FBQ3ZCLE1BQU1FLFdBQVcsQ0FBQ0MsTUFBTUM7SUFDdEIsSUFBSUM7SUFDSixPQUFPLFNBQVNDO1FBQWlCO1lBQUdDLEtBQUgsdUJBQU87O1FBQ3RDLE1BQU1DLFFBQVE7WUFDWkMsYUFBYUo7WUFDYkYsUUFBUUk7UUFDVjtRQUNBRSxhQUFhSjtRQUNiQSxVQUFVSyxXQUFXRixPQUFPSjtJQUM5QjtBQUNGO0FBRU8sTUFBTU8sbUJBQW1CLENBQUNDOztJQUMvQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR3pCLCtDQUFRQSxDQUFDLENBQUM7SUFDMUMsTUFBTSxDQUFDMEIsZUFBZUMsaUJBQWlCLEdBQUczQiwrQ0FBUUE7cUNBQUM7WUFDakQsd0NBQXdDO1lBQ3hDLE9BQU80QixhQUFhQyxPQUFPLENBQUM7UUFDOUI7O0lBQ0EsTUFB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eUJFLFNBQVMsWUFBWTtRQUMxRCxJQUFJLENBQUNBLFVBQVUsQ0FBQzJELGFBQWE7UUFDN0IsSUFBSTtZQUNGLE1BQU1sRCxXQUFXLE1BQU1DLE1BQU0sa0NBQXlDLE9BQVBWLFNBQVU7Z0JBQ3ZFdUQsUUFBUTtnQkFDUjVDLFNBQVM7b0JBQ1AsZ0JBQWdCO29CQUNoQixhQUFhQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO2dCQUNsRDtnQkFDQTBDLE1BQU1aLEtBQUtFLFNBQVMsQ0FBQztvQkFBRWMsT0FBT0Q7Z0JBQVk7WUFDNUM7WUFDQSxJQUFJLENBQUNsRCxTQUFTTSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVAsU0FBU1EsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlDLE1BQU1ILFVBQVVJLE1BQU0sSUFBSTtZQUN0QztZQUNBLDZEQUE2RDtZQUM3RCxNQUFNckIscUJBQXFCQztZQUMzQmxCLFNBQVM7WUFDVCxPQUFPO1FBQ1QsRUFBRSxPQUFPRCxPQUFPO1lBQ2RDLFNBQVNELE1BQU02QyxPQUFPO1lBQ3RCLE9BQU87UUFDVDtJQUNGO0lBRUEsT0FBTztRQUFFckQ7UUFBVWdGO1FBQWdCSztRQUFhN0U7SUFBTTtBQUN4RCxFQUFFO0dBelVXVjtBQTJVYiwrQkFBK0I7QUFDaEIsU0FBUzBGO0lBQ3RCLE9BQU8sTUFBTSw4REFBOEQ7QUFDN0U7S0FGd0JBIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9hZG1pblNldHRpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5cbi8vIEFkZCBkZWVwIGNvbXBhcmlzb24gdXRpbGl0eVxuY29uc3QgaXNFcXVhbCA9IChvYmoxLCBvYmoyKSA9PiB7XG4gIGlmIChvYmoxID09PSBvYmoyKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqMiAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgPT09IG51bGwgfHwgb2JqMiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgXG4gIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgcmV0dXJuIGtleXMxLmV2ZXJ5KGtleSA9PiBcbiAgICBrZXlzMi5pbmNsdWRlcyhrZXkpICYmIGlzRXF1YWwob2JqMVtrZXldLCBvYmoyW2tleV0pXG4gICk7XG59O1xuXG4vLyBBZGQgZGVib3VuY2UgdXRpbGl0eVxuY29uc3QgZGVib3VuY2UgPSAoZnVuYywgd2FpdCkgPT4ge1xuICBsZXQgdGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGVkRnVuY3Rpb24oLi4uYXJncykge1xuICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgZnVuYyguLi5hcmdzKTtcbiAgICB9O1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXNlQWRtaW5TZXR0aW5ncyA9IChyZWYpID0+IHtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJyZW50VXNlcklkJyk7XG4gIH0pO1xuICBjb25zdCBbaXNUb3BCYXJVcGRhdGVkLCBzZXRJc1RvcEJhclVwZGF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRTZXR0aW5ncywgc2V0Q3VycmVudFNldHRpbmdzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW2xhc3RVcGRhdGVUaW1lLCBzZXRMYXN0VXBkYXRlVGltZV0gPSB1c2VTdGF0ZSgwKTtcbiAgXG4gIC8vIEluY3JlYXNlIGludGVydmFscyB0byByZWR1Y2UgQVBJIGNhbGxzXG4gIGNvbnN0IFBPTExJTkdfSU5URVJWQUwgPSAzMDAwMDsgLy8gMzAgc2Vjb25kc1xuICBjb25zdCBNSU5fVVBEQVRFX0lOVEVSVkFMID0gNTAwMDsgLy8gNSBzZWNvbmRzXG4gIGNvbnN0IENBQ0hFX0RVUkFUSU9OID0gNjAwMDA7IC8vIDEgbWludXRlXG4gIFxuICAvLyBBZGQgY2FjaGUgZm9yIHNldHRpbmdzIHdpdGggdGltZXN0YW1wXG4gIGNvbnN0IHNldHRpbmdzQ2FjaGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgbGFzdFNldHRpbmdzVXBkYXRlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IHBlbmRpbmdVcGRhdGVzID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IGlzVXBkYXRpbmcgPSB1c2VSZWYoZmFsc2UpO1xuXG4gIC8vIERlYnVnIGxvZ2dpbmcgZm9yIHNldHRpbmdzIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQWRtaW5TZXR0aW5ncyAtIEN1cnJlbnQgU2V0dGluZ3M6Jywgc2V0dGluZ3MpO1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gQ3VycmVudCBVc2VyIElEOicsIGN1cnJlbnRVc2VySWQpO1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gSXMgVG9wQmFyIFVwZGF0ZWQ6JywgaXNUb3BCYXJVcGRhdGVkKTtcbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkLCBpc1RvcEJhclVwZGF0ZWRdKTtcblxuICAvLyBIZWxwZXI6IEZldGNoIHNldHRpbmdzIGZvciBhIHVzZXIgZnJvbSBiYWNrZW5kIHdpdGggZW5oYW5jZWQgY2FjaGluZ1xuICBjb25zdCBmZXRjaFNldHRpbmdzRm9yVXNlciA9IHVzZUNhbGxiYWNrKGFzeW5jICh1c2VySWQpID0+IHtcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICBjb25zdCBjYWNoZWRTZXR0aW5ncyA9IHNldHRpbmdzQ2FjaGUuY3VycmVudC5nZXQodXNlcklkKTtcbiAgICBjb25zdCBsYXN0VXBkYXRlID0gbGFzdFNldHRpbmdzVXBkYXRlLmN1cnJlbnQuZ2V0KHVzZXJJZCk7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIC8vIElmIHdlIGhhdmUgY2FjaGVkIHNldHRpbmdzIGFuZCB0aGV5J3JlIHJlY2VudCBlbm91Z2gsIHVzZSB0aGVtXG4gICAgaWYgKGNhY2hlZFNldHRpbmdzICYmIGxhc3RVcGRhdGUgJiYgKG5vdyAtIGxhc3RVcGRhdGUgPCBDQUNIRV9EVVJBVElPTikpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQWRtaW5TZXR0aW5nc10gVXNpbmcgY2FjaGVkIHNldHRpbmdzIGZvciB1c2VyOicsIHVzZXJJZCk7XG4gICAgICByZXR1cm4gY2FjaGVkU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUncyBhbHJlYWR5IGEgcGVuZGluZyB1cGRhdGUsIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlXG4gICAgaWYgKHBlbmRpbmdVcGRhdGVzLmN1cnJlbnQuaGFzKHVzZXJJZCkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbQWRtaW5TZXR0aW5nc10gUGVuZGluZyB1cGRhdGUgZXhpc3RzLCB1c2luZyBjYWNoZWQgdmFsdWUnKTtcbiAgICAgIHJldHVybiBjYWNoZWRTZXR0aW5ncztcbiAgICB9XG5cbiAgICAvLyBJZiBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3MsIHJldHVybiB0aGUgY2FjaGVkIHZhbHVlXG4gICAgaWYgKGlzVXBkYXRpbmcuY3VycmVudCkge1xuICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBVcGRhdGUgaW4gcHJvZ3Jlc3MsIHVzaW5nIGNhY2hlZCB2YWx1ZScpO1xuICAgICAgcmV0dXJuIGNhY2hlZFNldHRpbmdzO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc1VwZGF0aW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcGVuZGluZ1VwZGF0ZXMuY3VycmVudC5zZXQodXNlcklkLCB0cnVlKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIGZldGNoIHNldHRpbmdzJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gcmVzdWx0LmRhdGEgfHwge307XG4gICAgICBcbiAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHNldHRpbmdzIGhhdmUgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgaWYgKCFpc0VxdWFsKHNldHRpbmdzW3VzZXJJZF0sIG5ld1NldHRpbmdzKSkge1xuICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBbdXNlcklkXTogbmV3U2V0dGluZ3NcbiAgICAgICAgfSkpO1xuICAgICAgICBzZXRDdXJyZW50U2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGNhY2hlXG4gICAgICAgIHNldHRpbmdzQ2FjaGUuY3VycmVudC5zZXQodXNlcklkLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldCh1c2VySWQsIG5vdyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgVG9wQmFyIGlmIHJlZiBwcm92aWRlZFxuICAgICAgICBpZiAocmVmICYmIHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncykge1xuICAgICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgcmV0dXJuIG5ld1NldHRpbmdzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbQWRtaW5TZXR0aW5nc10gRXJyb3IgZmV0Y2hpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gY2FjaGVkU2V0dGluZ3M7IC8vIFJldHVybiBjYWNoZWQgc2V0dGluZ3Mgb24gZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNVcGRhdGluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBwZW5kaW5nVXBkYXRlcy5jdXJyZW50LmRlbGV0ZSh1c2VySWQpO1xuICAgIH1cbiAgfSwgW3JlZiwgc2V0dGluZ3NdKTtcblxuICAvLyBEZWJvdW5jZWQgdmVyc2lvbiBvZiBmZXRjaFNldHRpbmdzRm9yVXNlclxuICBjb25zdCBkZWJvdW5jZWRGZXRjaFNldHRpbmdzID0gdXNlQ2FsbGJhY2soXG4gICAgZGVib3VuY2UoKHVzZXJJZCkgPT4ge1xuICAgICAgZmV0Y2hTZXR0aW5nc0ZvclVzZXIodXNlcklkKTtcbiAgICB9LCAxMDAwKSxcbiAgICBbZmV0Y2hTZXR0aW5nc0ZvclVzZXJdXG4gICk7XG5cbiAgLy8gUG9sbGluZyBmb3Igc2V0dGluZ3MgdXBkYXRlcyB3aXRoIGVuaGFuY2VkIG9wdGltaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGZldGNoU2V0dGluZ3MgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgaWYgKG5vdyAtIGxhc3RVcGRhdGVUaW1lIDwgTUlOX1VQREFURV9JTlRFUlZBTCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGRlYm91bmNlZEZldGNoU2V0dGluZ3MoY3VycmVudFVzZXJJZCk7XG4gICAgICAgIHNldExhc3RVcGRhdGVUaW1lKG5vdyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbQWRtaW5TZXR0aW5nc10gUG9sbGluZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWwgZmV0Y2hcbiAgICBmZXRjaFNldHRpbmdzKCk7XG4gICAgXG4gICAgLy8gU2V0IHVwIHBvbGxpbmcgd2l0aCBpbmNyZWFzZWQgaW50ZXJ2YWxcbiAgICBwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCA9IHNldEludGVydmFsKGZldGNoU2V0dGluZ3MsIFBPTExJTkdfSU5URVJWQUwpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocG9sbGluZ0ludGVydmFsLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWQsIGxhc3RVcGRhdGVUaW1lLCBkZWJvdW5jZWRGZXRjaFNldHRpbmdzXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VySWQgY2hhbmdlcyAoZnJvbSBpbmRleC5qcyBuYXZpZ2F0aW9uKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudXNlcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVXNlcklkQ2hhbmdlXSB1c2VySWQ6JywgZXZlbnQuZGV0YWlsLnVzZXJJZCk7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2N1cnJlbnRVc2VySWQnLCBuZXdVc2VySWQpO1xuICAgICAgICBmZXRjaFNldHRpbmdzRm9yVXNlcihuZXdVc2VySWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICB9LCBbcmVmXSk7XG5cbiAgLy8gSW5pdGlhbCBzZXR0aW5ncyBmZXRjaCBvbiBtb3VudCBpZiB3ZSBoYXZlIGEgdXNlciBJRFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChjdXJyZW50VXNlcklkICYmICFpbml0aWFsaXplZC5jdXJyZW50KSB7XG4gICAgICBmZXRjaFNldHRpbmdzRm9yVXNlcihjdXJyZW50VXNlcklkKTtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICAvLyBFZmZlY3QgdG8gaGFuZGxlIGluZGV4LmpzIHVwZGF0ZSBhZnRlciBUb3BCYXIgaXMgdXBkYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1RvcEJhclVwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdzZXR0aW5nc1VwZGF0ZWQnLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHR5cGU6ICdzZXR0aW5ncycsXG4gICAgICAgICAgdXNlcklkOiBjdXJyZW50VXNlcklkLFxuICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIHNldElzVG9wQmFyVXBkYXRlZChmYWxzZSk7XG4gICAgfVxuICB9LCBbaXNUb3BCYXJVcGRhdGVkLCBjdXJyZW50VXNlcklkLCBzZXR0aW5nc10pO1xuXG4gIC8vIExvYWQgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2Ugb24gbW91bnQgKG9wdGlvbmFsLCBmYWxsYmFjaylcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc2F2ZWRTZXR0aW5ncyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhZG1pblNldHRpbmdzJyk7XG4gICAgICBpZiAoc2F2ZWRTZXR0aW5ncykge1xuICAgICAgICBjb25zdCBwYXJzZWRTZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2F2ZWRTZXR0aW5ncyk7XG4gICAgICAgIHNldFNldHRpbmdzKHBhcnNlZFNldHRpbmdzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSWdub3JlXG4gICAgfVxuICB9LCBbXSk7XG5cbiAgLy8gU2F2ZSBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2Ugd2hlbiB0aGV5IGNoYW5nZSAob3B0aW9uYWwpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluaXRpYWxpemVkLmN1cnJlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhZG1pblNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtzZXR0aW5nc10pO1xuXG4gIC8vIFVwZGF0ZSBzZXR0aW5ncyB3aGVuIHRoZXkgY2hhbmdlIGluIHRoZSBjb250ZXh0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNldHRpbmdzICYmIGN1cnJlbnRVc2VySWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbc2V0dGluZ3MgdXNlRWZmZWN0XSBjdXJyZW50VXNlcklkOicsIGN1cnJlbnRVc2VySWQpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdO1xuICAgICAgaWYgKHVzZXJTZXR0aW5ncykge1xuICAgICAgICBzZXRDdXJyZW50U2V0dGluZ3ModXNlclNldHRpbmdzKTtcbiAgICAgICAgLy8gT3B0aW9uYWxseSB1cGRhdGUgVUkgZWxlbWVudHMgaWYgbmVlZGVkXG4gICAgICB9XG4gICAgfVxuICB9LCBbc2V0dGluZ3MsIGN1cnJlbnRVc2VySWRdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXMgZnJvbSBhZG1pbiBwYWdlIChjYXB0dXJlU2V0dGluZ3NVcGRhdGUgZXZlbnQpXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCB0aW1lcywgZGVsYXkgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc29sZS5sb2coJ1toYW5kbGVTZXR0aW5nc1VwZGF0ZV0gdXNlcklkOicsIHVzZXJJZCwgJ2N1cnJlbnRVc2VySWQ6JywgY3VycmVudFVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgICAgICBpZiAodXNlcklkID09PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAuLi5jdXJyZW50U2V0dGluZ3MsXG4gICAgICAgICAgICB0aW1lczogdGltZXMgIT09IHVuZGVmaW5lZCA/IE51bWJlcih0aW1lcykgOiBjdXJyZW50U2V0dGluZ3MudGltZXMsXG4gICAgICAgICAgICBkZWxheTogZGVsYXkgIT09IHVuZGVmaW5lZCA/IE51bWJlcihkZWxheSkgOiBjdXJyZW50U2V0dGluZ3MuZGVsYXlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHNldEN1cnJlbnRTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogbmV3U2V0dGluZ3MgfSkpO1xuICAgICAgICAgIHVwZGF0ZVNldHRpbmdzKG5ld1NldHRpbmdzLCB1c2VySWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICB9LCBbY3VycmVudFVzZXJJZCwgY3VycmVudFNldHRpbmdzXSk7XG5cbiAgLy8gVXBkYXRlIHNldHRpbmdzIGZvciBhIHVzZXIgd2l0aCBlbmhhbmNlZCBvcHRpbWl6YXRpb25cbiAgY29uc3QgdXBkYXRlU2V0dGluZ3MgPSB1c2VDYWxsYmFjayhhc3luYyAobmV3U2V0dGluZ3MsIHVzZXJJZCkgPT4ge1xuICAgIGlmICghdXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobm93IC0gbGFzdFVwZGF0ZVRpbWUgPCBNSU5fVVBEQVRFX0lOVEVSVkFMKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VwZGF0ZVNldHRpbmdzXSBTa2lwcGluZyB1cGRhdGUgLSB0b28gc29vbiBhZnRlciBsYXN0IHVwZGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHtcbiAgICAgIC4uLnNldHRpbmdzW3VzZXJJZF0sXG4gICAgICAuLi5uZXdTZXR0aW5nc1xuICAgIH07XG5cbiAgICAvLyBDaGVjayBpZiBzZXR0aW5ncyBoYXZlIGFjdHVhbGx5IGNoYW5nZWRcbiAgICBpZiAoaXNFcXVhbChzZXR0aW5nc1t1c2VySWRdLCB1cGRhdGVkU2V0dGluZ3MpKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VwZGF0ZVNldHRpbmdzXSBTZXR0aW5ncyB1bmNoYW5nZWQsIHNraXBwaW5nIHVwZGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc1VwZGF0aW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcGVuZGluZ1VwZGF0ZXMuY3VycmVudC5zZXQodXNlcklkLCB0cnVlKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU2V0dGluZ3MpXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gc2F2ZSBzZXR0aW5ncycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zdCBmaW5hbFNldHRpbmdzID0gcmVzdWx0LmRhdGEgfHwgdXBkYXRlZFNldHRpbmdzO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgYW5kIGNhY2hlXG4gICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBmaW5hbFNldHRpbmdzIH0pKTtcbiAgICAgIHNldEN1cnJlbnRTZXR0aW5ncyhmaW5hbFNldHRpbmdzKTtcbiAgICAgIHNldHRpbmdzQ2FjaGUuY3VycmVudC5zZXQodXNlcklkLCBmaW5hbFNldHRpbmdzKTtcbiAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldCh1c2VySWQsIG5vdyk7XG4gICAgICBzZXRMYXN0VXBkYXRlVGltZShub3cpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1VwZGF0aW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIHBlbmRpbmdVcGRhdGVzLmN1cnJlbnQuZGVsZXRlKHVzZXJJZCk7XG4gICAgfVxuICB9LCBbc2V0dGluZ3MsIGxhc3RVcGRhdGVUaW1lXSk7XG5cbiAgLy8gVXBsb2FkIGFuZCB1cGRhdGUgaW1hZ2UgZm9yIGEgdXNlclxuICBjb25zdCB1cGRhdGVJbWFnZSA9IGFzeW5jICh1c2VySWQsIGJhc2U2NEltYWdlKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1cGRhdGVJbWFnZV0gdXNlcklkOicsIHVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgIGlmICghdXNlcklkIHx8ICFiYXNlNjRJbWFnZSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL2ltYWdlP3VzZXJfaWQ9JHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbWFnZTogYmFzZTY0SW1hZ2UgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gdXBsb2FkIGltYWdlJyk7XG4gICAgICB9XG4gICAgICAvLyBPcHRpb25hbGx5LCBmZXRjaCBzZXR0aW5ncyBhZ2FpbiB0byBnZXQgdXBkYXRlZCBpbWFnZSBpbmZvXG4gICAgICBhd2FpdCBmZXRjaFNldHRpbmdzRm9yVXNlcih1c2VySWQpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncywgdXBkYXRlSW1hZ2UsIGVycm9yIH07XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBZG1pblNldHRpbmdzKCkge1xuICByZXR1cm4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsImRlYm91bmNlIiwiZnVuYyIsIndhaXQiLCJ0aW1lb3V0IiwiZXhlY3V0ZWRGdW5jdGlvbiIsImFyZ3MiLCJsYXRlciIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ1c2VBZG1pblNldHRpbmdzIiwicmVmIiwic2V0dGluZ3MiLCJzZXRTZXR0aW5ncyIsImN1cnJlbnRVc2VySWQiLCJzZXRDdXJyZW50VXNlcklkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImlzVG9wQmFyVXBkYXRlZCIsInNldElzVG9wQmFyVXBkYXRlZCIsImVycm9yIiwic2V0RXJyb3IiLCJpbml0aWFsaXplZCIsInBvbGxpbmdJbnRlcnZhbCIsImN1cnJlbnRTZXR0aW5ncyIsInNldEN1cnJlbnRTZXR0aW5ncyIsImxhc3RVcGRhdGVUaW1lIiwic2V0TGFzdFVwZGF0ZVRpbWUiLCJQT0xMSU5HX0lOVEVSVkFMIiwiTUlOX1VQREFURV9JTlRFUlZBTCIsIkNBQ0hFX0RVUkFUSU9OIiwic2V0dGluZ3NDYWNoZSIsIk1hcCIsImxhc3RTZXR0aW5nc1VwZGF0ZSIsInBlbmRpbmdVcGRhdGVzIiwiaXNVcGRhdGluZyIsImNvbnNvbGUiLCJsb2ciLCJmZXRjaFNldHRpbmdzRm9yVXNlciIsInVzZXJJZCIsImNhY2hlZFNldHRpbmdzIiwiY3VycmVudCIsImdldCIsImxhc3RVcGRhdGUiLCJub3ciLCJEYXRlIiwiaGFzIiwic2V0IiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0tFWSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwiRXJyb3IiLCJkZXRhaWwiLCJyZXN1bHQiLCJuZXdTZXR0aW5ncyIsImRhdGEiLCJwcmV2Iiwic2V0Q2FwdHVyZVNldHRpbmdzIiwibWVzc2FnZSIsImRlbGV0ZSIsImRlYm91bmNlZEZldGNoU2V0dGluZ3MiLCJmZXRjaFNldHRpbmdzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJuZXdVc2VySWQiLCJzZXRJdGVtIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJDdXN0b21FdmVudCIsInR5cGUiLCJkaXNwYXRjaEV2ZW50Iiwic2F2ZWRTZXR0aW5ncyIsInBhcnNlZFNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwidXNlclNldHRpbmdzIiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJ0aW1lcyIsImRlbGF5IiwidW5kZWZpbmVkIiwiTnVtYmVyIiwidXBkYXRlU2V0dGluZ3MiLCJ1cGRhdGVkU2V0dGluZ3MiLCJtZXRob2QiLCJib2R5IiwiZmluYWxTZXR0aW5ncyIsInVwZGF0ZUltYWdlIiwiYmFzZTY0SW1hZ2UiLCJpbWFnZSIsIkFkbWluU2V0dGluZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});