"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useAdminSettings.useState\": ()=>{\n            // Initialize from localStorage on mount\n            return localStorage.getItem('currentUserId');\n        }\n    }[\"useAdminSettings.useState\"]);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [lastUpdateTime, setLastUpdateTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const POLLING_INTERVAL = 10000; // Increase to 10 seconds\n    const MIN_UPDATE_INTERVAL = 2000; // Minimum time between updates\n    // Debug logging for settings changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            console.log('AdminSettings - Current Settings:', settings);\n            console.log('AdminSettings - Current User ID:', currentUserId);\n            console.log('AdminSettings - Is TopBar Updated:', isTopBarUpdated);\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId,\n        isTopBarUpdated\n    ]);\n    // Helper: Fetch settings for a user from backend\n    const fetchSettingsForUser = async (userId)=>{\n        console.log('[AdminSettings] fetchSettingsForUser - userId:', userId);\n        if (!userId) return;\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to fetch settings');\n            }\n            const result = await response.json();\n            console.log('[AdminSettings] fetchSettingsForUser - Received settings:', result.data);\n            // result.data contains the settings object\n            const newSettings = result.data || {};\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: newSettings\n                }));\n            setCurrentSettings(newSettings);\n            setError(null);\n            // Update TopBar if ref provided\n            if (ref && ref.current && ref.current.setCaptureSettings) {\n                console.log('[AdminSettings] Updating TopBar with settings:', newSettings);\n                ref.current.setCaptureSettings(newSettings);\n                setIsTopBarUpdated(true);\n            }\n            return newSettings;\n        } catch (error) {\n            console.error('[AdminSettings] Error fetching settings:', error);\n            setError(error.message);\n            return null;\n        }\n    };\n    // Polling for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (!currentUserId) return;\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    const now = Date.now();\n                    if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                        return; // Skip if last update was too recent\n                    }\n                    try {\n                        const newSettings = await fetchSettingsForUser(currentUserId);\n                        if (newSettings) {\n                            setLastUpdateTime(now);\n                        }\n                    } catch (error) {\n                        console.error('[AdminSettings] Polling error:', error);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            fetchSettings();\n            pollingInterval.current = setInterval(fetchSettings, POLLING_INTERVAL);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref,\n        lastUpdateTime\n    ]);\n    // Listen for userId changes (from index.js navigation)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        console.log('[handleUserIdChange] userId:', event.detail.userId);\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        localStorage.setItem('currentUserId', newUserId);\n                        fetchSettingsForUser(newUserId);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Initial settings fetch on mount if we have a user ID\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (currentUserId && !initialized.current) {\n                fetchSettingsForUser(currentUserId);\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId\n    ]);\n    // Effect to handle index.js update after TopBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount (optional, fallback)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n            // Ignore\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {}\n            } else {\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('[settings useEffect] currentUserId:', currentUserId); // Debug log\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                // Optionally update UI elements if needed\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page (captureSettingsUpdate event)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        console.log('[handleSettingsUpdate] userId:', userId, 'currentUserId:', currentUserId); // Debug log\n                        if (userId === currentUserId) {\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            updateSettings(newSettings, userId);\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    // Update settings for a user (times, delay, image, etc.)\n    const updateSettings = async (newSettings, userId)=>{\n        console.log('[updateSettings] userId:', userId);\n        if (!userId) return;\n        const now = Date.now();\n        if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n            console.log('[updateSettings] Skipping update - too soon after last update');\n            return;\n        }\n        const updatedSettings = {\n            ...settings[userId],\n            ...newSettings\n        };\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify(updatedSettings)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to save settings');\n            }\n            const result = await response.json();\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: result.data || updatedSettings\n                }));\n            setCurrentSettings(result.data || updatedSettings);\n            setLastUpdateTime(now);\n            setError(null);\n        } catch (error) {\n            setError(error.message);\n        }\n    };\n    // Upload and update image for a user\n    const updateImage = async (userId, base64Image)=>{\n        console.log('[updateImage] userId:', userId); // Debug log\n        if (!userId || !base64Image) return;\n        try {\n            const response = await fetch(\"/api/data-center/image?user_id=\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify({\n                    image: base64Image\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to upload image');\n            }\n            // Optionally, fetch settings again to get updated image info\n            await fetchSettingsForUser(userId);\n            setError(null);\n            return true;\n        } catch (error) {\n            setError(error.message);\n            return false;\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        updateImage,\n        error\n    };\n};\n_s(useAdminSettings, \"CfbQ1vD3AuYVsQq6vjQvloqvJ9U=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFFN0MsTUFBTUcsbUJBQW1CLENBQUNDOztJQUMvQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR0osK0NBQVFBLENBQUMsQ0FBQztJQUMxQyxNQUFNLENBQUNLLGVBQWVDLGlCQUFpQixHQUFHTiwrQ0FBUUE7cUNBQUM7WUFDakQsd0NBQXdDO1lBQ3hDLE9BQU9PLGFBQWFDLE9BQU8sQ0FBQztRQUM5Qjs7SUFDQSxNQUFNLENBQUNDLGlCQUFpQkMsbUJBQW1CLEdBQUdWLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ1csT0FBT0MsU0FBUyxHQUFHWiwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNYSxjQUFjZCw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNZSxrQkFBa0JmLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ2dCLGlCQUFpQkMsbUJBQW1CLEdBQUdoQiwrQ0FBUUEsQ0FBQyxDQUFDO0lBQ3hELE1BQU0sQ0FBQ2lCLGdCQUFnQkMsa0JBQWtCLEdBQUdsQiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNbUIsbUJBQW1CLE9BQU8seUJBQXlCO0lBQ3pELE1BQU1DLHNCQUFzQixNQUFNLCtCQUErQjtJQUVqRSxxQ0FBcUM7SUFDckN0QixnREFBU0E7c0NBQUM7WUFDUnVCLFFBQVFDLEdBQUcsQ0FBQyxxQ0FBcUNuQjtZQUNqRGtCLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0NqQjtZQUNoRGdCLFFBQVFDLEdBQUcsQ0FBQyxzQ0FBc0NiO1FBQ3BEO3FDQUFHO1FBQUNOO1FBQVVFO1FBQWVJO0tBQWdCO0lBRTdDLGlEQUFpRDtJQUNqRCxNQUFNYyx1QkFBdUIsT0FBT0M7UUFDbENILFFBQVFDLEdBQUcsQ0FBQyxrREFBa0RFO1FBQzlELElBQUksQ0FBQ0EsUUFBUTtR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Q0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtnQkFDbEQ7Z0JBQ0EyQyxNQUFNWixLQUFLRSxTQUFTLENBQUM7b0JBQUVhLE9BQU9EO2dCQUFZO1lBQzVDO1lBQ0EsSUFBSSxDQUFDbEQsU0FBU00sRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1QLFNBQVNRLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJQyxNQUFNSCxVQUFVSSxNQUFNLElBQUk7WUFDdEM7WUFDQSw2REFBNkQ7WUFDN0QsTUFBTWIscUJBQXFCQztZQUMzQlosU0FBUztZQUNULE9BQU87UUFDVCxFQUFFLE9BQU9ELE9BQU87WUFDZEMsU0FBU0QsTUFBTWdDLE9BQU87WUFDdEIsT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPO1FBQUV4QztRQUFVbUU7UUFBZ0JJO1FBQWEvRDtJQUFNO0FBQ3hELEVBQUU7R0FuUVdWO0FBcVFiLCtCQUErQjtBQUNoQixTQUFTNEU7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtLQUZ3QkEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FkbWluU2V0dGluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgY29uc3QgdXNlQWRtaW5TZXR0aW5ncyA9IChyZWYpID0+IHtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJyZW50VXNlcklkJyk7XG4gIH0pO1xuICBjb25zdCBbaXNUb3BCYXJVcGRhdGVkLCBzZXRJc1RvcEJhclVwZGF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRTZXR0aW5ncywgc2V0Q3VycmVudFNldHRpbmdzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW2xhc3RVcGRhdGVUaW1lLCBzZXRMYXN0VXBkYXRlVGltZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgUE9MTElOR19JTlRFUlZBTCA9IDEwMDAwOyAvLyBJbmNyZWFzZSB0byAxMCBzZWNvbmRzXG4gIGNvbnN0IE1JTl9VUERBVEVfSU5URVJWQUwgPSAyMDAwOyAvLyBNaW5pbXVtIHRpbWUgYmV0d2VlbiB1cGRhdGVzXG5cbiAgLy8gRGVidWcgbG9nZ2luZyBmb3Igc2V0dGluZ3MgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gQ3VycmVudCBTZXR0aW5nczonLCBzZXR0aW5ncyk7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBDdXJyZW50IFVzZXIgSUQ6JywgY3VycmVudFVzZXJJZCk7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBJcyBUb3BCYXIgVXBkYXRlZDonLCBpc1RvcEJhclVwZGF0ZWQpO1xuICB9LCBbc2V0dGluZ3MsIGN1cnJlbnRVc2VySWQsIGlzVG9wQmFyVXBkYXRlZF0pO1xuXG4gIC8vIEhlbHBlcjogRmV0Y2ggc2V0dGluZ3MgZm9yIGEgdXNlciBmcm9tIGJhY2tlbmRcbiAgY29uc3QgZmV0Y2hTZXR0aW5nc0ZvclVzZXIgPSBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBmZXRjaFNldHRpbmdzRm9yVXNlciAtIHVzZXJJZDonLCB1c2VySWQpO1xuICAgIGlmICghdXNlcklkKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvc2V0dGluZ3MvJHt1c2VySWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZmV0Y2ggc2V0dGluZ3MnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbQWRtaW5TZXR0aW5nc10gZmV0Y2hTZXR0aW5nc0ZvclVzZXIgLSBSZWNlaXZlZCBzZXR0aW5nczonLCByZXN1bHQuZGF0YSk7XG4gICAgICBcbiAgICAgIC8vIHJlc3VsdC5kYXRhIGNvbnRhaW5zIHRoZSBzZXR0aW5ncyBvYmplY3RcbiAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gcmVzdWx0LmRhdGEgfHwge307XG4gICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFt1c2VySWRdOiBuZXdTZXR0aW5nc1xuICAgICAgfSkpO1xuICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgVG9wQmFyIGlmIHJlZiBwcm92aWRlZFxuICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCAmJiByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBVcGRhdGluZyBUb3BCYXIgd2l0aCBzZXR0aW5nczonLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgIHNldElzVG9wQmFyVXBkYXRlZCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTZXR0aW5ncztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0FkbWluU2V0dGluZ3NdIEVycm9yIGZldGNoaW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBvbGxpbmcgZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRVc2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBmZXRjaFNldHRpbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBTa2lwIGlmIGxhc3QgdXBkYXRlIHdhcyB0b28gcmVjZW50XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gYXdhaXQgZmV0Y2hTZXR0aW5nc0ZvclVzZXIoY3VycmVudFVzZXJJZCk7XG4gICAgICAgIGlmIChuZXdTZXR0aW5ncykge1xuICAgICAgICAgIHNldExhc3RVcGRhdGVUaW1lKG5vdyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBZG1pblNldHRpbmdzXSBQb2xsaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZmV0Y2hTZXR0aW5ncygpO1xuICAgIHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoZmV0Y2hTZXR0aW5ncywgUE9MTElOR19JTlRFUlZBTCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZCwgcmVmLCBsYXN0VXBkYXRlVGltZV0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlcklkIGNoYW5nZXMgKGZyb20gaW5kZXguanMgbmF2aWdhdGlvbilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVVzZXJJZENoYW5nZV0gdXNlcklkOicsIGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VXNlcklkJywgbmV3VXNlcklkKTtcbiAgICAgICAgZmV0Y2hTZXR0aW5nc0ZvclVzZXIobmV3VXNlcklkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgfSwgW3JlZl0pO1xuXG4gIC8vIEluaXRpYWwgc2V0dGluZ3MgZmV0Y2ggb24gbW91bnQgaWYgd2UgaGF2ZSBhIHVzZXIgSURcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3VycmVudFVzZXJJZCAmJiAhaW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgZmV0Y2hTZXR0aW5nc0ZvclVzZXIoY3VycmVudFVzZXJJZCk7XG4gICAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gRWZmZWN0IHRvIGhhbmRsZSBpbmRleC5qcyB1cGRhdGUgYWZ0ZXIgVG9wQmFyIGlzIHVwZGF0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNUb3BCYXJVcGRhdGVkKSB7XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2V0dGluZ3NVcGRhdGVkJywge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICB0eXBlOiAnc2V0dGluZ3MnLFxuICAgICAgICAgIHVzZXJJZDogY3VycmVudFVzZXJJZCxcbiAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3NbY3VycmVudFVzZXJJZF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICBzZXRJc1RvcEJhclVwZGF0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2lzVG9wQmFyVXBkYXRlZCwgY3VycmVudFVzZXJJZCwgc2V0dGluZ3NdKTtcblxuICAvLyBMb2FkIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50IChvcHRpb25hbCwgZmFsbGJhY2spXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5TZXR0aW5ncycpO1xuICAgICAgaWYgKHNhdmVkU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkU2V0dGluZ3MgPSBKU09OLnBhcnNlKHNhdmVkU2V0dGluZ3MpO1xuICAgICAgICBzZXRTZXR0aW5ncyhwYXJzZWRTZXR0aW5ncyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlIHdoZW4gdGhleSBjaGFuZ2UgKG9wdGlvbmFsKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbml0aWFsaXplZC5jdXJyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWRtaW5TZXR0aW5ncycsIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBVcGRhdGUgc2V0dGluZ3Mgd2hlbiB0aGV5IGNoYW5nZSBpbiB0aGUgY29udGV4dFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3NldHRpbmdzIHVzZUVmZmVjdF0gY3VycmVudFVzZXJJZDonLCBjdXJyZW50VXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGlmICh1c2VyU2V0dGluZ3MpIHtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIC8vIE9wdGlvbmFsbHkgdXBkYXRlIFVJIGVsZW1lbnRzIGlmIG5lZWRlZFxuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzIGZyb20gYWRtaW4gcGFnZSAoY2FwdHVyZVNldHRpbmdzVXBkYXRlIGV2ZW50KVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAnY2FwdHVyZVNldHRpbmdzJykge1xuICAgICAgICBjb25zdCB7IHVzZXJJZCwgdGltZXMsIGRlbGF5IH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlU2V0dGluZ3NVcGRhdGVdIHVzZXJJZDonLCB1c2VySWQsICdjdXJyZW50VXNlcklkOicsIGN1cnJlbnRVc2VySWQpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0ge1xuICAgICAgICAgICAgLi4uY3VycmVudFNldHRpbmdzLFxuICAgICAgICAgICAgdGltZXM6IHRpbWVzICE9PSB1bmRlZmluZWQgPyBOdW1iZXIodGltZXMpIDogY3VycmVudFNldHRpbmdzLnRpbWVzLFxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5ICE9PSB1bmRlZmluZWQgPyBOdW1iZXIoZGVsYXkpIDogY3VycmVudFNldHRpbmdzLmRlbGF5XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRDdXJyZW50U2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IG5ld1NldHRpbmdzIH0pKTtcbiAgICAgICAgICB1cGRhdGVTZXR0aW5ncyhuZXdTZXR0aW5ncywgdXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgfSwgW2N1cnJlbnRVc2VySWQsIGN1cnJlbnRTZXR0aW5nc10pO1xuXG4gIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgYSB1c2VyICh0aW1lcywgZGVsYXksIGltYWdlLCBldGMuKVxuICBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IGFzeW5jIChuZXdTZXR0aW5ncywgdXNlcklkKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1cGRhdGVTZXR0aW5nc10gdXNlcklkOicsIHVzZXJJZCk7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlU2V0dGluZ3NdIFNraXBwaW5nIHVwZGF0ZSAtIHRvbyBzb29uIGFmdGVyIGxhc3QgdXBkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3NbdXNlcklkXSxcbiAgICAgIC4uLm5ld1NldHRpbmdzXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRTZXR0aW5ncylcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBzYXZlIHNldHRpbmdzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IHJlc3VsdC5kYXRhIHx8IHVwZGF0ZWRTZXR0aW5ncyB9KSk7XG4gICAgICBzZXRDdXJyZW50U2V0dGluZ3MocmVzdWx0LmRhdGEgfHwgdXBkYXRlZFNldHRpbmdzKTtcbiAgICAgIHNldExhc3RVcGRhdGVUaW1lKG5vdyk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFVwbG9hZCBhbmQgdXBkYXRlIGltYWdlIGZvciBhIHVzZXJcbiAgY29uc3QgdXBkYXRlSW1hZ2UgPSBhc3luYyAodXNlcklkLCBiYXNlNjRJbWFnZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlSW1hZ2VdIHVzZXJJZDonLCB1c2VySWQpOyAvLyBEZWJ1ZyBsb2dcbiAgICBpZiAoIXVzZXJJZCB8fCAhYmFzZTY0SW1hZ2UpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9pbWFnZT91c2VyX2lkPSR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgaW1hZ2U6IGJhc2U2NEltYWdlIH0pXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIHVwbG9hZCBpbWFnZScpO1xuICAgICAgfVxuICAgICAgLy8gT3B0aW9uYWxseSwgZmV0Y2ggc2V0dGluZ3MgYWdhaW4gdG8gZ2V0IHVwZGF0ZWQgaW1hZ2UgaW5mb1xuICAgICAgYXdhaXQgZmV0Y2hTZXR0aW5nc0ZvclVzZXIodXNlcklkKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MsIHVwZGF0ZUltYWdlLCBlcnJvciB9O1xufTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWRtaW5TZXR0aW5ncygpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQWRtaW5TZXR0aW5ncyIsInJlZiIsInNldHRpbmdzIiwic2V0U2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJpc1RvcEJhclVwZGF0ZWQiLCJzZXRJc1RvcEJhclVwZGF0ZWQiLCJlcnJvciIsInNldEVycm9yIiwiaW5pdGlhbGl6ZWQiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjdXJyZW50U2V0dGluZ3MiLCJzZXRDdXJyZW50U2V0dGluZ3MiLCJsYXN0VXBkYXRlVGltZSIsInNldExhc3RVcGRhdGVUaW1lIiwiUE9MTElOR19JTlRFUlZBTCIsIk1JTl9VUERBVEVfSU5URVJWQUwiLCJjb25zb2xlIiwibG9nIiwiZmV0Y2hTZXR0aW5nc0ZvclVzZXIiLCJ1c2VySWQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfS0VZIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsImRldGFpbCIsInJlc3VsdCIsImRhdGEiLCJuZXdTZXR0aW5ncyIsInByZXYiLCJjdXJyZW50Iiwic2V0Q2FwdHVyZVNldHRpbmdzIiwibWVzc2FnZSIsImZldGNoU2V0dGluZ3MiLCJub3ciLCJEYXRlIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJuZXdVc2VySWQiLCJzZXRJdGVtIiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJDdXN0b21FdmVudCIsInR5cGUiLCJkaXNwYXRjaEV2ZW50Iiwic2F2ZWRTZXR0aW5ncyIsInBhcnNlZFNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5IiwidXNlclNldHRpbmdzIiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJ0aW1lcyIsImRlbGF5IiwidW5kZWZpbmVkIiwiTnVtYmVyIiwidXBkYXRlU2V0dGluZ3MiLCJ1cGRhdGVkU2V0dGluZ3MiLCJtZXRob2QiLCJib2R5IiwidXBkYXRlSW1hZ2UiLCJiYXNlNjRJbWFnZSIsImltYWdlIiwiQWRtaW5TZXR0aW5ncyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});