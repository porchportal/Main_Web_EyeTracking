"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\n// Deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || obj1 === null || typeof obj2 !== 'object' || obj2 === null) {\n        return false;\n    }\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>isEqual(obj1[key], obj2[key]));\n};\n// Cache for settings\nconst settingsCache = new Map();\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useAdminSettings.useState\": ()=>{\n            // Initialize from localStorage on mount\n            return localStorage.getItem('currentUserId');\n        }\n    }[\"useAdminSettings.useState\"]);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [lastUpdateTime, setLastUpdateTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const POLLING_INTERVAL = 10000; // Increase to 10 seconds\n    const MIN_UPDATE_INTERVAL = 2000; // Minimum time between updates\n    const lastSettingsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    // Debug logging for settings changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            console.log('AdminSettings - Current Settings:', settings);\n            console.log('AdminSettings - Current User ID:', currentUserId);\n            console.log('AdminSettings - Is TopBar Updated:', isTopBarUpdated);\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId,\n        isTopBarUpdated\n    ]);\n    // Helper: Fetch settings for a user from backend\n    const fetchSettingsForUser = async (userId)=>{\n        console.log('[AdminSettings] fetchSettingsForUser - userId:', userId);\n        if (!userId) return;\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to fetch settings');\n            }\n            const result = await response.json();\n            console.log('[AdminSettings] fetchSettingsForUser - Received settings:', result.data);\n            const newSettings = result.data || {};\n            // Check if settings have actually changed\n            const cachedSettings = settingsCache.get(userId);\n            if (cachedSettings && isEqual(cachedSettings, newSettings)) {\n                console.log('[AdminSettings] Settings unchanged, skipping update');\n                return cachedSettings;\n            }\n            // Update cache and state\n            settingsCache.set(userId, newSettings);\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: newSettings\n                }));\n            setCurrentSettings(newSettings);\n            setError(null);\n            // Update TopBar if ref provided\n            if (ref && ref.current && ref.current.setCaptureSettings) {\n                console.log('[AdminSettings] Updating TopBar with settings:', newSettings);\n                ref.current.setCaptureSettings(newSettings);\n                setIsTopBarUpdated(true);\n            }\n            return newSettings;\n        } catch (error) {\n            console.error('[AdminSettings] Error fetching settings:', error);\n            setError(error.message);\n            return null;\n        }\n    };\n    // Polling for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (!currentUserId) return;\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    const now = Date.now();\n                    if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                        return; // Skip if last update was too recent\n                    }\n                    try {\n                        const newSettings = await fetchSettingsForUser(currentUserId);\n                        if (newSettings) {\n                            setLastUpdateTime(now);\n                        }\n                    } catch (error) {\n                        console.error('[AdminSettings] Polling error:', error);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            fetchSettings();\n            pollingInterval.current = setInterval(fetchSettings, POLLING_INTERVAL);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref,\n        lastUpdateTime\n    ]);\n    // Listen for userId changes (from index.js navigation)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        console.log('[handleUserIdChange] userId:', event.detail.userId);\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        localStorage.setItem('currentUserId', newUserId);\n                        fetchSettingsForUser(newUserId);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Initial settings fetch on mount if we have a user ID\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (currentUserId && !initialized.current) {\n                fetchSettingsForUser(currentUserId);\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId\n    ]);\n    // Effect to handle index.js update after TopBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount (optional, fallback)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n            // Ignore\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {}\n            } else {\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('[settings useEffect] currentUserId:', currentUserId); // Debug log\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                // Optionally update UI elements if needed\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page (captureSettingsUpdate event)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        console.log('[handleSettingsUpdate] userId:', userId, 'currentUserId:', currentUserId); // Debug log\n                        if (userId === currentUserId) {\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            updateSettings(newSettings, userId);\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    // Update settings for a user with caching\n    const updateSettings = async (newSettings, userId)=>{\n        console.log('[updateSettings] userId:', userId);\n        if (!userId) return;\n        const now = Date.now();\n        if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n            console.log('[updateSettings] Skipping update - too soon after last update');\n            return;\n        }\n        const updatedSettings = {\n            ...settings[userId],\n            ...newSettings\n        };\n        // Check if settings have actually changed\n        const cachedSettings = settingsCache.get(userId);\n        if (cachedSettings && isEqual(cachedSettings, updatedSettings)) {\n            console.log('[updateSettings] Settings unchanged, skipping API call');\n            return;\n        }\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify(updatedSettings)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to save settings');\n            }\n            const result = await response.json();\n            const finalSettings = result.data || updatedSettings;\n            // Update cache\n            settingsCache.set(userId, finalSettings);\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: finalSettings\n                }));\n            setCurrentSettings(finalSettings);\n            setLastUpdateTime(now);\n            setError(null);\n        } catch (error) {\n            setError(error.message);\n        }\n    };\n    // Upload and update image for a user\n    const updateImage = async (userId, base64Image)=>{\n        console.log('[updateImage] userId:', userId); // Debug log\n        if (!userId || !base64Image) return;\n        try {\n            const response = await fetch(\"/api/data-center/image?user_id=\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify({\n                    image: base64Image\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to upload image');\n            }\n            // Optionally, fetch settings again to get updated image info\n            await fetchSettingsForUser(userId);\n            setError(null);\n            return true;\n        } catch (error) {\n            setError(error.message);\n            return false;\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        updateImage,\n        error\n    };\n};\n_s(useAdminSettings, \"CuKbNCTFYKGOyisX1csn/6jpOmE=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFFcEQsMEJBQTBCO0FBQzFCLE1BQU1HLFVBQVUsQ0FBQ0MsTUFBTUM7SUFDckIsSUFBSUQsU0FBU0MsTUFBTSxPQUFPO0lBQzFCLElBQUksT0FBT0QsU0FBUyxZQUFZQSxTQUFTLFFBQVEsT0FBT0MsU0FBUyxZQUFZQSxTQUFTLE1BQU07UUFDMUYsT0FBTztJQUNUO0lBQ0EsTUFBTUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSjtJQUMxQixNQUFNSyxRQUFRRixPQUFPQyxJQUFJLENBQUNIO0lBQzFCLElBQUlDLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFLE9BQU87SUFDMUMsT0FBT0osTUFBTUssS0FBSyxDQUFDQyxDQUFBQSxNQUFPVCxRQUFRQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO0FBQ3hEO0FBRUEscUJBQXFCO0FBQ3JCLE1BQU1DLGdCQUFnQixJQUFJQztBQUVuQixNQUFNQyxtQkFBbUIsQ0FBQ0M7O0lBQy9CLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHaEIsK0NBQVFBLENBQUMsQ0FBQztJQUMxQyxNQUFNLENBQUNpQixlQUFlQyxpQkFBaUIsR0FBR2xCLCtDQUFRQTtxQ0FBQztZQUNqRCx3Q0FBd0M7WUFDeEMsT0FBT21CLGFBQWFDLE9BQU8sQ0FBQztRQUM5Qjs7SUFDQSxNQUFNLENBQUNDLGlCQUFpQkMsbUJBQW1CLEdBQUd0QiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUN1QixPQUFPQyxTQUFTLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNeUIsY0FBYzFCLDZDQUFNQSxDQUFDO0lBQzNCLE1BQU0yQixrQkFBa0IzQiw2Q0FBTUEsQ0FBQztJQUMvQixNQUFNLENBQUM0QixpQkFB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NUM7WUFDQSxJQUFJLENBQUN0RCxTQUFTTSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTVAsU0FBU1EsSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTyxFQUFDO2dCQUN0RCxNQUFNLElBQUlDLE1BQU1ILFVBQVVJLE1BQU0sSUFBSTtZQUN0QztZQUNBLDZEQUE2RDtZQUM3RCxNQUFNYixxQkFBcUJDO1lBQzNCYixTQUFTO1lBQ1QsT0FBTztRQUNULEVBQUUsT0FBT0QsT0FBTztZQUNkQyxTQUFTRCxNQUFNb0MsT0FBTztZQUN0QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLE9BQU87UUFBRTVDO1FBQVV1RTtRQUFnQks7UUFBYXBFO0lBQU07QUFDeEQsRUFBRTtHQXpSV1Y7QUEyUmIsK0JBQStCO0FBQ2hCLFNBQVNpRjtJQUN0QixPQUFPLE1BQU0sOERBQThEO0FBQzdFO0tBRndCQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbi8vIERlZXAgY29tcGFyaXNvbiB1dGlsaXR5XG5jb25zdCBpc0VxdWFsID0gKG9iajEsIG9iajIpID0+IHtcbiAgaWYgKG9iajEgPT09IG9iajIpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iajEgIT09ICdvYmplY3QnIHx8IG9iajEgPT09IG51bGwgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnIHx8IG9iajIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gaXNFcXVhbChvYmoxW2tleV0sIG9iajJba2V5XSkpO1xufTtcblxuLy8gQ2FjaGUgZm9yIHNldHRpbmdzXG5jb25zdCBzZXR0aW5nc0NhY2hlID0gbmV3IE1hcCgpO1xuXG5leHBvcnQgY29uc3QgdXNlQWRtaW5TZXR0aW5ncyA9IChyZWYpID0+IHtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBJbml0aWFsaXplIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjdXJyZW50VXNlcklkJyk7XG4gIH0pO1xuICBjb25zdCBbaXNUb3BCYXJVcGRhdGVkLCBzZXRJc1RvcEJhclVwZGF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRTZXR0aW5ncywgc2V0Q3VycmVudFNldHRpbmdzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW2xhc3RVcGRhdGVUaW1lLCBzZXRMYXN0VXBkYXRlVGltZV0gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgUE9MTElOR19JTlRFUlZBTCA9IDEwMDAwOyAvLyBJbmNyZWFzZSB0byAxMCBzZWNvbmRzXG4gIGNvbnN0IE1JTl9VUERBVEVfSU5URVJWQUwgPSAyMDAwOyAvLyBNaW5pbXVtIHRpbWUgYmV0d2VlbiB1cGRhdGVzXG4gIGNvbnN0IGxhc3RTZXR0aW5nc1JlZiA9IHVzZVJlZih7fSk7XG5cbiAgLy8gRGVidWcgbG9nZ2luZyBmb3Igc2V0dGluZ3MgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gQ3VycmVudCBTZXR0aW5nczonLCBzZXR0aW5ncyk7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBDdXJyZW50IFVzZXIgSUQ6JywgY3VycmVudFVzZXJJZCk7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBJcyBUb3BCYXIgVXBkYXRlZDonLCBpc1RvcEJhclVwZGF0ZWQpO1xuICB9LCBbc2V0dGluZ3MsIGN1cnJlbnRVc2VySWQsIGlzVG9wQmFyVXBkYXRlZF0pO1xuXG4gIC8vIEhlbHBlcjogRmV0Y2ggc2V0dGluZ3MgZm9yIGEgdXNlciBmcm9tIGJhY2tlbmRcbiAgY29uc3QgZmV0Y2hTZXR0aW5nc0ZvclVzZXIgPSBhc3luYyAodXNlcklkKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBmZXRjaFNldHRpbmdzRm9yVXNlciAtIHVzZXJJZDonLCB1c2VySWQpO1xuICAgIGlmICghdXNlcklkKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvc2V0dGluZ3MvJHt1c2VySWR9YCwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZmV0Y2ggc2V0dGluZ3MnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbQWRtaW5TZXR0aW5nc10gZmV0Y2hTZXR0aW5nc0ZvclVzZXIgLSBSZWNlaXZlZCBzZXR0aW5nczonLCByZXN1bHQuZGF0YSk7XG4gICAgICBcbiAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gcmVzdWx0LmRhdGEgfHwge307XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHNldHRpbmdzIGhhdmUgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgY29uc3QgY2FjaGVkU2V0dGluZ3MgPSBzZXR0aW5nc0NhY2hlLmdldCh1c2VySWQpO1xuICAgICAgaWYgKGNhY2hlZFNldHRpbmdzICYmIGlzRXF1YWwoY2FjaGVkU2V0dGluZ3MsIG5ld1NldHRpbmdzKSkge1xuICAgICAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIFNldHRpbmdzIHVuY2hhbmdlZCwgc2tpcHBpbmcgdXBkYXRlJyk7XG4gICAgICAgIHJldHVybiBjYWNoZWRTZXR0aW5ncztcbiAgICAgIH1cblxuICAgICAgLy8gVXBkYXRlIGNhY2hlIGFuZCBzdGF0ZVxuICAgICAgc2V0dGluZ3NDYWNoZS5zZXQodXNlcklkLCBuZXdTZXR0aW5ncyk7XG4gICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFt1c2VySWRdOiBuZXdTZXR0aW5nc1xuICAgICAgfSkpO1xuICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgVG9wQmFyIGlmIHJlZiBwcm92aWRlZFxuICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCAmJiByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBVcGRhdGluZyBUb3BCYXIgd2l0aCBzZXR0aW5nczonLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgIHNldElzVG9wQmFyVXBkYXRlZCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTZXR0aW5ncztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0FkbWluU2V0dGluZ3NdIEVycm9yIGZldGNoaW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFBvbGxpbmcgZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRVc2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBmZXRjaFNldHRpbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBTa2lwIGlmIGxhc3QgdXBkYXRlIHdhcyB0b28gcmVjZW50XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gYXdhaXQgZmV0Y2hTZXR0aW5nc0ZvclVzZXIoY3VycmVudFVzZXJJZCk7XG4gICAgICAgIGlmIChuZXdTZXR0aW5ncykge1xuICAgICAgICAgIHNldExhc3RVcGRhdGVUaW1lKG5vdyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBZG1pblNldHRpbmdzXSBQb2xsaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZmV0Y2hTZXR0aW5ncygpO1xuICAgIHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoZmV0Y2hTZXR0aW5ncywgUE9MTElOR19JTlRFUlZBTCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZCwgcmVmLCBsYXN0VXBkYXRlVGltZV0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlcklkIGNoYW5nZXMgKGZyb20gaW5kZXguanMgbmF2aWdhdGlvbilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVVzZXJJZENoYW5nZV0gdXNlcklkOicsIGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdjdXJyZW50VXNlcklkJywgbmV3VXNlcklkKTtcbiAgICAgICAgZmV0Y2hTZXR0aW5nc0ZvclVzZXIobmV3VXNlcklkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgfSwgW3JlZl0pO1xuXG4gIC8vIEluaXRpYWwgc2V0dGluZ3MgZmV0Y2ggb24gbW91bnQgaWYgd2UgaGF2ZSBhIHVzZXIgSURcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY3VycmVudFVzZXJJZCAmJiAhaW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgZmV0Y2hTZXR0aW5nc0ZvclVzZXIoY3VycmVudFVzZXJJZCk7XG4gICAgICBpbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gRWZmZWN0IHRvIGhhbmRsZSBpbmRleC5qcyB1cGRhdGUgYWZ0ZXIgVG9wQmFyIGlzIHVwZGF0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNUb3BCYXJVcGRhdGVkKSB7XG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnc2V0dGluZ3NVcGRhdGVkJywge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICB0eXBlOiAnc2V0dGluZ3MnLFxuICAgICAgICAgIHVzZXJJZDogY3VycmVudFVzZXJJZCxcbiAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3NbY3VycmVudFVzZXJJZF1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICBzZXRJc1RvcEJhclVwZGF0ZWQoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2lzVG9wQmFyVXBkYXRlZCwgY3VycmVudFVzZXJJZCwgc2V0dGluZ3NdKTtcblxuICAvLyBMb2FkIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlIG9uIG1vdW50IChvcHRpb25hbCwgZmFsbGJhY2spXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnYWRtaW5TZXR0aW5ncycpO1xuICAgICAgaWYgKHNhdmVkU2V0dGluZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkU2V0dGluZ3MgPSBKU09OLnBhcnNlKHNhdmVkU2V0dGluZ3MpO1xuICAgICAgICBzZXRTZXR0aW5ncyhwYXJzZWRTZXR0aW5ncyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZVxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlIHdoZW4gdGhleSBjaGFuZ2UgKG9wdGlvbmFsKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpbml0aWFsaXplZC5jdXJyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnYWRtaW5TZXR0aW5ncycsIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBVcGRhdGUgc2V0dGluZ3Mgd2hlbiB0aGV5IGNoYW5nZSBpbiB0aGUgY29udGV4dFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3NldHRpbmdzIHVzZUVmZmVjdF0gY3VycmVudFVzZXJJZDonLCBjdXJyZW50VXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGlmICh1c2VyU2V0dGluZ3MpIHtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIC8vIE9wdGlvbmFsbHkgdXBkYXRlIFVJIGVsZW1lbnRzIGlmIG5lZWRlZFxuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzIGZyb20gYWRtaW4gcGFnZSAoY2FwdHVyZVNldHRpbmdzVXBkYXRlIGV2ZW50KVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVNldHRpbmdzVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAnY2FwdHVyZVNldHRpbmdzJykge1xuICAgICAgICBjb25zdCB7IHVzZXJJZCwgdGltZXMsIGRlbGF5IH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlU2V0dGluZ3NVcGRhdGVdIHVzZXJJZDonLCB1c2VySWQsICdjdXJyZW50VXNlcklkOicsIGN1cnJlbnRVc2VySWQpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0ge1xuICAgICAgICAgICAgLi4uY3VycmVudFNldHRpbmdzLFxuICAgICAgICAgICAgdGltZXM6IHRpbWVzICE9PSB1bmRlZmluZWQgPyBOdW1iZXIodGltZXMpIDogY3VycmVudFNldHRpbmdzLnRpbWVzLFxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5ICE9PSB1bmRlZmluZWQgPyBOdW1iZXIoZGVsYXkpIDogY3VycmVudFNldHRpbmdzLmRlbGF5XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzZXRDdXJyZW50U2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IG5ld1NldHRpbmdzIH0pKTtcbiAgICAgICAgICB1cGRhdGVTZXR0aW5ncyhuZXdTZXR0aW5ncywgdXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgfSwgW2N1cnJlbnRVc2VySWQsIGN1cnJlbnRTZXR0aW5nc10pO1xuXG4gIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgYSB1c2VyIHdpdGggY2FjaGluZ1xuICBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IGFzeW5jIChuZXdTZXR0aW5ncywgdXNlcklkKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1cGRhdGVTZXR0aW5nc10gdXNlcklkOicsIHVzZXJJZCk7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlU2V0dGluZ3NdIFNraXBwaW5nIHVwZGF0ZSAtIHRvbyBzb29uIGFmdGVyIGxhc3QgdXBkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3NbdXNlcklkXSxcbiAgICAgIC4uLm5ld1NldHRpbmdzXG4gICAgfTtcblxuICAgIC8vIENoZWNrIGlmIHNldHRpbmdzIGhhdmUgYWN0dWFsbHkgY2hhbmdlZFxuICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5nZXQodXNlcklkKTtcbiAgICBpZiAoY2FjaGVkU2V0dGluZ3MgJiYgaXNFcXVhbChjYWNoZWRTZXR0aW5ncywgdXBkYXRlZFNldHRpbmdzKSkge1xuICAgICAgY29uc29sZS5sb2coJ1t1cGRhdGVTZXR0aW5nc10gU2V0dGluZ3MgdW5jaGFuZ2VkLCBza2lwcGluZyBBUEkgY2FsbCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVwZGF0ZWRTZXR0aW5ncylcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBzYXZlIHNldHRpbmdzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnN0IGZpbmFsU2V0dGluZ3MgPSByZXN1bHQuZGF0YSB8fCB1cGRhdGVkU2V0dGluZ3M7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBjYWNoZVxuICAgICAgc2V0dGluZ3NDYWNoZS5zZXQodXNlcklkLCBmaW5hbFNldHRpbmdzKTtcbiAgICAgIFxuICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogZmluYWxTZXR0aW5ncyB9KSk7XG4gICAgICBzZXRDdXJyZW50U2V0dGluZ3MoZmluYWxTZXR0aW5ncyk7XG4gICAgICBzZXRMYXN0VXBkYXRlVGltZShub3cpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfTtcblxuICAvLyBVcGxvYWQgYW5kIHVwZGF0ZSBpbWFnZSBmb3IgYSB1c2VyXG4gIGNvbnN0IHVwZGF0ZUltYWdlID0gYXN5bmMgKHVzZXJJZCwgYmFzZTY0SW1hZ2UpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VwZGF0ZUltYWdlXSB1c2VySWQ6JywgdXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgaWYgKCF1c2VySWQgfHwgIWJhc2U2NEltYWdlKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvaW1hZ2U/dXNlcl9pZD0ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGltYWdlOiBiYXNlNjRJbWFnZSB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byB1cGxvYWQgaW1hZ2UnKTtcbiAgICAgIH1cbiAgICAgIC8vIE9wdGlvbmFsbHksIGZldGNoIHNldHRpbmdzIGFnYWluIHRvIGdldCB1cGRhdGVkIGltYWdlIGluZm9cbiAgICAgIGF3YWl0IGZldGNoU2V0dGluZ3NGb3JVc2VyKHVzZXJJZCk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgc2V0dGluZ3MsIHVwZGF0ZVNldHRpbmdzLCB1cGRhdGVJbWFnZSwgZXJyb3IgfTtcbn07XG5cbi8vIEFkZCBkZWZhdWx0IGV4cG9ydCBjb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFkbWluU2V0dGluZ3MoKSB7XG4gIHJldHVybiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJzZXR0aW5nc0NhY2hlIiwiTWFwIiwidXNlQWRtaW5TZXR0aW5ncyIsInJlZiIsInNldHRpbmdzIiwic2V0U2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJpc1RvcEJhclVwZGF0ZWQiLCJzZXRJc1RvcEJhclVwZGF0ZWQiLCJlcnJvciIsInNldEVycm9yIiwiaW5pdGlhbGl6ZWQiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjdXJyZW50U2V0dGluZ3MiLCJzZXRDdXJyZW50U2V0dGluZ3MiLCJsYXN0VXBkYXRlVGltZSIsInNldExhc3RVcGRhdGVUaW1lIiwiUE9MTElOR19JTlRFUlZBTCIsIk1JTl9VUERBVEVfSU5URVJWQUwiLCJsYXN0U2V0dGluZ3NSZWYiLCJjb25zb2xlIiwibG9nIiwiZmV0Y2hTZXR0aW5nc0ZvclVzZXIiLCJ1c2VySWQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfS0VZIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsImRldGFpbCIsInJlc3VsdCIsImRhdGEiLCJuZXdTZXR0aW5ncyIsImNhY2hlZFNldHRpbmdzIiwiZ2V0Iiwic2V0IiwicHJldiIsImN1cnJlbnQiLCJzZXRDYXB0dXJlU2V0dGluZ3MiLCJtZXNzYWdlIiwiZmV0Y2hTZXR0aW5ncyIsIm5vdyIsIkRhdGUiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJoYW5kbGVVc2VySWRDaGFuZ2UiLCJldmVudCIsIm5ld1VzZXJJZCIsInNldEl0ZW0iLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkN1c3RvbUV2ZW50IiwidHlwZSIsImRpc3BhdGNoRXZlbnQiLCJzYXZlZFNldHRpbmdzIiwicGFyc2VkU2V0dGluZ3MiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ1c2VyU2V0dGluZ3MiLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsInRpbWVzIiwiZGVsYXkiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJ1cGRhdGVTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsIm1ldGhvZCIsImJvZHkiLCJmaW5hbFNldHRpbmdzIiwidXBkYXRlSW1hZ2UiLCJiYXNlNjRJbWFnZSIsImltYWdlIiwiQWRtaW5TZXR0aW5ncyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});