"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/process_set",{

/***/ "(pages-dir-browser)/./pages/process_set/processApi.js":
/*!*****************************************!*\
  !*** ./pages/process_set/processApi.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkBackendConnection: () => (/* binding */ checkBackendConnection),\n/* harmony export */   checkFilesCompleteness: () => (/* binding */ checkFilesCompleteness),\n/* harmony export */   checkFilesNeedProcessing: () => (/* binding */ checkFilesNeedProcessing),\n/* harmony export */   checkProcessingStatus: () => (/* binding */ checkProcessingStatus),\n/* harmony export */   compareFileCounts: () => (/* binding */ compareFileCounts),\n/* harmony export */   \"default\": () => (/* binding */ ProcessApiPage),\n/* harmony export */   getFilesList: () => (/* binding */ getFilesList),\n/* harmony export */   previewFile: () => (/* binding */ previewFile),\n/* harmony export */   processFiles: () => (/* binding */ processFiles)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// pages/process_set/processApi.js - API functions for process_set with improved connection handling\n// Utility function for making API requests with retry and better error handling\nconst fetchWithRetry = async function(url) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    let lastError;\n    // Get API key from environment variable\n    const apiKey = \"A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV\" || 0;\n    // Get backend URL from environment variable\n    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || '';\n    // Ensure URL is absolute\n    const absoluteUrl = url.startsWith('http') ? url : \"\".concat(backendUrl).concat(url);\n    for(let i = 0; i <= retries; i++){\n        try {\n            console.log(\"Fetching \".concat(absoluteUrl).concat(i > 0 ? \" (retry \".concat(i, \"/\").concat(retries, \")\") : ''));\n            const controller = new AbortController();\n            const timeout = setTimeout(()=>controller.abort(), 8000); // 8 second timeout\n            const response = await fetch(absoluteUrl, {\n                ...options,\n                signal: controller.signal,\n                headers: {\n                    ...options.headers,\n                    'Content-Type': 'application/json',\n                    'X-API-Key': apiKey\n                }\n            });\n            clearTimeout(timeout);\n            // Check for response errors\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"API error (\".concat(response.status, \"):\"), errorText);\n                // Special handling for 401 (Unauthorized)\n                if (response.status === 401) {\n                    throw new Error('Invalid API key. Please check your configuration.');\n                }\n                throw new Error(\"API returned \".concat(response.status, \": \").concat(errorText || response.statusText));\n            }\n            // Try to parse JSON response\n            try {\n                const data = await response.json();\n                return data;\n            } catch (parseError) {\n                console.error('JSON parse error:', parseError);\n                throw new Error(\"Failed to parse response: \".concat(parseError.message));\n            }\n        } catch (error) {\n            console.error(\"Fetch error (attempt \".concat(i + 1, \"/\").concat(retries + 1, \"):\"), error);\n            lastError = error;\n            // If this was an abort error (timeout), log it specifically\n            if (error.name === 'AbortError') {\n                console.error('Request timed out');\n            }\n            // If we have retries left, wait before trying again\n            if (i < retries) {\n                const delay = 1000 * Math.pow(2, i); // Exponential backoff: 1s, 2s, 4s, etc.\n                // console.log(`Waiting ${delay}ms before retry...`);\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n        }\n    }\n    // If we got here, all retries failed\n    throw lastError;\n};\n// API configuration\nconst API_BASE_URL = \"http://backend:8000\" || 0;\nconst API_KEY = \"A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV\";\n// Check if the backend is connected\nconst checkBackendConnection = async ()=>{\n    try {\n        // console.log('Checking backend connection...');\n        const response = await fetchWithRetry('/api/check-backend-connection');\n        // console.log('Backend connection response:', response);\n        return {\n            success: true,\n            connected: response.connected || false,\n            status: response.status || 'unknown'\n        };\n    } catch (error) {\n        console.error('Backend connection check failed:', error);\n        return {\n            success: false,\n            connected: false,\n            error: error.message,\n            status: 'error'\n        };\n    }\n};\n// Get list of files from both capture and enhance folders\nconst getFilesList = async ()=>{\n    try {\n        const response = await fetchWithRetry('/api/for-process-folder/file-api?operation=list');\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to get files list');\n        }\n        // Organize files into capture and enhance arrays\n        const organizedFiles = {\n            capture: [],\n            enhance: []\n        };\n        if (response.files && response.files.capture && response.files.enhance) {\n            organizedFiles.capture = response.files.capture.map((filename)=>({\n                    filename,\n                    path: \"/captures/eye_tracking_captures/\".concat(filename),\n                    file_type: filename.split('.').pop(),\n                    size: 0 // Size will be updated when file is accessed\n                }));\n            organizedFiles.enhance = response.files.enhance.map((filename)=>({\n                    filename,\n                    path: \"/captures/enhance/\".concat(filename),\n                    file_type: filename.split('.').pop(),\n                    size: 0 // Size will be updated when file is accessed\n                }));\n        }\n        return {\n            success: true,\n            files: organizedFiles,\n            message: response.message || 'Files retrieved successfully'\n        };\n    } catch (error) {\n        console.error('Error getting files list:', error);\n        return {\n            success: false,\n            error: error.message,\n            message: 'Failed to get files list',\n            files: {\n                capture: [],\n                enhance: []\n            }\n        };\n    }\n};\n// Check file completeness (if webcam, screen, and parameter files exist for each set)\nconst checkFilesCompleteness = async ()=>{\n    try {\n        const response = await fetch('/api/for-process-folder/file-api?operation=check-completeness');\n        const data = await response.json();\n        if (!data.success) {\n            throw new Error(data.error || 'Failed to check files');\n        }\n        return {\n            success: true,\n            isComplete: data.isComplete,\n            missingFiles: data.missingFiles,\n            totalFiles: data.totalSets,\n            incompleteSets: data.incompleteSets || []\n        };\n    } catch (error) {\n        console.error('Error checking files completeness:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// Preview a specific file\nconst previewFile = async (filename)=>{\n    try {\n        const response = await fetchWithRetry(\"/api/preview-api?filename=\".concat(encodeURIComponent(filename)));\n        const data = await response.json();\n        if (!data.success) {\n            throw new Error(data.error || 'Failed to get preview');\n        }\n        return {\n            success: true,\n            data: data.data,\n            type: data.type\n        };\n    } catch (error) {\n        console.error('Preview API error:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// Check if files need processing\nconst checkFilesNeedProcessing = async ()=>{\n    try {\n        const response = await fetchWithRetry('/api/for-process-folder/file-api?operation=compare');\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to get files list');\n        }\n        const captureCount = response.captureCount || 0;\n        const enhanceCount = response.enhanceCount || 0;\n        const needsProcessing = captureCount > enhanceCount;\n        const filesToProcess = captureCount - enhanceCount;\n        return {\n            success: true,\n            needsProcessing,\n            captureCount,\n            enhanceCount,\n            filesToProcess,\n            setsNeedingProcessing: response.setsNeedingProcessing || []\n        };\n    } catch (error) {\n        console.error('Error checking files:', error);\n        return {\n            success: false,\n            error: error.message,\n            needsProcessing: false,\n            captureCount: 0,\n            enhanceCount: 0,\n            filesToProcess: 0,\n            setsNeedingProcessing: []\n        };\n    }\n};\n// Process files\nconst processFiles = async (setNumbers)=>{\n    try {\n        // console.log('Starting processing for sets:', setNumbers);\n        const response = await fetchWithRetry('/api/process-images', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                set_numbers: setNumbers\n            })\n        });\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to start processing');\n        }\n        return {\n            success: true,\n            message: response.message\n        };\n    } catch (error) {\n        console.error('Error processing files:', error);\n        return {\n            success: false,\n            error: error.message,\n            message: 'Failed to process files'\n        };\n    }\n};\n// Compare files between capture and enhance folders\nconst compareFileCounts = async ()=>{\n    try {\n        const response = await fetchWithRetry('/api/file-api?operation=compare');\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to compare file counts');\n        }\n        return {\n            success: true,\n            captureCount: response.captureCount,\n            enhanceCount: response.enhanceCount,\n            needsProcessing: response.needsProcessing\n        };\n    } catch (error) {\n        console.error('Error comparing file counts:', error);\n        return {\n            success: false,\n            error: error.message,\n            captureCount: 0,\n            enhanceCount: 0,\n            needsProcessing: false\n        };\n    }\n};\n// Check if processing is currently running\nconst checkProcessingStatus = async ()=>{\n    try {\n        // console.log('Requesting processing status...');\n        const response = await fetchWithRetry('/api/process-status-api', {}, 1); // Only 1 retry for status checks\n        // If fetch succeeded but response is malformed, handle it gracefully\n        if (!response || typeof response !== 'object') {\n            console.error('Invalid response format:', response);\n            return {\n                success: false,\n                error: \"Invalid response format: \".concat(typeof response),\n                isProcessing: false\n            };\n        }\n        return response;\n    } catch (error) {\n        console.error('Error checking processing status:', error);\n        return {\n            success: false,\n            error: error.message,\n            isProcessing: false\n        };\n    }\n};\n// Add default export component\nfunction ProcessApiPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = ProcessApiPage;\nvar _c;\n$RefreshReg$(_c, \"ProcessApiPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL3Byb2Nlc3Nfc2V0L3Byb2Nlc3NBcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLG9HQUFvRztBQUVwRyxnRkFBZ0Y7QUFDaEYsTUFBTUEsaUJBQWlCLGVBQU9DO1FBQUtDLDJFQUFVLENBQUMsR0FBR0MsMkVBQVU7SUFDekQsSUFBSUM7SUFFSix3Q0FBd0M7SUFDeEMsTUFBTUMsU0FBU0Msc0NBQStCLElBQUksQ0FBc0M7SUFFeEYsNENBQTRDO0lBQzVDLE1BQU1HLGFBQWFILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0csdUJBQXVCLElBQUk7SUFFMUQseUJBQXlCO0lBQ3pCLE1BQU1DLGNBQWNWLElBQUlXLFVBQVUsQ0FBQyxVQUFVWCxNQUFNLEdBQWdCQSxPQUFiUSxZQUFpQixPQUFKUjtJQUVuRSxJQUFLLElBQUlZLElBQUksR0FBR0EsS0FBS1YsU0FBU1UsSUFBSztRQUNqQyxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQyxZQUEwQkYsT0FBZEYsYUFBc0QsT0FBeENFLElBQUksSUFBSSxXQUFnQlYsT0FBTFUsR0FBRSxLQUFXLE9BQVJWLFNBQVEsT0FBSztZQUUzRSxNQUFNYSxhQUFhLElBQUlDO1lBQ3ZCLE1BQU1DLFVBQVVDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJLE9BQU8sbUJBQW1CO1lBRS9FLE1BQU1DLFdBQVcsTUFBTUMsTUFBTVgsYUFBYTtnQkFDeEMsR0FBR1QsT0FBTztnQkFDVnFCLFFBQVFQLFdBQVdPLE1BQU07Z0JBQ3pCQyxTQUFTO29CQUNQLEdBQUd0QixRQUFRc0IsT0FBTztvQkFDbEIsZ0JBQWdCO29CQUNoQixhQUFhbkI7Z0JBQ2Y7WUFDRjtZQUVBb0IsYUFBYVA7WUFFYiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDRyxTQUFTSyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTU4sU0FBU08sSUFBSTtnQkFDckNkLFFBQVFlLEtBQUssQ0FBQyxjQUE4QixP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LHFFQUFxRTtRQUNyRSxJQUFJLENBQUNxQixZQUFZLE9BQU9BLGFBQWEsVUFBVTtZQUM3Q1AsUUFBUWUsS0FBSyxDQUFDLDRCQUE0QlI7WUFDMUMsT0FBTztnQkFDTDBCLFNBQVM7Z0JBQ1RsQixPQUFPLDRCQUE0QyxPQUFoQixPQUFPUjtnQkFDMUNnRSxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSxPQUFPaEU7SUFDVCxFQUFFLE9BQU9RLE9BQU87UUFDZGYsUUFBUWUsS0FBSyxDQUFDLHFDQUFxQ0E7UUFDbkQsT0FBTztZQUNMa0IsU0FBUztZQUNUbEIsT0FBT0EsTUFBTU8sT0FBTztZQUNwQmlELGNBQWM7UUFDaEI7SUFDRjtBQUNGLEVBQUU7QUFFRiwrQkFBK0I7QUFDaEIsU0FBU0M7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtLQUZ3QkEiLCJzb3VyY2VzIjpbIi9hcHAvcGFnZXMvcHJvY2Vzc19zZXQvcHJvY2Vzc0FwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWdlcy9wcm9jZXNzX3NldC9wcm9jZXNzQXBpLmpzIC0gQVBJIGZ1bmN0aW9ucyBmb3IgcHJvY2Vzc19zZXQgd2l0aCBpbXByb3ZlZCBjb25uZWN0aW9uIGhhbmRsaW5nXG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIG1ha2luZyBBUEkgcmVxdWVzdHMgd2l0aCByZXRyeSBhbmQgYmV0dGVyIGVycm9yIGhhbmRsaW5nXG5jb25zdCBmZXRjaFdpdGhSZXRyeSA9IGFzeW5jICh1cmwsIG9wdGlvbnMgPSB7fSwgcmV0cmllcyA9IDIpID0+IHtcbiAgbGV0IGxhc3RFcnJvcjtcbiAgXG4gIC8vIEdldCBBUEkga2V5IGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJztcbiAgXG4gIC8vIEdldCBiYWNrZW5kIFVSTCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGNvbnN0IGJhY2tlbmRVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCB8fCAnJztcbiAgXG4gIC8vIEVuc3VyZSBVUkwgaXMgYWJzb2x1dGVcbiAgY29uc3QgYWJzb2x1dGVVcmwgPSB1cmwuc3RhcnRzV2l0aCgnaHR0cCcpID8gdXJsIDogYCR7YmFja2VuZFVybH0ke3VybH1gO1xuICBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPD0gcmV0cmllczsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBGZXRjaGluZyAke2Fic29sdXRlVXJsfSR7aSA+IDAgPyBgIChyZXRyeSAke2l9LyR7cmV0cmllc30pYCA6ICcnfWApO1xuICAgICAgXG4gICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCA4MDAwKTsgLy8gOCBzZWNvbmQgdGltZW91dFxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGFic29sdXRlVXJsLCB7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogYXBpS2V5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciByZXNwb25zZSBlcnJvcnNcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBBUEkgZXJyb3IgKCR7cmVzcG9uc2Uuc3RhdHVzfSk6YCwgZXJyb3JUZXh0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIDQwMSAoVW5hdXRob3JpemVkKVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQVBJIGtleS4gUGxlYXNlIGNoZWNrIHlvdXIgY29uZmlndXJhdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9OiAke2Vycm9yVGV4dCB8fCByZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcnkgdG8gcGFyc2UgSlNPTiByZXNwb25zZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0pTT04gcGFyc2UgZXJyb3I6JywgcGFyc2VFcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlOiAke3BhcnNlRXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmV0Y2ggZXJyb3IgKGF0dGVtcHQgJHtpKzF9LyR7cmV0cmllcysxfSk6YCwgZXJyb3IpO1xuICAgICAgbGFzdEVycm9yID0gZXJyb3I7XG4gICAgICBcbiAgICAgIC8vIElmIHRoaXMgd2FzIGFuIGFib3J0IGVycm9yICh0aW1lb3V0KSwgbG9nIGl0IHNwZWNpZmljYWxseVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdSZXF1ZXN0IHRpbWVkIG91dCcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiB3ZSBoYXZlIHJldHJpZXMgbGVmdCwgd2FpdCBiZWZvcmUgdHJ5aW5nIGFnYWluXG4gICAgICBpZiAoaSA8IHJldHJpZXMpIHtcbiAgICAgICAgY29uc3QgZGVsYXkgPSAxMDAwICogTWF0aC5wb3coMiwgaSk7IC8vIEV4cG9uZW50aWFsIGJhY2tvZmY6IDFzLCAycywgNHMsIGV0Yy5cbiAgICAgICAgLy8gY29uc29sZS5sb2coYFdhaXRpbmcgJHtkZWxheX1tcyBiZWZvcmUgcmV0cnkuLi5gKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIHJldHJpZXMgZmFpbGVkXG4gIHRocm93IGxhc3RFcnJvcjtcbn07XG5cbi8vIEFQSSBjb25maWd1cmF0aW9uXG5jb25zdCBBUElfQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vYmFja2VuZDo4MDAwJztcbmNvbnN0IEFQSV9LRVkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZO1xuXG4vLyBDaGVjayBpZiB0aGUgYmFja2VuZCBpcyBjb25uZWN0ZWRcbmV4cG9ydCBjb25zdCBjaGVja0JhY2tlbmRDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdDaGVja2luZyBiYWNrZW5kIGNvbm5lY3Rpb24uLi4nKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KCcvYXBpL2NoZWNrLWJhY2tlbmQtY29ubmVjdGlvbicpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdCYWNrZW5kIGNvbm5lY3Rpb24gcmVzcG9uc2U6JywgcmVzcG9uc2UpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgY29ubmVjdGVkOiByZXNwb25zZS5jb25uZWN0ZWQgfHwgZmFsc2UsXG4gICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyB8fCAndW5rbm93bidcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0JhY2tlbmQgY29ubmVjdGlvbiBjaGVjayBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YXR1czogJ2Vycm9yJ1xuICAgIH07XG4gIH1cbn07XG4gIFxuLy8gR2V0IGxpc3Qgb2YgZmlsZXMgZnJvbSBib3RoIGNhcHR1cmUgYW5kIGVuaGFuY2UgZm9sZGVyc1xuZXhwb3J0IGNvbnN0IGdldEZpbGVzTGlzdCA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KCcvYXBpL2Zvci1wcm9jZXNzLWZvbGRlci9maWxlLWFwaT9vcGVyYXRpb249bGlzdCcpO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBnZXQgZmlsZXMgbGlzdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBPcmdhbml6ZSBmaWxlcyBpbnRvIGNhcHR1cmUgYW5kIGVuaGFuY2UgYXJyYXlzXG4gICAgY29uc3Qgb3JnYW5pemVkRmlsZXMgPSB7XG4gICAgICBjYXB0dXJlOiBbXSxcbiAgICAgIGVuaGFuY2U6IFtdXG4gICAgfTtcbiAgICBcbiAgICBpZiAocmVzcG9uc2UuZmlsZXMgJiYgcmVzcG9uc2UuZmlsZXMuY2FwdHVyZSAmJiByZXNwb25zZS5maWxlcy5lbmhhbmNlKSB7XG4gICAgICBvcmdhbml6ZWRGaWxlcy5jYXB0dXJlID0gcmVzcG9uc2UuZmlsZXMuY2FwdHVyZS5tYXAoZmlsZW5hbWUgPT4gKHtcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIHBhdGg6IGAvY2FwdHVyZXMvZXllX3RyYWNraW5nX2NhcHR1cmVzLyR7ZmlsZW5hbWV9YCxcbiAgICAgICAgZmlsZV90eXBlOiBmaWxlbmFtZS5zcGxpdCgnLicpLnBvcCgpLFxuICAgICAgICBzaXplOiAwIC8vIFNpemUgd2lsbCBiZSB1cGRhdGVkIHdoZW4gZmlsZSBpcyBhY2Nlc3NlZFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICBvcmdhbml6ZWRGaWxlcy5lbmhhbmNlID0gcmVzcG9uc2UuZmlsZXMuZW5oYW5jZS5tYXAoZmlsZW5hbWUgPT4gKHtcbiAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgIHBhdGg6IGAvY2FwdHVyZXMvZW5oYW5jZS8ke2ZpbGVuYW1lfWAsXG4gICAgICAgIGZpbGVfdHlwZTogZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKSxcbiAgICAgICAgc2l6ZTogMCAvLyBTaXplIHdpbGwgYmUgdXBkYXRlZCB3aGVuIGZpbGUgaXMgYWNjZXNzZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBmaWxlczogb3JnYW5pemVkRmlsZXMsXG4gICAgICBtZXNzYWdlOiByZXNwb25zZS5tZXNzYWdlIHx8ICdGaWxlcyByZXRyaWV2ZWQgc3VjY2Vzc2Z1bGx5J1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBmaWxlcyBsaXN0OicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZ2V0IGZpbGVzIGxpc3QnLFxuICAgICAgZmlsZXM6IHsgY2FwdHVyZTogW10sIGVuaGFuY2U6IFtdIH1cbiAgICB9O1xuICB9XG59O1xuICBcbi8vIENoZWNrIGZpbGUgY29tcGxldGVuZXNzIChpZiB3ZWJjYW0sIHNjcmVlbiwgYW5kIHBhcmFtZXRlciBmaWxlcyBleGlzdCBmb3IgZWFjaCBzZXQpXG5leHBvcnQgY29uc3QgY2hlY2tGaWxlc0NvbXBsZXRlbmVzcyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL2Zvci1wcm9jZXNzLWZvbGRlci9maWxlLWFwaT9vcGVyYXRpb249Y2hlY2stY29tcGxldGVuZXNzJyk7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBjaGVjayBmaWxlcycpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgaXNDb21wbGV0ZTogZGF0YS5pc0NvbXBsZXRlLFxuICAgICAgbWlzc2luZ0ZpbGVzOiBkYXRhLm1pc3NpbmdGaWxlcyxcbiAgICAgIHRvdGFsRmlsZXM6IGRhdGEudG90YWxTZXRzLFxuICAgICAgaW5jb21wbGV0ZVNldHM6IGRhdGEuaW5jb21wbGV0ZVNldHMgfHwgW11cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGZpbGVzIGNvbXBsZXRlbmVzczonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuICBcbi8vIFByZXZpZXcgYSBzcGVjaWZpYyBmaWxlXG5leHBvcnQgY29uc3QgcHJldmlld0ZpbGUgPSBhc3luYyAoZmlsZW5hbWUpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KGAvYXBpL3ByZXZpZXctYXBpP2ZpbGVuYW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKX1gKTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvciB8fCAnRmFpbGVkIHRvIGdldCBwcmV2aWV3Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiBkYXRhLmRhdGEsXG4gICAgICB0eXBlOiBkYXRhLnR5cGVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1ByZXZpZXcgQVBJIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG4gIFxuLy8gQ2hlY2sgaWYgZmlsZXMgbmVlZCBwcm9jZXNzaW5nXG5leHBvcnQgY29uc3QgY2hlY2tGaWxlc05lZWRQcm9jZXNzaW5nID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkoJy9hcGkvZm9yLXByb2Nlc3MtZm9sZGVyL2ZpbGUtYXBpP29wZXJhdGlvbj1jb21wYXJlJyk7XG4gICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGdldCBmaWxlcyBsaXN0Jyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhcHR1cmVDb3VudCA9IHJlc3BvbnNlLmNhcHR1cmVDb3VudCB8fCAwO1xuICAgIGNvbnN0IGVuaGFuY2VDb3VudCA9IHJlc3BvbnNlLmVuaGFuY2VDb3VudCB8fCAwO1xuICAgIGNvbnN0IG5lZWRzUHJvY2Vzc2luZyA9IGNhcHR1cmVDb3VudCA+IGVuaGFuY2VDb3VudDtcbiAgICBjb25zdCBmaWxlc1RvUHJvY2VzcyA9IGNhcHR1cmVDb3VudCAtIGVuaGFuY2VDb3VudDtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG5lZWRzUHJvY2Vzc2luZyxcbiAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgIGVuaGFuY2VDb3VudCxcbiAgICAgIGZpbGVzVG9Qcm9jZXNzLFxuICAgICAgc2V0c05lZWRpbmdQcm9jZXNzaW5nOiByZXNwb25zZS5zZXRzTmVlZGluZ1Byb2Nlc3NpbmcgfHwgW11cbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGZpbGVzOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIG5lZWRzUHJvY2Vzc2luZzogZmFsc2UsXG4gICAgICBjYXB0dXJlQ291bnQ6IDAsXG4gICAgICBlbmhhbmNlQ291bnQ6IDAsXG4gICAgICBmaWxlc1RvUHJvY2VzczogMCxcbiAgICAgIHNldHNOZWVkaW5nUHJvY2Vzc2luZzogW11cbiAgICB9O1xuICB9XG59O1xuXG4vLyBQcm9jZXNzIGZpbGVzXG5leHBvcnQgY29uc3QgcHJvY2Vzc0ZpbGVzID0gYXN5bmMgKHNldE51bWJlcnMpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBjb25zb2xlLmxvZygnU3RhcnRpbmcgcHJvY2Vzc2luZyBmb3Igc2V0czonLCBzZXROdW1iZXJzKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KCcvYXBpL3Byb2Nlc3MtaW1hZ2VzJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzZXRfbnVtYmVyczogc2V0TnVtYmVycyB9KSxcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZycpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLm1lc3NhZ2VcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByb2Nlc3NpbmcgZmlsZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBwcm9jZXNzIGZpbGVzJ1xuICAgIH07XG4gIH1cbn07XG4gIFxuLy8gQ29tcGFyZSBmaWxlcyBiZXR3ZWVuIGNhcHR1cmUgYW5kIGVuaGFuY2UgZm9sZGVyc1xuZXhwb3J0IGNvbnN0IGNvbXBhcmVGaWxlQ291bnRzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkoJy9hcGkvZmlsZS1hcGk/b3BlcmF0aW9uPWNvbXBhcmUnKTtcbiAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gY29tcGFyZSBmaWxlIGNvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGNhcHR1cmVDb3VudDogcmVzcG9uc2UuY2FwdHVyZUNvdW50LFxuICAgICAgZW5oYW5jZUNvdW50OiByZXNwb25zZS5lbmhhbmNlQ291bnQsXG4gICAgICBuZWVkc1Byb2Nlc3Npbmc6IHJlc3BvbnNlLm5lZWRzUHJvY2Vzc2luZ1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY29tcGFyaW5nIGZpbGUgY291bnRzOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgY2FwdHVyZUNvdW50OiAwLFxuICAgICAgZW5oYW5jZUNvdW50OiAwLFxuICAgICAgbmVlZHNQcm9jZXNzaW5nOiBmYWxzZVxuICAgIH07XG4gIH1cbn07XG4gIFxuLy8gQ2hlY2sgaWYgcHJvY2Vzc2luZyBpcyBjdXJyZW50bHkgcnVubmluZ1xuZXhwb3J0IGNvbnN0IGNoZWNrUHJvY2Vzc2luZ1N0YXR1cyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBjb25zb2xlLmxvZygnUmVxdWVzdGluZyBwcm9jZXNzaW5nIHN0YXR1cy4uLicpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoUmV0cnkoJy9hcGkvcHJvY2Vzcy1zdGF0dXMtYXBpJywge30sIDEpOyAvLyBPbmx5IDEgcmV0cnkgZm9yIHN0YXR1cyBjaGVja3NcbiAgICBcbiAgICAvLyBJZiBmZXRjaCBzdWNjZWVkZWQgYnV0IHJlc3BvbnNlIGlzIG1hbGZvcm1lZCwgaGFuZGxlIGl0IGdyYWNlZnVsbHlcbiAgICBpZiAoIXJlc3BvbnNlIHx8IHR5cGVvZiByZXNwb25zZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgcmVzcG9uc2UgZm9ybWF0OicsIHJlc3BvbnNlKTtcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICAgIGVycm9yOiBgSW52YWxpZCByZXNwb25zZSBmb3JtYXQ6ICR7dHlwZW9mIHJlc3BvbnNlfWAsXG4gICAgICAgIGlzUHJvY2Vzc2luZzogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwcm9jZXNzaW5nIHN0YXR1czonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIGlzUHJvY2Vzc2luZzogZmFsc2VcbiAgICB9O1xuICB9XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQcm9jZXNzQXBpUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59Il0sIm5hbWVzIjpbImZldGNoV2l0aFJldHJ5IiwidXJsIiwib3B0aW9ucyIsInJldHJpZXMiLCJsYXN0RXJyb3IiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0tFWSIsImJhY2tlbmRVcmwiLCJORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCIsImFic29sdXRlVXJsIiwic3RhcnRzV2l0aCIsImkiLCJjb25zb2xlIiwibG9nIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXNwb25zZSIsImZldGNoIiwic2lnbmFsIiwiaGVhZGVycyIsImNsZWFyVGltZW91dCIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImVycm9yIiwic3RhdHVzIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiZGF0YSIsImpzb24iLCJwYXJzZUVycm9yIiwibWVzc2FnZSIsIm5hbWUiLCJkZWxheSIsIk1hdGgiLCJwb3ciLCJQcm9taXNlIiwicmVzb2x2ZSIsIkFQSV9CQVNFX1VSTCIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJBUElfS0VZIiwiY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiIsInN1Y2Nlc3MiLCJjb25uZWN0ZWQiLCJnZXRGaWxlc0xpc3QiLCJvcmdhbml6ZWRGaWxlcyIsImNhcHR1cmUiLCJlbmhhbmNlIiwiZmlsZXMiLCJtYXAiLCJmaWxlbmFtZSIsInBhdGgiLCJmaWxlX3R5cGUiLCJzcGxpdCIsInBvcCIsInNpemUiLCJjaGVja0ZpbGVzQ29tcGxldGVuZXNzIiwiaXNDb21wbGV0ZSIsIm1pc3NpbmdGaWxlcyIsInRvdGFsRmlsZXMiLCJ0b3RhbFNldHMiLCJpbmNvbXBsZXRlU2V0cyIsInByZXZpZXdGaWxlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwidHlwZSIsImNoZWNrRmlsZXNOZWVkUHJvY2Vzc2luZyIsImNhcHR1cmVDb3VudCIsImVuaGFuY2VDb3VudCIsIm5lZWRzUHJvY2Vzc2luZyIsImZpbGVzVG9Qcm9jZXNzIiwic2V0c05lZWRpbmdQcm9jZXNzaW5nIiwicHJvY2Vzc0ZpbGVzIiwic2V0TnVtYmVycyIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwic2V0X251bWJlcnMiLCJjb21wYXJlRmlsZUNvdW50cyIsImNoZWNrUHJvY2Vzc2luZ1N0YXR1cyIsImlzUHJvY2Vzc2luZyIsIlByb2Nlc3NBcGlQYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/process_set/processApi.js\n"));

/***/ })

});