"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/process_set",{

/***/ "(pages-dir-browser)/./pages/process_set/processApi.js":
/*!*****************************************!*\
  !*** ./pages/process_set/processApi.js ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checkBackendConnection: () => (/* binding */ checkBackendConnection),\n/* harmony export */   checkFilesCompleteness: () => (/* binding */ checkFilesCompleteness),\n/* harmony export */   checkFilesNeedProcessing: () => (/* binding */ checkFilesNeedProcessing),\n/* harmony export */   checkProcessingStatus: () => (/* binding */ checkProcessingStatus),\n/* harmony export */   compareFileCounts: () => (/* binding */ compareFileCounts),\n/* harmony export */   \"default\": () => (/* binding */ ProcessApiPage),\n/* harmony export */   getFilesList: () => (/* binding */ getFilesList),\n/* harmony export */   previewFile: () => (/* binding */ previewFile),\n/* harmony export */   processFiles: () => (/* binding */ processFiles)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// pages/process_set/processApi.js - API functions for process_set with improved connection handling\n// Utility function for making API requests with retry and better error handling\nconst fetchWithRetry = async function(url) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, retries = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;\n    let lastError;\n    // Get API key from environment variable\n    const apiKey = \"A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV\" || 0;\n    // Get backend URL from environment variable\n    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || '';\n    // Ensure URL is absolute\n    const absoluteUrl = url.startsWith('http') ? url : \"\".concat(backendUrl).concat(url);\n    for(let i = 0; i <= retries; i++){\n        try {\n            console.log(\"Fetching \".concat(absoluteUrl).concat(i > 0 ? \" (retry \".concat(i, \"/\").concat(retries, \")\") : ''));\n            const controller = new AbortController();\n            const timeout = setTimeout(()=>controller.abort(), 8000); // 8 second timeout\n            const response = await fetch(absoluteUrl, {\n                ...options,\n                signal: controller.signal,\n                headers: {\n                    ...options.headers,\n                    'Content-Type': 'application/json',\n                    'X-API-Key': apiKey\n                }\n            });\n            clearTimeout(timeout);\n            // Check for response errors\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"API error (\".concat(response.status, \"):\"), errorText);\n                // Special handling for 401 (Unauthorized)\n                if (response.status === 401) {\n                    throw new Error('Invalid API key. Please check your configuration.');\n                }\n                throw new Error(\"API returned \".concat(response.status, \": \").concat(errorText || response.statusText));\n            }\n            // Try to parse JSON response\n            try {\n                const data = await response.json();\n                return data;\n            } catch (parseError) {\n                console.error('JSON parse error:', parseError);\n                throw new Error(\"Failed to parse response: \".concat(parseError.message));\n            }\n        } catch (error) {\n            console.error(\"Fetch error (attempt \".concat(i + 1, \"/\").concat(retries + 1, \"):\"), error);\n            lastError = error;\n            // If this was an abort error (timeout), log it specifically\n            if (error.name === 'AbortError') {\n                console.error('Request timed out');\n            }\n            // If we have retries left, wait before trying again\n            if (i < retries) {\n                const delay = 1000 * Math.pow(2, i); // Exponential backoff: 1s, 2s, 4s, etc.\n                // console.log(`Waiting ${delay}ms before retry...`);\n                await new Promise((resolve)=>setTimeout(resolve, delay));\n            }\n        }\n    }\n    // If we got here, all retries failed\n    throw lastError;\n};\n// API configuration\nconst API_BASE_URL = \"http://backend:8000\" || 0;\nconst API_KEY = \"A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV\";\n// Check if the backend is connected\nconst checkBackendConnection = async ()=>{\n    try {\n        // console.log('Checking backend connection...');\n        const response = await fetchWithRetry('/api/check-backend-connection');\n        // console.log('Backend connection response:', response);\n        return {\n            success: true,\n            connected: response.connected || false,\n            status: response.status || 'unknown'\n        };\n    } catch (error) {\n        console.error('Backend connection check failed:', error);\n        return {\n            success: false,\n            connected: false,\n            error: error.message,\n            status: 'error'\n        };\n    }\n};\n// Get list of files from both capture and enhance folders\nconst getFilesList = async ()=>{\n    try {\n        const response = await fetchWithRetry('/api/for-process-folder/file-api?operation=list');\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to get files list');\n        }\n        // Organize files into capture and enhance arrays\n        const organizedFiles = {\n            capture: [],\n            enhance: []\n        };\n        if (response.files && response.files.capture && response.files.enhance) {\n            organizedFiles.capture = response.files.capture.map((filename)=>({\n                    filename,\n                    path: \"/captures/eye_tracking_captures/\".concat(filename),\n                    file_type: filename.split('.').pop(),\n                    size: 0 // Size will be updated when file is accessed\n                }));\n            organizedFiles.enhance = response.files.enhance.map((filename)=>({\n                    filename,\n                    path: \"/captures/enhance/\".concat(filename),\n                    file_type: filename.split('.').pop(),\n                    size: 0 // Size will be updated when file is accessed\n                }));\n        }\n        return {\n            success: true,\n            files: organizedFiles,\n            message: response.message || 'Files retrieved successfully'\n        };\n    } catch (error) {\n        console.error('Error getting files list:', error);\n        return {\n            success: false,\n            error: error.message,\n            message: 'Failed to get files list',\n            files: {\n                capture: [],\n                enhance: []\n            }\n        };\n    }\n};\n// Check file completeness (if webcam, screen, and parameter files exist for each set)\nconst checkFilesCompleteness = async ()=>{\n    try {\n        const response = await fetch('/api/check-files');\n        const data = await response.json();\n        if (!data.success) {\n            throw new Error(data.error || 'Failed to check files');\n        }\n        // Only check files in eye_tracking_captures folder\n        const captureFiles = data.files.capture || [];\n        const fileNumbers = new Set();\n        // Extract file numbers from capture files\n        captureFiles.forEach((file)=>{\n            const match = file.filename.match(/_(\\d+)\\./);\n            if (match) {\n                fileNumbers.add(parseInt(match[1]));\n            }\n        });\n        // Check for missing files in sequence\n        const missingFiles = [];\n        if (fileNumbers.size > 0) {\n            const minNumber = Math.min(...fileNumbers);\n            const maxNumber = Math.max(...fileNumbers);\n            for(let i = minNumber; i <= maxNumber; i++){\n                if (!fileNumbers.has(i)) {\n                    missingFiles.push(i);\n                }\n            }\n        }\n        return {\n            success: true,\n            isComplete: missingFiles.length === 0,\n            missingFiles: missingFiles.length,\n            totalFiles: fileNumbers.size\n        };\n    } catch (error) {\n        console.error('Error checking files completeness:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n// Preview a specific file\nconst previewFile = async (filename)=>{\n    try {\n        // console.log('Fetching preview for file:', filename);\n        const response = await fetchWithRetry(\"/api/preview-api?filename=\".concat(encodeURIComponent(filename)));\n        // console.log('Raw preview response:', response);\n        // Check if response has the expected format\n        if (!response || typeof response !== 'object') {\n            throw new Error('Invalid response format from preview API');\n        }\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to get preview');\n        }\n        return {\n            success: true,\n            data: response.data,\n            type: response.type,\n            message: response.message\n        };\n    } catch (error) {\n        console.error('Error previewing file:', error);\n        return {\n            success: false,\n            error: error.message,\n            message: 'Failed to get preview'\n        };\n    }\n};\n// Check if files need processing\nconst checkFilesNeedProcessing = async ()=>{\n    try {\n        const response = await fetchWithRetry('/api/file-api?operation=list');\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to get files list');\n        }\n        // Get unique set numbers from each folder\n        const captureSets = new Set();\n        const enhanceSets = new Set();\n        if (response.files && Array.isArray(response.files)) {\n            response.files.forEach((file)=>{\n                const match = file.filename.match(/_(\\d+)\\./);\n                if (match) {\n                    const setNumber = parseInt(match[1]);\n                    if (file.path.includes('eye_tracking_captures')) {\n                        captureSets.add(setNumber);\n                    } else if (file.path.includes('enhance')) {\n                        enhanceSets.add(setNumber);\n                    }\n                }\n            });\n        }\n        const captureCount = captureSets.size;\n        const enhanceCount = enhanceSets.size;\n        const needsProcessing = captureCount > enhanceCount;\n        const filesToProcess = captureCount - enhanceCount;\n        return {\n            success: true,\n            needsProcessing,\n            captureCount,\n            enhanceCount,\n            filesToProcess\n        };\n    } catch (error) {\n        console.error('Error checking files:', error);\n        return {\n            success: false,\n            error: error.message,\n            needsProcessing: false,\n            captureCount: 0,\n            enhanceCount: 0,\n            filesToProcess: 0\n        };\n    }\n};\n// Process files\nconst processFiles = async (setNumbers)=>{\n    try {\n        // console.log('Starting processing for sets:', setNumbers);\n        const response = await fetchWithRetry('/api/process-images', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                set_numbers: setNumbers\n            })\n        });\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to start processing');\n        }\n        return {\n            success: true,\n            message: response.message\n        };\n    } catch (error) {\n        console.error('Error processing files:', error);\n        return {\n            success: false,\n            error: error.message,\n            message: 'Failed to process files'\n        };\n    }\n};\n// Compare files between capture and enhance folders\nconst compareFileCounts = async ()=>{\n    try {\n        const response = await fetchWithRetry('/api/file-api?operation=compare');\n        if (!response.success) {\n            throw new Error(response.message || 'Failed to compare file counts');\n        }\n        return {\n            success: true,\n            captureCount: response.captureCount,\n            enhanceCount: response.enhanceCount,\n            needsProcessing: response.needsProcessing\n        };\n    } catch (error) {\n        console.error('Error comparing file counts:', error);\n        return {\n            success: false,\n            error: error.message,\n            captureCount: 0,\n            enhanceCount: 0,\n            needsProcessing: false\n        };\n    }\n};\n// Check if processing is currently running\nconst checkProcessingStatus = async ()=>{\n    try {\n        // console.log('Requesting processing status...');\n        const response = await fetchWithRetry('/api/process-status-api', {}, 1); // Only 1 retry for status checks\n        // If fetch succeeded but response is malformed, handle it gracefully\n        if (!response || typeof response !== 'object') {\n            console.error('Invalid response format:', response);\n            return {\n                success: false,\n                error: \"Invalid response format: \".concat(typeof response),\n                isProcessing: false\n            };\n        }\n        return response;\n    } catch (error) {\n        console.error('Error checking processing status:', error);\n        return {\n            success: false,\n            error: error.message,\n            isProcessing: false\n        };\n    }\n};\n// Add default export component\nfunction ProcessApiPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = ProcessApiPage;\nvar _c;\n$RefreshReg$(_c, \"ProcessApiPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL3Byb2Nlc3Nfc2V0L3Byb2Nlc3NBcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLG9HQUFvRztBQUVwRyxnRkFBZ0Y7QUFDaEYsTUFBTUEsaUJBQWlCLGVBQU9DO1FBQUtDLDJFQUFVLENBQUMsR0FBR0MsMkVBQVU7SUFDekQsSUFBSUM7SUFFSix3Q0FBd0M7SUFDeEMsTUFBTUMsU0FBU0Msc0NBQStCLElBQUksQ0FBc0M7SUFFeEYsNENBQTRDO0lBQzVDLE1BQU1HLGFBQWFILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0csdUJBQXVCLElBQUk7SUFFMUQseUJBQXlCO0lBQ3pCLE1BQU1DLGNBQWNWLElBQUlXLFVBQVUsQ0FBQyxVQUFVWCxNQUFNLEdBQWdCQSxPQUFiUSxZQUFpQixPQUFKUjtJQUVuRSxJQUFLLElBQUlZLElBQUksR0FBR0EsS0FBS1YsU0FBU1UsSUFBSztRQUNqQyxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQyxZQUEwQkYsT0FBZEYsYUFBc0QsT0FBeENFLElBQUksSUFBSSxXQUFnQlYsT0FBTFUsR0FBRSxLQUFXLE9BQVJWLFNBQVEsT0FBSztZQUUzRSxNQUFNYSxhQUFhLElBQUlDO1lBQ3ZCLE1BQU1DLFVBQVVDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJLE9BQU8sbUJBQW1CO1lBRS9FLE1BQU1DLFdBQVcsTUFBTUMsTUFBTVgsYUFBYTtnQkFDeEMsR0FBR1QsT0FBTztnQkFDVnFCLFFBQVFQLFdBQVdPLE1BQU07Z0JBQ3pCQyxTQUFTO29CQUNQLEdBQUd0QixRQUFRc0IsT0FBTztvQkFDbEIsZ0JBQWdCO29CQUNoQixhQUFhbkI7Z0JBQ2Y7WUFDRjtZQUVBb0IsYUFBYVA7WUFFYiw0QkFBNEI7WUFDNUIsSUFBSSxDQUFDRyxTQUFTSyxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU1DLFlBQVksTUFBTU4sU0FBU08sSUFBSTtnQkFDckNkLFFBQVFlLEtBQUssQ0FBQyxjQUE4QixP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LElBQUk7UUFDRixrREFBa0Q7UUFDbEQsTUFBTWpGLFdBQVcsTUFBTXJCLGVBQWUsMkJBQTJCLENBQUMsR0FBRyxJQUFJLGlDQUFpQztRQUUxRyxxRUFBcUU7UUFDckUsSUFBSSxDQUFDcUIsWUFBWSxPQUFPQSxhQUFhLFVBQVU7WUFDN0NQLFFBQVFlLEtBQUssQ0FBQyw0QkFBNEJSO1lBQzFDLE9BQU87Z0JBQ0wwQixTQUFTO2dCQUNUbEIsT0FBTyw0QkFBNEMsT0FBaEIsT0FBT1I7Z0JBQzFDa0YsY0FBYztZQUNoQjtRQUNGO1FBRUEsT0FBT2xGO0lBQ1QsRUFBRSxPQUFPUSxPQUFPO1FBQ2RmLFFBQVFlLEtBQUssQ0FBQyxxQ0FBcUNBO1FBQ25ELE9BQU87WUFDTGtCLFNBQVM7WUFDVGxCLE9BQU9BLE1BQU1PLE9BQU87WUFDcEJtRSxjQUFjO1FBQ2hCO0lBQ0Y7QUFDRixFQUFFO0FBRUYsK0JBQStCO0FBQ2hCLFNBQVNDO0lBQ3RCLE9BQU8sTUFBTSw4REFBOEQ7QUFDN0U7S0FGd0JBIiwic291cmNlcyI6WyIvYXBwL3BhZ2VzL3Byb2Nlc3Nfc2V0L3Byb2Nlc3NBcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcGFnZXMvcHJvY2Vzc19zZXQvcHJvY2Vzc0FwaS5qcyAtIEFQSSBmdW5jdGlvbnMgZm9yIHByb2Nlc3Nfc2V0IHdpdGggaW1wcm92ZWQgY29ubmVjdGlvbiBoYW5kbGluZ1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIGZvciBtYWtpbmcgQVBJIHJlcXVlc3RzIHdpdGggcmV0cnkgYW5kIGJldHRlciBlcnJvciBoYW5kbGluZ1xuY29uc3QgZmV0Y2hXaXRoUmV0cnkgPSBhc3luYyAodXJsLCBvcHRpb25zID0ge30sIHJldHJpZXMgPSAyKSA9PiB7XG4gIGxldCBsYXN0RXJyb3I7XG4gIFxuICAvLyBHZXQgQVBJIGtleSBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlXG4gIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVic7XG4gIFxuICAvLyBHZXQgYmFja2VuZCBVUkwgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICBjb25zdCBiYWNrZW5kVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwgfHwgJyc7XG4gIFxuICAvLyBFbnN1cmUgVVJMIGlzIGFic29sdXRlXG4gIGNvbnN0IGFic29sdXRlVXJsID0gdXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSA/IHVybCA6IGAke2JhY2tlbmRVcmx9JHt1cmx9YDtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDw9IHJldHJpZXM7IGkrKykge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgJHthYnNvbHV0ZVVybH0ke2kgPiAwID8gYCAocmV0cnkgJHtpfS8ke3JldHJpZXN9KWAgOiAnJ31gKTtcbiAgICAgIFxuICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgODAwMCk7IC8vIDggc2Vjb25kIHRpbWVvdXRcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhYnNvbHV0ZVVybCwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IGFwaUtleVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcmVzcG9uc2UgZXJyb3JzXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQVBJIGVycm9yICgke3Jlc3BvbnNlLnN0YXR1c30pOmAsIGVycm9yVGV4dCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciA0MDEgKFVuYXV0aG9yaXplZClcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEFQSSBrZXkuIFBsZWFzZSBjaGVjayB5b3VyIGNvbmZpZ3VyYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtlcnJvclRleHQgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJ5IHRvIHBhcnNlIEpTT04gcmVzcG9uc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdKU09OIHBhcnNlIGVycm9yOicsIHBhcnNlRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSByZXNwb25zZTogJHtwYXJzZUVycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZldGNoIGVycm9yIChhdHRlbXB0ICR7aSsxfS8ke3JldHJpZXMrMX0pOmAsIGVycm9yKTtcbiAgICAgIGxhc3RFcnJvciA9IGVycm9yO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGlzIHdhcyBhbiBhYm9ydCBlcnJvciAodGltZW91dCksIGxvZyBpdCBzcGVjaWZpY2FsbHlcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUmVxdWVzdCB0aW1lZCBvdXQnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgaGF2ZSByZXRyaWVzIGxlZnQsIHdhaXQgYmVmb3JlIHRyeWluZyBhZ2FpblxuICAgICAgaWYgKGkgPCByZXRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGRlbGF5ID0gMTAwMCAqIE1hdGgucG93KDIsIGkpOyAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmOiAxcywgMnMsIDRzLCBldGMuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBXYWl0aW5nICR7ZGVsYXl9bXMgYmVmb3JlIHJldHJ5Li4uYCk7XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgd2UgZ290IGhlcmUsIGFsbCByZXRyaWVzIGZhaWxlZFxuICB0aHJvdyBsYXN0RXJyb3I7XG59O1xuXG4vLyBBUEkgY29uZmlndXJhdGlvblxuY29uc3QgQVBJX0JBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2JhY2tlbmQ6ODAwMCc7XG5jb25zdCBBUElfS0VZID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWTtcblxuLy8gQ2hlY2sgaWYgdGhlIGJhY2tlbmQgaXMgY29ubmVjdGVkXG5leHBvcnQgY29uc3QgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBjb25zb2xlLmxvZygnQ2hlY2tpbmcgYmFja2VuZCBjb25uZWN0aW9uLi4uJyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSgnL2FwaS9jaGVjay1iYWNrZW5kLWNvbm5lY3Rpb24nKTtcbiAgICAvLyBjb25zb2xlLmxvZygnQmFja2VuZCBjb25uZWN0aW9uIHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGNvbm5lY3RlZDogcmVzcG9uc2UuY29ubmVjdGVkIHx8IGZhbHNlLFxuICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfHwgJ3Vua25vd24nXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdCYWNrZW5kIGNvbm5lY3Rpb24gY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBjb25uZWN0ZWQ6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBzdGF0dXM6ICdlcnJvcidcbiAgICB9O1xuICB9XG59O1xuICBcbi8vIEdldCBsaXN0IG9mIGZpbGVzIGZyb20gYm90aCBjYXB0dXJlIGFuZCBlbmhhbmNlIGZvbGRlcnNcbmV4cG9ydCBjb25zdCBnZXRGaWxlc0xpc3QgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSgnL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvZmlsZS1hcGk/b3BlcmF0aW9uPWxpc3QnKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZ2V0IGZpbGVzIGxpc3QnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gT3JnYW5pemUgZmlsZXMgaW50byBjYXB0dXJlIGFuZCBlbmhhbmNlIGFycmF5c1xuICAgIGNvbnN0IG9yZ2FuaXplZEZpbGVzID0ge1xuICAgICAgY2FwdHVyZTogW10sXG4gICAgICBlbmhhbmNlOiBbXVxuICAgIH07XG4gICAgXG4gICAgaWYgKHJlc3BvbnNlLmZpbGVzICYmIHJlc3BvbnNlLmZpbGVzLmNhcHR1cmUgJiYgcmVzcG9uc2UuZmlsZXMuZW5oYW5jZSkge1xuICAgICAgb3JnYW5pemVkRmlsZXMuY2FwdHVyZSA9IHJlc3BvbnNlLmZpbGVzLmNhcHR1cmUubWFwKGZpbGVuYW1lID0+ICh7XG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBwYXRoOiBgL2NhcHR1cmVzL2V5ZV90cmFja2luZ19jYXB0dXJlcy8ke2ZpbGVuYW1lfWAsXG4gICAgICAgIGZpbGVfdHlwZTogZmlsZW5hbWUuc3BsaXQoJy4nKS5wb3AoKSxcbiAgICAgICAgc2l6ZTogMCAvLyBTaXplIHdpbGwgYmUgdXBkYXRlZCB3aGVuIGZpbGUgaXMgYWNjZXNzZWRcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgb3JnYW5pemVkRmlsZXMuZW5oYW5jZSA9IHJlc3BvbnNlLmZpbGVzLmVuaGFuY2UubWFwKGZpbGVuYW1lID0+ICh7XG4gICAgICAgIGZpbGVuYW1lLFxuICAgICAgICBwYXRoOiBgL2NhcHR1cmVzL2VuaGFuY2UvJHtmaWxlbmFtZX1gLFxuICAgICAgICBmaWxlX3R5cGU6IGZpbGVuYW1lLnNwbGl0KCcuJykucG9wKCksXG4gICAgICAgIHNpemU6IDAgLy8gU2l6ZSB3aWxsIGJlIHVwZGF0ZWQgd2hlbiBmaWxlIGlzIGFjY2Vzc2VkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgZmlsZXM6IG9yZ2FuaXplZEZpbGVzLFxuICAgICAgbWVzc2FnZTogcmVzcG9uc2UubWVzc2FnZSB8fCAnRmlsZXMgcmV0cmlldmVkIHN1Y2Nlc3NmdWxseSdcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZmlsZXMgbGlzdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGdldCBmaWxlcyBsaXN0JyxcbiAgICAgIGZpbGVzOiB7IGNhcHR1cmU6IFtdLCBlbmhhbmNlOiBbXSB9XG4gICAgfTtcbiAgfVxufTtcbiAgXG4vLyBDaGVjayBmaWxlIGNvbXBsZXRlbmVzcyAoaWYgd2ViY2FtLCBzY3JlZW4sIGFuZCBwYXJhbWV0ZXIgZmlsZXMgZXhpc3QgZm9yIGVhY2ggc2V0KVxuZXhwb3J0IGNvbnN0IGNoZWNrRmlsZXNDb21wbGV0ZW5lc3MgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGVjay1maWxlcycpO1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yIHx8ICdGYWlsZWQgdG8gY2hlY2sgZmlsZXMnKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGNoZWNrIGZpbGVzIGluIGV5ZV90cmFja2luZ19jYXB0dXJlcyBmb2xkZXJcbiAgICBjb25zdCBjYXB0dXJlRmlsZXMgPSBkYXRhLmZpbGVzLmNhcHR1cmUgfHwgW107XG4gICAgY29uc3QgZmlsZU51bWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgXG4gICAgLy8gRXh0cmFjdCBmaWxlIG51bWJlcnMgZnJvbSBjYXB0dXJlIGZpbGVzXG4gICAgY2FwdHVyZUZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICBjb25zdCBtYXRjaCA9IGZpbGUuZmlsZW5hbWUubWF0Y2goL18oXFxkKylcXC4vKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBmaWxlTnVtYmVycy5hZGQocGFyc2VJbnQobWF0Y2hbMV0pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENoZWNrIGZvciBtaXNzaW5nIGZpbGVzIGluIHNlcXVlbmNlXG4gICAgY29uc3QgbWlzc2luZ0ZpbGVzID0gW107XG4gICAgaWYgKGZpbGVOdW1iZXJzLnNpemUgPiAwKSB7XG4gICAgICBjb25zdCBtaW5OdW1iZXIgPSBNYXRoLm1pbiguLi5maWxlTnVtYmVycyk7XG4gICAgICBjb25zdCBtYXhOdW1iZXIgPSBNYXRoLm1heCguLi5maWxlTnVtYmVycyk7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGkgPSBtaW5OdW1iZXI7IGkgPD0gbWF4TnVtYmVyOyBpKyspIHtcbiAgICAgICAgaWYgKCFmaWxlTnVtYmVycy5oYXMoaSkpIHtcbiAgICAgICAgICBtaXNzaW5nRmlsZXMucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgaXNDb21wbGV0ZTogbWlzc2luZ0ZpbGVzLmxlbmd0aCA9PT0gMCxcbiAgICAgIG1pc3NpbmdGaWxlczogbWlzc2luZ0ZpbGVzLmxlbmd0aCxcbiAgICAgIHRvdGFsRmlsZXM6IGZpbGVOdW1iZXJzLnNpemVcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGZpbGVzIGNvbXBsZXRlbmVzczonLCBlcnJvcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuICBcbi8vIFByZXZpZXcgYSBzcGVjaWZpYyBmaWxlXG5leHBvcnQgY29uc3QgcHJldmlld0ZpbGUgPSBhc3luYyAoZmlsZW5hbWUpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBjb25zb2xlLmxvZygnRmV0Y2hpbmcgcHJldmlldyBmb3IgZmlsZTonLCBmaWxlbmFtZSk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeShgL2FwaS9wcmV2aWV3LWFwaT9maWxlbmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChmaWxlbmFtZSl9YCk7XG4gICAgLy8gY29uc29sZS5sb2coJ1JhdyBwcmV2aWV3IHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiByZXNwb25zZSBoYXMgdGhlIGV4cGVjdGVkIGZvcm1hdFxuICAgIGlmICghcmVzcG9uc2UgfHwgdHlwZW9mIHJlc3BvbnNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIHByZXZpZXcgQVBJJyk7XG4gICAgfVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBnZXQgcHJldmlldycpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IHJlc3BvbnNlLmRhdGEsXG4gICAgICB0eXBlOiByZXNwb25zZS50eXBlLFxuICAgICAgbWVzc2FnZTogcmVzcG9uc2UubWVzc2FnZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJldmlld2luZyBmaWxlOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZ2V0IHByZXZpZXcnXG4gICAgfTtcbiAgfVxufTtcbiAgXG4vLyBDaGVjayBpZiBmaWxlcyBuZWVkIHByb2Nlc3NpbmdcbmV4cG9ydCBjb25zdCBjaGVja0ZpbGVzTmVlZFByb2Nlc3NpbmcgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSgnL2FwaS9maWxlLWFwaT9vcGVyYXRpb249bGlzdCcpO1xuICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLm1lc3NhZ2UgfHwgJ0ZhaWxlZCB0byBnZXQgZmlsZXMgbGlzdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdW5pcXVlIHNldCBudW1iZXJzIGZyb20gZWFjaCBmb2xkZXJcbiAgICBjb25zdCBjYXB0dXJlU2V0cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBlbmhhbmNlU2V0cyA9IG5ldyBTZXQoKTtcbiAgICBcbiAgICBpZiAocmVzcG9uc2UuZmlsZXMgJiYgQXJyYXkuaXNBcnJheShyZXNwb25zZS5maWxlcykpIHtcbiAgICAgIHJlc3BvbnNlLmZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gZmlsZS5maWxlbmFtZS5tYXRjaCgvXyhcXGQrKVxcLi8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBjb25zdCBzZXROdW1iZXIgPSBwYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgICAgaWYgKGZpbGUucGF0aC5pbmNsdWRlcygnZXllX3RyYWNraW5nX2NhcHR1cmVzJykpIHtcbiAgICAgICAgICAgIGNhcHR1cmVTZXRzLmFkZChzZXROdW1iZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZS5wYXRoLmluY2x1ZGVzKCdlbmhhbmNlJykpIHtcbiAgICAgICAgICAgIGVuaGFuY2VTZXRzLmFkZChzZXROdW1iZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhcHR1cmVDb3VudCA9IGNhcHR1cmVTZXRzLnNpemU7XG4gICAgY29uc3QgZW5oYW5jZUNvdW50ID0gZW5oYW5jZVNldHMuc2l6ZTtcbiAgICBjb25zdCBuZWVkc1Byb2Nlc3NpbmcgPSBjYXB0dXJlQ291bnQgPiBlbmhhbmNlQ291bnQ7XG4gICAgY29uc3QgZmlsZXNUb1Byb2Nlc3MgPSBjYXB0dXJlQ291bnQgLSBlbmhhbmNlQ291bnQ7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBuZWVkc1Byb2Nlc3NpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBlbmhhbmNlQ291bnQsXG4gICAgICBmaWxlc1RvUHJvY2Vzc1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgZmlsZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgbmVlZHNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgIGNhcHR1cmVDb3VudDogMCxcbiAgICAgIGVuaGFuY2VDb3VudDogMCxcbiAgICAgIGZpbGVzVG9Qcm9jZXNzOiAwXG4gICAgfTtcbiAgfVxufTtcblxuLy8gUHJvY2VzcyBmaWxlc1xuZXhwb3J0IGNvbnN0IHByb2Nlc3NGaWxlcyA9IGFzeW5jIChzZXROdW1iZXJzKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1N0YXJ0aW5nIHByb2Nlc3NpbmcgZm9yIHNldHM6Jywgc2V0TnVtYmVycyk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhSZXRyeSgnL2FwaS9wcm9jZXNzLWltYWdlcycsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc2V0X251bWJlcnM6IHNldE51bWJlcnMgfSksXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBtZXNzYWdlOiByZXNwb25zZS5tZXNzYWdlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIGZpbGVzOicsIGVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gcHJvY2VzcyBmaWxlcydcbiAgICB9O1xuICB9XG59O1xuICBcbi8vIENvbXBhcmUgZmlsZXMgYmV0d2VlbiBjYXB0dXJlIGFuZCBlbmhhbmNlIGZvbGRlcnNcbmV4cG9ydCBjb25zdCBjb21wYXJlRmlsZUNvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KCcvYXBpL2ZpbGUtYXBpP29wZXJhdGlvbj1jb21wYXJlJyk7XG4gICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2UubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGNvbXBhcmUgZmlsZSBjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBjYXB0dXJlQ291bnQ6IHJlc3BvbnNlLmNhcHR1cmVDb3VudCxcbiAgICAgIGVuaGFuY2VDb3VudDogcmVzcG9uc2UuZW5oYW5jZUNvdW50LFxuICAgICAgbmVlZHNQcm9jZXNzaW5nOiByZXNwb25zZS5uZWVkc1Byb2Nlc3NpbmdcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvbXBhcmluZyBmaWxlIGNvdW50czonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgIGNhcHR1cmVDb3VudDogMCxcbiAgICAgIGVuaGFuY2VDb3VudDogMCxcbiAgICAgIG5lZWRzUHJvY2Vzc2luZzogZmFsc2VcbiAgICB9O1xuICB9XG59O1xuICBcbi8vIENoZWNrIGlmIHByb2Nlc3NpbmcgaXMgY3VycmVudGx5IHJ1bm5pbmdcbmV4cG9ydCBjb25zdCBjaGVja1Byb2Nlc3NpbmdTdGF0dXMgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1JlcXVlc3RpbmcgcHJvY2Vzc2luZyBzdGF0dXMuLi4nKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFJldHJ5KCcvYXBpL3Byb2Nlc3Mtc3RhdHVzLWFwaScsIHt9LCAxKTsgLy8gT25seSAxIHJldHJ5IGZvciBzdGF0dXMgY2hlY2tzXG4gICAgXG4gICAgLy8gSWYgZmV0Y2ggc3VjY2VlZGVkIGJ1dCByZXNwb25zZSBpcyBtYWxmb3JtZWQsIGhhbmRsZSBpdCBncmFjZWZ1bGx5XG4gICAgaWYgKCFyZXNwb25zZSB8fCB0eXBlb2YgcmVzcG9uc2UgIT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvcm1hdDonLCByZXNwb25zZSk7XG4gICAgICByZXR1cm4geyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgICBlcnJvcjogYEludmFsaWQgcmVzcG9uc2UgZm9ybWF0OiAke3R5cGVvZiByZXNwb25zZX1gLFxuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgcHJvY2Vzc2luZyBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHJldHVybiB7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlXG4gICAgfTtcbiAgfVxufTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUHJvY2Vzc0FwaVBhZ2UoKSB7XG4gIHJldHVybiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xufSJdLCJuYW1lcyI6WyJmZXRjaFdpdGhSZXRyeSIsInVybCIsIm9wdGlvbnMiLCJyZXRyaWVzIiwibGFzdEVycm9yIiwiYXBpS2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9LRVkiLCJiYWNrZW5kVXJsIiwiTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwiLCJhYnNvbHV0ZVVybCIsInN0YXJ0c1dpdGgiLCJpIiwiY29uc29sZSIsImxvZyIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJmZXRjaCIsInNpZ25hbCIsImhlYWRlcnMiLCJjbGVhclRpbWVvdXQiLCJvayIsImVycm9yVGV4dCIsInRleHQiLCJlcnJvciIsInN0YXR1cyIsIkVycm9yIiwic3RhdHVzVGV4dCIsImRhdGEiLCJqc29uIiwicGFyc2VFcnJvciIsIm1lc3NhZ2UiLCJuYW1lIiwiZGVsYXkiLCJNYXRoIiwicG93IiwiUHJvbWlzZSIsInJlc29sdmUiLCJBUElfQkFTRV9VUkwiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQVBJX0tFWSIsImNoZWNrQmFja2VuZENvbm5lY3Rpb24iLCJzdWNjZXNzIiwiY29ubmVjdGVkIiwiZ2V0RmlsZXNMaXN0Iiwib3JnYW5pemVkRmlsZXMiLCJjYXB0dXJlIiwiZW5oYW5jZSIsImZpbGVzIiwibWFwIiwiZmlsZW5hbWUiLCJwYXRoIiwiZmlsZV90eXBlIiwic3BsaXQiLCJwb3AiLCJzaXplIiwiY2hlY2tGaWxlc0NvbXBsZXRlbmVzcyIsImNhcHR1cmVGaWxlcyIsImZpbGVOdW1iZXJzIiwiU2V0IiwiZm9yRWFjaCIsImZpbGUiLCJtYXRjaCIsImFkZCIsInBhcnNlSW50IiwibWlzc2luZ0ZpbGVzIiwibWluTnVtYmVyIiwibWluIiwibWF4TnVtYmVyIiwibWF4IiwiaGFzIiwicHVzaCIsImlzQ29tcGxldGUiLCJsZW5ndGgiLCJ0b3RhbEZpbGVzIiwicHJldmlld0ZpbGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0eXBlIiwiY2hlY2tGaWxlc05lZWRQcm9jZXNzaW5nIiwiY2FwdHVyZVNldHMiLCJlbmhhbmNlU2V0cyIsIkFycmF5IiwiaXNBcnJheSIsInNldE51bWJlciIsImluY2x1ZGVzIiwiY2FwdHVyZUNvdW50IiwiZW5oYW5jZUNvdW50IiwibmVlZHNQcm9jZXNzaW5nIiwiZmlsZXNUb1Byb2Nlc3MiLCJwcm9jZXNzRmlsZXMiLCJzZXROdW1iZXJzIiwibWV0aG9kIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJzZXRfbnVtYmVycyIsImNvbXBhcmVGaWxlQ291bnRzIiwiY2hlY2tQcm9jZXNzaW5nU3RhdHVzIiwiaXNQcm9jZXNzaW5nIiwiUHJvY2Vzc0FwaVBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/process_set/processApi.js\n"));

/***/ })

});