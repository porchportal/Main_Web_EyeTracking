"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Helper/savefile.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureImagesAtPoint: () => (/* binding */ captureImagesAtPoint),\n/* harmony export */   saveCSVToServer: () => (/* binding */ saveCSVToServer),\n/* harmony export */   saveImageToServer: () => (/* binding */ saveImageToServer)\n/* harmony export */ });\n// Helper/savefile.js - Added highest resolution webcam capture\n/**\n * Resize an image to fit within a certain size limit\n * @param {string} imageDataUrl - Base64 encoded image data\n * @param {number} maxWidth - Maximum width of the resized image\n * @param {number} maxHeight - Maximum height of the resized image\n * @param {number} quality - JPEG quality (0-1)\n * @returns {Promise<string>} - Resized image data URL\n */ const resizeImage = async function(imageDataUrl) {\n    let maxWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 800, maxHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 600, quality = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85;\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = new Image();\n            img.onload = ()=>{\n                // Calculate new dimensions while maintaining aspect ratio\n                let width = img.width;\n                let height = img.height;\n                if (width > maxWidth) {\n                    height = Math.round(height * (maxWidth / width));\n                    width = maxWidth;\n                }\n                if (height > maxHeight) {\n                    width = Math.round(width * (maxHeight / height));\n                    height = maxHeight;\n                }\n                // Create canvas for resizing\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                // Draw and resize image on canvas\n                const ctx = canvas.getContext('2d');\n                ctx.drawImage(img, 0, 0, width, height);\n                // Convert to JPEG with specified quality\n                const resizedDataUrl = canvas.toDataURL('image/jpeg', quality);\n                resolve(resizedDataUrl);\n            };\n            img.onerror = (err)=>reject(err);\n            img.src = imageDataUrl;\n        } catch (err) {\n            reject(err);\n        }\n    });\n};\n/**\n * Save an image or data to the server with group ID to ensure consistent numbering\n * @param {string} imageData - Base64 encoded image data\n * @param {string} filename - Filename pattern to save as\n * @param {string} type - Type of file (screen, webcam, parameters)\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveImageToServer = async function(imageData, filename, type) {\n    let folder = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'eye_tracking_captures', captureGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    try {\n        const response = await fetch('/api/save-capture', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                imageData,\n                filename,\n                type,\n                folder,\n                captureGroup\n            })\n        });\n        if (!response.ok) {\n            console.error(\"Server returned \".concat(response.status, \" for \").concat(type));\n            // If the error is 413 (payload too large) and it's an image, try resizing\n            if (response.status === 413 && type !== 'parameters') {\n                console.warn(\"Image too large for server (413 error), will resize and retry\");\n                // Start with higher quality and progressively reduce quality/size until it fits\n                const sizes = [\n                    {\n                        width: 1920,\n                        height: 1080,\n                        quality: 0.9\n                    },\n                    {\n                        width: 1280,\n                        height: 720,\n                        quality: 0.85\n                    },\n                    {\n                        width: 800,\n                        height: 600,\n                        quality: 0.8\n                    },\n                    {\n                        width: 640,\n                        height: 480,\n                        quality: 0.75\n                    }\n                ];\n                for (const { width, height, quality } of sizes){\n                    const resizedImage = await resizeImage(imageData, width, height, quality);\n                    try {\n                        const retryResponse = await fetch('/api/save-capture', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify({\n                                imageData: resizedImage,\n                                filename,\n                                type,\n                                folder,\n                                captureGroup\n                            })\n                        });\n                        if (retryResponse.ok) {\n                            console.log(\"Successfully saved resized \".concat(type, \" at \").concat(width, \"x\").concat(height, \", quality \").concat(quality));\n                            return await retryResponse.json();\n                        }\n                    } catch (retryError) {\n                        console.error(\"Error during retry for \".concat(type, \":\"), retryError);\n                    }\n                }\n                return {\n                    success: false,\n                    error: \"Failed to save image even after resizing\"\n                };\n            }\n            return {\n                success: false,\n                error: \"Server returned \".concat(response.status)\n            };\n        }\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error(\"Error saving \".concat(type, \":\"), error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Save CSV data to the server\n * @param {string} csvData - CSV data\n * @param {string} filename - Filename pattern to save as\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveCSVToServer = async function(csvData, filename) {\n    let folder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'eye_tracking_captures', captureGroup = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        const csvBlob = new Blob([\n            csvData\n        ], {\n            type: 'text/csv'\n        });\n        const reader = new FileReader();\n        const csvDataUrl = await new Promise((resolve)=>{\n            reader.onloadend = ()=>resolve(reader.result);\n            reader.readAsDataURL(csvBlob);\n        });\n        const result = await saveImageToServer(csvDataUrl, filename, 'parameters', folder, captureGroup);\n        return result;\n    } catch (error) {\n        console.error('Error saving CSV:', error);\n        return null;\n    }\n};\n/**\n * Get the highest resolution camera constraints supported by the device\n * @returns {Promise<MediaStreamConstraints>} - Camera constraints with highest resolution\n */ const getHighestResolutionConstraints = async ()=>{\n    // Try to get all available camera capabilities first\n    try {\n        var _videoTrack_getCapabilities;\n        // Get a temporary access to the camera\n        const tempStream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        const videoTrack = tempStream.getVideoTracks()[0];\n        // Get capabilities\n        const capabilities = (_videoTrack_getCapabilities = videoTrack.getCapabilities) === null || _videoTrack_getCapabilities === void 0 ? void 0 : _videoTrack_getCapabilities.call(videoTrack);\n        console.log(\"Camera capabilities:\", capabilities);\n        // Stop the temporary stream\n        videoTrack.stop();\n        if (capabilities && capabilities.width && capabilities.height) {\n            // Use the max width and height from device capabilities\n            return {\n                video: {\n                    width: {\n                        ideal: capabilities.width.max\n                    },\n                    height: {\n                        ideal: capabilities.height.max\n                    }\n                }\n            };\n        }\n    } catch (err) {\n        console.log(\"Could not get camera capabilities:\", err);\n    }\n    // Fallback: try standard resolutions in order\n    const resolutions = [\n        {\n            width: {\n                ideal: 4096\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 3840\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 2560\n            },\n            height: {\n                ideal: 1440\n            }\n        },\n        {\n            width: {\n                ideal: 1920\n            },\n            height: {\n                ideal: 1080\n            }\n        },\n        {\n            width: {\n                ideal: 1280\n            },\n            height: {\n                ideal: 720\n            }\n        },\n        {\n            width: {\n                ideal: 640\n            },\n            height: {\n                ideal: 480\n            }\n        },\n        {} // Default - let browser decide\n    ];\n    // Try the resolutions in order until one works\n    for (const resolution of resolutions){\n        try {\n            const constraints = {\n                video: {\n                    ...resolution,\n                    facingMode: \"user\"\n                }\n            };\n            // Test if this resolution is supported\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n            // Get the actual dimensions\n            const videoTrack = stream.getVideoTracks()[0];\n            const settings = videoTrack.getSettings();\n            console.log(\"Supported resolution:\", settings.width, \"x\", settings.height);\n            // Stop the test stream immediately\n            stream.getTracks().forEach((track)=>track.stop());\n            return constraints;\n        } catch (err) {\n            console.log(\"Resolution not supported: \".concat(JSON.stringify(resolution)));\n        // Continue to next resolution\n        }\n    }\n    // If nothing worked, return basic constraints\n    return {\n        video: true\n    };\n};\n/**\n * Capture and save images at a specific point with consistent numbering\n * @param {Object} options - Capture options\n * @returns {Promise<Object>} - Capture results\n */ const captureImagesAtPoint = async (param)=>{\n    let { point, captureCount = 1, canvasRef, setCaptureCount, showCapturePreview } = param;\n    try {\n        const folder = 'eye_tracking_captures';\n        // Create a unique ID for this capture group\n        const captureGroupId = \"capture-\".concat(Date.now());\n        console.log(\"Generated capture group ID: \".concat(captureGroupId));\n        // File patterns for saving\n        const screenFilename = 'screen_001.jpg'; // Pattern only - server will assign number\n        const webcamFilename = 'webcam_001.jpg'; // Pattern only - server will assign number\n        const parameterFilename = 'parameter_001.csv'; // Pattern only - server will assign number\n        // For logging\n        console.log(\"Starting capture with group ID:\", captureGroupId);\n        const canvas = canvasRef.current;\n        let screenImage = null;\n        let webcamImage = null;\n        let captureNumber = null;\n        // Variables to store webcam resolution\n        let webcamWidth = 0;\n        let webcamHeight = 0;\n        // 1. Prepare all data first\n        // 1.1 Canvas/screen image\n        if (canvas) {\n            screenImage = canvas.toDataURL('image/png');\n        }\n        // 1.2 Webcam image - Try to get the highest resolution available \n        // with device's native capabilities instead of fixed values\n        let webcamImagePreview = null; // Separate lower-resolution version for preview\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            try {\n                // Use existing video element if available\n                // First check if videoTrack has settings info\n                let trackSettings = null;\n                if (videoElement.srcObject) {\n                    const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                    if (videoTrack) {\n                        trackSettings = videoTrack.getSettings();\n                        console.log(\"Video track settings:\", trackSettings);\n                    }\n                }\n                // Get dimensions from track if available, otherwise from element\n                if (trackSettings && trackSettings.width && trackSettings.height) {\n                    webcamWidth = trackSettings.width;\n                    webcamHeight = trackSettings.height;\n                    console.log(\"Using track settings dimensions: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                    const settings = videoTrack.getSettings();\n                    webcamWidth = settings.width || 0;\n                    webcamHeight = settings.height || 0;\n                    +console.log(\"Using track.getSettings(): \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Sanity check - if both dimensions are the same, double-check\n                if (webcamWidth === webcamHeight && webcamWidth > 100) {\n                    console.warn(\"Suspicious square aspect ratio detected, double-checking dimensions\");\n                    // Try to get more reliable info\n                    if (videoElement.srcObject) {\n                        const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                        if (videoTrack) {\n                            const constraints = videoTrack.getConstraints();\n                            console.log(\"Video constraints:\", constraints);\n                            // If constraints have width/height, use those\n                            if (constraints.width && constraints.height) {\n                                if (typeof constraints.width.exact === 'number') {\n                                    webcamWidth = constraints.width.exact;\n                                } else if (typeof constraints.width.ideal === 'number') {\n                                    webcamWidth = constraints.width.ideal;\n                                }\n                                if (typeof constraints.height.exact === 'number') {\n                                    webcamHeight = constraints.height.exact;\n                                } else if (typeof constraints.height.ideal === 'number') {\n                                    webcamHeight = constraints.height.ideal;\n                                }\n                                console.log(\"Updated dimensions from constraints: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            }\n                        }\n                    }\n                }\n                // Final reality check - make sure dimensions are reasonable\n                if (webcamWidth <= 0 || webcamHeight <= 0) {\n                    console.warn(\"Invalid webcam dimensions, using defaults\");\n                    webcamWidth = 640;\n                    webcamHeight = 480;\n                }\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = webcamWidth;\n                tempCanvas.height = webcamHeight;\n                tempCanvas.getContext('2d').drawImage(videoElement, 0, 0, webcamWidth, webcamHeight);\n                // Create high-resolution version for saving\n                webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                // Create lower-resolution version for preview\n                webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                console.log(\"Webcam capture complete at resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n            } catch (err) {\n                console.error(\"Error capturing from existing video element:\", err);\n                webcamWidth = videoElement.videoWidth || 640;\n                webcamHeight = videoElement.videoHeight || 480;\n            }\n        } else {\n            try {\n                // Get highest resolution constraints for this device\n                const constraints = await getHighestResolutionConstraints();\n                console.log(\"Using camera constraints:\", constraints);\n                // Try to get stream with highest resolution\n                const stream = await navigator.mediaDevices.getUserMedia(constraints);\n                // Get the actual dimensions from the track first\n                const videoTrack = stream.getVideoTracks()[0];\n                const trackSettings = videoTrack.getSettings();\n                console.log(\"Actual camera settings:\", trackSettings);\n                // Create temporary video element to get the stream\n                const tempVideo = document.createElement('video');\n                tempVideo.srcObject = stream;\n                tempVideo.muted = true;\n                tempVideo.playsInline = true;\n                tempVideo.autoplay = true;\n                document.body.appendChild(tempVideo);\n                // Need to wait for video to be initialized\n                await new Promise((resolve)=>{\n                    tempVideo.onloadedmetadata = ()=>{\n                        tempVideo.play();\n                        resolve();\n                    };\n                    // Fallback if onloadedmetadata doesn't fire\n                    setTimeout(resolve, 1000);\n                });\n                // Wait a bit longer for the video to actually start playing\n                await new Promise((res)=>setTimeout(res, 500));\n                // Store webcam resolution - prioritize track settings over video element\n                if (trackSettings && trackSettings.width && trackSettings.height) {\n                    webcamWidth = trackSettings.width;\n                    webcamHeight = trackSettings.height;\n                    console.log(\"Using track settings for resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    webcamWidth = tempVideo.videoWidth || 0;\n                    webcamHeight = tempVideo.videoHeight || 0;\n                    console.log(\"Using video element for resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Reality check on dimensions\n                if (webcamWidth <= 0 || webcamHeight <= 0) {\n                    console.warn(\"Invalid webcam dimensions, trying to get from constraints\");\n                    if (constraints.video && typeof constraints.video === 'object') {\n                        if (constraints.video.width && constraints.video.width.ideal) {\n                            webcamWidth = constraints.video.width.ideal;\n                        }\n                        if (constraints.video.height && constraints.video.height.ideal) {\n                            webcamHeight = constraints.video.height.ideal;\n                        }\n                    }\n                    if (webcamWidth <= 0 || webcamHeight <= 0) {\n                        console.warn(\"Still invalid dimensions, using defaults\");\n                        webcamWidth = 640;\n                        webcamHeight = 480;\n                    }\n                }\n                // Final check for square aspect ratio which is usually incorrect\n                if (webcamWidth === webcamHeight && webcamWidth > 100) {\n                    var _videoTrack_getCapabilities;\n                    console.warn(\"Square aspect ratio detected, may be incorrect\");\n                    // Try to get more reliable dimensions\n                    const capabilities = (_videoTrack_getCapabilities = videoTrack.getCapabilities) === null || _videoTrack_getCapabilities === void 0 ? void 0 : _videoTrack_getCapabilities.call(videoTrack);\n                    if (capabilities && capabilities.width && capabilities.height) {\n                        if (capabilities.width.max && capabilities.height.max) {\n                            // Assume the maximum capabilities have the correct aspect ratio\n                            const aspectRatio = capabilities.width.max / capabilities.height.max;\n                            if (Math.abs(aspectRatio - 1.33) < 0.1) {\n                                webcamHeight = Math.round(webcamWidth / 1.33);\n                                console.log(\"Corrected to 4:3 aspect ratio: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            } else if (Math.abs(aspectRatio - 1.78) < 0.1) {\n                                webcamHeight = Math.round(webcamWidth / 1.78);\n                                console.log(\"Corrected to 16:9 aspect ratio: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            }\n                        }\n                    }\n                }\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = webcamWidth;\n                tempCanvas.height = webcamHeight;\n                tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0, webcamWidth, webcamHeight);\n                // Create high-resolution version for saving\n                webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                // Create lower-resolution version for preview\n                webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                console.log(\"High-resolution webcam capture complete: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                // Clean up\n                stream.getTracks().forEach((t)=>t.stop());\n                tempVideo.remove();\n            } catch (err) {\n                console.warn(\"High-resolution webcam capture failed:\", err);\n                // Try one more time with basic constraints\n                try {\n                    const stream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const videoTrack = stream.getVideoTracks()[0];\n                    const trackSettings = videoTrack.getSettings();\n                    const tempVideo = document.createElement('video');\n                    tempVideo.srcObject = stream;\n                    tempVideo.muted = true;\n                    tempVideo.playsInline = true;\n                    document.body.appendChild(tempVideo);\n                    await tempVideo.play();\n                    await new Promise((res)=>setTimeout(res, 300));\n                    // Get dimensions from track settings if available\n                    if (trackSettings && trackSettings.width && trackSettings.height) {\n                        webcamWidth = trackSettings.width;\n                        webcamHeight = trackSettings.height;\n                    } else {\n                        webcamWidth = tempVideo.videoWidth || 0;\n                        webcamHeight = tempVideo.videoHeight || 0;\n                    }\n                    // Final check for invalid dimensions\n                    if (webcamWidth <= 0 || webcamHeight <= 0) {\n                        webcamWidth = 640;\n                        webcamHeight = 480;\n                    }\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0, webcamWidth, webcamHeight);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.9);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.8);\n                    console.log(\"Basic webcam resolution captured: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                    stream.getTracks().forEach((t)=>t.stop());\n                    tempVideo.remove();\n                } catch (fallbackErr) {\n                    console.error(\"All webcam capture methods failed:\", fallbackErr);\n                    webcamWidth = 640;\n                    webcamHeight = 480;\n                }\n            }\n        }\n        // 1.3 Parameter data - Now including webcam resolution\n        const csvData = [\n            \"name,value\",\n            \"dot_x,\".concat(point.x),\n            \"dot_y,\".concat(point.y),\n            \"canvas_width,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.width) || 0),\n            \"canvas_height,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.height) || 0),\n            \"window_width,\".concat(window.innerWidth),\n            \"window_height,\".concat(window.innerHeight),\n            \"webcam_resolution_width,\".concat(webcamWidth),\n            \"webcam_resolution_height,\".concat(webcamHeight),\n            \"timestamp,\".concat(new Date().toISOString()),\n            \"group_id,\".concat(captureGroupId)\n        ].join('\\n');\n        // 2. Save all files with the same group ID so they get the same number\n        // 2.1 Save parameter file\n        const paramResult = await saveCSVToServer(csvData, parameterFilename, folder, captureGroupId);\n        if (paramResult && paramResult.success) {\n            captureNumber = paramResult.number;\n            console.log(\"Server assigned capture number: \".concat(captureNumber, \" for group: \").concat(captureGroupId));\n        }\n        // 2.2 Save screen image if available\n        let screenResult = null;\n        if (screenImage) {\n            screenResult = await saveImageToServer(screenImage, screenFilename, 'screen', folder, captureGroupId);\n        }\n        // 2.3 Save webcam image if available\n        let webcamResult = null;\n        if (webcamImage) {\n            webcamResult = await saveImageToServer(webcamImage, webcamFilename, 'webcam', folder, captureGroupId);\n        }\n        // 3. Show preview if needed - use the lower resolution version for preview\n        if (showCapturePreview && typeof showCapturePreview === 'function') {\n            showCapturePreview(screenImage, webcamImagePreview || webcamImage, point);\n        }\n        // 4. Increment counter for next capture\n        if (setCaptureCount && typeof setCaptureCount === 'function') {\n            setCaptureCount((prevCount)=>prevCount + 1);\n        }\n        // 5. Return results - now including webcam resolution\n        return {\n            screenImage,\n            webcamImage,\n            success: true,\n            point,\n            captureNumber,\n            groupId: captureGroupId,\n            webcamWidth,\n            webcamHeight\n        };\n    } catch (err) {\n        console.error(\"captureImagesAtPoint failed:\", err);\n        return {\n            success: false,\n            error: err.message,\n            screenImage: null,\n            webcamImage: null,\n            webcamWidth: 0,\n            webcamHeight: 0\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0hlbHBlci9zYXZlZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrREFBK0Q7QUFFL0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLGNBQWMsZUFBT0M7UUFBY0MsNEVBQVcsS0FBS0MsNkVBQVksS0FBS0MsMkVBQVU7SUFDbEYsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCLElBQUk7WUFDRixNQUFNQyxNQUFNLElBQUlDO1lBQ2hCRCxJQUFJRSxNQUFNLEdBQUc7Z0JBQ1gsMERBQTBEO2dCQUMxRCxJQUFJQyxRQUFRSCxJQUFJRyxLQUFLO2dCQUNyQixJQUFJQyxTQUFTSixJQUFJSSxNQUFNO2dCQUV2QixJQUFJRCxRQUFRVCxVQUFVO29CQUNwQlUsU0FBU0MsS0FBS0MsS0FBSyxDQUFDRixTQUFVVixDQUFBQSxXQUFXUyxLQUFJO29CQUM3Q0EsUUFBUVQ7Z0JBQ1Y7Z0JBRUEsSUFBSVUsU0FBU1QsV0FBVztvQkFDdEJRLFFBQVFFLEtBQUtDLEtBQUssQ0FBQ0gsUUFBU1IsQ0FBQUEsWUFBWVMsTUFBSztvQkFDN0NBLFNBQVNUO2dCQUNYO2dCQUVBLDZCQUE2QjtnQkFDN0IsTUFBTVksU0FBU0MsU0FBU0MsYUFBYSxDQUFDO2dCQUN0Q0YsT0FBT0osS0FBSyxHQUFHQTtnQkFDZkksT0FBT0gsTUFBTSxHQUFHQTtnQkFFaEIsa0NBQWtDO2dCQUNsQyxNQUFNTSxNQUFNSCxPQUFPSSxVQUFVLENBQUM7Z0JBQzlCRCxJQUFJRSxTQUFTLENBQUNaLEtBQUssR0FBRyxHQUFHRyxPQUFPQztnQkFFaEMseUNBQXlDO2dCQUN6QyxNQUFNUyxpQkFBaUJOLE9BQU9PLFNBQVMsQ0FBQyxjQUFjbEI7Z0JBQ3RERSxRQUFRZTtZQUNWO1lBRUFiLElBQUllLE9BQU8sR0FBRyxDQUFDQyxNQUFRakIsT0FBT2lCO1lBQzlCaEIsSUFBSWlCLEdBQUcsR0FB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NUJTLGVBQWMsZ0JBQTZCLE9BQWZUO1FBQzdFO1FBRUEscUNBQXFDO1FBQ3JDLElBQUk2QyxlQUFlO1FBQ25CLElBQUl0QyxhQUFhO1lBQ2ZzQyxlQUFlLE1BQU05RyxrQkFBa0J3RSxhQUFhSixnQkFBZ0IsVUFBVWhFLFFBQVE2RDtRQUN4RjtRQUVBLHFDQUFxQztRQUNyQyxJQUFJOEMsZUFBZTtRQUNuQixJQUFJdEMsYUFBYTtZQUNmc0MsZUFBZSxNQUFNL0csa0JBQWtCeUUsYUFBYUosZ0JBQWdCLFVBQVVqRSxRQUFRNkQ7UUFDeEY7UUFFQSwyRUFBMkU7UUFDM0UsSUFBSUQsc0JBQXNCLE9BQU9BLHVCQUF1QixZQUFZO1lBQ2xFQSxtQkFBbUJRLGFBQWFLLHNCQUFzQkosYUFBYWI7UUFDckU7UUFFQSx3Q0FBd0M7UUFDeEMsSUFBSUcsbUJBQW1CLE9BQU9BLG9CQUFvQixZQUFZO1lBQzVEQSxnQkFBZ0JpRCxDQUFBQSxZQUFhQSxZQUFZO1FBQzNDO1FBRUEsc0RBQXNEO1FBQ3RELE9BQU87WUFDTHhDO1lBQ0FDO1lBQ0FqRCxTQUFTO1lBQ1RvQztZQUNBYztZQUNBdUMsU0FBU2hEO1lBQ1RVO1lBQ0FDO1FBQ0Y7SUFDRixFQUFFLE9BQU85RSxLQUFLO1FBQ1pnQixRQUFRQyxLQUFLLENBQUMsZ0NBQWdDakI7UUFDOUMsT0FBTztZQUNMMEIsU0FBUztZQUNUVCxPQUFPakIsSUFBSTRCLE9BQU87WUFDbEI4QyxhQUFhO1lBQ2JDLGFBQWE7WUFDYkUsYUFBYTtZQUNiQyxjQUFjO1FBQ2hCO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvSGVscGVyL3NhdmVmaWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhlbHBlci9zYXZlZmlsZS5qcyAtIEFkZGVkIGhpZ2hlc3QgcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZVxuXG4vKipcbiAqIFJlc2l6ZSBhbiBpbWFnZSB0byBmaXQgd2l0aGluIGEgY2VydGFpbiBzaXplIGxpbWl0XG4gKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VEYXRhVXJsIC0gQmFzZTY0IGVuY29kZWQgaW1hZ2UgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gTWF4aW11bSB3aWR0aCBvZiB0aGUgcmVzaXplZCBpbWFnZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIE1heGltdW0gaGVpZ2h0IG9mIHRoZSByZXNpemVkIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eSAtIEpQRUcgcXVhbGl0eSAoMC0xKVxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBSZXNpemVkIGltYWdlIGRhdGEgVVJMXG4gKi9cbmNvbnN0IHJlc2l6ZUltYWdlID0gYXN5bmMgKGltYWdlRGF0YVVybCwgbWF4V2lkdGggPSA4MDAsIG1heEhlaWdodCA9IDYwMCwgcXVhbGl0eSA9IDAuODUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgd2hpbGUgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvXG4gICAgICAgIGxldCB3aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgbGV0IGhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICBpZiAod2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogKG1heFdpZHRoIC8gd2lkdGgpKTtcbiAgICAgICAgICB3aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogKG1heEhlaWdodCAvIGhlaWdodCkpO1xuICAgICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBmb3IgcmVzaXppbmdcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBhbmQgcmVzaXplIGltYWdlIG9uIGNhbnZhc1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCB0byBKUEVHIHdpdGggc3BlY2lmaWVkIHF1YWxpdHlcbiAgICAgICAgY29uc3QgcmVzaXplZERhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSk7XG4gICAgICAgIHJlc29sdmUocmVzaXplZERhdGFVcmwpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgaW1nLm9uZXJyb3IgPSAoZXJyKSA9PiByZWplY3QoZXJyKTtcbiAgICAgIGltZy5zcmMgPSBpbWFnZURhdGFVcmw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTYXZlIGFuIGltYWdlIG9yIGRhdGEgdG8gdGhlIHNlcnZlciB3aXRoIGdyb3VwIElEIHRvIGVuc3VyZSBjb25zaXN0ZW50IG51bWJlcmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGltYWdlRGF0YSAtIEJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIEZpbGVuYW1lIHBhdHRlcm4gdG8gc2F2ZSBhc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUeXBlIG9mIGZpbGUgKHNjcmVlbiwgd2ViY2FtLCBwYXJhbWV0ZXJzKVxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIEZvbGRlciB0byBzYXZlIGluXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FwdHVyZUdyb3VwIC0gVW5pcXVlIElEIGZvciBncm91cGluZyBmaWxlcyBmcm9tIHRoZSBzYW1lIGNhcHR1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gU2VydmVyIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBzYXZlSW1hZ2VUb1NlcnZlciA9IGFzeW5jIChpbWFnZURhdGEsIGZpbGVuYW1lLCB0eXBlLCBmb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJywgY2FwdHVyZUdyb3VwID0gbnVsbCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICBpbWFnZURhdGEsIFxuICAgICAgICBmaWxlbmFtZSwgXG4gICAgICAgIHR5cGUsIFxuICAgICAgICBmb2xkZXIsXG4gICAgICAgIGNhcHR1cmVHcm91cCAvLyBJbmNsdWRlIHRoZSBjYXB0dXJlIGdyb3VwIElEXG4gICAgICB9KVxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c30gZm9yICR7dHlwZX1gKTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIDQxMyAocGF5bG9hZCB0b28gbGFyZ2UpIGFuZCBpdCdzIGFuIGltYWdlLCB0cnkgcmVzaXppbmdcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQxMyAmJiB0eXBlICE9PSAncGFyYW1ldGVycycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB0b28gbGFyZ2UgZm9yIHNlcnZlciAoNDEzIGVycm9yKSwgd2lsbCByZXNpemUgYW5kIHJldHJ5YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCB3aXRoIGhpZ2hlciBxdWFsaXR5IGFuZCBwcm9ncmVzc2l2ZWx5IHJlZHVjZSBxdWFsaXR5L3NpemUgdW50aWwgaXQgZml0c1xuICAgICAgICBjb25zdCBzaXplcyA9IFtcbiAgICAgICAgICB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAsIHF1YWxpdHk6IDAuOSB9LFxuICAgICAgICAgIHsgd2lkdGg6IDEyODAsIGhlaWdodDogNzIwLCBxdWFsaXR5OiAwLjg1IH0sXG4gICAgICAgICAgeyB3aWR0aDogODAwLCBoZWlnaHQ6IDYwMCwgcXVhbGl0eTogMC44IH0sXG4gICAgICAgICAgeyB3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MCwgcXVhbGl0eTogMC43NSB9XG4gICAgICAgIF07XG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSB9IG9mIHNpemVzKSB7XG4gICAgICAgICAgY29uc3QgcmVzaXplZEltYWdlID0gYXdhaXQgcmVzaXplSW1hZ2UoaW1hZ2VEYXRhLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiByZXNpemVkSW1hZ2UsIFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLCBcbiAgICAgICAgICAgICAgICB0eXBlLCBcbiAgICAgICAgICAgICAgICBmb2xkZXIsXG4gICAgICAgICAgICAgICAgY2FwdHVyZUdyb3VwXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJldHJ5UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBzYXZlZCByZXNpemVkICR7dHlwZX0gYXQgJHt3aWR0aH14JHtoZWlnaHR9LCBxdWFsaXR5ICR7cXVhbGl0eX1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHJldHJ5RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyByZXRyeSBmb3IgJHt0eXBlfTpgLCByZXRyeUVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gc2F2ZSBpbWFnZSBldmVuIGFmdGVyIHJlc2l6aW5nXCIgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgU2VydmVyIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfWAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nICR7dHlwZX06YCwgZXJyb3IpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICB9XG59O1xuXG4vKipcbiAqIFNhdmUgQ1NWIGRhdGEgdG8gdGhlIHNlcnZlclxuICogQHBhcmFtIHtzdHJpbmd9IGNzdkRhdGEgLSBDU1YgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gRmlsZW5hbWUgcGF0dGVybiB0byBzYXZlIGFzXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVyIC0gRm9sZGVyIHRvIHNhdmUgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjYXB0dXJlR3JvdXAgLSBVbmlxdWUgSUQgZm9yIGdyb3VwaW5nIGZpbGVzIGZyb20gdGhlIHNhbWUgY2FwdHVyZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBTZXJ2ZXIgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNvbnN0IHNhdmVDU1ZUb1NlcnZlciA9IGFzeW5jIChjc3ZEYXRhLCBmaWxlbmFtZSwgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsIGNhcHR1cmVHcm91cCA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjc3ZCbG9iID0gbmV3IEJsb2IoW2NzdkRhdGFdLCB7IHR5cGU6ICd0ZXh0L2NzdicgfSk7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBjb25zdCBjc3ZEYXRhVXJsID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcihjc3ZEYXRhVXJsLCBmaWxlbmFtZSwgJ3BhcmFtZXRlcnMnLCBmb2xkZXIsIGNhcHR1cmVHcm91cCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgQ1NWOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvbiBjYW1lcmEgY29uc3RyYWludHMgc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+fSAtIENhbWVyYSBjb25zdHJhaW50cyB3aXRoIGhpZ2hlc3QgcmVzb2x1dGlvblxuICovXG5jb25zdCBnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzID0gYXN5bmMgKCkgPT4ge1xuICAvLyBUcnkgdG8gZ2V0IGFsbCBhdmFpbGFibGUgY2FtZXJhIGNhcGFiaWxpdGllcyBmaXJzdFxuICB0cnkge1xuICAgIC8vIEdldCBhIHRlbXBvcmFyeSBhY2Nlc3MgdG8gdGhlIGNhbWVyYVxuICAgIGNvbnN0IHRlbXBTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB0ZW1wU3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgXG4gICAgLy8gR2V0IGNhcGFiaWxpdGllc1xuICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHZpZGVvVHJhY2suZ2V0Q2FwYWJpbGl0aWVzPy4oKTtcbiAgICBjb25zb2xlLmxvZyhcIkNhbWVyYSBjYXBhYmlsaXRpZXM6XCIsIGNhcGFiaWxpdGllcyk7XG4gICAgXG4gICAgLy8gU3RvcCB0aGUgdGVtcG9yYXJ5IHN0cmVhbVxuICAgIHZpZGVvVHJhY2suc3RvcCgpO1xuICAgIFxuICAgIGlmIChjYXBhYmlsaXRpZXMgJiYgY2FwYWJpbGl0aWVzLndpZHRoICYmIGNhcGFiaWxpdGllcy5oZWlnaHQpIHtcbiAgICAgIC8vIFVzZSB0aGUgbWF4IHdpZHRoIGFuZCBoZWlnaHQgZnJvbSBkZXZpY2UgY2FwYWJpbGl0aWVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIHdpZHRoOiB7IGlkZWFsOiBjYXBhYmlsaXRpZXMud2lkdGgubWF4IH0sXG4gICAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiBjYXBhYmlsaXRpZXMuaGVpZ2h0Lm1heCB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCBnZXQgY2FtZXJhIGNhcGFiaWxpdGllczpcIiwgZXJyKTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IHRyeSBzdGFuZGFyZCByZXNvbHV0aW9ucyBpbiBvcmRlclxuICBjb25zdCByZXNvbHV0aW9ucyA9IFtcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiA0MDk2IH0sIGhlaWdodDogeyBpZGVhbDogMjE2MCB9IH0sIC8vIDRLXG4gICAgeyB3aWR0aDogeyBpZGVhbDogMzg0MCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDIxNjAgfSB9LCAvLyA0SyBVSERcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiAyNTYwIH0sIGhlaWdodDogeyBpZGVhbDogMTQ0MCB9IH0sIC8vIDJLIFFIRFxuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDE5MjAgfSwgaGVpZ2h0OiB7IGlkZWFsOiAxMDgwIH0gfSwgLy8gRnVsbCBIRFxuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDEyODAgfSwgaGVpZ2h0OiB7IGlkZWFsOiA3MjAgfSB9LCAgLy8gSERcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiA2NDAgfSwgaGVpZ2h0OiB7IGlkZWFsOiA0ODAgfSB9LCAgIC8vIFZHQVxuICAgIHt9ICAvLyBEZWZhdWx0IC0gbGV0IGJyb3dzZXIgZGVjaWRlXG4gIF07XG5cbiAgLy8gVHJ5IHRoZSByZXNvbHV0aW9ucyBpbiBvcmRlciB1bnRpbCBvbmUgd29ya3NcbiAgZm9yIChjb25zdCByZXNvbHV0aW9uIG9mIHJlc29sdXRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIC4uLnJlc29sdXRpb24sXG4gICAgICAgICAgZmFjaW5nTW9kZTogXCJ1c2VyXCJcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gVGVzdCBpZiB0aGlzIHJlc29sdXRpb24gaXMgc3VwcG9ydGVkXG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgYWN0dWFsIGRpbWVuc2lvbnNcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgY29uc29sZS5sb2coXCJTdXBwb3J0ZWQgcmVzb2x1dGlvbjpcIiwgc2V0dGluZ3Mud2lkdGgsIFwieFwiLCBzZXR0aW5ncy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBTdG9wIHRoZSB0ZXN0IHN0cmVhbSBpbW1lZGlhdGVseVxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGNvbnN0cmFpbnRzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coYFJlc29sdXRpb24gbm90IHN1cHBvcnRlZDogJHtKU09OLnN0cmluZ2lmeShyZXNvbHV0aW9uKX1gKTtcbiAgICAgIC8vIENvbnRpbnVlIHRvIG5leHQgcmVzb2x1dGlvblxuICAgIH1cbiAgfVxuICBcbiAgLy8gSWYgbm90aGluZyB3b3JrZWQsIHJldHVybiBiYXNpYyBjb25zdHJhaW50c1xuICByZXR1cm4geyB2aWRlbzogdHJ1ZSB9O1xufTtcblxuLyoqXG4gKiBDYXB0dXJlIGFuZCBzYXZlIGltYWdlcyBhdCBhIHNwZWNpZmljIHBvaW50IHdpdGggY29uc2lzdGVudCBudW1iZXJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENhcHR1cmUgcmVzdWx0c1xuICovXG5leHBvcnQgY29uc3QgY2FwdHVyZUltYWdlc0F0UG9pbnQgPSBhc3luYyAoeyBwb2ludCwgY2FwdHVyZUNvdW50ID0gMSwgY2FudmFzUmVmLCBzZXRDYXB0dXJlQ291bnQsIHNob3dDYXB0dXJlUHJldmlldyB9KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcyc7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIGNhcHR1cmUgZ3JvdXBcbiAgICBjb25zdCBjYXB0dXJlR3JvdXBJZCA9IGBjYXB0dXJlLSR7RGF0ZS5ub3coKX1gO1xuICAgIGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgY2FwdHVyZSBncm91cCBJRDogJHtjYXB0dXJlR3JvdXBJZH1gKTtcbiAgICBcbiAgICAvLyBGaWxlIHBhdHRlcm5zIGZvciBzYXZpbmdcbiAgICBjb25zdCBzY3JlZW5GaWxlbmFtZSA9ICdzY3JlZW5fMDAxLmpwZyc7ICAvLyBQYXR0ZXJuIG9ubHkgLSBzZXJ2ZXIgd2lsbCBhc3NpZ24gbnVtYmVyXG4gICAgY29uc3Qgd2ViY2FtRmlsZW5hbWUgPSAnd2ViY2FtXzAwMS5qcGcnOyAgLy8gUGF0dGVybiBvbmx5IC0gc2VydmVyIHdpbGwgYXNzaWduIG51bWJlclxuICAgIGNvbnN0IHBhcmFtZXRlckZpbGVuYW1lID0gJ3BhcmFtZXRlcl8wMDEuY3N2JzsgIC8vIFBhdHRlcm4gb25seSAtIHNlcnZlciB3aWxsIGFzc2lnbiBudW1iZXJcbiAgICBcbiAgICAvLyBGb3IgbG9nZ2luZ1xuICAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgY2FwdHVyZSB3aXRoIGdyb3VwIElEOlwiLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgbGV0IHNjcmVlbkltYWdlID0gbnVsbDtcbiAgICBsZXQgd2ViY2FtSW1hZ2UgPSBudWxsO1xuICAgIGxldCBjYXB0dXJlTnVtYmVyID0gbnVsbDtcbiAgICBcbiAgICAvLyBWYXJpYWJsZXMgdG8gc3RvcmUgd2ViY2FtIHJlc29sdXRpb25cbiAgICBsZXQgd2ViY2FtV2lkdGggPSAwO1xuICAgIGxldCB3ZWJjYW1IZWlnaHQgPSAwO1xuICAgIFxuICAgIC8vIDEuIFByZXBhcmUgYWxsIGRhdGEgZmlyc3RcbiAgICBcbiAgICAvLyAxLjEgQ2FudmFzL3NjcmVlbiBpbWFnZVxuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHNjcmVlbkltYWdlID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgfVxuXG4gICAgLy8gMS4yIFdlYmNhbSBpbWFnZSAtIFRyeSB0byBnZXQgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvbiBhdmFpbGFibGUgXG4gICAgLy8gd2l0aCBkZXZpY2UncyBuYXRpdmUgY2FwYWJpbGl0aWVzIGluc3RlYWQgb2YgZml4ZWQgdmFsdWVzXG4gICAgbGV0IHdlYmNhbUltYWdlUHJldmlldyA9IG51bGw7IC8vIFNlcGFyYXRlIGxvd2VyLXJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHdpbmRvdy52aWRlb0VsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICBcbiAgICBpZiAodmlkZW9FbGVtZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBVc2UgZXhpc3RpbmcgdmlkZW8gZWxlbWVudCBpZiBhdmFpbGFibGVcbiAgICAgICAgLy8gRmlyc3QgY2hlY2sgaWYgdmlkZW9UcmFjayBoYXMgc2V0dGluZ3MgaW5mb1xuICAgICAgICBsZXQgdHJhY2tTZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgaWYgKHZpZGVvVHJhY2spIHtcbiAgICAgICAgICAgIHRyYWNrU2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZpZGVvIHRyYWNrIHNldHRpbmdzOlwiLCB0cmFja1NldHRpbmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBkaW1lbnNpb25zIGZyb20gdHJhY2sgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZnJvbSBlbGVtZW50XG4gICAgICAgIGlmICh0cmFja1NldHRpbmdzICYmIHRyYWNrU2V0dGluZ3Mud2lkdGggJiYgdHJhY2tTZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRyYWNrU2V0dGluZ3Mud2lkdGg7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdHJhY2tTZXR0aW5ncy5oZWlnaHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHRyYWNrIHNldHRpbmdzIGRpbWVuc2lvbnM6ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0LmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgY29uc3Qgc2V0dGluZ3MgICA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCAgPSBzZXR0aW5ncy53aWR0aCAgfHwgMDtcbiAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBzZXR0aW5ncy5oZWlnaHQgfHwgMDtcbisgICAgICBjb25zb2xlLmxvZyhgVXNpbmcgdHJhY2suZ2V0U2V0dGluZ3MoKTogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNhbml0eSBjaGVjayAtIGlmIGJvdGggZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUsIGRvdWJsZS1jaGVja1xuICAgICAgICBpZiAod2ViY2FtV2lkdGggPT09IHdlYmNhbUhlaWdodCAmJiB3ZWJjYW1XaWR0aCA+IDEwMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlN1c3BpY2lvdXMgc3F1YXJlIGFzcGVjdCByYXRpbyBkZXRlY3RlZCwgZG91YmxlLWNoZWNraW5nIGRpbWVuc2lvbnNcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBtb3JlIHJlbGlhYmxlIGluZm9cbiAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHZpZGVvRWxlbWVudC5zcmNPYmplY3QuZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdmlkZW9UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZpZGVvIGNvbnN0cmFpbnRzOlwiLCBjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBJZiBjb25zdHJhaW50cyBoYXZlIHdpZHRoL2hlaWdodCwgdXNlIHRob3NlXG4gICAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy53aWR0aCAmJiBjb25zdHJhaW50cy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLndpZHRoLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgd2ViY2FtV2lkdGggPSBjb25zdHJhaW50cy53aWR0aC5leGFjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJhaW50cy53aWR0aC5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gY29uc3RyYWludHMud2lkdGguaWRlYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3RyYWludHMuaGVpZ2h0LmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gY29uc3RyYWludHMuaGVpZ2h0LmV4YWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLmhlaWdodC5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHdlYmNhbUhlaWdodCA9IGNvbnN0cmFpbnRzLmhlaWdodC5pZGVhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgZGltZW5zaW9ucyBmcm9tIGNvbnN0cmFpbnRzOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmluYWwgcmVhbGl0eSBjaGVjayAtIG1ha2Ugc3VyZSBkaW1lbnNpb25zIGFyZSByZWFzb25hYmxlXG4gICAgICAgIGlmICh3ZWJjYW1XaWR0aCA8PSAwIHx8IHdlYmNhbUhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCB3ZWJjYW0gZGltZW5zaW9ucywgdXNpbmcgZGVmYXVsdHNcIik7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSA2NDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3ZWJjYW1XaWR0aDtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCAwLCAwLCB3ZWJjYW1XaWR0aCwgd2ViY2FtSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgICAgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gYXdhaXQgcmVzaXplSW1hZ2Uod2ViY2FtSW1hZ2UsIDY0MCwgNDgwLCAwLjg1KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBXZWJjYW0gY2FwdHVyZSBjb21wbGV0ZSBhdCByZXNvbHV0aW9uOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIGZyb20gZXhpc3RpbmcgdmlkZW8gZWxlbWVudDpcIiwgZXJyKTtcbiAgICAgICAgd2ViY2FtV2lkdGggPSB2aWRlb0VsZW1lbnQudmlkZW9XaWR0aCB8fCA2NDA7XG4gICAgICAgIHdlYmNhbUhlaWdodCA9IHZpZGVvRWxlbWVudC52aWRlb0hlaWdodCB8fCA0ODA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBoaWdoZXN0IHJlc29sdXRpb24gY29uc3RyYWludHMgZm9yIHRoaXMgZGV2aWNlXG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGNhbWVyYSBjb25zdHJhaW50czpcIiwgY29uc3RyYWludHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBzdHJlYW0gd2l0aCBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgZGltZW5zaW9ucyBmcm9tIHRoZSB0cmFjayBmaXJzdFxuICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWN0dWFsIGNhbWVyYSBzZXR0aW5nczpcIiwgdHJhY2tTZXR0aW5ncyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IHZpZGVvIGVsZW1lbnQgdG8gZ2V0IHRoZSBzdHJlYW1cbiAgICAgICAgY29uc3QgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICBcbiAgICAgICAgLy8gTmVlZCB0byB3YWl0IGZvciB2aWRlbyB0byBiZSBpbml0aWFsaXplZFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICB0ZW1wVmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRlbXBWaWRlby5wbGF5KCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBGYWxsYmFjayBpZiBvbmxvYWRlZG1ldGFkYXRhIGRvZXNuJ3QgZmlyZVxuICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBhIGJpdCBsb25nZXIgZm9yIHRoZSB2aWRlbyB0byBhY3R1YWxseSBzdGFydCBwbGF5aW5nXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSB3ZWJjYW0gcmVzb2x1dGlvbiAtIHByaW9yaXRpemUgdHJhY2sgc2V0dGluZ3Mgb3ZlciB2aWRlbyBlbGVtZW50XG4gICAgICAgIGlmICh0cmFja1NldHRpbmdzICYmIHRyYWNrU2V0dGluZ3Mud2lkdGggJiYgdHJhY2tTZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRyYWNrU2V0dGluZ3Mud2lkdGg7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdHJhY2tTZXR0aW5ncy5oZWlnaHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHRyYWNrIHNldHRpbmdzIGZvciByZXNvbHV0aW9uOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRlbXBWaWRlby52aWRlb1dpZHRoIHx8IDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHZpZGVvIGVsZW1lbnQgZm9yIHJlc29sdXRpb246ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZWFsaXR5IGNoZWNrIG9uIGRpbWVuc2lvbnNcbiAgICAgICAgaWYgKHdlYmNhbVdpZHRoIDw9IDAgfHwgd2ViY2FtSGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHdlYmNhbSBkaW1lbnNpb25zLCB0cnlpbmcgdG8gZ2V0IGZyb20gY29uc3RyYWludHNcIik7XG4gICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvICYmIHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlby53aWR0aCAmJiBjb25zdHJhaW50cy52aWRlby53aWR0aC5pZGVhbCkge1xuICAgICAgICAgICAgICB3ZWJjYW1XaWR0aCA9IGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoLmlkZWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodCAmJiBjb25zdHJhaW50cy52aWRlby5oZWlnaHQuaWRlYWwpIHtcbiAgICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gY29uc3RyYWludHMudmlkZW8uaGVpZ2h0LmlkZWFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAod2ViY2FtV2lkdGggPD0gMCB8fCB3ZWJjYW1IZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3RpbGwgaW52YWxpZCBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0c1wiKTtcbiAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gNjQwO1xuICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmluYWwgY2hlY2sgZm9yIHNxdWFyZSBhc3BlY3QgcmF0aW8gd2hpY2ggaXMgdXN1YWxseSBpbmNvcnJlY3RcbiAgICAgICAgaWYgKHdlYmNhbVdpZHRoID09PSB3ZWJjYW1IZWlnaHQgJiYgd2ViY2FtV2lkdGggPiAxMDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcXVhcmUgYXNwZWN0IHJhdGlvIGRldGVjdGVkLCBtYXkgYmUgaW5jb3JyZWN0XCIpO1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgbW9yZSByZWxpYWJsZSBkaW1lbnNpb25zXG4gICAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdmlkZW9UcmFjay5nZXRDYXBhYmlsaXRpZXM/LigpO1xuICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMgJiYgY2FwYWJpbGl0aWVzLndpZHRoICYmIGNhcGFiaWxpdGllcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMud2lkdGgubWF4ICYmIGNhcGFiaWxpdGllcy5oZWlnaHQubWF4KSB7XG4gICAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgbWF4aW11bSBjYXBhYmlsaXRpZXMgaGF2ZSB0aGUgY29ycmVjdCBhc3BlY3QgcmF0aW9cbiAgICAgICAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYXBhYmlsaXRpZXMud2lkdGgubWF4IC8gY2FwYWJpbGl0aWVzLmhlaWdodC5tYXg7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYXNwZWN0UmF0aW8gLSAxLjMzKSA8IDAuMSkgeyAvLyBDbG9zZSB0byA0OjNcbiAgICAgICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBNYXRoLnJvdW5kKHdlYmNhbVdpZHRoIC8gMS4zMyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvcnJlY3RlZCB0byA0OjMgYXNwZWN0IHJhdGlvOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhhc3BlY3RSYXRpbyAtIDEuNzgpIDwgMC4xKSB7IC8vIENsb3NlIHRvIDE2OjlcbiAgICAgICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBNYXRoLnJvdW5kKHdlYmNhbVdpZHRoIC8gMS43OCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvcnJlY3RlZCB0byAxNjo5IGFzcGVjdCByYXRpbzogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdlYmNhbVdpZHRoO1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHdlYmNhbUhlaWdodDtcbiAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHdlYmNhbVdpZHRoLCB3ZWJjYW1IZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGhpZ2gtcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBzYXZpbmdcbiAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOTUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGxvd2VyLXJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgICAgICB3ZWJjYW1JbWFnZVByZXZpZXcgPSBhd2FpdCByZXNpemVJbWFnZSh3ZWJjYW1JbWFnZSwgNjQwLCA0ODAsIDAuODUpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEhpZ2gtcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZSBjb21wbGV0ZTogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkhpZ2gtcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZSBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgb25lIG1vcmUgdGltZSB3aXRoIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgICBhd2FpdCB0ZW1wVmlkZW8ucGxheSgpO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMzAwKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSB0cmFjayBzZXR0aW5ncyBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodHJhY2tTZXR0aW5ncyAmJiB0cmFja1NldHRpbmdzLndpZHRoICYmIHRyYWNrU2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRyYWNrU2V0dGluZ3Mud2lkdGg7XG4gICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSB0cmFja1NldHRpbmdzLmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViY2FtV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCAwO1xuICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpbmFsIGNoZWNrIGZvciBpbnZhbGlkIGRpbWVuc2lvbnNcbiAgICAgICAgICBpZiAod2ViY2FtV2lkdGggPD0gMCB8fCB3ZWJjYW1IZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgd2ViY2FtV2lkdGggPSA2NDA7XG4gICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSA0ODA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2ViY2FtV2lkdGg7XG4gICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHdlYmNhbVdpZHRoLCB3ZWJjYW1IZWlnaHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGxvd2VyLXJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgICAgICAgIHdlYmNhbUltYWdlUHJldmlldyA9IGF3YWl0IHJlc2l6ZUltYWdlKHdlYmNhbUltYWdlLCA2NDAsIDQ4MCwgMC44KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQmFzaWMgd2ViY2FtIHJlc29sdXRpb24gY2FwdHVyZWQ6ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpO1xuICAgICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQWxsIHdlYmNhbSBjYXB0dXJlIG1ldGhvZHMgZmFpbGVkOlwiLCBmYWxsYmFja0Vycik7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSA2NDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMS4zIFBhcmFtZXRlciBkYXRhIC0gTm93IGluY2x1ZGluZyB3ZWJjYW0gcmVzb2x1dGlvblxuICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICBcIm5hbWUsdmFsdWVcIixcbiAgICAgIGBkb3RfeCwke3BvaW50Lnh9YCxcbiAgICAgIGBkb3RfeSwke3BvaW50Lnl9YCxcbiAgICAgIGBjYW52YXNfd2lkdGgsJHtjYW52YXM/LndpZHRoIHx8IDB9YCxcbiAgICAgIGBjYW52YXNfaGVpZ2h0LCR7Y2FudmFzPy5oZWlnaHQgfHwgMH1gLFxuICAgICAgYHdpbmRvd193aWR0aCwke3dpbmRvdy5pbm5lcldpZHRofWAsXG4gICAgICBgd2luZG93X2hlaWdodCwke3dpbmRvdy5pbm5lckhlaWdodH1gLFxuICAgICAgYHdlYmNhbV9yZXNvbHV0aW9uX3dpZHRoLCR7d2ViY2FtV2lkdGh9YCxcbiAgICAgIGB3ZWJjYW1fcmVzb2x1dGlvbl9oZWlnaHQsJHt3ZWJjYW1IZWlnaHR9YCxcbiAgICAgIGB0aW1lc3RhbXAsJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgIGBncm91cF9pZCwke2NhcHR1cmVHcm91cElkfWBcbiAgICBdLmpvaW4oJ1xcbicpO1xuICAgIFxuICAgIC8vIDIuIFNhdmUgYWxsIGZpbGVzIHdpdGggdGhlIHNhbWUgZ3JvdXAgSUQgc28gdGhleSBnZXQgdGhlIHNhbWUgbnVtYmVyXG4gICAgXG4gICAgLy8gMi4xIFNhdmUgcGFyYW1ldGVyIGZpbGVcbiAgICBjb25zdCBwYXJhbVJlc3VsdCA9IGF3YWl0IHNhdmVDU1ZUb1NlcnZlcihjc3ZEYXRhLCBwYXJhbWV0ZXJGaWxlbmFtZSwgZm9sZGVyLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgXG4gICAgaWYgKHBhcmFtUmVzdWx0ICYmIHBhcmFtUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGNhcHR1cmVOdW1iZXIgPSBwYXJhbVJlc3VsdC5udW1iZXI7XG4gICAgICBjb25zb2xlLmxvZyhgU2VydmVyIGFzc2lnbmVkIGNhcHR1cmUgbnVtYmVyOiAke2NhcHR1cmVOdW1iZXJ9IGZvciBncm91cDogJHtjYXB0dXJlR3JvdXBJZH1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gMi4yIFNhdmUgc2NyZWVuIGltYWdlIGlmIGF2YWlsYWJsZVxuICAgIGxldCBzY3JlZW5SZXN1bHQgPSBudWxsO1xuICAgIGlmIChzY3JlZW5JbWFnZSkge1xuICAgICAgc2NyZWVuUmVzdWx0ID0gYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoc2NyZWVuSW1hZ2UsIHNjcmVlbkZpbGVuYW1lLCAnc2NyZWVuJywgZm9sZGVyLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDIuMyBTYXZlIHdlYmNhbSBpbWFnZSBpZiBhdmFpbGFibGVcbiAgICBsZXQgd2ViY2FtUmVzdWx0ID0gbnVsbDtcbiAgICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICAgIHdlYmNhbVJlc3VsdCA9IGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKHdlYmNhbUltYWdlLCB3ZWJjYW1GaWxlbmFtZSwgJ3dlYmNhbScsIGZvbGRlciwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyAzLiBTaG93IHByZXZpZXcgaWYgbmVlZGVkIC0gdXNlIHRoZSBsb3dlciByZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICBpZiAoc2hvd0NhcHR1cmVQcmV2aWV3ICYmIHR5cGVvZiBzaG93Q2FwdHVyZVByZXZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3dDYXB0dXJlUHJldmlldyhzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2VQcmV2aWV3IHx8IHdlYmNhbUltYWdlLCBwb2ludCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDQuIEluY3JlbWVudCBjb3VudGVyIGZvciBuZXh0IGNhcHR1cmVcbiAgICBpZiAoc2V0Q2FwdHVyZUNvdW50ICYmIHR5cGVvZiBzZXRDYXB0dXJlQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldENhcHR1cmVDb3VudChwcmV2Q291bnQgPT4gcHJldkNvdW50ICsgMSk7XG4gICAgfVxuICAgIFxuICAgIC8vIDUuIFJldHVybiByZXN1bHRzIC0gbm93IGluY2x1ZGluZyB3ZWJjYW0gcmVzb2x1dGlvblxuICAgIHJldHVybiB7XG4gICAgICBzY3JlZW5JbWFnZSxcbiAgICAgIHdlYmNhbUltYWdlLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHBvaW50LFxuICAgICAgY2FwdHVyZU51bWJlcixcbiAgICAgIGdyb3VwSWQ6IGNhcHR1cmVHcm91cElkLFxuICAgICAgd2ViY2FtV2lkdGgsXG4gICAgICB3ZWJjYW1IZWlnaHRcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiY2FwdHVyZUltYWdlc0F0UG9pbnQgZmFpbGVkOlwiLCBlcnIpO1xuICAgIHJldHVybiB7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6IGVyci5tZXNzYWdlLFxuICAgICAgc2NyZWVuSW1hZ2U6IG51bGwsXG4gICAgICB3ZWJjYW1JbWFnZTogbnVsbCxcbiAgICAgIHdlYmNhbVdpZHRoOiAwLFxuICAgICAgd2ViY2FtSGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxufTsiXSwibmFtZXMiOlsicmVzaXplSW1hZ2UiLCJpbWFnZURhdGFVcmwiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInF1YWxpdHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwib25sb2FkIiwid2lkdGgiLCJoZWlnaHQiLCJNYXRoIiwicm91bmQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwicmVzaXplZERhdGFVcmwiLCJ0b0RhdGFVUkwiLCJvbmVycm9yIiwiZXJyIiwic3JjIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJpbWFnZURhdGEiLCJmaWxlbmFtZSIsInR5cGUiLCJmb2xkZXIiLCJjYXB0dXJlR3JvdXAiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwiZXJyb3IiLCJzdGF0dXMiLCJ3YXJuIiwic2l6ZXMiLCJyZXNpemVkSW1hZ2UiLCJyZXRyeVJlc3BvbnNlIiwibG9nIiwianNvbiIsInJldHJ5RXJyb3IiLCJzdWNjZXNzIiwicmVzdWx0IiwibWVzc2FnZSIsInNhdmVDU1ZUb1NlcnZlciIsImNzdkRhdGEiLCJjc3ZCbG9iIiwiQmxvYiIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVhZEFzRGF0YVVSTCIsImdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMiLCJ2aWRlb1RyYWNrIiwidGVtcFN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiZ2V0VmlkZW9UcmFja3MiLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJzdG9wIiwiaWRlYWwiLCJtYXgiLCJyZXNvbHV0aW9ucyIsInJlc29sdXRpb24iLCJjb25zdHJhaW50cyIsImZhY2luZ01vZGUiLCJzdHJlYW0iLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInRyYWNrIiwiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJwb2ludCIsImNhcHR1cmVDb3VudCIsImNhbnZhc1JlZiIsInNldENhcHR1cmVDb3VudCIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVHcm91cElkIiwiRGF0ZSIsIm5vdyIsInNjcmVlbkZpbGVuYW1lIiwid2ViY2FtRmlsZW5hbWUiLCJwYXJhbWV0ZXJGaWxlbmFtZSIsImN1cnJlbnQiLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiY2FwdHVyZU51bWJlciIsIndlYmNhbVdpZHRoIiwid2ViY2FtSGVpZ2h0Iiwid2ViY2FtSW1hZ2VQcmV2aWV3IiwidmlkZW9FbGVtZW50Iiwid2luZG93IiwicXVlcnlTZWxlY3RvciIsInRyYWNrU2V0dGluZ3MiLCJzcmNPYmplY3QiLCJnZXRDb25zdHJhaW50cyIsImV4YWN0IiwidGVtcENhbnZhcyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsInRlbXBWaWRlbyIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJhdXRvcGxheSIsImFwcGVuZENoaWxkIiwib25sb2FkZWRtZXRhZGF0YSIsInBsYXkiLCJzZXRUaW1lb3V0IiwicmVzIiwiYXNwZWN0UmF0aW8iLCJhYnMiLCJ0IiwicmVtb3ZlIiwiZmFsbGJhY2tFcnIiLCJ4IiwieSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInRvSVNPU3RyaW5nIiwiam9pbiIsInBhcmFtUmVzdWx0IiwibnVtYmVyIiwic2NyZWVuUmVzdWx0Iiwid2ViY2FtUmVzdWx0IiwicHJldkNvdW50IiwiZ3JvdXBJZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\n"));

/***/ })

});