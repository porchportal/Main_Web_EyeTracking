"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    // Debug logging for settings changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            console.log('AdminSettings - Current Settings:', settings);\n            console.log('AdminSettings - Current User ID:', currentUserId);\n            console.log('AdminSettings - Is TopBar Updated:', isTopBarUpdated);\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId,\n        isTopBarUpdated\n    ]);\n    // Helper: Fetch settings for a user from backend\n    const fetchSettingsForUser = async (userId)=>{\n        console.log('[AdminSettings] fetchSettingsForUser - userId:', userId);\n        if (!userId) return;\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                }\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to fetch settings');\n            }\n            const result = await response.json();\n            console.log('[AdminSettings] fetchSettingsForUser - Received settings:', result.data);\n            // result.data contains the settings object\n            const newSettings = result.data || {};\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: newSettings\n                }));\n            setCurrentSettings(newSettings);\n            setError(null);\n            // Update TopBar if ref provided\n            if (ref && ref.current && ref.current.setCaptureSettings) {\n                console.log('[AdminSettings] Updating TopBar with settings:', newSettings);\n                ref.current.setCaptureSettings(newSettings);\n                setIsTopBarUpdated(true);\n            }\n            return newSettings;\n        } catch (error) {\n            console.error('[AdminSettings] Error fetching settings:', error);\n            setError(error.message);\n            return null;\n        }\n    };\n    // Polling for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (!currentUserId) return;\n            console.log('[Polling useEffect] currentUserId:', currentUserId); // Debug log\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": ()=>fetchSettingsForUser(currentUserId)\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            fetchSettings();\n            pollingInterval.current = setInterval(fetchSettings, 3000);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) clearInterval(pollingInterval.current);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref\n    ]);\n    // Listen for userId changes (from index.js navigation)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        console.log('[handleUserIdChange] userId:', event.detail.userId); // Debug log\n                        setCurrentUserId(event.detail.userId);\n                        fetchSettingsForUser(event.detail.userId);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Effect to handle index.js update after TopBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount (optional, fallback)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n            // Ignore\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {}\n            } else {\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('[settings useEffect] currentUserId:', currentUserId); // Debug log\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                // Optionally update UI elements if needed\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page (captureSettingsUpdate event)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        console.log('[handleSettingsUpdate] userId:', userId, 'currentUserId:', currentUserId); // Debug log\n                        if (userId === currentUserId) {\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            updateSettings(newSettings, userId);\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    // Update settings for a user (times, delay, image, etc.)\n    const updateSettings = async (newSettings, userId)=>{\n        console.log('[updateSettings] userId:', userId); // Debug log\n        if (!userId) return;\n        const updatedSettings = {\n            ...settings[userId],\n            ...newSettings\n        };\n        setSettings((prev)=>({\n                ...prev,\n                [userId]: updatedSettings\n            }));\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify(updatedSettings)\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to save settings');\n            }\n            const result = await response.json();\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: result.data || updatedSettings\n                }));\n            setCurrentSettings(result.data || updatedSettings);\n            setError(null);\n        } catch (error) {\n            setError(error.message);\n        }\n    };\n    // Upload and update image for a user\n    const updateImage = async (userId, base64Image)=>{\n        console.log('[updateImage] userId:', userId); // Debug log\n        if (!userId || !base64Image) return;\n        try {\n            const response = await fetch(\"/api/data-center/image?user_id=\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify({\n                    image: base64Image\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to upload image');\n            }\n            // Optionally, fetch settings again to get updated image info\n            await fetchSettingsForUser(userId);\n            setError(null);\n            return true;\n        } catch (error) {\n            setError(error.message);\n            return false;\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        updateImage,\n        error\n    };\n};\n_s(useAdminSettings, \"A4QjARs8IevHpGz1ipMKyItL4so=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFFN0MsTUFBTUcsbUJBQW1CLENBQUNDOztJQUMvQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR0osK0NBQVFBLENBQUMsQ0FBQztJQUMxQyxNQUFNLENBQUNLLGVBQWVDLGlCQUFpQixHQUFHTiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNPLGlCQUFpQkMsbUJBQW1CLEdBQUdSLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ1MsT0FBT0MsU0FBUyxHQUFHViwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNVyxjQUFjWiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNYSxrQkFBa0JiLDZDQUFNQSxDQUFDO0lBQy9CLE1BQU0sQ0FBQ2MsaUJBQWlCQyxtQkFBbUIsR0FBR2QsK0NBQVFBLENBQUMsQ0FBQztJQUV4RCxxQ0FBcUM7SUFDckNGLGdEQUFTQTtzQ0FBQztZQUNSaUIsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQ2I7WUFDakRZLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBb0NYO1lBQ2hEVSxRQUFRQyxHQUFHLENBQUMsc0NBQXNDVDtRQUNwRDtxQ0FBRztRQUFDSjtRQUFVRTtRQUFlRTtLQUFnQjtJQUU3QyxpREFBaUQ7SUFDakQsTUFBTVUsdUJBQXVCLE9BQU9DO1FBQ2xDSCxRQUFRQyxHQUFHLENBQUMsa0RBQWtERTtRQUM5RCxJQUFJLENBQUNBLFFBQVE7UUFDYixJQUFJO1lBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLDZCQUFvQyxPQUFQRixTQUFVO2dCQUNsRUcsU0FBUztvQkFDUCxVQUFVO29CQUNWLGdCQUFnQjtvQkFDaEIsYUFBYUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtnQkFDbEQ7WUFDRjtZQUNBLElBQUksQ0FBQ0wsU0FB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SUFBSWdDO1lBQ2xDdEQsU0FBUztRQUNYLEVBQUUsT0FBT0QsT0FBTztZQUNkQyxTQUFTRCxNQUFNNEIsT0FBTztRQUN4QjtJQUNGO0lBRUEscUNBQXFDO0lBQ3JDLE1BQU04QixjQUFjLE9BQU9qRCxRQUFRa0Q7UUFDakNyRCxRQUFRQyxHQUFHLENBQUMseUJBQXlCRSxTQUFTLFlBQVk7UUFDMUQsSUFBSSxDQUFDQSxVQUFVLENBQUNrRCxhQUFhO1FBQzdCLElBQUk7WUFDRixNQUFNakQsV0FBVyxNQUFNQyxNQUFNLGtDQUF5QyxPQUFQRixTQUFVO2dCQUN2RStDLFFBQVE7Z0JBQ1I1QyxTQUFTO29CQUNQLGdCQUFnQjtvQkFDaEIsYUFBYUMsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDQyxtQkFBbUIsSUFBSTtnQkFDbEQ7Z0JBQ0EwQyxNQUFNYixLQUFLRyxTQUFTLENBQUM7b0JBQUVhLE9BQU9EO2dCQUFZO1lBQzVDO1lBQ0EsSUFBSSxDQUFDakQsU0FBU00sRUFBRSxFQUFFO2dCQUNoQixNQUFNQyxZQUFZLE1BQU1QLFNBQVNRLElBQUksR0FBR0MsS0FBSyxDQUFDLElBQU8sRUFBQztnQkFDdEQsTUFBTSxJQUFJQyxNQUFNSCxVQUFVSSxNQUFNLElBQUk7WUFDdEM7WUFDQSw2REFBNkQ7WUFDN0QsTUFBTWIscUJBQXFCQztZQUMzQlIsU0FBUztZQUNULE9BQU87UUFDVCxFQUFFLE9BQU9ELE9BQU87WUFDZEMsU0FBU0QsTUFBTTRCLE9BQU87WUFDdEIsT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPO1FBQUVsQztRQUFVNEQ7UUFBZ0JJO1FBQWExRDtJQUFNO0FBQ3hELEVBQUU7R0F2TldSO0FBeU5iLCtCQUErQjtBQUNoQixTQUFTcUU7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtLQUZ3QkEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FkbWluU2V0dGluZ3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgY29uc3QgdXNlQWRtaW5TZXR0aW5ncyA9IChyZWYpID0+IHtcbiAgY29uc3QgW3NldHRpbmdzLCBzZXRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbaXNUb3BCYXJVcGRhdGVkLCBzZXRJc1RvcEJhclVwZGF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBpbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHBvbGxpbmdJbnRlcnZhbCA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW2N1cnJlbnRTZXR0aW5ncywgc2V0Q3VycmVudFNldHRpbmdzXSA9IHVzZVN0YXRlKHt9KTtcblxuICAvLyBEZWJ1ZyBsb2dnaW5nIGZvciBzZXR0aW5ncyBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBDdXJyZW50IFNldHRpbmdzOicsIHNldHRpbmdzKTtcbiAgICBjb25zb2xlLmxvZygnQWRtaW5TZXR0aW5ncyAtIEN1cnJlbnQgVXNlciBJRDonLCBjdXJyZW50VXNlcklkKTtcbiAgICBjb25zb2xlLmxvZygnQWRtaW5TZXR0aW5ncyAtIElzIFRvcEJhciBVcGRhdGVkOicsIGlzVG9wQmFyVXBkYXRlZCk7XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZCwgaXNUb3BCYXJVcGRhdGVkXSk7XG5cbiAgLy8gSGVscGVyOiBGZXRjaCBzZXR0aW5ncyBmb3IgYSB1c2VyIGZyb20gYmFja2VuZFxuICBjb25zdCBmZXRjaFNldHRpbmdzRm9yVXNlciA9IGFzeW5jICh1c2VySWQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIGZldGNoU2V0dGluZ3NGb3JVc2VyIC0gdXNlcklkOicsIHVzZXJJZCk7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBmZXRjaCBzZXR0aW5ncycpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBmZXRjaFNldHRpbmdzRm9yVXNlciAtIFJlY2VpdmVkIHNldHRpbmdzOicsIHJlc3VsdC5kYXRhKTtcbiAgICAgIFxuICAgICAgLy8gcmVzdWx0LmRhdGEgY29udGFpbnMgdGhlIHNldHRpbmdzIG9iamVjdFxuICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSByZXN1bHQuZGF0YSB8fCB7fTtcbiAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW3VzZXJJZF06IG5ld1NldHRpbmdzXG4gICAgICB9KSk7XG4gICAgICBzZXRDdXJyZW50U2V0dGluZ3MobmV3U2V0dGluZ3MpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBUb3BCYXIgaWYgcmVmIHByb3ZpZGVkXG4gICAgICBpZiAocmVmICYmIHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncykge1xuICAgICAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIFVwZGF0aW5nIFRvcEJhciB3aXRoIHNldHRpbmdzOicsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgcmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NldHRpbmdzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbQWRtaW5TZXR0aW5nc10gRXJyb3IgZmV0Y2hpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUG9sbGluZyBmb3Igc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXJJZCkgcmV0dXJuO1xuICAgIGNvbnNvbGUubG9nKCdbUG9sbGluZyB1c2VFZmZlY3RdIGN1cnJlbnRVc2VySWQ6JywgY3VycmVudFVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgIGNvbnN0IGZldGNoU2V0dGluZ3MgPSAoKSA9PiBmZXRjaFNldHRpbmdzRm9yVXNlcihjdXJyZW50VXNlcklkKTtcbiAgICBmZXRjaFNldHRpbmdzKCk7XG4gICAgcG9sbGluZ0ludGVydmFsLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChmZXRjaFNldHRpbmdzLCAzMDAwKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KSBjbGVhckludGVydmFsKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZCwgcmVmXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VySWQgY2hhbmdlcyAoZnJvbSBpbmRleC5qcyBuYXZpZ2F0aW9uKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudXNlcklkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbaGFuZGxlVXNlcklkQ2hhbmdlXSB1c2VySWQ6JywgZXZlbnQuZGV0YWlsLnVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICBmZXRjaFNldHRpbmdzRm9yVXNlcihldmVudC5kZXRhaWwudXNlcklkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgfSwgW3JlZl0pO1xuXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgaW5kZXguanMgdXBkYXRlIGFmdGVyIFRvcEJhciBpcyB1cGRhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzVG9wQmFyVXBkYXRlZCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NldHRpbmdzVXBkYXRlZCcsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdHlwZTogJ3NldHRpbmdzJyxcbiAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtpc1RvcEJhclVwZGF0ZWQsIGN1cnJlbnRVc2VySWQsIHNldHRpbmdzXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudCAob3B0aW9uYWwsIGZhbGxiYWNrKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FkbWluU2V0dGluZ3MnKTtcbiAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFNldHRpbmdzID0gSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKTtcbiAgICAgICAgc2V0U2V0dGluZ3MocGFyc2VkU2V0dGluZ3MpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZ25vcmVcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZSB3aGVuIHRoZXkgY2hhbmdlIChvcHRpb25hbClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FkbWluU2V0dGluZ3MnLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gVXBkYXRlIHNldHRpbmdzIHdoZW4gdGhleSBjaGFuZ2UgaW4gdGhlIGNvbnRleHRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2V0dGluZ3MgJiYgY3VycmVudFVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tzZXR0aW5ncyB1c2VFZmZlY3RdIGN1cnJlbnRVc2VySWQ6JywgY3VycmVudFVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbY3VycmVudFVzZXJJZF07XG4gICAgICBpZiAodXNlclNldHRpbmdzKSB7XG4gICAgICAgIHNldEN1cnJlbnRTZXR0aW5ncyh1c2VyU2V0dGluZ3MpO1xuICAgICAgICAvLyBPcHRpb25hbGx5IHVwZGF0ZSBVSSBlbGVtZW50cyBpZiBuZWVkZWRcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlcyBmcm9tIGFkbWluIHBhZ2UgKGNhcHR1cmVTZXR0aW5nc1VwZGF0ZSBldmVudClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzLCBkZWxheSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVNldHRpbmdzVXBkYXRlXSB1c2VySWQ6JywgdXNlcklkLCAnY3VycmVudFVzZXJJZDonLCBjdXJyZW50VXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgICAgIGlmICh1c2VySWQgPT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnRTZXR0aW5ncyxcbiAgICAgICAgICAgIHRpbWVzOiB0aW1lcyAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKHRpbWVzKSA6IGN1cnJlbnRTZXR0aW5ncy50aW1lcyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKGRlbGF5KSA6IGN1cnJlbnRTZXR0aW5ncy5kZWxheVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBuZXdTZXR0aW5ncyB9KSk7XG4gICAgICAgICAgdXBkYXRlU2V0dGluZ3MobmV3U2V0dGluZ3MsIHVzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gIH0sIFtjdXJyZW50VXNlcklkLCBjdXJyZW50U2V0dGluZ3NdKTtcblxuICAvLyBVcGRhdGUgc2V0dGluZ3MgZm9yIGEgdXNlciAodGltZXMsIGRlbGF5LCBpbWFnZSwgZXRjLilcbiAgY29uc3QgdXBkYXRlU2V0dGluZ3MgPSBhc3luYyAobmV3U2V0dGluZ3MsIHVzZXJJZCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlU2V0dGluZ3NdIHVzZXJJZDonLCB1c2VySWQpOyAvLyBEZWJ1ZyBsb2dcbiAgICBpZiAoIXVzZXJJZCkgcmV0dXJuO1xuICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHtcbiAgICAgIC4uLnNldHRpbmdzW3VzZXJJZF0sXG4gICAgICAuLi5uZXdTZXR0aW5nc1xuICAgIH07XG4gICAgc2V0U2V0dGluZ3MocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogdXBkYXRlZFNldHRpbmdzIH0pKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU2V0dGluZ3MpXG4gICAgICB9KTtcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIHNhdmUgc2V0dGluZ3MnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IHJlc3VsdC5kYXRhIHx8IHVwZGF0ZWRTZXR0aW5ncyB9KSk7XG4gICAgICBzZXRDdXJyZW50U2V0dGluZ3MocmVzdWx0LmRhdGEgfHwgdXBkYXRlZFNldHRpbmdzKTtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXBsb2FkIGFuZCB1cGRhdGUgaW1hZ2UgZm9yIGEgdXNlclxuICBjb25zdCB1cGRhdGVJbWFnZSA9IGFzeW5jICh1c2VySWQsIGJhc2U2NEltYWdlKSA9PiB7XG4gICAgY29uc29sZS5sb2coJ1t1cGRhdGVJbWFnZV0gdXNlcklkOicsIHVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgIGlmICghdXNlcklkIHx8ICFiYXNlNjRJbWFnZSkgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL2ltYWdlP3VzZXJfaWQ9JHt1c2VySWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBpbWFnZTogYmFzZTY0SW1hZ2UgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gdXBsb2FkIGltYWdlJyk7XG4gICAgICB9XG4gICAgICAvLyBPcHRpb25hbGx5LCBmZXRjaCBzZXR0aW5ncyBhZ2FpbiB0byBnZXQgdXBkYXRlZCBpbWFnZSBpbmZvXG4gICAgICBhd2FpdCBmZXRjaFNldHRpbmdzRm9yVXNlcih1c2VySWQpO1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncywgdXBkYXRlSW1hZ2UsIGVycm9yIH07XG59O1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBZG1pblNldHRpbmdzKCkge1xuICByZXR1cm4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcbn0iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VBZG1pblNldHRpbmdzIiwicmVmIiwic2V0dGluZ3MiLCJzZXRTZXR0aW5ncyIsImN1cnJlbnRVc2VySWQiLCJzZXRDdXJyZW50VXNlcklkIiwiaXNUb3BCYXJVcGRhdGVkIiwic2V0SXNUb3BCYXJVcGRhdGVkIiwiZXJyb3IiLCJzZXRFcnJvciIsImluaXRpYWxpemVkIiwicG9sbGluZ0ludGVydmFsIiwiY3VycmVudFNldHRpbmdzIiwic2V0Q3VycmVudFNldHRpbmdzIiwiY29uc29sZSIsImxvZyIsImZldGNoU2V0dGluZ3NGb3JVc2VyIiwidXNlcklkIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0tFWSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsImNhdGNoIiwiRXJyb3IiLCJkZXRhaWwiLCJyZXN1bHQiLCJkYXRhIiwibmV3U2V0dGluZ3MiLCJwcmV2IiwiY3VycmVudCIsInNldENhcHR1cmVTZXR0aW5ncyIsIm1lc3NhZ2UiLCJmZXRjaFNldHRpbmdzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkN1c3RvbUV2ZW50IiwidHlwZSIsImRpc3BhdGNoRXZlbnQiLCJzYXZlZFNldHRpbmdzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZFNldHRpbmdzIiwiSlNPTiIsInBhcnNlIiwic2V0SXRlbSIsInN0cmluZ2lmeSIsInVzZXJTZXR0aW5ncyIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidGltZXMiLCJkZWxheSIsInVuZGVmaW5lZCIsIk51bWJlciIsInVwZGF0ZVNldHRpbmdzIiwidXBkYXRlZFNldHRpbmdzIiwibWV0aG9kIiwiYm9keSIsInVwZGF0ZUltYWdlIiwiYmFzZTY0SW1hZ2UiLCJpbWFnZSIsIkFkbWluU2V0dGluZ3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});