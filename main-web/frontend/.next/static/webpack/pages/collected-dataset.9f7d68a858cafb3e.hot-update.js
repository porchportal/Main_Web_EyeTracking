"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Helper/savefile.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureImagesAtPoint: () => (/* binding */ captureImagesAtPoint),\n/* harmony export */   saveCSVToServer: () => (/* binding */ saveCSVToServer),\n/* harmony export */   saveImageToServer: () => (/* binding */ saveImageToServer)\n/* harmony export */ });\n// Helper/savefile.js - Added highest resolution webcam capture\n/**\n * Resize an image to fit within a certain size limit\n * @param {string} imageDataUrl - Base64 encoded image data\n * @param {number} maxWidth - Maximum width of the resized image\n * @param {number} maxHeight - Maximum height of the resized image\n * @param {number} quality - JPEG quality (0-1)\n * @returns {Promise<string>} - Resized image data URL\n */ const resizeImage = async function(imageDataUrl) {\n    let maxWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 800, maxHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 600, quality = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85;\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = new Image();\n            img.onload = ()=>{\n                // Calculate new dimensions while maintaining aspect ratio\n                let width = img.width;\n                let height = img.height;\n                if (width > maxWidth) {\n                    height = Math.round(height * (maxWidth / width));\n                    width = maxWidth;\n                }\n                if (height > maxHeight) {\n                    width = Math.round(width * (maxHeight / height));\n                    height = maxHeight;\n                }\n                // Create canvas for resizing\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                // Draw and resize image on canvas\n                const ctx = canvas.getContext('2d');\n                ctx.drawImage(img, 0, 0, width, height);\n                // Convert to JPEG with specified quality\n                const resizedDataUrl = canvas.toDataURL('image/jpeg', quality);\n                resolve(resizedDataUrl);\n            };\n            img.onerror = (err)=>reject(err);\n            img.src = imageDataUrl;\n        } catch (err) {\n            reject(err);\n        }\n    });\n};\n/**\n * Save an image or data to the server with group ID to ensure consistent numbering\n * @param {string} imageData - Base64 encoded image data\n * @param {string} filename - Filename pattern to save as\n * @param {string} type - Type of file (screen, webcam, parameters)\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveImageToServer = async function(imageData, filename, type) {\n    let folder = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'eye_tracking_captures', captureGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    try {\n        const response = await fetch('/api/save-capture', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                imageData,\n                filename,\n                type,\n                folder,\n                captureGroup\n            })\n        });\n        if (!response.ok) {\n            console.error(\"Server returned \".concat(response.status, \" for \").concat(type));\n            // If the error is 413 (payload too large) and it's an image, try resizing\n            if (response.status === 413 && type !== 'parameters') {\n                console.warn(\"Image too large for server (413 error), will resize and retry\");\n                // Start with higher quality and progressively reduce quality/size until it fits\n                const sizes = [\n                    {\n                        width: 1920,\n                        height: 1080,\n                        quality: 0.9\n                    },\n                    {\n                        width: 1280,\n                        height: 720,\n                        quality: 0.85\n                    },\n                    {\n                        width: 800,\n                        height: 600,\n                        quality: 0.8\n                    },\n                    {\n                        width: 640,\n                        height: 480,\n                        quality: 0.75\n                    }\n                ];\n                for (const { width, height, quality } of sizes){\n                    const resizedImage = await resizeImage(imageData, width, height, quality);\n                    try {\n                        const retryResponse = await fetch('/api/save-capture', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify({\n                                imageData: resizedImage,\n                                filename,\n                                type,\n                                folder,\n                                captureGroup\n                            })\n                        });\n                        if (retryResponse.ok) {\n                            console.log(\"Successfully saved resized \".concat(type, \" at \").concat(width, \"x\").concat(height, \", quality \").concat(quality));\n                            return await retryResponse.json();\n                        }\n                    } catch (retryError) {\n                        console.error(\"Error during retry for \".concat(type, \":\"), retryError);\n                    }\n                }\n                return {\n                    success: false,\n                    error: \"Failed to save image even after resizing\"\n                };\n            }\n            return {\n                success: false,\n                error: \"Server returned \".concat(response.status)\n            };\n        }\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error(\"Error saving \".concat(type, \":\"), error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Save CSV data to the server\n * @param {string} csvData - CSV data\n * @param {string} filename - Filename pattern to save as\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveCSVToServer = async function(csvData, filename) {\n    let folder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'eye_tracking_captures', captureGroup = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        const csvBlob = new Blob([\n            csvData\n        ], {\n            type: 'text/csv'\n        });\n        const reader = new FileReader();\n        const csvDataUrl = await new Promise((resolve)=>{\n            reader.onloadend = ()=>resolve(reader.result);\n            reader.readAsDataURL(csvBlob);\n        });\n        const result = await saveImageToServer(csvDataUrl, filename, 'parameters', folder, captureGroup);\n        return result;\n    } catch (error) {\n        console.error('Error saving CSV:', error);\n        return null;\n    }\n};\n/**\n * Get the highest resolution camera constraints supported by the device\n * @returns {Promise<MediaStreamConstraints>} - Camera constraints with highest resolution\n */ const getHighestResolutionConstraints = async ()=>{\n    // Define possible resolutions in descending order of quality\n    const resolutions = [\n        {\n            width: {\n                ideal: 4096\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 3840\n            },\n            height: {\n                ideal: 2160\n            }\n        },\n        {\n            width: {\n                ideal: 2560\n            },\n            height: {\n                ideal: 1440\n            }\n        },\n        {\n            width: {\n                ideal: 1920\n            },\n            height: {\n                ideal: 1080\n            }\n        },\n        {\n            width: {\n                ideal: 1280\n            },\n            height: {\n                ideal: 720\n            }\n        },\n        {\n            width: {\n                ideal: 640\n            },\n            height: {\n                ideal: 480\n            }\n        },\n        {} // Default - let browser decide\n    ];\n    // Try the resolutions in order until one works\n    for (const resolution of resolutions){\n        try {\n            const constraints = {\n                video: {\n                    ...resolution,\n                    facingMode: \"user\"\n                }\n            };\n            // Test if this resolution is supported\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n            // Stop the test stream immediately\n            stream.getTracks().forEach((track)=>track.stop());\n            console.log(\"Highest supported resolution:\", resolution);\n            return constraints;\n        } catch (err) {\n            console.log(\"Resolution not supported: \".concat(JSON.stringify(resolution)));\n        // Continue to next resolution\n        }\n    }\n    // If nothing worked, return basic constraints\n    return {\n        video: true\n    };\n};\n/**\n * Capture and save images at a specific point with consistent numbering\n * @param {Object} options - Capture options\n * @returns {Promise<Object>} - Capture results\n */ const captureImagesAtPoint = async (param)=>{\n    let { point, captureCount = 1, canvasRef, setCaptureCount, showCapturePreview } = param;\n    try {\n        const folder = 'eye_tracking_captures';\n        // Create a unique ID for this capture group\n        const captureGroupId = \"capture-\".concat(Date.now());\n        console.log(\"Generated capture group ID: \".concat(captureGroupId));\n        // File patterns for saving\n        const screenFilename = 'screen_001.jpg'; // Pattern only - server will assign number\n        const webcamFilename = 'webcam_001.jpg'; // Pattern only - server will assign number\n        const parameterFilename = 'parameter_001.csv'; // Pattern only - server will assign number\n        // For logging\n        console.log(\"Starting capture with group ID:\", captureGroupId);\n        const canvas = canvasRef.current;\n        let screenImage = null;\n        let webcamImage = null;\n        let captureNumber = null;\n        // Variables to store webcam resolution\n        let webcamWidth = 0;\n        let webcamHeight = 0;\n        // 1. Prepare all data first\n        // 1.1 Canvas/screen image\n        if (canvas) {\n            screenImage = canvas.toDataURL('image/png');\n        }\n        // 1.2 Webcam image - Try to get the highest resolution available\n        let webcamImagePreview = null; // Separate lower-resolution version for preview\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            // Use existing video element if available\n            webcamWidth = videoElement.videoWidth || 0;\n            webcamHeight = videoElement.videoHeight || 0;\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = webcamWidth;\n            tempCanvas.height = webcamHeight;\n            tempCanvas.getContext('2d').drawImage(videoElement, 0, 0);\n            // Create high-resolution version for saving\n            webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n            // Create lower-resolution version for preview\n            webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n            console.log(\"Existing webcam resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n        } else {\n            try {\n                // Get highest resolution constraints for this device\n                const constraints = await getHighestResolutionConstraints();\n                console.log(\"Using camera constraints:\", constraints);\n                // Try to get stream with highest resolution\n                const stream = await navigator.mediaDevices.getUserMedia(constraints);\n                // Create temporary video element to get the stream\n                const tempVideo = document.createElement('video');\n                tempVideo.srcObject = stream;\n                tempVideo.muted = true;\n                tempVideo.playsInline = true;\n                tempVideo.autoplay = true;\n                document.body.appendChild(tempVideo);\n                // Need to wait for video to be initialized\n                await new Promise((resolve)=>{\n                    tempVideo.onloadedmetadata = ()=>{\n                        tempVideo.play();\n                        resolve();\n                    };\n                    // Fallback if onloadedmetadata doesn't fire\n                    setTimeout(resolve, 1000);\n                });\n                // Wait a bit longer for the video to actually start playing\n                await new Promise((res)=>setTimeout(res, 500));\n                // Store webcam resolution\n                webcamWidth = tempVideo.videoWidth || 0;\n                webcamHeight = tempVideo.videoHeight || 0;\n                if (webcamWidth > 0 && webcamHeight > 0) {\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                    console.log(\"High-resolution webcam capture: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    console.warn(\"Unable to determine video dimensions, using fallback method\");\n                    const track = stream.getVideoTracks()[0];\n                    const settings = track.getSettings();\n                    webcamWidth = settings.width || 0;\n                    webcamHeight = settings.height || 0;\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth || 640;\n                    tempCanvas.height = webcamHeight || 480;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                    console.log(\"Fallback webcam resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Clean up\n                stream.getTracks().forEach((t)=>t.stop());\n                tempVideo.remove();\n            } catch (err) {\n                console.warn(\"High-resolution webcam capture failed:\", err);\n                // Try one more time with basic constraints\n                try {\n                    const stream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const tempVideo = document.createElement('video');\n                    tempVideo.srcObject = stream;\n                    tempVideo.muted = true;\n                    tempVideo.playsInline = true;\n                    document.body.appendChild(tempVideo);\n                    await tempVideo.play();\n                    await new Promise((res)=>setTimeout(res, 300));\n                    webcamWidth = tempVideo.videoWidth || 0;\n                    webcamHeight = tempVideo.videoHeight || 0;\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.9);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.8);\n                    console.log(\"Basic webcam resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                    stream.getTracks().forEach((t)=>t.stop());\n                    tempVideo.remove();\n                } catch (fallbackErr) {\n                    console.error(\"All webcam capture methods failed:\", fallbackErr);\n                }\n            }\n        }\n        // 1.3 Parameter data - Now including webcam resolution\n        const csvData = [\n            \"name,value\",\n            \"dot_x,\".concat(point.x),\n            \"dot_y,\".concat(point.y),\n            \"canvas_width,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.width) || 0),\n            \"canvas_height,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.height) || 0),\n            \"window_width,\".concat(window.innerWidth),\n            \"window_height,\".concat(window.innerHeight),\n            \"webcam_resolution_width,\".concat(webcamWidth),\n            \"webcam_resolution_height,\".concat(webcamHeight),\n            \"timestamp,\".concat(new Date().toISOString()),\n            \"group_id,\".concat(captureGroupId)\n        ].join('\\n');\n        // 2. Save all files with the same group ID so they get the same number\n        // 2.1 Save parameter file\n        const paramResult = await saveCSVToServer(csvData, parameterFilename, folder, captureGroupId);\n        if (paramResult && paramResult.success) {\n            captureNumber = paramResult.number;\n            console.log(\"Server assigned capture number: \".concat(captureNumber, \" for group: \").concat(captureGroupId));\n        }\n        // 2.2 Save screen image if available\n        let screenResult = null;\n        if (screenImage) {\n            screenResult = await saveImageToServer(screenImage, screenFilename, 'screen', folder, captureGroupId);\n        }\n        // 2.3 Save webcam image if available\n        let webcamResult = null;\n        if (webcamImage) {\n            webcamResult = await saveImageToServer(webcamImage, webcamFilename, 'webcam', folder, captureGroupId);\n        }\n        // 3. Show preview if needed - use the lower resolution version for preview\n        if (showCapturePreview && typeof showCapturePreview === 'function') {\n            showCapturePreview(screenImage, webcamImagePreview || webcamImage, point);\n        }\n        // 4. Increment counter for next capture\n        if (setCaptureCount && typeof setCaptureCount === 'function') {\n            setCaptureCount((prevCount)=>prevCount + 1);\n        }\n        // 5. Return results - now including webcam resolution\n        return {\n            screenImage,\n            webcamImage,\n            success: true,\n            point,\n            captureNumber,\n            groupId: captureGroupId,\n            webcamWidth,\n            webcamHeight\n        };\n    } catch (err) {\n        console.error(\"captureImagesAtPoint failed:\", err);\n        return {\n            success: false,\n            error: err.message,\n            screenImage: null,\n            webcamImage: null,\n            webcamWidth: 0,\n            webcamHeight: 0\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0hlbHBlci9zYXZlZmlsZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSwrREFBK0Q7QUFFL0Q7Ozs7Ozs7Q0FPQyxHQUNELE1BQU1BLGNBQWMsZUFBT0M7UUFBY0MsNEVBQVcsS0FBS0MsNkVBQVksS0FBS0MsMkVBQVU7SUFDbEYsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1FBQzNCLElBQUk7WUFDRixNQUFNQyxNQUFNLElBQUlDO1lBQ2hCRCxJQUFJRSxNQUFNLEdBQUc7Z0JBQ1gsMERBQTBEO2dCQUMxRCxJQUFJQyxRQUFRSCxJQUFJRyxLQUFLO2dCQUNyQixJQUFJQyxTQUFTSixJQUFJSSxNQUFNO2dCQUV2QixJQUFJRCxRQUFRVCxVQUFVO29CQUNwQlUsU0FBU0MsS0FBS0MsS0FBSyxDQUFDRixTQUFVVixDQUFBQSxXQUFXUyxLQUFJO29CQUM3Q0EsUUFBUVQ7Z0JBQ1Y7Z0JBRUEsSUFBSVUsU0FBU1QsV0FBVztvQkFDdEJRLFFBQVFFLEtBQUtDLEtBQUssQ0FBQ0gsUUFBU1IsQ0FBQUEsWUFBWVMsTUFBSztvQkFDN0NBLFNBQVNUO2dCQUNYO2dCQUVBLDZCQUE2QjtnQkFDN0IsTUFBTVksU0FBU0MsU0FBU0MsYUFBYSxDQUFDO2dCQUN0Q0YsT0FBT0osS0FBSyxHQUFHQTtnQkFDZkksT0FBT0gsTUFBTSxHQUFHQTtnQkFFaEIsa0NBQWtDO2dCQUNsQyxNQUFNTSxNQUFNSCxPQUFPSSxVQUFVLENBQUM7Z0JBQzlCRCxJQUFJRSxTQUFTLENBQUNaLEtBQUssR0FBRyxHQUFHRyxPQUFPQztnQkFFaEMseUNBQXlDO2dCQUN6QyxNQUFNUyxpQkFBaUJOLE9BQU9PLFNBQVMsQ0FBQyxjQUFjbEI7Z0JBQ3RERSxRQUFRZTtZQUNWO1lBRUFiLElBQUllLE9BQU8sR0FBRyxDQUFDQyxNQUFRakIsT0FBT2lCO1lBQzlCaEIsSUFBSWlCLEdBQUcsR0FB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RjtRQUVBLHFDQUFxQztRQUNyQyxJQUFJNEMsZUFBZTtRQUNuQixJQUFJcEMsYUFBYTtZQUNmb0MsZUFBZSxNQUFNckcsa0JBQWtCaUUsYUFBYUosZ0JBQWdCLFVBQVV6RCxRQUFRcUQ7UUFDeEY7UUFFQSwyRUFBMkU7UUFDM0UsSUFBSUQsc0JBQXNCLE9BQU9BLHVCQUF1QixZQUFZO1lBQ2xFQSxtQkFBbUJRLGFBQWFLLHNCQUFzQkosYUFBYWI7UUFDckU7UUFFQSx3Q0FBd0M7UUFDeEMsSUFBSUcsbUJBQW1CLE9BQU9BLG9CQUFvQixZQUFZO1lBQzVEQSxnQkFBZ0IrQyxDQUFBQSxZQUFhQSxZQUFZO1FBQzNDO1FBRUEsc0RBQXNEO1FBQ3RELE9BQU87WUFDTHRDO1lBQ0FDO1lBQ0F6QyxTQUFTO1lBQ1Q0QjtZQUNBYztZQUNBcUMsU0FBUzlDO1lBQ1RVO1lBQ0FDO1FBQ0Y7SUFDRixFQUFFLE9BQU90RSxLQUFLO1FBQ1pnQixRQUFRQyxLQUFLLENBQUMsZ0NBQWdDakI7UUFDOUMsT0FBTztZQUNMMEIsU0FBUztZQUNUVCxPQUFPakIsSUFBSTRCLE9BQU87WUFDbEJzQyxhQUFhO1lBQ2JDLGFBQWE7WUFDYkUsYUFBYTtZQUNiQyxjQUFjO1FBQ2hCO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvSGVscGVyL3NhdmVmaWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEhlbHBlci9zYXZlZmlsZS5qcyAtIEFkZGVkIGhpZ2hlc3QgcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZVxuXG4vKipcbiAqIFJlc2l6ZSBhbiBpbWFnZSB0byBmaXQgd2l0aGluIGEgY2VydGFpbiBzaXplIGxpbWl0XG4gKiBAcGFyYW0ge3N0cmluZ30gaW1hZ2VEYXRhVXJsIC0gQmFzZTY0IGVuY29kZWQgaW1hZ2UgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG1heFdpZHRoIC0gTWF4aW11bSB3aWR0aCBvZiB0aGUgcmVzaXplZCBpbWFnZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIE1heGltdW0gaGVpZ2h0IG9mIHRoZSByZXNpemVkIGltYWdlXG4gKiBAcGFyYW0ge251bWJlcn0gcXVhbGl0eSAtIEpQRUcgcXVhbGl0eSAoMC0xKVxuICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBSZXNpemVkIGltYWdlIGRhdGEgVVJMXG4gKi9cbmNvbnN0IHJlc2l6ZUltYWdlID0gYXN5bmMgKGltYWdlRGF0YVVybCwgbWF4V2lkdGggPSA4MDAsIG1heEhlaWdodCA9IDYwMCwgcXVhbGl0eSA9IDAuODUpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAvLyBDYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgd2hpbGUgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvXG4gICAgICAgIGxldCB3aWR0aCA9IGltZy53aWR0aDtcbiAgICAgICAgbGV0IGhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICBpZiAod2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIGhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0ICogKG1heFdpZHRoIC8gd2lkdGgpKTtcbiAgICAgICAgICB3aWR0aCA9IG1heFdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoICogKG1heEhlaWdodCAvIGhlaWdodCkpO1xuICAgICAgICAgIGhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGNhbnZhcyBmb3IgcmVzaXppbmdcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyBhbmQgcmVzaXplIGltYWdlIG9uIGNhbnZhc1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCB0byBKUEVHIHdpdGggc3BlY2lmaWVkIHF1YWxpdHlcbiAgICAgICAgY29uc3QgcmVzaXplZERhdGFVcmwgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgcXVhbGl0eSk7XG4gICAgICAgIHJlc29sdmUocmVzaXplZERhdGFVcmwpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgaW1nLm9uZXJyb3IgPSAoZXJyKSA9PiByZWplY3QoZXJyKTtcbiAgICAgIGltZy5zcmMgPSBpbWFnZURhdGFVcmw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBTYXZlIGFuIGltYWdlIG9yIGRhdGEgdG8gdGhlIHNlcnZlciB3aXRoIGdyb3VwIElEIHRvIGVuc3VyZSBjb25zaXN0ZW50IG51bWJlcmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGltYWdlRGF0YSAtIEJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIEZpbGVuYW1lIHBhdHRlcm4gdG8gc2F2ZSBhc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUeXBlIG9mIGZpbGUgKHNjcmVlbiwgd2ViY2FtLCBwYXJhbWV0ZXJzKVxuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIEZvbGRlciB0byBzYXZlIGluXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FwdHVyZUdyb3VwIC0gVW5pcXVlIElEIGZvciBncm91cGluZyBmaWxlcyBmcm9tIHRoZSBzYW1lIGNhcHR1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gU2VydmVyIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBzYXZlSW1hZ2VUb1NlcnZlciA9IGFzeW5jIChpbWFnZURhdGEsIGZpbGVuYW1lLCB0eXBlLCBmb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJywgY2FwdHVyZUdyb3VwID0gbnVsbCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICBpbWFnZURhdGEsIFxuICAgICAgICBmaWxlbmFtZSwgXG4gICAgICAgIHR5cGUsIFxuICAgICAgICBmb2xkZXIsXG4gICAgICAgIGNhcHR1cmVHcm91cCAvLyBJbmNsdWRlIHRoZSBjYXB0dXJlIGdyb3VwIElEXG4gICAgICB9KVxuICAgIH0pO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c30gZm9yICR7dHlwZX1gKTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIDQxMyAocGF5bG9hZCB0b28gbGFyZ2UpIGFuZCBpdCdzIGFuIGltYWdlLCB0cnkgcmVzaXppbmdcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQxMyAmJiB0eXBlICE9PSAncGFyYW1ldGVycycpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBJbWFnZSB0b28gbGFyZ2UgZm9yIHNlcnZlciAoNDEzIGVycm9yKSwgd2lsbCByZXNpemUgYW5kIHJldHJ5YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCB3aXRoIGhpZ2hlciBxdWFsaXR5IGFuZCBwcm9ncmVzc2l2ZWx5IHJlZHVjZSBxdWFsaXR5L3NpemUgdW50aWwgaXQgZml0c1xuICAgICAgICBjb25zdCBzaXplcyA9IFtcbiAgICAgICAgICB7IHdpZHRoOiAxOTIwLCBoZWlnaHQ6IDEwODAsIHF1YWxpdHk6IDAuOSB9LFxuICAgICAgICAgIHsgd2lkdGg6IDEyODAsIGhlaWdodDogNzIwLCBxdWFsaXR5OiAwLjg1IH0sXG4gICAgICAgICAgeyB3aWR0aDogODAwLCBoZWlnaHQ6IDYwMCwgcXVhbGl0eTogMC44IH0sXG4gICAgICAgICAgeyB3aWR0aDogNjQwLCBoZWlnaHQ6IDQ4MCwgcXVhbGl0eTogMC43NSB9XG4gICAgICAgIF07XG4gICAgICAgIFxuICAgICAgICBmb3IgKGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSB9IG9mIHNpemVzKSB7XG4gICAgICAgICAgY29uc3QgcmVzaXplZEltYWdlID0gYXdhaXQgcmVzaXplSW1hZ2UoaW1hZ2VEYXRhLCB3aWR0aCwgaGVpZ2h0LCBxdWFsaXR5KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmV0cnlSZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhOiByZXNpemVkSW1hZ2UsIFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lLCBcbiAgICAgICAgICAgICAgICB0eXBlLCBcbiAgICAgICAgICAgICAgICBmb2xkZXIsXG4gICAgICAgICAgICAgICAgY2FwdHVyZUdyb3VwXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJldHJ5UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBzYXZlZCByZXNpemVkICR7dHlwZX0gYXQgJHt3aWR0aH14JHtoZWlnaHR9LCBxdWFsaXR5ICR7cXVhbGl0eX1gKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHJldHJ5RXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGR1cmluZyByZXRyeSBmb3IgJHt0eXBlfTpgLCByZXRyeUVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJGYWlsZWQgdG8gc2F2ZSBpbWFnZSBldmVuIGFmdGVyIHJlc2l6aW5nXCIgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgU2VydmVyIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfWAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nICR7dHlwZX06YCwgZXJyb3IpO1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICB9XG59O1xuXG4vKipcbiAqIFNhdmUgQ1NWIGRhdGEgdG8gdGhlIHNlcnZlclxuICogQHBhcmFtIHtzdHJpbmd9IGNzdkRhdGEgLSBDU1YgZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gRmlsZW5hbWUgcGF0dGVybiB0byBzYXZlIGFzXG4gKiBAcGFyYW0ge3N0cmluZ30gZm9sZGVyIC0gRm9sZGVyIHRvIHNhdmUgaW5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjYXB0dXJlR3JvdXAgLSBVbmlxdWUgSUQgZm9yIGdyb3VwaW5nIGZpbGVzIGZyb20gdGhlIHNhbWUgY2FwdHVyZVxuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBTZXJ2ZXIgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGNvbnN0IHNhdmVDU1ZUb1NlcnZlciA9IGFzeW5jIChjc3ZEYXRhLCBmaWxlbmFtZSwgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsIGNhcHR1cmVHcm91cCA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBjc3ZCbG9iID0gbmV3IEJsb2IoW2NzdkRhdGFdLCB7IHR5cGU6ICd0ZXh0L2NzdicgfSk7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBjb25zdCBjc3ZEYXRhVXJsID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcihjc3ZEYXRhVXJsLCBmaWxlbmFtZSwgJ3BhcmFtZXRlcnMnLCBmb2xkZXIsIGNhcHR1cmVHcm91cCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgQ1NWOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvbiBjYW1lcmEgY29uc3RyYWludHMgc3VwcG9ydGVkIGJ5IHRoZSBkZXZpY2VcbiAqIEByZXR1cm5zIHtQcm9taXNlPE1lZGlhU3RyZWFtQ29uc3RyYWludHM+fSAtIENhbWVyYSBjb25zdHJhaW50cyB3aXRoIGhpZ2hlc3QgcmVzb2x1dGlvblxuICovXG5jb25zdCBnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzID0gYXN5bmMgKCkgPT4ge1xuICAvLyBEZWZpbmUgcG9zc2libGUgcmVzb2x1dGlvbnMgaW4gZGVzY2VuZGluZyBvcmRlciBvZiBxdWFsaXR5XG4gIGNvbnN0IHJlc29sdXRpb25zID0gW1xuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDQwOTYgfSwgaGVpZ2h0OiB7IGlkZWFsOiAyMTYwIH0gfSwgLy8gNEtcbiAgICB7IHdpZHRoOiB7IGlkZWFsOiAzODQwIH0sIGhlaWdodDogeyBpZGVhbDogMjE2MCB9IH0sIC8vIDRLIFVIRFxuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDI1NjAgfSwgaGVpZ2h0OiB7IGlkZWFsOiAxNDQwIH0gfSwgLy8gMksgUUhEXG4gICAgeyB3aWR0aDogeyBpZGVhbDogMTkyMCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDEwODAgfSB9LCAvLyBGdWxsIEhEXG4gICAgeyB3aWR0aDogeyBpZGVhbDogMTI4MCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDcyMCB9IH0sICAvLyBIRFxuICAgIHsgd2lkdGg6IHsgaWRlYWw6IDY0MCB9LCBoZWlnaHQ6IHsgaWRlYWw6IDQ4MCB9IH0sICAgLy8gVkdBXG4gICAge30gIC8vIERlZmF1bHQgLSBsZXQgYnJvd3NlciBkZWNpZGVcbiAgXTtcblxuICAvLyBUcnkgdGhlIHJlc29sdXRpb25zIGluIG9yZGVyIHVudGlsIG9uZSB3b3Jrc1xuICBmb3IgKGNvbnN0IHJlc29sdXRpb24gb2YgcmVzb2x1dGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY29uc3RyYWludHMgPSB7XG4gICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgLi4ucmVzb2x1dGlvbixcbiAgICAgICAgICBmYWNpbmdNb2RlOiBcInVzZXJcIlxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBUZXN0IGlmIHRoaXMgcmVzb2x1dGlvbiBpcyBzdXBwb3J0ZWRcbiAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgIFxuICAgICAgLy8gU3RvcCB0aGUgdGVzdCBzdHJlYW0gaW1tZWRpYXRlbHlcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiSGlnaGVzdCBzdXBwb3J0ZWQgcmVzb2x1dGlvbjpcIiwgcmVzb2x1dGlvbik7XG4gICAgICByZXR1cm4gY29uc3RyYWludHM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUmVzb2x1dGlvbiBub3Qgc3VwcG9ydGVkOiAke0pTT04uc3RyaW5naWZ5KHJlc29sdXRpb24pfWApO1xuICAgICAgLy8gQ29udGludWUgdG8gbmV4dCByZXNvbHV0aW9uXG4gICAgfVxuICB9XG4gIFxuICAvLyBJZiBub3RoaW5nIHdvcmtlZCwgcmV0dXJuIGJhc2ljIGNvbnN0cmFpbnRzXG4gIHJldHVybiB7IHZpZGVvOiB0cnVlIH07XG59O1xuXG4vKipcbiAqIENhcHR1cmUgYW5kIHNhdmUgaW1hZ2VzIGF0IGEgc3BlY2lmaWMgcG9pbnQgd2l0aCBjb25zaXN0ZW50IG51bWJlcmluZ1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDYXB0dXJlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gQ2FwdHVyZSByZXN1bHRzXG4gKi9cbmV4cG9ydCBjb25zdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCA9IGFzeW5jICh7IHBvaW50LCBjYXB0dXJlQ291bnQgPSAxLCBjYW52YXNSZWYsIHNldENhcHR1cmVDb3VudCwgc2hvd0NhcHR1cmVQcmV2aWV3IH0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBmb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJztcbiAgICBcbiAgICAvLyBDcmVhdGUgYSB1bmlxdWUgSUQgZm9yIHRoaXMgY2FwdHVyZSBncm91cFxuICAgIGNvbnN0IGNhcHR1cmVHcm91cElkID0gYGNhcHR1cmUtJHtEYXRlLm5vdygpfWA7XG4gICAgY29uc29sZS5sb2coYEdlbmVyYXRlZCBjYXB0dXJlIGdyb3VwIElEOiAke2NhcHR1cmVHcm91cElkfWApO1xuICAgIFxuICAgIC8vIEZpbGUgcGF0dGVybnMgZm9yIHNhdmluZ1xuICAgIGNvbnN0IHNjcmVlbkZpbGVuYW1lID0gJ3NjcmVlbl8wMDEuanBnJzsgIC8vIFBhdHRlcm4gb25seSAtIHNlcnZlciB3aWxsIGFzc2lnbiBudW1iZXJcbiAgICBjb25zdCB3ZWJjYW1GaWxlbmFtZSA9ICd3ZWJjYW1fMDAxLmpwZyc7ICAvLyBQYXR0ZXJuIG9ubHkgLSBzZXJ2ZXIgd2lsbCBhc3NpZ24gbnVtYmVyXG4gICAgY29uc3QgcGFyYW1ldGVyRmlsZW5hbWUgPSAncGFyYW1ldGVyXzAwMS5jc3YnOyAgLy8gUGF0dGVybiBvbmx5IC0gc2VydmVyIHdpbGwgYXNzaWduIG51bWJlclxuICAgIFxuICAgIC8vIEZvciBsb2dnaW5nXG4gICAgY29uc29sZS5sb2coXCJTdGFydGluZyBjYXB0dXJlIHdpdGggZ3JvdXAgSUQ6XCIsIGNhcHR1cmVHcm91cElkKTtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBsZXQgc2NyZWVuSW1hZ2UgPSBudWxsO1xuICAgIGxldCB3ZWJjYW1JbWFnZSA9IG51bGw7XG4gICAgbGV0IGNhcHR1cmVOdW1iZXIgPSBudWxsO1xuICAgIFxuICAgIC8vIFZhcmlhYmxlcyB0byBzdG9yZSB3ZWJjYW0gcmVzb2x1dGlvblxuICAgIGxldCB3ZWJjYW1XaWR0aCA9IDA7XG4gICAgbGV0IHdlYmNhbUhlaWdodCA9IDA7XG4gICAgXG4gICAgLy8gMS4gUHJlcGFyZSBhbGwgZGF0YSBmaXJzdFxuICAgIFxuICAgIC8vIDEuMSBDYW52YXMvc2NyZWVuIGltYWdlXG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgc2NyZWVuSW1hZ2UgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICB9XG5cbiAgICAvLyAxLjIgV2ViY2FtIGltYWdlIC0gVHJ5IHRvIGdldCB0aGUgaGlnaGVzdCByZXNvbHV0aW9uIGF2YWlsYWJsZVxuICAgIGxldCB3ZWJjYW1JbWFnZVByZXZpZXcgPSBudWxsOyAvLyBTZXBhcmF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB3aW5kb3cudmlkZW9FbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgaWYgKHZpZGVvRWxlbWVudCkge1xuICAgICAgLy8gVXNlIGV4aXN0aW5nIHZpZGVvIGVsZW1lbnQgaWYgYXZhaWxhYmxlXG4gICAgICB3ZWJjYW1XaWR0aCA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIHx8IDA7XG4gICAgICB3ZWJjYW1IZWlnaHQgPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgfHwgMDtcbiAgICAgIFxuICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdlYmNhbVdpZHRoO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHZpZGVvRWxlbWVudCwgMCwgMCk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICB3ZWJjYW1JbWFnZSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC45NSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgIHdlYmNhbUltYWdlUHJldmlldyA9IGF3YWl0IHJlc2l6ZUltYWdlKHdlYmNhbUltYWdlLCA2NDAsIDQ4MCwgMC44NSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBFeGlzdGluZyB3ZWJjYW0gcmVzb2x1dGlvbjogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBoaWdoZXN0IHJlc29sdXRpb24gY29uc3RyYWludHMgZm9yIHRoaXMgZGV2aWNlXG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGNhbWVyYSBjb25zdHJhaW50czpcIiwgY29uc3RyYWludHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBzdHJlYW0gd2l0aCBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHRlbXBvcmFyeSB2aWRlbyBlbGVtZW50IHRvIGdldCB0aGUgc3RyZWFtXG4gICAgICAgIGNvbnN0IHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIHRlbXBWaWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE5lZWQgdG8gd2FpdCBmb3IgdmlkZW8gdG8gYmUgaW5pdGlhbGl6ZWRcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkbWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICB0ZW1wVmlkZW8ucGxheSgpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgLy8gRmFsbGJhY2sgaWYgb25sb2FkZWRtZXRhZGF0YSBkb2Vzbid0IGZpcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSBiaXQgbG9uZ2VyIGZvciB0aGUgdmlkZW8gdG8gYWN0dWFsbHkgc3RhcnQgcGxheWluZ1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXMgPT4gc2V0VGltZW91dChyZXMsIDUwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgd2ViY2FtIHJlc29sdXRpb25cbiAgICAgICAgd2ViY2FtV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCAwO1xuICAgICAgICB3ZWJjYW1IZWlnaHQgPSB0ZW1wVmlkZW8udmlkZW9IZWlnaHQgfHwgMDtcbiAgICAgICAgXG4gICAgICAgIGlmICh3ZWJjYW1XaWR0aCA+IDAgJiYgd2ViY2FtSGVpZ2h0ID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2ViY2FtV2lkdGg7XG4gICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOTUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgICAgICB3ZWJjYW1JbWFnZVByZXZpZXcgPSBhd2FpdCByZXNpemVJbWFnZSh3ZWJjYW1JbWFnZSwgNjQwLCA0ODAsIDAuODUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBIaWdoLXJlc29sdXRpb24gd2ViY2FtIGNhcHR1cmU6ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuYWJsZSB0byBkZXRlcm1pbmUgdmlkZW8gZGltZW5zaW9ucywgdXNpbmcgZmFsbGJhY2sgbWV0aG9kXCIpO1xuICAgICAgICAgIGNvbnN0IHRyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgIHdlYmNhbVdpZHRoID0gc2V0dGluZ3Mud2lkdGggfHwgMDtcbiAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBzZXR0aW5ncy5oZWlnaHQgfHwgMDtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdlYmNhbVdpZHRoIHx8IDY0MDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHdlYmNhbUhlaWdodCB8fCA0ODA7XG4gICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOTUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgICAgICB3ZWJjYW1JbWFnZVByZXZpZXcgPSBhd2FpdCByZXNpemVJbWFnZSh3ZWJjYW1JbWFnZSwgNjQwLCA0ODAsIDAuODUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGYWxsYmFjayB3ZWJjYW0gcmVzb2x1dGlvbjogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpO1xuICAgICAgICB0ZW1wVmlkZW8ucmVtb3ZlKCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSGlnaC1yZXNvbHV0aW9uIHdlYmNhbSBjYXB0dXJlIGZhaWxlZDpcIiwgZXJyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyeSBvbmUgbW9yZSB0aW1lIHdpdGggYmFzaWMgY29uc3RyYWludHNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xuICAgICAgICAgIGNvbnN0IHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICB0ZW1wVmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWaWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICAgIGF3YWl0IHRlbXBWaWRlby5wbGF5KCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzID0+IHNldFRpbWVvdXQocmVzLCAzMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRlbXBWaWRlby52aWRlb1dpZHRoIHx8IDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3ZWJjYW1XaWR0aDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHdlYmNhbUhlaWdodDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKHRlbXBWaWRlbywgMCwgMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGhpZ2gtcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBzYXZpbmdcbiAgICAgICAgICB3ZWJjYW1JbWFnZSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC45KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgbG93ZXItcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgICAgICAgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gYXdhaXQgcmVzaXplSW1hZ2Uod2ViY2FtSW1hZ2UsIDY0MCwgNDgwLCAwLjgpO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBCYXNpYyB3ZWJjYW0gcmVzb2x1dGlvbjogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godCA9PiB0LnN0b3AoKSk7XG4gICAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgICB9IGNhdGNoIChmYWxsYmFja0Vycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJBbGwgd2ViY2FtIGNhcHR1cmUgbWV0aG9kcyBmYWlsZWQ6XCIsIGZhbGxiYWNrRXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEuMyBQYXJhbWV0ZXIgZGF0YSAtIE5vdyBpbmNsdWRpbmcgd2ViY2FtIHJlc29sdXRpb25cbiAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICBgZG90X3gsJHtwb2ludC54fWAsXG4gICAgICBgZG90X3ksJHtwb2ludC55fWAsXG4gICAgICBgY2FudmFzX3dpZHRoLCR7Y2FudmFzPy53aWR0aCB8fCAwfWAsXG4gICAgICBgY2FudmFzX2hlaWdodCwke2NhbnZhcz8uaGVpZ2h0IHx8IDB9YCxcbiAgICAgIGB3aW5kb3dfd2lkdGgsJHt3aW5kb3cuaW5uZXJXaWR0aH1gLFxuICAgICAgYHdpbmRvd19oZWlnaHQsJHt3aW5kb3cuaW5uZXJIZWlnaHR9YCxcbiAgICAgIGB3ZWJjYW1fcmVzb2x1dGlvbl93aWR0aCwke3dlYmNhbVdpZHRofWAsXG4gICAgICBgd2ViY2FtX3Jlc29sdXRpb25faGVpZ2h0LCR7d2ViY2FtSGVpZ2h0fWAsXG4gICAgICBgdGltZXN0YW1wLCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWAsXG4gICAgICBgZ3JvdXBfaWQsJHtjYXB0dXJlR3JvdXBJZH1gXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgICBcbiAgICAvLyAyLiBTYXZlIGFsbCBmaWxlcyB3aXRoIHRoZSBzYW1lIGdyb3VwIElEIHNvIHRoZXkgZ2V0IHRoZSBzYW1lIG51bWJlclxuICAgIFxuICAgIC8vIDIuMSBTYXZlIHBhcmFtZXRlciBmaWxlXG4gICAgY29uc3QgcGFyYW1SZXN1bHQgPSBhd2FpdCBzYXZlQ1NWVG9TZXJ2ZXIoY3N2RGF0YSwgcGFyYW1ldGVyRmlsZW5hbWUsIGZvbGRlciwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIFxuICAgIGlmIChwYXJhbVJlc3VsdCAmJiBwYXJhbVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBjYXB0dXJlTnVtYmVyID0gcGFyYW1SZXN1bHQubnVtYmVyO1xuICAgICAgY29uc29sZS5sb2coYFNlcnZlciBhc3NpZ25lZCBjYXB0dXJlIG51bWJlcjogJHtjYXB0dXJlTnVtYmVyfSBmb3IgZ3JvdXA6ICR7Y2FwdHVyZUdyb3VwSWR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDIuMiBTYXZlIHNjcmVlbiBpbWFnZSBpZiBhdmFpbGFibGVcbiAgICBsZXQgc2NyZWVuUmVzdWx0ID0gbnVsbDtcbiAgICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICAgIHNjcmVlblJlc3VsdCA9IGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKHNjcmVlbkltYWdlLCBzY3JlZW5GaWxlbmFtZSwgJ3NjcmVlbicsIGZvbGRlciwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyAyLjMgU2F2ZSB3ZWJjYW0gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gICAgbGV0IHdlYmNhbVJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICB3ZWJjYW1SZXN1bHQgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcih3ZWJjYW1JbWFnZSwgd2ViY2FtRmlsZW5hbWUsICd3ZWJjYW0nLCBmb2xkZXIsIGNhcHR1cmVHcm91cElkKTtcbiAgICB9XG4gICAgXG4gICAgLy8gMy4gU2hvdyBwcmV2aWV3IGlmIG5lZWRlZCAtIHVzZSB0aGUgbG93ZXIgcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBwcmV2aWV3XG4gICAgaWYgKHNob3dDYXB0dXJlUHJldmlldyAmJiB0eXBlb2Ygc2hvd0NhcHR1cmVQcmV2aWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlUHJldmlldyB8fCB3ZWJjYW1JbWFnZSwgcG9pbnQpO1xuICAgIH1cbiAgICBcbiAgICAvLyA0LiBJbmNyZW1lbnQgY291bnRlciBmb3IgbmV4dCBjYXB0dXJlXG4gICAgaWYgKHNldENhcHR1cmVDb3VudCAmJiB0eXBlb2Ygc2V0Q2FwdHVyZUNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZXRDYXB0dXJlQ291bnQocHJldkNvdW50ID0+IHByZXZDb3VudCArIDEpO1xuICAgIH1cbiAgICBcbiAgICAvLyA1LiBSZXR1cm4gcmVzdWx0cyAtIG5vdyBpbmNsdWRpbmcgd2ViY2FtIHJlc29sdXRpb25cbiAgICByZXR1cm4ge1xuICAgICAgc2NyZWVuSW1hZ2UsXG4gICAgICB3ZWJjYW1JbWFnZSxcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBwb2ludCxcbiAgICAgIGNhcHR1cmVOdW1iZXIsXG4gICAgICBncm91cElkOiBjYXB0dXJlR3JvdXBJZCxcbiAgICAgIHdlYmNhbVdpZHRoLFxuICAgICAgd2ViY2FtSGVpZ2h0XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcihcImNhcHR1cmVJbWFnZXNBdFBvaW50IGZhaWxlZDpcIiwgZXJyKTtcbiAgICByZXR1cm4geyBcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLCBcbiAgICAgIGVycm9yOiBlcnIubWVzc2FnZSxcbiAgICAgIHNjcmVlbkltYWdlOiBudWxsLFxuICAgICAgd2ViY2FtSW1hZ2U6IG51bGwsXG4gICAgICB3ZWJjYW1XaWR0aDogMCxcbiAgICAgIHdlYmNhbUhlaWdodDogMFxuICAgIH07XG4gIH1cbn07Il0sIm5hbWVzIjpbInJlc2l6ZUltYWdlIiwiaW1hZ2VEYXRhVXJsIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJxdWFsaXR5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsIndpZHRoIiwiaGVpZ2h0IiwiTWF0aCIsInJvdW5kIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInJlc2l6ZWREYXRhVXJsIiwidG9EYXRhVVJMIiwib25lcnJvciIsImVyciIsInNyYyIsInNhdmVJbWFnZVRvU2VydmVyIiwiaW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ0eXBlIiwiZm9sZGVyIiwiY2FwdHVyZUdyb3VwIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiY29uc29sZSIsImVycm9yIiwic3RhdHVzIiwid2FybiIsInNpemVzIiwicmVzaXplZEltYWdlIiwicmV0cnlSZXNwb25zZSIsImxvZyIsImpzb24iLCJyZXRyeUVycm9yIiwic3VjY2VzcyIsInJlc3VsdCIsIm1lc3NhZ2UiLCJzYXZlQ1NWVG9TZXJ2ZXIiLCJjc3ZEYXRhIiwiY3N2QmxvYiIsIkJsb2IiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlYWRBc0RhdGFVUkwiLCJnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzIiwicmVzb2x1dGlvbnMiLCJpZGVhbCIsInJlc29sdXRpb24iLCJjb25zdHJhaW50cyIsInZpZGVvIiwiZmFjaW5nTW9kZSIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsInBvaW50IiwiY2FwdHVyZUNvdW50IiwiY2FudmFzUmVmIiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiY2FwdHVyZUdyb3VwSWQiLCJEYXRlIiwibm93Iiwic2NyZWVuRmlsZW5hbWUiLCJ3ZWJjYW1GaWxlbmFtZSIsInBhcmFtZXRlckZpbGVuYW1lIiwiY3VycmVudCIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJjYXB0dXJlTnVtYmVyIiwid2ViY2FtV2lkdGgiLCJ3ZWJjYW1IZWlnaHQiLCJ3ZWJjYW1JbWFnZVByZXZpZXciLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwidGVtcENhbnZhcyIsInRlbXBWaWRlbyIsInNyY09iamVjdCIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJhdXRvcGxheSIsImFwcGVuZENoaWxkIiwib25sb2FkZWRtZXRhZGF0YSIsInBsYXkiLCJzZXRUaW1lb3V0IiwicmVzIiwiZ2V0VmlkZW9UcmFja3MiLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwidCIsInJlbW92ZSIsImZhbGxiYWNrRXJyIiwieCIsInkiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJwYXJhbVJlc3VsdCIsIm51bWJlciIsInNjcmVlblJlc3VsdCIsIndlYmNhbVJlc3VsdCIsInByZXZDb3VudCIsImdyb3VwSWQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\n"));

/***/ })

});