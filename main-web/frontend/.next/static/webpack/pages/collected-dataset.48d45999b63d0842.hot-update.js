"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset",{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js":
/*!********************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/countSave.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calibrationCapture: () => (/* binding */ calibrationCapture),\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown)\n/* harmony export */ });\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\");\n// Fixed countSave.js - Resolving redrawInterval reference error\n// Shared functionality for countdown and image capture processes\n\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(absoluteX, \"px;\\n    top: \").concat(absoluteY - 60, \"px;\\n    transform: translateX(-50%);\\n    color: red;\\n    font-size: 36px;\\n    font-weight: bold;\\n    text-shadow: 0 0 10px white, 0 0 20px white;\\n    z-index: 9999;\\n    background-color: rgba(255, 255, 255, 0.8);\\n    border: 2px solid red;\\n    border-radius: 50%;\\n    width: 50px;\\n    height: 50px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n  \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Display a preview of the captured images\n * @param {string} screenImage - Data URL of the screen image\n * @param {string} webcamImage - Data URL of the webcam image\n * @param {Object} point - {x, y} position of the dot\n */ const showCapturePreview = (screenImage, webcamImage, point)=>{\n    if (!screenImage && !webcamImage) return;\n    // Remove any existing previews\n    const existingPreviews = document.querySelectorAll('.capture-preview-container');\n    existingPreviews.forEach((preview)=>{\n        if (preview.parentNode) {\n            preview.parentNode.removeChild(preview);\n        }\n    });\n    // Create preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n      position: fixed;\\n      top: 50%;\\n      left: 50%;\\n      transform: translate(-50%, -50%);\\n      display: flex;\\n      gap: 20px;\\n      background-color: rgba(0, 0, 0, 0.85);\\n      padding: 20px;\\n      border-radius: 12px;\\n      z-index: 999999;\\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n    \";\n    // Set a consistent height for both previews\n    const previewHeight = 240; // Fixed height for both images\n    // Add screen image if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.alt = 'Screen Capture';\n        screenImg.style.cssText = \"\\n        height: \".concat(previewHeight, \"px;\\n        width: auto;\\n        object-fit: contain;\\n        border: 3px solid white;\\n        border-radius: 8px;\\n        background-color: #333;\\n      \");\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n        color: white;\\n        font-size: 14px;\\n        margin-top: 10px;\\n        font-weight: bold;\\n      \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam image if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.alt = 'Webcam Capture';\n        webcamImg.style.cssText = \"\\n        height: \".concat(previewHeight, \"px;\\n        width: auto;\\n        object-fit: contain;\\n        border: 3px solid white;\\n        border-radius: 8px;\\n        background-color: #333;\\n      \");\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n        color: white;\\n        font-size: 14px;\\n        margin-top: 10px;\\n        font-weight: bold;\\n      \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add point info\n    if (point) {\n        const pointInfo = document.createElement('div');\n        pointInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Point: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n        pointInfo.style.cssText = \"\\n        color: #ffcc00;\\n        font-size: 14px;\\n        position: absolute;\\n        top: -40px;\\n        left: 0;\\n        width: 100%;\\n        text-align: center;\\n      \";\n        previewContainer.appendChild(pointInfo);\n    }\n    // Add timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n      position: absolute;\\n      bottom: -25px;\\n      right: 20px;\\n      color: white;\\n      font-size: 12px;\\n      background-color: rgba(0, 0, 0, 0.7);\\n      padding: 3px 8px;\\n      border-radius: 4px;\\n    \";\n    previewContainer.appendChild(timerElement);\n    // Add to document\n    document.body.appendChild(previewContainer);\n    // Countdown\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            previewContainer.style.opacity = '0';\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    // Create redrawInterval for keeping dot visible during countdown\n    let redrawInterval = setInterval(()=>{\n        drawRedDot(ctx, position.x, position.y, 12, false);\n    }, 200);\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    drawRedDot(ctx, position.x, position.y, 12, false);\n                    // Clear the redrawInterval we defined above\n                    if (redrawInterval) {\n                        clearInterval(redrawInterval);\n                    }\n                    if (onComplete) {\n                        drawRedDot(ctx, position.x, position.y, 12, false);\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n * Draw a red dot on the canvas\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n * @returns {Object} - {x, y} position\n */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * @param {Object} options - Capture options\n * @returns {Promise} - Promise that resolves with the capture result\n */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[captureImages] Invalid position object:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid capture position');\n        return null;\n    }\n    try {\n        // Call the captureImagesAtPoint from savefile.js\n        const result = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_0__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        return {\n            screenImage: (result === null || result === void 0 ? void 0 : result.screenImage) || '',\n            webcamImage: (result === null || result === void 0 ? void 0 : result.webcamImage) || '',\n            success: true\n        };\n    } catch (err) {\n        console.error('[captureImages] Unexpected error:', err);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: err.message\n        };\n    }\n};\n/**\n * Generate a random dot position within the canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} padding - Padding from the edges\n * @returns {Object} - {x, y} position\n */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n * Special calibration capture function that avoids problematic code paths\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ /**\n * Special calibration capture function that behaves like random dot capture\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ const calibrationCapture = async (options)=>{\n    const { canvasRef, point, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures', pointIndex, totalPoints } = options;\n    try {\n        console.log(\"Starting calibration capture for point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Get canvas\n        const canvas = canvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas reference is null in calibrationCapture\");\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: Canvas not available\");\n            return {\n                success: false\n            };\n        }\n        // Use the exact same drawing method as random dots\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, point.x, point.y);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Calibration point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Use the same countdown element creation method\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = createCountdownElement(point, canvasRect);\n        if (!countdownElement) {\n            console.error(\"Failed to create countdown element\");\n            return {\n                success: false\n            };\n        }\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, point.x, point.y, 12, false);\n        }, 200);\n        // Run the same countdown as random dot\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Point \".concat(pointIndex + 1, \"/\").concat(totalPoints, \" - countdown \").concat(count));\n            // Redraw the dot at each step to ensure it remains visible\n            drawRedDot(ctx, point.x, point.y, 12, false);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show checkmark\n        countdownElement.textContent = \"✓\";\n        // Remove countdown element\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Clear redrawInterval\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureAndPreviewProcess instead of directly calling captureImagesAtPoint\n        const captureResult = await captureAndPreviewProcess({\n            canvasRef,\n            position: point,\n            captureCounter,\n            setCaptureCounter,\n            setProcessStatus: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            captureFolder\n        });\n        // Ensure proper return even if captureResult is null\n        const safeResult = captureResult && typeof captureResult === 'object' ? captureResult : {\n            screenImage: '',\n            webcamImage: '',\n            success: false\n        };\n        return {\n            screenImage: safeResult.screenImage || '',\n            webcamImage: safeResult.webcamImage || '',\n            success: true,\n            point\n        };\n    } catch (error) {\n        console.error(\"Error in calibrationCapture:\", error);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(error.message));\n        // Always return a valid object with default values\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Complete capture and preview process\n * @param {Object} options - Process options\n */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder } = options;\n    try {\n        const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;\n        if (!canvas) {\n            console.error(\"[captureAndPreviewProcess] Canvas reference is null\");\n            if (setProcessStatus) setProcessStatus('Error: Canvas is not available');\n            return null;\n        }\n        // Draw the dot\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, position.x, position.y);\n        // Countdown before capture\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Starting countdown...',\n                isCapturing: true\n            });\n        }\n        // Create a custom countdown element\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = document.createElement('div');\n        countdownElement.className = 'calibrate-countdown';\n        countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(canvasRect.left + position.x, \"px;\\n      top: \").concat(canvasRect.top + position.y - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n        document.body.appendChild(countdownElement);\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y, 12, false);\n        }, 200);\n        // Manual countdown\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n            // Redraw dot to ensure it's visible\n            drawRedDot(ctx, position.x, position.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Change to checkmark\n        countdownElement.textContent = \"✓\";\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capturing images...',\n                countdownValue: \"Capturing...\",\n                isCapturing: true\n            });\n        }\n        // Remove countdown element and clear redrawInterval\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureImagesAtPoint from savefile.js\n        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_0__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured dot at x=\".concat(Math.round(position.x), \", y=\").concat(Math.round(position.y)));\n        }\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capture complete',\n                isCapturing: false\n            });\n        }\n        // Show TopBar again with delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"[captureAndPreviewProcess] Fatal error:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Fatal error: \".concat(error.message));\n        }\n        // Ensure TopBar is shown even on error\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        // Return a minimal valid object to prevent null reference errors\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxnRUFBZ0U7QUFDaEUsaUVBQWlFO0FBQ1A7QUFFMUQ7Ozs7O0NBS0MsR0FDTSxNQUFNQyx5QkFBeUIsQ0FBQ0MsVUFBVUM7SUFDL0MsSUFBSSxDQUFDRCxZQUFZLE9BQU9BLFNBQVNFLENBQUMsS0FBSyxZQUFZLE9BQU9GLFNBQVNHLENBQUMsS0FBSyxVQUFVO1FBQ2pGQyxRQUFRQyxJQUFJLENBQUMsOENBQThDTDtRQUMzRCxPQUFPO0lBQ1Q7SUFFQSxNQUFNTSxxQkFBcUJDLFNBQVNDLGdCQUFnQixDQUFDO0lBQ3JERixtQkFBbUJHLE9BQU8sQ0FBQ0MsQ0FBQUEsS0FBTUEsR0FBR0MsTUFBTTtJQUUxQyxNQUFNQyxZQUFZWCxXQUFXWSxJQUFJLEdBQUdiLFNBQVNFLENBQUM7SUFDOUMsTUFBTVksWUFBWWIsV0FBV2MsR0FBRyxHQUFHZixTQUFTRyxDQUFDO0lBRTdDLE1BQU1hLG1CQUFtQlQsU0FBU1UsYUFBYSxDQUFDO0lBQ2hERCxpQkFBaUJFLFNBQVMsR0FBRztJQUM3QkYsaUJBQWlCRyxLQUFLLENBQUNDLE9BQU8sR0FBRyxxQ0FHeEJOLE9BRENGLFdBQVUsa0JBQ0ksT0FBZkUsWUFBWSxJQUFHO0lBa0J4QlAsU0FBU2MsSUFBSSxDQUFDQyxXQUFXLENBQUNOO0lBQzFCLE9BQU9BO0FBQ1QsRUFBRTtBQUVGOzs7OztDQUtDLEdBQ0QsTUFBTU8scUJBQXFCLENBQUNDLGFBQWFDLGFBQWFDO0lBQ2xELElBQUksQ0FBQ0YsZUFBZSxDQUFDQyxhQUFhO0lBRWxDLCtCQUErQjtJQUMvQixNQUFNRSxtQkFBbUJwQixTQUFTQyxnQkFBZ0IsQ0FBQztJQUNuRG1CLGlCQUFpQmxCLE9BQU8sQ0FBQ21CLENBQUFBO1FBQ3ZCLElBQUlBLFFBQVFDLFVBQVUsRUFBRTtZQUN0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aHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9BY3Rpb24vY291bnRTYXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpeGVkIGNvdW50U2F2ZS5qcyAtIFJlc29sdmluZyByZWRyYXdJbnRlcnZhbCByZWZlcmVuY2UgZXJyb3Jcbi8vIFNoYXJlZCBmdW5jdGlvbmFsaXR5IGZvciBjb3VudGRvd24gYW5kIGltYWdlIGNhcHR1cmUgcHJvY2Vzc2VzXG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uL0hlbHBlci9zYXZlZmlsZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgYSBjb3VudGRvd24gZWxlbWVudCBhYm92ZSBhIGRvdCBwb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqIEBwYXJhbSB7RE9NUmVjdH0gY2FudmFzUmVjdCAtIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIG9mIHRoZSBjYW52YXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBUaGUgY3JlYXRlZCBjb3VudGRvd24gZWxlbWVudFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ291bnRkb3duRWxlbWVudCA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVDb3VudGRvd25FbGVtZW50XSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtY291bnRkb3duLCAuZm9yY2VkLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwJyk7XG4gIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcblxuICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICBjb25zdCBhYnNvbHV0ZVkgPSBjYW52YXNSZWN0LnRvcCArIHBvc2l0aW9uLnk7XG5cbiAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgIGNvbG9yOiByZWQ7XG4gICAgZm9udC1zaXplOiAzNnB4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgei1pbmRleDogOTk5OTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICB3aWR0aDogNTBweDtcbiAgICBoZWlnaHQ6IDUwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgYDtcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICByZXR1cm4gY291bnRkb3duRWxlbWVudDtcbn07XG5cbi8qKlxuICogRGlzcGxheSBhIHByZXZpZXcgb2YgdGhlIGNhcHR1cmVkIGltYWdlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmVlbkltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHNjcmVlbiBpbWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IHdlYmNhbUltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHdlYmNhbSBpbWFnZVxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50IC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqL1xuY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgcG9pbnQpID0+IHtcbiAgICBpZiAoIXNjcmVlbkltYWdlICYmICF3ZWJjYW1JbWFnZSkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlld3NcbiAgICBjb25zdCBleGlzdGluZ1ByZXZpZXdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcHR1cmUtcHJldmlldy1jb250YWluZXInKTtcbiAgICBleGlzdGluZ1ByZXZpZXdzLmZvckVhY2gocHJldmlldyA9PiB7XG4gICAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHByZXZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBDcmVhdGUgcHJldmlldyBjb250YWluZXJcbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICBgO1xuICAgIFxuICAgIC8vIFNldCBhIGNvbnNpc3RlbnQgaGVpZ2h0IGZvciBib3RoIHByZXZpZXdzXG4gICAgY29uc3QgcHJldmlld0hlaWdodCA9IDI0MDsgLy8gRml4ZWQgaGVpZ2h0IGZvciBib3RoIGltYWdlc1xuICAgIFxuICAgIC8vIEFkZCBzY3JlZW4gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCBzY3JlZW5JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHNjcmVlbkltZy5zcmMgPSBzY3JlZW5JbWFnZTtcbiAgICAgIHNjcmVlbkltZy5hbHQgPSAnU2NyZWVuIENhcHR1cmUnO1xuICAgICAgc2NyZWVuSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGhlaWdodDogJHtwcmV2aWV3SGVpZ2h0fXB4O1xuICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNjcmVlbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgICBzY3JlZW5MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkltZyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc2NyZWVuUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB3ZWJjYW0gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3ZWJjYW1QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWJjYW1JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHdlYmNhbUltZy5zcmMgPSB3ZWJjYW1JbWFnZTtcbiAgICAgIHdlYmNhbUltZy5hbHQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgICAgd2ViY2FtSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGhlaWdodDogJHtwcmV2aWV3SGVpZ2h0fXB4O1xuICAgICAgICB3aWR0aDogYXV0bztcbiAgICAgICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHdlYmNhbUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3ZWJjYW1MYWJlbC50ZXh0Q29udGVudCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgICB3ZWJjYW1MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUltZyk7XG4gICAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQod2ViY2FtUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBwb2ludCBpbmZvXG4gICAgaWYgKHBvaW50KSB7XG4gICAgICBjb25zdCBwb2ludEluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvaW50SW5mby50ZXh0Q29udGVudCA9IHBvaW50LmxhYmVsID8gXG4gICAgICAgIGAke3BvaW50LmxhYmVsfTogeD0ke01hdGgucm91bmQocG9pbnQueCl9LCB5PSR7TWF0aC5yb3VuZChwb2ludC55KX1gIDpcbiAgICAgICAgYFBvaW50OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWA7XG4gICAgICAgIFxuICAgICAgcG9pbnRJbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtNDBweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvaW50SW5mbyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aW1lclxuICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgXG4gICAgLy8gQWRkIHRvIGRvY3VtZW50XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICBcbiAgICAvLyBDb3VudGRvd25cbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwLjNzIGVhc2UnO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICAgIFxuICAgIC8vIFNhZmV0eSBjbGVhbnVwXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9LCA1MDAwKTtcbiAgfTtcbiAgXG4vKipcbiAqIFJ1bnMgYSBjb3VudGRvd24gcHJvY2VzcyB0aGF0IGRpc3BsYXlzIDMtMi0xIGFib3ZlIGEgZG90XG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgZG90XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblN0YXR1c1VwZGF0ZSAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdGF0dXMgbWVzc2FnZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGUgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICovXG5leHBvcnQgY29uc3QgcnVuQ291bnRkb3duID0gYXN5bmMgKHBvc2l0aW9uLCBjYW52YXMsIG9uU3RhdHVzVXBkYXRlLCBvbkNvbXBsZXRlKSA9PiB7XG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICBwcm9jZXNzU3RhdHVzOiBcIkludmFsaWQgZG90IHBvc2l0aW9uXCIsXG4gICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvc2l0aW9uLCBjYW52YXNSZWN0KTtcbiAgXG4gIGlmICghY291bnRkb3duRWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gQ291bnRkb3duIGVsZW1lbnQgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICBsZXQgY291bnQgPSAzO1xuICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG5cbiAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIGRvdCB2aXNpYmxlIGR1cmluZyBjb3VudGRvd25cbiAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAxMiwgZmFsc2UpO1xuICB9LCAyMDApO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ZG93bkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY291bnQtLTtcblxuICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudGRvd25JbnRlcnZhbCk7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ2FwdHVyaW5nIGltYWdlLi4uXCIsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcblxuICAgICAgICAgIC8vIENsZWFyIHRoZSByZWRyYXdJbnRlcnZhbCB3ZSBkZWZpbmVkIGFib3ZlXG4gICAgICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcblxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkNvdW50ZG93blwiLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCA4MDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhc1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQ2FudmFzIC0gV2hldGhlciB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIChkZWZhdWx0OiB0cnVlKVxuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYXdSZWREb3QgPSAoY3R4LCB4LCB5LCByYWRpdXMgPSAxMiwgY2xlYXJDYW52YXMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gIFxuICAvLyBDbGVhciB0aGUgY2FudmFzIGlmIHJlcXVlc3RlZCAoZGVmYXVsdCBiZWhhdmlvcilcbiAgaWYgKGNsZWFyQ2FudmFzKSB7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9XG4gIFxuICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGJyaWdodCByZWQgY29sb3JcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gIGN0eC5maWxsKCk7XG4gIFxuICAvLyBBZGQgZ2xvdyBlZmZlY3QgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gIGN0eC5saW5lV2lkdGggPSAzO1xuICBjdHguc3Ryb2tlKCk7XG4gIFxuICAvLyBBZGQgYSBzZWNvbmQgbGFyZ2VyIGdsb3cgZm9yIGV2ZW4gYmV0dGVyIHZpc2liaWxpdHlcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDYsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjMpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gIGN0eC5zdHJva2UoKTtcbiAgXG4gIHJldHVybiB7IHgsIHkgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDYXB0dXJlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjYXB0dXJlIHJlc3VsdFxuICovXG5leHBvcnQgY29uc3QgY2FwdHVyZUltYWdlcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjYW52YXNSZWYsXG4gICAgcG9zaXRpb24sXG4gICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICB0b2dnbGVUb3BCYXIsXG4gICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gIH0gPSBvcHRpb25zO1xuXG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW2NhcHR1cmVJbWFnZXNdIEludmFsaWQgcG9zaXRpb24gb2JqZWN0OicsIHBvc2l0aW9uKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzPy4oJ0Vycm9yOiBJbnZhbGlkIGNhcHR1cmUgcG9zaXRpb24nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gQ2FsbCB0aGUgY2FwdHVyZUltYWdlc0F0UG9pbnQgZnJvbSBzYXZlZmlsZS5qc1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgIHBvaW50OiBwb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50ZXIsXG4gICAgICBjYW52YXNSZWYsIFxuICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbkltYWdlOiByZXN1bHQ/LnNjcmVlbkltYWdlIHx8ICcnLFxuICAgICAgd2ViY2FtSW1hZ2U6IHJlc3VsdD8ud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICBzdWNjZXNzOiB0cnVlXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc29sZS5lcnJvcignW2NhcHR1cmVJbWFnZXNdIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgIHJldHVybiB7XG4gICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnIubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gZG90IHBvc2l0aW9uIHdpdGhpbiB0aGUgY2FudmFzXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBQYWRkaW5nIGZyb20gdGhlIGVkZ2VzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHt4LCB5fSBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0UmFuZG9tUG9zaXRpb24gPSAoY2FudmFzLCBwYWRkaW5nID0gNDApID0+IHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiB7IHg6IDEwMCwgeTogMTAwIH07IC8vIEZhbGxiYWNrIHBvc2l0aW9uXG4gIFxuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCB8fCA0MDA7ICAvLyBGYWxsYmFjayBpZiB3aWR0aCBpcyAwXG4gIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgfHwgMzAwOyAvLyBGYWxsYmFjayBpZiBoZWlnaHQgaXMgMFxuICBcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICB5OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGVpZ2h0IC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmdcbiAgfTtcbn07XG5cbi8qKlxuICogU3BlY2lhbCBjYWxpYnJhdGlvbiBjYXB0dXJlIGZ1bmN0aW9uIHRoYXQgYXZvaWRzIHByb2JsZW1hdGljIGNvZGUgcGF0aHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWxsIHRoZSBjYWxpYnJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZWQgZGF0YVxuICovXG4vKipcbiAqIFNwZWNpYWwgY2FsaWJyYXRpb24gY2FwdHVyZSBmdW5jdGlvbiB0aGF0IGJlaGF2ZXMgbGlrZSByYW5kb20gZG90IGNhcHR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWxsIHRoZSBjYWxpYnJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZWQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgY2FsaWJyYXRpb25DYXB0dXJlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb2ludCxcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLFxuICAgICAgcG9pbnRJbmRleCxcbiAgICAgIHRvdGFsUG9pbnRzXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FsaWJyYXRpb24gY2FwdHVyZSBmb3IgcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhc1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsIGluIGNhbGlicmF0aW9uQ2FwdHVyZVwiKTtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBVc2UgdGhlIGV4YWN0IHNhbWUgZHJhd2luZyBtZXRob2QgYXMgcmFuZG9tIGRvdHNcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICBcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgQ2FsaWJyYXRpb24gcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgY291bnRkb3duIGVsZW1lbnQgY3JlYXRpb24gbWV0aG9kXG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9pbnQsIGNhbnZhc1JlY3QpO1xuICAgICAgXG4gICAgICBpZiAoIWNvdW50ZG93bkVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY291bnRkb3duIGVsZW1lbnRcIik7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgZm9yIGtlZXBpbmcgdGhlIGRvdCB2aXNpYmxlXG4gICAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCAxMiwgZmFsc2UpO1xuICAgICAgfSwgMjAwKTtcbiAgXG4gICAgICAvLyBSdW4gdGhlIHNhbWUgY291bnRkb3duIGFzIHJhbmRvbSBkb3RcbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBQb2ludCAke3BvaW50SW5kZXggKyAxfS8ke3RvdGFsUG9pbnRzfSAtIGNvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVkcmF3IHRoZSBkb3QgYXQgZWFjaCBzdGVwIHRvIGVuc3VyZSBpdCByZW1haW5zIHZpc2libGVcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIDEyLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbFxuICAgICAgICBpZiAocmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgXG4gICAgICAvLyBVc2UgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIGluc3RlYWQgb2YgZGlyZWN0bHkgY2FsbGluZyBjYXB0dXJlSW1hZ2VzQXRQb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzcyh7XG4gICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgcG9zaXRpb246IHBvaW50LFxuICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzLnByb2Nlc3NTdGF0dXMgfHwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgJiYgdHlwZW9mIHN0YXR1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMucHJvY2Vzc1N0YXR1cyB8fCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICB9KTtcbiAgXG4gICAgICAvLyBFbnN1cmUgcHJvcGVyIHJldHVybiBldmVuIGlmIGNhcHR1cmVSZXN1bHQgaXMgbnVsbFxuICAgICAgY29uc3Qgc2FmZVJlc3VsdCA9IGNhcHR1cmVSZXN1bHQgJiYgdHlwZW9mIGNhcHR1cmVSZXN1bHQgPT09ICdvYmplY3QnIFxuICAgICAgICA/IGNhcHR1cmVSZXN1bHQgXG4gICAgICAgIDogeyBzY3JlZW5JbWFnZTogJycsIHdlYmNhbUltYWdlOiAnJywgc3VjY2VzczogZmFsc2UgfTtcbiAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogc2FmZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHNhZmVSZXN1bHQud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvaW50XG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYWxpYnJhdGlvbkNhcHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQWx3YXlzIHJldHVybiBhIHZhbGlkIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBDb21wbGV0ZSBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvY2VzcyBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgY2FudmFzUmVmLFxuICAgIHBvc2l0aW9uLFxuICAgIGNhcHR1cmVDb3VudGVyLFxuICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgdG9nZ2xlVG9wQmFyLFxuICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgIGNhcHR1cmVGb2xkZXJcbiAgfSA9IG9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWY/LmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBDYW52YXMgcmVmZXJlbmNlIGlzIG51bGxcIik7XG4gICAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6IENhbnZhcyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cbiAgICAvLyBDb3VudGRvd24gYmVmb3JlIGNhcHR1cmVcbiAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNvdW50ZG93bi4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjdXN0b20gY291bnRkb3duIGVsZW1lbnRcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2NhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLnh9cHg7XG4gICAgICB0b3A6ICR7Y2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55IC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG5cbiAgICAvLyBDcmVhdGUgYSByZWRyYXdJbnRlcnZhbCBmb3Iga2VlcGluZyB0aGUgZG90IHZpc2libGVcbiAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICB9LCAyMDApO1xuXG4gICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZWRyYXcgZG90IHRvIGVuc3VyZSBpdCdzIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdG8gY2hlY2ttYXJrXG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJpbmcgaW1hZ2VzLi4uJyxcbiAgICAgICAgY291bnRkb3duVmFsdWU6IFwiQ2FwdHVyaW5nLi4uXCIsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYW5kIGNsZWFyIHJlZHJhd0ludGVydmFsXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0sIDMwMCk7XG5cbiAgICAvLyBVc2UgY2FwdHVyZUltYWdlc0F0UG9pbnQgZnJvbSBzYXZlZmlsZS5qc1xuICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgY2FudmFzUmVmLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgIH0pO1xuXG4gICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIGRvdCBhdCB4PSR7TWF0aC5yb3VuZChwb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKHBvc2l0aW9uLnkpfWApO1xuICAgIH1cblxuICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyZSBjb21wbGV0ZScsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gd2l0aCBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgMjUwMCk7XG5cbiAgICByZXR1cm4gY2FwdHVyZVJlc3VsdDtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBGYXRhbCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgIFxuICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBGYXRhbCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgVG9wQmFyIGlzIHNob3duIGV2ZW4gb24gZXJyb3JcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgIH0sIDE1MDApO1xuICAgIFxuICAgIC8vIFJldHVybiBhIG1pbmltYWwgdmFsaWQgb2JqZWN0IHRvIHByZXZlbnQgbnVsbCByZWZlcmVuY2UgZXJyb3JzXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59OyJdLCJuYW1lcyI6WyJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJ4IiwieSIsImNvbnNvbGUiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicmVtb3ZlIiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsInBvaW50IiwiZXhpc3RpbmdQcmV2aWV3cyIsInByZXZpZXciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJwcmV2aWV3Q29udGFpbmVyIiwicHJldmlld0hlaWdodCIsInNjcmVlblByZXZpZXciLCJzY3JlZW5JbWciLCJzcmMiLCJhbHQiLCJzY3JlZW5MYWJlbCIsInRleHRDb250ZW50Iiwid2ViY2FtUHJldmlldyIsIndlYmNhbUltZyIsIndlYmNhbUxhYmVsIiwicG9pbnRJbmZvIiwibGFiZWwiLCJNYXRoIiwicm91bmQiLCJ0aW1lckVsZW1lbnQiLCJ0aW1lTGVmdCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwib3BhY2l0eSIsInRyYW5zaXRpb24iLCJzZXRUaW1lb3V0IiwidG9GaXhlZCIsInJ1bkNvdW50ZG93biIsImNhbnZhcyIsIm9uU3RhdHVzVXBkYXRlIiwib25Db21wbGV0ZSIsInByb2Nlc3NTdGF0dXMiLCJjb3VudGRvd25WYWx1ZSIsImlzQ2FwdHVyaW5nIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdSZWREb3QiLCJjb3VudCIsInJlZHJhd0ludGVydmFsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjb3VudGRvd25JbnRlcnZhbCIsInJhZGl1cyIsImNsZWFyQ2FudmFzIiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiY2FwdHVyZUltYWdlcyIsIm9wdGlvbnMiLCJjYW52YXNSZWYiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVGb2xkZXIiLCJyZXN1bHQiLCJjYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzdWNjZXNzIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxpYnJhdGlvbkNhcHR1cmUiLCJwb2ludEluZGV4IiwidG90YWxQb2ludHMiLCJsb2ciLCJjdXJyZW50IiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsInN0YXR1cyIsInNhZmVSZXN1bHQiLCJ3aW5kb3ciXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js\n"));

/***/ })

});