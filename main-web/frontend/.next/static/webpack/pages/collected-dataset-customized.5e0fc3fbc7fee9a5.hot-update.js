"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Initialize canvas on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const initializeCanvas = {\n                \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                    // Remove any existing canvas\n                    const existingCanvas = document.querySelector('.tracking-canvas');\n                    if (existingCanvas) {\n                        existingCanvas.remove();\n                    }\n                    // Create new canvas\n                    const canvas = document.createElement('canvas');\n                    canvas.className = 'tracking-canvas';\n                    canvas.id = 'tracking-canvas';\n                    canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        opacity: 0;\\n        pointer-events: none;\\n        z-index: 5;\\n      \";\n                    // Set canvas dimensions\n                    canvas.width = window.innerWidth;\n                    canvas.height = window.innerHeight;\n                    // Add canvas to body\n                    document.body.appendChild(canvas);\n                    // Store reference\n                    canvasRef.current = canvas;\n                    if (true) {\n                        window.whiteScreenCanvas = canvas;\n                    }\n                    // Initialize with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Add resize handler\n                    const handleResize = {\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\": ()=>{\n                            canvas.width = window.innerWidth;\n                            canvas.height = window.innerHeight;\n                            ctx.fillStyle = 'white';\n                            ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        }\n                    }[\"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\"];\n                    window.addEventListener('resize', handleResize);\n                    return ({\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                            window.removeEventListener('resize', handleResize);\n                            if (canvas.parentNode) {\n                                canvas.parentNode.removeChild(canvas);\n                            }\n                        }\n                    })[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n                }\n            }[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n            const cleanup = initializeCanvas();\n            return cleanup;\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas = ()=>{\n        // First, try to get existing canvas from ref\n        if (canvasRef.current && document.contains(canvasRef.current)) {\n            return canvasRef.current;\n        }\n        // Try to get from window global\n        if ( true && window.whiteScreenCanvas && document.contains(window.whiteScreenCanvas)) {\n            canvasRef.current = window.whiteScreenCanvas;\n            return window.whiteScreenCanvas;\n        }\n        // Try to find existing canvas in DOM\n        let existingCanvas = document.querySelector('#tracking-canvas') || document.querySelector('.tracking-canvas') || document.querySelector('canvas[data-type=\"tracking\"]');\n        if (existingCanvas && document.contains(existingCanvas)) {\n            canvasRef.current = existingCanvas;\n            window.whiteScreenCanvas = existingCanvas;\n            return existingCanvas;\n        }\n        // Create new canvas if none found\n        console.log('Creating new canvas...');\n        const canvas = document.createElement('canvas');\n        canvas.className = 'tracking-canvas';\n        canvas.id = 'tracking-canvas';\n        canvas.setAttribute('data-type', 'tracking');\n        // Set initial style for regular use (not fullscreen)\n        canvas.style.cssText = \"\\n      position: relative;\\n      width: 100%;\\n      height: 400px;\\n      background-color: white;\\n      border: 1px solid #ccc;\\n      display: block;\\n    \";\n        // Set initial dimensions\n        canvas.width = 800;\n        canvas.height = 400;\n        // Initialize with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Find appropriate container or append to body\n        let container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.querySelector('.video-container') || document.body;\n        container.appendChild(canvas);\n        // Store references\n        canvasRef.current = canvas;\n        window.whiteScreenCanvas = canvas;\n        // Add resize handler for when canvas is in regular mode\n        const handleResize = ()=>{\n            if (canvas.style.position !== 'fixed') {\n                const parent = canvas.parentElement;\n                if (parent && parent !== document.body) {\n                    canvas.width = parent.clientWidth || 800;\n                    canvas.height = parent.clientHeight || 400;\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                }\n            }\n        };\n        window.addEventListener('resize', handleResize);\n        // Store cleanup function\n        canvas._cleanup = ()=>{\n            window.removeEventListener('resize', handleResize);\n        };\n        console.log('Canvas created successfully:', canvas);\n        return canvas;\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas)=>{\n        if (!canvas || !canvas._originalState) return;\n        const original = canvas._originalState;\n        try {\n            // Restore to original parent\n            if (original.parent && document.contains(original.parent)) {\n                original.parent.appendChild(canvas);\n            } else {\n                // Fallback to a container if original parent is gone\n                const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n                container.appendChild(canvas);\n            }\n            // Restore styles\n            canvas.style.position = original.position || 'relative';\n            canvas.style.top = original.top || '';\n            canvas.style.left = original.left || '';\n            canvas.style.width = original.width || '100%';\n            canvas.style.height = original.height || '400px';\n            canvas.style.zIndex = original.zIndex || '';\n            canvas.style.backgroundColor = 'white';\n            // Restore dimensions\n            canvas.width = original.canvasWidth || 800;\n            canvas.height = original.canvasHeight || 400;\n            // Clear with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Clear the saved state\n            delete canvas._originalState;\n        } catch (error) {\n            console.error('Error restoring canvas:', error);\n            // Fallback: just clear the canvas\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ // Modified handleDotProcess function with improved dot and countdown alignment\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get canvas reference with retries\n            let canvas = null;\n            let retryCount = 0;\n            const maxRetries = 3;\n            while(!canvas && retryCount < maxRetries){\n                canvas = getMainCanvas();\n                if (!canvas) {\n                    console.warn(\"Canvas not found, retry \".concat(retryCount + 1, \"/\").concat(maxRetries));\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    retryCount++;\n                }\n            }\n            if (!canvas) {\n                throw new Error(\"Canvas not available after multiple retries\");\n            }\n            // Save original state for restoration\n            const originalParent = canvas.parentElement;\n            const originalStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Prepare canvas for fullscreen display\n            document.body.appendChild(canvas);\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            // Clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            let keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            // Important: Position the countdown centered directly over the dot\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Clear redraw interval\n            clearInterval(keepDotVisibleInterval);\n            // Restore canvas to original state\n            if (originalParent && canvas.parentElement !== originalParent) {\n                originalParent.appendChild(canvas);\n            }\n            canvas.style.position = originalStyle.position || '';\n            canvas.style.top = originalStyle.top || '';\n            canvas.style.left = originalStyle.left || '';\n            canvas.style.width = originalStyle.width || '100%';\n            canvas.style.height = originalStyle.height || '100%';\n            canvas.style.zIndex = originalStyle.zIndex || '';\n            // Reset dimensions\n            if (originalParent) {\n                canvas.width = originalParent.clientWidth || 800;\n                canvas.height = originalParent.clientHeight || 600;\n            }\n            // Clear canvas\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2000);\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            // Show TopBar again if there's an error\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"✓\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            // Restore canvas to original parent and styling - Only if canvas was successfully initialized\n            if (canvas) {\n                try {\n                    // Try to find original parent\n                    if (originalCanvasParent && canvas.parentElement !== originalCanvasParent) {\n                        originalCanvasParent.appendChild(canvas);\n                    } else if (!originalCanvasParent) {\n                        // Fallback to looking for a container element\n                        const possibleParent = document.querySelector('.canvas-container');\n                        if (possibleParent && canvas.parentElement !== possibleParent) {\n                            possibleParent.appendChild(canvas);\n                        }\n                    }\n                    // Restore styling\n                    canvas.style.position = originalCanvasStyle.position || '';\n                    canvas.style.top = originalCanvasStyle.top || '';\n                    canvas.style.left = originalCanvasStyle.left || '';\n                    canvas.style.width = originalCanvasStyle.width || '100%';\n                    canvas.style.height = originalCanvasStyle.height || '100%';\n                    canvas.style.zIndex = originalCanvasStyle.zIndex || '';\n                    // Reset dimensions based on parent\n                    const parent = canvas.parentElement;\n                    if (parent) {\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                    } else {\n                        canvas.width = 800;\n                        canvas.height = 600;\n                    }\n                    // Clear canvas with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas restored to original state\");\n                } catch (e) {\n                    console.error(\"Error restoring canvas:\", e);\n                }\n            }\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        // Use the consolidated function with random position\n        await handleDotProcess({\n            useRandomPosition: true,\n            onStatusUpdate: (status)=>{\n                if (status.processStatus) setProcessStatus(status.processStatus);\n                if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n            },\n            toggleTopBar: (show)=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', show);\n                }\n            },\n            triggerCameraAccess,\n            setIsCapturing,\n            captureCount,\n            setCaptureCount: setCaptureCount,\n            postCountdownDelay: 1000\n        });\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        if (!canvas) return null;\n        // Save original state if not already saved\n        if (!canvas._originalState) {\n            canvas._originalState = {\n                parent: canvas.parentElement,\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex,\n                canvasWidth: canvas.width,\n                canvasHeight: canvas.height\n            };\n        }\n        // Move to body and make fullscreen\n        document.body.appendChild(canvas);\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '10';\n        canvas.style.backgroundColor = 'white';\n        // Set canvas dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        return canvas;\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        clearCanvas();\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1467,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1466,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1471,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1470,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1502,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1512,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1530,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1543,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1522,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1492,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1477,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1464,\n        columnNumber: 5\n    }, undefined);\n}, \"JKWsncWoQfU/JEIcMyyXupasNlE=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1565,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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RCw4REFBQ0M7NEJBQ0NoTyxXQUFVOzRCQUNWaUcsT0FBTztnQ0FDTDRILFFBQVE7Z0NBQ1JDLFVBQVU7Z0NBQ1ZHLFlBQVk7NEJBQ2Q7c0NBQ0Q7Ozs7OztzQ0FHRCw4REFBQy9NOzRCQUNDbEIsV0FBVTs0QkFDVmlHLE9BQU87Z0NBQ0xxSCxTQUFTO2dDQUNUQyxnQkFBZ0I7Z0NBQ2hCVyxLQUFLOzRCQUNQOzs4Q0FFQSw4REFBQ2pOO29DQUNDakMsU0FBUzBJO29DQUNUMUgsV0FBVTtvQ0FDVmlHLE9BQU87d0NBQ0x5SCxTQUFTO3dDQUNUekYsaUJBQWlCO3dDQUNqQmtHLFFBQVE7d0NBQ1JWLGNBQWM7d0NBQ2RXLFFBQVE7b0NBQ1Y7OENBQ0Q7Ozs7Ozs4Q0FHRCw4REFBQ25OO29DQUNDakMsU0FBU3lJO29DQUNUekgsV0FBVTtvQ0FDVmlHLE9BQU87d0NBQ0x5SCxTQUFTO3dDQUNUekYsaUJBQWlCO3dDQUNqQm9HLE9BQU87d0NBQ1BGLFFBQVE7d0NBQ1JWLGNBQWM7d0NBQ2RXLFFBQVE7b0NBQ1Y7OENBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU2Y7O1FBdDdDaUJwUSxrREFBU0E7UUFDYUMsNERBQWdCQTs7O01BRmpEa0Q7QUF3N0NOLE1BQU1tTixvQkFBb0I5USxtREFBT0EsT0FBQyxJQUFNc0wsUUFBUUMsT0FBTyxlQUNyRDFMLGlEQUFVQSxDQUFDLENBQUNrUixPQUFPbk4sb0JBQVEsOERBQUNEO1lBQXdCLEdBQUdvTixLQUFLO1lBQUVuTixLQUFLQTs7Ozs7eUJBQ2xFO0lBQUVvTixLQUFLO0FBQU07O0FBQ2hCLG9EQUFvRDtBQUNwRCxvR0FBb0c7QUFFcEcsK0JBQStCO0FBQ2hCLFNBQVNDO0lBQ3RCLE9BQU8sTUFBTSw4REFBOEQ7QUFDN0U7TUFGd0JBO0FBSW1CIiwic291cmNlcyI6WyIvYXBwL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJztcbmltcG9ydCB7IFxuICBzaG93Q2FwdHVyZVByZXZpZXcsIFxuICBkcmF3UmVkRG90LCBcbiAgZ2V0UmFuZG9tUG9zaXRpb24sXG4gIGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQsXG4gIHJ1bkNvdW50ZG93blxufSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL2NvdW50U2F2ZSc7XG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9IZWxwZXIvc2F2ZWZpbGUnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xuaW1wb3J0IHsgdXNlQWRtaW5TZXR0aW5ncyB9IGZyb20gJy4vYWRtaW5TZXR0aW5ncyc7XG5cbi8vIEFkZCBkZWVwIGNvbXBhcmlzb24gdXRpbGl0eVxuY29uc3QgaXNFcXVhbCA9IChvYmoxLCBvYmoyKSA9PiB7XG4gIGlmIChvYmoxID09PSBvYmoyKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqMiAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgPT09IG51bGwgfHwgb2JqMiA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgXG4gIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgcmV0dXJuIGtleXMxLmV2ZXJ5KGtleSA9PiBcbiAgICBrZXlzMi5pbmNsdWRlcyhrZXkpICYmIGlzRXF1YWwob2JqMVtrZXldLCBvYmoyW2tleV0pXG4gICk7XG59O1xuXG4vLyBDcmVhdGUgYSBiYXNpYyBBY3Rpb25CdXR0b24gY29tcG9uZW50IHdpdGggb3B0aW1pemF0aW9uXG5jb25zdCBBY3Rpb25CdXR0b24gPSAoeyB0ZXh0LCBhYmJyZXZpYXRlZFRleHQsIG9uQ2xpY2ssIGN1c3RvbUNsYXNzID0gJycsIGRpc2FibGVkID0gZmFsc2UsIGFjdGl2ZSA9IGZhbHNlIH0pID0+IHtcbiAgY29uc3QgW2lzQWJicmV2aWF0ZWQsIHNldElzQWJicmV2aWF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7IHNldHRpbmdzIH0gPSB1c2VBZG1pblNldHRpbmdzKCk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCdkZWZhdWx0Jyk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY2FwdHVyZUNvdW50ZXIsIHNldENhcHR1cmVDb3VudGVyXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG5cbiAgLy8gTWVtb2l6ZSBidXR0b24gcHJvcHMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzXG4gIGNvbnN0IGJ1dHRvblByb3BzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGNsYXNzTmFtZTogYGFjdGlvbi1idXR0b24gJHtjdXN0b21DbGFzc30gJHtpc0FiYnJldmlhdGVkID8gJ2FiYnJldmlhdGVkJyA6ICcnfSAke2FjdGl2ZSA/ICdhY3RpdmUnIDogJyd9YCxcbiAgICBvbkNsaWNrLFxuICAgIGRpc2FibGVkLFxuICAgIHRpdGxlOiB0ZXh0XG4gIH0pLCBbY3VzdG9tQ2xhc3MsIGlzQWJicmV2aWF0ZWQsIGFjdGl2ZSwgb25DbGljaywgZGlzYWJsZWQsIHRleHRdKTtcblxuICAvLyBDaGVjayB3aW5kb3cgc2l6ZSBhbmQgc2V0IGFiYnJldmlhdGVkIG1vZGUgd2l0aCBkZWJvdW5jZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgc2V0SXNBYmJyZXZpYXRlZCh3aWR0aCA8IDc2OCk7XG4gICAgICB9LCAxMDApO1xuICAgIH07XG4gICAgXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgaGFuZGxlUmVzaXplKCk7IC8vIEluaXRpYWwgY2FsbFxuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBBZGQgZWZmZWN0IHRvIGxpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzIHdpdGggb3B0aW1pemF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBpZiAobmV3VXNlcklkICE9PSBjdXJyZW50VXNlcklkKSB7XG4gICAgICAgICAgc2V0Q3VycmVudFVzZXJJZChuZXdVc2VySWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIHJldHVybiAoXG4gICAgPGJ1dHRvbiB7Li4uYnV0dG9uUHJvcHN9PlxuICAgICAge2lzQWJicmV2aWF0ZWQgPyBhYmJyZXZpYXRlZFRleHQgOiB0ZXh0fVxuICAgICAge3Byb2Nlc3NTdGF0dXMgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb2Nlc3Mtc3RhdHVzXCI+XG4gICAgICAgICAge3Byb2Nlc3NTdGF0dXN9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2J1dHRvbj5cbiAgKTtcbn07XG5cbi8vIENyZWF0ZSB0aGUgQWN0aW9uQnV0dG9uR3JvdXAgY29tcG9uZW50IHdpdGggY2xpZW50LXNpZGUgb25seSByZW5kZXJpbmcgYW5kIG9wdGltaXphdGlvblxuY29uc3QgQWN0aW9uQnV0dG9uR3JvdXBJbm5lciA9IGZvcndhcmRSZWYoKHsgdHJpZ2dlckNhbWVyYUFjY2VzcywgaXNDb21wYWN0TW9kZSwgb25BY3Rpb25DbGljayB9LCByZWYpID0+IHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IHsgc2V0dGluZ3MsIHVwZGF0ZVNldHRpbmdzIH0gPSB1c2VBZG1pblNldHRpbmdzKHJlZik7XG4gIFxuICAvLyBTdGF0ZSBmb3IgYnV0dG9uIGFjdGlvbnNcbiAgY29uc3QgW3JhbmRvbVRpbWVzLCBzZXRSYW5kb21UaW1lc10gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2RlbGF5U2Vjb25kcywgc2V0RGVsYXlTZWNvbmRzXSA9IHVzZVN0YXRlKDMpO1xuICBjb25zdCBjYW52YXNSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtwcm9jZXNzU3RhdHVzLCBzZXRQcm9jZXNzU3RhdHVzXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2NvdW50ZG93blZhbHVlLCBzZXRDb3VudGRvd25WYWx1ZV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2N1cnJlbnREb3QsIHNldEN1cnJlbnREb3RdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjYWxpYnJhdGlvblBvaW50cywgc2V0Q2FsaWJyYXRpb25Qb2ludHNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbcmVtYWluaW5nQ2FwdHVyZXMsIHNldFJlbWFpbmluZ0NhcHR1cmVzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbc2hvd0NhbnZhcywgc2V0U2hvd0NhbnZhc10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgXG4gIC8vIFRyYWNrIHRoZSBjYXB0dXJlIGNvdW50XG4gIGNvbnN0IFtjYWxpYnJhdGlvbkhhbmRsZXIsIHNldENhbGlicmF0aW9uSGFuZGxlcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudCwgc2V0Q2FwdHVyZUNvdW50XSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIFRvZ2dsZSBzdGF0ZXNcbiAgY29uc3QgW3Nob3dIZWFkUG9zZSwgc2V0U2hvd0hlYWRQb3NlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dCb3VuZGluZ0JveCwgc2V0U2hvd0JvdW5kaW5nQm94XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dNYXNrLCBzZXRTaG93TWFza10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGFyYW1ldGVycywgc2V0U2hvd1BhcmFtZXRlcnNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNDYW1lcmFBY3RpdmUsIHNldElzQ2FtZXJhQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQZXJtaXNzaW9uUG9wdXAsIHNldFNob3dQZXJtaXNzaW9uUG9wdXBdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuXG4gIC8vIEFkZCBjYWNoZSBmb3Igc2V0dGluZ3NcbiAgY29uc3Qgc2V0dGluZ3NDYWNoZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuICBjb25zdCBsYXN0U2V0dGluZ3NVcGRhdGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcblxuICBcbiAgLy8gT3B0aW1pemUgc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdKSB7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldChjdXJyZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc0VxdWFsKGNhY2hlZFNldHRpbmdzLCB1c2VyU2V0dGluZ3MpKSB7XG4gICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgbmV3IHVzZXJcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzW25ld1VzZXJJZF0pIHtcbiAgICAgICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tuZXdVc2VySWRdO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzX3NldF9yYW5kb20sIGRlbGF5X3NldF9yYW5kb20gfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGlmICh0aW1lc19zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVzID0gTnVtYmVyKHRpbWVzX3NldF9yYW5kb20pIHx8IDE7XG4gICAgICAgICAgICBzZXRSYW5kb21UaW1lcyhuZXdUaW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWxheV9zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlbGF5ID0gTnVtYmVyKGRlbGF5X3NldF9yYW5kb20pIHx8IDM7XG4gICAgICAgICAgICBzZXREZWxheVNlY29uZHMobmV3RGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTWFrZSBmdW5jdGlvbnMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBhcyBhIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zID0ge1xuICAgICAgICBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSxcbiAgICAgICAgaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAgICAgICBoYW5kbGVDbGVhckFsbFxuICAgICAgfTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9uIGZ1bmN0aW9ucyBleHBvc2VkIHRvIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucztcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGdldCBjb250cm9sIHZhbHVlcyBmcm9tIFRvcEJhclxuICAgIGNvbnN0IHVwZGF0ZUNvbnRyb2xWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIHRpbWUgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSBwYXJzZUludCh0aW1lSW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTih0aW1lVmFsdWUpICYmIHRpbWVWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgcmFuZG9tVGltZXMgdG86JywgdGltZVZhbHVlKTtcbiAgICAgICAgICBzZXRSYW5kb21UaW1lcyh0aW1lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgZGVsYXkgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBjb25zdCBkZWxheVZhbHVlID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKGRlbGF5VmFsdWUpICYmIGRlbGF5VmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGRlbGF5U2Vjb25kcyB0bzonLCBkZWxheVZhbHVlKTtcbiAgICAgICAgICBzZXREZWxheVNlY29uZHMoZGVsYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGNvbnRyb2wgaW5wdXRzXG4gICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgIFxuICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIC8vIEluaXRpYWwgdXBkYXRlXG4gICAgdXBkYXRlQ29udHJvbFZhbHVlcygpO1xuICAgIFxuICAgIC8vIENsZWFudXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICAvLyBJbml0aWFsaXplIGNhbnZhcyBvbiBjb21wb25lbnQgbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKCkgPT4ge1xuICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjYW52YXNcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRyYWNraW5nLWNhbnZhcycpO1xuICAgICAgaWYgKGV4aXN0aW5nQ2FudmFzKSB7XG4gICAgICAgIGV4aXN0aW5nQ2FudmFzLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IGNhbnZhc1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMuY2xhc3NOYW1lID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICBjYW52YXMuaWQgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICAgIGNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgei1pbmRleDogNTtcbiAgICAgIGA7XG5cbiAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAvLyBBZGQgY2FudmFzIHRvIGJvZHlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlXG4gICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhcztcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIC8vIEFkZCByZXNpemUgaGFuZGxlclxuICAgICAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgICBpZiAoY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBjbGVhbnVwID0gaW5pdGlhbGl6ZUNhbnZhcygpO1xuICAgIHJldHVybiBjbGVhbnVwO1xuICB9LCBbXSk7XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWFpbiBjYW52YXMgLSBpbXByb3ZlZCB0byBiZSBtb3JlIHJlbGlhYmxlXG4gIGNvbnN0IGdldE1haW5DYW52YXMgPSAoKSA9PiB7XG4gICAgLy8gRmlyc3QsIHRyeSB0byBnZXQgZXhpc3RpbmcgY2FudmFzIGZyb20gcmVmXG4gICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50ICYmIGRvY3VtZW50LmNvbnRhaW5zKGNhbnZhc1JlZi5jdXJyZW50KSkge1xuICAgICAgcmV0dXJuIGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIH1cbiAgICBcbiAgICAvLyBUcnkgdG8gZ2V0IGZyb20gd2luZG93IGdsb2JhbFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgJiYgZG9jdW1lbnQuY29udGFpbnMod2luZG93LndoaXRlU2NyZWVuQ2FudmFzKSkge1xuICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgICByZXR1cm4gd2luZG93LndoaXRlU2NyZWVuQ2FudmFzO1xuICAgIH1cblxuICAgIC8vIFRyeSB0byBmaW5kIGV4aXN0aW5nIGNhbnZhcyBpbiBET01cbiAgICBsZXQgZXhpc3RpbmdDYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRyYWNraW5nLWNhbnZhcycpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzW2RhdGEtdHlwZT1cInRyYWNraW5nXCJdJyk7XG4gICAgXG4gICAgaWYgKGV4aXN0aW5nQ2FudmFzICYmIGRvY3VtZW50LmNvbnRhaW5zKGV4aXN0aW5nQ2FudmFzKSkge1xuICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSBleGlzdGluZ0NhbnZhcztcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGV4aXN0aW5nQ2FudmFzO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nQ2FudmFzO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBuZXcgY2FudmFzIGlmIG5vbmUgZm91bmRcbiAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgbmV3IGNhbnZhcy4uLicpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5jbGFzc05hbWUgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICBjYW52YXMuaWQgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICBjYW52YXMuc2V0QXR0cmlidXRlKCdkYXRhLXR5cGUnLCAndHJhY2tpbmcnKTtcbiAgICBcbiAgICAvLyBTZXQgaW5pdGlhbCBzdHlsZSBmb3IgcmVndWxhciB1c2UgKG5vdCBmdWxsc2NyZWVuKVxuICAgIGNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDQwMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2NjO1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgYDtcbiAgICBcbiAgICAvLyBTZXQgaW5pdGlhbCBkaW1lbnNpb25zXG4gICAgY2FudmFzLndpZHRoID0gODAwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSA0MDA7XG4gICAgXG4gICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBGaW5kIGFwcHJvcHJpYXRlIGNvbnRhaW5lciBvciBhcHBlbmQgdG8gYm9keVxuICAgIGxldCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnZpZGVvLWNvbnRhaW5lcicpIHx8XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgXG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgXG4gICAgLy8gU3RvcmUgcmVmZXJlbmNlc1xuICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzO1xuICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICBcbiAgICAvLyBBZGQgcmVzaXplIGhhbmRsZXIgZm9yIHdoZW4gY2FudmFzIGlzIGluIHJlZ3VsYXIgbW9kZVxuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmIChjYW52YXMuc3R5bGUucG9zaXRpb24gIT09ICdmaXhlZCcpIHsgLy8gT25seSByZXNpemUgaWYgbm90IGluIGZ1bGxzY3JlZW5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA0MDA7XG4gICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIFxuICAgIC8vIFN0b3JlIGNsZWFudXAgZnVuY3Rpb25cbiAgICBjYW52YXMuX2NsZWFudXAgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICB9O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDYW52YXMgY3JlYXRlZCBzdWNjZXNzZnVsbHk6JywgY2FudmFzKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBpZiAodHJpZ2dlckNhbWVyYUFjY2Vzcykge1xuICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlciB0byBjYW5jZWwgcGVybWlzc2lvbiBwb3B1cFxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uRGVuaWVkID0gKCkgPT4ge1xuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byByZXN0b3JlIHRoZSBjYW52YXMgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGluZ1xuICBjb25zdCByZXN0b3JlQ2FudmFzID0gKGNhbnZhcykgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFjYW52YXMuX29yaWdpbmFsU3RhdGUpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBvcmlnaW5hbCA9IGNhbnZhcy5fb3JpZ2luYWxTdGF0ZTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gUmVzdG9yZSB0byBvcmlnaW5hbCBwYXJlbnRcbiAgICAgIGlmIChvcmlnaW5hbC5wYXJlbnQgJiYgZG9jdW1lbnQuY29udGFpbnMob3JpZ2luYWwucGFyZW50KSkge1xuICAgICAgICBvcmlnaW5hbC5wYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIGEgY29udGFpbmVyIGlmIG9yaWdpbmFsIHBhcmVudCBpcyBnb25lXG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIHN0eWxlc1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWwucG9zaXRpb24gfHwgJ3JlbGF0aXZlJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbC50b3AgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsLmxlZnQgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbC53aWR0aCB8fCAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWwuaGVpZ2h0IHx8ICc0MDBweCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gb3JpZ2luYWwuekluZGV4IHx8ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgZGltZW5zaW9uc1xuICAgICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWwuY2FudmFzV2lkdGggfHwgODAwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IG9yaWdpbmFsLmNhbnZhc0hlaWdodCB8fCA0MDA7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciB0aGUgc2F2ZWQgc3RhdGVcbiAgICAgIGRlbGV0ZSBjYW52YXMuX29yaWdpbmFsU3RhdGU7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVzdG9yaW5nIGNhbnZhczonLCBlcnJvcik7XG4gICAgICAvLyBGYWxsYmFjazoganVzdCBjbGVhciB0aGUgY2FudmFzXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICB9O1xuXG5cbiAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICBjb25zdCBjbGVhckNhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCBmb3IgY2xlYXJpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICB9O1xuICAvLyBBZGQgdGhpcyBmdW5jdGlvbiB0byBhY3Rpb25CdXR0b24uanNcblxuICAvKipcbiAgICogQ29uc29saWRhdGVkIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgZW50aXJlIGRvdCBwcm9jZXNzOiBkcmF3aW5nLCBjb3VudGRvd24sIGNhcHR1cmUsIGFuZCBwcmV2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IGNvb3JkaW5hdGVzIHdoZXJlIHRvIGRyYXcgdGhlIGRvdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU3RhdHVzVXBkYXRlIC0gQ2FsbGJhY2sgZm9yIHN0YXR1cyB1cGRhdGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRyaWdnZXJDYW1lcmFBY2Nlc3MgLSBGdW5jdGlvbiB0byBlbnN1cmUgY2FtZXJhIGlzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldElzQ2FwdHVyaW5nIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmluZyBzdGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnQgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudCAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy51c2VSYW5kb21Qb3NpdGlvbiAtIFdoZXRoZXIgdG8gZ2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZSBkYXRhXG4gICAqL1xuICAvLyBNb2RpZmllZCBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggaW1wcm92ZWQgZG90IGFuZCBjb3VudGRvd24gYWxpZ25tZW50XG4gIGNvbnN0IGhhbmRsZURvdFByb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICB1c2VSYW5kb21Qb3NpdGlvbiA9IGZhbHNlLFxuICAgICAgcG9zdENvdW50ZG93bkRlbGF5ID0gNTAwIFxuICAgIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHNob3dpbmcgdGhlIGRvdFxuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZVxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiB1c2VSYW5kb21Qb3NpdGlvbiA/ICdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nIDogJ1N0YXJ0aW5nIGRvdCBwcm9jZXNzLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlIHdpdGggcmV0cmllc1xuICAgICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICAgIFxuICAgICAgd2hpbGUgKCFjYW52YXMgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FudmFzIG5vdCBmb3VuZCwgcmV0cnkgJHtyZXRyeUNvdW50ICsgMX0vJHttYXhSZXRyaWVzfWApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllc1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZSBmb3IgcmVzdG9yYXRpb25cbiAgICAgIGNvbnN0IG9yaWdpbmFsUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBvcmlnaW5hbFN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcblxuICAgICAgLy8gUHJlcGFyZSBjYW52YXMgZm9yIGZ1bGxzY3JlZW4gZGlzcGxheVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgXG4gICAgICAvLyBTZXQgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3cgZXhhY3RseVxuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgICAgY29uc3QgZG90UG9zaXRpb24gPSB1c2VSYW5kb21Qb3NpdGlvbiBcbiAgICAgICAgPyBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKSBcbiAgICAgICAgOiBwb3NpdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKCFkb3RQb3NpdGlvbiB8fCB0eXBlb2YgZG90UG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDEyO1xuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSByZWRyYXcgaW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICBsZXQga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgfSwgNTApOyAgLy8gTW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJpbGl0eVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBjb3VudGRvd24gZWxlbWVudCBkaXJlY3RseSBvbiB0b3Agb2YgdGhlIGRvdFxuICAgICAgLy8gSW1wb3J0YW50OiBQb3NpdGlvbiB0aGUgY291bnRkb3duIGNlbnRlcmVkIGRpcmVjdGx5IG92ZXIgdGhlIGRvdFxuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgbGVmdDogJHtkb3RQb3NpdGlvbi54fXB4O1xuICAgICAgICB0b3A6ICR7ZG90UG9zaXRpb24ueX1weDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRyYXcgdGhlIGRvdCBmb3IgcmVsaWFiaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkaXRpb25hbCByZWRyYXcgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGFmdGVyIGNvdW50ZG93biBjb21wbGV0ZXNcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBwb3N0Q291bnRkb3duRGVsYXkpKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICBwb2ludDogZG90UG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50LFxuICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgIGNsZWFySW50ZXJ2YWwoa2VlcERvdFZpc2libGVJbnRlcnZhbCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgY2FudmFzIHRvIG9yaWdpbmFsIHN0YXRlXG4gICAgICBpZiAob3JpZ2luYWxQYXJlbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IG9yaWdpbmFsUGFyZW50KSB7XG4gICAgICAgIG9yaWdpbmFsUGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsU3R5bGUucG9zaXRpb24gfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gb3JpZ2luYWxTdHlsZS50b3AgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsU3R5bGUubGVmdCB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9yaWdpbmFsU3R5bGUud2lkdGggfHwgJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsU3R5bGUuaGVpZ2h0IHx8ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBvcmlnaW5hbFN0eWxlLnpJbmRleCB8fCAnJztcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgZGltZW5zaW9uc1xuICAgICAgaWYgKG9yaWdpbmFsUGFyZW50KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJlIGNvbXBsZXRlZCcsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjAwMCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZVJlc3VsdFxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlRG90UHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBEZWNsYXJlIHRoZXNlIHZhcmlhYmxlcyBPVVRTSURFIHRoZSB0cnkgYmxvY2tcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBsZXQgb3JpZ2luYWxDYW52YXNQYXJlbnQgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1N0eWxlID0ge307XG4gICAgbGV0IHN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0U2hvd0NhbnZhcyh0cnVlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoXCJTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLlwiKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgVUkgdXBkYXRlcyB0byB0YWtlIGVmZmVjdFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FudmFzIHJlZmVyZW5jZVxuICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIkVycm9yOiBDYW52YXMgbm90IGZvdW5kXCIpO1xuICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBwYXJlbnQgYW5kIHN0eWxlXG4gICAgICBvcmlnaW5hbENhbnZhc1BhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgb3JpZ2luYWxDYW52YXNTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgdG9wOiBjYW52YXMuc3R5bGUudG9wLFxuICAgICAgICBsZWZ0OiBjYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICB6SW5kZXg6IGNhbnZhcy5zdHlsZS56SW5kZXhcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIE1vdmUgY2FudmFzIHRvIGJvZHkgZm9yIG1heGltdW0gcmVsaWFiaWxpdHlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBjYW52YXMgZnVsbHNjcmVlbiB3aXRoIGZpeGVkIHBvc2l0aW9uaW5nXG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgICBcbiAgICAgIC8vIFNldCBkaW1lbnNpb25zIHRvIG1hdGNoIHdpbmRvdyBleGFjdGx5XG4gICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHNldCB0byBmdWxsc2NyZWVuOiAke2NhbnZhc1dpZHRofXgke2NhbnZhc0hlaWdodH1gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNvbnRleHRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cyBiYXNlZCBvbiB0aGUgY2FudmFzIHNpemVcbiAgICAgIGNvbnN0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cycpO1xuICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIFxuICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN0YXR1c0luZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbjogSW5pdGlhbGl6aW5nLi4uJztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGlzcGxheXNcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBjYW52YXMgaWYgZGltZW5zaW9ucyBjaGFuZ2VkXG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FudmFzIGRpbWVuc2lvbnMgY2hhbmdlZC4gUmVzZXR0aW5nIHRvICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYm9keSBhbmQgaW4gZnVsbHNjcmVlbiBtb2RlXG4gICAgICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgICAgY29uc3QgcmFkaXVzID0gMTQ7IC8vIFNsaWdodGx5IGxhcmdlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBmdW5jdGlvbiBmb3IgdGhpcyBwb2ludFxuICAgICAgICBjb25zdCByZWRyYXdDdXJyZW50RG90ID0gKCkgPT4ge1xuICAgICAgICAgIC8vIFZlcmlmeSBjYW52YXMgZGltZW5zaW9ucyBhbmQgcGFyZW50XG4gICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5XG4gICAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZHJhdyBkb3Qgd2l0aG91dCBjbGVhcmluZ1xuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHJlZHJhdyBpbnRlcnZhbCAtIG1vcmUgZnJlcXVlbnQgdXBkYXRlcyBmb3IgcmVsaWFibGUgZG90IHZpc2liaWxpdHlcbiAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwocmVkcmF3Q3VycmVudERvdCwgNTApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nOyAvLyBDb25zaXN0ZW50IGNsYXNzIG5hbWVcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICBsZWZ0OiAke3BvaW50Lnh9cHg7XG4gICAgICAgICAgdG9wOiAke3BvaW50LnkgLSA2MH1weDtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofTogQ291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVkcmF3IGFnYWluIGhhbGZ3YXkgdGhyb3VnaCB0aGUgd2FpdCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGFmdGVyIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcblxuICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFudWFsIGZvcmNlIHJlZHJhdyBvbmUgbW9yZSB0aW1lIGp1c3QgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICB9XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgcmVkcmF3IGludGVydmFsXG4gICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yICYmIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIGNhbnZhcyB0byBvcmlnaW5hbCBwYXJlbnQgYW5kIHN0eWxpbmcgLSBPbmx5IGlmIGNhbnZhcyB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkXG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgb3JpZ2luYWwgcGFyZW50XG4gICAgICAgICAgaWYgKG9yaWdpbmFsQ2FudmFzUGFyZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBvcmlnaW5hbENhbnZhc1BhcmVudCkge1xuICAgICAgICAgICAgb3JpZ2luYWxDYW52YXNQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFvcmlnaW5hbENhbnZhc1BhcmVudCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gbG9va2luZyBmb3IgYSBjb250YWluZXIgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVQYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUGFyZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBwb3NzaWJsZVBhcmVudCkge1xuICAgICAgICAgICAgICBwb3NzaWJsZVBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXN0b3JlIHN0eWxpbmdcbiAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbENhbnZhc1N0eWxlLnBvc2l0aW9uIHx8ICcnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbENhbnZhc1N0eWxlLnRvcCB8fCAnJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUubGVmdCB8fCAnJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbENhbnZhc1N0eWxlLndpZHRoIHx8ICcxMDAlJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxDYW52YXNTdHlsZS5oZWlnaHQgfHwgJzEwMCUnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBvcmlnaW5hbENhbnZhc1N0eWxlLnpJbmRleCB8fCAnJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXNldCBkaW1lbnNpb25zIGJhc2VkIG9uIHBhcmVudFxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDgwMDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSA2MDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coXCJDYW52YXMgcmVzdG9yZWQgdG8gb3JpZ2luYWwgc3RhdGVcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzdG9yaW5nIGNhbnZhczpcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBBbHdheXMgZ2V0IHRoZSBsYXRlc3Qgc2V0dGluZ3MgZnJvbSBjb250ZXh0IGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5ncyAmJiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSA/IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdIDoge307XG4gICAgICBjb25zdCB0aW1lcyA9IE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgTnVtYmVyKHJhbmRvbVRpbWVzKSB8fCAxO1xuICAgICAgY29uc3QgZGVsYXkgPSBOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IE51bWJlcihkZWxheVNlY29uZHMpIHx8IDM7XG5cbiAgICAgIC8vIExvZyBjdXJyZW50IHNldHRpbmdzIGJlZm9yZSBzdGFydGluZ1xuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIFNldCBSYW5kb20gd2l0aCBzZXR0aW5nczonLCB7XG4gICAgICAgIHJhbmRvbVRpbWVzLFxuICAgICAgICBkZWxheVNlY29uZHMsXG4gICAgICAgIGN1cnJlbnRVc2VySWQsXG4gICAgICAgIHNldHRpbmdzLFxuICAgICAgICB1c2VyU2V0dGluZ3MsXG4gICAgICAgIHRpbWVzLFxuICAgICAgICBkZWxheVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEhpZGUgVG9wQmFyXG4gICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFN0YXJ0aW5nICR7dGltZXN9IHJhbmRvbSBjYXB0dXJlcyB3aXRoICR7ZGVsYXl9cyBkZWxheS4uLmApO1xuXG4gICAgICAvLyBQcm9jZXNzIGFsbCBjYXB0dXJlcyBpbiBzZXF1ZW5jZVxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGN1cnJlbnRJbmRleCA9IDE7IGN1cnJlbnRJbmRleCA8PSB0aW1lczsgY3VycmVudEluZGV4KyspIHtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgY3VycmVudCBjYXB0dXJlXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG9mICR7dGltZXN9YCk7XG4gICAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzIC0gY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBoYW5kbGVEb3RQcm9jZXNzIGZvciBlYWNoIGNhcHR1cmVcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlRG90UHJvY2Vzcyh7XG4gICAgICAgICAgdXNlUmFuZG9tUG9zaXRpb246IHRydWUsXG4gICAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fS8ke3RpbWVzfTogJHtzdGF0dXMucHJvY2Vzc1N0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyBUb3BCYXIgYWZ0ZXIgdGhlIGxhc3QgY2FwdHVyZVxuICAgICAgICAgICAgaWYgKHNob3cgJiYgY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBzaG93IHlldCBmb3IgaW50ZXJtZWRpYXRlIGNhcHR1cmVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHNob3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgICAgICBzZXRJc0NhcHR1cmluZzogKGNhcHR1cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzZXQgY2FwdHVyaW5nIHRvIGZhbHNlIGFmdGVyIGFsbCBjYXB0dXJlc1xuICAgICAgICAgICAgaWYgKCFjYXB0dXJpbmcgJiYgY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdGF5IGluIGNhcHR1cmluZyBzdGF0ZSBiZXR3ZWVuIGRvdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGNhcHR1cmluZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHBvc3RDb3VudGRvd25EZWxheTogODAwXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY29tcGxldGVkIGNhcHR1cmUgJHtjdXJyZW50SW5kZXh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fSBtYXkgaGF2ZSBmYWlsZWQ6YCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIGNhcHR1cmVzIC0gYnV0IG9ubHkgaWYgdGhlcmUgYXJlIG1vcmUgY2FwdHVyZXMgdG8gZ29cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgV2FpdGluZyAke2RlbGF5fXMgYmVmb3JlIG5leHQgY2FwdHVyZS4uLmApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5ICogMTAwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBsZXRpb24gbm90aWZpY2F0aW9uXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBjYXB0dXJlcyBzdWNjZXNzZnVsYCk7XG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcygwKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDb21wbGV0ZWQgYWxsIGNhcHR1cmVzOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gc3VjY2Vzc2Z1bGApO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYW5kb20gc2VxdWVuY2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBzZXF1ZW5jZSBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBoYW5kbGVSYW5kb21Eb3QgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgLy8gVXNlIHRoZSBjb25zb2xpZGF0ZWQgZnVuY3Rpb24gd2l0aCByYW5kb20gcG9zaXRpb25cbiAgICBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgIHVzZVJhbmRvbVBvc2l0aW9uOiB0cnVlLFxuICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgaWYgKHN0YXR1cy5pc0NhcHR1cmluZyAhPT0gdW5kZWZpbmVkKSBzZXRJc0NhcHR1cmluZyhzdGF0dXMuaXNDYXB0dXJpbmcpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgc2hvdyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgIHBvc3RDb3VudGRvd25EZWxheTogMTAwMFxuICAgIH0pO1xuICB9O1xuICBjb25zdCBtYWtlQ2FudmFzRnVsbHNjcmVlbiA9IChjYW52YXMpID0+IHtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZSBpZiBub3QgYWxyZWFkeSBzYXZlZFxuICAgIGlmICghY2FudmFzLl9vcmlnaW5hbFN0YXRlKSB7XG4gICAgICBjYW52YXMuX29yaWdpbmFsU3RhdGUgPSB7XG4gICAgICAgIHBhcmVudDogY2FudmFzLnBhcmVudEVsZW1lbnQsXG4gICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgIHRvcDogY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogY2FudmFzLnN0eWxlLmxlZnQsXG4gICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiBjYW52YXMuc3R5bGUuekluZGV4LFxuICAgICAgICBjYW52YXNXaWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBjYW52YXNIZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIC8vIE1vdmUgdG8gYm9keSBhbmQgbWFrZSBmdWxsc2NyZWVuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGUnO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3dcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG4gIFxuXG4gIC8vIExvYWQgY2FsaWJyYXRpb24gc2V0dXBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIGNvbnN0IHNldHVwQ2FsaWJyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IENhbGlicmF0ZUhhbmRsZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyJyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW52YXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgc2V0dXBDYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIG1ha2VDYW52YXNGdWxsc2NyZWVuKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhcyBzaXplOicsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0dlbmVyYXRlZCBjYWxpYnJhdGlvbiBwb2ludHM6JywgcG9pbnRzKTtcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25Qb2ludHMocG9pbnRzKTtcbiAgICBcbiAgICAgICAgY29uc3QgY2FsaWJyYXRlSGFuZGxlciA9IG5ldyBDYWxpYnJhdGVIYW5kbGVyKHtcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgY2FsaWJyYXRpb25Qb2ludHM6IHBvaW50cyxcbiAgICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiBvbkFjdGlvbkNsaWNrPy4oJ3RvZ2dsZVRvcEJhcicsIHNob3cpLFxuICAgICAgICAgIHNldE91dHB1dFRleHQ6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudGVyOiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0NvdW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KHByZXYgPT4gbmV3Q291bnRlcihwcmV2KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQobmV3Q291bnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBzZXRDYWxpYnJhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgIGhhbmRsZUFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbi4uLicpO1xuICAgICAgICAgICAgYXdhaXQgY2FsaWJyYXRlSGFuZGxlci5zdGFydENhbGlicmF0aW9uKCk7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIHJlc3RvcmVDYW52YXNTaXplKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY2FsaWJyYXRpb246JywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0dXBDYWxpYnJhdGlvbigpO1xuICB9LCBbY2FwdHVyZUNvdW50LCBvbkFjdGlvbkNsaWNrXSk7XG4gIFxuICAvLyBDbGVhciBBbGwgQnV0dG9uIC0gUmVzZXQgZXZlcnl0aGluZ1xuICBjb25zdCBoYW5kbGVDbGVhckFsbCA9ICgpID0+IHtcbiAgICBjbGVhckNhbnZhcygpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSBIZWFkIFBvc2UgdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVIZWFkUG9zZSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdIZWFkUG9zZVN0YXRlID0gIXNob3dIZWFkUG9zZTtcbiAgICBzZXRTaG93SGVhZFBvc2UobmV3SGVhZFBvc2VTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgSGVhZCBwb3NlIHZpc3VhbGl6YXRpb24gJHtuZXdIZWFkUG9zZVN0YXRlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnaGVhZFBvc2UnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93SGVhZFBvc2U6IG5ld0hlYWRQb3NlU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBoZWFkIHBvc2U6ICR7bmV3SGVhZFBvc2VTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEJvdW5kaW5nIEJveCB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94ID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0JvdW5kaW5nQm94U3RhdGUgPSAhc2hvd0JvdW5kaW5nQm94O1xuICAgIHNldFNob3dCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveFN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBCb3VuZGluZyBib3ggJHtuZXdCb3VuZGluZ0JveFN0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdib3VuZGluZ0JveCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dCb3VuZGluZ0JveDogbmV3Qm91bmRpbmdCb3hTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGJvdW5kaW5nIGJveDogJHtuZXdCb3VuZGluZ0JveFN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgTWFzayB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZU1hc2sgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFza1N0YXRlID0gIXNob3dNYXNrO1xuICAgIHNldFNob3dNYXNrKG5ld01hc2tTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgTWFzayAke25ld01hc2tTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnbWFzaycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dNYXNrOiBuZXdNYXNrU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBtYXNrOiAke25ld01hc2tTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIFBhcmFtZXRlcnMgZGlzcGxheVxuICBjb25zdCBoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld1BhcmFtZXRlcnNTdGF0ZSA9ICFzaG93UGFyYW1ldGVycztcbiAgICBzZXRTaG93UGFyYW1ldGVycyhuZXdQYXJhbWV0ZXJzU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYFBhcmFtZXRlcnMgJHtuZXdQYXJhbWV0ZXJzU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3BhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93UGFyYW1ldGVyczogbmV3UGFyYW1ldGVyc1N0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgcGFyYW1ldGVyczogJHtuZXdQYXJhbWV0ZXJzU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBjYW1lcmEgcHJldmlld1xuICBjb25zdCBoYW5kbGVUb2dnbGVDYW1lcmEgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Q2FtZXJhU3RhdGUgPSAhaXNDYW1lcmFBY3RpdmU7XG4gICAgc2V0SXNDYW1lcmFBY3RpdmUobmV3Q2FtZXJhU3RhdGUpO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHdpdGggJ3ByZXZpZXcnIGFjdGlvblxuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdwcmV2aWV3JywgbmV3Q2FtZXJhU3RhdGUpOyAvLyBQYXNzIHRoZSBuZXcgc3RhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IHRyaWdnZXIgaWYgbm8gYWN0aW9uIGhhbmRsZXJcbiAgICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHR1cm5pbmcgb24gY2FtZXJhLCBlbnN1cmUgd2UgYXBwbHkgY3VycmVudCB2aXN1YWxpemF0aW9uIHNldHRpbmdzXG4gICAgaWYgKG5ld0NhbWVyYVN0YXRlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgLy8gV2FpdCBhIHNob3J0IG1vbWVudCB0byBlbnN1cmUgdGhlIHZpZGVvIGVsZW1lbnQgaXMgcmVhZHlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgc2hvd0hlYWRQb3NlLFxuICAgICAgICAgICAgc2hvd0JvdW5kaW5nQm94LFxuICAgICAgICAgICAgc2hvd01hc2ssXG4gICAgICAgICAgICBzaG93UGFyYW1ldGVyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYmFjayBidXR0b24gaGFuZGxlclxuICBjb25zdCBoYW5kbGVHb0JhY2sgPSAoKSA9PiB7XG4gICAgcm91dGVyLnB1c2goJy8nKTtcbiAgfTtcblxuICAvLyBNb2JpbGUgbGF5b3V0IC0gMng1IGdyaWRcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAge2lzQ29tcGFjdE1vZGUgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMiBtYi00XCI+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTJcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBDYW1lcmEgUGVybWlzc2lvbiBQb3B1cCAqL31cbiAgICAgIHtzaG93UGVybWlzc2lvblBvcHVwICYmIChcbiAgICAgICAgPGRpdiBcbiAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1wb3B1cFwiIFxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICB6SW5kZXg6IDE1XG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1kaWFsb2dcIiBcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHdpZHRoOiAnNDAwcHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcyMHB4JyxcbiAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCA0cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yKSdcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGgzIFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi10aXRsZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAxNXB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE4cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDYW1lcmEgQWNjZXNzIFJlcXVpcmVkXG4gICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgPHAgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLW1lc3NhZ2VcIiBcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMjBweCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMS40J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBUaGlzIGFwcGxpY2F0aW9uIG5lZWRzIGFjY2VzcyB0byB5b3VyIGNhbWVyYSB0byBmdW5jdGlvbiBwcm9wZXJseS4gV2hlbiBwcm9tcHRlZCBieSB5b3VyIGJyb3dzZXIsIHBsZWFzZSBjbGljayBcIkFsbG93XCIgdG8gZ3JhbnQgY2FtZXJhIGFjY2Vzcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWJ1dHRvbnNcIiBcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgICAgICAgICAgZ2FwOiAnMTBweCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uRGVuaWVkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1idG5cIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2YwZjBmMCcsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1idG5cIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwNjZjYycsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENvbnRpbnVlXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn0pO1xuY29uc3QgQWN0aW9uQnV0dG9uR3JvdXAgPSBkeW5hbWljKCgpID0+IFByb21pc2UucmVzb2x2ZShcbiAgZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gPEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgey4uLnByb3BzfSByZWY9e3JlZn0gLz4pXG4pLCB7IHNzcjogZmFsc2UgfSk7XG4vLyBDcmVhdGUgYSBjbGllbnQtb25seSB2ZXJzaW9uIG9mIEFjdGlvbkJ1dHRvbkdyb3VwXG4vLyBjb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIpLCB7IHNzcjogZmFsc2UgfSk7XG5cbi8vIEFkZCBkZWZhdWx0IGV4cG9ydCBjb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFjdGlvbkJ1dHRvblBhZ2UoKSB7XG4gIHJldHVybiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xufVxuXG5leHBvcnQgeyBBY3Rpb25CdXR0b24sIEFjdGlvbkJ1dHRvbkdyb3VwIH07Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJmb3J3YXJkUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZU1lbW8iLCJkeW5hbWljIiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsInNob3dDYXB0dXJlUHJldmlldyIsImRyYXdSZWREb3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJydW5Db3VudGRvd24iLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsInVzZVJvdXRlciIsInVzZUFkbWluU2V0dGluZ3MiLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJrZXlzMSIsIk9iamVjdCIsImtleXMiLCJrZXlzMiIsImxlbmd0aCIsImV2ZXJ5Iiwia2V5IiwiaW5jbHVkZXMiLCJBY3Rpb25CdXR0b24iLCJ0ZXh0IiwiYWJicmV2aWF0ZWRUZXh0Iiwib25DbGljayIsImN1c3RvbUNsYXNzIiwiZGlzYWJsZWQiLCJhY3RpdmUiLCJpc0FiYnJldmlhdGVkIiwic2V0SXNBYmJyZXZpYXRlZCIsInNldHRpbmdzIiwiY3VycmVudFVzZXJJZCIsInNldEN1cnJlbnRVc2VySWQiLCJpc0NhcHR1cmluZyIsInNldElzQ2FwdHVyaW5nIiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsInByb2Nlc3NTdGF0dXMiLCJzZXRQcm9jZXNzU3RhdHVzIiwiYnV0dG9uUHJvcHMiLCJjbGFzc05hbWUiLCJ0aXRsZSIsInRpbWVvdXRJZCIsImhhbmRsZVJlc2l6ZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVVzZXJJZENoYW5nZSIsImV2ZW50IiwiZGV0YWlsIiwidHlwZSIsIm5ld1VzZXJJZCIsInVzZXJJZCIsImJ1dHRvbiIsImRpdiIsIkFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIiLCJyZWYiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwiaXNDb21wYWN0TW9kZSIsIm9uQWN0aW9uQ2xpY2siLCJyb3V0ZXIiLCJ1cGRhdGVTZXR0aW5ncyIsInJhbmRvbVRpbWVzIiwic2V0UmFuZG9tVGltZXMiLCJkZWxheVNlY29uZHMiLCJzZXREZWxheVNlY29uZHMiLCJjYW52YXNSZWYiLCJjb3VudGRvd25WYWx1ZSIsInNldENvdW50ZG93blZhbHVlIiwiY3VycmVudERvdCIsInNldEN1cnJlbnREb3QiLCJjYWxpYnJhdGlvblBvaW50cyIsInNldENhbGlicmF0aW9uUG9pbnRzIiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzZXRSZW1haW5pbmdDYXB0dXJlcyIsInNob3dDYW52YXMiLCJzZXRTaG93Q2FudmFzIiwiY2FsaWJyYXRpb25IYW5kbGVyIiwic2V0Q2FsaWJyYXRpb25IYW5kbGVyIiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0hlYWRQb3NlIiwic2V0U2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2V0U2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzZXRTaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2V0U2hvd1BhcmFtZXRlcnMiLCJpc0NhbWVyYUFjdGl2ZSIsInNldElzQ2FtZXJhQWN0aXZlIiwic2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldFNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXR0aW5nc0NhY2hlIiwiTWFwIiwibGFzdFNldHRpbmdzVXBkYXRlIiwidXNlclNldHRpbmdzIiwiY2FjaGVkU2V0dGluZ3MiLCJjdXJyZW50IiwiZ2V0IiwiTnVtYmVyIiwidGltZXNfc2V0X3JhbmRvbSIsImRlbGF5X3NldF9yYW5kb20iLCJzZXQiLCJEYXRlIiwibm93IiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJ1bmRlZmluZWQiLCJuZXdUaW1lcyIsIm5ld0RlbGF5IiwiYWN0aW9uQnV0dG9uRnVuY3Rpb25zIiwiaGFuZGxlUmFuZG9tRG90IiwiaGFuZGxlU2V0UmFuZG9tIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwiaGFuZGxlQ2xlYXJBbGwiLCJ1cGRhdGVDb250cm9sVmFsdWVzIiwidGltZUlucHV0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidGltZVZhbHVlIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImlzTmFOIiwiY29uc29sZSIsImxvZyIsImRlbGF5SW5wdXQiLCJkZWxheVZhbHVlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImV4aXN0aW5nQ2FudmFzIiwicmVtb3ZlIiwiY2FudmFzIiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJjc3NUZXh0IiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJ3aGl0ZVNjcmVlbkNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNsZWFudXAiLCJnZXRNYWluQ2FudmFzIiwiY29udGFpbnMiLCJzZXRBdHRyaWJ1dGUiLCJjb250YWluZXIiLCJwb3NpdGlvbiIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsIl9jbGVhbnVwIiwiaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkIiwiaGFuZGxlUGVybWlzc2lvbkRlbmllZCIsInJlc3RvcmVDYW52YXMiLCJfb3JpZ2luYWxTdGF0ZSIsIm9yaWdpbmFsIiwidG9wIiwibGVmdCIsInpJbmRleCIsImJhY2tncm91bmRDb2xvciIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZXJyb3IiLCJjbGVhckNhbnZhcyIsIndhcm4iLCJjbGVhclJlY3QiLCJoYW5kbGVEb3RQcm9jZXNzIiwib3B0aW9ucyIsIm9uU3RhdHVzVXBkYXRlIiwidG9nZ2xlVG9wQmFyIiwidXNlUmFuZG9tUG9zaXRpb24iLCJwb3N0Q291bnRkb3duRGVsYXkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJldHJ5Q291bnQiLCJtYXhSZXRyaWVzIiwiRXJyb3IiLCJvcmlnaW5hbFBhcmVudCIsIm9yaWdpbmFsU3R5bGUiLCJkb3RQb3NpdGlvbiIsIngiLCJ5IiwiZG90UmFkaXVzIiwia2VlcERvdFZpc2libGVJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsImNvdW50ZG93bkVsZW1lbnQiLCJjb3VudCIsInRleHRDb250ZW50IiwiY2FwdHVyZVJlc3VsdCIsInBvaW50IiwiY2xlYXJJbnRlcnZhbCIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwib3JpZ2luYWxDYW52YXNQYXJlbnQiLCJvcmlnaW5hbENhbnZhc1N0eWxlIiwic3RhdHVzSW5kaWNhdG9yIiwiY3VycmVudFJlZHJhd0ludGVydmFsIiwicG9pbnRzIiwic3VjY2Vzc0NvdW50IiwiaSIsInJhZGl1cyIsInJlZHJhd0N1cnJlbnREb3QiLCJzY3JlZW5JbWFnZSIsInBvc3NpYmxlUGFyZW50IiwiZSIsInRpbWVzIiwiZGVsYXkiLCJjdXJyZW50SW5kZXgiLCJyZXN1bHQiLCJzdGF0dXMiLCJzaG93IiwiY2FwdHVyaW5nIiwibWFrZUNhbnZhc0Z1bGxzY3JlZW4iLCJzZXR1cENhbGlicmF0aW9uIiwiZGVmYXVsdCIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjYWxpYnJhdGVIYW5kbGVyIiwic2V0T3V0cHV0VGV4dCIsIm5ld0NvdW50ZXIiLCJwcmV2IiwiY2FwdHVyZUZvbGRlciIsIm9uQ29tcGxldGUiLCJoYW5kbGVBY3Rpb24iLCJzdGFydENhbGlicmF0aW9uIiwicmVzdG9yZUNhbnZhc1NpemUiLCJlcnIiLCJoYW5kbGVUb2dnbGVIZWFkUG9zZSIsIm5ld0hlYWRQb3NlU3RhdGUiLCJ2aWRlb1Byb2Nlc3NvciIsInVwZGF0ZU9wdGlvbnMiLCJoYW5kbGVUb2dnbGVCb3VuZGluZ0JveCIsIm5ld0JvdW5kaW5nQm94U3RhdGUiLCJoYW5kbGVUb2dnbGVNYXNrIiwibmV3TWFza1N0YXRlIiwiaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyIsIm5ld1BhcmFtZXRlcnNTdGF0ZSIsImhhbmRsZVRvZ2dsZUNhbWVyYSIsIm5ld0NhbWVyYVN0YXRlIiwiaGFuZGxlR29CYWNrIiwicHVzaCIsImRpc3BsYXkiLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJib3JkZXJSYWRpdXMiLCJwYWRkaW5nIiwiYm94U2hhZG93IiwiaDMiLCJtYXJnaW4iLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJwIiwibGluZUhlaWdodCIsImdhcCIsImJvcmRlciIsImN1cnNvciIsImNvbG9yIiwiQWN0aW9uQnV0dG9uR3JvdXAiLCJwcm9wcyIsInNzciIsIkFjdGlvbkJ1dHRvblBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});