"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Initialize polling for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    if (!currentUserId) return;\n                    try {\n                        console.log('Polling settings for user:', currentUserId);\n                        const response = await fetch(\"/api/data-center/settings/\".concat(currentUserId), {\n                            headers: {\n                                'Accept': 'application/json',\n                                'Content-Type': 'application/json',\n                                'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                            }\n                        });\n                        if (!response.ok) {\n                            const errorData = await response.json();\n                            throw new Error(errorData.detail || 'Failed to fetch settings');\n                        }\n                        const newSettings = await response.json();\n                        console.log('Fetched settings for user:', currentUserId, newSettings);\n                        // Only update if settings have changed\n                        const currentUserSettings = settings[currentUserId];\n                        if (JSON.stringify(currentUserSettings) !== JSON.stringify(newSettings)) {\n                            setSettings({\n                                \"useAdminSettings.useEffect.fetchSettings\": (prev)=>({\n                                        ...prev,\n                                        [currentUserId]: {\n                                            ...newSettings,\n                                            times: newSettings.times,\n                                            delay: newSettings.delay // Preserve the exact delay value\n                                        }\n                                    })\n                            }[\"useAdminSettings.useEffect.fetchSettings\"]);\n                            // Update topBar through ref\n                            if (ref && ref.current) {\n                                if (ref.current.setCaptureSettings) {\n                                    ref.current.setCaptureSettings(newSettings);\n                                    setIsTopBarUpdated(true);\n                                }\n                            }\n                        }\n                        setError(null);\n                    } catch (error) {\n                        console.error('Error fetching settings:', error);\n                        setError(error.message);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            // Initial fetch\n            fetchSettings();\n            // Set up polling interval\n            pollingInterval.current = setInterval(fetchSettings, 3000);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref,\n        settings\n    ]);\n    // Effect to handle index.js update after topBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                // Dispatch event to update index.js\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n                console.error('Error loading settings from localStorage:', error);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {\n                    console.error('Error saving settings to localStorage:', error);\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        setCurrentUserId(event.detail.userId);\n                        // Trigger immediate settings fetch for new user\n                        const fetchSettings = {\n                            \"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\": async ()=>{\n                                try {\n                                    const response = await fetch(\"/api/data-center/settings/\".concat(event.detail.userId), {\n                                        headers: {\n                                            'Accept': 'application/json',\n                                            'Content-Type': 'application/json',\n                                            'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                                        }\n                                    });\n                                    if (!response.ok) throw new Error('Failed to fetch settings');\n                                    const newSettings = await response.json();\n                                    console.log('Fetched settings for new user:', newSettings);\n                                    setSettings({\n                                        \"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\": (prev)=>({\n                                                ...prev,\n                                                [event.detail.userId]: newSettings\n                                            })\n                                    }[\"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\"]);\n                                    if (ref && ref.current && ref.current.setCaptureSettings) {\n                                        ref.current.setCaptureSettings(newSettings);\n                                        setIsTopBarUpdated(true);\n                                    }\n                                } catch (error) {\n                                    console.error('Error fetching settings for new user:', error);\n                                }\n                            }\n                        }[\"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\"];\n                        fetchSettings();\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Listen for settings updates from admin page\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": async (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        if (times !== undefined || delay !== undefined) {\n                            // Get current settings for this user\n                            const currentSettings = settings[userId] || {};\n                            // Create new settings by preserving current values and only updating what's provided\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? times : currentSettings.times,\n                                delay: delay !== undefined ? delay : currentSettings.delay,\n                                // Remove default values to prevent overriding user input\n                                image_path: currentSettings.image_path,\n                                updateImage: currentSettings.updateImage,\n                                set_timeRandomImage: currentSettings.set_timeRandomImage,\n                                every_set: currentSettings.every_set,\n                                zoom_percentage: currentSettings.zoom_percentage,\n                                position_zoom: currentSettings.position_zoom,\n                                state_isProcessOn: currentSettings.state_isProcessOn,\n                                currentlyPage: currentSettings.currentlyPage,\n                                freeState: currentSettings.freeState\n                            };\n                            console.log('Updating settings with:', newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            // First update topBar through ref\n                            if (ref && ref.current) {\n                                if (ref.current.setCaptureSettings) {\n                                    ref.current.setCaptureSettings(newSettings);\n                                    setIsTopBarUpdated(true);\n                                }\n                            }\n                            // Save to backend using REST API\n                            try {\n                                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                                    method: 'POST',\n                                    headers: {\n                                        'Content-Type': 'application/json',\n                                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                                    },\n                                    body: JSON.stringify(newSettings)\n                                });\n                                if (!response.ok) {\n                                    const errorData = await response.json();\n                                    throw new Error(errorData.detail || 'Failed to save settings to backend');\n                                }\n                                console.log('Settings saved to backend:', newSettings);\n                                setError(null);\n                            } catch (error) {\n                                console.error('Error saving settings to backend:', error);\n                                setError(error.message);\n                            }\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        ref\n    ]);\n    const updateSettings = async (newSettings, userId)=>{\n        var _settings_userId, _settings_userId1;\n        if (!userId) {\n            console.error('No user ID provided for settings update');\n            return;\n        }\n        // Create a clean settings object for this user\n        const updatedSettings = {\n            ...settings[userId],\n            ...newSettings,\n            // Ensure times and delay are preserved exactly as provided\n            times: newSettings.times !== undefined ? newSettings.times : (_settings_userId = settings[userId]) === null || _settings_userId === void 0 ? void 0 : _settings_userId.times,\n            delay: newSettings.delay !== undefined ? newSettings.delay : (_settings_userId1 = settings[userId]) === null || _settings_userId1 === void 0 ? void 0 : _settings_userId1.delay\n        };\n        console.log(\"Updating settings for user \".concat(userId, \":\"), updatedSettings);\n        // Update local state\n        setSettings((prev)=>({\n                ...prev,\n                [userId]: updatedSettings\n            }));\n        // Save to backend using REST API\n        try {\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify(updatedSettings)\n            });\n            if (!response.ok) {\n                throw new Error('Failed to save settings');\n            }\n            const savedSettings = await response.json();\n            console.log('Settings saved successfully:', savedSettings);\n            // Update local state with the saved settings\n            setSettings((prev)=>({\n                    ...prev,\n                    [userId]: savedSettings\n                }));\n        } catch (error) {\n            console.error('Error saving settings:', error);\n        }\n    };\n    return {\n        settings,\n        updateSettings,\n        error\n    };\n};\n_s(useAdminSettings, \"wyRehNK8BbZecFVC4rDbi09GWoI=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFFN0MsTUFBTUcsbUJBQW1CLENBQUNDOztJQUMvQixNQUFNLENBQUNDLFVBQVVDLFlBQVksR0FBR0osK0NBQVFBLENBQUMsQ0FBQztJQUMxQyxNQUFNLENBQUNLLGVBQWVDLGlCQUFpQixHQUFHTiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNPLGlCQUFpQkMsbUJBQW1CLEdBQUdSLCtDQUFRQSxDQUFDO0lBQ3ZELE1BQU0sQ0FBQ1MsT0FBT0MsU0FBUyxHQUFHViwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNVyxjQUFjWiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNYSxrQkFBa0JiLDZDQUFNQSxDQUFDO0lBRS9CLDBDQUEwQztJQUMxQ0QsZ0RBQVNBO3NDQUFDO1lBQ1IsTUFBTWU7NERBQWdCO29CQUNwQixJQUFJLENBQUNSLGVBQWU7b0JBRXBCLElBQUk7d0JBQ0ZTLFFBQVFDLEdBQUcsQ0FBQyw4QkFBOEJWO3dCQUMxQyxNQUFNVyxXQUFXLE1BQU1DLE1BQU0sNkJBQTJDLE9BQWRaLGdCQUFpQjs0QkFDekVhLFNBQVM7Z0NBQ1AsVUFBVTtnQ0FDVixnQkFBZ0I7Z0NBQ2hCLGFBQWFDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7NEJBQ2xEO3dCQUNGO3dCQUVBLElBQUksQ0FBQ0wsU0FBU00sRUFBRSxFQUFFOzRCQUNoQixNQUFNQyxZQUFZLE1BQU1QLFNBQVNRLElBQUk7NEJBQ3JDLE1BQU0sSUFBSUMsTUFBTUYsVUFBVUcsTUFBTSxJQUFJO3dCQUN0Qzt3QkFFQSxNQUFNQyxjQUFjLE1BQU1YLFNBQVNRLElBQUk7d0JBQ3ZDVixRQUFRQyxHQUFHLENBQUMsOEJBQThCVixlQUFlc0I7d0JBRXpELHVDQUF1Qzt3QkFDdkMsTUFBTUMs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V0FBVyxNQUFNQyxNQUFNLDZCQUFvQyxPQUFQeUIsU0FBVTtnQkFDbEV3QixRQUFRO2dCQUNSaEQsU0FBUztvQkFDUCxnQkFBZ0I7b0JBQ2hCLGFBQWFDLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0MsbUJBQW1CLElBQUk7Z0JBQ2xEO2dCQUNBOEMsTUFBTXRDLEtBQUtDLFNBQVMsQ0FBQ3VDO1lBQ3ZCO1lBRUEsSUFBSSxDQUFDckQsU0FBU00sRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlHLE1BQU07WUFDbEI7WUFFQSxNQUFNb0IsZ0JBQWdCLE1BQU03QixTQUFTUSxJQUFJO1lBQ3pDVixRQUFRQyxHQUFHLENBQUMsZ0NBQWdDOEI7WUFFNUMsNkNBQTZDO1lBQzdDekMsWUFBWTJCLENBQUFBLE9BQVM7b0JBQ25CLEdBQUdBLElBQUk7b0JBQ1AsQ0FBQ1csT0FBTyxFQUFFRztnQkFDWjtRQUNGLEVBQUUsT0FBT3BDLE9BQU87WUFDZEssUUFBUUwsS0FBSyxDQUFDLDBCQUEwQkE7UUFDMUM7SUFDRjtJQUVBLE9BQU87UUFBRU47UUFBVWlFO1FBQWdCM0Q7SUFBTTtBQUMzQyxFQUFFO0dBeFJXUjtBQTBSYiwrQkFBK0I7QUFDaEIsU0FBU3FFO0lBQ3RCLE9BQU8sTUFBTSw4REFBOEQ7QUFDN0U7S0FGd0JBIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9hZG1pblNldHRpbmdzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IHVzZUFkbWluU2V0dGluZ3MgPSAocmVmKSA9PiB7XG4gIGNvbnN0IFtzZXR0aW5ncywgc2V0U2V0dGluZ3NdID0gdXNlU3RhdGUoe30pO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzVG9wQmFyVXBkYXRlZCwgc2V0SXNUb3BCYXJVcGRhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSB1c2VSZWYobnVsbCk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBwb2xsaW5nIGZvciBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2hTZXR0aW5ncyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghY3VycmVudFVzZXJJZCkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnUG9sbGluZyBzZXR0aW5ncyBmb3IgdXNlcjonLCBjdXJyZW50VXNlcklkKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke2N1cnJlbnRVc2VySWR9YCwge1xuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVidcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIGZldGNoIHNldHRpbmdzJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZygnRmV0Y2hlZCBzZXR0aW5ncyBmb3IgdXNlcjonLCBjdXJyZW50VXNlcklkLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgIFxuICAgICAgICAvLyBPbmx5IHVwZGF0ZSBpZiBzZXR0aW5ncyBoYXZlIGNoYW5nZWRcbiAgICAgICAgY29uc3QgY3VycmVudFVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdO1xuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoY3VycmVudFVzZXJTZXR0aW5ncykgIT09IEpTT04uc3RyaW5naWZ5KG5ld1NldHRpbmdzKSkge1xuICAgICAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHtcbiAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICBbY3VycmVudFVzZXJJZF06IHtcbiAgICAgICAgICAgICAgLi4ubmV3U2V0dGluZ3MsICAvLyBVc2UgdGhlIGV4YWN0IHNldHRpbmdzIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICB0aW1lczogbmV3U2V0dGluZ3MudGltZXMsICAvLyBQcmVzZXJ2ZSB0aGUgZXhhY3QgdGltZXMgdmFsdWVcbiAgICAgICAgICAgICAgZGVsYXk6IG5ld1NldHRpbmdzLmRlbGF5ICAgLy8gUHJlc2VydmUgdGhlIGV4YWN0IGRlbGF5IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSB0b3BCYXIgdGhyb3VnaCByZWZcbiAgICAgICAgICBpZiAocmVmICYmIHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAocmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKSB7XG4gICAgICAgICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgICAgIHNldElzVG9wQmFyVXBkYXRlZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbCBmZXRjaFxuICAgIGZldGNoU2V0dGluZ3MoKTtcblxuICAgIC8vIFNldCB1cCBwb2xsaW5nIGludGVydmFsXG4gICAgcG9sbGluZ0ludGVydmFsLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChmZXRjaFNldHRpbmdzLCAzMDAwKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocG9sbGluZ0ludGVydmFsLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWwuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWQsIHJlZiwgc2V0dGluZ3NdKTtcblxuICAvLyBFZmZlY3QgdG8gaGFuZGxlIGluZGV4LmpzIHVwZGF0ZSBhZnRlciB0b3BCYXIgaXMgdXBkYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1RvcEJhclVwZGF0ZWQpIHtcbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50IHRvIHVwZGF0ZSBpbmRleC5qc1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NldHRpbmdzVXBkYXRlZCcsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdHlwZTogJ3NldHRpbmdzJyxcbiAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtpc1RvcEJhclVwZGF0ZWQsIGN1cnJlbnRVc2VySWQsIHNldHRpbmdzXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FkbWluU2V0dGluZ3MnKTtcbiAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFNldHRpbmdzID0gSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKTtcbiAgICAgICAgc2V0U2V0dGluZ3MocGFyc2VkU2V0dGluZ3MpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZSB3aGVuIHRoZXkgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluaXRpYWxpemVkLmN1cnJlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhZG1pblNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnVzZXJJZCkge1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICAvLyBUcmlnZ2VyIGltbWVkaWF0ZSBzZXR0aW5ncyBmZXRjaCBmb3IgbmV3IHVzZXJcbiAgICAgICAgY29uc3QgZmV0Y2hTZXR0aW5ncyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke2V2ZW50LmRldGFpbC51c2VySWR9YCwge1xuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgICdYLUFQSS1LZXknOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzZXR0aW5ncycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHNldHRpbmdzIGZvciBuZXcgdXNlcjonLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgIFtldmVudC5kZXRhaWwudXNlcklkXTogbmV3U2V0dGluZ3NcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCAmJiByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgcmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXR0aW5ncyBmb3IgbmV3IHVzZXI6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZmV0Y2hTZXR0aW5ncygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3JlZl0pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlcyBmcm9tIGFkbWluIHBhZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzLCBkZWxheSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAodGltZXMgIT09IHVuZGVmaW5lZCB8fCBkZWxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gR2V0IGN1cnJlbnQgc2V0dGluZ3MgZm9yIHRoaXMgdXNlclxuICAgICAgICAgIGNvbnN0IGN1cnJlbnRTZXR0aW5ncyA9IHNldHRpbmdzW3VzZXJJZF0gfHwge307XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBzZXR0aW5ncyBieSBwcmVzZXJ2aW5nIGN1cnJlbnQgdmFsdWVzIGFuZCBvbmx5IHVwZGF0aW5nIHdoYXQncyBwcm92aWRlZFxuICAgICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0ge1xuICAgICAgICAgICAgLi4uY3VycmVudFNldHRpbmdzLCAgLy8gS2VlcCBhbGwgZXhpc3Rpbmcgc2V0dGluZ3NcbiAgICAgICAgICAgIHRpbWVzOiB0aW1lcyAhPT0gdW5kZWZpbmVkID8gdGltZXMgOiBjdXJyZW50U2V0dGluZ3MudGltZXMsICAvLyBPbmx5IHVwZGF0ZSBpZiBwcm92aWRlZFxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5ICE9PSB1bmRlZmluZWQgPyBkZWxheSA6IGN1cnJlbnRTZXR0aW5ncy5kZWxheSwgIC8vIE9ubHkgdXBkYXRlIGlmIHByb3ZpZGVkXG4gICAgICAgICAgICAvLyBSZW1vdmUgZGVmYXVsdCB2YWx1ZXMgdG8gcHJldmVudCBvdmVycmlkaW5nIHVzZXIgaW5wdXRcbiAgICAgICAgICAgIGltYWdlX3BhdGg6IGN1cnJlbnRTZXR0aW5ncy5pbWFnZV9wYXRoLFxuICAgICAgICAgICAgdXBkYXRlSW1hZ2U6IGN1cnJlbnRTZXR0aW5ncy51cGRhdGVJbWFnZSxcbiAgICAgICAgICAgIHNldF90aW1lUmFuZG9tSW1hZ2U6IGN1cnJlbnRTZXR0aW5ncy5zZXRfdGltZVJhbmRvbUltYWdlLFxuICAgICAgICAgICAgZXZlcnlfc2V0OiBjdXJyZW50U2V0dGluZ3MuZXZlcnlfc2V0LFxuICAgICAgICAgICAgem9vbV9wZXJjZW50YWdlOiBjdXJyZW50U2V0dGluZ3Muem9vbV9wZXJjZW50YWdlLFxuICAgICAgICAgICAgcG9zaXRpb25fem9vbTogY3VycmVudFNldHRpbmdzLnBvc2l0aW9uX3pvb20sXG4gICAgICAgICAgICBzdGF0ZV9pc1Byb2Nlc3NPbjogY3VycmVudFNldHRpbmdzLnN0YXRlX2lzUHJvY2Vzc09uLFxuICAgICAgICAgICAgY3VycmVudGx5UGFnZTogY3VycmVudFNldHRpbmdzLmN1cnJlbnRseVBhZ2UsXG4gICAgICAgICAgICBmcmVlU3RhdGU6IGN1cnJlbnRTZXR0aW5ncy5mcmVlU3RhdGVcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHNldHRpbmdzIHdpdGg6JywgbmV3U2V0dGluZ3MpO1xuXG4gICAgICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgIFt1c2VySWRdOiBuZXdTZXR0aW5nc1xuICAgICAgICAgIH0pKTtcblxuICAgICAgICAgIC8vIEZpcnN0IHVwZGF0ZSB0b3BCYXIgdGhyb3VnaCByZWZcbiAgICAgICAgICBpZiAocmVmICYmIHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAocmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKSB7XG4gICAgICAgICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgICAgIHNldElzVG9wQmFyVXBkYXRlZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTYXZlIHRvIGJhY2tlbmQgdXNpbmcgUkVTVCBBUElcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShuZXdTZXR0aW5ncylcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byBzYXZlIHNldHRpbmdzIHRvIGJhY2tlbmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIHNhdmVkIHRvIGJhY2tlbmQ6JywgbmV3U2V0dGluZ3MpO1xuICAgICAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5ncyB0byBiYWNrZW5kOicsIGVycm9yKTtcbiAgICAgICAgICAgIHNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIH07XG4gIH0sIFtzZXR0aW5ncywgcmVmXSk7XG5cbiAgY29uc3QgdXBkYXRlU2V0dGluZ3MgPSBhc3luYyAobmV3U2V0dGluZ3MsIHVzZXJJZCkgPT4ge1xuICAgIGlmICghdXNlcklkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdObyB1c2VyIElEIHByb3ZpZGVkIGZvciBzZXR0aW5ncyB1cGRhdGUnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjbGVhbiBzZXR0aW5ncyBvYmplY3QgZm9yIHRoaXMgdXNlclxuICAgIGNvbnN0IHVwZGF0ZWRTZXR0aW5ncyA9IHtcbiAgICAgIC4uLnNldHRpbmdzW3VzZXJJZF0sXG4gICAgICAuLi5uZXdTZXR0aW5ncyxcbiAgICAgIC8vIEVuc3VyZSB0aW1lcyBhbmQgZGVsYXkgYXJlIHByZXNlcnZlZCBleGFjdGx5IGFzIHByb3ZpZGVkXG4gICAgICB0aW1lczogbmV3U2V0dGluZ3MudGltZXMgIT09IHVuZGVmaW5lZCA/IG5ld1NldHRpbmdzLnRpbWVzIDogc2V0dGluZ3NbdXNlcklkXT8udGltZXMsXG4gICAgICBkZWxheTogbmV3U2V0dGluZ3MuZGVsYXkgIT09IHVuZGVmaW5lZCA/IG5ld1NldHRpbmdzLmRlbGF5IDogc2V0dGluZ3NbdXNlcklkXT8uZGVsYXlcbiAgICB9O1xuXG4gICAgY29uc29sZS5sb2coYFVwZGF0aW5nIHNldHRpbmdzIGZvciB1c2VyICR7dXNlcklkfTpgLCB1cGRhdGVkU2V0dGluZ3MpO1xuXG4gICAgLy8gVXBkYXRlIGxvY2FsIHN0YXRlXG4gICAgc2V0U2V0dGluZ3MocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIFt1c2VySWRdOiB1cGRhdGVkU2V0dGluZ3NcbiAgICB9KSk7XG5cbiAgICAvLyBTYXZlIHRvIGJhY2tlbmQgdXNpbmcgUkVTVCBBUElcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU2V0dGluZ3MpXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHNldHRpbmdzJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQgc3VjY2Vzc2Z1bGx5OicsIHNhdmVkU2V0dGluZ3MpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgbG9jYWwgc3RhdGUgd2l0aCB0aGUgc2F2ZWQgc2V0dGluZ3NcbiAgICAgIHNldFNldHRpbmdzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW3VzZXJJZF06IHNhdmVkU2V0dGluZ3NcbiAgICAgIH0pKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIHNldHRpbmdzOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgc2V0dGluZ3MsIHVwZGF0ZVNldHRpbmdzLCBlcnJvciB9O1xufTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWRtaW5TZXR0aW5ncygpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59Il0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlQWRtaW5TZXR0aW5ncyIsInJlZiIsInNldHRpbmdzIiwic2V0U2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzVG9wQmFyVXBkYXRlZCIsInNldElzVG9wQmFyVXBkYXRlZCIsImVycm9yIiwic2V0RXJyb3IiLCJpbml0aWFsaXplZCIsInBvbGxpbmdJbnRlcnZhbCIsImZldGNoU2V0dGluZ3MiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0tFWSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsIkVycm9yIiwiZGV0YWlsIiwibmV3U2V0dGluZ3MiLCJjdXJyZW50VXNlclNldHRpbmdzIiwiSlNPTiIsInN0cmluZ2lmeSIsInByZXYiLCJ0aW1lcyIsImRlbGF5IiwiY3VycmVudCIsInNldENhcHR1cmVTZXR0aW5ncyIsIm1lc3NhZ2UiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJldmVudCIsIkN1c3RvbUV2ZW50IiwidHlwZSIsInVzZXJJZCIsIndpbmRvdyIsImRpc3BhdGNoRXZlbnQiLCJzYXZlZFNldHRpbmdzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsInBhcnNlZFNldHRpbmdzIiwicGFyc2UiLCJzZXRJdGVtIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsInVuZGVmaW5lZCIsImN1cnJlbnRTZXR0aW5ncyIsImltYWdlX3BhdGgiLCJ1cGRhdGVJbWFnZSIsInNldF90aW1lUmFuZG9tSW1hZ2UiLCJldmVyeV9zZXQiLCJ6b29tX3BlcmNlbnRhZ2UiLCJwb3NpdGlvbl96b29tIiwic3RhdGVfaXNQcm9jZXNzT24iLCJjdXJyZW50bHlQYWdlIiwiZnJlZVN0YXRlIiwibWV0aG9kIiwiYm9keSIsInVwZGF0ZVNldHRpbmdzIiwidXBkYXRlZFNldHRpbmdzIiwiQWRtaW5TZXR0aW5ncyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});