"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/admin",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _s = $RefreshSig$();\n\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Initialize polling for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    if (!currentUserId) return;\n                    try {\n                        const response = await fetch(\"/api/data-center/settings/\".concat(currentUserId));\n                        if (!response.ok) throw new Error('Failed to fetch settings');\n                        const newSettings = await response.json();\n                        console.log('Fetched settings:', newSettings);\n                        setSettings({\n                            \"useAdminSettings.useEffect.fetchSettings\": (prev)=>({\n                                    ...prev,\n                                    [currentUserId]: newSettings\n                                })\n                        }[\"useAdminSettings.useEffect.fetchSettings\"]);\n                        // First update topBar through ref\n                        if (ref && ref.current) {\n                            if (ref.current.setCaptureSettings) {\n                                ref.current.setCaptureSettings(newSettings);\n                                setIsTopBarUpdated(true);\n                            }\n                        }\n                    } catch (error) {\n                        console.error('Error fetching settings:', error);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            // Initial fetch\n            fetchSettings();\n            // Set up polling interval\n            pollingInterval.current = setInterval(fetchSettings, 3000);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        ref\n    ]);\n    // Effect to handle index.js update after topBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                // Dispatch event to update index.js\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = localStorage.getItem('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n                console.error('Error loading settings from localStorage:', error);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    localStorage.setItem('adminSettings', JSON.stringify(settings));\n                } catch (error) {\n                    console.error('Error saving settings to localStorage:', error);\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        setCurrentUserId(event.detail.userId);\n                        // Trigger immediate settings fetch for new user\n                        const fetchSettings = {\n                            \"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\": async ()=>{\n                                try {\n                                    const response = await fetch(\"/api/data-center/settings/\".concat(event.detail.userId));\n                                    if (!response.ok) throw new Error('Failed to fetch settings');\n                                    const newSettings = await response.json();\n                                    console.log('Fetched settings for new user:', newSettings);\n                                    setSettings({\n                                        \"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\": (prev)=>({\n                                                ...prev,\n                                                [event.detail.userId]: newSettings\n                                            })\n                                    }[\"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\"]);\n                                    if (ref && ref.current && ref.current.setCaptureSettings) {\n                                        ref.current.setCaptureSettings(newSettings);\n                                        setIsTopBarUpdated(true);\n                                    }\n                                } catch (error) {\n                                    console.error('Error fetching settings for new user:', error);\n                                }\n                            }\n                        }[\"useAdminSettings.useEffect.handleUserIdChange.fetchSettings\"];\n                        fetchSettings();\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Listen for settings updates from admin page\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        if (times !== undefined || delay !== undefined) {\n                            var _settings_userId, _settings_userId1;\n                            const newSettings = {\n                                times: times !== undefined ? times : ((_settings_userId = settings[userId]) === null || _settings_userId === void 0 ? void 0 : _settings_userId.times) || 1,\n                                delay: delay !== undefined ? delay : ((_settings_userId1 = settings[userId]) === null || _settings_userId1 === void 0 ? void 0 : _settings_userId1.delay) || 3\n                            };\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            // First update topBar through ref\n                            if (ref && ref.current) {\n                                if (ref.current.setCaptureSettings) {\n                                    ref.current.setCaptureSettings(newSettings);\n                                    setIsTopBarUpdated(true);\n                                }\n                            }\n                            // Save to backend\n                            const saveToBackend = {\n                                \"useAdminSettings.useEffect.handleSettingsUpdate.saveToBackend\": async ()=>{\n                                    try {\n                                        const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                                            method: 'POST',\n                                            headers: {\n                                                'Content-Type': 'application/json'\n                                            },\n                                            body: JSON.stringify(newSettings)\n                                        });\n                                        if (!response.ok) {\n                                            throw new Error('Failed to save settings to backend');\n                                        }\n                                        console.log('Settings saved to backend:', newSettings);\n                                    } catch (error) {\n                                        console.error('Error saving settings to backend:', error);\n                                    }\n                                }\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate.saveToBackend\"];\n                            saveToBackend();\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        ref\n    ]);\n    const updateSettings = async (newSettings, userId)=>{\n        try {\n            if (!newSettings || typeof newSettings !== 'object') {\n                throw new Error('Invalid settings format');\n            }\n            const { times, delay } = newSettings;\n            if (typeof times !== 'number' || typeof delay !== 'number' || times < 1 || delay < 1) {\n                throw new Error('Invalid settings values');\n            }\n            const updatedSettings = {\n                ...settings,\n                [userId]: {\n                    times,\n                    delay\n                }\n            };\n            setSettings(updatedSettings);\n            initialized.current = true;\n            // Save settings to backend\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    times,\n                    delay\n                })\n            });\n            if (!response.ok) {\n                throw new Error('Failed to save settings to backend');\n            }\n            console.log('Settings updated and saved:', {\n                userId,\n                times,\n                delay\n            });\n            // First update topBar through ref\n            if (ref && ref.current) {\n                if (ref.current.setCaptureSettings) {\n                    ref.current.setCaptureSettings({\n                        times,\n                        delay\n                    });\n                    setIsTopBarUpdated(true);\n                }\n            }\n        } catch (error) {\n            console.error('Error updating settings:', error);\n            throw error;\n        }\n    };\n    return {\n        settings,\n        updateSettings\n    };\n};\n_s(useAdminSettings, \"nuvxxM8Wg39fvpcwYnB6g4V14AE=\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9EO0FBRTdDLE1BQU1HLG1CQUFtQixDQUFDQzs7SUFDL0IsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdKLCtDQUFRQSxDQUFDLENBQUM7SUFDMUMsTUFBTSxDQUFDSyxlQUFlQyxpQkFBaUIsR0FBR04sK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDTyxpQkFBaUJDLG1CQUFtQixHQUFHUiwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNUyxjQUFjViw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNVyxrQkFBa0JYLDZDQUFNQSxDQUFDO0lBRS9CLDBDQUEwQztJQUMxQ0QsZ0RBQVNBO3NDQUFDO1lBQ1IsTUFBTWE7NERBQWdCO29CQUNwQixJQUFJLENBQUNOLGVBQWU7b0JBRXBCLElBQUk7d0JBQ0YsTUFBTU8sV0FBVyxNQUFNQyxNQUFNLDZCQUEyQyxPQUFkUjt3QkFDMUQsSUFBSSxDQUFDTyxTQUFTRSxFQUFFLEVBQUUsTUFBTSxJQUFJQyxNQUFNO3dCQUVsQyxNQUFNQyxjQUFjLE1BQU1KLFNBQVNLLElBQUk7d0JBQ3ZDQyxRQUFRQyxHQUFHLENBQUMscUJBQXFCSDt3QkFDakNaO3dFQUFZZ0IsQ0FBQUEsT0FBUztvQ0FDbkIsR0FBR0EsSUFBSTtvQ0FDUCxDQUFDZixjQUFjLEVBQUVXO2dDQUNuQjs7d0JBRUEsa0NBQWtDO3dCQUNsQyxJQUFJZCxPQUFPQSxJQUFJbUIsT0FBTyxFQUFFOzRCQUN0QixJQUFJbkIsSUFBSW1CLE9BQU8sQ0FBQ0Msa0JBQWtCLEVBQUU7Z0NBQ2xDcEIsSUFBSW1CLE9BQU8sQ0FBQ0Msa0JBQWtCLENBQUNOO2dDQUMvQlIsbUJBQW1COzRCQUNyQjt3QkFDRjtvQkFDRixFQUFFLE9BQU9lLE9BQU87d0JBQ2RMLFFBQVFLLEtBQUssQ0FBQyw0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QUN0QixJQUFJbkIsSUFBSW1CLE9BQU8sQ0FBQ0Msa0JBQWtCLEVBQUU7b0JBQ2xDcEIsSUFBSW1CLE9BQU8sQ0FBQ0Msa0JBQWtCLENBQUM7d0JBQUV1Qjt3QkFBT0M7b0JBQU07b0JBQzlDdEMsbUJBQW1CO2dCQUNyQjtZQUNGO1FBRUYsRUFBRSxPQUFPZSxPQUFPO1lBQ2RMLFFBQVFLLEtBQUssQ0FBQyw0QkFBNEJBO1lBQzFDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE9BQU87UUFBRXBCO1FBQVVpRDtJQUFlO0FBQ3BDLEVBQUU7R0FyT1duRCIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBjb25zdCB1c2VBZG1pblNldHRpbmdzID0gKHJlZikgPT4ge1xuICBjb25zdCBbc2V0dGluZ3MsIHNldFNldHRpbmdzXSA9IHVzZVN0YXRlKHt9KTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtpc1RvcEJhclVwZGF0ZWQsIHNldElzVG9wQmFyVXBkYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IGluaXRpYWxpemVkID0gdXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcG9sbGluZ0ludGVydmFsID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIEluaXRpYWxpemUgcG9sbGluZyBmb3Igc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoU2V0dGluZ3MgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRVc2VySWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke2N1cnJlbnRVc2VySWR9YCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHNldHRpbmdzJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0ZldGNoZWQgc2V0dGluZ3M6JywgbmV3U2V0dGluZ3MpO1xuICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBbY3VycmVudFVzZXJJZF06IG5ld1NldHRpbmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZpcnN0IHVwZGF0ZSB0b3BCYXIgdGhyb3VnaCByZWZcbiAgICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCkge1xuICAgICAgICAgIGlmIChyZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgICBzZXRJc1RvcEJhclVwZGF0ZWQodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEluaXRpYWwgZmV0Y2hcbiAgICBmZXRjaFNldHRpbmdzKCk7XG5cbiAgICAvLyBTZXQgdXAgcG9sbGluZyBpbnRlcnZhbFxuICAgIHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoZmV0Y2hTZXR0aW5ncywgMzAwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkLCByZWZdKTtcblxuICAvLyBFZmZlY3QgdG8gaGFuZGxlIGluZGV4LmpzIHVwZGF0ZSBhZnRlciB0b3BCYXIgaXMgdXBkYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1RvcEJhclVwZGF0ZWQpIHtcbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50IHRvIHVwZGF0ZSBpbmRleC5qc1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NldHRpbmdzVXBkYXRlZCcsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdHlwZTogJ3NldHRpbmdzJyxcbiAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtpc1RvcEJhclVwZGF0ZWQsIGN1cnJlbnRVc2VySWQsIHNldHRpbmdzXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2FkbWluU2V0dGluZ3MnKTtcbiAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFNldHRpbmdzID0gSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKTtcbiAgICAgICAgc2V0U2V0dGluZ3MocGFyc2VkU2V0dGluZ3MpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZSB3aGVuIHRoZXkgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGluaXRpYWxpemVkLmN1cnJlbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdhZG1pblNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2U6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnVzZXJJZCkge1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICAvLyBUcmlnZ2VyIGltbWVkaWF0ZSBzZXR0aW5ncyBmZXRjaCBmb3IgbmV3IHVzZXJcbiAgICAgICAgY29uc3QgZmV0Y2hTZXR0aW5ncyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke2V2ZW50LmRldGFpbC51c2VySWR9YCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzZXR0aW5ncycpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGVkIHNldHRpbmdzIGZvciBuZXcgdXNlcjonLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgIFtldmVudC5kZXRhaWwudXNlcklkXTogbmV3U2V0dGluZ3NcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlZiAmJiByZWYuY3VycmVudCAmJiByZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgcmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzZXR0aW5ncyBmb3IgbmV3IHVzZXI6JywgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZmV0Y2hTZXR0aW5ncygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3JlZl0pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlcyBmcm9tIGFkbWluIHBhZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzLCBkZWxheSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBpZiAodGltZXMgIT09IHVuZGVmaW5lZCB8fCBkZWxheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSB7XG4gICAgICAgICAgICB0aW1lczogdGltZXMgIT09IHVuZGVmaW5lZCA/IHRpbWVzIDogKHNldHRpbmdzW3VzZXJJZF0/LnRpbWVzIHx8IDEpLFxuICAgICAgICAgICAgZGVsYXk6IGRlbGF5ICE9PSB1bmRlZmluZWQgPyBkZWxheSA6IChzZXR0aW5nc1t1c2VySWRdPy5kZWxheSB8fCAzKVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgW3VzZXJJZF06IG5ld1NldHRpbmdzXG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgLy8gRmlyc3QgdXBkYXRlIHRvcEJhciB0aHJvdWdoIHJlZlxuICAgICAgICAgIGlmIChyZWYgJiYgcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlmIChyZWYuY3VycmVudC5zZXRDYXB0dXJlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgcmVmLmN1cnJlbnQuc2V0Q2FwdHVyZVNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNhdmUgdG8gYmFja2VuZFxuICAgICAgICAgIGNvbnN0IHNhdmVUb0JhY2tlbmQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkobmV3U2V0dGluZ3MpXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHNldHRpbmdzIHRvIGJhY2tlbmQnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQgdG8gYmFja2VuZDonLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgc2V0dGluZ3MgdG8gYmFja2VuZDonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBzYXZlVG9CYWNrZW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICB9O1xuICB9LCBbc2V0dGluZ3MsIHJlZl0pO1xuXG4gIGNvbnN0IHVwZGF0ZVNldHRpbmdzID0gYXN5bmMgKG5ld1NldHRpbmdzLCB1c2VySWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFuZXdTZXR0aW5ncyB8fCB0eXBlb2YgbmV3U2V0dGluZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXR0aW5ncyBmb3JtYXQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyB0aW1lcywgZGVsYXkgfSA9IG5ld1NldHRpbmdzO1xuICAgICAgaWYgKHR5cGVvZiB0aW1lcyAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRlbGF5ICE9PSAnbnVtYmVyJyB8fCB0aW1lcyA8IDEgfHwgZGVsYXkgPCAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXR0aW5ncyB2YWx1ZXMnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgICAuLi5zZXR0aW5ncyxcbiAgICAgICAgW3VzZXJJZF06IHtcbiAgICAgICAgICB0aW1lcyxcbiAgICAgICAgICBkZWxheVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZXRTZXR0aW5ncyh1cGRhdGVkU2V0dGluZ3MpO1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG5cbiAgICAgIC8vIFNhdmUgc2V0dGluZ3MgdG8gYmFja2VuZFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyB0aW1lcywgZGVsYXkgfSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHNhdmUgc2V0dGluZ3MgdG8gYmFja2VuZCcpO1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIHVwZGF0ZWQgYW5kIHNhdmVkOicsIHsgdXNlcklkLCB0aW1lcywgZGVsYXkgfSk7XG5cbiAgICAgIC8vIEZpcnN0IHVwZGF0ZSB0b3BCYXIgdGhyb3VnaCByZWZcbiAgICAgIGlmIChyZWYgJiYgcmVmLmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncykge1xuICAgICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyh7IHRpbWVzLCBkZWxheSB9KTtcbiAgICAgICAgICBzZXRJc1RvcEJhclVwZGF0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHsgc2V0dGluZ3MsIHVwZGF0ZVNldHRpbmdzIH07XG59OyJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUFkbWluU2V0dGluZ3MiLCJyZWYiLCJzZXR0aW5ncyIsInNldFNldHRpbmdzIiwiY3VycmVudFVzZXJJZCIsInNldEN1cnJlbnRVc2VySWQiLCJpc1RvcEJhclVwZGF0ZWQiLCJzZXRJc1RvcEJhclVwZGF0ZWQiLCJpbml0aWFsaXplZCIsInBvbGxpbmdJbnRlcnZhbCIsImZldGNoU2V0dGluZ3MiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsIm5ld1NldHRpbmdzIiwianNvbiIsImNvbnNvbGUiLCJsb2ciLCJwcmV2IiwiY3VycmVudCIsInNldENhcHR1cmVTZXR0aW5ncyIsImVycm9yIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiZXZlbnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsInR5cGUiLCJ1c2VySWQiLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50Iiwic2F2ZWRTZXR0aW5ncyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJwYXJzZWRTZXR0aW5ncyIsIkpTT04iLCJwYXJzZSIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJoYW5kbGVVc2VySWRDaGFuZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidGltZXMiLCJkZWxheSIsInVuZGVmaW5lZCIsInNhdmVUb0JhY2tlbmQiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsInVwZGF0ZVNldHRpbmdzIiwidXBkYXRlZFNldHRpbmdzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ })

});