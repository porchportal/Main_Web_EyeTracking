"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas1, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Memoize button configurations\n    // const buttons = useMemo(() => [\n    //   { \n    //     text: \"Set Random\", \n    //     abbreviatedText: \"SRandom\", \n    //     onClick: handleSetRandom,\n    //     disabled: isCapturing\n    //   },\n    //   { \n    //     text: \"Random Dot\", \n    //     abbreviatedText: \"Random\", \n    //     onClick: handleRandomDot,\n    //     disabled: isCapturing \n    //   },\n    //   { \n    //     text: \"Set Calibrate\", \n    //     abbreviatedText: \"Calibrate\", \n    //     onClick: handleSetCalibrate,\n    //     disabled: isCapturing \n    //   },\n    //   { \n    //     text: \"Clear All\", \n    //     abbreviatedText: \"Clear\", \n    //     onClick: handleClearAll\n    //   },\n    //   { divider: true },\n    //   { \n    //     text: \"Draw Head pose\", \n    //     abbreviatedText: \"Head pose\", \n    //     onClick: handleToggleHeadPose,\n    //     active: showHeadPose\n    //   },\n    //   { \n    //     text: \"Show Bounding Box\", \n    //     abbreviatedText: \"â˜ Box\", \n    //     onClick: handleToggleBoundingBox,\n    //     active: showBoundingBox\n    //   },\n    //   { \n    //     text: isCameraActive ? \"Stop Camera\" : \"Show Preview\", \n    //     abbreviatedText: isCameraActive ? \"Stop\" : \"Preview\", \n    //     onClick: () => {\n    //       if (!isCameraActive && !triggerCameraAccess(true)) {\n    //         setShowPermissionPopup(true);\n    //       } else {\n    //         handleToggleCamera();\n    //       }\n    //     },\n    //     active: isCameraActive,\n    //     disabled: isCapturing\n    //   },\n    //   { \n    //     text: \"ðŸ˜· Show Mask\", \n    //     abbreviatedText: \"ðŸ˜· Mask\", \n    //     onClick: handleToggleMask,\n    //     active: showMask\n    //   },\n    //   { \n    //     text: \"Parameters\", \n    //     abbreviatedText: \"Values\", \n    //     onClick: handleToggleParameters,\n    //     active: showParameters\n    //   }\n    // ], [isCapturing, showHeadPose, showBoundingBox, isCameraActive, showMask, showParameters]);\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    const initializeCanvas = (canvas, parent)=>{\n        if (!canvas || !parent) {\n            // console.warn('[initializeCanvas] Canvas or parent is null', { canvas, parent });\n            return false;\n        }\n        try {\n            // Set canvas dimensions to match parent\n            canvas.width = parent.clientWidth || 800;\n            canvas.height = parent.clientHeight || 600;\n            // Clear canvas and set white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // console.log(`Canvas initialized with dimensions: ${canvas.width}x${canvas.height}`);\n            return true;\n        } catch (error) {\n            console.error('[initializeCanvas] Error initializing canvas:', error);\n            return false;\n        }\n    };\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas1 = ()=>{\n        // Try multiple methods to find the canvas\n        if (canvasRef1.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef1.current;\n        }\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef1.current = window.whiteScreenCanvas;\n            return window.whiteScreenCanvas;\n        }\n        if (typeof document !== 'undefined') {\n            // Try multiple selectors to find the canvas\n            const selectors = [\n                '.tracking-canvas',\n                'canvas',\n                '#tracking-canvas'\n            ];\n            for (const selector of selectors){\n                const canvasElement = document.querySelector(selector);\n                if (canvasElement) {\n                    console.log(\"Found canvas via selector: \".concat(selector));\n                    canvasRef1.current = canvasElement;\n                    if (true) {\n                        window.whiteScreenCanvas = canvasElement;\n                    }\n                    return canvasElement;\n                }\n            }\n        }\n        console.error(\"No canvas found through any method\");\n        return null;\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        // First initialize with parent dimensions\n        const parent = canvas.parentElement || document.body;\n        initializeCanvas(canvas, parent);\n        // Then force fullscreen styling\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '5';\n        // Force dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear and prepare canvas again\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas set to fullscreen: \".concat(canvas.width, \"x\").concat(canvas.height));\n    };\n    const restoreCanvasSize = (canvas)=>{\n        // Restore original canvas styling\n        canvas.style.position = '';\n        canvas.style.top = '';\n        canvas.style.left = '';\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n        canvas.style.zIndex = '';\n        // Restore original dimensions\n        if (canvas.parentElement) {\n            initializeCanvas(canvas, canvas.parentElement);\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas, originalParent, originalStyle)=>{\n        if (!canvas || !originalParent) return;\n        // Append the canvas back to its original parent if needed\n        if (canvas.parentElement !== originalParent) {\n            originalParent.appendChild(canvas);\n        }\n        // Restore the inline styles saved earlier\n        canvas.style.position = originalStyle.position;\n        canvas.style.top = originalStyle.top;\n        canvas.style.left = originalStyle.left;\n        canvas.style.width = originalStyle.width;\n        canvas.style.height = originalStyle.height;\n        canvas.style.zIndex = originalStyle.zIndex;\n        // Reset the dimensions based on the parent element's size or fallback defaults\n        canvas.width = originalParent.clientWidth || 800;\n        canvas.height = originalParent.clientHeight || 600;\n        // Clear the canvas and fill with a white background\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas1();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ // Modified handleDotProcess function with improved dot and countdown alignment\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get canvas reference with retries\n            let canvas = null;\n            let retryCount = 0;\n            const maxRetries = 3;\n            while(!canvas && retryCount < maxRetries){\n                canvas = getMainCanvas1();\n                if (!canvas) {\n                    console.warn(\"Canvas not found, retry \".concat(retryCount + 1, \"/\").concat(maxRetries));\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    retryCount++;\n                }\n            }\n            if (!canvas) {\n                throw new Error(\"Canvas not available after multiple retries\");\n            }\n            // Save original state for restoration\n            const originalParent = canvas.parentElement;\n            const originalStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Prepare canvas for fullscreen display\n            document.body.appendChild(canvas);\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            // Clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            let keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            // Important: Position the countdown centered directly over the dot\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"âœ“\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Clear redraw interval\n            clearInterval(keepDotVisibleInterval);\n            // Restore canvas to original state\n            if (originalParent && canvas.parentElement !== originalParent) {\n                originalParent.appendChild(canvas);\n            }\n            canvas.style.position = originalStyle.position || '';\n            canvas.style.top = originalStyle.top || '';\n            canvas.style.left = originalStyle.left || '';\n            canvas.style.width = originalStyle.width || '100%';\n            canvas.style.height = originalStyle.height || '100%';\n            canvas.style.zIndex = originalStyle.zIndex || '';\n            // Reset dimensions\n            if (originalParent) {\n                canvas.width = originalParent.clientWidth || 800;\n                canvas.height = originalParent.clientHeight || 600;\n            }\n            // Clear canvas\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2000);\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            // Show TopBar again if there's an error\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas1();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"âœ“\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            // Restore canvas to original parent and styling - Only if canvas was successfully initialized\n            if (canvas) {\n                try {\n                    // Try to find original parent\n                    if (originalCanvasParent && canvas.parentElement !== originalCanvasParent) {\n                        originalCanvasParent.appendChild(canvas);\n                    } else if (!originalCanvasParent) {\n                        // Fallback to looking for a container element\n                        const possibleParent = document.querySelector('.canvas-container');\n                        if (possibleParent && canvas.parentElement !== possibleParent) {\n                            possibleParent.appendChild(canvas);\n                        }\n                    }\n                    // Restore styling\n                    canvas.style.position = originalCanvasStyle.position || '';\n                    canvas.style.top = originalCanvasStyle.top || '';\n                    canvas.style.left = originalCanvasStyle.left || '';\n                    canvas.style.width = originalCanvasStyle.width || '100%';\n                    canvas.style.height = originalCanvasStyle.height || '100%';\n                    canvas.style.zIndex = originalCanvasStyle.zIndex || '';\n                    // Reset dimensions based on parent\n                    const parent = canvas.parentElement;\n                    if (parent) {\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                    } else {\n                        canvas.width = 800;\n                        canvas.height = 600;\n                    }\n                    // Clear canvas with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas restored to original state\");\n                } catch (e) {\n                    console.error(\"Error restoring canvas:\", e);\n                }\n            }\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Wait for canvas to be ready\n            let canvas = null;\n            let retryCount = 0;\n            const maxRetries = 5;\n            while(!canvas && retryCount < maxRetries){\n                canvas = getMainCanvas1();\n                if (!canvas) {\n                    console.log(\"Waiting for canvas... attempt \".concat(retryCount + 1, \"/\").concat(maxRetries));\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    retryCount++;\n                }\n            }\n            if (!canvas) {\n                throw new Error(\"Canvas not available after multiple retries\");\n            }\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        // Use the consolidated function with random position\n        await handleDotProcess({\n            useRandomPosition: true,\n            onStatusUpdate: (status)=>{\n                if (status.processStatus) setProcessStatus(status.processStatus);\n                if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n            },\n            toggleTopBar: (show)=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', show);\n                }\n            },\n            triggerCameraAccess,\n            setIsCapturing,\n            captureCount,\n            setCaptureCount: setCaptureCount,\n            postCountdownDelay: 1000\n        });\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas1();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        clearCanvas();\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1439,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1438,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1443,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1442,\n                columnNumber: 9\n            }, undefined),\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"ActionButtonGroupInner.useMemo\": ()=>(processStatus || remainingCaptures > 0 || countdownValue) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"status-display mt-4 p-2 bg-blue-50 rounded-md\",\n                        children: [\n                            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-blue-800\",\n                                children: processStatus\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1452,\n                                columnNumber: 15\n                            }, undefined),\n                            remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-yellow-600\",\n                                children: [\n                                    \"Remaining: \",\n                                    remainingCaptures\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1455,\n                                columnNumber: 15\n                            }, undefined),\n                            countdownValue && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-2xl font-bold text-red-600\",\n                                children: countdownValue\n                            }, void 0, false, {\n                                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1458,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1450,\n                        columnNumber: 11\n                    }, undefined)\n            }[\"ActionButtonGroupInner.useMemo\"], [\n                processStatus,\n                remainingCaptures,\n                countdownValue\n            ]),\n            showCanvas1 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"canvas-container mt-4\",\n                style: {\n                    position: 'relative',\n                    width: '100%',\n                    height: '40vh',\n                    minHeight: '300px',\n                    border: '1px solid #e0e0e0',\n                    backgroundColor: 'white',\n                    borderRadius: '4px',\n                    overflow: 'hidden'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                        ref: canvasRef1,\n                        className: \"tracking-canvas\",\n                        id: \"tracking-canvas\",\n                        style: {\n                            width: '100%',\n                            height: '100%',\n                            display: 'block',\n                            position: 'absolute',\n                            top: 0,\n                            left: 0\n                        },\n                        onLoad: (e)=>{\n                            const canvas = e.target;\n                            if (canvas) {\n                                canvasRef1.current = canvas;\n                                if (true) {\n                                    window.whiteScreenCanvas = canvas;\n                                }\n                                // Initialize canvas with white background\n                                const ctx = canvas.getContext('2d');\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                            }\n                        }\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1479,\n                        columnNumber: 11\n                    }, undefined),\n                    countdownValue && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"dot-countdown\",\n                        style: {\n                            position: 'absolute',\n                            left: \"\".concat(currentDot.x - 15, \"px\"),\n                            top: \"\".concat(currentDot.y - 40, \"px\"),\n                            color: 'red',\n                            fontSize: '28px',\n                            fontWeight: 'bold'\n                        },\n                        children: countdownValue\n                    }, void 0, false, {\n                        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1508,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1466,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1552,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1562,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1580,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1593,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1572,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1542,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1527,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1436,\n        columnNumber: 5\n    }, undefined);\n}, \"HJt9EyoiQgJ9MXgzyruz0YP98Dc=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1615,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\n// Add this useEffect for canvas initialization\n(0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n    const initializeCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (canvas) {\n            // Set canvas dimensions\n            const container = canvas.parentElement;\n            if (container) {\n                canvas.width = container.clientWidth;\n                canvas.height = container.clientHeight;\n                // Initialize with white background\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                // Store reference\n                canvasRef.current = canvas;\n                if (true) {\n                    window.whiteScreenCanvas = canvas;\n                }\n            }\n        }\n    };\n    // Initial initialization\n    initializeCanvas();\n    // Add resize handler\n    const handleResize = ()=>{\n        initializeCanvas();\n    };\n    window.addEventListener('resize', handleResize);\n    return ()=>window.removeEventListener('resize', handleResize);\n}, [\n    showCanvas\n]); // Re-run when showCanvas changes\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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TixvQkFBUSw4REFBQ0Q7WUFBd0IsR0FBR29OLEtBQUs7WUFBRW5OLEtBQUtBOzs7Ozt5QkFDbEU7SUFBRW9OLEtBQUs7QUFBTTs7QUFDaEIsb0RBQW9EO0FBQ3BELG9HQUFvRztBQUVwRywrQkFBK0I7QUFDaEIsU0FBU0M7SUFDdEIsT0FBTyxNQUFNLDhEQUE4RDtBQUM3RTtNQUZ3QkE7QUFJbUI7QUFFM0MsK0NBQStDO0FBQy9DdFIsZ0RBQVNBLENBQUM7SUFDUixNQUFNMEksbUJBQW1CO1FBQ3ZCLE1BQU1DLFNBQVNXO1FBQ2YsSUFBSVgsUUFBUTtZQUNWLHdCQUF3QjtZQUN4QixNQUFNNEksWUFBWTVJLE9BQU9pQixhQUFhO1lBQ3RDLElBQUkySCxXQUFXO2dCQUNiNUksT0FBT3hGLEtBQUssR0FBR29PLFVBQVUxSSxXQUFXO2dCQUNwQ0YsT0FBT0csTUFBTSxHQUFHeUksVUFBVXhJLFlBQVk7Z0JBRXRDLG1DQUFtQztnQkFDbkMsTUFBTUMsTUFBTUwsT0FBT00sVUFBVSxDQUFDO2dCQUM5QkQsSUFBSUcsU0FBUyxHQUFHO2dCQUNoQkgsSUFBSUksUUFBUSxDQUFDLEdBQUcsR0FBR1QsT0FBT3hGLEtBQUssRUFBRXdGLE9BQU9HLE1BQU07Z0JBRTlDLGtCQUFrQjtnQkFDbEJuRSxVQUFVa0MsT0FBTyxHQUFHOEI7Z0JBQ3BCLElBQUksSUFBNkIsRUFBRTtvQkFDakN2RixPQUFPbUcsaUJBQWlCLEdBQUdaO2dCQUM3QjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLHlCQUF5QjtJQUN6QkQ7SUFFQSxxQkFBcUI7SUFDckIsTUFBTTFGLGVBQWU7UUFDbkIwRjtJQUNGO0lBRUF0RixPQUFPRSxnQkFBZ0IsQ0FBQyxVQUFVTjtJQUNsQyxPQUFPLElBQU1JLE9BQU9HLG1CQUFtQixDQUFDLFVBQVVQO0FBQ3BELEdBQUc7SUFBQ3NDO0NBQVcsR0FBRyxpQ0FBaUMiLCJzb3VyY2VzIjpbIi9hcHAvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9hY3Rpb25CdXR0b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgXG4gIHNob3dDYXB0dXJlUHJldmlldywgXG4gIGRyYXdSZWREb3QsIFxuICBnZXRSYW5kb21Qb3NpdGlvbixcbiAgY3JlYXRlQ291bnRkb3duRWxlbWVudCxcbiAgcnVuQ291bnRkb3duXG59IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZSc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG5pbXBvcnQgeyB1c2VBZG1pblNldHRpbmdzIH0gZnJvbSAnLi9hZG1pblNldHRpbmdzJztcblxuLy8gQWRkIGRlZXAgY29tcGFyaXNvbiB1dGlsaXR5XG5jb25zdCBpc0VxdWFsID0gKG9iajEsIG9iajIpID0+IHtcbiAgaWYgKG9iajEgPT09IG9iajIpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iajEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmoyICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSA9PT0gbnVsbCB8fCBvYmoyID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIFxuICByZXR1cm4ga2V5czEuZXZlcnkoa2V5ID0+IFxuICAgIGtleXMyLmluY2x1ZGVzKGtleSkgJiYgaXNFcXVhbChvYmoxW2tleV0sIG9iajJba2V5XSlcbiAgKTtcbn07XG5cbi8vIENyZWF0ZSBhIGJhc2ljIEFjdGlvbkJ1dHRvbiBjb21wb25lbnQgd2l0aCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbiA9ICh7IHRleHQsIGFiYnJldmlhdGVkVGV4dCwgb25DbGljaywgY3VzdG9tQ2xhc3MgPSAnJywgZGlzYWJsZWQgPSBmYWxzZSwgYWN0aXZlID0gZmFsc2UgfSkgPT4ge1xuICBjb25zdCBbaXNBYmJyZXZpYXRlZCwgc2V0SXNBYmJyZXZpYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MoKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnRlciwgc2V0Q2FwdHVyZUNvdW50ZXJdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtwcm9jZXNzU3RhdHVzLCBzZXRQcm9jZXNzU3RhdHVzXSA9IHVzZVN0YXRlKCcnKTtcblxuICAvLyBNZW1vaXplIGJ1dHRvbiBwcm9wcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcbiAgY29uc3QgYnV0dG9uUHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2xhc3NOYW1lOiBgYWN0aW9uLWJ1dHRvbiAke2N1c3RvbUNsYXNzfSAke2lzQWJicmV2aWF0ZWQgPyAnYWJicmV2aWF0ZWQnIDogJyd9ICR7YWN0aXZlID8gJ2FjdGl2ZScgOiAnJ31gLFxuICAgIG9uQ2xpY2ssXG4gICAgZGlzYWJsZWQsXG4gICAgdGl0bGU6IHRleHRcbiAgfSksIFtjdXN0b21DbGFzcywgaXNBYmJyZXZpYXRlZCwgYWN0aXZlLCBvbkNsaWNrLCBkaXNhYmxlZCwgdGV4dF0pO1xuXG4gIC8vIENoZWNrIHdpbmRvdyBzaXplIGFuZCBzZXQgYWJicmV2aWF0ZWQgbW9kZSB3aXRoIGRlYm91bmNlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBzZXRJc0FiYnJldmlhdGVkKHdpZHRoIDwgNzY4KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfTtcbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICBoYW5kbGVSZXNpemUoKTsgLy8gSW5pdGlhbCBjYWxsXG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEFkZCBlZmZlY3QgdG8gbGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXMgd2l0aCBvcHRpbWl6YXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIGlmIChuZXdVc2VySWQgIT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIHsuLi5idXR0b25Qcm9wc30+XG4gICAgICB7aXNBYmJyZXZpYXRlZCA/IGFiYnJldmlhdGVkVGV4dCA6IHRleHR9XG4gICAgICB7cHJvY2Vzc1N0YXR1cyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvY2Vzcy1zdGF0dXNcIj5cbiAgICAgICAgICB7cHJvY2Vzc1N0YXR1c31cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBBY3Rpb25CdXR0b25Hcm91cCBjb21wb25lbnQgd2l0aCBjbGllbnQtc2lkZSBvbmx5IHJlbmRlcmluZyBhbmQgb3B0aW1pemF0aW9uXG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cElubmVyID0gZm9yd2FyZFJlZigoeyB0cmlnZ2VyQ2FtZXJhQWNjZXNzLCBpc0NvbXBhY3RNb2RlLCBvbkFjdGlvbkNsaWNrIH0sIHJlZikgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MocmVmKTtcbiAgXG4gIC8vIFN0YXRlIGZvciBidXR0b24gYWN0aW9uc1xuICBjb25zdCBbcmFuZG9tVGltZXMsIHNldFJhbmRvbVRpbWVzXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbZGVsYXlTZWNvbmRzLCBzZXREZWxheVNlY29uZHNdID0gdXNlU3RhdGUoMyk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbY291bnRkb3duVmFsdWUsIHNldENvdW50ZG93blZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY3VycmVudERvdCwgc2V0Q3VycmVudERvdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NhbGlicmF0aW9uUG9pbnRzLCBzZXRDYWxpYnJhdGlvblBvaW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtjdXJyZW50Q2FsaWJyYXRpb25JbmRleCwgc2V0Q3VycmVudENhbGlicmF0aW9uSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtyZW1haW5pbmdDYXB0dXJlcywgc2V0UmVtYWluaW5nQ2FwdHVyZXNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtzaG93Q2FudmFzLCBzZXRTaG93Q2FudmFzXSA9IHVzZVN0YXRlKHRydWUpO1xuICBcbiAgLy8gVHJhY2sgdGhlIGNhcHR1cmUgY291bnRcbiAgY29uc3QgW2NhbGlicmF0aW9uSGFuZGxlciwgc2V0Q2FsaWJyYXRpb25IYW5kbGVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FwdHVyZUNvdW50LCBzZXRDYXB0dXJlQ291bnRdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gVG9nZ2xlIHN0YXRlc1xuICBjb25zdCBbc2hvd0hlYWRQb3NlLCBzZXRTaG93SGVhZFBvc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0JvdW5kaW5nQm94LCBzZXRTaG93Qm91bmRpbmdCb3hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd01hc2ssIHNldFNob3dNYXNrXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQYXJhbWV0ZXJzLCBzZXRTaG93UGFyYW1ldGVyc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0NhbWVyYUFjdGl2ZSwgc2V0SXNDYW1lcmFBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1Blcm1pc3Npb25Qb3B1cCwgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCdkZWZhdWx0Jyk7XG5cbiAgLy8gQWRkIGNhY2hlIGZvciBzZXR0aW5nc1xuICBjb25zdCBzZXR0aW5nc0NhY2hlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IGxhc3RTZXR0aW5nc1VwZGF0ZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIGNvbmZpZ3VyYXRpb25zXG4gIC8vIGNvbnN0IGJ1dHRvbnMgPSB1c2VNZW1vKCgpID0+IFtcbiAgLy8gICB7IFxuICAvLyAgICAgdGV4dDogXCJTZXQgUmFuZG9tXCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIlNSYW5kb21cIiwgXG4gIC8vICAgICBvbkNsaWNrOiBoYW5kbGVTZXRSYW5kb20sXG4gIC8vICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmdcbiAgLy8gICB9LFxuICAvLyAgIHsgXG4gIC8vICAgICB0ZXh0OiBcIlJhbmRvbSBEb3RcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiUmFuZG9tXCIsIFxuICAvLyAgICAgb25DbGljazogaGFuZGxlUmFuZG9tRG90LFxuICAvLyAgICAgZGlzYWJsZWQ6IGlzQ2FwdHVyaW5nIFxuICAvLyAgIH0sXG4gIC8vICAgeyBcbiAgLy8gICAgIHRleHQ6IFwiU2V0IENhbGlicmF0ZVwiLCBcbiAgLy8gICAgIGFiYnJldmlhdGVkVGV4dDogXCJDYWxpYnJhdGVcIiwgXG4gIC8vICAgICBvbkNsaWNrOiBoYW5kbGVTZXRDYWxpYnJhdGUsXG4gIC8vICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmcgXG4gIC8vICAgfSxcbiAgLy8gICB7IFxuICAvLyAgICAgdGV4dDogXCJDbGVhciBBbGxcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiQ2xlYXJcIiwgXG4gIC8vICAgICBvbkNsaWNrOiBoYW5kbGVDbGVhckFsbFxuICAvLyAgIH0sXG4gIC8vICAgeyBkaXZpZGVyOiB0cnVlIH0sXG4gIC8vICAgeyBcbiAgLy8gICAgIHRleHQ6IFwiRHJhdyBIZWFkIHBvc2VcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiSGVhZCBwb3NlXCIsIFxuICAvLyAgICAgb25DbGljazogaGFuZGxlVG9nZ2xlSGVhZFBvc2UsXG4gIC8vICAgICBhY3RpdmU6IHNob3dIZWFkUG9zZVxuICAvLyAgIH0sXG4gIC8vICAgeyBcbiAgLy8gICAgIHRleHQ6IFwiU2hvdyBCb3VuZGluZyBCb3hcIiwgXG4gIC8vICAgICBhYmJyZXZpYXRlZFRleHQ6IFwi4piQIEJveFwiLCBcbiAgLy8gICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94LFxuICAvLyAgICAgYWN0aXZlOiBzaG93Qm91bmRpbmdCb3hcbiAgLy8gICB9LFxuICAvLyAgIHsgXG4gIC8vICAgICB0ZXh0OiBpc0NhbWVyYUFjdGl2ZSA/IFwiU3RvcCBDYW1lcmFcIiA6IFwiU2hvdyBQcmV2aWV3XCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBpc0NhbWVyYUFjdGl2ZSA/IFwiU3RvcFwiIDogXCJQcmV2aWV3XCIsIFxuICAvLyAgICAgb25DbGljazogKCkgPT4ge1xuICAvLyAgICAgICBpZiAoIWlzQ2FtZXJhQWN0aXZlICYmICF0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpKSB7XG4gIC8vICAgICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgLy8gICAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgICBoYW5kbGVUb2dnbGVDYW1lcmEoKTtcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfSxcbiAgLy8gICAgIGFjdGl2ZTogaXNDYW1lcmFBY3RpdmUsXG4gIC8vICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmdcbiAgLy8gICB9LFxuICAvLyAgIHsgXG4gIC8vICAgICB0ZXh0OiBcIvCfmLcgU2hvdyBNYXNrXCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIvCfmLcgTWFza1wiLCBcbiAgLy8gICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZU1hc2ssXG4gIC8vICAgICBhY3RpdmU6IHNob3dNYXNrXG4gIC8vICAgfSxcbiAgLy8gICB7IFxuICAvLyAgICAgdGV4dDogXCJQYXJhbWV0ZXJzXCIsIFxuICAvLyAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIlZhbHVlc1wiLCBcbiAgLy8gICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMsXG4gIC8vICAgICBhY3RpdmU6IHNob3dQYXJhbWV0ZXJzXG4gIC8vICAgfVxuICAvLyBdLCBbaXNDYXB0dXJpbmcsIHNob3dIZWFkUG9zZSwgc2hvd0JvdW5kaW5nQm94LCBpc0NhbWVyYUFjdGl2ZSwgc2hvd01hc2ssIHNob3dQYXJhbWV0ZXJzXSk7XG5cbiAgLy8gT3B0aW1pemUgc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdKSB7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldChjdXJyZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc0VxdWFsKGNhY2hlZFNldHRpbmdzLCB1c2VyU2V0dGluZ3MpKSB7XG4gICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgbmV3IHVzZXJcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzW25ld1VzZXJJZF0pIHtcbiAgICAgICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tuZXdVc2VySWRdO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzX3NldF9yYW5kb20sIGRlbGF5X3NldF9yYW5kb20gfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGlmICh0aW1lc19zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVzID0gTnVtYmVyKHRpbWVzX3NldF9yYW5kb20pIHx8IDE7XG4gICAgICAgICAgICBzZXRSYW5kb21UaW1lcyhuZXdUaW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWxheV9zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlbGF5ID0gTnVtYmVyKGRlbGF5X3NldF9yYW5kb20pIHx8IDM7XG4gICAgICAgICAgICBzZXREZWxheVNlY29uZHMobmV3RGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTWFrZSBmdW5jdGlvbnMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBhcyBhIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zID0ge1xuICAgICAgICBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSxcbiAgICAgICAgaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAgICAgICBoYW5kbGVDbGVhckFsbFxuICAgICAgfTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9uIGZ1bmN0aW9ucyBleHBvc2VkIHRvIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucztcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGdldCBjb250cm9sIHZhbHVlcyBmcm9tIFRvcEJhclxuICAgIGNvbnN0IHVwZGF0ZUNvbnRyb2xWYWx1ZXMgPSAoKSA9PiB7XG4gICAgICAvLyBHZXQgdGhlIHRpbWUgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICBjb25zdCB0aW1lVmFsdWUgPSBwYXJzZUludCh0aW1lSW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTih0aW1lVmFsdWUpICYmIHRpbWVWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgcmFuZG9tVGltZXMgdG86JywgdGltZVZhbHVlKTtcbiAgICAgICAgICBzZXRSYW5kb21UaW1lcyh0aW1lVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgZGVsYXkgaW5wdXQgZWxlbWVudFxuICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBjb25zdCBkZWxheVZhbHVlID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKGRlbGF5VmFsdWUpICYmIGRlbGF5VmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIGRlbGF5U2Vjb25kcyB0bzonLCBkZWxheVZhbHVlKTtcbiAgICAgICAgICBzZXREZWxheVNlY29uZHMoZGVsYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIGNvbnRyb2wgaW5wdXRzXG4gICAgY29uc3QgdGltZUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwidGltZVwiXScpO1xuICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgIFxuICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIHRpbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpOyAvLyBBbHNvIGxpc3RlbiBmb3IgaW5wdXQgZXZlbnRzXG4gICAgfVxuICAgIFxuICAgIC8vIEluaXRpYWwgdXBkYXRlXG4gICAgdXBkYXRlQ29udHJvbFZhbHVlcygpO1xuICAgIFxuICAgIC8vIENsZWFudXAgZXZlbnQgbGlzdGVuZXJzXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgZGVsYXlJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTtcblxuICBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkge1xuICAgICAgLy8gY29uc29sZS53YXJuKCdbaW5pdGlhbGl6ZUNhbnZhc10gQ2FudmFzIG9yIHBhcmVudCBpcyBudWxsJywgeyBjYW52YXMsIHBhcmVudCB9KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyBhbmQgc2V0IHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gY29uc29sZS5sb2coYENhbnZhcyBpbml0aWFsaXplZCB3aXRoIGRpbWVuc2lvbnM6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW2luaXRpYWxpemVDYW52YXNdIEVycm9yIGluaXRpYWxpemluZyBjYW52YXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBtYWluIGNhbnZhcyAtIGltcHJvdmVkIHRvIGJlIG1vcmUgcmVsaWFibGVcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICAvLyBUcnkgbXVsdGlwbGUgbWV0aG9kcyB0byBmaW5kIHRoZSBjYW52YXNcbiAgICBpZiAoY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZGlyZWN0IGNhbnZhc1JlZi5jdXJyZW50IHJlZmVyZW5jZVwiKTtcbiAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcykge1xuICAgICAgY29uc29sZS5sb2coXCJVc2luZyBnbG9iYWwgd2hpdGVTY3JlZW5DYW52YXMgcmVmZXJlbmNlXCIpO1xuICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgICByZXR1cm4gd2luZG93LndoaXRlU2NyZWVuQ2FudmFzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUcnkgbXVsdGlwbGUgc2VsZWN0b3JzIHRvIGZpbmQgdGhlIGNhbnZhc1xuICAgICAgY29uc3Qgc2VsZWN0b3JzID0gWycudHJhY2tpbmctY2FudmFzJywgJ2NhbnZhcycsICcjdHJhY2tpbmctY2FudmFzJ107XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIHNlbGVjdG9ycykge1xuICAgICAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgIGlmIChjYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGNhbnZhcyB2aWEgc2VsZWN0b3I6ICR7c2VsZWN0b3J9YCk7XG4gICAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSBjYW52YXNFbGVtZW50O1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5lcnJvcihcIk5vIGNhbnZhcyBmb3VuZCB0aHJvdWdoIGFueSBtZXRob2RcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0IG1ha2VDYW52YXNGdWxsc2NyZWVuID0gKGNhbnZhcykgPT4ge1xuICAgIC8vIEZpcnN0IGluaXRpYWxpemUgd2l0aCBwYXJlbnQgZGltZW5zaW9uc1xuICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXMsIHBhcmVudCk7XG4gICAgXG4gICAgLy8gVGhlbiBmb3JjZSBmdWxsc2NyZWVuIHN0eWxpbmdcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzUnO1xuICAgIFxuICAgIC8vIEZvcmNlIGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciBhbmQgcHJlcGFyZSBjYW52YXMgYWdhaW5cbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYENhbnZhcyBzZXQgdG8gZnVsbHNjcmVlbjogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgfTtcbiAgY29uc3QgcmVzdG9yZUNhbnZhc1NpemUgPSAoY2FudmFzKSA9PiB7XG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBjYW52YXMgc3R5bGluZ1xuICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnJztcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcnO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnJztcbiAgICBcbiAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGRpbWVuc2lvbnNcbiAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIGluaXRpYWxpemVDYW52YXMoY2FudmFzLCBjYW52YXMucGFyZW50RWxlbWVudCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBpZiAodHJpZ2dlckNhbWVyYUFjY2Vzcykge1xuICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGFuZGxlciB0byBjYW5jZWwgcGVybWlzc2lvbiBwb3B1cFxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uRGVuaWVkID0gKCkgPT4ge1xuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICB9O1xuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byByZXN0b3JlIHRoZSBjYW52YXMgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGluZ1xuICBjb25zdCByZXN0b3JlQ2FudmFzID0gKGNhbnZhcywgb3JpZ2luYWxQYXJlbnQsIG9yaWdpbmFsU3R5bGUpID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhb3JpZ2luYWxQYXJlbnQpIHJldHVybjtcblxuICAgIC8vIEFwcGVuZCB0aGUgY2FudmFzIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHBhcmVudCBpZiBuZWVkZWRcbiAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IG9yaWdpbmFsUGFyZW50KSB7XG4gICAgICBvcmlnaW5hbFBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXN0b3JlIHRoZSBpbmxpbmUgc3R5bGVzIHNhdmVkIGVhcmxpZXJcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbFN0eWxlLnBvc2l0aW9uO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbFN0eWxlLnRvcDtcbiAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsU3R5bGUubGVmdDtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbFN0eWxlLndpZHRoO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbFN0eWxlLmhlaWdodDtcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gb3JpZ2luYWxTdHlsZS56SW5kZXg7XG4gICAgXG4gICAgLy8gUmVzZXQgdGhlIGRpbWVuc2lvbnMgYmFzZWQgb24gdGhlIHBhcmVudCBlbGVtZW50J3Mgc2l6ZSBvciBmYWxsYmFjayBkZWZhdWx0c1xuICAgIGNhbnZhcy53aWR0aCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgY2FudmFzIGFuZCBmaWxsIHdpdGggYSB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9O1xuXG5cbiAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICBjb25zdCBjbGVhckNhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCBmb3IgY2xlYXJpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICB9O1xuICAvLyBBZGQgdGhpcyBmdW5jdGlvbiB0byBhY3Rpb25CdXR0b24uanNcblxuICAvKipcbiAgICogQ29uc29saWRhdGVkIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyB0aGUgZW50aXJlIGRvdCBwcm9jZXNzOiBkcmF3aW5nLCBjb3VudGRvd24sIGNhcHR1cmUsIGFuZCBwcmV2aWV3XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IGNvb3JkaW5hdGVzIHdoZXJlIHRvIGRyYXcgdGhlIGRvdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU3RhdHVzVXBkYXRlIC0gQ2FsbGJhY2sgZm9yIHN0YXR1cyB1cGRhdGVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRyaWdnZXJDYW1lcmFBY2Nlc3MgLSBGdW5jdGlvbiB0byBlbnN1cmUgY2FtZXJhIGlzIGF2YWlsYWJsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldElzQ2FwdHVyaW5nIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmluZyBzdGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnQgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudCAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy51c2VSYW5kb21Qb3NpdGlvbiAtIFdoZXRoZXIgdG8gZ2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb25cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZSBkYXRhXG4gICAqL1xuICAvLyBNb2RpZmllZCBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggaW1wcm92ZWQgZG90IGFuZCBjb3VudGRvd24gYWxpZ25tZW50XG4gIGNvbnN0IGhhbmRsZURvdFByb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICB1c2VSYW5kb21Qb3NpdGlvbiA9IGZhbHNlLFxuICAgICAgcG9zdENvdW50ZG93bkRlbGF5ID0gNTAwIFxuICAgIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHNob3dpbmcgdGhlIGRvdFxuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZVxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiB1c2VSYW5kb21Qb3NpdGlvbiA/ICdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nIDogJ1N0YXJ0aW5nIGRvdCBwcm9jZXNzLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlIHdpdGggcmV0cmllc1xuICAgICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gMztcbiAgICAgIFxuICAgICAgd2hpbGUgKCFjYW52YXMgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FudmFzIG5vdCBmb3VuZCwgcmV0cnkgJHtyZXRyeUNvdW50ICsgMX0vJHttYXhSZXRyaWVzfWApO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICByZXRyeUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgYWZ0ZXIgbXVsdGlwbGUgcmV0cmllc1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZSBmb3IgcmVzdG9yYXRpb25cbiAgICAgIGNvbnN0IG9yaWdpbmFsUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBvcmlnaW5hbFN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcblxuICAgICAgLy8gUHJlcGFyZSBjYW52YXMgZm9yIGZ1bGxzY3JlZW4gZGlzcGxheVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgXG4gICAgICAvLyBTZXQgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3cgZXhhY3RseVxuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgICAgY29uc3QgZG90UG9zaXRpb24gPSB1c2VSYW5kb21Qb3NpdGlvbiBcbiAgICAgICAgPyBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKSBcbiAgICAgICAgOiBwb3NpdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKCFkb3RQb3NpdGlvbiB8fCB0eXBlb2YgZG90UG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDEyO1xuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSByZWRyYXcgaW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICBsZXQga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgfSwgNTApOyAgLy8gTW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJpbGl0eVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBjb3VudGRvd24gZWxlbWVudCBkaXJlY3RseSBvbiB0b3Agb2YgdGhlIGRvdFxuICAgICAgLy8gSW1wb3J0YW50OiBQb3NpdGlvbiB0aGUgY291bnRkb3duIGNlbnRlcmVkIGRpcmVjdGx5IG92ZXIgdGhlIGRvdFxuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgbGVmdDogJHtkb3RQb3NpdGlvbi54fXB4O1xuICAgICAgICB0b3A6ICR7ZG90UG9zaXRpb24ueX1weDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRyYXcgdGhlIGRvdCBmb3IgcmVsaWFiaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkaXRpb25hbCByZWRyYXcgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgYWZ0ZXIgY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHBvc3RDb3VudGRvd25EZWxheSkpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgIHBvaW50OiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgY2xlYXJJbnRlcnZhbChrZWVwRG90VmlzaWJsZUludGVydmFsKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBjYW52YXMgdG8gb3JpZ2luYWwgc3RhdGVcbiAgICAgIGlmIChvcmlnaW5hbFBhcmVudCAmJiBjYW52YXMucGFyZW50RWxlbWVudCAhPT0gb3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgICAgb3JpZ2luYWxQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxTdHlsZS5wb3NpdGlvbiB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbFN0eWxlLnRvcCB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gb3JpZ2luYWxTdHlsZS5sZWZ0IHx8ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gb3JpZ2luYWxTdHlsZS53aWR0aCB8fCAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxTdHlsZS5oZWlnaHQgfHwgJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IG9yaWdpbmFsU3R5bGUuekluZGV4IHx8ICcnO1xuICAgICAgXG4gICAgICAvLyBSZXNldCBkaW1lbnNpb25zXG4gICAgICBpZiAob3JpZ2luYWxQYXJlbnQpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWxQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0NhcHR1cmUgY29tcGxldGVkJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAyMDAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IGRvdFBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlUmVzdWx0XG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBoYW5kbGVEb3RQcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICBcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIERlY2xhcmUgdGhlc2UgdmFyaWFibGVzIE9VVFNJREUgdGhlIHRyeSBibG9ja1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1BhcmVudCA9IG51bGw7XG4gICAgbGV0IG9yaWdpbmFsQ2FudmFzU3R5bGUgPSB7fTtcbiAgICBsZXQgc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICAvLyBIaWRlIFRvcEJhclxuICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIlN0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlXG4gICAgICBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKFwiRXJyb3I6IENhbnZhcyBub3QgZm91bmRcIik7XG4gICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGVcbiAgICAgIG9yaWdpbmFsQ2FudmFzUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBvcmlnaW5hbENhbnZhc1N0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTW92ZSBjYW52YXMgdG8gYm9keSBmb3IgbWF4aW11bSByZWxpYWJpbGl0eVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgXG4gICAgICAvLyBNYWtlIGNhbnZhcyBmdWxsc2NyZWVuIHdpdGggZml4ZWQgcG9zaXRpb25pbmdcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgIFxuICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93IGV4YWN0bHlcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgc2V0IHRvIGZ1bGxzY3JlZW46ICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcblxuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIHRoZSBjYW52YXMgc2l6ZVxuICAgICAgY29uc3QgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJyk7XG4gICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgXG4gICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgIHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgcmVkcmF3IGludGVydmFsXG4gICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBkaXNwbGF5c1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGNhbnZhcyBpZiBkaW1lbnNpb25zIGNoYW5nZWRcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYW52YXMgZGltZW5zaW9ucyBjaGFuZ2VkLiBSZXNldHRpbmcgdG8gJHtjYW52YXNXaWR0aH14JHtjYW52YXNIZWlnaHR9YCk7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5IGFuZCBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBjb25zdCByYWRpdXMgPSAxNDsgLy8gU2xpZ2h0bHkgbGFyZ2VyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGZ1bmN0aW9uIGZvciB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHJlZHJhd0N1cnJlbnREb3QgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVmVyaWZ5IGNhbnZhcyBkaW1lbnNpb25zIGFuZCBwYXJlbnRcbiAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGJvZHlcbiAgICAgICAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVkcmF3IGRvdCB3aXRob3V0IGNsZWFyaW5nXG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgcmVkcmF3IGludGVydmFsIC0gbW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJsZSBkb3QgdmlzaWJpbGl0eVxuICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChyZWRyYXdDdXJyZW50RG90LCA1MCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7IC8vIENvbnNpc3RlbnQgY2xhc3MgbmFtZVxuICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIGxlZnQ6ICR7cG9pbnQueH1weDtcbiAgICAgICAgICB0b3A6ICR7cG9pbnQueSAtIDYwfXB4O1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3IG11bHRpcGxlIHRpbWVzIGR1cmluZyBjb3VudGRvd24gdG8gZW5zdXJlIHZpc2liaWxpdHlcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0IHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuXG4gICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtwb2ludC54fSwgJHtwb2ludC55fSlgKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYW51YWwgZm9yY2UgcmVkcmF3IG9uZSBtb3JlIHRpbWUganVzdCBiZWZvcmUgY2FwdHVyZVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIENsZWFuIHVwIGNvdW50ZG93biBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgIH1cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbGlicmF0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCByZWRyYXcgaW50ZXJ2YWxcbiAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZW1vdmUgc3RhdHVzIGluZGljYXRvciBpZiBpdCBleGlzdHNcbiAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IgJiYgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgY2FudmFzIHRvIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGluZyAtIE9ubHkgaWYgY2FudmFzIHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWRcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBvcmlnaW5hbCBwYXJlbnRcbiAgICAgICAgICBpZiAob3JpZ2luYWxDYW52YXNQYXJlbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IG9yaWdpbmFsQ2FudmFzUGFyZW50KSB7XG4gICAgICAgICAgICBvcmlnaW5hbENhbnZhc1BhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW9yaWdpbmFsQ2FudmFzUGFyZW50KSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBsb29raW5nIGZvciBhIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBwb3NzaWJsZVBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJyk7XG4gICAgICAgICAgICBpZiAocG9zc2libGVQYXJlbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IHBvc3NpYmxlUGFyZW50KSB7XG4gICAgICAgICAgICAgIHBvc3NpYmxlUGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlc3RvcmUgc3R5bGluZ1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsQ2FudmFzU3R5bGUucG9zaXRpb24gfHwgJyc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUudG9wIHx8ICcnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gb3JpZ2luYWxDYW52YXNTdHlsZS5sZWZ0IHx8ICcnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUud2lkdGggfHwgJzEwMCUnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbENhbnZhc1N0eWxlLmhlaWdodCB8fCAnMTAwJSc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUuekluZGV4IHx8ICcnO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlc2V0IGRpbWVuc2lvbnMgYmFzZWQgb24gcGFyZW50XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDYwMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gODAwO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IDYwMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNhbnZhcyByZXN0b3JlZCB0byBvcmlnaW5hbCBzdGF0ZVwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZXN0b3JpbmcgY2FudmFzOlwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTZXRSYW5kb20gPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdhaXQgZm9yIGNhbnZhcyB0byBiZSByZWFkeVxuICAgICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgICBsZXQgcmV0cnlDb3VudCA9IDA7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gNTtcbiAgICAgIFxuICAgICAgd2hpbGUgKCFjYW52YXMgJiYgcmV0cnlDb3VudCA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nIGZvciBjYW52YXMuLi4gYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfS8ke21heFJldHJpZXN9YCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgIHJldHJ5Q291bnQrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZSBhZnRlciBtdWx0aXBsZSByZXRyaWVzXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBBbHdheXMgZ2V0IHRoZSBsYXRlc3Qgc2V0dGluZ3MgZnJvbSBjb250ZXh0IGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5ncyAmJiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSA/IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdIDoge307XG4gICAgICBjb25zdCB0aW1lcyA9IE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgTnVtYmVyKHJhbmRvbVRpbWVzKSB8fCAxO1xuICAgICAgY29uc3QgZGVsYXkgPSBOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IE51bWJlcihkZWxheVNlY29uZHMpIHx8IDM7XG5cbiAgICAgIC8vIExvZyBjdXJyZW50IHNldHRpbmdzIGJlZm9yZSBzdGFydGluZ1xuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIFNldCBSYW5kb20gd2l0aCBzZXR0aW5nczonLCB7XG4gICAgICAgIHJhbmRvbVRpbWVzLFxuICAgICAgICBkZWxheVNlY29uZHMsXG4gICAgICAgIGN1cnJlbnRVc2VySWQsXG4gICAgICAgIHNldHRpbmdzLFxuICAgICAgICB1c2VyU2V0dGluZ3MsXG4gICAgICAgIHRpbWVzLFxuICAgICAgICBkZWxheVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEhpZGUgVG9wQmFyXG4gICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFN0YXJ0aW5nICR7dGltZXN9IHJhbmRvbSBjYXB0dXJlcyB3aXRoICR7ZGVsYXl9cyBkZWxheS4uLmApO1xuXG4gICAgICAvLyBQcm9jZXNzIGFsbCBjYXB0dXJlcyBpbiBzZXF1ZW5jZVxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGN1cnJlbnRJbmRleCA9IDE7IGN1cnJlbnRJbmRleCA8PSB0aW1lczsgY3VycmVudEluZGV4KyspIHtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgY3VycmVudCBjYXB0dXJlXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG9mICR7dGltZXN9YCk7XG4gICAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzIC0gY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBoYW5kbGVEb3RQcm9jZXNzIGZvciBlYWNoIGNhcHR1cmVcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlRG90UHJvY2Vzcyh7XG4gICAgICAgICAgdXNlUmFuZG9tUG9zaXRpb246IHRydWUsXG4gICAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fS8ke3RpbWVzfTogJHtzdGF0dXMucHJvY2Vzc1N0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyBUb3BCYXIgYWZ0ZXIgdGhlIGxhc3QgY2FwdHVyZVxuICAgICAgICAgICAgaWYgKHNob3cgJiYgY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBzaG93IHlldCBmb3IgaW50ZXJtZWRpYXRlIGNhcHR1cmVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHNob3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgICAgICBzZXRJc0NhcHR1cmluZzogKGNhcHR1cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzZXQgY2FwdHVyaW5nIHRvIGZhbHNlIGFmdGVyIGFsbCBjYXB0dXJlc1xuICAgICAgICAgICAgaWYgKCFjYXB0dXJpbmcgJiYgY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdGF5IGluIGNhcHR1cmluZyBzdGF0ZSBiZXR3ZWVuIGRvdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGNhcHR1cmluZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHBvc3RDb3VudGRvd25EZWxheTogODAwXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY29tcGxldGVkIGNhcHR1cmUgJHtjdXJyZW50SW5kZXh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fSBtYXkgaGF2ZSBmYWlsZWQ6YCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIGNhcHR1cmVzIC0gYnV0IG9ubHkgaWYgdGhlcmUgYXJlIG1vcmUgY2FwdHVyZXMgdG8gZ29cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgV2FpdGluZyAke2RlbGF5fXMgYmVmb3JlIG5leHQgY2FwdHVyZS4uLmApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5ICogMTAwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBsZXRpb24gbm90aWZpY2F0aW9uXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBjYXB0dXJlcyBzdWNjZXNzZnVsYCk7XG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcygwKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDb21wbGV0ZWQgYWxsIGNhcHR1cmVzOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gc3VjY2Vzc2Z1bGApO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYW5kb20gc2VxdWVuY2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBzZXF1ZW5jZSBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBoYW5kbGVSYW5kb21Eb3QgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgLy8gVXNlIHRoZSBjb25zb2xpZGF0ZWQgZnVuY3Rpb24gd2l0aCByYW5kb20gcG9zaXRpb25cbiAgICBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgIHVzZVJhbmRvbVBvc2l0aW9uOiB0cnVlLFxuICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgaWYgKHN0YXR1cy5pc0NhcHR1cmluZyAhPT0gdW5kZWZpbmVkKSBzZXRJc0NhcHR1cmluZyhzdGF0dXMuaXNDYXB0dXJpbmcpO1xuICAgICAgfSxcbiAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgc2hvdyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgIHBvc3RDb3VudGRvd25EZWxheTogMTAwMFxuICAgIH0pO1xuICB9O1xuICBcblxuICAvLyBMb2FkIGNhbGlicmF0aW9uIHNldHVwXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBjb25zdCBzZXR1cENhbGlicmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBDYWxpYnJhdGVIYW5kbGVyIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlcicpO1xuICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHNldHVwQ2FsaWJyYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBtYWtlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXMgc2l6ZTonLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgY2FsaWJyYXRpb24gcG9pbnRzOicsIHBvaW50cyk7XG4gICAgICAgIHNldENhbGlicmF0aW9uUG9pbnRzKHBvaW50cyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbGlicmF0ZUhhbmRsZXIgPSBuZXcgQ2FsaWJyYXRlSGFuZGxlcih7XG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIGNhbGlicmF0aW9uUG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4gb25BY3Rpb25DbGljaz8uKCd0b2dnbGVUb3BCYXInLCBzaG93KSxcbiAgICAgICAgICBzZXRPdXRwdXRUZXh0OiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnRlcjogY2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyOiAobmV3Q291bnRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdDb3VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudChwcmV2ID0+IG5ld0NvdW50ZXIocHJldikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KG5ld0NvdW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUZvbGRlcjogJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25IYW5kbGVyKHtcbiAgICAgICAgICBoYW5kbGVBY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24uLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGlicmF0ZUhhbmRsZXIuc3RhcnRDYWxpYnJhdGlvbigpO1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICByZXN0b3JlQ2FudmFzU2l6ZShjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNhbGlicmF0aW9uOicsIGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldHVwQ2FsaWJyYXRpb24oKTtcbiAgfSwgW2NhcHR1cmVDb3VudCwgb25BY3Rpb25DbGlja10pO1xuICBcbiAgLy8gQ2xlYXIgQWxsIEJ1dHRvbiAtIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgY29uc3QgaGFuZGxlQ2xlYXJBbGwgPSAoKSA9PiB7XG4gICAgY2xlYXJDYW52YXMoKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICBzZXRSZW1haW5pbmdDYXB0dXJlcygwKTtcbiAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgc2V0Q291bnRkb3duVmFsdWUobnVsbCk7XG4gICAgc2V0U2hvd0NhbnZhcyh0cnVlKTtcbiAgfTtcblxuICAvLyBUb2dnbGUgSGVhZCBQb3NlIHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlSGVhZFBvc2UgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3SGVhZFBvc2VTdGF0ZSA9ICFzaG93SGVhZFBvc2U7XG4gICAgc2V0U2hvd0hlYWRQb3NlKG5ld0hlYWRQb3NlU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYEhlYWQgcG9zZSB2aXN1YWxpemF0aW9uICR7bmV3SGVhZFBvc2VTdGF0ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCd9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ2hlYWRQb3NlJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd0hlYWRQb3NlOiBuZXdIZWFkUG9zZVN0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgaGVhZCBwb3NlOiAke25ld0hlYWRQb3NlU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBCb3VuZGluZyBCb3ggdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVCb3VuZGluZ0JveCA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdCb3VuZGluZ0JveFN0YXRlID0gIXNob3dCb3VuZGluZ0JveDtcbiAgICBzZXRTaG93Qm91bmRpbmdCb3gobmV3Qm91bmRpbmdCb3hTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgQm91bmRpbmcgYm94ICR7bmV3Qm91bmRpbmdCb3hTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnYm91bmRpbmdCb3gnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93Qm91bmRpbmdCb3g6IG5ld0JvdW5kaW5nQm94U3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBib3VuZGluZyBib3g6ICR7bmV3Qm91bmRpbmdCb3hTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIE1hc2sgdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVNYXNrID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld01hc2tTdGF0ZSA9ICFzaG93TWFzaztcbiAgICBzZXRTaG93TWFzayhuZXdNYXNrU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYE1hc2sgJHtuZXdNYXNrU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ21hc2snKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93TWFzazogbmV3TWFza1N0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgbWFzazogJHtuZXdNYXNrU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBQYXJhbWV0ZXJzIGRpc3BsYXlcbiAgY29uc3QgaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdQYXJhbWV0ZXJzU3RhdGUgPSAhc2hvd1BhcmFtZXRlcnM7XG4gICAgc2V0U2hvd1BhcmFtZXRlcnMobmV3UGFyYW1ldGVyc1N0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBQYXJhbWV0ZXJzICR7bmV3UGFyYW1ldGVyc1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdwYXJhbWV0ZXJzJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd1BhcmFtZXRlcnM6IG5ld1BhcmFtZXRlcnNTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIHBhcmFtZXRlcnM6ICR7bmV3UGFyYW1ldGVyc1N0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgY2FtZXJhIHByZXZpZXdcbiAgY29uc3QgaGFuZGxlVG9nZ2xlQ2FtZXJhID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0NhbWVyYVN0YXRlID0gIWlzQ2FtZXJhQWN0aXZlO1xuICAgIHNldElzQ2FtZXJhQWN0aXZlKG5ld0NhbWVyYVN0YXRlKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB3aXRoICdwcmV2aWV3JyBhY3Rpb25cbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygncHJldmlldycsIG5ld0NhbWVyYVN0YXRlKTsgLy8gUGFzcyB0aGUgbmV3IHN0YXRlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCB0cmlnZ2VyIGlmIG5vIGFjdGlvbiBoYW5kbGVyXG4gICAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB0dXJuaW5nIG9uIGNhbWVyYSwgZW5zdXJlIHdlIGFwcGx5IGN1cnJlbnQgdmlzdWFsaXphdGlvbiBzZXR0aW5nc1xuICAgIGlmIChuZXdDYW1lcmFTdGF0ZSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIC8vIFdhaXQgYSBzaG9ydCBtb21lbnQgdG8gZW5zdXJlIHRoZSB2aWRlbyBlbGVtZW50IGlzIHJlYWR5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgIHNob3dIZWFkUG9zZSxcbiAgICAgICAgICAgIHNob3dCb3VuZGluZ0JveCxcbiAgICAgICAgICAgIHNob3dNYXNrLFxuICAgICAgICAgICAgc2hvd1BhcmFtZXRlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWRkIGJhY2sgYnV0dG9uIGhhbmRsZXJcbiAgY29uc3QgaGFuZGxlR29CYWNrID0gKCkgPT4ge1xuICAgIHJvdXRlci5wdXNoKCcvJyk7XG4gIH07XG5cbiAgLy8gTW9iaWxlIGxheW91dCAtIDJ4NSBncmlkXG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIHtpc0NvbXBhY3RNb2RlID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTIgbWItNFwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yXCI+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgXG4gICAgICB7LyogU3RhdHVzIGRpc3BsYXkgd2l0aCBtZW1vaXphdGlvbiAqL31cbiAgICAgIHt1c2VNZW1vKCgpID0+IChcbiAgICAgICAgKHByb2Nlc3NTdGF0dXMgfHwgcmVtYWluaW5nQ2FwdHVyZXMgPiAwIHx8IGNvdW50ZG93blZhbHVlKSAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzdGF0dXMtZGlzcGxheSBtdC00IHAtMiBiZy1ibHVlLTUwIHJvdW5kZWQtbWRcIj5cbiAgICAgICAgICAgIHtwcm9jZXNzU3RhdHVzICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtYmx1ZS04MDBcIj57cHJvY2Vzc1N0YXR1c308L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7cmVtYWluaW5nQ2FwdHVyZXMgPiAwICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQteWVsbG93LTYwMFwiPlJlbWFpbmluZzoge3JlbWFpbmluZ0NhcHR1cmVzfTwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZSAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIHRleHQtcmVkLTYwMFwiPntjb3VudGRvd25WYWx1ZX08L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICAgICksIFtwcm9jZXNzU3RhdHVzLCByZW1haW5pbmdDYXB0dXJlcywgY291bnRkb3duVmFsdWVdKX1cbiAgICAgIFxuICAgICAgey8qIENhbnZhcyBmb3IgZHJhd2luZyBkb3RzICovfVxuICAgICAge3Nob3dDYW52YXMgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbnZhcy1jb250YWluZXIgbXQtNFwiIFxuICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnNDB2aCcsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6ICczMDBweCcsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2UwZTBlMCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxjYW52YXMgXG4gICAgICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInRyYWNraW5nLWNhbnZhc1wiXG4gICAgICAgICAgICBpZD1cInRyYWNraW5nLWNhbnZhc1wiXG4gICAgICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlJywgXG4gICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25Mb2FkPXsoZSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBlLnRhcmdldDtcbiAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIFxuICAgICAgICAgIHsvKiBPdmVybGF5IGZvciBjb3VudGRvd24gb24gZG90ICovfVxuICAgICAgICAgIHtjb3VudGRvd25WYWx1ZSAmJiBjdXJyZW50RG90ICYmIChcbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdC1jb3VudGRvd25cIlxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgIGxlZnQ6IGAke2N1cnJlbnREb3QueCAtIDE1fXB4YCxcbiAgICAgICAgICAgICAgICB0b3A6IGAke2N1cnJlbnREb3QueSAtIDQwfXB4YCxcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcyOHB4JyxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge2NvdW50ZG93blZhbHVlfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgXG4gICAgICB7LyogQ2FtZXJhIFBlcm1pc3Npb24gUG9wdXAgKi99XG4gICAgICB7c2hvd1Blcm1pc3Npb25Qb3B1cCAmJiAoXG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tcG9wdXBcIiBcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgekluZGV4OiAxNVxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tZGlhbG9nXCIgXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICB3aWR0aDogJzQwMHB4JyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMjBweCcsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMiknXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxoMyBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tdGl0bGVcIiBcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMTVweCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgQ2FtZXJhIEFjY2VzcyBSZXF1aXJlZFxuICAgICAgICAgICAgPC9oMz5cbiAgICAgICAgICAgIDxwIFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1tZXNzYWdlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDIwcHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogJzEuNCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgVGhpcyBhcHBsaWNhdGlvbiBuZWVkcyBhY2Nlc3MgdG8geW91ciBjYW1lcmEgdG8gZnVuY3Rpb24gcHJvcGVybHkuIFdoZW4gcHJvbXB0ZWQgYnkgeW91ciBicm93c2VyLCBwbGVhc2UgY2xpY2sgXCJBbGxvd1wiIHRvIGdyYW50IGNhbWVyYSBhY2Nlc3MuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1idXR0b25zXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnZmxleC1lbmQnLFxuICAgICAgICAgICAgICAgIGdhcDogJzEwcHgnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUGVybWlzc2lvbkRlbmllZH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtYnRuXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCAxNnB4JyxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmMGYwZjAnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ2FuY2VsXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25BY2NlcHRlZH1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtYnRuXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzhweCAxNnB4JyxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMwMDY2Y2MnLFxuICAgICAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBDb250aW51ZVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59KTtcbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoXG4gIGZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IDxBY3Rpb25CdXR0b25Hcm91cElubmVyIHsuLi5wcm9wc30gcmVmPXtyZWZ9IC8+KVxuKSwgeyBzc3I6IGZhbHNlIH0pO1xuLy8gQ3JlYXRlIGEgY2xpZW50LW9ubHkgdmVyc2lvbiBvZiBBY3Rpb25CdXR0b25Hcm91cFxuLy8gY29uc3QgQWN0aW9uQnV0dG9uR3JvdXAgPSBkeW5hbWljKCgpID0+IFByb21pc2UucmVzb2x2ZShBY3Rpb25CdXR0b25Hcm91cElubmVyKSwgeyBzc3I6IGZhbHNlIH0pO1xuXG4vLyBBZGQgZGVmYXVsdCBleHBvcnQgY29tcG9uZW50XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBBY3Rpb25CdXR0b25QYWdlKCkge1xuICByZXR1cm4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcbn1cblxuZXhwb3J0IHsgQWN0aW9uQnV0dG9uLCBBY3Rpb25CdXR0b25Hcm91cCB9O1xuXG4vLyBBZGQgdGhpcyB1c2VFZmZlY3QgZm9yIGNhbnZhcyBpbml0aWFsaXphdGlvblxudXNlRWZmZWN0KCgpID0+IHtcbiAgY29uc3QgaW5pdGlhbGl6ZUNhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSByZWZlcmVuY2VcbiAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSBjYW52YXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBJbml0aWFsIGluaXRpYWxpemF0aW9uXG4gIGluaXRpYWxpemVDYW52YXMoKTtcblxuICAvLyBBZGQgcmVzaXplIGhhbmRsZXJcbiAgY29uc3QgaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgIGluaXRpYWxpemVDYW52YXMoKTtcbiAgfTtcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xufSwgW3Nob3dDYW52YXNdKTsgLy8gUmUtcnVuIHdoZW4gc2hvd0NhbnZhcyBjaGFuZ2VzIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJmb3J3YXJkUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZU1lbW8iLCJkeW5hbWljIiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsInNob3dDYXB0dXJlUHJldmlldyIsImRyYXdSZWREb3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJydW5Db3VudGRvd24iLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsInVzZVJvdXRlciIsInVzZUFkbWluU2V0dGluZ3MiLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJrZXlzMSIsIk9iamVjdCIsImtleXMiLCJrZXlzMiIsImxlbmd0aCIsImV2ZXJ5Iiwia2V5IiwiaW5jbHVkZXMiLCJBY3Rpb25CdXR0b24iLCJ0ZXh0IiwiYWJicmV2aWF0ZWRUZXh0Iiwib25DbGljayIsImN1c3RvbUNsYXNzIiwiZGlzYWJsZWQiLCJhY3RpdmUiLCJpc0FiYnJldmlhdGVkIiwic2V0SXNBYmJyZXZpYXRlZCIsInNldHRpbmdzIiwiY3VycmVudFVzZXJJZCIsInNldEN1cnJlbnRVc2VySWQiLCJpc0NhcHR1cmluZyIsInNldElzQ2FwdHVyaW5nIiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsInByb2Nlc3NTdGF0dXMiLCJzZXRQcm9jZXNzU3RhdHVzIiwiYnV0dG9uUHJvcHMiLCJjbGFzc05hbWUiLCJ0aXRsZSIsInRpbWVvdXRJZCIsImhhbmRsZVJlc2l6ZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVVzZXJJZENoYW5nZSIsImV2ZW50IiwiZGV0YWlsIiwidHlwZSIsIm5ld1VzZXJJZCIsInVzZXJJZCIsImJ1dHRvbiIsImRpdiIsIkFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIiLCJyZWYiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwiaXNDb21wYWN0TW9kZSIsIm9uQWN0aW9uQ2xpY2siLCJyb3V0ZXIiLCJ1cGRhdGVTZXR0aW5ncyIsInJhbmRvbVRpbWVzIiwic2V0UmFuZG9tVGltZXMiLCJkZWxheVNlY29uZHMiLCJzZXREZWxheVNlY29uZHMiLCJjYW52YXNSZWYiLCJjb3VudGRvd25WYWx1ZSIsInNldENvdW50ZG93blZhbHVlIiwiY3VycmVudERvdCIsInNldEN1cnJlbnREb3QiLCJjYWxpYnJhdGlvblBvaW50cyIsInNldENhbGlicmF0aW9uUG9pbnRzIiwiY3VycmVudENhbGlicmF0aW9uSW5kZXgiLCJzZXRDdXJyZW50Q2FsaWJyYXRpb25JbmRleCIsInJlbWFpbmluZ0NhcHR1cmVzIiwic2V0UmVtYWluaW5nQ2FwdHVyZXMiLCJzaG93Q2FudmFzIiwic2V0U2hvd0NhbnZhcyIsImNhbGlicmF0aW9uSGFuZGxlciIsInNldENhbGlicmF0aW9uSGFuZGxlciIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsInNob3dIZWFkUG9zZSIsInNldFNob3dIZWFkUG9zZSIsInNob3dCb3VuZGluZ0JveCIsInNldFNob3dCb3VuZGluZ0JveCIsInNob3dNYXNrIiwic2V0U2hvd01hc2siLCJzaG93UGFyYW1ldGVycyIsInNldFNob3dQYXJhbWV0ZXJzIiwiaXNDYW1lcmFBY3RpdmUiLCJzZXRJc0NhbWVyYUFjdGl2ZSIsInNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXRTaG93UGVybWlzc2lvblBvcHVwIiwic2V0dGluZ3NDYWNoZSIsIk1hcCIsImxhc3RTZXR0aW5nc1VwZGF0ZSIsInVzZXJTZXR0aW5ncyIsImNhY2hlZFNldHRpbmdzIiwiY3VycmVudCIsImdldCIsIk51bWJlciIsInRpbWVzX3NldF9yYW5kb20iLCJkZWxheV9zZXRfcmFuZG9tIiwic2V0IiwiRGF0ZSIsIm5vdyIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidW5kZWZpbmVkIiwibmV3VGltZXMiLCJuZXdEZWxheSIsImFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyIsImhhbmRsZVJhbmRvbURvdCIsImhhbmRsZVNldFJhbmRvbSIsImhhbmRsZVNldENhbGlicmF0ZSIsImhhbmRsZUNsZWFyQWxsIiwidXBkYXRlQ29udHJvbFZhbHVlcyIsInRpbWVJbnB1dCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInRpbWVWYWx1ZSIsInBhcnNlSW50IiwidmFsdWUiLCJpc05hTiIsImNvbnNvbGUiLCJsb2ciLCJkZWxheUlucHV0IiwiZGVsYXlWYWx1ZSIsImluaXRpYWxpemVDYW52YXMiLCJjYW52YXMiLCJwYXJlbnQiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImVycm9yIiwiZ2V0TWFpbkNhbnZhcyIsIndoaXRlU2NyZWVuQ2FudmFzIiwic2VsZWN0b3JzIiwic2VsZWN0b3IiLCJjYW52YXNFbGVtZW50IiwibWFrZUNhbnZhc0Z1bGxzY3JlZW4iLCJwYXJlbnRFbGVtZW50IiwiYm9keSIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiekluZGV4IiwiaW5uZXJIZWlnaHQiLCJyZXN0b3JlQ2FudmFzU2l6ZSIsImhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCIsImhhbmRsZVBlcm1pc3Npb25EZW5pZWQiLCJyZXN0b3JlQ2FudmFzIiwib3JpZ2luYWxQYXJlbnQiLCJvcmlnaW5hbFN0eWxlIiwiYXBwZW5kQ2hpbGQiLCJjbGVhckNhbnZhcyIsIndhcm4iLCJoYW5kbGVEb3RQcm9jZXNzIiwib3B0aW9ucyIsIm9uU3RhdHVzVXBkYXRlIiwidG9nZ2xlVG9wQmFyIiwidXNlUmFuZG9tUG9zaXRpb24iLCJwb3N0Q291bnRkb3duRGVsYXkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJldHJ5Q291bnQiLCJtYXhSZXRyaWVzIiwiRXJyb3IiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImRvdFBvc2l0aW9uIiwieCIsInkiLCJkb3RSYWRpdXMiLCJrZWVwRG90VmlzaWJsZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJleGlzdGluZ0NvdW50ZG93bnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjc3NUZXh0IiwiY291bnQiLCJ0ZXh0Q29udGVudCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsImNsZWFySW50ZXJ2YWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsIm9yaWdpbmFsQ2FudmFzUGFyZW50Iiwib3JpZ2luYWxDYW52YXNTdHlsZSIsInN0YXR1c0luZGljYXRvciIsImN1cnJlbnRSZWRyYXdJbnRlcnZhbCIsInBvaW50cyIsInN1Y2Nlc3NDb3VudCIsImkiLCJyYWRpdXMiLCJyZWRyYXdDdXJyZW50RG90Iiwic2NyZWVuSW1hZ2UiLCJwb3NzaWJsZVBhcmVudCIsImUiLCJ0aW1lcyIsImRlbGF5IiwiY3VycmVudEluZGV4IiwicmVzdWx0Iiwic3RhdHVzIiwic2hvdyIsImNhcHR1cmluZyIsInNldHVwQ2FsaWJyYXRpb24iLCJkZWZhdWx0IiwiQ2FsaWJyYXRlSGFuZGxlciIsImNhbGlicmF0ZUhhbmRsZXIiLCJzZXRPdXRwdXRUZXh0IiwibmV3Q291bnRlciIsInByZXYiLCJjYXB0dXJlRm9sZGVyIiwib25Db21wbGV0ZSIsImhhbmRsZUFjdGlvbiIsInN0YXJ0Q2FsaWJyYXRpb24iLCJlcnIiLCJoYW5kbGVUb2dnbGVIZWFkUG9zZSIsIm5ld0hlYWRQb3NlU3RhdGUiLCJ2aWRlb1Byb2Nlc3NvciIsInVwZGF0ZU9wdGlvbnMiLCJoYW5kbGVUb2dnbGVCb3VuZGluZ0JveCIsIm5ld0JvdW5kaW5nQm94U3RhdGUiLCJoYW5kbGVUb2dnbGVNYXNrIiwibmV3TWFza1N0YXRlIiwiaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyIsIm5ld1BhcmFtZXRlcnNTdGF0ZSIsImhhbmRsZVRvZ2dsZUNhbWVyYSIsIm5ld0NhbWVyYVN0YXRlIiwiaGFuZGxlR29CYWNrIiwicHVzaCIsIm1pbkhlaWdodCIsImJvcmRlciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlclJhZGl1cyIsIm92ZXJmbG93IiwiaWQiLCJkaXNwbGF5Iiwib25Mb2FkIiwidGFyZ2V0IiwiY29sb3IiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJwYWRkaW5nIiwiYm94U2hhZG93IiwiaDMiLCJtYXJnaW4iLCJwIiwibGluZUhlaWdodCIsImdhcCIsImN1cnNvciIsIkFjdGlvbkJ1dHRvbkdyb3VwIiwicHJvcHMiLCJzc3IiLCJBY3Rpb25CdXR0b25QYWdlIiwiY29udGFpbmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});