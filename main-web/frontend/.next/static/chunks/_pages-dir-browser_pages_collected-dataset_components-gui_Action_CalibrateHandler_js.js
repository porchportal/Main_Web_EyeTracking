"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset_components-gui_Action_CalibrateHandler_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CalibrateHandler.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js\");\n// CalibrateHandler.js - Handles the calibration process\n\n\nclass CalibrateHandler {\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = \"\\n      position: fixed;\\n      top: 10px;\\n      right: 10px;\\n      background-color: rgba(0, 102, 204, 0.9);\\n      color: white;\\n      font-size: 14px;\\n      font-weight: bold;\\n      padding: 8px 12px;\\n      border-radius: 6px;\\n      z-index: 9999;\\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n    \";\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            const canvas = this.canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Processing point \".concat(index + 1, \"/\").concat(total);\n            }\n            await (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.captureAndPreviewProcess)({\n                canvasRef: this.canvasRef,\n                position: point,\n                captureCounter: this.captureCounter,\n                saveImageToServer: async (imageData, filename, type, folder)=>{\n                    const response = await fetch('/api/save-capture', {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: JSON.stringify({\n                            imageData,\n                            filename,\n                            type,\n                            folder: this.captureFolder\n                        })\n                    });\n                    if (!response.ok) {\n                        throw new Error(\"Server error: \".concat(response.status));\n                    }\n                    return await response.json();\n                },\n                setCaptureCounter: (newCounter)=>{\n                    var _this_setCaptureCounter, _this;\n                    this.captureCounter = newCounter;\n                    (_this_setCaptureCounter = (_this = this).setCaptureCounter) === null || _this_setCaptureCounter === void 0 ? void 0 : _this_setCaptureCounter.call(_this, newCounter);\n                },\n                setProcessStatus: (status)=>{\n                    var _this_setOutputText, _this;\n                    (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, status);\n                },\n                toggleTopBar: this.toggleTopBar,\n                onStatusUpdate: (status)=>{\n                    var _this_setOutputText, _this;\n                    const msg = typeof status === 'string' ? status : \"Point \".concat(index + 1, \"/\").concat(total, \" - \").concat(status.countdownValue || status.processStatus);\n                    (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, msg);\n                },\n                captureFolder: this.captureFolder\n            });\n            return true;\n        } catch (err) {\n            var _this_setOutputText, _this;\n            console.error(\"Error processing point \".concat(index + 1, \":\"), err);\n            this.statusIndicator.textContent = \"Error: \".concat(err.message);\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Error: \".concat(err.message));\n            return false;\n        }\n    }\n    async startCalibration() {\n        var _this_toggleTopBar, _this;\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        (_this_toggleTopBar = (_this = this).toggleTopBar) === null || _this_toggleTopBar === void 0 ? void 0 : _this_toggleTopBar.call(_this, false);\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            var _this_setOutputText, _this1, _this_setOutputText1, _this2, _this_toggleTopBar1, _this3, _this_onComplete, _this4;\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            (_this_setOutputText = (_this1 = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this1, \"Starting calibration with \".concat(this.calibrationPoints.length, \" points\"));\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (!success) break;\n            }\n            (_this_setOutputText1 = (_this2 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this2, 'Calibration completed');\n            this.statusIndicator.textContent = 'Calibration completed';\n            (_this_toggleTopBar1 = (_this3 = this).toggleTopBar) === null || _this_toggleTopBar1 === void 0 ? void 0 : _this_toggleTopBar1.call(_this3, true);\n            (_this_onComplete = (_this4 = this).onComplete) === null || _this_onComplete === void 0 ? void 0 : _this_onComplete.call(_this4);\n        } catch (error) {\n            var _this_setOutputText2, _this5, _this_toggleTopBar2, _this6;\n            console.error('Calibration error:', error);\n            (_this_setOutputText2 = (_this5 = this).setOutputText) === null || _this_setOutputText2 === void 0 ? void 0 : _this_setOutputText2.call(_this5, \"Calibration error: \".concat(error.message));\n            this.statusIndicator.textContent = \"Error: \".concat(error.message);\n            (_this_toggleTopBar2 = (_this6 = this).toggleTopBar) === null || _this_toggleTopBar2 === void 0 ? void 0 : _this_toggleTopBar2.call(_this6, true);\n        } finally{\n            this.isProcessing = false;\n        }\n    }\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHdEQUF3RDtBQUNNO0FBSXpDO0FBRXJCLE1BQU1HO0lBbUJKQyx3QkFBd0I7UUFDdEIsTUFBTUMscUJBQXFCQyxTQUFTQyxnQkFBZ0IsQ0FBQztRQUNyREYsbUJBQW1CRyxPQUFPLENBQUNDLENBQUFBLFlBQWFBLFVBQVVDLE1BQU07UUFFeEQsTUFBTUQsWUFBWUgsU0FBU0ssYUFBYSxDQUFDO1FBQ3pDRixVQUFVRyxTQUFTLEdBQUc7UUFDdEJILFVBQVVJLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBYTNCUixTQUFTUyxJQUFJLENBQUNDLFdBQVcsQ0FBQ1A7UUFDMUIsSUFBSSxDQUFDUSxlQUFlLEdBQUdSO1FBQ3ZCLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNUyx3QkFBd0JDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7UUFDakQsSUFBSTtZQUNGLElBQUksQ0FBQ0YsU0FBUyxPQUFPQSxNQUFNRyxDQUFDLEtBQUssWUFBWSxPQUFPSCxNQUFNSSxDQUFDLEtBQUssVUFBVTtnQkFDeEUsTUFBTSxJQUFJQyxNQUFNO1lBQ2xCO1lBRUEsTUFBTUMsU0FBUyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTztZQUNyQyxNQUFNQyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7WUFDOUI1QixzREFBVUEsQ0FBQzJCLEtBQUtULE1BQU1HLENBQUMsRUFBRUgsTUFBTUksQ0FBQztZQUVoQyxJQUFJLElBQUksQ0FBQ04sZUFBZSxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGVBQWUsQ0FBQ2EsV0FBVyxHQUFHLG9CQUFpQ1QsT0FBYkQsUUFBUSxHQUFFLEtBQVMsT0FBTkM7WUFDdEU7WUFFQSxNQUFNbkIsb0VBQXdCQSxDQUFDO2dCQUM3QndCLFdBQVcsSUFBSSxDQUFDQSxTQUFT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LElBQUksQ0FBQ3lCLFVBQVUsR0FBR0UsT0FBT0YsVUFBVTtRQUVuQyxtRUFBbUU7UUFDbkUsSUFBSSxDQUFDSixpQkFBaUIsR0FBR00sT0FBT04saUJBQWlCLElBQUksRUFBRTtRQUV2RCxZQUFZO1FBQ1osSUFBSSxDQUFDSCxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDVSxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUN2RCxlQUFlLEdBQUc7SUFDekI7QUFtSUY7QUFFQSxpRUFBZWQsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlSGFuZGxlci5qcyAtIEhhbmRsZXMgdGhlIGNhbGlicmF0aW9uIHByb2Nlc3NcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQge1xuICBkcmF3UmVkRG90LFxuICBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Ncbn0gZnJvbSAnLi9jb3VudFNhdmUnO1xuXG5jbGFzcyBDYWxpYnJhdGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldE91dHB1dFRleHQgPSBjb25maWcuc2V0T3V0cHV0VGV4dDtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyIHx8IDE7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSBjb25maWcuY2FwdHVyZUZvbGRlciB8fCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJztcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBjb25maWcub25Db21wbGV0ZTtcblxuICAgIC8vIEFjY2VwdCBwYXNzZWQtaW4gY2FsaWJyYXRpb24gcG9pbnRzIChmcm9tIFNldENhbGlicmF0ZUFjdGlvbi5qcylcbiAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gY29uZmlnLmNhbGlicmF0aW9uUG9pbnRzIHx8IFtdO1xuXG4gICAgLy8gSW50ZXJuYWxzXG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRQb2ludEluZGV4ID0gMDtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gIH1cblxuICBjcmVhdGVTdGF0dXNJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJbmRpY2F0b3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJyk7XG4gICAgZXhpc3RpbmdJbmRpY2F0b3JzLmZvckVhY2goaW5kaWNhdG9yID0+IGluZGljYXRvci5yZW1vdmUoKSk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICBpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIHRvcDogMTBweDtcbiAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IGluZGljYXRvcjtcbiAgICByZXR1cm4gaW5kaWNhdG9yO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQocG9pbnQsIGluZGV4LCB0b3RhbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXBvaW50IHx8IHR5cGVvZiBwb2ludC54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9pbnQueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYWxpYnJhdGlvbiBwb2ludFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgUHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgICBjYW52YXNSZWY6IHRoaXMuY2FudmFzUmVmLFxuICAgICAgICBwb3NpdGlvbjogcG9pbnQsXG4gICAgICAgIGNhcHR1cmVDb3VudGVyOiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICBzYXZlSW1hZ2VUb1NlcnZlcjogYXN5bmMgKGltYWdlRGF0YSwgZmlsZW5hbWUsIHR5cGUsIGZvbGRlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IG5ld0NvdW50ZXI7XG4gICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcj8uKG5ld0NvdW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oc3RhdHVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyOiB0aGlzLnRvZ2dsZVRvcEJhcixcbiAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJyA/IHN0YXR1cyA6IGBQb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH0gLSAke3N0YXR1cy5jb3VudGRvd25WYWx1ZSB8fCBzdGF0dXMucHJvY2Vzc1N0YXR1c31gO1xuICAgICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKG1zZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmVGb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX06YCwgZXJyKTtcbiAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RhcnRDYWxpYnJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgICB0aGlzLnRvZ2dsZVRvcEJhcj8uKGZhbHNlKTtcblxuICAgIGNvbnN0IGluZGljYXRvciA9IHRoaXMuY3JlYXRlU3RhdHVzSW5kaWNhdG9yKCk7XG4gICAgaW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0luaXRpYWxpemluZyBjYWxpYnJhdGlvbi4uLic7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCByZWFkeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IGdlbmVyYXRlIGlmIG5vbmUgd2VyZSBwYXNzZWQgaW5cbiAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBTdGFydGluZyBjYWxpYnJhdGlvbiB3aXRoICR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2ApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMucHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQodGhpcy5jYWxpYnJhdGlvblBvaW50c1tpXSwgaSwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LignQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnO1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXI/Lih0cnVlKTtcbiAgICAgIHRoaXMub25Db21wbGV0ZT8uKCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ2FsaWJyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcj8uKHRydWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWxpYnJhdGVIYW5kbGVyOyJdLCJuYW1lcyI6WyJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZHJhd1JlZERvdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjcmVhdGVTdGF0dXNJbmRpY2F0b3IiLCJleGlzdGluZ0luZGljYXRvcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaW5kaWNhdG9yIiwicmVtb3ZlIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN0YXR1c0luZGljYXRvciIsInByb2Nlc3NDYWxpYnJhdGlvblBvaW50IiwicG9pbnQiLCJpbmRleCIsInRvdGFsIiwieCIsInkiLCJFcnJvciIsImNhbnZhcyIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwidGV4dENvbnRlbnQiLCJwb3NpdGlvbiIsImNhcHR1cmVDb3VudGVyIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJpbWFnZURhdGEiLCJmaWxlbmFtZSIsInR5cGUiLCJmb2xkZXIiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJjYXB0dXJlRm9sZGVyIiwib2siLCJzdGF0dXMiLCJqc29uIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJuZXdDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInNldE91dHB1dFRleHQiLCJ0b2dnbGVUb3BCYXIiLCJvblN0YXR1c1VwZGF0ZSIsIm1zZyIsImNvdW50ZG93blZhbHVlIiwicHJvY2Vzc1N0YXR1cyIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGFydENhbGlicmF0aW9uIiwiaXNQcm9jZXNzaW5nIiwid2lkdGgiLCJoZWlnaHQiLCJjYWxpYnJhdGlvblBvaW50cyIsImxlbmd0aCIsImkiLCJzdWNjZXNzIiwib25Db21wbGV0ZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiY3VycmVudFBvaW50SW5kZXgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js":
/*!********************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/countSave.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n// countSave.js\n// Shared functionality for countdown and image capture processes\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @param {Function} onComplete - Callback to execute when countdown finishes\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(absoluteX, \"px;\\n      top: \").concat(absoluteY - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    if (position && typeof position.x === 'number' && typeof position.y === 'number') {\n                        drawRedDot(ctx, position.x, position.y);\n                    } else {\n                        console.warn(\"[runCountdown] Position is null after countdown\", position);\n                    }\n                    if (onComplete) {\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n   * Captures images from both canvas and webcam\n   * @param {Object} options - Capture options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {string} options.captureFolder - Folder to save captures in\n   * @returns {Object} - Result with captured image data\n   */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    try {\n        const counter = String(captureCounter).padStart(3, '0');\n        const screenFilename = \"screen_\".concat(counter, \".jpg\");\n        const webcamFilename = \"webcam_\".concat(counter, \".jpg\");\n        const parameterFilename = \"parameter_\".concat(counter, \".csv\");\n        console.log(\"Starting capture process with counter: \".concat(counter));\n        console.log(\"Dot position: x=\".concat(position.x, \", y=\").concat(position.y));\n        let screenImageData = null;\n        let webcamImageData = null;\n        let usedCaptureNumber = captureCounter;\n        // === 1. Capture screen image from canvas ===\n        const canvas = canvasRef.current;\n        if (canvas) {\n            try {\n                const ctx = canvas.getContext('2d');\n                // ✅ Make sure the red dot is drawn RIGHT before screen capture\n                drawRedDot(ctx, position.x, position.y);\n                console.log(\"Canvas dimensions: \".concat(canvas.width, \"x\").concat(canvas.height));\n                screenImageData = canvas.toDataURL('image/png');\n                console.log(\"Screen image captured, size: \".concat(screenImageData.length, \" chars\"));\n                if (saveImageToServer) {\n                    const screenResponse = await saveImageToServer(screenImageData, screenFilename, 'screen', captureFolder);\n                    if (screenResponse && screenResponse.captureNumber) {\n                        usedCaptureNumber = screenResponse.captureNumber;\n                        console.log(\"Server assigned capture number: \".concat(usedCaptureNumber));\n                    }\n                }\n            } catch (screenError) {\n                console.error(\"Error capturing or saving screen image:\", screenError);\n            }\n        } else {\n            console.error(\"Canvas reference is null, cannot capture screen\");\n        }\n        // === 2. Capture webcam image ===\n        try {\n            console.log(\"Attempting to capture webcam silently\");\n            const videoElement = window.videoElement || document.querySelector('video');\n            if (videoElement && videoElement.readyState >= 2) {\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = videoElement.videoWidth || 640;\n                tempCanvas.height = videoElement.videoHeight || 480;\n                ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, \"webcam_\".concat(String(usedCaptureNumber).padStart(3, '0'), \".jpg\"), 'webcam', captureFolder);\n                }\n            } else {\n                const stream = await navigator.mediaDevices.getUserMedia({\n                    video: true,\n                    audio: false\n                });\n                const tempVideo = document.createElement('video');\n                tempVideo.autoplay = true;\n                tempVideo.playsInline = true;\n                tempVideo.muted = true;\n                tempVideo.style.position = 'absolute';\n                tempVideo.style.left = '-9999px';\n                tempVideo.style.opacity = '0';\n                document.body.appendChild(tempVideo);\n                tempVideo.srcObject = stream;\n                await new Promise((resolve)=>{\n                    const timeoutId = setTimeout(resolve, 1000);\n                    tempVideo.onloadeddata = ()=>{\n                        clearTimeout(timeoutId);\n                        resolve();\n                    };\n                });\n                await new Promise((resolve)=>setTimeout(resolve, 200));\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = tempVideo.videoWidth || 640;\n                tempCanvas.height = tempVideo.videoHeight || 480;\n                ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, \"webcam_\".concat(String(usedCaptureNumber).padStart(3, '0'), \".jpg\"), 'webcam', captureFolder);\n                }\n                stream.getTracks().forEach((track)=>track.stop());\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        } catch (webcamError) {\n            console.error(\"Error capturing webcam silently:\", webcamError);\n        }\n        // === 3. Save parameter CSV ===\n        try {\n            console.log(\"Creating parameter CSV\");\n            const csvData = [\n                \"name,value\",\n                \"dot_x,\".concat(position.x),\n                \"dot_y,\".concat(position.y),\n                \"canvas_width,\".concat(canvas ? canvas.width : 0),\n                \"canvas_height,\".concat(canvas ? canvas.height : 0),\n                \"window_width,\".concat(window.innerWidth),\n                \"window_height,\".concat(window.innerHeight),\n                \"timestamp,\".concat(new Date().toISOString())\n            ].join('\\n');\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            if (saveImageToServer) {\n                await saveImageToServer(csvDataUrl, \"parameter_\".concat(String(usedCaptureNumber).padStart(3, '0'), \".csv\"), 'parameters', captureFolder);\n            }\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n        }\n        // === 4. Update counter ===\n        if (setCaptureCounter) {\n            setCaptureCounter(usedCaptureNumber + 1);\n        }\n        // === 5. Set process status ===\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured with dot at: x=\".concat(position.x, \", y=\").concat(position.y));\n        }\n        // === 6. Return capture data ===\n        return {\n            screenImage: screenImageData,\n            webcamImage: webcamImageData,\n            position,\n            captureNumber: usedCaptureNumber\n        };\n    } catch (error) {\n        console.error(\"Error during capture:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Error capturing images: \".concat(error.message));\n        }\n        throw error;\n    }\n};\n/**\n   * Display a preview of the captured images\n   * @param {string} screenImage - Data URL of the screen image\n   * @param {string} webcamImage - Data URL of the webcam image\n   * @param {Object} dotPosition - {x, y} position of the dot\n   */ const showCapturePreview = (screenImage, webcamImage, dotPosition)=>{\n    if (!screenImage && !webcamImage) {\n        console.warn(\"No images available to preview\");\n        return;\n    }\n    // Remove any existing preview containers first\n    try {\n        const existingPreviews = document.querySelectorAll('.capture-preview-container');\n        existingPreviews.forEach((preview)=>{\n            if (preview.parentNode) {\n                console.log(\"Removing existing preview container\");\n                preview.parentNode.removeChild(preview);\n            }\n        });\n    } catch (cleanupError) {\n        console.error(\"Error cleaning up existing previews:\", cleanupError);\n    }\n    // Create a new preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n      position: fixed;\\n      top: 50%;\\n      left: 50%;\\n      transform: translate(-50%, -50%);\\n      display: flex;\\n      gap: 20px;\\n      background-color: rgba(0, 0, 0, 0.85);\\n      padding: 20px;\\n      border-radius: 12px;\\n      z-index: 999999;\\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n    \";\n    // Function to add an image to the preview\n    const addImagePreview = (image, label)=>{\n        try {\n            const preview = document.createElement('div');\n            preview.style.cssText = \"\\n          display: flex;\\n          flex-direction: column;\\n          align-items: center;\\n        \";\n            const img = document.createElement('img');\n            img.src = image;\n            img.alt = label;\n            img.style.cssText = \"\\n          max-width: 320px;\\n          max-height: 240px;\\n          border: 3px solid white;\\n          border-radius: 8px;\\n          background-color: #333;\\n        \";\n            const labelElement = document.createElement('div');\n            labelElement.textContent = label;\n            labelElement.style.cssText = \"\\n          color: white;\\n          font-size: 14px;\\n          margin-top: 10px;\\n          font-weight: bold;\\n        \";\n            preview.appendChild(img);\n            preview.appendChild(labelElement);\n            previewContainer.appendChild(preview);\n            return true;\n        } catch (error) {\n            console.error(\"Error adding \".concat(label, \" preview:\"), error);\n            return false;\n        }\n    };\n    // Add debug info div\n    const debugInfo = document.createElement('div');\n    debugInfo.style.cssText = \"\\n      position: absolute;\\n      top: -30px;\\n      left: 0;\\n      width: 100%;\\n      color: white;\\n      font-size: 12px;\\n      text-align: center;\\n    \";\n    debugInfo.textContent = \"Screen: \".concat(screenImage ? 'YES' : 'NO', \", Webcam: \").concat(webcamImage ? 'YES' : 'NO');\n    previewContainer.appendChild(debugInfo);\n    // Add both images to preview if available\n    if (screenImage) {\n        addImagePreview(screenImage, 'Screen Capture');\n    }\n    if (webcamImage) {\n        addImagePreview(webcamImage, 'Webcam Capture');\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = \"Dot position: x=\".concat(Math.round(dotPosition.x), \", y=\").concat(Math.round(dotPosition.y));\n        positionInfo.style.cssText = \"\\n        color: #ffcc00;\\n        font-size: 14px;\\n        position: absolute;\\n        top: -50px;\\n        left: 0;\\n        width: 100%;\\n        text-align: center;\\n      \";\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add countdown timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n      position: absolute;\\n      bottom: -25px;\\n      right: 20px;\\n      color: white;\\n      font-size: 12px;\\n      background-color: rgba(0, 0, 0, 0.7);\\n      padding: 3px 8px;\\n      border-radius: 4px;\\n    \";\n    previewContainer.appendChild(timerElement);\n    // Add to document body\n    document.body.appendChild(previewContainer);\n    // Countdown and remove the preview after 2 seconds\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            // Fade out\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            previewContainer.style.opacity = '0';\n            // Remove after fade\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup after 5 seconds in case anything goes wrong\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n    return previewContainer;\n};\n/**\n   * Complete capture and preview process\n   * @param {Object} options - Process options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.onStatusUpdate - Function to update status\n   * @param {string} options.captureFolder - Folder to save captures in\n   */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.error('[captureImages] Invalid position:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid dot position (captureImages)');\n        return;\n    }\n    let dotInterval;\n    try {\n        // Make sure we have a valid canvas reference\n        if (!(canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current)) {\n            throw new Error(\"Canvas reference is invalid\");\n        }\n        // Draw the dot in its position first to ensure it's visible\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Initially draw the dot\n        drawRedDot(ctx, position.x, position.y);\n        // Create an interval to keep redrawing the dot to ensure it stays visible\n        dotInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y);\n        }, 200);\n        // First run the countdown\n        //   await runCountdown(\n        //     position,\n        //     canvasRef.current,\n        //     onStatusUpdate, \n        //     null // No callback here as we'll handle it directly\n        //   );\n        await runCountdown(position, canvas, onStatusUpdate, async ()=>{\n            try {\n                // ✅ Validate again here if needed\n                if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n                    throw new Error('Position is missing after countdown');\n                }\n                // Capture both canvas and webcam\n                const result = await captureImages({\n                    canvasRef,\n                    position,\n                    captureCounter,\n                    saveImageToServer,\n                    setCaptureCounter,\n                    setProcessStatus,\n                    toggleTopBar,\n                    captureFolder\n                });\n                return result;\n            } catch (err) {\n                console.error('[captureAndPreviewProcess] Error during capture:', err);\n                setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n            }\n        });\n        // Make sure dot is visible after countdown\n        drawRedDot(ctx, position.x, position.y);\n        // Capture the images\n        const captureResult = await captureImages({\n            canvasRef,\n            position,\n            captureCounter,\n            saveImageToServer,\n            setCaptureCounter,\n            setProcessStatus,\n            toggleTopBar,\n            captureFolder\n        });\n        // Make sure dot is visible after capturing\n        drawRedDot(ctx, position.x, position.y);\n        // Show preview of captured images\n        showCapturePreview(captureResult.screenImage, captureResult.webcamImage, captureResult.position);\n        // Make sure dot is visible after preview\n        drawRedDot(ctx, position.x, position.y);\n        // Show TopBar again after a delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n            // Make sure dot is still visible even after showing TopBar\n            drawRedDot(ctx, position.x, position.y);\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"Error in capture and preview process:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Error: \".concat(error.message));\n        }\n        // Show TopBar again even if error occurred\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        throw error;\n    } finally{\n        // Clear the dot redraw interval if it was created\n        if (dotInterval) {\n            clearInterval(dotInterval);\n        }\n    }\n};\n/**\n   * Generate a random dot position within the canvas\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {number} padding - Padding from the edges\n   * @returns {Object} - {x, y} position\n   */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n   * Draw a red dot on the canvas\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @param {number} radius - Dot radius\n   * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n   * @returns {Object} - {x, y} position\n   */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n   * Initialize canvas for drawing\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {HTMLElement} parent - Parent element for dimensions\n   * @returns {boolean} - Success status\n   */ const initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsaUVBQWlFO0FBRWpFOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLHlCQUF5QixDQUFDQyxVQUFVQztJQUM3QyxJQUFJLENBQUNELFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyw4Q0FBOENMO1FBQzNELE9BQU87SUFDVDtJQUVBLE1BQU1NLHFCQUFxQkMsU0FBU0MsZ0JBQWdCLENBQUM7SUFDckRGLG1CQUFtQkcsT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHQyxNQUFNO0lBRTFDLE1BQU1DLFlBQVlYLFdBQVdZLElBQUksR0FBR2IsU0FBU0UsQ0FBQztJQUM5QyxNQUFNWSxZQUFZYixXQUFXYyxHQUFHLEdBQUdmLFNBQVNHLENBQUM7SUFFN0MsTUFBTWEsbUJBQW1CVCxTQUFTVSxhQUFhLENBQUM7SUFDaERELGlCQUFpQkUsU0FBUyxHQUFHO0lBQzdCRixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLHlDQUd4Qk4sT0FEQ0YsV0FBVSxvQkFDSSxPQUFmRSxZQUFZLElBQUc7SUFrQnhCUCxTQUFTYyxJQUFJLENBQUNDLFdBQVcsQ0FBQ047SUFDMUIsT0FBT0E7QUFDVCxFQUFFO0FBRUY7Ozs7OztDQU1ELEdBQ00sTUFBTU8sZUFBZSxPQUFPdkIsVUFBVXdCLFFBQVFDLGdCQUFnQkM7SUFDakUsSUFBSSxDQUFDMUIsWUFBWSxPQUFPQSxTQUFTRSxDQUFDLEtBQUssWUFBWSxPQUFPRixTQUFTRyxDQUFDLEtBQUssVUFBVTtRQUNqRkMsUUFBUUMsSUFBSSxDQUFDLG9DQUFvQ0w7UUFDakR5QiwyQkFBQUEscUNBQUFBLGVBQWlCO1lBQ2ZFLGVBQWU7WUFD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QzlCRCxJQUFJd0gsU0FBUyxDQUFDLEdBQUcsR0FBRy9ILE9BQU93QyxLQUFLLEVBQUV4QyxPQUFPeUMsTUFBTTtJQUMvQ2xDLElBQUl5SCxTQUFTLEdBQUc7SUFDaEJ6SCxJQUFJMEgsUUFBUSxDQUFDLEdBQUcsR0FBR2pJLE9BQU93QyxLQUFLLEVBQUV4QyxPQUFPeUMsTUFBTTtJQUU5QyxPQUFPO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY291bnRTYXZlLmpzXG4vLyBTaGFyZWQgZnVuY3Rpb25hbGl0eSBmb3IgY291bnRkb3duIGFuZCBpbWFnZSBjYXB0dXJlIHByb2Nlc3Nlc1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGRpc3BsYXlzIGEgY291bnRkb3duIGVsZW1lbnQgYWJvdmUgYSBkb3QgcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKiBAcGFyYW0ge0RPTVJlY3R9IGNhbnZhc1JlY3QgLSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBvZiB0aGUgY2FudmFzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGNvdW50ZG93biBmaW5pc2hlc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBjcmVhdGVkIGNvdW50ZG93biBlbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDb3VudGRvd25FbGVtZW50ID0gKHBvc2l0aW9uLCBjYW52YXNSZWN0KSA9PiB7XG4gICAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVDb3VudGRvd25FbGVtZW50XSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgXG4gICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1jb3VudGRvd24sIC5mb3JjZWQtY291bnRkb3duLCAuY2VudGVyLWNvdW50ZG93bi1iYWNrdXAnKTtcbiAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG4gIFxuICAgIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLng7XG4gICAgY29uc3QgYWJzb2x1dGVZID0gY2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55O1xuICBcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogJHthYnNvbHV0ZVh9cHg7XG4gICAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgIHJldHVybiBjb3VudGRvd25FbGVtZW50O1xuICB9O1xuICBcbiAgLyoqXG4gKiBSdW5zIGEgY291bnRkb3duIHByb2Nlc3MgdGhhdCBkaXNwbGF5cyAzLTItMSBhYm92ZSBhIGRvdFxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIGRvdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25TdGF0dXNVcGRhdGUgLSBGdW5jdGlvbiB0byB1cGRhdGUgc3RhdHVzIG1lc3NhZ2VzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGNvdW50ZG93biBjb21wbGV0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1bkNvdW50ZG93biA9IGFzeW5jIChwb3NpdGlvbiwgY2FudmFzLCBvblN0YXR1c1VwZGF0ZSwgb25Db21wbGV0ZSkgPT4ge1xuICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKCdbcnVuQ291bnRkb3duXSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkludmFsaWQgZG90IHBvc2l0aW9uXCIsXG4gICAgICAgIGNvdW50ZG93blZhbHVlOiBudWxsLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gY3JlYXRlQ291bnRkb3duRWxlbWVudChwb3NpdGlvbiwgY2FudmFzUmVjdCk7XG4gICAgXG4gICAgaWYgKCFjb3VudGRvd25FbGVtZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tydW5Db3VudGRvd25dIENvdW50ZG93biBlbGVtZW50IGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIFxuICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgXG4gICAgbGV0IGNvdW50ID0gMztcbiAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gIFxuICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY291bnRkb3duSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvdW50LS07XG4gIFxuICAgICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY291bnRkb3duSW50ZXJ2YWwpO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICBcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJDYXB0dXJpbmcgaW1hZ2UuLi5cIixcbiAgICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICYmIHR5cGVvZiBwb3NpdGlvbi54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcG9zaXRpb24ueSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltydW5Db3VudGRvd25dIFBvc2l0aW9uIGlzIG51bGwgYWZ0ZXIgY291bnRkb3duXCIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gIFxuICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDgwMCk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBDYXB0dXJlcyBpbWFnZXMgZnJvbSBib3RoIGNhbnZhcyBhbmQgd2ViY2FtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7UmVhY3QuUmVmT2JqZWN0fSBvcHRpb25zLmNhbnZhc1JlZiAtIFJlZiB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnRlciAtIEN1cnJlbnQgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2F2ZUltYWdlVG9TZXJ2ZXIgLSBGdW5jdGlvbiB0byBzYXZlIGltYWdlIHRvIHNlcnZlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudGVyIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldFByb2Nlc3NTdGF0dXMgLSBGdW5jdGlvbiB0byB1cGRhdGUgcHJvY2VzcyBzdGF0dXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50b2dnbGVUb3BCYXIgLSBGdW5jdGlvbiB0byB0b2dnbGUgdG9wIGJhciB2aXNpYmlsaXR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhcHR1cmVGb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBjYXB0dXJlcyBpblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFJlc3VsdCB3aXRoIGNhcHR1cmVkIGltYWdlIGRhdGFcbiAgICovXG4gIGV4cG9ydCBjb25zdCBjYXB0dXJlSW1hZ2VzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICBjYXB0dXJlRm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICB9ID0gb3B0aW9ucztcbiAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSBTdHJpbmcoY2FwdHVyZUNvdW50ZXIpLnBhZFN0YXJ0KDMsICcwJyk7XG4gICAgICBjb25zdCBzY3JlZW5GaWxlbmFtZSA9IGBzY3JlZW5fJHtjb3VudGVyfS5qcGdgO1xuICAgICAgY29uc3Qgd2ViY2FtRmlsZW5hbWUgPSBgd2ViY2FtXyR7Y291bnRlcn0uanBnYDtcbiAgICAgIGNvbnN0IHBhcmFtZXRlckZpbGVuYW1lID0gYHBhcmFtZXRlcl8ke2NvdW50ZXJ9LmNzdmA7XG4gIFxuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgcHJvY2VzcyB3aXRoIGNvdW50ZXI6ICR7Y291bnRlcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBEb3QgcG9zaXRpb246IHg9JHtwb3NpdGlvbi54fSwgeT0ke3Bvc2l0aW9uLnl9YCk7XG4gIFxuICAgICAgbGV0IHNjcmVlbkltYWdlRGF0YSA9IG51bGw7XG4gICAgICBsZXQgd2ViY2FtSW1hZ2VEYXRhID0gbnVsbDtcbiAgICAgIGxldCB1c2VkQ2FwdHVyZU51bWJlciA9IGNhcHR1cmVDb3VudGVyO1xuICBcbiAgICAgIC8vID09PSAxLiBDYXB0dXJlIHNjcmVlbiBpbWFnZSBmcm9tIGNhbnZhcyA9PT1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgICAgICAgICAvLyDinIUgTWFrZSBzdXJlIHRoZSByZWQgZG90IGlzIGRyYXduIFJJR0hUIGJlZm9yZSBzY3JlZW4gY2FwdHVyZVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgXG4gICAgICAgICAgY29uc29sZS5sb2coYENhbnZhcyBkaW1lbnNpb25zOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgICAgIHNjcmVlbkltYWdlRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTY3JlZW4gaW1hZ2UgY2FwdHVyZWQsIHNpemU6ICR7c2NyZWVuSW1hZ2VEYXRhLmxlbmd0aH0gY2hhcnNgKTtcbiAgXG4gICAgICAgICAgaWYgKHNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JlZW5SZXNwb25zZSA9IGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgICBzY3JlZW5JbWFnZURhdGEsXG4gICAgICAgICAgICAgIHNjcmVlbkZpbGVuYW1lLFxuICAgICAgICAgICAgICAnc2NyZWVuJyxcbiAgICAgICAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgICAgICAgKTtcbiAgXG4gICAgICAgICAgICBpZiAoc2NyZWVuUmVzcG9uc2UgJiYgc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlcikge1xuICAgICAgICAgICAgICB1c2VkQ2FwdHVyZU51bWJlciA9IHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXI7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTZXJ2ZXIgYXNzaWduZWQgY2FwdHVyZSBudW1iZXI6ICR7dXNlZENhcHR1cmVOdW1iZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChzY3JlZW5FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgb3Igc2F2aW5nIHNjcmVlbiBpbWFnZTpcIiwgc2NyZWVuRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsLCBjYW5ub3QgY2FwdHVyZSBzY3JlZW5cIik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDIuIENhcHR1cmUgd2ViY2FtIGltYWdlID09PVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBdHRlbXB0aW5nIHRvIGNhcHR1cmUgd2ViY2FtIHNpbGVudGx5XCIpO1xuICBcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gd2luZG93LnZpZGVvRWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICBcbiAgICAgICAgaWYgKHZpZGVvRWxlbWVudCAmJiB2aWRlb0VsZW1lbnQucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdmlkZW9FbGVtZW50LnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlb0VsZW1lbnQsIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIFxuICAgICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoXG4gICAgICAgICAgICAgIHdlYmNhbUltYWdlRGF0YSxcbiAgICAgICAgICAgICAgYHdlYmNhbV8ke1N0cmluZyh1c2VkQ2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYCxcbiAgICAgICAgICAgICAgJ3dlYmNhbScsXG4gICAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIGNvbnN0IHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWaWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICB0ZW1wVmlkZW8uc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICAgICAgICB0ZW1wVmlkZW8uc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gIFxuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApO1xuICAgICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgXG4gICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIFxuICAgICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoXG4gICAgICAgICAgICAgIHdlYmNhbUltYWdlRGF0YSxcbiAgICAgICAgICAgICAgYHdlYmNhbV8ke1N0cmluZyh1c2VkQ2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYCxcbiAgICAgICAgICAgICAgJ3dlYmNhbScsXG4gICAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgIGlmICh0ZW1wVmlkZW8ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGVtcFZpZGVvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHdlYmNhbUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgd2ViY2FtIHNpbGVudGx5OlwiLCB3ZWJjYW1FcnJvcik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDMuIFNhdmUgcGFyYW1ldGVyIENTViA9PT1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgcGFyYW1ldGVyIENTVlwiKTtcbiAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICAgICAgYGRvdF94LCR7cG9zaXRpb24ueH1gLFxuICAgICAgICAgIGBkb3RfeSwke3Bvc2l0aW9uLnl9YCxcbiAgICAgICAgICBgY2FudmFzX3dpZHRoLCR7Y2FudmFzID8gY2FudmFzLndpZHRoIDogMH1gLFxuICAgICAgICAgIGBjYW52YXNfaGVpZ2h0LCR7Y2FudmFzID8gY2FudmFzLmhlaWdodCA6IDB9YCxcbiAgICAgICAgICBgd2luZG93X3dpZHRoLCR7d2luZG93LmlubmVyV2lkdGh9YCxcbiAgICAgICAgICBgd2luZG93X2hlaWdodCwke3dpbmRvdy5pbm5lckhlaWdodH1gLFxuICAgICAgICAgIGB0aW1lc3RhbXAsJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICBcbiAgICAgICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgICAgICBjb25zdCBjc3ZSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBcbiAgICAgICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY3N2UmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUoY3N2UmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgY3N2UmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgaWYgKHNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoXG4gICAgICAgICAgICBjc3ZEYXRhVXJsLFxuICAgICAgICAgICAgYHBhcmFtZXRlcl8ke1N0cmluZyh1c2VkQ2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uY3N2YCxcbiAgICAgICAgICAgICdwYXJhbWV0ZXJzJyxcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChjc3ZFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHBhcmFtZXRlciBDU1Y6XCIsIGNzdkVycm9yKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyA9PT0gNC4gVXBkYXRlIGNvdW50ZXIgPT09XG4gICAgICBpZiAoc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIodXNlZENhcHR1cmVOdW1iZXIgKyAxKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyA9PT0gNS4gU2V0IHByb2Nlc3Mgc3RhdHVzID09PVxuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZWQgd2l0aCBkb3QgYXQ6IHg9JHtwb3NpdGlvbi54fSwgeT0ke3Bvc2l0aW9uLnl9YCk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDYuIFJldHVybiBjYXB0dXJlIGRhdGEgPT09XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogc2NyZWVuSW1hZ2VEYXRhLFxuICAgICAgICB3ZWJjYW1JbWFnZTogd2ViY2FtSW1hZ2VEYXRhLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZU51bWJlcjogdXNlZENhcHR1cmVOdW1iZXJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgY2FwdHVyZTpcIiwgZXJyb3IpO1xuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRXJyb3IgY2FwdHVyaW5nIGltYWdlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIERpc3BsYXkgYSBwcmV2aWV3IG9mIHRoZSBjYXB0dXJlZCBpbWFnZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmVlbkltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHNjcmVlbiBpbWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViY2FtSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgd2ViY2FtIGltYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkb3RQb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gICAqL1xuICBleHBvcnQgY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgZG90UG9zaXRpb24pID0+IHtcbiAgICBpZiAoIXNjcmVlbkltYWdlICYmICF3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gaW1hZ2VzIGF2YWlsYWJsZSB0byBwcmV2aWV3XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBwcmV2aWV3IGNvbnRhaW5lcnMgZmlyc3RcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdQcmV2aWV3cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXB0dXJlLXByZXZpZXctY29udGFpbmVyJyk7XG4gICAgICBleGlzdGluZ1ByZXZpZXdzLmZvckVhY2gocHJldmlldyA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbW92aW5nIGV4aXN0aW5nIHByZXZpZXcgY29udGFpbmVyXCIpO1xuICAgICAgICAgIHByZXZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2xlYW5pbmcgdXAgZXhpc3RpbmcgcHJldmlld3M6XCIsIGNsZWFudXBFcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBwcmV2aWV3IGNvbnRhaW5lclxuICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYXB0dXJlLXByZXZpZXctY29udGFpbmVyJztcbiAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGdhcDogMjBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgIGA7XG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gYWRkIGFuIGltYWdlIHRvIHRoZSBwcmV2aWV3XG4gICAgY29uc3QgYWRkSW1hZ2VQcmV2aWV3ID0gKGltYWdlLCBsYWJlbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlO1xuICAgICAgICBpbWcuYWx0ID0gbGFiZWw7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgIGxhYmVsRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZChsYWJlbEVsZW1lbnQpO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHByZXZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFkZGluZyAke2xhYmVsfSBwcmV2aWV3OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIGRlYnVnIGluZm8gZGl2XG4gICAgY29uc3QgZGVidWdJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVidWdJbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IC0zMHB4O1xuICAgICAgbGVmdDogMDtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGA7XG4gICAgZGVidWdJbmZvLnRleHRDb250ZW50ID0gYFNjcmVlbjogJHtzY3JlZW5JbWFnZSA/ICdZRVMnIDogJ05PJ30sIFdlYmNhbTogJHt3ZWJjYW1JbWFnZSA/ICdZRVMnIDogJ05PJ31gO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoZGVidWdJbmZvKTtcbiAgICBcbiAgICAvLyBBZGQgYm90aCBpbWFnZXMgdG8gcHJldmlldyBpZiBhdmFpbGFibGVcbiAgICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICAgIGFkZEltYWdlUHJldmlldyhzY3JlZW5JbWFnZSwgJ1NjcmVlbiBDYXB0dXJlJyk7XG4gICAgfVxuICAgIFxuICAgIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgICAgYWRkSW1hZ2VQcmV2aWV3KHdlYmNhbUltYWdlLCAnV2ViY2FtIENhcHR1cmUnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGRvdCBwb3NpdGlvbiBpbmZvIGlmIGF2YWlsYWJsZVxuICAgIGlmIChkb3RQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3NpdGlvbkluZm8udGV4dENvbnRlbnQgPSBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLnkpfWA7XG4gICAgICBwb3NpdGlvbkluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC01MHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9zaXRpb25JbmZvKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGNvdW50ZG93biB0aW1lclxuICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgXG4gICAgLy8gQWRkIHRvIGRvY3VtZW50IGJvZHlcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIFxuICAgIC8vIENvdW50ZG93biBhbmQgcmVtb3ZlIHRoZSBwcmV2aWV3IGFmdGVyIDIgc2Vjb25kc1xuICAgIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAvLyBGYWRlIG91dFxuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwLjNzIGVhc2UnO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIC8vIFJlbW92ZSBhZnRlciBmYWRlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgLy8gU2FmZXR5IGNsZWFudXAgYWZ0ZXIgNSBzZWNvbmRzIGluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfSwgNTAwMCk7XG4gICAgXG4gICAgcmV0dXJuIHByZXZpZXdDb250YWluZXI7XG4gIH07XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvY2VzcyBvcHRpb25zXG4gICAqIEBwYXJhbSB7UmVhY3QuUmVmT2JqZWN0fSBvcHRpb25zLmNhbnZhc1JlZiAtIFJlZiB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnRlciAtIEN1cnJlbnQgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2F2ZUltYWdlVG9TZXJ2ZXIgLSBGdW5jdGlvbiB0byBzYXZlIGltYWdlIHRvIHNlcnZlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudGVyIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldFByb2Nlc3NTdGF0dXMgLSBGdW5jdGlvbiB0byB1cGRhdGUgcHJvY2VzcyBzdGF0dXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50b2dnbGVUb3BCYXIgLSBGdW5jdGlvbiB0byB0b2dnbGUgdG9wIGJhciB2aXNpYmlsaXR5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdGF0dXNVcGRhdGUgLSBGdW5jdGlvbiB0byB1cGRhdGUgc3RhdHVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhcHR1cmVGb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBjYXB0dXJlcyBpblxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICBjYXB0dXJlRm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW2NhcHR1cmVJbWFnZXNdIEludmFsaWQgcG9zaXRpb246JywgcG9zaXRpb24pO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oJ0Vycm9yOiBJbnZhbGlkIGRvdCBwb3NpdGlvbiAoY2FwdHVyZUltYWdlcyknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIFxuICAgIFxuICAgIGxldCBkb3RJbnRlcnZhbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHZhbGlkIGNhbnZhcyByZWZlcmVuY2VcbiAgICAgICAgaWYgKCFjYW52YXNSZWY/LmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgZG90IGluIGl0cyBwb3NpdGlvbiBmaXJzdCB0byBlbnN1cmUgaXQncyB2aXNpYmxlXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxseSBkcmF3IHRoZSBkb3RcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGludGVydmFsIHRvIGtlZXAgcmVkcmF3aW5nIHRoZSBkb3QgdG8gZW5zdXJlIGl0IHN0YXlzIHZpc2libGVcbiAgICAgICAgZG90SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHJ1biB0aGUgY291bnRkb3duXG4gICAgLy8gICBhd2FpdCBydW5Db3VudGRvd24oXG4gICAgLy8gICAgIHBvc2l0aW9uLFxuICAgIC8vICAgICBjYW52YXNSZWYuY3VycmVudCxcbiAgICAvLyAgICAgb25TdGF0dXNVcGRhdGUsIFxuICAgIC8vICAgICBudWxsIC8vIE5vIGNhbGxiYWNrIGhlcmUgYXMgd2UnbGwgaGFuZGxlIGl0IGRpcmVjdGx5XG4gICAgLy8gICApO1xuICAgICAgICBhd2FpdCBydW5Db3VudGRvd24ocG9zaXRpb24sIGNhbnZhcywgb25TdGF0dXNVcGRhdGUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyDinIUgVmFsaWRhdGUgYWdhaW4gaGVyZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gaXMgbWlzc2luZyBhZnRlciBjb3VudGRvd24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGJvdGggY2FudmFzIGFuZCB3ZWJjYW1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXMoe1xuICAgICAgICAgICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2VUb1NlcnZlcixcbiAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBFcnJvciBkdXJpbmcgY2FwdHVyZTonLCBlcnIpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyB2aXNpYmxlIGFmdGVyIGNvdW50ZG93blxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBpbWFnZXNcbiAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXMoe1xuICAgICAgICAgICAgY2FudmFzUmVmLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgdmlzaWJsZSBhZnRlciBjYXB0dXJpbmdcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBwcmV2aWV3IG9mIGNhcHR1cmVkIGltYWdlc1xuICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXcoXG4gICAgICAgICAgICBjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlLFxuICAgICAgICAgICAgY2FwdHVyZVJlc3VsdC53ZWJjYW1JbWFnZSxcbiAgICAgICAgICAgIGNhcHR1cmVSZXN1bHQucG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgdmlzaWJsZSBhZnRlciBwcmV2aWV3XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGUgZXZlbiBhZnRlciBzaG93aW5nIFRvcEJhclxuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICB9LCAyNTAwKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjYXB0dXJlUmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIGVycm9yIG9jY3VycmVkXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDE1MDApO1xuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQ2xlYXIgdGhlIGRvdCByZWRyYXcgaW50ZXJ2YWwgaWYgaXQgd2FzIGNyZWF0ZWRcbiAgICAgIGlmIChkb3RJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGRvdEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gZG90IHBvc2l0aW9uIHdpdGhpbiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gUGFkZGluZyBmcm9tIHRoZSBlZGdlc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHt4LCB5fSBwb3NpdGlvblxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiB7IHg6IDEwMCwgeTogMTAwIH07IC8vIEZhbGxiYWNrIHBvc2l0aW9uXG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgfHwgMzAwOyAvLyBGYWxsYmFjayBpZiBoZWlnaHQgaXMgMFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyICogcGFkZGluZykpICsgcGFkZGluZ1xuICAgIH07XG4gIH07XG4gIFxuICAvKipcbiAgICogRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ2FudmFzIDJEIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIERvdCByYWRpdXNcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckNhbnZhcyAtIFdoZXRoZXIgdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyAoZGVmYXVsdDogdHJ1ZSlcbiAgICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAgICovXG4gIGV4cG9ydCBjb25zdCBkcmF3UmVkRG90ID0gKGN0eCwgeCwgeSwgcmFkaXVzID0gMTIsIGNsZWFyQ2FudmFzID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBpZiByZXF1ZXN0ZWQgKGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgaWYgKGNsZWFyQ2FudmFzKSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGJyaWdodCByZWQgY29sb3JcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3QgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIEFkZCBhIHNlY29uZCBsYXJnZXIgZ2xvdyBmb3IgZXZlbiBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDYsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuMyknO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH07XG4gIFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBjYW52YXMgZm9yIGRyYXdpbmdcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IC0gUGFyZW50IGVsZW1lbnQgZm9yIGRpbWVuc2lvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gU3VjY2VzcyBzdGF0dXNcbiAgICovXG4gIGV4cG9ydCBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzIGFuZCBzZXQgd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsiXSwibmFtZXMiOlsiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInBvc2l0aW9uIiwiY2FudmFzUmVjdCIsIngiLCJ5IiwiY29uc29sZSIsIndhcm4iLCJleGlzdGluZ0NvdW50ZG93bnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJyZW1vdmUiLCJhYnNvbHV0ZVgiLCJsZWZ0IiwiYWJzb2x1dGVZIiwidG9wIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJydW5Db3VudGRvd24iLCJjYW52YXMiLCJvblN0YXR1c1VwZGF0ZSIsIm9uQ29tcGxldGUiLCJwcm9jZXNzU3RhdHVzIiwiY291bnRkb3duVmFsdWUiLCJpc0NhcHR1cmluZyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3UmVkRG90IiwiY291bnQiLCJ0ZXh0Q29udGVudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY291bnRkb3duSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2FwdHVyZUltYWdlcyIsIm9wdGlvbnMiLCJjYW52YXNSZWYiLCJjYXB0dXJlQ291bnRlciIsInNhdmVJbWFnZVRvU2VydmVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzZXRQcm9jZXNzU3RhdHVzIiwidG9nZ2xlVG9wQmFyIiwiY2FwdHVyZUZvbGRlciIsImNvdW50ZXIiLCJTdHJpbmciLCJwYWRTdGFydCIsInNjcmVlbkZpbGVuYW1lIiwid2ViY2FtRmlsZW5hbWUiLCJwYXJhbWV0ZXJGaWxlbmFtZSIsImxvZyIsInNjcmVlbkltYWdlRGF0YSIsIndlYmNhbUltYWdlRGF0YSIsInVzZWRDYXB0dXJlTnVtYmVyIiwiY3VycmVudCIsIndpZHRoIiwiaGVpZ2h0IiwidG9EYXRhVVJMIiwibGVuZ3RoIiwic2NyZWVuUmVzcG9uc2UiLCJjYXB0dXJlTnVtYmVyIiwic2NyZWVuRXJyb3IiLCJlcnJvciIsInZpZGVvRWxlbWVudCIsIndpbmRvdyIsInF1ZXJ5U2VsZWN0b3IiLCJyZWFkeVN0YXRlIiwidGVtcENhbnZhcyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImRyYXdJbWFnZSIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJ0ZW1wVmlkZW8iLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJvcGFjaXR5Iiwic3JjT2JqZWN0IiwidGltZW91dElkIiwib25sb2FkZWRkYXRhIiwiY2xlYXJUaW1lb3V0IiwiZ2V0VHJhY2tzIiwidHJhY2siLCJzdG9wIiwid2ViY2FtRXJyb3IiLCJjc3ZEYXRhIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiam9pbiIsImNzdkJsb2IiLCJCbG9iIiwidHlwZSIsImNzdlJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsImNzdkVycm9yIiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsIm1lc3NhZ2UiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJkb3RQb3NpdGlvbiIsImV4aXN0aW5nUHJldmlld3MiLCJwcmV2aWV3IiwiY2xlYW51cEVycm9yIiwicHJldmlld0NvbnRhaW5lciIsImFkZEltYWdlUHJldmlldyIsImltYWdlIiwibGFiZWwiLCJpbWciLCJzcmMiLCJhbHQiLCJsYWJlbEVsZW1lbnQiLCJkZWJ1Z0luZm8iLCJwb3NpdGlvbkluZm8iLCJNYXRoIiwicm91bmQiLCJ0aW1lckVsZW1lbnQiLCJ0aW1lTGVmdCIsImludGVydmFsIiwidHJhbnNpdGlvbiIsInRvRml4ZWQiLCJjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MiLCJkb3RJbnRlcnZhbCIsIkVycm9yIiwiZXJyIiwiY2FwdHVyZVJlc3VsdCIsImdldFJhbmRvbVBvc2l0aW9uIiwicGFkZGluZyIsImZsb29yIiwicmFuZG9tIiwicmFkaXVzIiwiY2xlYXJDYW52YXMiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsInBhcmVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js\n"));

/***/ })

}]);