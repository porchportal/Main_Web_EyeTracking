"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset_components-gui_Action_CalibrateHandler_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CalibrateHandler.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibratePoints.js\");\n/* harmony import */ var _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CaptureHandler */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CaptureHandler.js\");\n/* harmony import */ var _DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotCaptureUtil */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js\");\n// CalibrateHandler.js - Using the existing CaptureHandler class\n\n\n\nclass CalibrateHandler {\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = \"\\n      position: fixed;\\n      top: 10px;\\n      right: 10px;\\n      background-color: rgba(0, 102, 204, 0.9);\\n      color: white;\\n      font-size: 14px;\\n      font-weight: bold;\\n      padding: 8px 12px;\\n      border-radius: 6px;\\n      z-index: 9999;\\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n    \";\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            var _this_setOutputText, _this;\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Processing point \".concat(index + 1, \"/\").concat(total);\n            }\n            // Draw the dot\n            const canvas = this.canvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            const ctx = canvas.getContext('2d');\n            (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n            // Create countdown element\n            const canvasRect = canvas.getBoundingClientRect();\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'calibrate-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(canvasRect.left + point.x, \"px;\\n        top: \").concat(canvasRect.top + point.y - 60, \"px;\\n        transform: translateX(-50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 9999;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Run countdown\n            for(let count = 3; count > 0; count--){\n                var _this_setOutputText1, _this1;\n                countdownElement.textContent = count;\n                (_this_setOutputText1 = (_this1 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this1, \"Point \".concat(index + 1, \"/\").concat(total, \" - countdown \").concat(count));\n                // Make sure dot remains visible during countdown\n                (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n                // Wait for next countdown step\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            // Show capturing indicator\n            countdownElement.textContent = \"âœ“\";\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Capturing point \".concat(index + 1, \"/\").concat(total));\n            // Remove countdown element\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Use CaptureHandler to handle the capture process\n            const captureResult = await this.captureHandler.captureAndShowPreview(this.captureCounter, this.canvasRef, point);\n            // Add null check before using the result\n            if (!captureResult) {\n                console.warn(\"No capture result for point \".concat(index + 1));\n            // You might want to set a default or retry logic here\n            }\n            // Wait for the preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2500));\n            return true;\n        } catch (err) {\n            var _this_setOutputText2, _this2;\n            console.error(\"Error processing point \".concat(index + 1, \":\"), err);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Error: \".concat(err.message);\n            }\n            (_this_setOutputText2 = (_this2 = this).setOutputText) === null || _this_setOutputText2 === void 0 ? void 0 : _this_setOutputText2.call(_this2, \"Error: \".concat(err.message));\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        if (this.toggleTopBar) {\n            this.toggleTopBar(false);\n        }\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            var _this_setOutputText, _this, _this_setOutputText1, _this1;\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Starting calibration with \".concat(this.calibrationPoints.length, \" points\"));\n            let successCount = 0;\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (success) {\n                    successCount++;\n                }\n                // Small delay between points\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            (_this_setOutputText1 = (_this1 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this1, \"Calibration completed: \".concat(successCount, \"/\").concat(this.calibrationPoints.length, \" points captured\"));\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(this.calibrationPoints.length, \" points\");\n            }\n            // Turn TopBar back on\n            if (this.toggleTopBar) {\n                this.toggleTopBar(true);\n            }\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        } catch (error) {\n            // console.error('Calibration error:', error);\n            // this.setOutputText?.(`Calibration error: ${error.message}`);\n            // if (this.statusIndicator) {\n            //   this.statusIndicator.textContent = `Error: ${error.message}`;\n            // }\n            // // Make sure we turn TopBar back on even on error\n            // if (this.toggleTopBar) {\n            //   this.toggleTopBar(true);\n            // }\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1500);\n            // Return a default object to prevent null reference errors\n            return {\n                screenImage: '',\n                webcamImage: '',\n                success: false\n            };\n        } finally{\n            this.isProcessing = false;\n            // Remove the status indicator after a delay\n            setTimeout(()=>{\n                if (this.statusIndicator && this.statusIndicator.parentNode) {\n                    this.statusIndicator.parentNode.removeChild(this.statusIndicator);\n                }\n            }, 3000);\n        }\n    }\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Create a CaptureHandler instance for handling the captures\n        this.captureHandler = new _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__[\"default\"](// Pass saveImageToServer function\n        async (imageData, filename, type, folder)=>{\n            try {\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type,\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    console.warn(\"Server responded with \".concat(response.status));\n                    return {};\n                }\n                return await response.json();\n            } catch (err) {\n                console.error(\"Error saving \".concat(type, \":\"), err);\n                return {};\n            }\n        }, // Pass setCaptureCounter function\n        (newCounter)=>{\n            if (typeof newCounter === 'function') {\n                this.captureCounter = newCounter(this.captureCounter);\n            } else {\n                this.captureCounter = newCounter;\n            }\n            if (this.setCaptureCounter) {\n                this.setCaptureCounter(this.captureCounter);\n            }\n        }, // Pass setProcessStatus function\n        (status)=>{\n            if (this.setOutputText) {\n                this.setOutputText(status);\n            }\n        }, // Pass toggleTopBar function\n        this.toggleTopBar);\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxnRUFBZ0U7QUFDRjtBQUNoQjtBQUNBO0FBRTlDLE1BQU1HO0lBc0VKQyx3QkFBd0I7UUFDdEIsTUFBTUMscUJBQXFCQyxTQUFTQyxnQkFBZ0IsQ0FBQztRQUNyREYsbUJBQW1CRyxPQUFPLENBQUNDLENBQUFBLFlBQWFBLFVBQVVDLE1BQU07UUFFeEQsTUFBTUQsWUFBWUgsU0FBU0ssYUFBYSxDQUFDO1FBQ3pDRixVQUFVRyxTQUFTLEdBQUc7UUFDdEJILFVBQVVJLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBYTNCUixTQUFTUyxJQUFJLENBQUNDLFdBQVcsQ0FBQ1A7UUFDMUIsSUFBSSxDQUFDUSxlQUFlLEdBQUdSO1FBQ3ZCLE9BQU9BO0lBQ1Q7SUFFQSxNQUFNUyx3QkFBd0JDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUU7UUFDakQsSUFBSTtnQkEwREY7WUF6REEsSUFBSSxDQUFDRixTQUFTLE9BQU9BLE1BQU1HLENBQUMsS0FBSyxZQUFZLE9BQU9ILE1BQU1JLENBQUMsS0FBSyxVQUFVO2dCQUN4RSxNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFFQSxJQUFJLElBQUksQ0FBQ1AsZUFBZSxFQUFFO2dCQUN4QixJQUFJLENBQUNBLGVBQWUsQ0FBQ1EsV0FBVyxHQUFHLG9CQUFpQ0osT0FBYkQsUUFBUSxHQUFFLEtBQVMsT0FBTkM7WUFDdEU7WUFFQSxlQUFlO1lBQ2YsTUFBTUssU0FBUyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTztZQUNyQyxJQUFJLENBQUNGLFFBQVE7Z0JBQ1gsTUFBTSxJQUFJRixNQUFNO1lBQ2xCO1lBRUEsTUFBTUssTUFBTUgsT0FBT0ksVUFBVSxDQUFDO1lBQzlCNUIsMkRBQVVBLENBQUMyQixLQUFLVixNQUFNRyxDQUFD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WTtnQkFDcEMsSUFBSSxDQUFDdEMsY0FBYyxHQUFHc0MsV0FBVyxJQUFJLENBQUN0QyxjQUFjO1lBQ3RELE9BQU87Z0JBQ0wsSUFBSSxDQUFDQSxjQUFjLEdBQUdzQztZQUN4QjtZQUVBLElBQUksSUFBSSxDQUFDZixpQkFBaUIsRUFBRTtnQkFDMUIsSUFBSSxDQUFDQSxpQkFBaUIsQ0FBQyxJQUFJLENBQUN2QixjQUFjO1lBQzVDO1FBQ0YsR0FDQSxpQ0FBaUM7UUFDakMsQ0FBQ29DO1lBQ0MsSUFBSSxJQUFJLENBQUM3QyxhQUFhLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDNkM7WUFDckI7UUFDRixHQUNBLDZCQUE2QjtRQUM3QixJQUFJLENBQUM1QixZQUFZO1FBR25CLFlBQVk7UUFDWixJQUFJLENBQUNELFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNnQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNwRSxlQUFlLEdBQUc7SUFDekI7QUFpT0Y7QUFFQSxpRUFBZWQsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlSGFuZGxlci5qcyAtIFVzaW5nIHRoZSBleGlzdGluZyBDYXB0dXJlSGFuZGxlciBjbGFzc1xuaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4vQ2FsaWJyYXRlUG9pbnRzJztcbmltcG9ydCBDYXB0dXJlSGFuZGxlciBmcm9tICcuL0NhcHR1cmVIYW5kbGVyJztcbmltcG9ydCB7IGRyYXdSZWREb3QgfSBmcm9tICcuL0RvdENhcHR1cmVVdGlsJztcblxuY2xhc3MgQ2FsaWJyYXRlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRPdXRwdXRUZXh0ID0gY29uZmlnLnNldE91dHB1dFRleHQ7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlciB8fCAxO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlRm9sZGVyID0gY29uZmlnLmNhcHR1cmVGb2xkZXIgfHwgJ2V5ZV90cmFja2luZ19jYXB0dXJlcyc7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gY29uZmlnLm9uQ29tcGxldGU7XG5cbiAgICAvLyBBY2NlcHQgcGFzc2VkLWluIGNhbGlicmF0aW9uIHBvaW50cyAoZnJvbSBTZXRDYWxpYnJhdGVBY3Rpb24uanMpXG4gICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cyA9IGNvbmZpZy5jYWxpYnJhdGlvblBvaW50cyB8fCBbXTtcblxuICAgIC8vIENyZWF0ZSBhIENhcHR1cmVIYW5kbGVyIGluc3RhbmNlIGZvciBoYW5kbGluZyB0aGUgY2FwdHVyZXNcbiAgICB0aGlzLmNhcHR1cmVIYW5kbGVyID0gbmV3IENhcHR1cmVIYW5kbGVyKFxuICAgICAgLy8gUGFzcyBzYXZlSW1hZ2VUb1NlcnZlciBmdW5jdGlvblxuICAgICAgYXN5bmMgKGltYWdlRGF0YSwgZmlsZW5hbWUsIHR5cGUsIGZvbGRlcikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGZvbGRlcjogdGhpcy5jYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgJHt0eXBlfTpgLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFBhc3Mgc2V0Q2FwdHVyZUNvdW50ZXIgZnVuY3Rpb25cbiAgICAgIChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q291bnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBuZXdDb3VudGVyKHRoaXMuY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBuZXdDb3VudGVyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5zZXRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIodGhpcy5jYXB0dXJlQ291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIHNldFByb2Nlc3NTdGF0dXMgZnVuY3Rpb25cbiAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0T3V0cHV0VGV4dCkge1xuICAgICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dChzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUGFzcyB0b2dnbGVUb3BCYXIgZnVuY3Rpb25cbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyXG4gICAgKTtcblxuICAgIC8vIEludGVybmFsc1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50UG9pbnRJbmRleCA9IDA7XG4gICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IgPSBudWxsO1xuICB9XG5cbiAgY3JlYXRlU3RhdHVzSW5kaWNhdG9yKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSW5kaWNhdG9ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcicpO1xuICAgIGV4aXN0aW5nSW5kaWNhdG9ycy5mb3JFYWNoKGluZGljYXRvciA9PiBpbmRpY2F0b3IucmVtb3ZlKCkpO1xuXG4gICAgY29uc3QgaW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgaW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDEwcHg7XG4gICAgICByaWdodDogMTBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHBhZGRpbmc6IDhweCAxMnB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluZGljYXRvcik7XG4gICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IgPSBpbmRpY2F0b3I7XG4gICAgcmV0dXJuIGluZGljYXRvcjtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NDYWxpYnJhdGlvblBvaW50KHBvaW50LCBpbmRleCwgdG90YWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFwb2ludCB8fCB0eXBlb2YgcG9pbnQueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvaW50LnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FsaWJyYXRpb24gcG9pbnRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBQcm9jZXNzaW5nIHBvaW50ICR7aW5kZXggKyAxfS8ke3RvdGFsfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNvdW50ZG93biBlbGVtZW50XG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLWNvdW50ZG93bic7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgbGVmdDogJHtjYW52YXNSZWN0LmxlZnQgKyBwb2ludC54fXB4O1xuICAgICAgICB0b3A6ICR7Y2FudmFzUmVjdC50b3AgKyBwb2ludC55IC0gNjB9cHg7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBSdW4gY291bnRkb3duXG4gICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBQb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH0gLSBjb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgcmVtYWlucyB2aXNpYmxlIGR1cmluZyBjb3VudGRvd25cbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgbmV4dCBjb3VudGRvd24gc3RlcFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgY2FwdHVyaW5nIGluZGljYXRvclxuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgQ2FwdHVyaW5nIHBvaW50ICR7aW5kZXggKyAxfS8ke3RvdGFsfWApO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgICAgXG4gICAgICAvLyBVc2UgQ2FwdHVyZUhhbmRsZXIgdG8gaGFuZGxlIHRoZSBjYXB0dXJlIHByb2Nlc3NcbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCB0aGlzLmNhcHR1cmVIYW5kbGVyLmNhcHR1cmVBbmRTaG93UHJldmlldyhcbiAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlcixcbiAgICAgICAgdGhpcy5jYW52YXNSZWYsXG4gICAgICAgIHBvaW50XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBBZGQgbnVsbCBjaGVjayBiZWZvcmUgdXNpbmcgdGhlIHJlc3VsdFxuICAgICAgaWYgKCFjYXB0dXJlUmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gY2FwdHVyZSByZXN1bHQgZm9yIHBvaW50ICR7aW5kZXggKyAxfWApO1xuICAgICAgICAvLyBZb3UgbWlnaHQgd2FudCB0byBzZXQgYSBkZWZhdWx0IG9yIHJldHJ5IGxvZ2ljIGhlcmVcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHByZXZpZXcgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyNTAwKSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX06YCwgZXJyKTtcbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FsaWJyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNQcm9jZXNzaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuXG5cblxuICAgIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljYXRvciA9IHRoaXMuY3JlYXRlU3RhdHVzSW5kaWNhdG9yKCk7XG4gICAgaW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0luaXRpYWxpemluZyBjYWxpYnJhdGlvbi4uLic7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCByZWFkeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IGdlbmVyYXRlIGlmIG5vbmUgd2VyZSBwYXNzZWQgaW5cbiAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBTdGFydGluZyBjYWxpYnJhdGlvbiB3aXRoICR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2ApO1xuICAgICAgXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5wcm9jZXNzQ2FsaWJyYXRpb25Qb2ludChcbiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzW2ldLCBcbiAgICAgICAgICBpLCBcbiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU21hbGwgZGVsYXkgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUdXJuIFRvcEJhciBiYWNrIG9uXG4gICAgICBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignQ2FsaWJyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgLy8gdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAvLyBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgIC8vICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgLy8gfVxuICAgICAgXG4gICAgICAvLyAvLyBNYWtlIHN1cmUgd2UgdHVybiBUb3BCYXIgYmFjayBvbiBldmVuIG9uIGVycm9yXG4gICAgICAvLyBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIC8vICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAvLyB9XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgY2FwdHVyZSBhbmQgcHJldmlldzonLCBlcnJvcik7XG4gIFxuICAgICAgLy8gU2hvdyBlcnJvciBtZXNzYWdlXG4gICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDE1MDApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gYSBkZWZhdWx0IG9iamVjdCB0byBwcmV2ZW50IG51bGwgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgdGhlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvciAmJiB0aGlzLnN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnN0YXR1c0luZGljYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMDApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWxpYnJhdGVIYW5kbGVyOyJdLCJuYW1lcyI6WyJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiQ2FwdHVyZUhhbmRsZXIiLCJkcmF3UmVkRG90IiwiQ2FsaWJyYXRlSGFuZGxlciIsImNyZWF0ZVN0YXR1c0luZGljYXRvciIsImV4aXN0aW5nSW5kaWNhdG9ycyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpbmRpY2F0b3IiLCJyZW1vdmUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwic3RhdHVzSW5kaWNhdG9yIiwicHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQiLCJwb2ludCIsImluZGV4IiwidG90YWwiLCJ4IiwieSIsIkVycm9yIiwidGV4dENvbnRlbnQiLCJjYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNhbnZhc1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3VudGRvd25FbGVtZW50IiwibGVmdCIsInRvcCIsImNvdW50Iiwic2V0T3V0cHV0VGV4dCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhcHR1cmVSZXN1bHQiLCJjYXB0dXJlSGFuZGxlciIsImNhcHR1cmVBbmRTaG93UHJldmlldyIsImNhcHR1cmVDb3VudGVyIiwiY29uc29sZSIsIndhcm4iLCJlcnIiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGFydENhbGlicmF0aW9uIiwiaXNQcm9jZXNzaW5nIiwidG9nZ2xlVG9wQmFyIiwid2lkdGgiLCJoZWlnaHQiLCJjYWxpYnJhdGlvblBvaW50cyIsImxlbmd0aCIsInN1Y2Nlc3NDb3VudCIsImkiLCJzdWNjZXNzIiwib25Db21wbGV0ZSIsInNldFByb2Nlc3NTdGF0dXMiLCJ3aW5kb3ciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJzZXRDYXB0dXJlQ291bnRlciIsImNhcHR1cmVGb2xkZXIiLCJpbWFnZURhdGEiLCJmaWxlbmFtZSIsInR5cGUiLCJmb2xkZXIiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsInN0YXR1cyIsImpzb24iLCJuZXdDb3VudGVyIiwiY3VycmVudFBvaW50SW5kZXgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CaptureHandler.js":
/*!*************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CaptureHandler.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// CaptureHandler.js - With fixed capture numbering\nclass CaptureHandler {\n    // Show preview of the SAVED images for exactly 2 seconds\n    showCapturePreview(screenImage, webcamImage, dotPosition) {\n        // Create a centered preview container\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = \"\\n        position: fixed;\\n        top: 50%;\\n        left: 50%;\\n        transform: translate(-50%, -50%);\\n        display: flex;\\n        gap: 20px;\\n        background-color: rgba(0, 0, 0, 0.85);\\n        padding: 20px;\\n        border-radius: 12px;\\n        z-index: 999999;\\n        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n        opacity: 1;\\n        transition: opacity 0.3s ease;\\n      \";\n        // Function to create an image preview element\n        const createImagePreview = (imageData, label)=>{\n            if (!imageData) return null;\n            const preview = document.createElement('div');\n            preview.style.cssText = \"\\n          display: flex;\\n          flex-direction: column;\\n          align-items: center;\\n        \";\n            const img = document.createElement('img');\n            img.src = imageData;\n            img.style.cssText = \"\\n          max-width: 320px;\\n          max-height: 240px;\\n          border: 3px solid white;\\n          border-radius: 8px;\\n          background-color: #333;\\n        \";\n            // Event listeners for image loading\n            img.onload = ()=>console.log(\"\".concat(label, \" image loaded successfully\"));\n            img.onerror = (e)=>console.error(\"Error loading \".concat(label, \" image:\"), e);\n            const textLabel = document.createElement('div');\n            textLabel.textContent = label;\n            textLabel.style.cssText = \"\\n          color: white;\\n          font-size: 14px;\\n          margin-top: 10px;\\n          font-weight: bold;\\n        \";\n            preview.appendChild(img);\n            preview.appendChild(textLabel);\n            return preview;\n        };\n        // Add debug info\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = \"\\n        position: absolute;\\n        top: -30px;\\n        left: 0;\\n        width: 100%;\\n        color: white;\\n        font-size: 12px;\\n        text-align: center;\\n      \";\n        debugInfo.textContent = \"Screen: \".concat(screenImage ? 'YES' : 'NO', \", Webcam: \").concat(webcamImage ? 'YES' : 'NO');\n        previewContainer.appendChild(debugInfo);\n        // Add screen capture preview\n        const screenPreview = createImagePreview(screenImage, 'Screen Capture');\n        if (screenPreview) {\n            previewContainer.appendChild(screenPreview);\n        }\n        // Add webcam capture preview\n        const webcamPreview = createImagePreview(webcamImage, 'Webcam Capture');\n        if (webcamPreview) {\n            previewContainer.appendChild(webcamPreview);\n        }\n        // Add dot position info if available\n        if (dotPosition) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = \"Dot position: x=\".concat(Math.round(dotPosition.x), \", y=\").concat(Math.round(dotPosition.y));\n            positionInfo.style.cssText = \"\\n          color: #ffcc00;\\n          font-size: 14px;\\n          position: absolute;\\n          top: -50px;\\n          left: 0;\\n          width: 100%;\\n          text-align: center;\\n        \";\n            previewContainer.appendChild(positionInfo);\n        }\n        // Add timer countdown\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = \"\\n        position: absolute;\\n        bottom: -25px;\\n        right: 20px;\\n        color: white;\\n        font-size: 12px;\\n        background-color: rgba(0, 0, 0, 0.7);\\n        padding: 3px 8px;\\n        border-radius: 4px;\\n      \";\n        previewContainer.appendChild(timerElement);\n        // Add the preview to the document\n        document.body.appendChild(previewContainer);\n        // Start countdown timer\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Take a webcam picture and immediately stop the stream\n    async captureWebcamImage(captureNumber) {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format the filename with the current counter\n            const filename = \"webcam_\".concat(String(captureNumber).padStart(3, '0'), \".jpg\");\n            // Create a new stream just for this capture\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: true,\n                audio: false\n            });\n            // Create a temporary video element\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Connect stream to video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Check if video dimensions are valid\n            if (tempVideo.videoWidth === 0 || tempVideo.videoHeight === 0) {\n                console.warn(\"Video dimensions are invalid, using default dimensions\");\n            }\n            // Capture the frame\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = tempVideo.videoWidth || 640;\n            tempCanvas.height = tempVideo.videoHeight || 480;\n            const ctx = tempCanvas.getContext('2d');\n            try {\n                ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n                // Get image data\n                const imageData = tempCanvas.toDataURL('image/png');\n                // Save the image\n                if (this.saveImageToServer) {\n                    const saveResponse = await this.saveImageToServer(imageData, filename, 'webcam', this.captureFolder);\n                    console.log(\"Saved webcam image: \".concat(filename));\n                    return {\n                        imageData,\n                        saveResponse\n                    };\n                }\n                return {\n                    imageData,\n                    saveResponse: null\n                };\n            } catch (drawError) {\n                console.error(\"Error drawing video to canvas:\", drawError);\n                return {\n                    imageData: null,\n                    saveResponse: null\n                };\n            }\n        } catch (error) {\n            console.error(\"Error capturing webcam image:\", error);\n            return {\n                imageData: null,\n                saveResponse: null\n            };\n        } finally{\n            // IMPORTANT: Always stop the stream and clean up, even if there was an error\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        }\n    }\n    // Capture screen image from canvas\n    async captureScreenImage(canvasRef, captureNumber) {\n        try {\n            // Format the filename with the current counter\n            const filename = \"screen_\".concat(String(captureNumber).padStart(3, '0'), \".jpg\");\n            const canvas = canvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas reference is null\");\n                return {\n                    imageData: null,\n                    saveResponse: null\n                };\n            }\n            // Get image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save the image\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(imageData, filename, 'screen', this.captureFolder);\n                console.log(\"Saved screen image: \".concat(filename, \", response:\"), saveResponse);\n                return {\n                    imageData,\n                    saveResponse\n                };\n            }\n            return {\n                imageData,\n                saveResponse: null\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            return {\n                imageData: null,\n                saveResponse: null\n            };\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(captureNumber, params) {\n        try {\n            // Format the filename with the current counter\n            const filename = \"parameter_\".concat(String(captureNumber).padStart(3, '0'), \".csv\");\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                ...Object.entries(params).map((param)=>{\n                    let [name, value] = param;\n                    return \"\".concat(name, \",\").concat(value);\n                })\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(csvDataUrl, filename, 'parameters', this.captureFolder);\n                console.log(\"Saved parameter CSV: \".concat(filename));\n                return saveResponse;\n            }\n            return null;\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n            return null;\n        }\n    }\n    // Main capture and show process\n    async captureAndShowPreview(captureCounter, canvasRef, position) {\n        try {\n            console.log(\"Starting capture process with counter: \".concat(captureCounter));\n            // Step 1: Capture screen image\n            const { imageData: screenImage, saveResponse: screenResponse } = await this.captureScreenImage(canvasRef, captureCounter);\n            // Get the capture number from the response if available (for continuous numbering)\n            let usedCaptureNumber = captureCounter;\n            if (screenResponse && screenResponse.captureNumber) {\n                usedCaptureNumber = screenResponse.captureNumber;\n                console.log(\"Server assigned capture number: \".concat(usedCaptureNumber));\n            }\n            // Step 2: Capture webcam image (and immediately stop stream)\n            const { imageData: webcamImage } = await this.captureWebcamImage(usedCaptureNumber);\n            // Step 3: Save parameters\n            const params = {\n                dot_x: position ? position.x : 0,\n                dot_y: position ? position.y : 0,\n                canvas_width: canvasRef.current ? canvasRef.current.width : 0,\n                canvas_height: canvasRef.current ? canvasRef.current.height : 0,\n                window_width: window.innerWidth,\n                window_height: window.innerHeight,\n                timestamp: new Date().toISOString()\n            };\n            await this.saveParameterCSV(usedCaptureNumber, params);\n            // Step 4: Increment counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server is managing numbering, use the next number\n                if (screenResponse && screenResponse.captureNumber) {\n                    this.setCaptureCounter(screenResponse.captureNumber + 1);\n                } else {\n                    this.setCaptureCounter((prev)=>prev + 1);\n                }\n            }\n            // Step 5: Update status\n            if (this.setProcessStatus) {\n                this.setProcessStatus(\"Captured with dot at: x=\".concat(position === null || position === void 0 ? void 0 : position.x, \", y=\").concat(position === null || position === void 0 ? void 0 : position.y));\n            }\n            // Step 6: Show preview using the in-memory image data\n            this.showCapturePreview(screenImage, webcamImage, position);\n            // Step 7: Show TopBar again after preview is done\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2200); // Wait longer than the preview duration\n            // Step 8: Clear status after a delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1500);\n            // Clear error message after delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        }\n    }\n    constructor(saveFunction, counterSetter, statusSetter, toggleTopBarFunction){\n        this.saveImageToServer = saveFunction;\n        this.setCaptureCounter = counterSetter;\n        this.setProcessStatus = statusSetter;\n        this.toggleTopBar = toggleTopBarFunction;\n        this.captureFolder = 'eye_tracking_captures'; // Use fixed folder name\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CaptureHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYXB0dXJlSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsbURBQW1EO0FBRW5ELE1BQU1BO0lBU0YseURBQXlEO0lBQ3pEQyxtQkFBbUJDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDeEQsc0NBQXNDO1FBQ3RDLE1BQU1DLG1CQUFtQkMsU0FBU0MsYUFBYSxDQUFDO1FBQ2hERixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBZ0JsQyw4Q0FBOEM7UUFDOUMsTUFBTUMscUJBQXFCLENBQUNDLFdBQVdDO1lBQ3JDLElBQUksQ0FBQ0QsV0FBVyxPQUFPO1lBRXZCLE1BQU1FLFVBQVVQLFNBQVNDLGFBQWEsQ0FBQztZQUN2Q00sUUFBUUwsS0FBSyxDQUFDQyxPQUFPLEdBQUk7WUFNekIsTUFBTUssTUFBTVIsU0FBU0MsYUFBYSxDQUFDO1lBQ25DTyxJQUFJQyxHQUFHLEdBQUdKO1lBQ1ZHLElBQUlOLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1lBUXJCLG9DQUFvQztZQUNwQ0ssSUFBSUUsTUFBTSxHQUFHLElBQU1DLFFBQVFDLEdBQUcsQ0FBQyxHQUFTLE9BQU5OLE9BQU07WUFDeENFLElBQUlLLE9BQU8sR0FBRyxDQUFDQyxJQUFNSCxRQUFRSSxLQUFLLENBQUMsaUJBQXVCLE9BQU5ULE9BQU0sWUFBVVE7WUFFcEUsTUFBTUUsWUFBWWhCLFNBQVNDLGFBQWEsQ0FBQztZQUN6Q2UsVUFBVUMsV0FBVyxHQUFHWDtZQUN4QlUsVUFBVWQsS0FBSyxDQUFDQyxPQUFPLEdBQUk7WUFPM0JJLFFBQVFXLFdBQVcsQ0FBQ1Y7WUFDcEJELFFBQVFXLFdBQVcsQ0FBQ0Y7WUFDcEIsT0FBT1Q7UUFDVDtRQUVBLGlCQUFpQjtRQUNqQixNQUFNWSxZQUFZbkIsU0FBU0MsYUFBYSxDQUFDO1FBQ3pDa0IsVUFBVWpCLEtBQUssQ0FB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QUssWUFBWTtvQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7Z0JBQ3BCLE9BQU8sSUFBSSxLQUE2QixJQUFJVixPQUFPVSxZQUFZLEVBQUU7b0JBQy9EVixPQUFPVSxZQUFZLENBQUM7Z0JBQ3RCO1lBQ0YsR0FBRztZQUVILGtDQUFrQztZQUNsQ3ZGLFdBQVc7Z0JBQ1QsSUFBSSxJQUFJLENBQUNzRixnQkFBZ0IsRUFBRTtvQkFDekIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQztnQkFDeEI7WUFDRixHQUFHO1FBQ0w7SUFDRjtJQTlZQUcsWUFBWUMsWUFBWSxFQUFFQyxhQUFhLEVBQUVDLFlBQVksRUFBRUMsb0JBQW9CLENBQUU7UUFDM0UsSUFBSSxDQUFDeEQsaUJBQWlCLEdBQUdxRDtRQUN6QixJQUFJLENBQUNOLGlCQUFpQixHQUFHTztRQUN6QixJQUFJLENBQUNMLGdCQUFnQixHQUFHTTtRQUN4QixJQUFJLENBQUNMLFlBQVksR0FBR007UUFDcEIsSUFBSSxDQUFDdEQsYUFBYSxHQUFHLHlCQUF5Qix3QkFBd0I7SUFDeEU7QUF5WUY7QUFFQSxpRUFBZS9FLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9BY3Rpb24vQ2FwdHVyZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FwdHVyZUhhbmRsZXIuanMgLSBXaXRoIGZpeGVkIGNhcHR1cmUgbnVtYmVyaW5nXG5cbmNsYXNzIENhcHR1cmVIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzYXZlRnVuY3Rpb24sIGNvdW50ZXJTZXR0ZXIsIHN0YXR1c1NldHRlciwgdG9nZ2xlVG9wQmFyRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBzYXZlRnVuY3Rpb247XG4gICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyID0gY291bnRlclNldHRlcjtcbiAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyA9IHN0YXR1c1NldHRlcjtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gdG9nZ2xlVG9wQmFyRnVuY3Rpb247XG4gICAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJzsgLy8gVXNlIGZpeGVkIGZvbGRlciBuYW1lXG4gICAgfVxuICBcbiAgICAvLyBTaG93IHByZXZpZXcgb2YgdGhlIFNBVkVEIGltYWdlcyBmb3IgZXhhY3RseSAyIHNlY29uZHNcbiAgICBzaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlLCBkb3RQb3NpdGlvbikge1xuICAgICAgLy8gQ3JlYXRlIGEgY2VudGVyZWQgcHJldmlldyBjb250YWluZXJcbiAgICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZ2FwOiAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZTtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIC8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbWFnZSBwcmV2aWV3IGVsZW1lbnRcbiAgICAgIGNvbnN0IGNyZWF0ZUltYWdlUHJldmlldyA9IChpbWFnZURhdGEsIGxhYmVsKSA9PiB7XG4gICAgICAgIGlmICghaW1hZ2VEYXRhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZURhdGE7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmVudCBsaXN0ZW5lcnMgZm9yIGltYWdlIGxvYWRpbmdcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IGNvbnNvbGUubG9nKGAke2xhYmVsfSBpbWFnZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgJHtsYWJlbH0gaW1hZ2U6YCwgZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXh0TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGV4dExhYmVsLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgIHRleHRMYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZCh0ZXh0TGFiZWwpO1xuICAgICAgICByZXR1cm4gcHJldmlldztcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEFkZCBkZWJ1ZyBpbmZvXG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRlYnVnSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTMwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIGRlYnVnSW5mby50ZXh0Q29udGVudCA9IGBTY3JlZW46ICR7c2NyZWVuSW1hZ2UgPyAnWUVTJyA6ICdOTyd9LCBXZWJjYW06ICR7d2ViY2FtSW1hZ2UgPyAnWUVTJyA6ICdOTyd9YDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoZGVidWdJbmZvKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHNjcmVlbiBjYXB0dXJlIHByZXZpZXdcbiAgICAgIGNvbnN0IHNjcmVlblByZXZpZXcgPSBjcmVhdGVJbWFnZVByZXZpZXcoc2NyZWVuSW1hZ2UsICdTY3JlZW4gQ2FwdHVyZScpO1xuICAgICAgaWYgKHNjcmVlblByZXZpZXcpIHtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChzY3JlZW5QcmV2aWV3KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIHdlYmNhbSBjYXB0dXJlIHByZXZpZXdcbiAgICAgIGNvbnN0IHdlYmNhbVByZXZpZXcgPSBjcmVhdGVJbWFnZVByZXZpZXcod2ViY2FtSW1hZ2UsICdXZWJjYW0gQ2FwdHVyZScpO1xuICAgICAgaWYgKHdlYmNhbVByZXZpZXcpIHtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWJjYW1QcmV2aWV3KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIGRvdCBwb3NpdGlvbiBpbmZvIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGRvdFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwb3NpdGlvbkluZm8udGV4dENvbnRlbnQgPSBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLnkpfWA7XG4gICAgICAgIHBvc2l0aW9uSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgdG9wOiAtNTBweDtcbiAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgYDtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3NpdGlvbkluZm8pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgdGltZXIgY291bnRkb3duXG4gICAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICAgIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICBgO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBBZGQgdGhlIHByZXZpZXcgdG8gdGhlIGRvY3VtZW50XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBjb3VudGRvd24gdGltZXJcbiAgICAgIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGZhZGVcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICAgIFxuICAgICAgLy8gU2FmZXR5IGNsZWFudXAgYWZ0ZXIgNSBzZWNvbmRzIGluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgXG4gICAgLy8gVGFrZSBhIHdlYmNhbSBwaWN0dXJlIGFuZCBpbW1lZGlhdGVseSBzdG9wIHRoZSBzdHJlYW1cbiAgICBhc3luYyBjYXB0dXJlV2ViY2FtSW1hZ2UoY2FwdHVyZU51bWJlcikge1xuICAgICAgbGV0IHN0cmVhbSA9IG51bGw7XG4gICAgICBsZXQgdGVtcFZpZGVvID0gbnVsbDtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRm9ybWF0IHRoZSBmaWxlbmFtZSB3aXRoIHRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBgd2ViY2FtXyR7U3RyaW5nKGNhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2A7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RyZWFtIGp1c3QgZm9yIHRoaXMgY2FwdHVyZVxuICAgICAgICBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHZpZGVvIGVsZW1lbnRcbiAgICAgICAgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgICAgIHRlbXBWaWRlby5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb25uZWN0IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50XG4gICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB2aWRlbyB0byBpbml0aWFsaXplXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWaWRlbyBsb2FkaW5nIHRpbWVkIG91dCwgY29udGludWluZyBhbnl3YXlcIik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGEgY2xlYXIgZnJhbWVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdmlkZW8gZGltZW5zaW9ucyBhcmUgdmFsaWRcbiAgICAgICAgaWYgKHRlbXBWaWRlby52aWRlb1dpZHRoID09PSAwIHx8IHRlbXBWaWRlby52aWRlb0hlaWdodCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlZpZGVvIGRpbWVuc2lvbnMgYXJlIGludmFsaWQsIHVzaW5nIGRlZmF1bHQgZGltZW5zaW9uc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgZnJhbWVcbiAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCA0ODA7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTYXZlIHRoZSBpbWFnZVxuICAgICAgICAgIGlmICh0aGlzLnNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgICBjb25zdCBzYXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGltYWdlRGF0YSwgZmlsZW5hbWUsICd3ZWJjYW0nLCB0aGlzLmNhcHR1cmVGb2xkZXIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHdlYmNhbSBpbWFnZTogJHtmaWxlbmFtZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGltYWdlRGF0YSwgc2F2ZVJlc3BvbnNlIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB7IGltYWdlRGF0YSwgc2F2ZVJlc3BvbnNlOiBudWxsIH07XG4gICAgICAgIH0gY2F0Y2ggKGRyYXdFcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkcmF3aW5nIHZpZGVvIHRvIGNhbnZhczpcIiwgZHJhd0Vycm9yKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGE6IG51bGwsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIHdlYmNhbSBpbWFnZTpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBpbWFnZURhdGE6IG51bGwsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBBbHdheXMgc3RvcCB0aGUgc3RyZWFtIGFuZCBjbGVhbiB1cCwgZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0ZW1wVmlkZW8pIHtcbiAgICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICBpZiAodGVtcFZpZGVvLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRlbXBWaWRlby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyBDYXB0dXJlIHNjcmVlbiBpbWFnZSBmcm9tIGNhbnZhc1xuICAgIGFzeW5jIGNhcHR1cmVTY3JlZW5JbWFnZShjYW52YXNSZWYsIGNhcHR1cmVOdW1iZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHNjcmVlbl8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbFwiKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGE6IG51bGwsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdGhlIGltYWdlXG4gICAgICAgIGlmICh0aGlzLnNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgY29uc3Qgc2F2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlcihpbWFnZURhdGEsIGZpbGVuYW1lLCAnc2NyZWVuJywgdGhpcy5jYXB0dXJlRm9sZGVyKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgc2NyZWVuIGltYWdlOiAke2ZpbGVuYW1lfSwgcmVzcG9uc2U6YCwgc2F2ZVJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGEsIHNhdmVSZXNwb25zZSB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBpbWFnZURhdGEsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhcHR1cmluZyBzY3JlZW4gaW1hZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgaW1hZ2VEYXRhOiBudWxsLCBzYXZlUmVzcG9uc2U6IG51bGwgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXIgQ1NWXG4gICAgYXN5bmMgc2F2ZVBhcmFtZXRlckNTVihjYXB0dXJlTnVtYmVyLCBwYXJhbXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHBhcmFtZXRlcl8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5jc3ZgO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIENTViBjb250ZW50IHdpdGggdHdvIGNvbHVtbnM6IG5hbWUgYW5kIHZhbHVlXG4gICAgICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IGAke25hbWV9LCR7dmFsdWV9YClcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgQ1NWIHRvIGRhdGEgVVJMXG4gICAgICAgIGNvbnN0IGNzdkJsb2IgPSBuZXcgQmxvYihbY3N2RGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgICAgY29uc3QgY3N2UmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNzdlJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKGNzdlJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIGNzdlJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgQ1NWIHVzaW5nIHRoZSBBUElcbiAgICAgICAgaWYgKHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICBjb25zdCBzYXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGNzdkRhdGFVcmwsIGZpbGVuYW1lLCAncGFyYW1ldGVycycsIHRoaXMuY2FwdHVyZUZvbGRlcik7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHBhcmFtZXRlciBDU1Y6ICR7ZmlsZW5hbWV9YCk7XG4gICAgICAgICAgcmV0dXJuIHNhdmVSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGNhdGNoIChjc3ZFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHBhcmFtZXRlciBDU1Y6XCIsIGNzdkVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyBNYWluIGNhcHR1cmUgYW5kIHNob3cgcHJvY2Vzc1xuICAgIGFzeW5jIGNhcHR1cmVBbmRTaG93UHJldmlldyhjYXB0dXJlQ291bnRlciwgY2FudmFzUmVmLCBwb3NpdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgcHJvY2VzcyB3aXRoIGNvdW50ZXI6ICR7Y2FwdHVyZUNvdW50ZXJ9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDE6IENhcHR1cmUgc2NyZWVuIGltYWdlXG4gICAgICAgIGNvbnN0IHsgaW1hZ2VEYXRhOiBzY3JlZW5JbWFnZSwgc2F2ZVJlc3BvbnNlOiBzY3JlZW5SZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5jYXB0dXJlU2NyZWVuSW1hZ2UoY2FudmFzUmVmLCBjYXB0dXJlQ291bnRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIGNhcHR1cmUgbnVtYmVyIGZyb20gdGhlIHJlc3BvbnNlIGlmIGF2YWlsYWJsZSAoZm9yIGNvbnRpbnVvdXMgbnVtYmVyaW5nKVxuICAgICAgICBsZXQgdXNlZENhcHR1cmVOdW1iZXIgPSBjYXB0dXJlQ291bnRlcjtcbiAgICAgICAgaWYgKHNjcmVlblJlc3BvbnNlICYmIHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgICB1c2VkQ2FwdHVyZU51bWJlciA9IHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXI7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNlcnZlciBhc3NpZ25lZCBjYXB0dXJlIG51bWJlcjogJHt1c2VkQ2FwdHVyZU51bWJlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAyOiBDYXB0dXJlIHdlYmNhbSBpbWFnZSAoYW5kIGltbWVkaWF0ZWx5IHN0b3Agc3RyZWFtKVxuICAgICAgICBjb25zdCB7IGltYWdlRGF0YTogd2ViY2FtSW1hZ2UgfSA9IGF3YWl0IHRoaXMuY2FwdHVyZVdlYmNhbUltYWdlKHVzZWRDYXB0dXJlTnVtYmVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgMzogU2F2ZSBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBkb3RfeDogcG9zaXRpb24gPyBwb3NpdGlvbi54IDogMCxcbiAgICAgICAgICBkb3RfeTogcG9zaXRpb24gPyBwb3NpdGlvbi55IDogMCxcbiAgICAgICAgICBjYW52YXNfd2lkdGg6IGNhbnZhc1JlZi5jdXJyZW50ID8gY2FudmFzUmVmLmN1cnJlbnQud2lkdGggOiAwLFxuICAgICAgICAgIGNhbnZhc19oZWlnaHQ6IGNhbnZhc1JlZi5jdXJyZW50ID8gY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0IDogMCxcbiAgICAgICAgICB3aW5kb3dfd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgIHdpbmRvd19oZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlUGFyYW1ldGVyQ1NWKHVzZWRDYXB0dXJlTnVtYmVyLCBwYXJhbXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA0OiBJbmNyZW1lbnQgY291bnRlciBmb3IgbmV4dCBjYXB0dXJlXG4gICAgICAgIGlmICh0aGlzLnNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBpcyBtYW5hZ2luZyBudW1iZXJpbmcsIHVzZSB0aGUgbmV4dCBudW1iZXJcbiAgICAgICAgICBpZiAoc2NyZWVuUmVzcG9uc2UgJiYgc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcihzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDU6IFVwZGF0ZSBzdGF0dXNcbiAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZWQgd2l0aCBkb3QgYXQ6IHg9JHtwb3NpdGlvbj8ueH0sIHk9JHtwb3NpdGlvbj8ueX1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA2OiBTaG93IHByZXZpZXcgdXNpbmcgdGhlIGluLW1lbW9yeSBpbWFnZSBkYXRhXG4gICAgICAgIHRoaXMuc2hvd0NhcHR1cmVQcmV2aWV3KHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgcG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA3OiBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBwcmV2aWV3IGlzIGRvbmVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjIwMCk7IC8vIFdhaXQgbG9uZ2VyIHRoYW4gdGhlIHByZXZpZXcgZHVyYXRpb25cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgODogQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlIGFuZCBwcmV2aWV3OicsIGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGVycm9yIG1lc3NhZ2UgYWZ0ZXIgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgZXhwb3J0IGRlZmF1bHQgQ2FwdHVyZUhhbmRsZXI7Il0sIm5hbWVzIjpbIkNhcHR1cmVIYW5kbGVyIiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImRvdFBvc2l0aW9uIiwicHJldmlld0NvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImNyZWF0ZUltYWdlUHJldmlldyIsImltYWdlRGF0YSIsImxhYmVsIiwicHJldmlldyIsImltZyIsInNyYyIsIm9ubG9hZCIsImNvbnNvbGUiLCJsb2ciLCJvbmVycm9yIiwiZSIsImVycm9yIiwidGV4dExhYmVsIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsImRlYnVnSW5mbyIsInNjcmVlblByZXZpZXciLCJ3ZWJjYW1QcmV2aWV3IiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwieCIsInkiLCJ0aW1lckVsZW1lbnQiLCJib2R5IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9wYWNpdHkiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9GaXhlZCIsImNhcHR1cmVXZWJjYW1JbWFnZSIsImNhcHR1cmVOdW1iZXIiLCJzdHJlYW0iLCJ0ZW1wVmlkZW8iLCJmaWxlbmFtZSIsIlN0cmluZyIsInBhZFN0YXJ0IiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwidmlkZW8iLCJhdWRpbyIsImF1dG9wbGF5IiwicGxheXNJbmxpbmUiLCJtdXRlZCIsInBvc2l0aW9uIiwibGVmdCIsInNyY09iamVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGltZW91dElkIiwid2FybiIsIm9ubG9hZGVkZGF0YSIsImNsZWFyVGltZW91dCIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsInRlbXBDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJzYXZlSW1hZ2VUb1NlcnZlciIsInNhdmVSZXNwb25zZSIsImNhcHR1cmVGb2xkZXIiLCJkcmF3RXJyb3IiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdG9wIiwiY2FwdHVyZVNjcmVlbkltYWdlIiwiY2FudmFzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsInNhdmVQYXJhbWV0ZXJDU1YiLCJwYXJhbXMiLCJjc3ZEYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsIm5hbWUiLCJ2YWx1ZSIsImpvaW4iLCJjc3ZCbG9iIiwiQmxvYiIsInR5cGUiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJjc3ZFcnJvciIsImNhcHR1cmVBbmRTaG93UHJldmlldyIsImNhcHR1cmVDb3VudGVyIiwic2NyZWVuUmVzcG9uc2UiLCJ1c2VkQ2FwdHVyZU51bWJlciIsImRvdF94IiwiZG90X3kiLCJjYW52YXNfd2lkdGgiLCJjYW52YXNfaGVpZ2h0Iiwid2luZG93X3dpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsIndpbmRvd19oZWlnaHQiLCJpbm5lckhlaWdodCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInNldENhcHR1cmVDb3VudGVyIiwicHJldiIsInNldFByb2Nlc3NTdGF0dXMiLCJ0b2dnbGVUb3BCYXIiLCJtZXNzYWdlIiwiY29uc3RydWN0b3IiLCJzYXZlRnVuY3Rpb24iLCJjb3VudGVyU2V0dGVyIiwic3RhdHVzU2V0dGVyIiwidG9nZ2xlVG9wQmFyRnVuY3Rpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CaptureHandler.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js":
/*!*************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDotCountdown: () => (/* binding */ createDotCountdown),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   showImagePreview: () => (/* binding */ showImagePreview)\n/* harmony export */ });\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Show preview of captured images for exactly 2 seconds\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Improved function to show preview of captured images for exactly 2 seconds\nconst showImagePreview = (screenImage, webcamImage, dotPosition)=>{\n    // Create a preview container that centers in the screen\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n      position: fixed;\\n      top: 50%;\\n      left: 50%;\\n      transform: translate(-50%, -50%);\\n      display: flex;\\n      gap: 20px;\\n      background-color: rgba(0, 0, 0, 0.85);\\n      padding: 20px;\\n      border-radius: 12px;\\n      z-index: 9999;\\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n      opacity: 1;\\n      transition: opacity 0.2s ease-in-out;\\n    \";\n    // Add screen capture preview if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.style.cssText = \"\\n        max-width: 350px;\\n        max-height: 250px;\\n        border: 3px solid white;\\n        border-radius: 8px;\\n      \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n        color: white;\\n        font-size: 14px;\\n        margin-top: 10px;\\n        font-weight: bold;\\n      \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam capture preview if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.style.cssText = \"\\n        max-width: 350px;\\n        max-height: 250px;\\n        border: 3px solid white;\\n        border-radius: 8px;\\n      \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n        color: white;\\n        font-size: 14px;\\n        margin-top: 10px;\\n        font-weight: bold;\\n      \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = \"Dot position: x=\".concat(Math.round(dotPosition.x), \", y=\").concat(Math.round(dotPosition.y));\n        positionInfo.style.cssText = \"\\n        color: #ffcc00;\\n        font-size: 14px;\\n        position: absolute;\\n        top: -25px;\\n        left: 0;\\n        width: 100%;\\n        text-align: center;\\n      \";\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add timer countdown\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n      position: absolute;\\n      bottom: -25px;\\n      right: 20px;\\n      color: white;\\n      font-size: 12px;\\n      background-color: rgba(0, 0, 0, 0.7);\\n      padding: 3px 8px;\\n      border-radius: 4px;\\n    \";\n    previewContainer.appendChild(timerElement);\n    // Add the preview to the document\n    document.body.appendChild(previewContainer);\n    // Start countdown timer\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            timerElement.textContent = 'Closing...';\n            // Fade out the preview\n            previewContainer.style.opacity = '0';\n            // Remove after fade animation\n            setTimeout(()=>{\n                if (previewContainer && previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 200);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    return previewContainer;\n};\n// Other utility functions remain the same...\n// Create and append a countdown element above a dot\nconst createDotCountdown = (position, canvasRect)=>{\n    // Create the countdown element directly above the dot\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'forced-countdown';\n    // Position it above the dot (calculate absolute position considering the canvas position)\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(absoluteX, \"px;\\n      top: \").concat(absoluteY - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n// Draw a red dot on the canvas\nconst drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12;\n    // Draw the dot with a glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect to the dot\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n// Initialize the canvas for drawing\nconst initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n// Generate a random position on the canvas\nconst getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9Eb3RDYXB0dXJlVXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLG9CQUFvQjtBQUNwQix3REFBd0Q7QUFFeEQsd0RBQXdEO0FBQ3hELG9CQUFvQjtBQUNwQix3REFBd0Q7QUFFeEQsNkVBQTZFO0FBQ3RFLE1BQU1BLG1CQUFtQixDQUFDQyxhQUFhQyxhQUFhQztJQUN2RCx3REFBd0Q7SUFDeEQsTUFBTUMsbUJBQW1CQyxTQUFTQyxhQUFhLENBQUM7SUFDaERGLGlCQUFpQkcsU0FBUyxHQUFHO0lBQzdCSCxpQkFBaUJJLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO0lBZ0JsQywwQ0FBMEM7SUFDMUMsSUFBSVIsYUFBYTtRQUNmLE1BQU1TLGdCQUFnQkwsU0FBU0MsYUFBYSxDQUFDO1FBQzdDSSxjQUFjRixLQUFLLENBQUNDLE9BQU8sR0FBSTtRQU0vQixNQUFNRSxZQUFZTixTQUFTQyxhQUFhLENBQUM7UUFDekNLLFVBQVVDLEdBQUcsR0FBR1g7UUFDaEJVLFVBQVVILEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBTzNCLE1BQU1JLGNBQWNSLFNBQVNDLGFBQWEsQ0FBQztRQUMzQ08sWUFBWUMsV0FBVyxHQUFHO1FBQzFCRCxZQUFZTCxLQUFLLENBQUNDLE9BQU8sR0FBSTtRQU83QkMsY0FBY0ssV0FBVyxDQUFDSjtRQUMxQkQsY0FBY0ssV0FBVyxDQUFDRjtRQUMxQlQsaUJBQWlCVyxXQUFXLENBQUNMO0lBQy9CO0lBRUEsMENBQTBDO0lBQzFDLElBQUlSLGFBQWE7UUFDZixNQUFNYyxnQkFBZ0JYLFNBQVNDLGFBQWEsQ0FBQztRQUM3Q1UsY0FBY1IsS0FBSyxDQUFDQyxPQUFPLEdBQUk7UUFNL0IsTUFBTVEsWUFBWVosU0FBU0MsYUFBYSxDQUFDO1FBQ3pDVyxVQUFVTCxHQUFHLEdBQUdWO1FBQ2hCZSxVQUFVVCxLQUFLLENBQUNDLE9BQU8s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QzdCLE1BQU0rQixtQkFBbUIsQ0FBQ0MsUUFBUUM7SUFDdkMsSUFBSSxDQUFDRCxVQUFVLENBQUNDLFFBQVEsT0FBTztJQUUvQix3Q0FBd0M7SUFDeENELE9BQU9FLEtBQUssR0FBR0QsT0FBT0UsV0FBVztJQUNqQ0gsT0FBT0ksTUFBTSxHQUFHSCxPQUFPSSxZQUFZO0lBRW5DLHdDQUF3QztJQUN4QyxNQUFNaEIsTUFBTVcsT0FBT00sVUFBVSxDQUFDO0lBQzlCakIsSUFBSWtCLFNBQVMsQ0FBQyxHQUFHLEdBQUdQLE9BQU9FLEtBQUssRUFBRUYsT0FBT0ksTUFBTTtJQUMvQ2YsSUFBSUssU0FBUyxHQUFHO0lBQ2hCTCxJQUFJbUIsUUFBUSxDQUFDLEdBQUcsR0FBR1IsT0FBT0UsS0FBSyxFQUFFRixPQUFPSSxNQUFNO0lBRTlDLE9BQU87QUFDVCxFQUFFO0FBRUYsMkNBQTJDO0FBQ3BDLE1BQU1LLG9CQUFvQixTQUFDVDtRQUFRVSwyRUFBVTtJQUNsRCxJQUFJLENBQUNWLFFBQVEsT0FBTztRQUFFakMsR0FBRztRQUFLQyxHQUFHO0lBQUksR0FBRyxvQkFBb0I7SUFFNUQsTUFBTWtDLFFBQVFGLE9BQU9FLEtBQUssSUFBSSxLQUFNLHlCQUF5QjtJQUM3RCxNQUFNRSxTQUFTSixPQUFPSSxNQUFNLElBQUksS0FBSywwQkFBMEI7SUFFL0QsT0FBTztRQUNMckMsR0FBR0YsS0FBSzhDLEtBQUssQ0FBQzlDLEtBQUsrQyxNQUFNLEtBQU1WLENBQUFBLFFBQVEsSUFBSVEsT0FBTSxLQUFNQTtRQUN2RDFDLEdBQUdILEtBQUs4QyxLQUFLLENBQUM5QyxLQUFLK0MsTUFBTSxLQUFNUixDQUFBQSxTQUFTLElBQUlNLE9BQU0sS0FBTUE7SUFDMUQ7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0RvdENhcHR1cmVVdGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERvdENhcHR1cmVVdGlsLmpzXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZG90IGNhcHR1cmUgYW5kIHByZXZpZXcgZGlzcGxheVxuXG4vLyBTaG93IHByZXZpZXcgb2YgY2FwdHVyZWQgaW1hZ2VzIGZvciBleGFjdGx5IDIgc2Vjb25kc1xuLy8gRG90Q2FwdHVyZVV0aWwuanNcbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkb3QgY2FwdHVyZSBhbmQgcHJldmlldyBkaXNwbGF5XG5cbi8vIEltcHJvdmVkIGZ1bmN0aW9uIHRvIHNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXMgZm9yIGV4YWN0bHkgMiBzZWNvbmRzXG5leHBvcnQgY29uc3Qgc2hvd0ltYWdlUHJldmlldyA9IChzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgcHJldmlldyBjb250YWluZXIgdGhhdCBjZW50ZXJzIGluIHRoZSBzY3JlZW5cbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW4tb3V0O1xuICAgIGA7XG4gICAgXG4gICAgLy8gQWRkIHNjcmVlbiBjYXB0dXJlIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCBzY3JlZW5JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHNjcmVlbkltZy5zcmMgPSBzY3JlZW5JbWFnZTtcbiAgICAgIHNjcmVlbkltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXgtd2lkdGg6IDM1MHB4O1xuICAgICAgICBtYXgtaGVpZ2h0OiAyNTBweDtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNjcmVlbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgICBzY3JlZW5MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkltZyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc2NyZWVuUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB3ZWJjYW0gY2FwdHVyZSBwcmV2aWV3IGlmIGF2YWlsYWJsZVxuICAgIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc3Qgd2ViY2FtUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd2ViY2FtUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgd2ViY2FtSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB3ZWJjYW1JbWcuc3JjID0gd2ViY2FtSW1hZ2U7XG4gICAgICB3ZWJjYW1JbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgbWF4LXdpZHRoOiAzNTBweDtcbiAgICAgICAgbWF4LWhlaWdodDogMjUwcHg7XG4gICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWJjYW1MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd2ViY2FtTGFiZWwudGV4dENvbnRlbnQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgICAgd2ViY2FtTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1JbWcpO1xuICAgICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1MYWJlbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgZG90IHBvc2l0aW9uIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgaWYgKGRvdFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvc2l0aW9uSW5mby50ZXh0Q29udGVudCA9IGBEb3QgcG9zaXRpb246IHg9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLngpfSwgeT0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueSl9YDtcbiAgICAgIHBvc2l0aW9uSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogI2ZmY2MwMDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTI1cHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3NpdGlvbkluZm8pO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgdGltZXIgY291bnRkb3duXG4gICAgY29uc3QgdGltZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJzIuMHMnO1xuICAgIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYm90dG9tOiAtMjVweDtcbiAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgcGFkZGluZzogM3B4IDhweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBgO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQodGltZXJFbGVtZW50KTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIHByZXZpZXcgdG8gdGhlIGRvY3VtZW50XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICBcbiAgICAvLyBTdGFydCBjb3VudGRvd24gdGltZXJcbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJ0Nsb3NpbmcuLi4nO1xuICAgICAgICBcbiAgICAgICAgLy8gRmFkZSBvdXQgdGhlIHByZXZpZXdcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGZhZGUgYW5pbWF0aW9uXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyICYmIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICByZXR1cm4gcHJldmlld0NvbnRhaW5lcjtcbiAgfTtcbiAgXG4gIC8vIE90aGVyIHV0aWxpdHkgZnVuY3Rpb25zIHJlbWFpbiB0aGUgc2FtZS4uLlxuICAgIFxuICAvLyBDcmVhdGUgYW5kIGFwcGVuZCBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIGEgZG90XG4gIGV4cG9ydCBjb25zdCBjcmVhdGVEb3RDb3VudGRvd24gPSAocG9zaXRpb24sIGNhbnZhc1JlY3QpID0+IHtcbiAgICAvLyBDcmVhdGUgdGhlIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IGFib3ZlIHRoZSBkb3RcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZm9yY2VkLWNvdW50ZG93bic7XG4gICAgXG4gICAgLy8gUG9zaXRpb24gaXQgYWJvdmUgdGhlIGRvdCAoY2FsY3VsYXRlIGFic29sdXRlIHBvc2l0aW9uIGNvbnNpZGVyaW5nIHRoZSBjYW52YXMgcG9zaXRpb24pXG4gICAgY29uc3QgYWJzb2x1dGVYID0gY2FudmFzUmVjdC5sZWZ0ICsgcG9zaXRpb24ueDtcbiAgICBjb25zdCBhYnNvbHV0ZVkgPSBjYW52YXNSZWN0LnRvcCArIHBvc2l0aW9uLnk7XG4gICAgXG4gICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogJHthYnNvbHV0ZVh9cHg7XG4gICAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgXG4gICAgcmV0dXJuIGNvdW50ZG93bkVsZW1lbnQ7XG4gIH07XG4gIFxuICAvLyBEcmF3IGEgcmVkIGRvdCBvbiB0aGUgY2FudmFzXG4gIGV4cG9ydCBjb25zdCBkcmF3UmVkRG90ID0gKGN0eCwgeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGdsb3cgZWZmZWN0XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gQWRkIGdsb3cgZWZmZWN0IHRvIHRoZSBkb3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJztcbiAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9O1xuICBcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGZvciBkcmF3aW5nXG4gIGV4cG9ydCBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzIGFuZCBzZXQgd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIHBvc2l0aW9uIG9uIHRoZSBjYW52YXNcbiAgZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiB7IHg6IDEwMCwgeTogMTAwIH07IC8vIEZhbGxiYWNrIHBvc2l0aW9uXG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgfHwgMzAwOyAvLyBGYWxsYmFjayBpZiBoZWlnaHQgaXMgMFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyICogcGFkZGluZykpICsgcGFkZGluZ1xuICAgIH07XG4gIH07Il0sIm5hbWVzIjpbInNob3dJbWFnZVByZXZpZXciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiZG90UG9zaXRpb24iLCJwcmV2aWV3Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0Iiwic2NyZWVuUHJldmlldyIsInNjcmVlbkltZyIsInNyYyIsInNjcmVlbkxhYmVsIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsIndlYmNhbVByZXZpZXciLCJ3ZWJjYW1JbWciLCJ3ZWJjYW1MYWJlbCIsInBvc2l0aW9uSW5mbyIsIk1hdGgiLCJyb3VuZCIsIngiLCJ5IiwidGltZXJFbGVtZW50IiwiYm9keSIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5Iiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRvRml4ZWQiLCJjcmVhdGVEb3RDb3VudGRvd24iLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJjb3VudGRvd25FbGVtZW50IiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImRyYXdSZWREb3QiLCJjdHgiLCJyYWRpdXMiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGxTdHlsZSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImluaXRpYWxpemVDYW52YXMiLCJjYW52YXMiLCJwYXJlbnQiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImZpbGxSZWN0IiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js\n"));

/***/ })

}]);