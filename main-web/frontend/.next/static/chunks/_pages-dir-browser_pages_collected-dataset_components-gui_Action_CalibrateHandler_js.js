"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset_components-gui_Action_CalibrateHandler_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CalibrateHandler.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibratePoints.js\");\n// CalibrateHandler.js - This should be placed in the components-gui folder\n// This is a complete implementation of the calibration functionality\n\nclass CalibrateHandler {\n    // Create a status indicator in the top right corner\n    createStatusIndicator() {\n        // Remove any existing indicators first\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>{\n            if (indicator.parentNode) {\n                indicator.parentNode.removeChild(indicator);\n            }\n        });\n        // Create new status indicator\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = \"\\n      position: fixed;\\n      top: 10px;\\n      right: 10px;\\n      background-color: rgba(0, 102, 204, 0.9);\\n      color: white;\\n      font-size: 14px;\\n      font-weight: bold;\\n      padding: 8px 12px;\\n      border-radius: 6px;\\n      z-index: 9999;\\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n    \";\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    // Draw a specific calibration point\n    drawCalibrationPoint(point) {\n        const canvas = this.canvasRef.current;\n        if (!canvas) return null;\n        const ctx = canvas.getContext('2d');\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Draw the point with larger radius and glow effect\n        const radius = 8;\n        // Draw the calibration point\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = 'red';\n        ctx.fill();\n        // Add glow effect\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, radius + 4, 0, Math.PI * 2);\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        return {\n            x: point.x,\n            y: point.y\n        };\n    }\n    // Create a countdown element above the current dot\n    createCountdownElement(position) {\n        // Remove any existing countdown elements\n        const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .center-countdown-backup');\n        existingCountdowns.forEach((countdown)=>{\n            if (countdown.parentNode) {\n                countdown.parentNode.removeChild(countdown);\n            }\n        });\n        // Get canvas position for absolute positioning\n        const canvas = this.canvasRef.current;\n        if (!canvas) return null;\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate absolute position\n        const absoluteX = canvasRect.left + position.x;\n        const absoluteY = canvasRect.top + position.y;\n        // Create new countdown element positioned above the dot\n        const countdown = document.createElement('div');\n        countdown.className = 'calibrate-countdown';\n        countdown.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(absoluteX, \"px;\\n      top: \").concat(absoluteY - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n        document.body.appendChild(countdown);\n        this.countdownElement = countdown;\n        return {\n            dot: countdown\n        };\n    }\n    // Capture screen image\n    async captureScreenImage() {\n        try {\n            const canvas = this.canvasRef.current;\n            if (!canvas) throw new Error(\"Canvas reference is null\");\n            // Format filename with counter\n            const counter = String(this.captureCounter).padStart(3, '0');\n            const filename = \"screen_\".concat(counter, \".jpg\");\n            // Capture image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save image via API\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type: 'screen',\n                    folder: this.captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server responded with \".concat(response.status));\n            }\n            const result = await response.json();\n            console.log(\"Saved screen image: \".concat(filename));\n            return {\n                data: imageData,\n                response: result\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            throw error;\n        }\n    }\n    // Capture webcam image silently\n    async captureWebcamImage() {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format filename with counter\n            const counter = String(this.captureCounter).padStart(3, '0');\n            const filename = \"webcam_\".concat(counter, \".jpg\");\n            // Look for an existing video element first\n            const videoElement = window.videoElement || document.querySelector('video');\n            if (videoElement && videoElement.readyState >= 2) {\n                // If we have a video element that's loaded, use it\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = videoElement.videoWidth || 640;\n                tempCanvas.height = videoElement.videoHeight || 480;\n                ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                const imageData = tempCanvas.toDataURL('image/png');\n                // Save the image\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type: 'webcam',\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    throw new Error(\"Server responded with \".concat(response.status));\n                }\n                const result = await response.json();\n                console.log(\"Saved webcam image: \".concat(filename));\n                return {\n                    data: imageData,\n                    response: result\n                };\n            }\n            // If no video element, create a temporary one\n            // Create a temporary stream for just this capture\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: true,\n                audio: false\n            });\n            // Create a hidden video element to receive the stream\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Set the stream to the video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Check if video dimensions are valid\n            if (tempVideo.videoWidth === 0 || tempVideo.videoHeight === 0) {\n                console.warn(\"Video dimensions are invalid, using default dimensions\");\n            }\n            // Capture the frame to a canvas\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = tempVideo.videoWidth || 640;\n            tempCanvas.height = tempVideo.videoHeight || 480;\n            const ctx = tempCanvas.getContext('2d');\n            ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n            // Get image data\n            const imageData = tempCanvas.toDataURL('image/png');\n            // Save the image via API\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type: 'webcam',\n                    folder: this.captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server responded with \".concat(response.status));\n            }\n            const result = await response.json();\n            console.log(\"Saved webcam image: \".concat(filename));\n            return {\n                data: imageData,\n                response: result\n            };\n        } catch (error) {\n            console.error(\"Error capturing webcam image:\", error);\n            return {\n                data: null,\n                response: null\n            };\n        } finally{\n            // IMPORTANT: Clean up resources even if there was an error\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(point, index) {\n        try {\n            // Format filename with counter\n            const counter = String(this.captureCounter).padStart(3, '0');\n            const filename = \"parameter_\".concat(counter, \".csv\");\n            const canvas = this.canvasRef.current;\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                \"dot_x,\".concat(point.x),\n                \"dot_y,\".concat(point.y),\n                \"canvas_width,\".concat(canvas ? canvas.width : 0),\n                \"canvas_height,\".concat(canvas ? canvas.height : 0),\n                \"window_width,\".concat(window.innerWidth),\n                \"window_height,\".concat(window.innerHeight),\n                \"calibration_point_index,\".concat(index),\n                \"calibration_point_label,\".concat(point.label || ''),\n                \"timestamp,\".concat(new Date().toISOString())\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData: csvDataUrl,\n                    filename,\n                    type: 'parameters',\n                    folder: this.captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server responded with \".concat(response.status));\n            }\n            const result = await response.json();\n            console.log(\"Saved parameter CSV: \".concat(filename));\n            return result;\n        } catch (error) {\n            console.error(\"Error saving parameter CSV:\", error);\n            throw error;\n        }\n    }\n    // Show preview of captured images - made identical to WhiteScreenMain implementation\n    showCapturePreview(screenImage, webcamImage, point) {\n        if (!screenImage && !webcamImage) {\n            console.warn(\"No images available to preview\");\n            return;\n        }\n        // Remove any existing preview containers first (in case of overlapping)\n        try {\n            const existingPreviews = document.querySelectorAll('.capture-preview-container');\n            existingPreviews.forEach((preview)=>{\n                if (preview.parentNode) {\n                    console.log(\"Removing existing preview container\");\n                    preview.parentNode.removeChild(preview);\n                }\n            });\n        } catch (cleanupError) {\n            console.error(\"Error cleaning up existing previews:\", cleanupError);\n        }\n        // Create a new preview container with z-index higher than everything else\n        const previewContainer = document.createElement('div');\n        previewContainer.className = 'capture-preview-container';\n        previewContainer.style.cssText = \"\\n      position: fixed;\\n      top: 50%;\\n      left: 50%;\\n      transform: translate(-50%, -50%);\\n      display: flex;\\n      gap: 20px;\\n      background-color: rgba(0, 0, 0, 0.85);\\n      padding: 20px;\\n      border-radius: 12px;\\n      z-index: 999999;\\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n    \";\n        console.log(\"Preview container created\");\n        // Add debug info div\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = \"\\n      position: absolute;\\n      top: -30px;\\n      left: 0;\\n      width: 100%;\\n      color: white;\\n      font-size: 12px;\\n      text-align: center;\\n    \";\n        debugInfo.textContent = \"Screen: \".concat(screenImage ? 'YES' : 'NO', \", Webcam: \").concat(webcamImage ? 'YES' : 'NO');\n        previewContainer.appendChild(debugInfo);\n        // Function to add an image to the preview\n        const addImagePreview = (image, label)=>{\n            try {\n                console.log(\"Adding \".concat(label, \" preview, image data length: \").concat(image ? image.length : 'N/A'));\n                const preview = document.createElement('div');\n                preview.style.cssText = \"\\n          display: flex;\\n          flex-direction: column;\\n          align-items: center;\\n        \";\n                const img = document.createElement('img');\n                img.src = image;\n                img.alt = label;\n                img.style.cssText = \"\\n          max-width: 320px;\\n          max-height: 240px;\\n          border: 3px solid white;\\n          border-radius: 8px;\\n          background-color: #333;\\n        \";\n                // Event listeners for image loading\n                img.onload = ()=>console.log(\"\".concat(label, \" image loaded successfully\"));\n                img.onerror = (e)=>console.error(\"Error loading \".concat(label, \" image:\"), e);\n                const labelElement = document.createElement('div');\n                labelElement.textContent = label;\n                labelElement.style.cssText = \"\\n          color: white;\\n          font-size: 14px;\\n          margin-top: 10px;\\n          font-weight: bold;\\n        \";\n                preview.appendChild(img);\n                preview.appendChild(labelElement);\n                previewContainer.appendChild(preview);\n                console.log(\"\".concat(label, \" preview element added to container\"));\n                return true;\n            } catch (error) {\n                console.error(\"Error adding \".concat(label, \" preview:\"), error);\n                return false;\n            }\n        };\n        // Add both images to preview if available\n        if (screenImage) {\n            addImagePreview(screenImage, 'Screen Capture');\n        }\n        if (webcamImage) {\n            addImagePreview(webcamImage, 'Webcam Capture');\n        }\n        // Add dot position info if available\n        if (point) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Dot position: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n            positionInfo.style.cssText = \"\\n        color: #ffcc00;\\n        font-size: 14px;\\n        position: absolute;\\n        top: -50px;\\n        left: 0;\\n        width: 100%;\\n        text-align: center;\\n      \";\n            previewContainer.appendChild(positionInfo);\n            console.log(\"Dot position info added\");\n        }\n        // Add countdown timer\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = \"\\n      position: absolute;\\n      bottom: -25px;\\n      right: 20px;\\n      color: white;\\n      font-size: 12px;\\n      background-color: rgba(0, 0, 0, 0.7);\\n      padding: 3px 8px;\\n      border-radius: 4px;\\n    \";\n        previewContainer.appendChild(timerElement);\n        // Add to document body\n        try {\n            document.body.appendChild(previewContainer);\n            console.log(\"Preview container added to DOM\");\n        } catch (appendError) {\n            console.error(\"Error adding preview container to DOM:\", appendError);\n        }\n        // Countdown and remove the preview after 2 seconds\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.transition = 'opacity 0.3s ease';\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        console.log(\"Removing preview container from DOM\");\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                console.log(\"Safety cleanup of preview container\");\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Run the countdown animation for a point - simplified to only show countdown above dot\n    async runCountdown(point, index, total) {\n        // Create countdown element\n        const countdownElements = this.createCountdownElement(point);\n        if (!countdownElements) return false;\n        const { dot: countdownElement } = countdownElements;\n        // Run 3-2-1 countdown\n        for(let count = 3; count > 0; count--){\n            // Update countdown display\n            countdownElement.textContent = count;\n            // Update status indicator\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Calibrate Set Active: countdown \".concat(count, \" (\").concat(index + 1, \"/\").concat(total, \")\");\n            }\n            // Update output text if available\n            if (this.setOutputText) {\n                this.setOutputText(\"Calibration point \".concat(index + 1, \"/\").concat(total, \" - countdown \").concat(count));\n            }\n            // Wait for the next countdown step\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show capturing indicator briefly\n        countdownElement.textContent = \"âœ“\";\n        if (this.statusIndicator) {\n            this.statusIndicator.textContent = \"Capturing point \".concat(index + 1, \"/\").concat(total);\n        }\n        // Remove countdown element immediately after capture to only show the dot\n        // This ensures we see ONLY the red dot after capture, not the countdown indicators\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n        }, 300);\n        return true;\n    }\n    // Process a single calibration point\n    async processCalibrationPoint(point, index, total) {\n        try {\n            // Draw the calibration point\n            this.drawCalibrationPoint(point);\n            // Run countdown animation - same as RandomDot\n            await this.runCountdown(point, index, total);\n            // Capture screen image\n            const screenResult = await this.captureScreenImage();\n            // Capture webcam image\n            const webcamResult = await this.captureWebcamImage();\n            // Save parameter CSV\n            await this.saveParameterCSV(point, index);\n            // Increment capture counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server returned a new capture number, use it\n                if (screenResult.response && screenResult.response.captureNumber !== undefined) {\n                    this.captureCounter = screenResult.response.captureNumber + 1;\n                    this.setCaptureCounter(this.captureCounter);\n                } else {\n                    this.captureCounter++;\n                    this.setCaptureCounter(this.captureCounter);\n                }\n            }\n            // Show preview\n            this.showCapturePreview(screenResult.data, webcamResult ? webcamResult.data : null, point);\n            // Wait for preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2300));\n            return true;\n        } catch (error) {\n            console.error(\"Error processing calibration point \".concat(index + 1, \":\"), error);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Error: \".concat(error.message);\n            }\n            if (this.setOutputText) {\n                this.setOutputText(\"Error: \".concat(error.message));\n            }\n            return false;\n        }\n    }\n    // Start the full calibration sequence\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        // Hide the TopBar IMMEDIATELY (first action)\n        if (typeof this.toggleTopBar === 'function') {\n            this.toggleTopBar(false);\n        }\n        // Small delay to ensure UI updates\n        await new Promise((resolve)=>setTimeout(resolve, 50));\n        // Create status indicator\n        const statusIndicator = this.createStatusIndicator();\n        statusIndicator.textContent = 'Calibrate Set Active: Initializing...';\n        try {\n            // Generate calibration points\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n            if (!this.calibrationPoints.length) {\n                throw new Error('Failed to generate calibration points');\n            }\n            // Update status\n            if (this.setOutputText) {\n                this.setOutputText(\"Starting calibration with \".concat(this.calibrationPoints.length, \" points\"));\n            }\n            // Process each calibration point in sequence\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                statusIndicator.textContent = \"Processing point \".concat(i + 1, \"/\").concat(this.calibrationPoints.length);\n                // Process current point\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                // If processing failed, stop the sequence\n                if (!success) {\n                    throw new Error(\"Failed to process point \".concat(i + 1));\n                }\n            }\n            // Calibration complete\n            statusIndicator.textContent = 'Calibration completed';\n            if (this.setOutputText) {\n                this.setOutputText('Calibration completed successfully');\n            }\n            return true;\n        } catch (error) {\n            console.error('Calibration error:', error);\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Error: \".concat(error.message);\n            }\n            if (this.setOutputText) {\n                this.setOutputText(\"Calibration error: \".concat(error.message));\n            }\n            return false;\n        } finally{\n            this.isProcessing = false;\n            // Show TopBar again\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(true);\n            }\n            // Remove status indicator after a delay\n            setTimeout(()=>{\n                if (statusIndicator && statusIndicator.parentNode) {\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }\n            }, 3000);\n            // Call onComplete callback if provided\n            if (typeof this.onComplete === 'function') {\n                this.onComplete();\n            }\n        }\n    }\n    constructor(config){\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCount || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Internal state\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.calibrationPoints = [];\n        this.statusIndicator = null;\n        this.countdownElement = null;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNQO0FBRTlELE1BQU1DO0lBbUJKLG9EQUFvRDtJQUNwREMsd0JBQXdCO1FBQ3RCLHVDQUF1QztRQUN2QyxNQUFNQyxxQkFBcUJDLFNBQVNDLGdCQUFnQixDQUFDO1FBQ3JERixtQkFBbUJHLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDekIsSUFBSUEsVUFBVUMsVUFBVSxFQUFFO2dCQUN4QkQsVUFBVUMsVUFBVSxDQUFDQyxXQUFXLENBQUNGO1lBQ25DO1FBQ0Y7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTUEsWUFBWUgsU0FBU00sYUFBYSxDQUFDO1FBQ3pDSCxVQUFVSSxTQUFTLEdBQUc7UUFDdEJKLFVBQVVLLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBYzNCVCxTQUFTVSxJQUFJLENBQUNDLFdBQVcsQ0FBQ1I7UUFDMUIsSUFBSSxDQUFDUyxlQUFlLEdBQUdUO1FBQ3ZCLE9BQU9BO0lBQ1Q7SUFFQSxvQ0FBb0M7SUFDcENVLHFCQUFxQkMsS0FBSyxFQUFFO1FBQzFCLE1BQU1DLFNBQVMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE9BQU87UUFDckMsSUFBSSxDQUFDRixRQUFRLE9BQU87UUFFcEIsTUFBTUcsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO1FBRTlCLGVBQWU7UUFDZkQsSUFBSUUsU0FBUyxDQUFDLEdBQUcsR0FBR0wsT0FBT00sS0FBSyxFQUFFTixPQUFPTyxNQUFNO1FBQy9DSixJQUFJSyxTQUFTLEdBQUc7UUFDaEJMLElBQUlNLFFBQVEsQ0FBQyxHQUFHLEdBQUdULE9BQU9NLEtBQUssRUFBRU4sT0FBT08sTUFBTTtRQUU5QyxvREFBb0Q7UUFDcEQsTUFBTUcsU0FBUztRQUVmLDZCQUE2QjtRQUM3QlAsSUFBSVEsU0FBUztRQUNi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O1lBQ2pCO1FBQ0Y7SUFDRjtJQWp1QkFDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDMUosU0FBUyxHQUFHMEosT0FBTzFKLFNBQVM7UUFDakMsSUFBSSxDQUFDb0osWUFBWSxHQUFHTSxPQUFPTixZQUFZO1FBQ3ZDLElBQUksQ0FBQ1YsYUFBYSxHQUFHZ0IsT0FBT2hCLGFBQWE7UUFDekMsSUFBSSxDQUFDdEcsY0FBYyxHQUFHc0gsT0FBT0MsWUFBWSxJQUFJO1FBQzdDLElBQUksQ0FBQ2IsaUJBQWlCLEdBQUdZLE9BQU9aLGlCQUFpQjtRQUNqRCxJQUFJLENBQUM3RixhQUFhLEdBQUd5RyxPQUFPekcsYUFBYSxJQUFJO1FBQzdDLElBQUksQ0FBQ3VHLFVBQVUsR0FBR0UsT0FBT0YsVUFBVTtRQUVuQyxpQkFBaUI7UUFDakIsSUFBSSxDQUFDTCxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDUyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNQLGlCQUFpQixHQUFHLEVBQUU7UUFDM0IsSUFBSSxDQUFDekosZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ2tDLGdCQUFnQixHQUFHO0lBQzFCO0FBa3RCRjtBQUVBLGlFQUFlakQsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlSGFuZGxlci5qcyAtIFRoaXMgc2hvdWxkIGJlIHBsYWNlZCBpbiB0aGUgY29tcG9uZW50cy1ndWkgZm9sZGVyXG4vLyBUaGlzIGlzIGEgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGlicmF0aW9uIGZ1bmN0aW9uYWxpdHlcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5cbmNsYXNzIENhbGlicmF0ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvLyBSZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldE91dHB1dFRleHQgPSBjb25maWcuc2V0T3V0cHV0VGV4dDtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudCB8fCAxO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlRm9sZGVyID0gY29uZmlnLmNhcHR1cmVGb2xkZXIgfHwgJ2V5ZV90cmFja2luZ19jYXB0dXJlcyc7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gY29uZmlnLm9uQ29tcGxldGU7XG4gICAgXG4gICAgLy8gSW50ZXJuYWwgc3RhdGVcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFBvaW50SW5kZXggPSAwO1xuICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBbXTtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gICAgdGhpcy5jb3VudGRvd25FbGVtZW50ID0gbnVsbDtcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIGEgc3RhdHVzIGluZGljYXRvciBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lclxuICBjcmVhdGVTdGF0dXNJbmRpY2F0b3IoKSB7XG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBpbmRpY2F0b3JzIGZpcnN0XG4gICAgY29uc3QgZXhpc3RpbmdJbmRpY2F0b3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJyk7XG4gICAgZXhpc3RpbmdJbmRpY2F0b3JzLmZvckVhY2goaW5kaWNhdG9yID0+IHtcbiAgICAgIGlmIChpbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICBpbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbmRpY2F0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBuZXcgc3RhdHVzIGluZGljYXRvclxuICAgIGNvbnN0IGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGluZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgIGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiAxMHB4O1xuICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBwYWRkaW5nOiA4cHggMTJweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGA7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbmRpY2F0b3IpO1xuICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yID0gaW5kaWNhdG9yO1xuICAgIHJldHVybiBpbmRpY2F0b3I7XG4gIH1cbiAgXG4gIC8vIERyYXcgYSBzcGVjaWZpYyBjYWxpYnJhdGlvbiBwb2ludFxuICBkcmF3Q2FsaWJyYXRpb25Qb2ludChwb2ludCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiBudWxsO1xuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vIENsZWFyIGNhbnZhc1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBEcmF3IHRoZSBwb2ludCB3aXRoIGxhcmdlciByYWRpdXMgYW5kIGdsb3cgZWZmZWN0XG4gICAgY29uc3QgcmFkaXVzID0gODtcbiAgICBcbiAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICBjdHguZmlsbCgpO1xuICAgIFxuICAgIC8vIEFkZCBnbG93IGVmZmVjdFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIHJhZGl1cyArIDQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICByZXR1cm4geyB4OiBwb2ludC54LCB5OiBwb2ludC55IH07XG4gIH1cbiAgXG4gIC8vIENyZWF0ZSBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIHRoZSBjdXJyZW50IGRvdFxuICBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvc2l0aW9uKSB7XG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FsaWJyYXRlLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwJyk7XG4gICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goY291bnRkb3duID0+IHtcbiAgICAgIGlmIChjb3VudGRvd24ucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgcG9zaXRpb24gZm9yIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgYWJzb2x1dGUgcG9zaXRpb25cbiAgICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICAgIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcbiAgICBcbiAgICAvLyBDcmVhdGUgbmV3IGNvdW50ZG93biBlbGVtZW50IHBvc2l0aW9uZWQgYWJvdmUgdGhlIGRvdFxuICAgIGNvbnN0IGNvdW50ZG93biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvdW50ZG93bi5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLWNvdW50ZG93bic7XG4gICAgY291bnRkb3duLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICAgIHRvcDogJHthYnNvbHV0ZVkgLSA2MH1weDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgIGNvbG9yOiByZWQ7XG4gICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGA7XG4gICAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd24pO1xuICAgIHRoaXMuY291bnRkb3duRWxlbWVudCA9IGNvdW50ZG93bjtcbiAgICBcbiAgICByZXR1cm4geyBkb3Q6IGNvdW50ZG93biB9O1xuICB9XG4gIFxuICAvLyBDYXB0dXJlIHNjcmVlbiBpbWFnZVxuICBhc3luYyBjYXB0dXJlU2NyZWVuSW1hZ2UoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcykgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsXCIpO1xuICAgICAgXG4gICAgICAvLyBGb3JtYXQgZmlsZW5hbWUgd2l0aCBjb3VudGVyXG4gICAgICBjb25zdCBjb3VudGVyID0gU3RyaW5nKHRoaXMuY2FwdHVyZUNvdW50ZXIpLnBhZFN0YXJ0KDMsICcwJyk7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGBzY3JlZW5fJHtjb3VudGVyfS5qcGdgO1xuICAgICAgXG4gICAgICAvLyBDYXB0dXJlIGltYWdlIGRhdGFcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgXG4gICAgICAvLyBTYXZlIGltYWdlIHZpYSBBUElcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgdHlwZTogJ3NjcmVlbicsXG4gICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgc2NyZWVuIGltYWdlOiAke2ZpbGVuYW1lfWApO1xuICAgICAgXG4gICAgICByZXR1cm4geyBkYXRhOiBpbWFnZURhdGEsIHJlc3BvbnNlOiByZXN1bHQgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhcHR1cmluZyBzY3JlZW4gaW1hZ2U6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQ2FwdHVyZSB3ZWJjYW0gaW1hZ2Ugc2lsZW50bHlcbiAgYXN5bmMgY2FwdHVyZVdlYmNhbUltYWdlKCkge1xuICAgIGxldCBzdHJlYW0gPSBudWxsO1xuICAgIGxldCB0ZW1wVmlkZW8gPSBudWxsO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBGb3JtYXQgZmlsZW5hbWUgd2l0aCBjb3VudGVyXG4gICAgICBjb25zdCBjb3VudGVyID0gU3RyaW5nKHRoaXMuY2FwdHVyZUNvdW50ZXIpLnBhZFN0YXJ0KDMsICcwJyk7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGB3ZWJjYW1fJHtjb3VudGVyfS5qcGdgO1xuICAgICAgXG4gICAgICAvLyBMb29rIGZvciBhbiBleGlzdGluZyB2aWRlbyBlbGVtZW50IGZpcnN0XG4gICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB3aW5kb3cudmlkZW9FbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICBcbiAgICAgIGlmICh2aWRlb0VsZW1lbnQgJiYgdmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgdmlkZW8gZWxlbWVudCB0aGF0J3MgbG9hZGVkLCB1c2UgaXRcbiAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB2aWRlb0VsZW1lbnQudmlkZW9XaWR0aCB8fCA2NDA7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgICAgICAgXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdGhlIGltYWdlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgdHlwZTogJ3dlYmNhbScsXG4gICAgICAgICAgICBmb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCB3ZWJjYW0gaW1hZ2U6ICR7ZmlsZW5hbWV9YCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBkYXRhOiBpbWFnZURhdGEsIHJlc3BvbnNlOiByZXN1bHQgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgbm8gdmlkZW8gZWxlbWVudCwgY3JlYXRlIGEgdGVtcG9yYXJ5IG9uZVxuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHN0cmVhbSBmb3IganVzdCB0aGlzIGNhcHR1cmVcbiAgICAgIHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgXG4gICAgICAgIHZpZGVvOiB0cnVlLCBcbiAgICAgICAgYXVkaW86IGZhbHNlIFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGhpZGRlbiB2aWRlbyBlbGVtZW50IHRvIHJlY2VpdmUgdGhlIHN0cmVhbVxuICAgICAgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgIHRlbXBWaWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgIHRlbXBWaWRlby5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0ZW1wVmlkZW8uc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICAgIHRlbXBWaWRlby5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgXG4gICAgICAvLyBTZXQgdGhlIHN0cmVhbSB0byB0aGUgdmlkZW8gZWxlbWVudFxuICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdmlkZW8gdG8gaW5pdGlhbGl6ZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiVmlkZW8gbG9hZGluZyB0aW1lZCBvdXQsIGNvbnRpbnVpbmcgYW55d2F5XCIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIFxuICAgICAgICB0ZW1wVmlkZW8ub25sb2FkZWRkYXRhID0gKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgYSBjbGVhciBmcmFtZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB2aWRlbyBkaW1lbnNpb25zIGFyZSB2YWxpZFxuICAgICAgaWYgKHRlbXBWaWRlby52aWRlb1dpZHRoID09PSAwIHx8IHRlbXBWaWRlby52aWRlb0hlaWdodCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJWaWRlbyBkaW1lbnNpb25zIGFyZSBpbnZhbGlkLCB1c2luZyBkZWZhdWx0IGRpbWVuc2lvbnNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgdGhlIGZyYW1lIHRvIGEgY2FudmFzXG4gICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB0ZW1wVmlkZW8udmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgY29uc3QgY3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgXG4gICAgICBjdHguZHJhd0ltYWdlKHRlbXBWaWRlbywgMCwgMCwgdGVtcENhbnZhcy53aWR0aCwgdGVtcENhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHRoZSBpbWFnZSB2aWEgQVBJXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIHR5cGU6ICd3ZWJjYW0nLFxuICAgICAgICAgIGZvbGRlcjogdGhpcy5jYXB0dXJlRm9sZGVyXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coYFNhdmVkIHdlYmNhbSBpbWFnZTogJHtmaWxlbmFtZX1gKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHsgZGF0YTogaW1hZ2VEYXRhLCByZXNwb25zZTogcmVzdWx0IH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgd2ViY2FtIGltYWdlOlwiLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBkYXRhOiBudWxsLCByZXNwb25zZTogbnVsbCB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBJTVBPUlRBTlQ6IENsZWFuIHVwIHJlc291cmNlcyBldmVuIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGVtcFZpZGVvKSB7XG4gICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICBpZiAodGVtcFZpZGVvLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0ZW1wVmlkZW8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBTYXZlIHBhcmFtZXRlciBDU1ZcbiAgYXN5bmMgc2F2ZVBhcmFtZXRlckNTVihwb2ludCwgaW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgLy8gRm9ybWF0IGZpbGVuYW1lIHdpdGggY291bnRlclxuICAgICAgY29uc3QgY291bnRlciA9IFN0cmluZyh0aGlzLmNhcHR1cmVDb3VudGVyKS5wYWRTdGFydCgzLCAnMCcpO1xuICAgICAgY29uc3QgZmlsZW5hbWUgPSBgcGFyYW1ldGVyXyR7Y291bnRlcn0uY3N2YDtcbiAgICAgIFxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIENTViBjb250ZW50IHdpdGggdHdvIGNvbHVtbnM6IG5hbWUgYW5kIHZhbHVlXG4gICAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgICBcIm5hbWUsdmFsdWVcIixcbiAgICAgICAgYGRvdF94LCR7cG9pbnQueH1gLFxuICAgICAgICBgZG90X3ksJHtwb2ludC55fWAsXG4gICAgICAgIGBjYW52YXNfd2lkdGgsJHtjYW52YXMgPyBjYW52YXMud2lkdGggOiAwfWAsXG4gICAgICAgIGBjYW52YXNfaGVpZ2h0LCR7Y2FudmFzID8gY2FudmFzLmhlaWdodCA6IDB9YCxcbiAgICAgICAgYHdpbmRvd193aWR0aCwke3dpbmRvdy5pbm5lcldpZHRofWAsXG4gICAgICAgIGB3aW5kb3dfaGVpZ2h0LCR7d2luZG93LmlubmVySGVpZ2h0fWAsXG4gICAgICAgIGBjYWxpYnJhdGlvbl9wb2ludF9pbmRleCwke2luZGV4fWAsXG4gICAgICAgIGBjYWxpYnJhdGlvbl9wb2ludF9sYWJlbCwke3BvaW50LmxhYmVsIHx8ICcnfWAsXG4gICAgICAgIGB0aW1lc3RhbXAsJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YFxuICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgIFxuICAgICAgLy8gQ29udmVydCBDU1YgdG8gZGF0YSBVUkxcbiAgICAgIGNvbnN0IGNzdkJsb2IgPSBuZXcgQmxvYihbY3N2RGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgIGNvbnN0IGNzdlJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBcbiAgICAgIGNvbnN0IGNzdkRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjc3ZSZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShjc3ZSZWFkZXIucmVzdWx0KTtcbiAgICAgICAgY3N2UmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSBDU1YgdXNpbmcgdGhlIEFQSVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGltYWdlRGF0YTogY3N2RGF0YVVybCxcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICB0eXBlOiAncGFyYW1ldGVycycsXG4gICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgcGFyYW1ldGVyIENTVjogJHtmaWxlbmFtZX1gKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBwYXJhbWV0ZXIgQ1NWOlwiLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXMgLSBtYWRlIGlkZW50aWNhbCB0byBXaGl0ZVNjcmVlbk1haW4gaW1wbGVtZW50YXRpb25cbiAgc2hvd0NhcHR1cmVQcmV2aWV3KHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgcG9pbnQpIHtcbiAgICBpZiAoIXNjcmVlbkltYWdlICYmICF3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gaW1hZ2VzIGF2YWlsYWJsZSB0byBwcmV2aWV3XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlldyBjb250YWluZXJzIGZpcnN0IChpbiBjYXNlIG9mIG92ZXJsYXBwaW5nKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZ1ByZXZpZXdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcHR1cmUtcHJldmlldy1jb250YWluZXInKTtcbiAgICAgIGV4aXN0aW5nUHJldmlld3MuZm9yRWFjaChwcmV2aWV3ID0+IHtcbiAgICAgICAgaWYgKHByZXZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgZXhpc3RpbmcgcHJldmlldyBjb250YWluZXJcIik7XG4gICAgICAgICAgcHJldmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChjbGVhbnVwRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjbGVhbmluZyB1cCBleGlzdGluZyBwcmV2aWV3czpcIiwgY2xlYW51cEVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHByZXZpZXcgY29udGFpbmVyIHdpdGggei1pbmRleCBoaWdoZXIgdGhhbiBldmVyeXRoaW5nIGVsc2VcbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICBgO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiUHJldmlldyBjb250YWluZXIgY3JlYXRlZFwiKTtcbiAgICBcbiAgICAvLyBBZGQgZGVidWcgaW5mbyBkaXZcbiAgICBjb25zdCBkZWJ1Z0luZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWJ1Z0luZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogLTMwcHg7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgYDtcbiAgICBkZWJ1Z0luZm8udGV4dENvbnRlbnQgPSBgU2NyZWVuOiAke3NjcmVlbkltYWdlID8gJ1lFUycgOiAnTk8nfSwgV2ViY2FtOiAke3dlYmNhbUltYWdlID8gJ1lFUycgOiAnTk8nfWA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChkZWJ1Z0luZm8pO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGFkZCBhbiBpbWFnZSB0byB0aGUgcHJldmlld1xuICAgIGNvbnN0IGFkZEltYWdlUHJldmlldyA9IChpbWFnZSwgbGFiZWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgJHtsYWJlbH0gcHJldmlldywgaW1hZ2UgZGF0YSBsZW5ndGg6ICR7aW1hZ2UgPyBpbWFnZS5sZW5ndGggOiAnTi9BJ31gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZTtcbiAgICAgICAgaW1nLmFsdCA9IGxhYmVsO1xuICAgICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXJzIGZvciBpbWFnZSBsb2FkaW5nXG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBjb25zb2xlLmxvZyhgJHtsYWJlbH0gaW1hZ2UgbG9hZGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nICR7bGFiZWx9IGltYWdlOmAsIGUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICBsYWJlbEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQobGFiZWxFbGVtZW50KTtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7bGFiZWx9IHByZXZpZXcgZWxlbWVudCBhZGRlZCB0byBjb250YWluZXJgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgJHtsYWJlbH0gcHJldmlldzpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBib3RoIGltYWdlcyB0byBwcmV2aWV3IGlmIGF2YWlsYWJsZVxuICAgIGlmIChzY3JlZW5JbWFnZSkge1xuICAgICAgYWRkSW1hZ2VQcmV2aWV3KHNjcmVlbkltYWdlLCAnU2NyZWVuIENhcHR1cmUnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICBhZGRJbWFnZVByZXZpZXcod2ViY2FtSW1hZ2UsICdXZWJjYW0gQ2FwdHVyZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgZG90IHBvc2l0aW9uIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgaWYgKHBvaW50KSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvc2l0aW9uSW5mby50ZXh0Q29udGVudCA9IHBvaW50LmxhYmVsID9cbiAgICAgICAgYCR7cG9pbnQubGFiZWx9OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWAgOlxuICAgICAgICBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWA7XG4gICAgICBwb3NpdGlvbkluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC01MHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9zaXRpb25JbmZvKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiRG90IHBvc2l0aW9uIGluZm8gYWRkZWRcIik7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBjb3VudGRvd24gdGltZXJcbiAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IC0yNXB4O1xuICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgIFxuICAgIC8vIEFkZCB0byBkb2N1bWVudCBib2R5XG4gICAgdHJ5IHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICBjb25zb2xlLmxvZyhcIlByZXZpZXcgY29udGFpbmVyIGFkZGVkIHRvIERPTVwiKTtcbiAgICB9IGNhdGNoIChhcHBlbmRFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGFkZGluZyBwcmV2aWV3IGNvbnRhaW5lciB0byBET006XCIsIGFwcGVuZEVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ291bnRkb3duIGFuZCByZW1vdmUgdGhlIHByZXZpZXcgYWZ0ZXIgMiBzZWNvbmRzXG4gICAgbGV0IHRpbWVMZWZ0ID0gMi4wO1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGltZUxlZnQgLT0gMC4xO1xuICAgICAgaWYgKHRpbWVMZWZ0IDw9IDApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIC8vIEZhZGUgb3V0XG4gICAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDAuM3MgZWFzZSc7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGZhZGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZW1vdmluZyBwcmV2aWV3IGNvbnRhaW5lciBmcm9tIERPTVwiKTtcbiAgICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgLy8gU2FmZXR5IGNsZWFudXAgYWZ0ZXIgNSBzZWNvbmRzIGluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNhZmV0eSBjbGVhbnVwIG9mIHByZXZpZXcgY29udGFpbmVyXCIpO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfSwgNTAwMCk7XG4gIH1cbiAgXG4gIC8vIFJ1biB0aGUgY291bnRkb3duIGFuaW1hdGlvbiBmb3IgYSBwb2ludCAtIHNpbXBsaWZpZWQgdG8gb25seSBzaG93IGNvdW50ZG93biBhYm92ZSBkb3RcbiAgYXN5bmMgcnVuQ291bnRkb3duKHBvaW50LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBDcmVhdGUgY291bnRkb3duIGVsZW1lbnRcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50cyA9IHRoaXMuY3JlYXRlQ291bnRkb3duRWxlbWVudChwb2ludCk7XG4gICAgaWYgKCFjb3VudGRvd25FbGVtZW50cykgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIGNvbnN0IHsgZG90OiBjb3VudGRvd25FbGVtZW50IH0gPSBjb3VudGRvd25FbGVtZW50cztcbiAgICBcbiAgICAvLyBSdW4gMy0yLTEgY291bnRkb3duXG4gICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgIC8vIFVwZGF0ZSBjb3VudGRvd24gZGlzcGxheVxuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzIGluZGljYXRvclxuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0ZSBTZXQgQWN0aXZlOiBjb3VudGRvd24gJHtjb3VudH0gKCR7aW5kZXggKyAxfS8ke3RvdGFsfSlgO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgb3V0cHV0IHRleHQgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAodGhpcy5zZXRPdXRwdXRUZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dChgQ2FsaWJyYXRpb24gcG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9IC0gY291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBuZXh0IGNvdW50ZG93biBzdGVwXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNob3cgY2FwdHVyaW5nIGluZGljYXRvciBicmllZmx5XG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgXG4gICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYXB0dXJpbmcgcG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9YDtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGltbWVkaWF0ZWx5IGFmdGVyIGNhcHR1cmUgdG8gb25seSBzaG93IHRoZSBkb3RcbiAgICAvLyBUaGlzIGVuc3VyZXMgd2Ugc2VlIE9OTFkgdGhlIHJlZCBkb3QgYWZ0ZXIgY2FwdHVyZSwgbm90IHRoZSBjb3VudGRvd24gaW5kaWNhdG9yc1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICB9XG4gICAgfSwgMzAwKTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBcbiAgLy8gUHJvY2VzcyBhIHNpbmdsZSBjYWxpYnJhdGlvbiBwb2ludFxuICBhc3luYyBwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludChwb2ludCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIERyYXcgdGhlIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICB0aGlzLmRyYXdDYWxpYnJhdGlvblBvaW50KHBvaW50KTtcbiAgICAgIFxuICAgICAgLy8gUnVuIGNvdW50ZG93biBhbmltYXRpb24gLSBzYW1lIGFzIFJhbmRvbURvdFxuICAgICAgYXdhaXQgdGhpcy5ydW5Db3VudGRvd24ocG9pbnQsIGluZGV4LCB0b3RhbCk7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgc2NyZWVuIGltYWdlXG4gICAgICBjb25zdCBzY3JlZW5SZXN1bHQgPSBhd2FpdCB0aGlzLmNhcHR1cmVTY3JlZW5JbWFnZSgpO1xuICAgICAgXG4gICAgICAvLyBDYXB0dXJlIHdlYmNhbSBpbWFnZVxuICAgICAgY29uc3Qgd2ViY2FtUmVzdWx0ID0gYXdhaXQgdGhpcy5jYXB0dXJlV2ViY2FtSW1hZ2UoKTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSBwYXJhbWV0ZXIgQ1NWXG4gICAgICBhd2FpdCB0aGlzLnNhdmVQYXJhbWV0ZXJDU1YocG9pbnQsIGluZGV4KTtcbiAgICAgIFxuICAgICAgLy8gSW5jcmVtZW50IGNhcHR1cmUgY291bnRlciBmb3IgbmV4dCBjYXB0dXJlXG4gICAgICBpZiAodGhpcy5zZXRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybmVkIGEgbmV3IGNhcHR1cmUgbnVtYmVyLCB1c2UgaXRcbiAgICAgICAgaWYgKHNjcmVlblJlc3VsdC5yZXNwb25zZSAmJiBzY3JlZW5SZXN1bHQucmVzcG9uc2UuY2FwdHVyZU51bWJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IHNjcmVlblJlc3VsdC5yZXNwb25zZS5jYXB0dXJlTnVtYmVyICsgMTtcbiAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHRoaXMuY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIrKztcbiAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHRoaXMuY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgcHJldmlld1xuICAgICAgdGhpcy5zaG93Q2FwdHVyZVByZXZpZXcoXG4gICAgICAgIHNjcmVlblJlc3VsdC5kYXRhLFxuICAgICAgICB3ZWJjYW1SZXN1bHQgPyB3ZWJjYW1SZXN1bHQuZGF0YSA6IG51bGwsXG4gICAgICAgIHBvaW50XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBwcmV2aWV3IHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjMwMCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2luZGV4ICsgMX06YCwgZXJyb3IpO1xuICAgICAgXG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGhpcy5zZXRPdXRwdXRUZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dChgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU3RhcnQgdGhlIGZ1bGwgY2FsaWJyYXRpb24gc2VxdWVuY2VcbiAgYXN5bmMgc3RhcnRDYWxpYnJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgXG4gICAgLy8gSGlkZSB0aGUgVG9wQmFyIElNTUVESUFURUxZIChmaXJzdCBhY3Rpb24pXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgVUkgdXBkYXRlc1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gdGhpcy5jcmVhdGVTdGF0dXNJbmRpY2F0b3IoKTtcbiAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRlIFNldCBBY3RpdmU6IEluaXRpYWxpemluZy4uLic7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCByZWFkeScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICBpZiAoIXRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBpZiAodGhpcy5zZXRPdXRwdXRUZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dChgU3RhcnRpbmcgY2FsaWJyYXRpb24gd2l0aCAke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHNgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50IGluIHNlcXVlbmNlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYFByb2Nlc3NpbmcgcG9pbnQgJHtpICsgMX0vJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyBjdXJyZW50IHBvaW50XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnByb2Nlc3NDYWxpYnJhdGlvblBvaW50KFxuICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHNbaV0sXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgcHJvY2Vzc2luZyBmYWlsZWQsIHN0b3AgdGhlIHNlcXVlbmNlXG4gICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHByb2Nlc3MgcG9pbnQgJHtpICsgMX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCc7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnNldE91dHB1dFRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0KCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYWxpYnJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRoaXMuc2V0T3V0cHV0VGV4dCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dFRleHQoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yICYmIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7XG4gICAgICBcbiAgICAgIC8vIENhbGwgb25Db21wbGV0ZSBjYWxsYmFjayBpZiBwcm92aWRlZFxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uQ29tcGxldGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbGlicmF0ZUhhbmRsZXI7Il0sIm5hbWVzIjpbImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJDYWxpYnJhdGVIYW5kbGVyIiwiY3JlYXRlU3RhdHVzSW5kaWNhdG9yIiwiZXhpc3RpbmdJbmRpY2F0b3JzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImluZGljYXRvciIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzdGF0dXNJbmRpY2F0b3IiLCJkcmF3Q2FsaWJyYXRpb25Qb2ludCIsInBvaW50IiwiY2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicmFkaXVzIiwiYmVnaW5QYXRoIiwiYXJjIiwieCIsInkiLCJNYXRoIiwiUEkiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJjcmVhdGVDb3VudGRvd25FbGVtZW50IiwicG9zaXRpb24iLCJleGlzdGluZ0NvdW50ZG93bnMiLCJjb3VudGRvd24iLCJjYW52YXNSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkVsZW1lbnQiLCJkb3QiLCJjYXB0dXJlU2NyZWVuSW1hZ2UiLCJFcnJvciIsImNvdW50ZXIiLCJTdHJpbmciLCJjYXB0dXJlQ291bnRlciIsInBhZFN0YXJ0IiwiZmlsZW5hbWUiLCJpbWFnZURhdGEiLCJ0b0RhdGFVUkwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0eXBlIiwiZm9sZGVyIiwiY2FwdHVyZUZvbGRlciIsIm9rIiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJjYXB0dXJlV2ViY2FtSW1hZ2UiLCJzdHJlYW0iLCJ0ZW1wVmlkZW8iLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwicmVhZHlTdGF0ZSIsInRlbXBDYW52YXMiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsImF1ZGlvIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwib3BhY2l0eSIsInNyY09iamVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGltZW91dElkIiwic2V0VGltZW91dCIsIndhcm4iLCJvbmxvYWRlZGRhdGEiLCJjbGVhclRpbWVvdXQiLCJnZXRUcmFja3MiLCJ0cmFjayIsInN0b3AiLCJzYXZlUGFyYW1ldGVyQ1NWIiwiaW5kZXgiLCJjc3ZEYXRhIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwibGFiZWwiLCJEYXRlIiwidG9JU09TdHJpbmciLCJqb2luIiwiY3N2QmxvYiIsIkJsb2IiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlYWRBc0RhdGFVUkwiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiZXhpc3RpbmdQcmV2aWV3cyIsInByZXZpZXciLCJjbGVhbnVwRXJyb3IiLCJwcmV2aWV3Q29udGFpbmVyIiwiZGVidWdJbmZvIiwidGV4dENvbnRlbnQiLCJhZGRJbWFnZVByZXZpZXciLCJpbWFnZSIsImxlbmd0aCIsImltZyIsInNyYyIsImFsdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJlIiwibGFiZWxFbGVtZW50IiwicG9zaXRpb25JbmZvIiwicm91bmQiLCJ0aW1lckVsZW1lbnQiLCJhcHBlbmRFcnJvciIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ0cmFuc2l0aW9uIiwidG9GaXhlZCIsInJ1bkNvdW50ZG93biIsInRvdGFsIiwiY291bnRkb3duRWxlbWVudHMiLCJjb3VudCIsInNldE91dHB1dFRleHQiLCJwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludCIsInNjcmVlblJlc3VsdCIsIndlYmNhbVJlc3VsdCIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZU51bWJlciIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJzdGFydENhbGlicmF0aW9uIiwiaXNQcm9jZXNzaW5nIiwidG9nZ2xlVG9wQmFyIiwiY2FsaWJyYXRpb25Qb2ludHMiLCJpIiwic3VjY2VzcyIsIm9uQ29tcGxldGUiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImNhcHR1cmVDb3VudCIsImN1cnJlbnRQb2ludEluZGV4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js\n"));

/***/ })

}]);