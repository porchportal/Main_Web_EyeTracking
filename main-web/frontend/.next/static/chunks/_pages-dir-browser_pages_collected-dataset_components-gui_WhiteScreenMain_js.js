"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset_components-gui_WhiteScreenMain_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js":
/*!********************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/countSave.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n// countSave.js\n// Shared functionality for countdown and image capture processes\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @param {Function} onComplete - Callback to execute when countdown finishes\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(absoluteX, \"px;\\n      top: \").concat(absoluteY - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    if (position && typeof position.x === 'number' && typeof position.y === 'number') {\n                        drawRedDot(ctx, position.x, position.y);\n                    } else {\n                        console.warn(\"[runCountdown] Position is null after countdown\", position);\n                    }\n                    if (onComplete) {\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n   * Captures images from both canvas and webcam\n   * @param {Object} options - Capture options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {string} options.captureFolder - Folder to save captures in\n   * @returns {Object} - Result with captured image data\n   */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    try {\n        const counter = String(captureCounter).padStart(3, '0');\n        const screenFilename = \"screen_\".concat(counter, \".jpg\");\n        const webcamFilename = \"webcam_\".concat(counter, \".jpg\");\n        const parameterFilename = \"parameter_\".concat(counter, \".csv\");\n        console.log(\"Starting capture process with counter: \".concat(counter));\n        console.log(\"Dot position: x=\".concat(position.x, \", y=\").concat(position.y));\n        let screenImageData = null;\n        let webcamImageData = null;\n        let usedCaptureNumber = captureCounter;\n        // === 1. Capture screen image from canvas ===\n        const canvas = canvasRef.current;\n        if (canvas) {\n            try {\n                const ctx = canvas.getContext('2d');\n                // ✅ Make sure the red dot is drawn RIGHT before screen capture\n                drawRedDot(ctx, position.x, position.y);\n                console.log(\"Canvas dimensions: \".concat(canvas.width, \"x\").concat(canvas.height));\n                screenImageData = canvas.toDataURL('image/png');\n                console.log(\"Screen image captured, size: \".concat(screenImageData.length, \" chars\"));\n                if (saveImageToServer) {\n                    const screenResponse = await saveImageToServer(screenImageData, screenFilename, 'screen', captureFolder);\n                    if (screenResponse && screenResponse.captureNumber) {\n                        usedCaptureNumber = screenResponse.captureNumber;\n                        console.log(\"Server assigned capture number: \".concat(usedCaptureNumber));\n                    }\n                }\n            } catch (screenError) {\n                console.error(\"Error capturing or saving screen image:\", screenError);\n            }\n        } else {\n            console.error(\"Canvas reference is null, cannot capture screen\");\n        }\n        // === 2. Capture webcam image ===\n        try {\n            console.log(\"Attempting to capture webcam silently\");\n            const videoElement = window.videoElement || document.querySelector('video');\n            if (videoElement && videoElement.readyState >= 2) {\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = videoElement.videoWidth || 640;\n                tempCanvas.height = videoElement.videoHeight || 480;\n                ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, \"webcam_\".concat(String(usedCaptureNumber).padStart(3, '0'), \".jpg\"), 'webcam', captureFolder);\n                }\n            } else {\n                const stream = await navigator.mediaDevices.getUserMedia({\n                    video: true,\n                    audio: false\n                });\n                const tempVideo = document.createElement('video');\n                tempVideo.autoplay = true;\n                tempVideo.playsInline = true;\n                tempVideo.muted = true;\n                tempVideo.style.position = 'absolute';\n                tempVideo.style.left = '-9999px';\n                tempVideo.style.opacity = '0';\n                document.body.appendChild(tempVideo);\n                tempVideo.srcObject = stream;\n                await new Promise((resolve)=>{\n                    const timeoutId = setTimeout(resolve, 1000);\n                    tempVideo.onloadeddata = ()=>{\n                        clearTimeout(timeoutId);\n                        resolve();\n                    };\n                });\n                await new Promise((resolve)=>setTimeout(resolve, 200));\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = tempVideo.videoWidth || 640;\n                tempCanvas.height = tempVideo.videoHeight || 480;\n                ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, \"webcam_\".concat(String(usedCaptureNumber).padStart(3, '0'), \".jpg\"), 'webcam', captureFolder);\n                }\n                stream.getTracks().forEach((track)=>track.stop());\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        } catch (webcamError) {\n            console.error(\"Error capturing webcam silently:\", webcamError);\n        }\n        // === 3. Save parameter CSV ===\n        try {\n            console.log(\"Creating parameter CSV\");\n            const csvData = [\n                \"name,value\",\n                \"dot_x,\".concat(position.x),\n                \"dot_y,\".concat(position.y),\n                \"canvas_width,\".concat(canvas ? canvas.width : 0),\n                \"canvas_height,\".concat(canvas ? canvas.height : 0),\n                \"window_width,\".concat(window.innerWidth),\n                \"window_height,\".concat(window.innerHeight),\n                \"timestamp,\".concat(new Date().toISOString())\n            ].join('\\n');\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            if (saveImageToServer) {\n                await saveImageToServer(csvDataUrl, \"parameter_\".concat(String(usedCaptureNumber).padStart(3, '0'), \".csv\"), 'parameters', captureFolder);\n            }\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n        }\n        // === 4. Update counter ===\n        if (setCaptureCounter) {\n            setCaptureCounter(usedCaptureNumber + 1);\n        }\n        // === 5. Set process status ===\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured with dot at: x=\".concat(position.x, \", y=\").concat(position.y));\n        }\n        // === 6. Return capture data ===\n        return {\n            screenImage: screenImageData,\n            webcamImage: webcamImageData,\n            position,\n            captureNumber: usedCaptureNumber\n        };\n    } catch (error) {\n        console.error(\"Error during capture:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Error capturing images: \".concat(error.message));\n        }\n        throw error;\n    }\n};\n/**\n   * Display a preview of the captured images\n   * @param {string} screenImage - Data URL of the screen image\n   * @param {string} webcamImage - Data URL of the webcam image\n   * @param {Object} dotPosition - {x, y} position of the dot\n   */ const showCapturePreview = (screenImage, webcamImage, dotPosition)=>{\n    if (!screenImage && !webcamImage) {\n        console.warn(\"No images available to preview\");\n        return;\n    }\n    // Remove any existing preview containers first\n    try {\n        const existingPreviews = document.querySelectorAll('.capture-preview-container');\n        existingPreviews.forEach((preview)=>{\n            if (preview.parentNode) {\n                console.log(\"Removing existing preview container\");\n                preview.parentNode.removeChild(preview);\n            }\n        });\n    } catch (cleanupError) {\n        console.error(\"Error cleaning up existing previews:\", cleanupError);\n    }\n    // Create a new preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n      position: fixed;\\n      top: 50%;\\n      left: 50%;\\n      transform: translate(-50%, -50%);\\n      display: flex;\\n      gap: 20px;\\n      background-color: rgba(0, 0, 0, 0.85);\\n      padding: 20px;\\n      border-radius: 12px;\\n      z-index: 999999;\\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n    \";\n    // Function to add an image to the preview\n    const addImagePreview = (image, label)=>{\n        try {\n            const preview = document.createElement('div');\n            preview.style.cssText = \"\\n          display: flex;\\n          flex-direction: column;\\n          align-items: center;\\n        \";\n            const img = document.createElement('img');\n            img.src = image;\n            img.alt = label;\n            img.style.cssText = \"\\n          max-width: 320px;\\n          max-height: 240px;\\n          border: 3px solid white;\\n          border-radius: 8px;\\n          background-color: #333;\\n        \";\n            const labelElement = document.createElement('div');\n            labelElement.textContent = label;\n            labelElement.style.cssText = \"\\n          color: white;\\n          font-size: 14px;\\n          margin-top: 10px;\\n          font-weight: bold;\\n        \";\n            preview.appendChild(img);\n            preview.appendChild(labelElement);\n            previewContainer.appendChild(preview);\n            return true;\n        } catch (error) {\n            console.error(\"Error adding \".concat(label, \" preview:\"), error);\n            return false;\n        }\n    };\n    // Add debug info div\n    const debugInfo = document.createElement('div');\n    debugInfo.style.cssText = \"\\n      position: absolute;\\n      top: -30px;\\n      left: 0;\\n      width: 100%;\\n      color: white;\\n      font-size: 12px;\\n      text-align: center;\\n    \";\n    debugInfo.textContent = \"Screen: \".concat(screenImage ? 'YES' : 'NO', \", Webcam: \").concat(webcamImage ? 'YES' : 'NO');\n    previewContainer.appendChild(debugInfo);\n    // Add both images to preview if available\n    if (screenImage) {\n        addImagePreview(screenImage, 'Screen Capture');\n    }\n    if (webcamImage) {\n        addImagePreview(webcamImage, 'Webcam Capture');\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = \"Dot position: x=\".concat(Math.round(dotPosition.x), \", y=\").concat(Math.round(dotPosition.y));\n        positionInfo.style.cssText = \"\\n        color: #ffcc00;\\n        font-size: 14px;\\n        position: absolute;\\n        top: -50px;\\n        left: 0;\\n        width: 100%;\\n        text-align: center;\\n      \";\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add countdown timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n      position: absolute;\\n      bottom: -25px;\\n      right: 20px;\\n      color: white;\\n      font-size: 12px;\\n      background-color: rgba(0, 0, 0, 0.7);\\n      padding: 3px 8px;\\n      border-radius: 4px;\\n    \";\n    previewContainer.appendChild(timerElement);\n    // Add to document body\n    document.body.appendChild(previewContainer);\n    // Countdown and remove the preview after 2 seconds\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            // Fade out\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            previewContainer.style.opacity = '0';\n            // Remove after fade\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup after 5 seconds in case anything goes wrong\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n    return previewContainer;\n};\n/**\n   * Complete capture and preview process\n   * @param {Object} options - Process options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.onStatusUpdate - Function to update status\n   * @param {string} options.captureFolder - Folder to save captures in\n   */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.error('[captureImages] Invalid position:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid dot position (captureImages)');\n        return;\n    }\n    let dotInterval;\n    try {\n        // Make sure we have a valid canvas reference\n        if (!(canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current)) {\n            throw new Error(\"Canvas reference is invalid\");\n        }\n        // Draw the dot in its position first to ensure it's visible\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Initially draw the dot\n        drawRedDot(ctx, position.x, position.y);\n        // Create an interval to keep redrawing the dot to ensure it stays visible\n        dotInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y);\n        }, 200);\n        // First run the countdown\n        //   await runCountdown(\n        //     position,\n        //     canvasRef.current,\n        //     onStatusUpdate, \n        //     null // No callback here as we'll handle it directly\n        //   );\n        await runCountdown(position, canvas, onStatusUpdate, async ()=>{\n            try {\n                // ✅ Validate again here if needed\n                if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n                    throw new Error('Position is missing after countdown');\n                }\n                // Capture both canvas and webcam\n                const result = await captureImages({\n                    canvasRef,\n                    position,\n                    captureCounter,\n                    saveImageToServer,\n                    setCaptureCounter,\n                    setProcessStatus,\n                    toggleTopBar,\n                    captureFolder\n                });\n                return result;\n            } catch (err) {\n                console.error('[captureAndPreviewProcess] Error during capture:', err);\n                setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n            }\n        });\n        // Make sure dot is visible after countdown\n        drawRedDot(ctx, position.x, position.y);\n        // Capture the images\n        const captureResult = await captureImages({\n            canvasRef,\n            position,\n            captureCounter,\n            saveImageToServer,\n            setCaptureCounter,\n            setProcessStatus,\n            toggleTopBar,\n            captureFolder\n        });\n        // Make sure dot is visible after capturing\n        drawRedDot(ctx, position.x, position.y);\n        // Show preview of captured images\n        showCapturePreview(captureResult.screenImage, captureResult.webcamImage, captureResult.position);\n        // Make sure dot is visible after preview\n        drawRedDot(ctx, position.x, position.y);\n        // Show TopBar again after a delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n            // Make sure dot is still visible even after showing TopBar\n            drawRedDot(ctx, position.x, position.y);\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"Error in capture and preview process:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Error: \".concat(error.message));\n        }\n        // Show TopBar again even if error occurred\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        throw error;\n    } finally{\n        // Clear the dot redraw interval if it was created\n        if (dotInterval) {\n            clearInterval(dotInterval);\n        }\n    }\n};\n/**\n   * Generate a random dot position within the canvas\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {number} padding - Padding from the edges\n   * @returns {Object} - {x, y} position\n   */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n   * Draw a red dot on the canvas\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @param {number} radius - Dot radius\n   * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n   * @returns {Object} - {x, y} position\n   */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n   * Initialize canvas for drawing\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {HTMLElement} parent - Parent element for dimensions\n   * @returns {boolean} - Success status\n   */ const initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsaUVBQWlFO0FBRWpFOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLHlCQUF5QixDQUFDQyxVQUFVQztJQUM3QyxJQUFJLENBQUNELFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyw4Q0FBOENMO1FBQzNELE9BQU87SUFDVDtJQUVBLE1BQU1NLHFCQUFxQkMsU0FBU0MsZ0JBQWdCLENBQUM7SUFDckRGLG1CQUFtQkcsT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHQyxNQUFNO0lBRTFDLE1BQU1DLFlBQVlYLFdBQVdZLElBQUksR0FBR2IsU0FBU0UsQ0FBQztJQUM5QyxNQUFNWSxZQUFZYixXQUFXYyxHQUFHLEdBQUdmLFNBQVNHLENBQUM7SUFFN0MsTUFBTWEsbUJBQW1CVCxTQUFTVSxhQUFhLENBQUM7SUFDaERELGlCQUFpQkUsU0FBUyxHQUFHO0lBQzdCRixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLHlDQUd4Qk4sT0FEQ0YsV0FBVSxvQkFDSSxPQUFmRSxZQUFZLElBQUc7SUFrQnhCUCxTQUFTYyxJQUFJLENBQUNDLFdBQVcsQ0FBQ047SUFDMUIsT0FBT0E7QUFDVCxFQUFFO0FBRUY7Ozs7OztDQU1ELEdBQ00sTUFBTU8sZUFBZSxPQUFPdkIsVUFBVXdCLFFBQVFDLGdCQUFnQkM7SUFDakUsSUFBSSxDQUFDMUIsWUFBWSxPQUFPQSxTQUFTRSxDQUFDLEtBQUssWUFBWSxPQUFPRixTQUFTRyxDQUFDLEtBQUssVUFBVTtRQUNqRkMsUUFBUUMsSUFBSSxDQUFDLG9DQUFvQ0w7UUFDakR5QiwyQkFBQUEscUNBQUFBLGVBQWlCO1lBQ2ZFLGVBQWU7WUFD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QzlCRCxJQUFJd0gsU0FBUyxDQUFDLEdBQUcsR0FBRy9ILE9BQU93QyxLQUFLLEVBQUV4QyxPQUFPeUMsTUFBTTtJQUMvQ2xDLElBQUl5SCxTQUFTLEdBQUc7SUFDaEJ6SCxJQUFJMEgsUUFBUSxDQUFDLEdBQUcsR0FBR2pJLE9BQU93QyxLQUFLLEVBQUV4QyxPQUFPeUMsTUFBTTtJQUU5QyxPQUFPO0FBQ1QsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY291bnRTYXZlLmpzXG4vLyBTaGFyZWQgZnVuY3Rpb25hbGl0eSBmb3IgY291bnRkb3duIGFuZCBpbWFnZSBjYXB0dXJlIHByb2Nlc3Nlc1xuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGRpc3BsYXlzIGEgY291bnRkb3duIGVsZW1lbnQgYWJvdmUgYSBkb3QgcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKiBAcGFyYW0ge0RPTVJlY3R9IGNhbnZhc1JlY3QgLSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBvZiB0aGUgY2FudmFzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGNvdW50ZG93biBmaW5pc2hlc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBjcmVhdGVkIGNvdW50ZG93biBlbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDb3VudGRvd25FbGVtZW50ID0gKHBvc2l0aW9uLCBjYW52YXNSZWN0KSA9PiB7XG4gICAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVDb3VudGRvd25FbGVtZW50XSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgXG4gICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1jb3VudGRvd24sIC5mb3JjZWQtY291bnRkb3duLCAuY2VudGVyLWNvdW50ZG93bi1iYWNrdXAnKTtcbiAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiBlbC5yZW1vdmUoKSk7XG4gIFxuICAgIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLng7XG4gICAgY29uc3QgYWJzb2x1dGVZID0gY2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55O1xuICBcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogJHthYnNvbHV0ZVh9cHg7XG4gICAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgIHJldHVybiBjb3VudGRvd25FbGVtZW50O1xuICB9O1xuICBcbiAgLyoqXG4gKiBSdW5zIGEgY291bnRkb3duIHByb2Nlc3MgdGhhdCBkaXNwbGF5cyAzLTItMSBhYm92ZSBhIGRvdFxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIGRvdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25TdGF0dXNVcGRhdGUgLSBGdW5jdGlvbiB0byB1cGRhdGUgc3RhdHVzIG1lc3NhZ2VzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGNvdW50ZG93biBjb21wbGV0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1bkNvdW50ZG93biA9IGFzeW5jIChwb3NpdGlvbiwgY2FudmFzLCBvblN0YXR1c1VwZGF0ZSwgb25Db21wbGV0ZSkgPT4ge1xuICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKCdbcnVuQ291bnRkb3duXSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkludmFsaWQgZG90IHBvc2l0aW9uXCIsXG4gICAgICAgIGNvdW50ZG93blZhbHVlOiBudWxsLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gY3JlYXRlQ291bnRkb3duRWxlbWVudChwb3NpdGlvbiwgY2FudmFzUmVjdCk7XG4gICAgXG4gICAgaWYgKCFjb3VudGRvd25FbGVtZW50KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tydW5Db3VudGRvd25dIENvdW50ZG93biBlbGVtZW50IGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIFxuICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgXG4gICAgbGV0IGNvdW50ID0gMztcbiAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gIFxuICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgfSk7XG4gIFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgY291bnRkb3duSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvdW50LS07XG4gIFxuICAgICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoY291bnRkb3duSW50ZXJ2YWwpO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICBcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJDYXB0dXJpbmcgaW1hZ2UuLi5cIixcbiAgICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uICYmIHR5cGVvZiBwb3NpdGlvbi54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgcG9zaXRpb24ueSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltydW5Db3VudGRvd25dIFBvc2l0aW9uIGlzIG51bGwgYWZ0ZXIgY291bnRkb3duXCIsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gIFxuICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDgwMCk7XG4gICAgfSk7XG4gIH07XG4gIC8qKlxuICAgKiBDYXB0dXJlcyBpbWFnZXMgZnJvbSBib3RoIGNhbnZhcyBhbmQgd2ViY2FtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7UmVhY3QuUmVmT2JqZWN0fSBvcHRpb25zLmNhbnZhc1JlZiAtIFJlZiB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnRlciAtIEN1cnJlbnQgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2F2ZUltYWdlVG9TZXJ2ZXIgLSBGdW5jdGlvbiB0byBzYXZlIGltYWdlIHRvIHNlcnZlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudGVyIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldFByb2Nlc3NTdGF0dXMgLSBGdW5jdGlvbiB0byB1cGRhdGUgcHJvY2VzcyBzdGF0dXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50b2dnbGVUb3BCYXIgLSBGdW5jdGlvbiB0byB0b2dnbGUgdG9wIGJhciB2aXNpYmlsaXR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhcHR1cmVGb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBjYXB0dXJlcyBpblxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFJlc3VsdCB3aXRoIGNhcHR1cmVkIGltYWdlIGRhdGFcbiAgICovXG4gIGV4cG9ydCBjb25zdCBjYXB0dXJlSW1hZ2VzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICBjYXB0dXJlRm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICB9ID0gb3B0aW9ucztcbiAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSBTdHJpbmcoY2FwdHVyZUNvdW50ZXIpLnBhZFN0YXJ0KDMsICcwJyk7XG4gICAgICBjb25zdCBzY3JlZW5GaWxlbmFtZSA9IGBzY3JlZW5fJHtjb3VudGVyfS5qcGdgO1xuICAgICAgY29uc3Qgd2ViY2FtRmlsZW5hbWUgPSBgd2ViY2FtXyR7Y291bnRlcn0uanBnYDtcbiAgICAgIGNvbnN0IHBhcmFtZXRlckZpbGVuYW1lID0gYHBhcmFtZXRlcl8ke2NvdW50ZXJ9LmNzdmA7XG4gIFxuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgcHJvY2VzcyB3aXRoIGNvdW50ZXI6ICR7Y291bnRlcn1gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBEb3QgcG9zaXRpb246IHg9JHtwb3NpdGlvbi54fSwgeT0ke3Bvc2l0aW9uLnl9YCk7XG4gIFxuICAgICAgbGV0IHNjcmVlbkltYWdlRGF0YSA9IG51bGw7XG4gICAgICBsZXQgd2ViY2FtSW1hZ2VEYXRhID0gbnVsbDtcbiAgICAgIGxldCB1c2VkQ2FwdHVyZU51bWJlciA9IGNhcHR1cmVDb3VudGVyO1xuICBcbiAgICAgIC8vID09PSAxLiBDYXB0dXJlIHNjcmVlbiBpbWFnZSBmcm9tIGNhbnZhcyA9PT1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgICAgICAgICAvLyDinIUgTWFrZSBzdXJlIHRoZSByZWQgZG90IGlzIGRyYXduIFJJR0hUIGJlZm9yZSBzY3JlZW4gY2FwdHVyZVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgXG4gICAgICAgICAgY29uc29sZS5sb2coYENhbnZhcyBkaW1lbnNpb25zOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgICAgIHNjcmVlbkltYWdlRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTY3JlZW4gaW1hZ2UgY2FwdHVyZWQsIHNpemU6ICR7c2NyZWVuSW1hZ2VEYXRhLmxlbmd0aH0gY2hhcnNgKTtcbiAgXG4gICAgICAgICAgaWYgKHNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JlZW5SZXNwb25zZSA9IGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgICBzY3JlZW5JbWFnZURhdGEsXG4gICAgICAgICAgICAgIHNjcmVlbkZpbGVuYW1lLFxuICAgICAgICAgICAgICAnc2NyZWVuJyxcbiAgICAgICAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgICAgICAgKTtcbiAgXG4gICAgICAgICAgICBpZiAoc2NyZWVuUmVzcG9uc2UgJiYgc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlcikge1xuICAgICAgICAgICAgICB1c2VkQ2FwdHVyZU51bWJlciA9IHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXI7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTZXJ2ZXIgYXNzaWduZWQgY2FwdHVyZSBudW1iZXI6ICR7dXNlZENhcHR1cmVOdW1iZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChzY3JlZW5FcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgb3Igc2F2aW5nIHNjcmVlbiBpbWFnZTpcIiwgc2NyZWVuRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsLCBjYW5ub3QgY2FwdHVyZSBzY3JlZW5cIik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDIuIENhcHR1cmUgd2ViY2FtIGltYWdlID09PVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJBdHRlbXB0aW5nIHRvIGNhcHR1cmUgd2ViY2FtIHNpbGVudGx5XCIpO1xuICBcbiAgICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gd2luZG93LnZpZGVvRWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICBcbiAgICAgICAgaWYgKHZpZGVvRWxlbWVudCAmJiB2aWRlb0VsZW1lbnQucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdmlkZW9FbGVtZW50LnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlb0VsZW1lbnQsIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIFxuICAgICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoXG4gICAgICAgICAgICAgIHdlYmNhbUltYWdlRGF0YSxcbiAgICAgICAgICAgICAgYHdlYmNhbV8ke1N0cmluZyh1c2VkQ2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYCxcbiAgICAgICAgICAgICAgJ3dlYmNhbScsXG4gICAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIGNvbnN0IHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWaWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICB0ZW1wVmlkZW8uc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICAgICAgICB0ZW1wVmlkZW8uc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gIFxuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApO1xuICAgICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgXG4gICAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgXG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gIFxuICAgICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoXG4gICAgICAgICAgICAgIHdlYmNhbUltYWdlRGF0YSxcbiAgICAgICAgICAgICAgYHdlYmNhbV8ke1N0cmluZyh1c2VkQ2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYCxcbiAgICAgICAgICAgICAgJ3dlYmNhbScsXG4gICAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBudWxsO1xuICAgICAgICAgIGlmICh0ZW1wVmlkZW8ucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGVtcFZpZGVvLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHdlYmNhbUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgd2ViY2FtIHNpbGVudGx5OlwiLCB3ZWJjYW1FcnJvcik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDMuIFNhdmUgcGFyYW1ldGVyIENTViA9PT1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ3JlYXRpbmcgcGFyYW1ldGVyIENTVlwiKTtcbiAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICAgICAgYGRvdF94LCR7cG9zaXRpb24ueH1gLFxuICAgICAgICAgIGBkb3RfeSwke3Bvc2l0aW9uLnl9YCxcbiAgICAgICAgICBgY2FudmFzX3dpZHRoLCR7Y2FudmFzID8gY2FudmFzLndpZHRoIDogMH1gLFxuICAgICAgICAgIGBjYW52YXNfaGVpZ2h0LCR7Y2FudmFzID8gY2FudmFzLmhlaWdodCA6IDB9YCxcbiAgICAgICAgICBgd2luZG93X3dpZHRoLCR7d2luZG93LmlubmVyV2lkdGh9YCxcbiAgICAgICAgICBgd2luZG93X2hlaWdodCwke3dpbmRvdy5pbm5lckhlaWdodH1gLFxuICAgICAgICAgIGB0aW1lc3RhbXAsJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICBcbiAgICAgICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgICAgICBjb25zdCBjc3ZSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBcbiAgICAgICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY3N2UmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUoY3N2UmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgY3N2UmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgICAgIH0pO1xuICBcbiAgICAgICAgaWYgKHNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoXG4gICAgICAgICAgICBjc3ZEYXRhVXJsLFxuICAgICAgICAgICAgYHBhcmFtZXRlcl8ke1N0cmluZyh1c2VkQ2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uY3N2YCxcbiAgICAgICAgICAgICdwYXJhbWV0ZXJzJyxcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChjc3ZFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHBhcmFtZXRlciBDU1Y6XCIsIGNzdkVycm9yKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyA9PT0gNC4gVXBkYXRlIGNvdW50ZXIgPT09XG4gICAgICBpZiAoc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIodXNlZENhcHR1cmVOdW1iZXIgKyAxKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyA9PT0gNS4gU2V0IHByb2Nlc3Mgc3RhdHVzID09PVxuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZWQgd2l0aCBkb3QgYXQ6IHg9JHtwb3NpdGlvbi54fSwgeT0ke3Bvc2l0aW9uLnl9YCk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDYuIFJldHVybiBjYXB0dXJlIGRhdGEgPT09XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogc2NyZWVuSW1hZ2VEYXRhLFxuICAgICAgICB3ZWJjYW1JbWFnZTogd2ViY2FtSW1hZ2VEYXRhLFxuICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZU51bWJlcjogdXNlZENhcHR1cmVOdW1iZXJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgY2FwdHVyZTpcIiwgZXJyb3IpO1xuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRXJyb3IgY2FwdHVyaW5nIGltYWdlczogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIERpc3BsYXkgYSBwcmV2aWV3IG9mIHRoZSBjYXB0dXJlZCBpbWFnZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjcmVlbkltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHNjcmVlbiBpbWFnZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViY2FtSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgd2ViY2FtIGltYWdlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkb3RQb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gICAqL1xuICBleHBvcnQgY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgZG90UG9zaXRpb24pID0+IHtcbiAgICBpZiAoIXNjcmVlbkltYWdlICYmICF3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gaW1hZ2VzIGF2YWlsYWJsZSB0byBwcmV2aWV3XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBwcmV2aWV3IGNvbnRhaW5lcnMgZmlyc3RcbiAgICB0cnkge1xuICAgICAgY29uc3QgZXhpc3RpbmdQcmV2aWV3cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXB0dXJlLXByZXZpZXctY29udGFpbmVyJyk7XG4gICAgICBleGlzdGluZ1ByZXZpZXdzLmZvckVhY2gocHJldmlldyA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbW92aW5nIGV4aXN0aW5nIHByZXZpZXcgY29udGFpbmVyXCIpO1xuICAgICAgICAgIHByZXZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2xlYW5pbmcgdXAgZXhpc3RpbmcgcHJldmlld3M6XCIsIGNsZWFudXBFcnJvcik7XG4gICAgfVxuICAgIFxuICAgIC8vIENyZWF0ZSBhIG5ldyBwcmV2aWV3IGNvbnRhaW5lclxuICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYXB0dXJlLXByZXZpZXctY29udGFpbmVyJztcbiAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGdhcDogMjBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgIGA7XG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gYWRkIGFuIGltYWdlIHRvIHRoZSBwcmV2aWV3XG4gICAgY29uc3QgYWRkSW1hZ2VQcmV2aWV3ID0gKGltYWdlLCBsYWJlbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlO1xuICAgICAgICBpbWcuYWx0ID0gbGFiZWw7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgIGxhYmVsRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZChsYWJlbEVsZW1lbnQpO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHByZXZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFkZGluZyAke2xhYmVsfSBwcmV2aWV3OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIGRlYnVnIGluZm8gZGl2XG4gICAgY29uc3QgZGVidWdJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVidWdJbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IC0zMHB4O1xuICAgICAgbGVmdDogMDtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGA7XG4gICAgZGVidWdJbmZvLnRleHRDb250ZW50ID0gYFNjcmVlbjogJHtzY3JlZW5JbWFnZSA/ICdZRVMnIDogJ05PJ30sIFdlYmNhbTogJHt3ZWJjYW1JbWFnZSA/ICdZRVMnIDogJ05PJ31gO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoZGVidWdJbmZvKTtcbiAgICBcbiAgICAvLyBBZGQgYm90aCBpbWFnZXMgdG8gcHJldmlldyBpZiBhdmFpbGFibGVcbiAgICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICAgIGFkZEltYWdlUHJldmlldyhzY3JlZW5JbWFnZSwgJ1NjcmVlbiBDYXB0dXJlJyk7XG4gICAgfVxuICAgIFxuICAgIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgICAgYWRkSW1hZ2VQcmV2aWV3KHdlYmNhbUltYWdlLCAnV2ViY2FtIENhcHR1cmUnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGRvdCBwb3NpdGlvbiBpbmZvIGlmIGF2YWlsYWJsZVxuICAgIGlmIChkb3RQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3NpdGlvbkluZm8udGV4dENvbnRlbnQgPSBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLnkpfWA7XG4gICAgICBwb3NpdGlvbkluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC01MHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9zaXRpb25JbmZvKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGNvdW50ZG93biB0aW1lclxuICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgXG4gICAgLy8gQWRkIHRvIGRvY3VtZW50IGJvZHlcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIFxuICAgIC8vIENvdW50ZG93biBhbmQgcmVtb3ZlIHRoZSBwcmV2aWV3IGFmdGVyIDIgc2Vjb25kc1xuICAgIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAvLyBGYWRlIG91dFxuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwLjNzIGVhc2UnO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIC8vIFJlbW92ZSBhZnRlciBmYWRlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgLy8gU2FmZXR5IGNsZWFudXAgYWZ0ZXIgNSBzZWNvbmRzIGluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfSwgNTAwMCk7XG4gICAgXG4gICAgcmV0dXJuIHByZXZpZXdDb250YWluZXI7XG4gIH07XG4gIFxuICAvKipcbiAgICogQ29tcGxldGUgY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvY2VzcyBvcHRpb25zXG4gICAqIEBwYXJhbSB7UmVhY3QuUmVmT2JqZWN0fSBvcHRpb25zLmNhbnZhc1JlZiAtIFJlZiB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jYXB0dXJlQ291bnRlciAtIEN1cnJlbnQgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2F2ZUltYWdlVG9TZXJ2ZXIgLSBGdW5jdGlvbiB0byBzYXZlIGltYWdlIHRvIHNlcnZlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldENhcHR1cmVDb3VudGVyIC0gRnVuY3Rpb24gdG8gdXBkYXRlIGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNldFByb2Nlc3NTdGF0dXMgLSBGdW5jdGlvbiB0byB1cGRhdGUgcHJvY2VzcyBzdGF0dXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50b2dnbGVUb3BCYXIgLSBGdW5jdGlvbiB0byB0b2dnbGUgdG9wIGJhciB2aXNpYmlsaXR5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdGF0dXNVcGRhdGUgLSBGdW5jdGlvbiB0byB1cGRhdGUgc3RhdHVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhcHR1cmVGb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBjYXB0dXJlcyBpblxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICBjYXB0dXJlRm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW2NhcHR1cmVJbWFnZXNdIEludmFsaWQgcG9zaXRpb246JywgcG9zaXRpb24pO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oJ0Vycm9yOiBJbnZhbGlkIGRvdCBwb3NpdGlvbiAoY2FwdHVyZUltYWdlcyknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIFxuICAgIFxuICAgIGxldCBkb3RJbnRlcnZhbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhIHZhbGlkIGNhbnZhcyByZWZlcmVuY2VcbiAgICAgICAgaWYgKCFjYW52YXNSZWY/LmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgaW52YWxpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgZG90IGluIGl0cyBwb3NpdGlvbiBmaXJzdCB0byBlbnN1cmUgaXQncyB2aXNpYmxlXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEluaXRpYWxseSBkcmF3IHRoZSBkb3RcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGludGVydmFsIHRvIGtlZXAgcmVkcmF3aW5nIHRoZSBkb3QgdG8gZW5zdXJlIGl0IHN0YXlzIHZpc2libGVcbiAgICAgICAgZG90SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICBcbiAgICAgIC8vIEZpcnN0IHJ1biB0aGUgY291bnRkb3duXG4gICAgLy8gICBhd2FpdCBydW5Db3VudGRvd24oXG4gICAgLy8gICAgIHBvc2l0aW9uLFxuICAgIC8vICAgICBjYW52YXNSZWYuY3VycmVudCxcbiAgICAvLyAgICAgb25TdGF0dXNVcGRhdGUsIFxuICAgIC8vICAgICBudWxsIC8vIE5vIGNhbGxiYWNrIGhlcmUgYXMgd2UnbGwgaGFuZGxlIGl0IGRpcmVjdGx5XG4gICAgLy8gICApO1xuICAgICAgICBhd2FpdCBydW5Db3VudGRvd24ocG9zaXRpb24sIGNhbnZhcywgb25TdGF0dXNVcGRhdGUsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyDinIUgVmFsaWRhdGUgYWdhaW4gaGVyZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gaXMgbWlzc2luZyBhZnRlciBjb3VudGRvd24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGJvdGggY2FudmFzIGFuZCB3ZWJjYW1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXMoe1xuICAgICAgICAgICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICBzYXZlSW1hZ2VUb1NlcnZlcixcbiAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgICAgICAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBFcnJvciBkdXJpbmcgY2FwdHVyZTonLCBlcnIpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyB2aXNpYmxlIGFmdGVyIGNvdW50ZG93blxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBpbWFnZXNcbiAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXMoe1xuICAgICAgICAgICAgY2FudmFzUmVmLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgdmlzaWJsZSBhZnRlciBjYXB0dXJpbmdcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBwcmV2aWV3IG9mIGNhcHR1cmVkIGltYWdlc1xuICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXcoXG4gICAgICAgICAgICBjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlLFxuICAgICAgICAgICAgY2FwdHVyZVJlc3VsdC53ZWJjYW1JbWFnZSxcbiAgICAgICAgICAgIGNhcHR1cmVSZXN1bHQucG9zaXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgdmlzaWJsZSBhZnRlciBwcmV2aWV3XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGUgZXZlbiBhZnRlciBzaG93aW5nIFRvcEJhclxuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICB9LCAyNTAwKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBjYXB0dXJlUmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIGVycm9yIG9jY3VycmVkXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDE1MDApO1xuICAgICAgXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gQ2xlYXIgdGhlIGRvdCByZWRyYXcgaW50ZXJ2YWwgaWYgaXQgd2FzIGNyZWF0ZWRcbiAgICAgIGlmIChkb3RJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGRvdEludGVydmFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvKipcbiAgICogR2VuZXJhdGUgYSByYW5kb20gZG90IHBvc2l0aW9uIHdpdGhpbiB0aGUgY2FudmFzXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gUGFkZGluZyBmcm9tIHRoZSBlZGdlc1xuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHt4LCB5fSBwb3NpdGlvblxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiB7IHg6IDEwMCwgeTogMTAwIH07IC8vIEZhbGxiYWNrIHBvc2l0aW9uXG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgfHwgMzAwOyAvLyBGYWxsYmFjayBpZiBoZWlnaHQgaXMgMFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyICogcGFkZGluZykpICsgcGFkZGluZ1xuICAgIH07XG4gIH07XG4gIFxuICAvKipcbiAgICogRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ2FudmFzIDJEIGNvbnRleHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIERvdCByYWRpdXNcbiAgICogQHBhcmFtIHtib29sZWFufSBjbGVhckNhbnZhcyAtIFdoZXRoZXIgdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyAoZGVmYXVsdDogdHJ1ZSlcbiAgICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAgICovXG4gIGV4cG9ydCBjb25zdCBkcmF3UmVkRG90ID0gKGN0eCwgeCwgeSwgcmFkaXVzID0gMTIsIGNsZWFyQ2FudmFzID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBpZiByZXF1ZXN0ZWQgKGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgaWYgKGNsZWFyQ2FudmFzKSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGJyaWdodCByZWQgY29sb3JcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3QgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIEFkZCBhIHNlY29uZCBsYXJnZXIgZ2xvdyBmb3IgZXZlbiBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDYsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuMyknO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH07XG4gIFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBjYW52YXMgZm9yIGRyYXdpbmdcbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcGFyZW50IC0gUGFyZW50IGVsZW1lbnQgZm9yIGRpbWVuc2lvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gU3VjY2VzcyBzdGF0dXNcbiAgICovXG4gIGV4cG9ydCBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzIGFuZCBzZXQgd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTsiXSwibmFtZXMiOlsiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInBvc2l0aW9uIiwiY2FudmFzUmVjdCIsIngiLCJ5IiwiY29uc29sZSIsIndhcm4iLCJleGlzdGluZ0NvdW50ZG93bnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJyZW1vdmUiLCJhYnNvbHV0ZVgiLCJsZWZ0IiwiYWJzb2x1dGVZIiwidG9wIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJydW5Db3VudGRvd24iLCJjYW52YXMiLCJvblN0YXR1c1VwZGF0ZSIsIm9uQ29tcGxldGUiLCJwcm9jZXNzU3RhdHVzIiwiY291bnRkb3duVmFsdWUiLCJpc0NhcHR1cmluZyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3UmVkRG90IiwiY291bnQiLCJ0ZXh0Q29udGVudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY291bnRkb3duSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2FwdHVyZUltYWdlcyIsIm9wdGlvbnMiLCJjYW52YXNSZWYiLCJjYXB0dXJlQ291bnRlciIsInNhdmVJbWFnZVRvU2VydmVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzZXRQcm9jZXNzU3RhdHVzIiwidG9nZ2xlVG9wQmFyIiwiY2FwdHVyZUZvbGRlciIsImNvdW50ZXIiLCJTdHJpbmciLCJwYWRTdGFydCIsInNjcmVlbkZpbGVuYW1lIiwid2ViY2FtRmlsZW5hbWUiLCJwYXJhbWV0ZXJGaWxlbmFtZSIsImxvZyIsInNjcmVlbkltYWdlRGF0YSIsIndlYmNhbUltYWdlRGF0YSIsInVzZWRDYXB0dXJlTnVtYmVyIiwiY3VycmVudCIsIndpZHRoIiwiaGVpZ2h0IiwidG9EYXRhVVJMIiwibGVuZ3RoIiwic2NyZWVuUmVzcG9uc2UiLCJjYXB0dXJlTnVtYmVyIiwic2NyZWVuRXJyb3IiLCJlcnJvciIsInZpZGVvRWxlbWVudCIsIndpbmRvdyIsInF1ZXJ5U2VsZWN0b3IiLCJyZWFkeVN0YXRlIiwidGVtcENhbnZhcyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImRyYXdJbWFnZSIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJ0ZW1wVmlkZW8iLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJvcGFjaXR5Iiwic3JjT2JqZWN0IiwidGltZW91dElkIiwib25sb2FkZWRkYXRhIiwiY2xlYXJUaW1lb3V0IiwiZ2V0VHJhY2tzIiwidHJhY2siLCJzdG9wIiwid2ViY2FtRXJyb3IiLCJjc3ZEYXRhIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiam9pbiIsImNzdkJsb2IiLCJCbG9iIiwidHlwZSIsImNzdlJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsImNzdkVycm9yIiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsIm1lc3NhZ2UiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJkb3RQb3NpdGlvbiIsImV4aXN0aW5nUHJldmlld3MiLCJwcmV2aWV3IiwiY2xlYW51cEVycm9yIiwicHJldmlld0NvbnRhaW5lciIsImFkZEltYWdlUHJldmlldyIsImltYWdlIiwibGFiZWwiLCJpbWciLCJzcmMiLCJhbHQiLCJsYWJlbEVsZW1lbnQiLCJkZWJ1Z0luZm8iLCJwb3NpdGlvbkluZm8iLCJNYXRoIiwicm91bmQiLCJ0aW1lckVsZW1lbnQiLCJ0aW1lTGVmdCIsImludGVydmFsIiwidHJhbnNpdGlvbiIsInRvRml4ZWQiLCJjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MiLCJkb3RJbnRlcnZhbCIsIkVycm9yIiwiZXJyIiwiY2FwdHVyZVJlc3VsdCIsImdldFJhbmRvbVBvc2l0aW9uIiwicGFkZGluZyIsImZsb29yIiwicmFuZG9tIiwicmFkaXVzIiwiY2xlYXJDYW52YXMiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsInBhcmVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/WhiteScreenMain.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/WhiteScreenMain.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Action_countSave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Action/countSave */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Action/countSave.js\");\n// components-gui/WhiteScreenMain.js\n\nvar _s = $RefreshSig$();\n\n\n// Import the shared functionality\n\n// Create a client-only version of the component\nconst WhiteScreenMain = (param)=>{\n    let { onStatusUpdate, triggerCameraAccess, onButtonClick, canvasRef = null, toggleTopBar } = param;\n    _s();\n    // Use provided canvasRef or create a new one\n    const internalCanvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const activeCanvasRef = canvasRef || internalCanvasRef;\n    // Current dot state\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Track capture session\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [captureFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('eye_tracking_captures'); // Fixed folder name\n    // Configuration state\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Debug state to make visibility easier to track\n    const [canvasVisible, setCanvasVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [forceShowCountdown, setForceShowCountdown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Set up canvas when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            // Skip if this runs during SSR\n            if (false) {}\n            const canvas = activeCanvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas ref is null in setup effect\");\n                return;\n            }\n            console.log(\"Canvas setup effect running\", {\n                hasCanvas: !!canvas,\n                canvasHeight: canvas.height,\n                canvasWidth: canvas.width\n            });\n            // Function to update canvas dimensions\n            const updateDimensions = {\n                \"WhiteScreenMain.useEffect.updateDimensions\": ()=>{\n                    const parent = canvas.parentElement;\n                    if (!parent) {\n                        console.error(\"Canvas parent is null\");\n                        return;\n                    }\n                    // Get the parent container dimensions\n                    const parentWidth = parent.clientWidth;\n                    const parentHeight = parent.clientHeight;\n                    console.log(\"Resizing canvas to:\", {\n                        parentWidth,\n                        parentHeight\n                    });\n                    canvas.width = parentWidth;\n                    canvas.height = parentHeight;\n                    // Clear the canvas and set background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Redraw current dot if exists\n                    if (currentDot) {\n                        console.log(\"Redrawing dot after resize:\", currentDot);\n                        drawDot(currentDot.x, currentDot.y, 'red', 8);\n                    }\n                    setCanvasVisible(true);\n                }\n            }[\"WhiteScreenMain.useEffect.updateDimensions\"];\n            // Initial sizing\n            updateDimensions();\n            // Listen for window resize\n            window.addEventListener('resize', updateDimensions);\n            // Clean up\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    window.removeEventListener('resize', updateDimensions);\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        activeCanvasRef,\n        currentDot\n    ]);\n    // Draw a dot on the canvas\n    const drawDot = function(x, y) {\n        let color = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'red', radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12;\n        console.log(\"Drawing dot at:\", {\n            x,\n            y,\n            color,\n            radius\n        });\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in drawDot\");\n            return null;\n        }\n        const ctx = canvas.getContext('2d');\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Draw dot with glow effect\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        // Add glow effect\n        ctx.beginPath();\n        ctx.arc(x, y, radius + 5, 0, Math.PI * 2); // Increased glow\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; // More visible glow\n        ctx.lineWidth = 3; // Thicker line\n        ctx.stroke();\n        // Store current dot position - using callback form to ensure it updates\n        setCurrentDot((prev)=>{\n            console.log(\"Updating currentDot state from:\", prev, \"to:\", {\n                x,\n                y\n            });\n            return {\n                x,\n                y\n            };\n        });\n        return {\n            x,\n            y\n        };\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        console.log(\"Clearing canvas\");\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in clearCanvas\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n        setCountdownValue(null);\n        setForceShowCountdown(false);\n        setProcessStatus('Canvas cleared');\n        // Clear the message after a delay\n        setTimeout(()=>{\n            setProcessStatus('');\n        }, 1500);\n    };\n    // Save an image to the server\n    const saveImageToServer = async (imageData, filename, type)=>{\n        try {\n            console.log(\"Attempting to save \".concat(type, \" image: \").concat(filename));\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type,\n                    folder: captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(\"Server responded with \".concat(response.status));\n            }\n            const result = await response.json();\n            console.log(\"Saved \".concat(type, \" image:\"), result);\n            // If the server returns a new capture number, update our counter\n            if (result.captureNumber) {\n                setCaptureCounter(result.captureNumber + 1);\n            }\n            return result;\n        } catch (error) {\n            console.error(\"Error saving \".concat(type, \" image:\"), error);\n            throw error;\n        }\n    };\n    // Updated captureImage function using countSave module\n    const captureImage = async ()=>{\n        console.log(\"Capturing images...\");\n        setIsCapturing(true);\n        try {\n            // Use the shared capture function\n            const captureResult = await (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.captureImages)({\n                canvasRef: activeCanvasRef,\n                position: currentDot,\n                captureCounter,\n                saveImageToServer,\n                setCaptureCounter,\n                setProcessStatus,\n                toggleTopBar,\n                captureFolder: 'eye_tracking_captures'\n            });\n            // Show preview using the shared function\n            (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.showCapturePreview)(captureResult.screenImage, captureResult.webcamImage, currentDot);\n            // Update status\n            setIsCapturing(false);\n            setProcessStatus(\"Captured with dot at: x=\".concat(currentDot === null || currentDot === void 0 ? void 0 : currentDot.x, \", y=\").concat(currentDot === null || currentDot === void 0 ? void 0 : currentDot.y));\n            // Update parent component\n            if (onStatusUpdate) {\n                onStatusUpdate(\"Images and parameters saved for capture #\".concat(captureCounter));\n            }\n            // Show TopBar again after capture with a delay to let preview finish\n            setTimeout(()=>{\n                console.log(\"Showing TopBar after capture\");\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2500);\n        } catch (error) {\n            console.error('Error during capture:', error);\n            setIsCapturing(false);\n            setProcessStatus('Error capturing images: ' + error.message);\n        }\n        // Clear status after a delay\n        setTimeout(()=>{\n            setProcessStatus('');\n        }, 3000);\n    };\n    // Random Dot action\n    const handleRandomDot = ()=>{\n        // Hide the TopBar before showing dot\n        if (typeof toggleTopBar === 'function') {\n            toggleTopBar(false);\n        } else if ( true && window.toggleTopBar) {\n            toggleTopBar(false);\n        }\n        setIsCapturing(true);\n        setProcessStatus('Generating random dot...');\n        // Give the component time to update\n        setTimeout(async ()=>{\n            const canvas = activeCanvasRef.current;\n            if (canvas) {\n                // Make sure canvas dimensions are properly set\n                const parent = canvas.parentElement;\n                (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.initializeCanvas)(canvas, parent);\n                // Generate random position\n                const position = (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.getRandomPosition)(canvas);\n                // Draw the dot\n                const ctx = canvas.getContext('2d');\n                (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.drawRedDot)(ctx, position.x, position.y);\n                // Store current dot position directly\n                setCurrentDot(position);\n                try {\n                    // Use the shared capture and preview process\n                    await (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.captureAndPreviewProcess)({\n                        canvasRef: activeCanvasRef,\n                        position,\n                        captureCounter,\n                        saveImageToServer,\n                        setCaptureCounter,\n                        setProcessStatus,\n                        toggleTopBar,\n                        onStatusUpdate: (status)=>{\n                            if (onStatusUpdate) {\n                                onStatusUpdate(status);\n                            }\n                        },\n                        captureFolder: 'eye_tracking_captures'\n                    });\n                    // Set capturing state to false after a delay\n                    setTimeout(()=>{\n                        setIsCapturing(false);\n                    }, 2200);\n                } catch (error) {\n                    console.error(\"Error in capture and preview process:\", error);\n                    setIsCapturing(false);\n                    setProcessStatus('Error capturing images: ' + error.message);\n                    // Clear error message after a delay\n                    setTimeout(()=>{\n                        setProcessStatus('');\n                    }, 3000);\n                }\n            }\n        }, 200);\n    };\n    // Multiple random dots sequence - also updated to use countSave functions\n    const handleSetRandom = ()=>{\n        if (isCapturing) return;\n        // Parse input values (use defaults if invalid)\n        const times = parseInt(randomTimes) || 1;\n        const delay = parseInt(delaySeconds) || 3;\n        if (times <= 0 || delay <= 0) {\n            setProcessStatus('Please use positive values for times and delay');\n            return;\n        }\n        setIsCapturing(true);\n        setRemainingCaptures(times);\n        setProcessStatus(\"Starting \".concat(times, \" random captures...\"));\n        // Start sequence\n        scheduleRandomCaptures(times, times, delay);\n    };\n    // Schedule sequence of random captures - updated with countSave\n    const scheduleRandomCaptures = (remaining, total, delay)=>{\n        if (remaining <= 0) {\n            setIsCapturing(false);\n            setRemainingCaptures(0);\n            setProcessStatus('Random capture sequence completed');\n            // Clear status after a delay\n            setTimeout(()=>{\n                setProcessStatus('');\n            }, 2000);\n            return;\n        }\n        setRemainingCaptures(remaining);\n        setProcessStatus(\"Capture \".concat(total - remaining + 1, \" of \").concat(total));\n        // Generate random position and draw\n        const canvas = activeCanvasRef.current;\n        const ctx = canvas.getContext('2d');\n        const position = (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.getRandomPosition)(canvas);\n        (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.drawRedDot)(ctx, position.x, position.y);\n        setCurrentDot(position);\n        // Use shared capture and preview process\n        (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.captureAndPreviewProcess)({\n            canvasRef: activeCanvasRef,\n            position,\n            captureCounter,\n            saveImageToServer,\n            setCaptureCounter,\n            setProcessStatus,\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (onStatusUpdate) {\n                    onStatusUpdate(status);\n                }\n            },\n            captureFolder: 'eye_tracking_captures'\n        }).then(()=>{\n            // Schedule next capture\n            setTimeout(()=>{\n                scheduleRandomCaptures(remaining - 1, total, delay);\n            }, delay * 1000);\n        }).catch((error)=>{\n            console.error('Error during random capture:', error);\n            setIsCapturing(false);\n            setProcessStatus('Error: ' + error.message);\n            // Clear error message after a delay\n            setTimeout(()=>{\n                setProcessStatus('');\n            }, 3000);\n        });\n    };\n    // Generate calibration points based on canvas dimensions\n    const generateCalibrationPoints = (width, height)=>{\n        if (!width || !height || width <= 0 || height <= 0) {\n            console.error(\"generateCalibrationPoints: Invalid canvas dimensions\", {\n                width,\n                height\n            });\n            return [];\n        }\n        const conditionalRound = (dimension, percentage)=>Math.round(dimension * percentage);\n        // Outer frame (12% from edges)\n        const xLeftOuter = conditionalRound(width, 0.12);\n        const xRightOuter = width - xLeftOuter;\n        const yTopOuter = conditionalRound(height, 0.12);\n        const yBottomOuter = height - yTopOuter;\n        // Inner frame (26% from edges)\n        const xLeftInner = conditionalRound(width, 0.26);\n        const xRightInner = width - xLeftInner;\n        const yTopInner = conditionalRound(height, 0.26);\n        const yBottomInner = height - yTopInner;\n        const xCenter = Math.floor(width / 2);\n        const yCenter = Math.floor(height / 2);\n        return [\n            // Outer frame (8 points)\n            {\n                x: xLeftOuter,\n                y: yTopOuter,\n                label: \"Outer Top-Left\"\n            },\n            {\n                x: xCenter,\n                y: yTopOuter,\n                label: \"Outer Top-Center\"\n            },\n            {\n                x: xRightOuter,\n                y: yTopOuter,\n                label: \"Outer Top-Right\"\n            },\n            {\n                x: xLeftOuter,\n                y: yCenter,\n                label: \"Outer Middle-Left\"\n            },\n            {\n                x: xRightOuter,\n                y: yCenter,\n                label: \"Outer Middle-Right\"\n            },\n            {\n                x: xLeftOuter,\n                y: yBottomOuter,\n                label: \"Outer Bottom-Left\"\n            },\n            {\n                x: xCenter,\n                y: yBottomOuter,\n                label: \"Outer Bottom-Center\"\n            },\n            {\n                x: xRightOuter,\n                y: yBottomOuter,\n                label: \"Outer Bottom-Right\"\n            },\n            // Inner frame (8 points)\n            {\n                x: xLeftInner,\n                y: yTopInner,\n                label: \"Inner Top-Left\"\n            },\n            {\n                x: xCenter,\n                y: yTopInner,\n                label: \"Inner Top-Center\"\n            },\n            {\n                x: xRightInner,\n                y: yTopInner,\n                label: \"Inner Top-Right\"\n            },\n            {\n                x: xLeftInner,\n                y: yCenter,\n                label: \"Inner Middle-Left\"\n            },\n            {\n                x: xRightInner,\n                y: yCenter,\n                label: \"Inner Middle-Right\"\n            },\n            {\n                x: xLeftInner,\n                y: yBottomInner,\n                label: \"Inner Bottom-Left\"\n            },\n            {\n                x: xCenter,\n                y: yBottomInner,\n                label: \"Inner Bottom-Center\"\n            },\n            {\n                x: xRightInner,\n                y: yBottomInner,\n                label: \"Inner Bottom-Right\"\n            }\n        ];\n    };\n    // Handle Set Calibrate action\n    const handleSetCalibrate = async ()=>{\n        try {\n            // STEP 1: HIDE THE TOP BAR IMMEDIATELY (before anything else happens)\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Add a small delay to ensure UI updates\n            await new Promise((resolve)=>setTimeout(resolve, 50));\n            // STEP 2: Initial setup\n            setIsCapturing(true);\n            setProcessStatus('Starting calibration sequence...');\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: 'Starting calibration sequence',\n                    isCapturing: true\n                });\n            }\n            // Create a status indicator\n            const statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 10px;\\n        right: 10px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 14px;\\n        font-weight: bold;\\n        padding: 8px 12px;\\n        border-radius: 6px;\\n        z-index: 9999;\\n        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibrate Set Active: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // STEP 3: Setup canvas and generate points\n            const canvas = activeCanvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas reference is null\");\n            }\n            // Ensure canvas dimensions are set\n            const parent = canvas.parentElement;\n            if (parent) {\n                canvas.width = parent.clientWidth;\n                canvas.height = parent.clientHeight;\n            }\n            console.log(\"Canvas dimensions for calibration:\", {\n                width: canvas.width,\n                height: canvas.height\n            });\n            // Generate calibration points using the imported function\n            const points = generateCalibrationPoints(canvas.width, canvas.height);\n            setCalibrationPoints(points);\n            console.log(\"Generated \".concat(points.length, \" calibration points\"));\n            if (!points || points.length === 0) {\n                throw new Error('Failed to generate calibration points');\n            }\n            setRemainingCaptures(points.length);\n            // STEP 4: Process each calibration point in sequence\n            for(let i = 0; i < points.length; i++){\n                // Update state\n                setCurrentCalibrationIndex(i);\n                setRemainingCaptures(points.length - i);\n                // Update status\n                const statusText = \"Calibration \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(statusText);\n                statusIndicator.textContent = \"Calibrate Set Active: Processing point \".concat(i + 1, \"/\").concat(points.length);\n                if (onStatusUpdate) {\n                    onStatusUpdate(statusText);\n                }\n                // STEP 5: Draw the red dot FIRST, before any countdown\n                const point = points[i];\n                drawDot(point.x, point.y);\n                // Wait a moment to ensure dot is visible\n                await new Promise((resolve)=>setTimeout(resolve, 50));\n                // STEP 6: Get canvas position for absolute positioning\n                const canvasRect = canvas.getBoundingClientRect();\n                // Create countdown element above the dot\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'calibrate-countdown';\n                // Position it above the dot\n                const absoluteX = canvasRect.left + point.x;\n                const absoluteY = canvasRect.top + point.y;\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(absoluteX, \"px;\\n          top: \").concat(absoluteY - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 9999;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                // STEP 7: Run 3-2-1 countdown (the dot stays visible during this time)\n                for(let count = 3; count > 0; count--){\n                    countdownElement.textContent = count;\n                    statusIndicator.textContent = \"Calibrate Set Active: countdown \".concat(count, \" (\").concat(i + 1, \"/\").concat(points.length, \")\");\n                    // Wait for next countdown step\n                    await new Promise((resolve)=>setTimeout(resolve, 800));\n                }\n                // STEP 8: Show capturing indicator\n                countdownElement.textContent = \"✓\";\n                statusIndicator.textContent = \"Capturing point \".concat(i + 1, \"/\").concat(points.length);\n                // STEP 9: Remove countdown element but KEEP the dot visible\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                }, 300);\n                // STEP 10: Capture images (the dot is still visible)\n                await captureImage();\n                // STEP 11: Wait for preview to complete before moving to next point\n                // During this time, the dot remains visible\n                await new Promise((resolve)=>setTimeout(resolve, 2300));\n            }\n            // STEP 12: Calibration complete\n            statusIndicator.textContent = 'Calibration completed';\n            setProcessStatus('Calibration completed');\n            if (onStatusUpdate) {\n                onStatusUpdate('Calibration completed successfully');\n            }\n            setRemainingCaptures(0);\n            // Remove status indicator after a delay\n            setTimeout(()=>{\n                if (statusIndicator.parentNode) {\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Calibration error:', error);\n            setProcessStatus(\"Error: \".concat(error.message));\n            if (onStatusUpdate) {\n                onStatusUpdate(\"Calibration error: \".concat(error.message));\n            }\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }\n    };\n    // Map button clicks to appropriate handlers\n    const handleScreenAction = (actionType)=>{\n        console.log(\"Screen action received: \".concat(actionType));\n        switch(actionType){\n            case 'randomDot':\n                handleRandomDot();\n                break;\n            case 'setRandom':\n                handleSetRandom();\n                break;\n            case 'calibrate':\n                handleSetCalibrate();\n                break;\n            case 'clearAll':\n                clearCanvas();\n                break;\n            default:\n                // Forward to parent if not handled here\n                if (onButtonClick) {\n                    onButtonClick(actionType);\n                }\n        }\n    };\n    // Register action handlers with parent component\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            // Skip during SSR\n            if (false) {}\n            console.log(\"Registering action handlers with parent\");\n            if (onButtonClick) {\n                // Create action handlers\n                const actionHandlers = {\n                    randomDot: handleRandomDot,\n                    setRandom: handleSetRandom,\n                    calibrate: handleSetCalibrate,\n                    clearAll: clearCanvas\n                };\n                // Store in parent component context\n                onButtonClick('registerActions', actionHandlers);\n                // Also make them globally available for direct access\n                window.whiteScreenActions = actionHandlers;\n            }\n            // Cleanup on unmount\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    if ( true && window.whiteScreenActions) {\n                        window.whiteScreenActions = null;\n                    }\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        onButtonClick\n    ]);\n    // Update parent with status changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            if (onStatusUpdate && processStatus) {\n                onStatusUpdate(processStatus);\n            }\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        processStatus,\n        onStatusUpdate\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"white-screen-container\",\n        style: {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            zIndex: 50,\n            backgroundColor: 'rgba(255, 255, 255, 0.5)' // Slight transparency to see if it's rendered\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"white-screen-canvas-container\",\n            style: {\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                backgroundColor: 'white',\n                overflow: 'hidden',\n                border: '1px solid #ccc',\n                zIndex: 51\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                    ref: canvasRef ? canvasRef : internalCanvasRef,\n                    className: \"white-screen-canvas\",\n                    style: {\n                        width: '100%',\n                        height: '100%',\n                        display: 'block'\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 732,\n                    columnNumber: 9\n                }, undefined),\n                (countdownValue !== null || forceShowCountdown) && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dot-countdown\",\n                    style: {\n                        position: 'absolute',\n                        left: \"\".concat(currentDot.x - 30, \"px\"),\n                        top: \"\".concat(currentDot.y - 70, \"px\"),\n                        color: 'red',\n                        fontSize: '48px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 10px white, 0 0 20px white',\n                        zIndex: 999,\n                        backgroundColor: 'rgba(255, 255, 255, 0.8)',\n                        padding: '10px 20px',\n                        borderRadius: '50%',\n                        boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)',\n                        width: '60px',\n                        height: '60px',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        border: '2px solid red' // Border to make it stand out\n                    },\n                    children: countdownValue || 3\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 744,\n                    columnNumber: 11\n                }, undefined),\n                (countdownValue !== null || forceShowCountdown) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"center-countdown-backup\",\n                    style: {\n                        position: 'fixed',\n                        top: '50%',\n                        left: '50%',\n                        transform: 'translate(-50%, -50%)',\n                        color: 'white',\n                        fontSize: '120px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 20px black',\n                        zIndex: 1000,\n                        backgroundColor: 'rgba(255, 0, 0, 0.7)',\n                        width: '200px',\n                        height: '200px',\n                        borderRadius: '50%',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        boxShadow: '0 0 30px rgba(0, 0, 0, 0.5)'\n                    },\n                    children: countdownValue || 3\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 773,\n                    columnNumber: 11\n                }, undefined),\n                currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dot-indicator\",\n                    style: {\n                        position: 'absolute',\n                        top: '10px',\n                        right: '10px',\n                        backgroundColor: 'rgba(0, 255, 0, 0.7)',\n                        color: 'black',\n                        padding: '5px 10px',\n                        borderRadius: '4px',\n                        fontSize: '12px',\n                        zIndex: 52\n                    },\n                    children: [\n                        \"Dot at x:\",\n                        currentDot.x,\n                        \", y:\",\n                        currentDot.y\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 801,\n                    columnNumber: 11\n                }, undefined),\n                (processStatus || remainingCaptures > 0) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"status-overlay\",\n                    style: {\n                        position: 'absolute',\n                        bottom: '10px',\n                        left: '10px',\n                        backgroundColor: 'rgba(0, 0, 0, 0.8)',\n                        color: 'white',\n                        padding: '10px 15px',\n                        borderRadius: '4px',\n                        fontSize: '16px',\n                        fontWeight: 'bold',\n                        boxShadow: '0 4px 8px rgba(0,0,0,0.3)',\n                        zIndex: 53\n                    },\n                    children: [\n                        processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: processStatus\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                            lineNumber: 837,\n                            columnNumber: 31\n                        }, undefined),\n                        remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                color: '#ffcc00'\n                            },\n                            children: [\n                                \"Remaining: \",\n                                remainingCaptures\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                            lineNumber: 839,\n                            columnNumber: 15\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 821,\n                    columnNumber: 11\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"canvas-indicator\",\n                    style: {\n                        position: 'absolute',\n                        top: '10px',\n                        left: '10px',\n                        backgroundColor: canvasVisible ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)',\n                        color: 'black',\n                        padding: '5px 10px',\n                        borderRadius: '4px',\n                        fontSize: '12px',\n                        zIndex: 52\n                    },\n                    children: [\n                        \"Canvas: \",\n                        canvasVisible ? 'Visible' : 'Hidden'\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 847,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n            lineNumber: 717,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n        lineNumber: 707,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WhiteScreenMain, \"PJgnBwbb+MxFn3w9CaII6BOFoCc=\");\n_c = WhiteScreenMain;\n// Export a dynamic version with SSR disabled to avoid useLayoutEffect warnings\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_c2 = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c1 = ()=>Promise.resolve(WhiteScreenMain), {\n    ssr: false\n}));\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"WhiteScreenMain\");\n$RefreshReg$(_c1, \"%default%$dynamic\");\n$RefreshReg$(_c2, \"%default%\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL1doaXRlU2NyZWVuTWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLG9DQUFvQzs7O0FBQ3VCO0FBQ3hCO0FBRW5DLGtDQUFrQztBQVFOO0FBRTVCLGdEQUFnRDtBQUNoRCxNQUFNVyxrQkFBa0I7UUFBQyxFQUN2QkMsY0FBYyxFQUNkQyxtQkFBbUIsRUFDbkJDLGFBQWEsRUFDYkMsWUFBWSxJQUFJLEVBQ2hCQyxZQUFZLEVBQ2I7O0lBQ0MsNkNBQTZDO0lBQzdDLE1BQU1DLG9CQUFvQmQsNkNBQU1BLENBQUM7SUFDakMsTUFBTWUsa0JBQWtCSCxhQUFhRTtJQUVyQyxvQkFBb0I7SUFDcEIsTUFBTSxDQUFDRSxZQUFZQyxjQUFjLEdBQUduQiwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUNvQixhQUFhQyxlQUFlLEdBQUdyQiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNzQixnQkFBZ0JDLGtCQUFrQixHQUFHdkIsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDd0IsbUJBQW1CQyxxQkFBcUIsR0FBR3pCLCtDQUFRQSxDQUFDO0lBQzNELE1BQU0sQ0FBQzBCLGVBQWVDLGlCQUFpQixHQUFHM0IsK0NBQVFBLENBQUM7SUFFbkQsd0JBQXdCO0lBQ3hCLE1BQU0sQ0FBQzRCLGdCQUFnQkMsa0JBQWtCLEdBQUc3QiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNLENBQUM4QixjQUFjLEdBQUc5QiwrQ0FBUUEsQ0FBQywwQkFBMEIsb0JBQW9CO0lBRS9FLHNCQUFzQjtJQUN0QixNQUFNLENBQUMrQixhQUFhQyxlQUFlLEdBQUdoQywrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNpQyxjQUFjQyxnQkFBZ0IsR0FBR2xDLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ21DLG1CQUFtQkMscUJBQXFCLEdBQUdwQywrQ0FBUUEsQ0FBQyxFQUFFO0lBQzdELE1BQU0sQ0FBQ3FDLHlCQUF5QkMsMkJBQTJCLEdBQUd0QywrQ0FBUUEsQ0FBQztJQUV2RSxpREFBaUQ7SUFDakQsTUFBTSxDQUFDdUMsZUFBZUMsaUJBQWlCLEdBQUd4QywrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUN5QyxvQkFBb0JDLHNCQUFzQixHQUFHMUMsK0NBQVFBLENBQUM7SUFFN0Qsc0NBQXNDO0lBQ3RDQyxnREFBU0E7cUNBQUM7WUFDUiwrQkFBK0I7WUFDL0IsSUFBSSxLQUE2QixFQUFFLEVBQU87WUFFMUMsTUFBTTBDLFNBQVMxQixnQkFBZ0IyQixPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsUUFBUTtnQkFDWEUsUUFBUUMsS0FBSyxDQUFDO2dCQUNkO1lBQ0Y7WUFFQUQsUUFBUUUsR0FBRyxDQUFDLCtCQUErQjtnQkFDekNDLFdBQVcsQ0FBQyxDQUFDTDtnQkFDYk0sY0FBY04sT0FBT08sTUFBTTtnQkFDM0JDLGFBQWFSLE9BQU9TLEtBQUs7WUFDM0I7WUFFQSx1Q0FBdUM7WUFDdkMsTUFBTUM7OERBQW1CO29CQUN2QixNQUFNQyxTQUFTWCxPQUFPWSxhQUFhO29CQUNuQyxJQUFJLENBQUNELFFBQVE7d0JBQ1hULFFBQVFDLEtBQUssQ0FBQzt3QkFDZDtvQkFDRjtvQkFFQSxzQ0FBc0M7b0JBQ3RDLE1BQU1VLGNBQWNGLE9BQU9HLFdBQVc7b0JBQ3RDLE1BQU1DLGVBQWVKLE9BQU9LLFlBQVk7b0JBRXhDZCxRQUFRRSxHQUFHLENBQUMsdUJBQXVCO3dCQUFFUzt3QkFBYUU7b0JBQWE7b0JBRS9EZixPQUFPUyxLQUFLLEdBQUdJO29CQUNmYixPQUFPTyxNQUFNLEdBQUdRO29CQUVoQixzQ0FBc0M7b0JBQ3RDLE1BQU1FLE1BQU1qQixPQUFPa0IsVUFBVSxDQUFDO29CQUM5QkQsSUFBSUUsU0FBUyxHQUFHO29CQUNoQkYsSUFBSUcsUUFBUSxDQUFDLEdBQUcsR0FBR3BCLE9BQU9TLEtBQUssRUFBRVQsT0FBT08sTUFBTTtvQkFFOUMsK0JBQStCO29CQUMvQixJQUFJaEMsWUFBWTt3QkFDZDJCLFFBQVFFLEdBQUcsQ0FBQywrQkFBK0I3Qjt3QkFDM0M4QyxRQUFROUMsV0FBVytDLENBQUMsRUFBRS9DLFdBQVdnRCxDQUFDLEVBQUUsT0FBTztvQkFDN0M7b0JBRUExQixpQkFBaUI7Z0JBQ25COztZQUVBLGlCQUFpQjtZQUNqQmE7WUFFQSwyQkFBMkI7WUFDM0JjLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVmO1lBRWxDLFdBQVc7WUFDWDs2Q0FBTztvQkFDTGMsT0FBT0UsbUJBQW1CLENBQUMsVUFBVWhCO2dCQUN2Qzs7UUFDRjtvQ0FBRztRQUFDcEM7UUFBaUJDO0tBQVc7SUFFaEMsMkJBQTJCO0lBQzNCLE1BQU04QyxVQUFVLFNBQUNDLEdBQUdDO1lBQUdJLHlFQUFRLE9BQU9DLDBFQUFTO1FBQzdDMUIsUUFBUUUsR0FBRyxDQUFDLG1CQUFtQjtZQUFFa0I7WUFBR0M7WUFBR0k7WUFBT0M7UUFBTztRQUVyRCxNQUFNNUIsU0FBUzFCLGdCQUFnQjJCLE9BQU87UUFDdEMsSUFBSSxDQUFDRCxRQUFRO1lBQ1hFLFFBQVFDLEtBQUssQ0FBQztZQUNkLE9BQU87UUFDVDtRQUVBLE1BQU1jLE1BQU1qQixPQUFPa0IsVUFBVSxDQUFDO1FBRTlCLGVBQWU7UUFDZkQsSUFBSVksU0FBUyxDQUFDLEdBQUcsR0FBRzdCLE9BQU9TLEtBQUssRUFBRVQsT0FBT08sTUFBTTtRQUMvQ1UsSUFBSUUsU0FBUyxHQUFHO1FBQ2hCRixJQUFJRyxRQUFRLENBQUMsR0FBRyxHQUFHcEIsT0FBT1MsS0FBSyxFQUFFVCxPQUFPTyxNQUFNO1FBRTlDLDRCQUE0QjtRQUM1QlUsSUFBSWEsU0FBUztRQUNiYixJQUFJYyxHQUFHLENBQUNULEdBQUdDLEdBQUdLLFFBQVEsR0FBR0ksS0FBS0MsRUFBRSxHQUFHO1FBQ25DaEIsSUFBSUUsU0FBUyxHQUFHUTtRQUNoQlYsSUFBSWlCLElBQUk7UUFFUixrQkFBa0I7UUFDbEJqQixJQUFJYSxTQUFTO1FBQ2JiLElBQUljLEdBQUcsQ0FBQ1QsR0FBR0MsR0FBR0ssU0FBUyxHQUFHLEdBQUdJLEtBQUtDLEVBQUUsR0FBRyxJQUFJLGlCQUFpQjtRQUM1RGhCLElBQUlrQixXQUFXLEdBQUcsd0JBQXdCLG9CQUFvQjtRQUM5RGxCLElBQUltQixTQUFTLEdBQUcsR0FBRyxlQUFlO1FBQ2xDbkIsSUFBSW9CLE1BQU07UUFFVix3RUFBd0U7UUFDeEU3RCxjQUFjOEQsQ0FBQUE7WUFDWnBDLFFBQVFFLEdBQUcsQ0FBQyxtQ0FBbUNrQyxNQUFNLE9BQU87Z0JBQUVoQjtnQkFBR0M7WUFBRTtZQUNuRSxPQUFPO2dCQUFFRDtnQkFBR0M7WUFBRTtRQUNoQjtRQUVBLE9BQU87WUFBRUQ7WUFBR0M7UUFBRTtJQUNoQjtJQUVBLG1CQUFtQjtJQUNuQixNQUFNZ0IsY0FBYztRQUNsQnJDLFFBQVFFLEdBQUcsQ0FBQztRQUVaLE1BQU1KLFNBQVMxQixnQkFBZ0IyQixPQUFPO1FBQ3RDLElBQUksQ0FBQ0QsUUFBUTtZQUNYRSxRQUFRQyxLQUFLLENBQUM7WUFDZDtRQUNGO1FBRUEsTUFBTWMsTUFBTWpCLE9BQU9rQixVQUFVLENBQUM7UUFDOUJELElBQUlZLFNBQVMsQ0FBQyxHQUFHLEdBQUc3QixPQUFPUyxLQUFLLEVBQUVULE9BQU9PLE1BQU07UUFDL0NVLElBQUlFLFNBQVMsR0FBRztRQUNoQkYsSUFBSUcsUUFBUSxDQUFDLEdBQUcsR0FBR3BCLE9BQU9TLEtBQUssRUFBRVQsT0FBT08sTUFBTTtRQUU5Qy9CLGNBQWM7UUFDZEksa0JBQWtCO1FBQ2xCbUIsc0JBQXNCO1FBQ3RCZixpQkFBaUI7UUFFakIsa0NBQWtDO1FBQ2xDd0QsV0FBVztZQUNUeEQsaUJBQWlCO1FBQ25CLEdBQUc7SUFDTDtJQUVBLDhCQUE4QjtJQUM5QixNQUFNeUQsb0JBQW9CLE9BQU9DLFdBQVdDLFVBQVVDO1FBQ3BELElBQUk7WUFDRjFDLFFBQVFFLEdBQUcsQ0FBQyxzQkFBcUN1QyxPQUFmQyxNQUFLLFlBQW1CLE9BQVREO1lBRWpELE1BQU1FLFdBQVcsTUFBTUMsTUFBTSxxQkFBcUI7Z0JBQ2hEQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFDbkJUO29CQUNBQztvQkFDQUM7b0JBQ0FRLFFBQVFqRTtnQkFDVjtZQUNGO1lBRUEsSUFBSSxDQUFDMEQsU0FBU1EsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUlDLE1BQU0seUJBQXlDLE9BQWhCVCxTQUFTVSxNQUFNO1lBQzFEO1lBRUEsTUFBTUMsU0FBUyxNQUFNWCxTQUFTWSxJQUFJO1lBQ2xDdkQsUUFBUUUsR0FBRyxDQUFDLFNBQWMsT0FBTHdDLE1BQUssWUFBVVk7WUFFcEMsaUVBQWlFO1lBQ2pFLElBQUlBLE9BQU9FLGFBQWEsRUFBRTtnQkFDeEJ4RSxrQkFBa0JzRSxPQUFPRSxhQUFhLEdBQUc7WUFDM0M7WUFFQSxPQUFPRjtRQUNULEVBQUUsT0FBT3JELE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLGdCQUFxQixPQUFMeUMsTUFBSyxZQUFVekM7WUFDN0MsTUFBTUE7UUFDUjtJQUNGO0lBRUEsdURBQXVEO0lBQ3ZELE1BQU13RCxlQUFlO1FBQ25CekQsUUFBUUUsR0FBRyxDQUFDO1FBQ1oxQixlQUFlO1FBRWYsSUFBSTtZQUNGLGtDQUFrQztZQUNsQyxNQUFNa0YsZ0JBQWdCLE1BQU0vRixnRUFBYUEsQ0FBQztnQkFDeENNLFdBQVdHO2dCQUNYdUYsVUFBVXRGO2dCQUNWVTtnQkFDQXdEO2dCQUNBdkQ7Z0JBQ0FGO2dCQUNBWjtnQkFDQWUsZUFBZTtZQUNqQjtZQUVBLHlDQUF5QztZQUN6Q3JCLHFFQUFrQkEsQ0FDaEI4RixjQUFjRSxXQUFXLEVBQ3pCRixjQUFjRyxXQUFXLEVBQ3pCeEY7WUFHRixnQkFBZ0I7WUFDaEJHLGVBQWU7WUFDZk0saUJBQWlCLGtDQUEyQlQsdUJBQUFBLGlDQUFBQSxXQUFZK0MsQ0FBQyxFQUFDLFFBQW9CLE9BQWQvQyx1QkFBQUEsaUNBQUFBLFdBQVlnRCxDQUFDO1lBRTdFLDBCQUEwQjtZQUMxQixJQUFJdkQsZ0JBQWdCO2dCQUNsQkEsZUFBZSw0Q0FBMkQsT0FBZmlCO1lBQzdEO1lBRUEscUVBQXFFO1lBQ3JFdUQsV0FBVztnQkFDVHRDLFFBQVFFLEdBQUcsQ0FBQztnQkFDWixJQUFJLE9BQU9oQyxpQkFBaUIsWUFBWTtvQkFDdENBLGFBQWE7Z0JBQ2YsT0FBTyxJQUFJLEtBQTZCLElBQUlvRCxPQUFPcEQsWUFBWSxFQUFFO29CQUMvRG9ELE9BQU9wRCxZQUFZLENBQUM7Z0JBQ3RCO1lBQ0YsR0FBRztRQUNMLEVBQUUsT0FBTytCLE9BQU87WUFDZEQsUUFBUUMsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkN6QixlQUFlO1lBQ2ZNLGlCQUFpQiw2QkFBNkJtQixNQUFNNkQsT0FBTztRQUM3RDtRQUVBLDZCQUE2QjtRQUM3QnhCLFdBQVc7WUFDVHhELGlCQUFpQjtRQUNuQixHQUFHO0lBQ0w7SUFFQSxvQkFBb0I7SUFDcEIsTUFBTWlGLGtCQUFrQjtRQUN0QixxQ0FBcUM7UUFDckMsSUFBSSxPQUFPN0YsaUJBQWlCLFlBQVk7WUFDdENBLGFBQWE7UUFDZixPQUFPLElBQUksS0FBNkIsSUFBSW9ELE9BQU9wRCxZQUFZLEVBQUU7WUFDL0RBLGFBQWE7UUFDZjtRQUVBTSxlQUFlO1FBQ2ZNLGlCQUFpQjtRQUVqQixvQ0FBb0M7UUFDcEN3RCxXQUFXO1lBQ1QsTUFBTXhDLFNBQVMxQixnQkFBZ0IyQixPQUFPO1lBQ3RDLElBQUlELFFBQVE7Z0JBQ1YsK0NBQStDO2dCQUMvQyxNQUFNVyxTQUFTWCxPQUFPWSxhQUFhO2dCQUNuQ2hELG1FQUFnQkEsQ0FBQ29DLFFBQVFXO2dCQUV6QiwyQkFBMkI7Z0JBQzNCLE1BQU1rRCxXQUFXcEcsb0VBQWlCQSxDQUFDdUM7Z0JBRW5DLGVBQWU7Z0JBQ2YsTUFBTWlCLE1BQU1qQixPQUFPa0IsVUFBVSxDQUFDO2dCQUM5QnhELDZEQUFVQSxDQUFDdUQsS0FBSzRDLFNBQVN2QyxDQUFDLEVBQUV1QyxTQUFTdEMsQ0FBQztnQkFFdEMsc0NBQXNDO2dCQUN0Qy9DLGNBQWNxRjtnQkFFZCxJQUFJO29CQUNGLDZDQUE2QztvQkFDN0MsTUFBTWxHLDJFQUF3QkEsQ0FBQzt3QkFDN0JRLFdBQVdHO3dCQUNYdUY7d0JBQ0E1RTt3QkFDQXdEO3dCQUNBdkQ7d0JBQ0FGO3dCQUNBWjt3QkFDQUosZ0JBQWdCLENBQUN1Rjs0QkFDZixJQUFJdkYsZ0JBQWdCO2dDQUNsQkEsZUFBZXVGOzRCQUNqQjt3QkFDRjt3QkFDQXBFLGVBQWU7b0JBQ2pCO29CQUVBLDZDQUE2QztvQkFDN0NxRCxXQUFXO3dCQUNUOUQsZUFBZTtvQkFDakIsR0FBRztnQkFDTCxFQUFFLE9BQU95QixPQUFPO29CQUNkRCxRQUFRQyxLQUFLLENBQUMseUNBQXlDQTtvQkFDdkR6QixlQUFlO29CQUNmTSxpQkFBaUIsNkJBQTZCbUIsTUFBTTZELE9BQU87b0JBRTNELG9DQUFvQztvQkFDcEN4QixXQUFXO3dCQUNUeEQsaUJBQWlCO29CQUNuQixHQUFHO2dCQUNMO1lBQ0Y7UUFDRixHQUFHO0lBQ0w7SUFFQSwwRUFBMEU7SUFDMUUsTUFBTWtGLGtCQUFrQjtRQUN0QixJQUFJekYsYUFBYTtRQUVqQiwrQ0FBK0M7UUFDL0MsTUFBTTBGLFFBQVFDLFNBQVNoRixnQkFBZ0I7UUFDdkMsTUFBTWlGLFFBQVFELFNBQVM5RSxpQkFBaUI7UUFFeEMsSUFBSTZFLFNBQVMsS0FBS0UsU0FBUyxHQUFHO1lBQzVCckYsaUJBQWlCO1lBQ2pCO1FBQ0Y7UUFFQU4sZUFBZTtRQUNmSSxxQkFBcUJxRjtRQUNyQm5GLGlCQUFpQixZQUFrQixPQUFObUYsT0FBTTtRQUVuQyxpQkFBaUI7UUFDakJHLHVCQUF1QkgsT0FBT0EsT0FBT0U7SUFDdkM7SUFFQSxnRUFBZ0U7SUFDaEUsTUFBTUMseUJBQXlCLENBQUNDLFdBQVdDLE9BQU9IO1FBQ2hELElBQUlFLGFBQWEsR0FBRztZQUNsQjdGLGVBQWU7WUFDZkkscUJBQXFCO1lBQ3JCRSxpQkFBaUI7WUFFakIsNkJBQTZCO1lBQzdCd0QsV0FBVztnQkFDVHhELGlCQUFpQjtZQUNuQixHQUFHO1lBRUg7UUFDRjtRQUVBRixxQkFBcUJ5RjtRQUNyQnZGLGlCQUFpQixXQUF1Q3dGLE9BQTVCQSxRQUFRRCxZQUFZLEdBQUUsUUFBWSxPQUFOQztRQUV4RCxvQ0FBb0M7UUFDcEMsTUFBTXhFLFNBQVMxQixnQkFBZ0IyQixPQUFPO1FBQ3RDLE1BQU1nQixNQUFNakIsT0FBT2tCLFVBQVUsQ0FBQztRQUM5QixNQUFNMkMsV0FBV3BHLG9FQUFpQkEsQ0FBQ3VDO1FBQ25DdEMsNkRBQVVBLENBQUN1RCxLQUFLNEMsU0FBU3ZDLENBQUMsRUFBRXVDLFNBQVN0QyxDQUFDO1FBQ3RDL0MsY0FBY3FGO1FBRWQseUNBQXlDO1FBQ3pDbEcsMkVBQXdCQSxDQUFDO1lBQ3ZCUSxXQUFXRztZQUNYdUY7WUFDQTVFO1lBQ0F3RDtZQUNBdkQ7WUFDQUY7WUFDQVo7WUFDQUosZ0JBQWdCLENBQUN1RjtnQkFDZixJQUFJdkYsZ0JBQWdCO29CQUNsQkEsZUFBZXVGO2dCQUNqQjtZQUNGO1lBQ0FwRSxlQUFlO1FBQ2pCLEdBQUdzRixJQUFJLENBQUM7WUFDTix3QkFBd0I7WUFDeEJqQyxXQUFXO2dCQUNUOEIsdUJBQXVCQyxZQUFZLEdBQUdDLE9BQU9IO1lBQy9DLEdBQUdBLFFBQVE7UUFDYixHQUFHSyxLQUFLLENBQUN2RSxDQUFBQTtZQUNQRCxRQUFRQyxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5Q3pCLGVBQWU7WUFDZk0saUJBQWlCLFlBQVltQixNQUFNNkQsT0FBTztZQUUxQyxvQ0FBb0M7WUFDcEN4QixXQUFXO2dCQUNUeEQsaUJBQWlCO1lBQ25CLEdBQUc7UUFDTDtJQUNGO0lBRUEseURBQXlEO0lBQ3pELE1BQU0yRiw0QkFBNEIsQ0FBQ2xFLE9BQU9GO1FBQ3hDLElBQUksQ0FBQ0UsU0FBUyxDQUFDRixVQUFVRSxTQUFTLEtBQUtGLFVBQVUsR0FBRztZQUNsREwsUUFBUUMsS0FBSyxDQUFDLHdEQUF3RDtnQkFBRU07Z0JBQU9GO1lBQU87WUFDdEYsT0FBTyxFQUFFO1FBQ1g7UUFFQSxNQUFNcUUsbUJBQW1CLENBQUNDLFdBQVdDLGFBQWU5QyxLQUFLK0MsS0FBSyxDQUFDRixZQUFZQztRQUUzRSwrQkFBK0I7UUFDL0IsTUFBTUUsYUFBYUosaUJBQWlCbkUsT0FBTztRQUMzQyxNQUFNd0UsY0FBY3hFLFFBQVF1RTtRQUM1QixNQUFNRSxZQUFZTixpQkFBaUJyRSxRQUFRO1FBQzNDLE1BQU00RSxlQUFlNUUsU0FBUzJFO1FBRTlCLCtCQUErQjtRQUMvQixNQUFNRSxhQUFhUixpQkFBaUJuRSxPQUFPO1FBQzNDLE1BQU00RSxjQUFjNUUsUUFBUTJFO1FBQzVCLE1BQU1FLFlBQVlWLGlCQUFpQnJFLFFBQVE7UUFDM0MsTUFBTWdGLGVBQWVoRixTQUFTK0U7UUFFOUIsTUFBTUUsVUFBVXhELEtBQUt5RCxLQUFLLENBQUNoRixRQUFRO1FBQ25DLE1BQU1pRixVQUFVMUQsS0FBS3lELEtBQUssQ0FBQ2xGLFNBQVM7UUFFcEMsT0FBTztZQUNMLHlCQUF5QjtZQUN6QjtnQkFBRWUsR0FBRzBEO2dCQUFZekQsR0FBRzJEO2dCQUFXUyxPQUFPO1lBQWlCO1lBQ3ZEO2dCQUFFckUsR0FBR2tFO2dCQUFTakUsR0FBRzJEO2dCQUFXUyxPQUFPO1lBQW1CO1lBQ3REO2dCQUFFckUsR0FBRzJEO2dCQUFhMUQsR0FBRzJEO2dCQUFXUyxPQUFPO1lBQWtCO1lBQ3pEO2dCQUFFckUsR0FBRzBEO2dCQUFZekQsR0FBR21FO2dCQUFTQyxPQUFPO1lBQW9CO1lBQ3hEO2dCQUFFckUsR0FBRzJEO2dCQUFhMUQsR0FBR21FO2dCQUFTQyxPQUFPO1lBQXFCO1lBQzFEO2dCQUFFckUsR0FBRzBEO2dCQUFZekQsR0FBRzREO2dCQUFjUSxPQUFPO1lBQW9CO1lBQzdEO2dCQUFFckUsR0FBR2tFO2dCQUFTakUsR0FBRzREO2dCQUFjUSxPQUFPO1lBQXNCO1lBQzVEO2dCQUFFckUsR0FBRzJEO2dCQUFhMUQsR0FBRzREO2dCQUFjUSxPQUFPO1lBQXFCO1lBRS9ELHlCQUF5QjtZQUN6QjtnQkFBRXJFLEdBQUc4RDtnQkFBWTdELEdBQUcrRDtnQkFBV0ssT0FBTztZQUFpQjtZQUN2RDtnQkFBRXJFLEdBQUdrRTtnQkFBU2pFLEdBQUcrRDtnQkFBV0ssT0FBTztZQUFtQjtZQUN0RDtnQkFBRXJFLEdBQUcrRDtnQkFBYTlELEdBQUcrRDtnQkFBV0ssT0FBTztZQUFrQjtZQUN6RDtnQkFBRXJFLEdBQUc4RDtnQkFBWTdELEdBQUdtRTtnQkFBU0MsT0FBTztZQUFvQjtZQUN4RDtnQkFBRXJFLEdBQUcrRDtnQkFBYTlELEdBQUdtRTtnQkFBU0MsT0FBTztZQUFxQjtZQUMxRDtnQkFBRXJFLEdBQUc4RDtnQkFBWTdELEdBQUdnRTtnQkFBY0ksT0FBTztZQUFvQjtZQUM3RDtnQkFBRXJFLEdBQUdrRTtnQkFBU2pFLEdBQUdnRTtnQkFBY0ksT0FBTztZQUFzQjtZQUM1RDtnQkFBRXJFLEdBQUcrRDtnQkFBYTlELEdBQUdnRTtnQkFBY0ksT0FBTztZQUFxQjtTQUNoRTtJQUNIO0lBRUEsOEJBQThCO0lBQzlCLE1BQU1DLHFCQUFxQjtRQUN6QixJQUFJO1lBQ0Ysc0VBQXNFO1lBQ3RFLElBQUksT0FBT3hILGlCQUFpQixZQUFZO2dCQUN0Q0EsYUFBYTtZQUNmLE9BQU8sSUFBSSxLQUE2QixJQUFJb0QsT0FBT3BELFlBQVksRUFBRTtnQkFDL0RvRCxPQUFPcEQsWUFBWSxDQUFDO1lBQ3RCO1lBRUEseUNBQXlDO1lBQ3pDLE1BQU0sSUFBSXlILFFBQVFDLENBQUFBLFVBQVd0RCxXQUFXc0QsU0FBUztZQUVqRCx3QkFBd0I7WUFDeEJwSCxlQUFlO1lBQ2ZNLGlCQUFpQjtZQUVqQixJQUFJaEIsZ0JBQWdCO2dCQUNsQkEsZUFBZTtvQkFDYmUsZUFBZTtvQkFDZk4sYUFBYTtnQkFDZjtZQUNGO1lBRUEsNEJBQTRCO1lBQzVCLE1BQU1zSCxrQkFBa0JDLFNBQVNDLGFBQWEsQ0FBQztZQUMvQ0YsZ0JBQWdCRyxTQUFTLEdBQUc7WUFDNUJILGdCQUFnQkksS0FBSyxDQUFDQyxPQUFPLEdBQUk7WUFhakNMLGdCQUFnQk0sV0FBVyxHQUFHO1lBQzlCTCxTQUFTL0MsSUFBSSxDQUFDcUQsV0FBVyxDQUFDUDtZQUUxQiwyQ0FBMkM7WUFDM0MsTUFBTS9GLFNBQVMxQixnQkFBZ0IyQixPQUFPO1lBQ3RDLElBQUksQ0FBQ0QsUUFBUTtnQkFDWCxNQUFNLElBQUlzRCxNQUFNO1lBQ2xCO1lBRUEsbUNBQW1DO1lBQ25DLE1BQU0zQyxTQUFTWCxPQUFPWSxhQUFhO1lBQ25DLElBQUlELFFBQVE7Z0JBQ1ZYLE9BQU9TLEtBQUssR0FBR0UsT0FBT0csV0FBVztnQkFDakNkLE9BQU9PLE1BQU0sR0FBR0ksT0FBT0ssWUFBWTtZQUNyQztZQUVBZCxRQUFRRSxHQUFHLENBQUMsc0NBQXNDO2dCQUFFSyxPQUFPVCxPQUFPUyxLQUFLO2dCQUFFRixRQUFRUCxPQUFPTyxNQUFNO1lBQUM7WUFFL0YsMERBQTBEO1lBQzFELE1BQU1nRyxTQUFTNUIsMEJBQTBCM0UsT0FBT1MsS0FBSyxFQUFFVCxPQUFPTyxNQUFNO1lBQ3BFZCxxQkFBcUI4RztZQUVyQnJHLFFBQVFFLEdBQUcsQ0FBQyxhQUEyQixPQUFkbUcsT0FBT0MsTUFBTSxFQUFDO1lBRXZDLElBQUksQ0FBQ0QsVUFBVUEsT0FBT0MsTUFBTSxLQUFLLEdBQUc7Z0JBQ2xDLE1BQU0sSUFBSWxELE1BQU07WUFDbEI7WUFFQXhFLHFCQUFxQnlILE9BQU9DLE1BQU07WUFFbEMscURBQXFEO1lBQ3JELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixPQUFPQyxNQUFNLEVBQUVDLElBQUs7Z0JBQ3RDLGVBQWU7Z0JBQ2Y5RywyQkFBMkI4RztnQkFDM0IzSCxxQkFBcUJ5SCxPQUFPQyxNQUFNLEdBQUdDO2dCQUVyQyxnQkFBZ0I7Z0JBQ2hCLE1BQU1DLGFBQWEsZUFBd0JILE9BQVRFLElBQUksR0FBRSxLQUFpQixPQUFkRixPQUFPQyxNQUFNO2dCQUN4RHhILGlCQUFpQjBIO2dCQUNqQlgsZ0JBQWdCTSxXQUFXLEdBQUcsMENBQW1ERSxPQUFURSxJQUFJLEdBQUUsS0FBaUIsT0FBZEYsT0FBT0MsTUFBTTtnQkFFOUYsSUFBSXhJLGdCQUFnQjtvQkFDbEJBLGVBQWUwSTtnQkFDakI7Z0JBRUEsdURBQXVEO2dCQUN2RCxNQUFNQyxRQUFRSixNQUFNLENBQUNFLEVBQUU7Z0JBQ3ZCcEYsUUFBUXNGLE1BQU1yRixDQUFDLEVBQUVxRixNQUFNcEYsQ0FBQztnQkFFeEIseUNBQXlDO2dCQUN6QyxNQUFNLElBQUlzRSxRQUFRQyxDQUFBQSxVQUFXdEQsV0FBV3NELFNBQVM7Z0JBRWpELHVEQUF1RDtnQkFDdkQsTUFBTWMsYUFBYTVHLE9BQU82RyxxQkFBcUI7Z0JBRS9DLHlDQUF5QztnQkFDekMsTUFBTUMsbUJBQW1CZCxTQUFTQyxhQUFhLENBQUM7Z0JBQ2hEYSxpQkFBaUJaLFNBQVMsR0FBRztnQkFFN0IsNEJBQTRCO2dCQUM1QixNQUFNYSxZQUFZSCxXQUFXSSxJQUFJLEdBQUdMLE1BQU1yRixDQUFDO2dCQUMzQyxNQUFNMkYsWUFBWUwsV0FBV00sR0FBRyxHQUFHUCxNQUFNcEYsQ0FBQztnQkFFMUN1RixpQkFBaUJYLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLGlEQUd4QmEsT0FEQ0YsV0FBVSx3QkFDSSxPQUFmRSxZQUFZLElBQUc7Z0JBaUJ4QmpCLFNBQVMvQyxJQUFJLENBQUNxRCxXQUFXLENBQUNRO2dCQUUxQix1RUFBdUU7Z0JBQ3ZFLElBQUssSUFBSUssUUFBUSxHQUFHQSxRQUFRLEdBQUdBLFFBQVM7b0JBQ3RDTCxpQkFBaUJULFdBQVcsR0FBR2M7b0JBQy9CcEIsZ0JBQWdCTSxXQUFXLEdBQUcsbUNBQTZDSSxPQUFWVSxPQUFNLE1BQWFaLE9BQVRFLElBQUksR0FBRSxLQUFpQixPQUFkRixPQUFPQyxNQUFNLEVBQUM7b0JBRWxHLCtCQUErQjtvQkFDL0IsTUFBTSxJQUFJWCxRQUFRQyxDQUFBQSxVQUFXdEQsV0FBV3NELFNBQVM7Z0JBQ25EO2dCQUVBLG1DQUFtQztnQkFDbkNnQixpQkFBaUJULFdBQVcsR0FBRztnQkFDL0JOLGdCQUFnQk0sV0FBVyxHQUFHLG1CQUE0QkUsT0FBVEUsSUFBSSxHQUFFLEtBQWlCLE9BQWRGLE9BQU9DLE1BQU07Z0JBRXZFLDREQUE0RDtnQkFDNURoRSxXQUFXO29CQUNULElBQUlzRSxpQkFBaUJNLFVBQVUsRUFBRTt3QkFDL0JOLGlCQUFpQk0sVUFBVSxDQUFDQyxXQUFXLENBQUNQO29CQUMxQztnQkFDRixHQUFHO2dCQUVILHFEQUFxRDtnQkFDckQsTUFBTW5EO2dCQUVOLG9FQUFvRTtnQkFDcEUsNENBQTRDO2dCQUM1QyxNQUFNLElBQUlrQyxRQUFRQyxDQUFBQSxVQUFXdEQsV0FBV3NELFNBQVM7WUFDbkQ7WUFFQSxnQ0FBZ0M7WUFDaENDLGdCQUFnQk0sV0FBVyxHQUFHO1lBQzlCckgsaUJBQWlCO1lBQ2pCLElBQUloQixnQkFBZ0I7Z0JBQ2xCQSxlQUFlO1lBQ2pCO1lBRUFjLHFCQUFxQjtZQUVyQix3Q0FBd0M7WUFDeEMwRCxXQUFXO2dCQUNULElBQUl1RCxnQkFBZ0JxQixVQUFVLEVBQUU7b0JBQzlCckIsZ0JBQWdCcUIsVUFBVSxDQUFDQyxXQUFXLENBQUN0QjtnQkFDekM7WUFDRixHQUFHO1FBRUwsRUFBRSxPQUFPNUYsT0FBTztZQUNkRCxRQUFRQyxLQUFLLENBQUMsc0JBQXNCQTtZQUNwQ25CLGlCQUFpQixVQUF3QixPQUFkbUIsTUFBTTZELE9BQU87WUFDeEMsSUFBSWhHLGdCQUFnQjtnQkFDbEJBLGVBQWUsc0JBQW9DLE9BQWRtQyxNQUFNNkQsT0FBTztZQUNwRDtRQUNGLFNBQVU7WUFDUnRGLGVBQWU7WUFFZixvQkFBb0I7WUFDcEIsSUFBSSxPQUFPTixpQkFBaUIsWUFBWTtnQkFDdENBLGFBQWE7WUFDZixPQUFPLElBQUksS0FBNkIsSUFBSW9ELE9BQU9wRCxZQUFZLEVBQUU7Z0JBQy9Eb0QsT0FBT3BELFlBQVksQ0FBQztZQUN0QjtRQUNGO0lBQ0Y7SUFFQSw0Q0FBNEM7SUFDNUMsTUFBTWtKLHFCQUFxQixDQUFDQztRQUMxQnJILFFBQVFFLEdBQUcsQ0FBQywyQkFBc0MsT0FBWG1IO1FBRXZDLE9BQU9BO1lBQ0wsS0FBSztnQkFDSHREO2dCQUNBO1lBQ0YsS0FBSztnQkFDSEM7Z0JBQ0E7WUFDRixLQUFLO2dCQUNIMEI7Z0JBQ0E7WUFDRixLQUFLO2dCQUNIckQ7Z0JBQ0E7WUFDRjtnQkFDRSx3Q0FBd0M7Z0JBQ3hDLElBQUlyRSxlQUFlO29CQUNqQkEsY0FBY3FKO2dCQUNoQjtRQUNKO0lBQ0Y7SUFFQSxpREFBaUQ7SUFDakRqSyxnREFBU0E7cUNBQUM7WUFDUixrQkFBa0I7WUFDbEIsSUFBSSxLQUE2QixFQUFFLEVBQU87WUFFMUM0QyxRQUFRRSxHQUFHLENBQUM7WUFFWixJQUFJbEMsZUFBZTtnQkFDakIseUJBQXlCO2dCQUN6QixNQUFNc0osaUJBQWlCO29CQUNyQkMsV0FBV3hEO29CQUNYeUQsV0FBV3hEO29CQUNYeUQsV0FBVy9CO29CQUNYZ0MsVUFBVXJGO2dCQUNaO2dCQUVBLG9DQUFvQztnQkFDcENyRSxjQUFjLG1CQUFtQnNKO2dCQUVqQyxzREFBc0Q7Z0JBQ3REaEcsT0FBT3FHLGtCQUFrQixHQUFHTDtZQUM5QjtZQUVBLHFCQUFxQjtZQUNyQjs2Q0FBTztvQkFDTCxJQUFJLEtBQTZCLElBQUloRyxPQUFPcUcsa0JBQWtCLEVBQUU7d0JBQzlEckcsT0FBT3FHLGtCQUFrQixHQUFHO29CQUM5QjtnQkFDRjs7UUFDRjtvQ0FBRztRQUFDM0o7S0FBYztJQUVsQixvQ0FBb0M7SUFDcENaLGdEQUFTQTtxQ0FBQztZQUNSLElBQUlVLGtCQUFrQmUsZUFBZTtnQkFDbkNmLGVBQWVlO1lBQ2pCO1FBQ0Y7b0NBQUc7UUFBQ0E7UUFBZWY7S0FBZTtJQUVsQyxxQkFDRSw4REFBQzhKO1FBQUk1QixXQUFVO1FBQXlCQyxPQUFPO1lBQzdDdEMsVUFBVTtZQUNWcUQsS0FBSztZQUNMRixNQUFNO1lBQ052RyxPQUFPO1lBQ1BGLFFBQVE7WUFDUndILFFBQVE7WUFDUkMsaUJBQWlCLDJCQUEyQiw4Q0FBOEM7UUFDNUY7a0JBRUUsNEVBQUNGO1lBQ0M1QixXQUFVO1lBQ1ZDLE9BQU87Z0JBQ0x0QyxVQUFVO2dCQUNWcUQsS0FBSztnQkFDTEYsTUFBTTtnQkFDTnZHLE9BQU87Z0JBQ1BGLFFBQVE7Z0JBQ1J5SCxpQkFBaUI7Z0JBQ2pCQyxVQUFVO2dCQUNWQyxRQUFRO2dCQUNSSCxRQUFRO1lBQ1Y7OzhCQUdBLDhEQUFDL0g7b0JBQ0NtSSxLQUFLaEssWUFBWUEsWUFBWUU7b0JBQzdCNkgsV0FBVTtvQkFDVkMsT0FBTzt3QkFDTDFGLE9BQU87d0JBQ1BGLFFBQVE7d0JBQ1I2SCxTQUFTO29CQUNYOzs7Ozs7Z0JBSUF6SixDQUFBQSxtQkFBbUIsUUFBUW1CLGtCQUFpQixLQUFNdkIsNEJBQ2xELDhEQUFDdUo7b0JBQ0M1QixXQUFVO29CQUNWQyxPQUFPO3dCQUNMdEMsVUFBVTt3QkFDVm1ELE1BQU0sR0FBcUIsT0FBbEJ6SSxXQUFXK0MsQ0FBQyxHQUFHLElBQUc7d0JBQzNCNEYsS0FBSyxHQUFxQixPQUFsQjNJLFdBQVdnRCxDQUFDLEdBQUcsSUFBRzt3QkFDMUJJLE9BQU87d0JBQ1AwRyxVQUFVO3dCQUNWQyxZQUFZO3dCQUNaQyxZQUFZO3dCQUNaUixRQUFRO3dCQUNSQyxpQkFBaUI7d0JBQ2pCUSxTQUFTO3dCQUNUQyxjQUFjO3dCQUNkQyxXQUFXO3dCQUNYakksT0FBTzt3QkFDUEYsUUFBUTt3QkFDUjZILFNBQVM7d0JBQ1RPLGdCQUFnQjt3QkFDaEJDLFlBQVk7d0JBQ1pWLFFBQVEsZ0JBQWdCLDhCQUE4QjtvQkFDeEQ7OEJBRUN2SixrQkFBa0I7Ozs7OztnQkFLckJBLENBQUFBLG1CQUFtQixRQUFRbUIsa0JBQWlCLG1CQUM1Qyw4REFBQ2dJO29CQUNDNUIsV0FBVTtvQkFDVkMsT0FBTzt3QkFDTHRDLFVBQVU7d0JBQ1ZxRCxLQUFLO3dCQUNMRixNQUFNO3dCQUNONkIsV0FBVzt3QkFDWGxILE9BQU87d0JBQ1AwRyxVQUFVO3dCQUNWQyxZQUFZO3dCQUNaQyxZQUFZO3dCQUNaUixRQUFRO3dCQUNSQyxpQkFBaUI7d0JBQ2pCdkgsT0FBTzt3QkFDUEYsUUFBUTt3QkFDUmtJLGNBQWM7d0JBQ2RMLFNBQVM7d0JBQ1RPLGdCQUFnQjt3QkFDaEJDLFlBQVk7d0JBQ1pGLFdBQVc7b0JBQ2I7OEJBRUMvSixrQkFBa0I7Ozs7OztnQkFLdEJKLDRCQUNDLDhEQUFDdUo7b0JBQ0M1QixXQUFVO29CQUNWQyxPQUFPO3dCQUNMdEMsVUFBVTt3QkFDVnFELEtBQUs7d0JBQ0w0QixPQUFPO3dCQUNQZCxpQkFBaUI7d0JBQ2pCckcsT0FBTzt3QkFDUDZHLFNBQVM7d0JBQ1RDLGNBQWM7d0JBQ2RKLFVBQVU7d0JBQ1ZOLFFBQVE7b0JBQ1Y7O3dCQUNEO3dCQUNXeEosV0FBVytDLENBQUM7d0JBQUM7d0JBQUsvQyxXQUFXZ0QsQ0FBQzs7Ozs7OztnQkFLMUN4QyxDQUFBQSxpQkFBaUJGLG9CQUFvQixvQkFDckMsOERBQUNpSjtvQkFDQzVCLFdBQVU7b0JBQ1ZDLE9BQU87d0JBQ0x0QyxVQUFVO3dCQUNWa0YsUUFBUTt3QkFDUi9CLE1BQU07d0JBQ05nQixpQkFBaUI7d0JBQ2pCckcsT0FBTzt3QkFDUDZHLFNBQVM7d0JBQ1RDLGNBQWM7d0JBQ2RKLFVBQVU7d0JBQ1ZDLFlBQVk7d0JBQ1pJLFdBQVc7d0JBQ1hYLFFBQVE7b0JBQ1Y7O3dCQUVDaEosK0JBQWlCLDhEQUFDK0k7c0NBQUsvSTs7Ozs7O3dCQUN2QkYsb0JBQW9CLG1CQUNuQiw4REFBQ2lKOzRCQUFJM0IsT0FBTztnQ0FBRXhFLE9BQU87NEJBQVU7O2dDQUFHO2dDQUNwQjlDOzs7Ozs7Ozs7Ozs7OzhCQU9wQiw4REFBQ2lKO29CQUNDNUIsV0FBVTtvQkFDVkMsT0FBTzt3QkFDTHRDLFVBQVU7d0JBQ1ZxRCxLQUFLO3dCQUNMRixNQUFNO3dCQUNOZ0IsaUJBQWlCcEksZ0JBQWdCLHlCQUF5Qjt3QkFDMUQrQixPQUFPO3dCQUNQNkcsU0FBUzt3QkFDVEMsY0FBYzt3QkFDZEosVUFBVTt3QkFDVk4sUUFBUTtvQkFDVjs7d0JBQ0Q7d0JBQ1VuSSxnQkFBZ0IsWUFBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSy9DO0dBbDFCTTdCO0tBQUFBO0FBbzFCTiwrRUFBK0U7QUFDL0UsaUVBQWUsTUFBQVAsbURBQU9BLE9BQUMsSUFBTXFJLFFBQVFDLE9BQU8sQ0FBQy9ILGtCQUFrQjtJQUFFaUwsS0FBSztBQUFNLEVBQUUsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL1doaXRlU2NyZWVuTWFpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21wb25lbnRzLWd1aS9XaGl0ZVNjcmVlbk1haW4uanNcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuXG4vLyBJbXBvcnQgdGhlIHNoYXJlZCBmdW5jdGlvbmFsaXR5XG5pbXBvcnQgeyBcbiAgZ2V0UmFuZG9tUG9zaXRpb24sIFxuICBkcmF3UmVkRG90LCBcbiAgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzLFxuICBpbml0aWFsaXplQ2FudmFzLFxuICBjYXB0dXJlSW1hZ2VzLFxuICBzaG93Q2FwdHVyZVByZXZpZXdcbn0gZnJvbSAnLi9BY3Rpb24vY291bnRTYXZlJztcblxuLy8gQ3JlYXRlIGEgY2xpZW50LW9ubHkgdmVyc2lvbiBvZiB0aGUgY29tcG9uZW50XG5jb25zdCBXaGl0ZVNjcmVlbk1haW4gPSAoeyBcbiAgb25TdGF0dXNVcGRhdGUsIFxuICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICBvbkJ1dHRvbkNsaWNrLFxuICBjYW52YXNSZWYgPSBudWxsLFxuICB0b2dnbGVUb3BCYXJcbn0pID0+IHtcbiAgLy8gVXNlIHByb3ZpZGVkIGNhbnZhc1JlZiBvciBjcmVhdGUgYSBuZXcgb25lXG4gIGNvbnN0IGludGVybmFsQ2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBhY3RpdmVDYW52YXNSZWYgPSBjYW52YXNSZWYgfHwgaW50ZXJuYWxDYW52YXNSZWY7XG4gIFxuICAvLyBDdXJyZW50IGRvdCBzdGF0ZVxuICBjb25zdCBbY3VycmVudERvdCwgc2V0Q3VycmVudERvdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjb3VudGRvd25WYWx1ZSwgc2V0Q291bnRkb3duVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtyZW1haW5pbmdDYXB0dXJlcywgc2V0UmVtYWluaW5nQ2FwdHVyZXNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtwcm9jZXNzU3RhdHVzLCBzZXRQcm9jZXNzU3RhdHVzXSA9IHVzZVN0YXRlKCcnKTtcbiAgXG4gIC8vIFRyYWNrIGNhcHR1cmUgc2Vzc2lvblxuICBjb25zdCBbY2FwdHVyZUNvdW50ZXIsIHNldENhcHR1cmVDb3VudGVyXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbY2FwdHVyZUZvbGRlcl0gPSB1c2VTdGF0ZSgnZXllX3RyYWNraW5nX2NhcHR1cmVzJyk7IC8vIEZpeGVkIGZvbGRlciBuYW1lXG4gIFxuICAvLyBDb25maWd1cmF0aW9uIHN0YXRlXG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgW2NhbGlicmF0aW9uUG9pbnRzLCBzZXRDYWxpYnJhdGlvblBvaW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtjdXJyZW50Q2FsaWJyYXRpb25JbmRleCwgc2V0Q3VycmVudENhbGlicmF0aW9uSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gIFxuICAvLyBEZWJ1ZyBzdGF0ZSB0byBtYWtlIHZpc2liaWxpdHkgZWFzaWVyIHRvIHRyYWNrXG4gIGNvbnN0IFtjYW52YXNWaXNpYmxlLCBzZXRDYW52YXNWaXNpYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2ZvcmNlU2hvd0NvdW50ZG93biwgc2V0Rm9yY2VTaG93Q291bnRkb3duXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIC8vIFNldCB1cCBjYW52YXMgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU2tpcCBpZiB0aGlzIHJ1bnMgZHVyaW5nIFNTUlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZiBpcyBudWxsIGluIHNldHVwIGVmZmVjdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJDYW52YXMgc2V0dXAgZWZmZWN0IHJ1bm5pbmdcIiwgeyBcbiAgICAgIGhhc0NhbnZhczogISFjYW52YXMsIFxuICAgICAgY2FudmFzSGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgY2FudmFzV2lkdGg6IGNhbnZhcy53aWR0aFxuICAgIH0pO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjYW52YXMgZGltZW5zaW9uc1xuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcGFyZW50IGlzIG51bGxcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBwYXJlbnQgY29udGFpbmVyIGRpbWVuc2lvbnNcbiAgICAgIGNvbnN0IHBhcmVudFdpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgICAgY29uc3QgcGFyZW50SGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coXCJSZXNpemluZyBjYW52YXMgdG86XCIsIHsgcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodCB9KTtcbiAgICAgIFxuICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBDbGVhciB0aGUgY2FudmFzIGFuZCBzZXQgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBSZWRyYXcgY3VycmVudCBkb3QgaWYgZXhpc3RzXG4gICAgICBpZiAoY3VycmVudERvdCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlZHJhd2luZyBkb3QgYWZ0ZXIgcmVzaXplOlwiLCBjdXJyZW50RG90KTtcbiAgICAgICAgZHJhd0RvdChjdXJyZW50RG90LngsIGN1cnJlbnREb3QueSwgJ3JlZCcsIDgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRDYW52YXNWaXNpYmxlKHRydWUpO1xuICAgIH07XG4gICAgXG4gICAgLy8gSW5pdGlhbCBzaXppbmdcbiAgICB1cGRhdGVEaW1lbnNpb25zKCk7XG4gICAgXG4gICAgLy8gTGlzdGVuIGZvciB3aW5kb3cgcmVzaXplXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgIFxuICAgIC8vIENsZWFuIHVwXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICB9O1xuICB9LCBbYWN0aXZlQ2FudmFzUmVmLCBjdXJyZW50RG90XSk7XG4gIFxuICAvLyBEcmF3IGEgZG90IG9uIHRoZSBjYW52YXNcbiAgY29uc3QgZHJhd0RvdCA9ICh4LCB5LCBjb2xvciA9ICdyZWQnLCByYWRpdXMgPSAxMikgPT4geyAvLyBJbmNyZWFzZWQgcmFkaXVzXG4gICAgY29uc29sZS5sb2coXCJEcmF3aW5nIGRvdCBhdDpcIiwgeyB4LCB5LCBjb2xvciwgcmFkaXVzIH0pO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZiBpcyBudWxsIGluIGRyYXdEb3RcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIERyYXcgZG90IHdpdGggZ2xvdyBlZmZlY3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA1LCAwLCBNYXRoLlBJICogMik7IC8vIEluY3JlYXNlZCBnbG93XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJzsgLy8gTW9yZSB2aXNpYmxlIGdsb3dcbiAgICBjdHgubGluZVdpZHRoID0gMzsgLy8gVGhpY2tlciBsaW5lXG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIFN0b3JlIGN1cnJlbnQgZG90IHBvc2l0aW9uIC0gdXNpbmcgY2FsbGJhY2sgZm9ybSB0byBlbnN1cmUgaXQgdXBkYXRlc1xuICAgIHNldEN1cnJlbnREb3QocHJldiA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVwZGF0aW5nIGN1cnJlbnREb3Qgc3RhdGUgZnJvbTpcIiwgcHJldiwgXCJ0bzpcIiwgeyB4LCB5IH0pO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfTtcbiAgXG4gIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJDbGVhcmluZyBjYW52YXNcIik7XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gYWN0aXZlQ2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcmVmIGlzIG51bGwgaW4gY2xlYXJDYW52YXNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICAgIHNldENvdW50ZG93blZhbHVlKG51bGwpO1xuICAgIHNldEZvcmNlU2hvd0NvdW50ZG93bihmYWxzZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FudmFzIGNsZWFyZWQnKTtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgbWVzc2FnZSBhZnRlciBhIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICB9LCAxNTAwKTtcbiAgfTtcbiAgXG4gIC8vIFNhdmUgYW4gaW1hZ2UgdG8gdGhlIHNlcnZlclxuICBjb25zdCBzYXZlSW1hZ2VUb1NlcnZlciA9IGFzeW5jIChpbWFnZURhdGEsIGZpbGVuYW1lLCB0eXBlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKGBBdHRlbXB0aW5nIHRvIHNhdmUgJHt0eXBlfSBpbWFnZTogJHtmaWxlbmFtZX1gKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgZm9sZGVyOiBjYXB0dXJlRm9sZGVyXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coYFNhdmVkICR7dHlwZX0gaW1hZ2U6YCwgcmVzdWx0KTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIHNlcnZlciByZXR1cm5zIGEgbmV3IGNhcHR1cmUgbnVtYmVyLCB1cGRhdGUgb3VyIGNvdW50ZXJcbiAgICAgIGlmIChyZXN1bHQuY2FwdHVyZU51bWJlcikge1xuICAgICAgICBzZXRDYXB0dXJlQ291bnRlcihyZXN1bHQuY2FwdHVyZU51bWJlciArIDEpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgJHt0eXBlfSBpbWFnZTpgLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBVcGRhdGVkIGNhcHR1cmVJbWFnZSBmdW5jdGlvbiB1c2luZyBjb3VudFNhdmUgbW9kdWxlXG4gIGNvbnN0IGNhcHR1cmVJbWFnZSA9IGFzeW5jICgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcIkNhcHR1cmluZyBpbWFnZXMuLi5cIik7XG4gICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFVzZSB0aGUgc2hhcmVkIGNhcHR1cmUgZnVuY3Rpb25cbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzKHtcbiAgICAgICAgY2FudmFzUmVmOiBhY3RpdmVDYW52YXNSZWYsXG4gICAgICAgIHBvc2l0aW9uOiBjdXJyZW50RG90LFxuICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBwcmV2aWV3IHVzaW5nIHRoZSBzaGFyZWQgZnVuY3Rpb25cbiAgICAgIHNob3dDYXB0dXJlUHJldmlldyhcbiAgICAgICAgY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSxcbiAgICAgICAgY2FwdHVyZVJlc3VsdC53ZWJjYW1JbWFnZSxcbiAgICAgICAgY3VycmVudERvdFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZWQgd2l0aCBkb3QgYXQ6IHg9JHtjdXJyZW50RG90Py54fSwgeT0ke2N1cnJlbnREb3Q/Lnl9YCk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoYEltYWdlcyBhbmQgcGFyYW1ldGVycyBzYXZlZCBmb3IgY2FwdHVyZSAjJHtjYXB0dXJlQ291bnRlcn1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgY2FwdHVyZSB3aXRoIGEgZGVsYXkgdG8gbGV0IHByZXZpZXcgZmluaXNoXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJTaG93aW5nIFRvcEJhciBhZnRlciBjYXB0dXJlXCIpO1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjUwMCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlOicsIGVycm9yKTtcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yIGNhcHR1cmluZyBpbWFnZXM6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIH0sIDMwMDApO1xuICB9O1xuICBcbiAgLy8gUmFuZG9tIERvdCBhY3Rpb25cbiAgY29uc3QgaGFuZGxlUmFuZG9tRG90ID0gKCkgPT4ge1xuICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyBkb3RcbiAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicpO1xuICAgIFxuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aW1lIHRvIHVwZGF0ZVxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gYWN0aXZlQ2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgZGltZW5zaW9ucyBhcmUgcHJvcGVybHkgc2V0XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpbml0aWFsaXplQ2FudmFzKGNhbnZhcywgcGFyZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvblxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhbmRvbVBvc2l0aW9uKGNhbnZhcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgZG90IHBvc2l0aW9uIGRpcmVjdGx5XG4gICAgICAgIHNldEN1cnJlbnREb3QocG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHNoYXJlZCBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAgICAgICAgICBhd2FpdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgICAgICAgY2FudmFzUmVmOiBhY3RpdmVDYW52YXNSZWYsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgICAgICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBvblN0YXR1c1VwZGF0ZShzdGF0dXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FwdHVyZUZvbGRlcjogJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgY2FwdHVyaW5nIHN0YXRlIHRvIGZhbHNlIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICB9LCAyMjAwKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yIGNhcHR1cmluZyBpbWFnZXM6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBlcnJvciBtZXNzYWdlIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbiAgXG4gIC8vIE11bHRpcGxlIHJhbmRvbSBkb3RzIHNlcXVlbmNlIC0gYWxzbyB1cGRhdGVkIHRvIHVzZSBjb3VudFNhdmUgZnVuY3Rpb25zXG4gIGNvbnN0IGhhbmRsZVNldFJhbmRvbSA9ICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBQYXJzZSBpbnB1dCB2YWx1ZXMgKHVzZSBkZWZhdWx0cyBpZiBpbnZhbGlkKVxuICAgIGNvbnN0IHRpbWVzID0gcGFyc2VJbnQocmFuZG9tVGltZXMpIHx8IDE7XG4gICAgY29uc3QgZGVsYXkgPSBwYXJzZUludChkZWxheVNlY29uZHMpIHx8IDM7XG4gICAgXG4gICAgaWYgKHRpbWVzIDw9IDAgfHwgZGVsYXkgPD0gMCkge1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnUGxlYXNlIHVzZSBwb3NpdGl2ZSB2YWx1ZXMgZm9yIHRpbWVzIGFuZCBkZWxheScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyh0aW1lcyk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgU3RhcnRpbmcgJHt0aW1lc30gcmFuZG9tIGNhcHR1cmVzLi4uYCk7XG4gICAgXG4gICAgLy8gU3RhcnQgc2VxdWVuY2VcbiAgICBzY2hlZHVsZVJhbmRvbUNhcHR1cmVzKHRpbWVzLCB0aW1lcywgZGVsYXkpO1xuICB9O1xuICBcbiAgLy8gU2NoZWR1bGUgc2VxdWVuY2Ugb2YgcmFuZG9tIGNhcHR1cmVzIC0gdXBkYXRlZCB3aXRoIGNvdW50U2F2ZVxuICBjb25zdCBzY2hlZHVsZVJhbmRvbUNhcHR1cmVzID0gKHJlbWFpbmluZywgdG90YWwsIGRlbGF5KSA9PiB7XG4gICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcygwKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ1JhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZCcpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBzdGF0dXMgYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgICBcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMocmVtYWluaW5nKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlICR7dG90YWwgLSByZW1haW5pbmcgKyAxfSBvZiAke3RvdGFsfWApO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvbiBhbmQgZHJhd1xuICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzKTtcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgc2V0Q3VycmVudERvdChwb3NpdGlvbik7XG4gICAgXG4gICAgLy8gVXNlIHNoYXJlZCBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAgICBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgY2FudmFzUmVmOiBhY3RpdmVDYW52YXNSZWYsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZShzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FwdHVyZUZvbGRlcjogJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIC8vIFNjaGVkdWxlIG5leHQgY2FwdHVyZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNjaGVkdWxlUmFuZG9tQ2FwdHVyZXMocmVtYWluaW5nIC0gMSwgdG90YWwsIGRlbGF5KTtcbiAgICAgIH0sIGRlbGF5ICogMTAwMCk7XG4gICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIHJhbmRvbSBjYXB0dXJlOicsIGVycm9yKTtcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGVycm9yIG1lc3NhZ2UgYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gY2FudmFzIGRpbWVuc2lvbnNcbiAgY29uc3QgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0IHx8IHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzOiBJbnZhbGlkIGNhbnZhcyBkaW1lbnNpb25zXCIsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGNvbmRpdGlvbmFsUm91bmQgPSAoZGltZW5zaW9uLCBwZXJjZW50YWdlKSA9PiBNYXRoLnJvdW5kKGRpbWVuc2lvbiAqIHBlcmNlbnRhZ2UpO1xuICBcbiAgICAvLyBPdXRlciBmcmFtZSAoMTIlIGZyb20gZWRnZXMpXG4gICAgY29uc3QgeExlZnRPdXRlciA9IGNvbmRpdGlvbmFsUm91bmQod2lkdGgsIDAuMTIpO1xuICAgIGNvbnN0IHhSaWdodE91dGVyID0gd2lkdGggLSB4TGVmdE91dGVyO1xuICAgIGNvbnN0IHlUb3BPdXRlciA9IGNvbmRpdGlvbmFsUm91bmQoaGVpZ2h0LCAwLjEyKTtcbiAgICBjb25zdCB5Qm90dG9tT3V0ZXIgPSBoZWlnaHQgLSB5VG9wT3V0ZXI7XG4gIFxuICAgIC8vIElubmVyIGZyYW1lICgyNiUgZnJvbSBlZGdlcylcbiAgICBjb25zdCB4TGVmdElubmVyID0gY29uZGl0aW9uYWxSb3VuZCh3aWR0aCwgMC4yNik7XG4gICAgY29uc3QgeFJpZ2h0SW5uZXIgPSB3aWR0aCAtIHhMZWZ0SW5uZXI7XG4gICAgY29uc3QgeVRvcElubmVyID0gY29uZGl0aW9uYWxSb3VuZChoZWlnaHQsIDAuMjYpO1xuICAgIGNvbnN0IHlCb3R0b21Jbm5lciA9IGhlaWdodCAtIHlUb3BJbm5lcjtcbiAgXG4gICAgY29uc3QgeENlbnRlciA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcbiAgICBjb25zdCB5Q2VudGVyID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKTtcbiAgXG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIE91dGVyIGZyYW1lICg4IHBvaW50cylcbiAgICAgIHsgeDogeExlZnRPdXRlciwgeTogeVRvcE91dGVyLCBsYWJlbDogXCJPdXRlciBUb3AtTGVmdFwiIH0sXG4gICAgICB7IHg6IHhDZW50ZXIsIHk6IHlUb3BPdXRlciwgbGFiZWw6IFwiT3V0ZXIgVG9wLUNlbnRlclwiIH0sXG4gICAgICB7IHg6IHhSaWdodE91dGVyLCB5OiB5VG9wT3V0ZXIsIGxhYmVsOiBcIk91dGVyIFRvcC1SaWdodFwiIH0sXG4gICAgICB7IHg6IHhMZWZ0T3V0ZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIk91dGVyIE1pZGRsZS1MZWZ0XCIgfSxcbiAgICAgIHsgeDogeFJpZ2h0T3V0ZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIk91dGVyIE1pZGRsZS1SaWdodFwiIH0sXG4gICAgICB7IHg6IHhMZWZ0T3V0ZXIsIHk6IHlCb3R0b21PdXRlciwgbGFiZWw6IFwiT3V0ZXIgQm90dG9tLUxlZnRcIiB9LFxuICAgICAgeyB4OiB4Q2VudGVyLCB5OiB5Qm90dG9tT3V0ZXIsIGxhYmVsOiBcIk91dGVyIEJvdHRvbS1DZW50ZXJcIiB9LFxuICAgICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeUJvdHRvbU91dGVyLCBsYWJlbDogXCJPdXRlciBCb3R0b20tUmlnaHRcIiB9LFxuICBcbiAgICAgIC8vIElubmVyIGZyYW1lICg4IHBvaW50cylcbiAgICAgIHsgeDogeExlZnRJbm5lciwgeTogeVRvcElubmVyLCBsYWJlbDogXCJJbm5lciBUb3AtTGVmdFwiIH0sXG4gICAgICB7IHg6IHhDZW50ZXIsIHk6IHlUb3BJbm5lciwgbGFiZWw6IFwiSW5uZXIgVG9wLUNlbnRlclwiIH0sXG4gICAgICB7IHg6IHhSaWdodElubmVyLCB5OiB5VG9wSW5uZXIsIGxhYmVsOiBcIklubmVyIFRvcC1SaWdodFwiIH0sXG4gICAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIklubmVyIE1pZGRsZS1MZWZ0XCIgfSxcbiAgICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIklubmVyIE1pZGRsZS1SaWdodFwiIH0sXG4gICAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlCb3R0b21Jbm5lciwgbGFiZWw6IFwiSW5uZXIgQm90dG9tLUxlZnRcIiB9LFxuICAgICAgeyB4OiB4Q2VudGVyLCB5OiB5Qm90dG9tSW5uZXIsIGxhYmVsOiBcIklubmVyIEJvdHRvbS1DZW50ZXJcIiB9LFxuICAgICAgeyB4OiB4UmlnaHRJbm5lciwgeTogeUJvdHRvbUlubmVyLCBsYWJlbDogXCJJbm5lciBCb3R0b20tUmlnaHRcIiB9XG4gICAgXTtcbiAgfTtcbiAgXG4gIC8vIEhhbmRsZSBTZXQgQ2FsaWJyYXRlIGFjdGlvblxuICBjb25zdCBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNURVAgMTogSElERSBUSEUgVE9QIEJBUiBJTU1FRElBVEVMWSAoYmVmb3JlIGFueXRoaW5nIGVsc2UgaGFwcGVucylcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBVSSB1cGRhdGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgIFxuICAgICAgLy8gU1RFUCAyOiBJbml0aWFsIHNldHVwXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyk7XG4gICAgICBcbiAgICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlJyxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgc3RhdHVzIGluZGljYXRvclxuICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRlIFNldCBBY3RpdmU6IEluaXRpYWxpemluZy4uLic7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICBcbiAgICAgIC8vIFNURVAgMzogU2V0dXAgY2FudmFzIGFuZCBnZW5lcmF0ZSBwb2ludHNcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgY2FudmFzIGRpbWVuc2lvbnMgYXJlIHNldFxuICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIGRpbWVuc2lvbnMgZm9yIGNhbGlicmF0aW9uOlwiLCB7IHdpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCB9KTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIHVzaW5nIHRoZSBpbXBvcnRlZCBmdW5jdGlvblxuICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgc2V0Q2FsaWJyYXRpb25Qb2ludHMocG9pbnRzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYEdlbmVyYXRlZCAke3BvaW50cy5sZW5ndGh9IGNhbGlicmF0aW9uIHBvaW50c2ApO1xuICAgICAgXG4gICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyhwb2ludHMubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gU1RFUCA0OiBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnQgaW4gc2VxdWVuY2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzZXRDdXJyZW50Q2FsaWJyYXRpb25JbmRleChpKTtcbiAgICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMocG9pbnRzLmxlbmd0aCAtIGkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgICBjb25zdCBzdGF0dXNUZXh0ID0gYENhbGlicmF0aW9uICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1c1RleHQpO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRlIFNldCBBY3RpdmU6IFByb2Nlc3NpbmcgcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgIFxuICAgICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZShzdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA1OiBEcmF3IHRoZSByZWQgZG90IEZJUlNULCBiZWZvcmUgYW55IGNvdW50ZG93blxuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgZHJhd0RvdChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSBtb21lbnQgdG8gZW5zdXJlIGRvdCBpcyB2aXNpYmxlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA2OiBHZXQgY2FudmFzIHBvc2l0aW9uIGZvciBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIHRoZSBkb3RcbiAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICAgICAgXG4gICAgICAgIC8vIFBvc2l0aW9uIGl0IGFib3ZlIHRoZSBkb3RcbiAgICAgICAgY29uc3QgYWJzb2x1dGVYID0gY2FudmFzUmVjdC5sZWZ0ICsgcG9pbnQueDtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVZID0gY2FudmFzUmVjdC50b3AgKyBwb2ludC55O1xuICAgICAgICBcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICAgICAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgNzogUnVuIDMtMi0xIGNvdW50ZG93biAodGhlIGRvdCBzdGF5cyB2aXNpYmxlIGR1cmluZyB0aGlzIHRpbWUpXG4gICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGUgU2V0IEFjdGl2ZTogY291bnRkb3duICR7Y291bnR9ICgke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9KWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgbmV4dCBjb3VudGRvd24gc3RlcFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA4OiBTaG93IGNhcHR1cmluZyBpbmRpY2F0b3JcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYXB0dXJpbmcgcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDk6IFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBidXQgS0VFUCB0aGUgZG90IHZpc2libGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgMTA6IENhcHR1cmUgaW1hZ2VzICh0aGUgZG90IGlzIHN0aWxsIHZpc2libGUpXG4gICAgICAgIGF3YWl0IGNhcHR1cmVJbWFnZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCAxMTogV2FpdCBmb3IgcHJldmlldyB0byBjb21wbGV0ZSBiZWZvcmUgbW92aW5nIHRvIG5leHQgcG9pbnRcbiAgICAgICAgLy8gRHVyaW5nIHRoaXMgdGltZSwgdGhlIGRvdCByZW1haW5zIHZpc2libGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIzMDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU1RFUCAxMjogQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDAwKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYWxpYnJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgIG9uU3RhdHVzVXBkYXRlKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvLyBNYXAgYnV0dG9uIGNsaWNrcyB0byBhcHByb3ByaWF0ZSBoYW5kbGVyc1xuICBjb25zdCBoYW5kbGVTY3JlZW5BY3Rpb24gPSAoYWN0aW9uVHlwZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBTY3JlZW4gYWN0aW9uIHJlY2VpdmVkOiAke2FjdGlvblR5cGV9YCk7XG4gICAgXG4gICAgc3dpdGNoKGFjdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgJ3JhbmRvbURvdCc6XG4gICAgICAgIGhhbmRsZVJhbmRvbURvdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NldFJhbmRvbSc6XG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NhbGlicmF0ZSc6XG4gICAgICAgIGhhbmRsZVNldENhbGlicmF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsZWFyQWxsJzpcbiAgICAgICAgY2xlYXJDYW52YXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGb3J3YXJkIHRvIHBhcmVudCBpZiBub3QgaGFuZGxlZCBoZXJlXG4gICAgICAgIGlmIChvbkJ1dHRvbkNsaWNrKSB7XG4gICAgICAgICAgb25CdXR0b25DbGljayhhY3Rpb25UeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIFJlZ2lzdGVyIGFjdGlvbiBoYW5kbGVycyB3aXRoIHBhcmVudCBjb21wb25lbnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTa2lwIGR1cmluZyBTU1JcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIlJlZ2lzdGVyaW5nIGFjdGlvbiBoYW5kbGVycyB3aXRoIHBhcmVudFwiKTtcbiAgICBcbiAgICBpZiAob25CdXR0b25DbGljaykge1xuICAgICAgLy8gQ3JlYXRlIGFjdGlvbiBoYW5kbGVyc1xuICAgICAgY29uc3QgYWN0aW9uSGFuZGxlcnMgPSB7XG4gICAgICAgIHJhbmRvbURvdDogaGFuZGxlUmFuZG9tRG90LFxuICAgICAgICBzZXRSYW5kb206IGhhbmRsZVNldFJhbmRvbSxcbiAgICAgICAgY2FsaWJyYXRlOiBoYW5kbGVTZXRDYWxpYnJhdGUsXG4gICAgICAgIGNsZWFyQWxsOiBjbGVhckNhbnZhc1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gU3RvcmUgaW4gcGFyZW50IGNvbXBvbmVudCBjb250ZXh0XG4gICAgICBvbkJ1dHRvbkNsaWNrKCdyZWdpc3RlckFjdGlvbnMnLCBhY3Rpb25IYW5kbGVycyk7XG4gICAgICBcbiAgICAgIC8vIEFsc28gbWFrZSB0aGVtIGdsb2JhbGx5IGF2YWlsYWJsZSBmb3IgZGlyZWN0IGFjY2Vzc1xuICAgICAgd2luZG93LndoaXRlU2NyZWVuQWN0aW9ucyA9IGFjdGlvbkhhbmRsZXJzO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbnVwIG9uIHVubW91bnRcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy53aGl0ZVNjcmVlbkFjdGlvbnMpIHtcbiAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQWN0aW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uQnV0dG9uQ2xpY2tdKTtcbiAgXG4gIC8vIFVwZGF0ZSBwYXJlbnQgd2l0aCBzdGF0dXMgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChvblN0YXR1c1VwZGF0ZSAmJiBwcm9jZXNzU3RhdHVzKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZShwcm9jZXNzU3RhdHVzKTtcbiAgICB9XG4gIH0sIFtwcm9jZXNzU3RhdHVzLCBvblN0YXR1c1VwZGF0ZV0pO1xuICBcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIndoaXRlLXNjcmVlbi1jb250YWluZXJcIiBzdHlsZT17eyBcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIHpJbmRleDogNTAsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNSknIC8vIFNsaWdodCB0cmFuc3BhcmVuY3kgdG8gc2VlIGlmIGl0J3MgcmVuZGVyZWRcbiAgICB9fT5cbiAgICAgIHsvKiBXaGl0ZSBzY3JlZW4gY2FudmFzIC0gTWFrZSBpdCBjb3ZlciB0aGUgZW50aXJlIGNvbnRhaW5lciAqL31cbiAgICAgIDxkaXYgXG4gICAgICAgIGNsYXNzTmFtZT1cIndoaXRlLXNjcmVlbi1jYW52YXMtY29udGFpbmVyXCJcbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNjY2MnLCAvLyBNb3JlIHZpc2libGUgYm9yZGVyXG4gICAgICAgICAgekluZGV4OiA1MVxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICB7LyogQ2FudmFzIC0gQWx3YXlzIHJlbmRlciBpdCAqL31cbiAgICAgICAgPGNhbnZhc1xuICAgICAgICAgIHJlZj17Y2FudmFzUmVmID8gY2FudmFzUmVmIDogaW50ZXJuYWxDYW52YXNSZWZ9XG4gICAgICAgICAgY2xhc3NOYW1lPVwid2hpdGUtc2NyZWVuLWNhbnZhc1wiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgICAgICB9fVxuICAgICAgICAvPlxuICAgICAgICBcbiAgICAgICAgey8qIE92ZXJsYXkgZm9yIGNvdW50ZG93biBuZWFyIGRvdCAtIHdpdGggaW1wcm92ZWQgdmlzaWJpbGl0eSBhbmQgYSBmYWxsYmFjayAqL31cbiAgICAgICAgeyhjb3VudGRvd25WYWx1ZSAhPT0gbnVsbCB8fCBmb3JjZVNob3dDb3VudGRvd24pICYmIGN1cnJlbnREb3QgJiYgKFxuICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJkb3QtY291bnRkb3duXCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICBsZWZ0OiBgJHtjdXJyZW50RG90LnggLSAzMH1weGAsXG4gICAgICAgICAgICAgIHRvcDogYCR7Y3VycmVudERvdC55IC0gNzB9cHhgLFxuICAgICAgICAgICAgICBjb2xvcjogJ3JlZCcsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnNDhweCcsIC8vIE11Y2ggbGFyZ2VyXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgdGV4dFNoYWRvdzogJzAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZScsIC8vIFN0cm9uZ2VyIHNoYWRvd1xuICAgICAgICAgICAgICB6SW5kZXg6IDk5OSxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpJywgLy8gQmFja2dyb3VuZCB0byBtYWtlIGl0IG1vcmUgdmlzaWJsZVxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMTBweCAyMHB4JyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpJyxcbiAgICAgICAgICAgICAgd2lkdGg6ICc2MHB4JyxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnNjBweCcsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkIHJlZCcgLy8gQm9yZGVyIHRvIG1ha2UgaXQgc3RhbmQgb3V0XG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZSB8fCAzfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICBcbiAgICAgICAgey8qIEJhY2t1cCBjZW50ZXJlZCBjb3VudGRvd24gZm9yIGJldHRlciB2aXNpYmlsaXR5ICovfVxuICAgICAgICB7KGNvdW50ZG93blZhbHVlICE9PSBudWxsIHx8IGZvcmNlU2hvd0NvdW50ZG93bikgJiYgKFxuICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjZW50ZXItY291bnRkb3duLWJhY2t1cFwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzEyMHB4JywgLy8gVmVyeSBsYXJnZVxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgIHRleHRTaGFkb3c6ICcwIDAgMjBweCBibGFjaycsXG4gICAgICAgICAgICAgIHpJbmRleDogMTAwMCxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDAsIDAsIDAuNyknLCAvLyBSZWQgYmFja2dyb3VuZFxuICAgICAgICAgICAgICB3aWR0aDogJzIwMHB4JyxcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMjAwcHgnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAzMHB4IHJnYmEoMCwgMCwgMCwgMC41KSdcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2NvdW50ZG93blZhbHVlIHx8IDN9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIFxuICAgICAgICB7LyogSW5kaWNhdG9yIHRoYXQgdGhlIGRvdCBpcyBwcmVzZW50IC0gaGVscHMgd2l0aCBkZWJ1Z2dpbmcgKi99XG4gICAgICAgIHtjdXJyZW50RG90ICYmIChcbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZG90LWluZGljYXRvclwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgdG9wOiAnMTBweCcsXG4gICAgICAgICAgICAgIHJpZ2h0OiAnMTBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMjU1LCAwLCAwLjcpJyxcbiAgICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTJweCcsXG4gICAgICAgICAgICAgIHpJbmRleDogNTJcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgRG90IGF0IHg6e2N1cnJlbnREb3QueH0sIHk6e2N1cnJlbnREb3QueX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBTdGF0dXMgb3ZlcmxheSAqL31cbiAgICAgICAgeyhwcm9jZXNzU3RhdHVzIHx8IHJlbWFpbmluZ0NhcHR1cmVzID4gMCkgJiYgKFxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInN0YXR1cy1vdmVybGF5XCJcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICBib3R0b206ICcxMHB4JyxcbiAgICAgICAgICAgICAgbGVmdDogJzEwcHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuOCknLCAvLyBEYXJrZXIgZm9yIHZpc2liaWxpdHlcbiAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsIC8vIFdoaXRlIHRleHRcbiAgICAgICAgICAgICAgcGFkZGluZzogJzEwcHggMTVweCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAnMTZweCcsIC8vIExhcmdlclxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsMCwwLDAuMyknLFxuICAgICAgICAgICAgICB6SW5kZXg6IDUzXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtwcm9jZXNzU3RhdHVzICYmIDxkaXY+e3Byb2Nlc3NTdGF0dXN9PC9kaXY+fVxuICAgICAgICAgICAge3JlbWFpbmluZ0NhcHR1cmVzID4gMCAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgY29sb3I6ICcjZmZjYzAwJyB9fT5cbiAgICAgICAgICAgICAgICBSZW1haW5pbmc6IHtyZW1haW5pbmdDYXB0dXJlc31cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICBcbiAgICAgICAgey8qIENhbnZhcyB2aXNpYmlsaXR5IGluZGljYXRvciAtIGRlYnVnZ2luZyBvbmx5ICovfVxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPVwiY2FudmFzLWluZGljYXRvclwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgdG9wOiAnMTBweCcsXG4gICAgICAgICAgICBsZWZ0OiAnMTBweCcsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNhbnZhc1Zpc2libGUgPyAncmdiYSgwLCAyNTUsIDAsIDAuNyknIDogJ3JnYmEoMjU1LCAwLCAwLCAwLjcpJyxcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgcGFkZGluZzogJzVweCAxMHB4JyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgekluZGV4OiA1MlxuICAgICAgICAgIH19XG4gICAgICAgID5cbiAgICAgICAgICBDYW52YXM6IHtjYW52YXNWaXNpYmxlID8gJ1Zpc2libGUnIDogJ0hpZGRlbid9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG4vLyBFeHBvcnQgYSBkeW5hbWljIHZlcnNpb24gd2l0aCBTU1IgZGlzYWJsZWQgdG8gYXZvaWQgdXNlTGF5b3V0RWZmZWN0IHdhcm5pbmdzXG5leHBvcnQgZGVmYXVsdCBkeW5hbWljKCgpID0+IFByb21pc2UucmVzb2x2ZShXaGl0ZVNjcmVlbk1haW4pLCB7IHNzcjogZmFsc2UgfSk7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJkeW5hbWljIiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJkcmF3UmVkRG90IiwiY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImNhcHR1cmVJbWFnZXMiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJXaGl0ZVNjcmVlbk1haW4iLCJvblN0YXR1c1VwZGF0ZSIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJvbkJ1dHRvbkNsaWNrIiwiY2FudmFzUmVmIiwidG9nZ2xlVG9wQmFyIiwiaW50ZXJuYWxDYW52YXNSZWYiLCJhY3RpdmVDYW52YXNSZWYiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjb3VudGRvd25WYWx1ZSIsInNldENvdW50ZG93blZhbHVlIiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzZXRSZW1haW5pbmdDYXB0dXJlcyIsInByb2Nlc3NTdGF0dXMiLCJzZXRQcm9jZXNzU3RhdHVzIiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsImNhcHR1cmVGb2xkZXIiLCJyYW5kb21UaW1lcyIsInNldFJhbmRvbVRpbWVzIiwiZGVsYXlTZWNvbmRzIiwic2V0RGVsYXlTZWNvbmRzIiwiY2FsaWJyYXRpb25Qb2ludHMiLCJzZXRDYWxpYnJhdGlvblBvaW50cyIsImN1cnJlbnRDYWxpYnJhdGlvbkluZGV4Iiwic2V0Q3VycmVudENhbGlicmF0aW9uSW5kZXgiLCJjYW52YXNWaXNpYmxlIiwic2V0Q2FudmFzVmlzaWJsZSIsImZvcmNlU2hvd0NvdW50ZG93biIsInNldEZvcmNlU2hvd0NvdW50ZG93biIsImNhbnZhcyIsImN1cnJlbnQiLCJjb25zb2xlIiwiZXJyb3IiLCJsb2ciLCJoYXNDYW52YXMiLCJjYW52YXNIZWlnaHQiLCJoZWlnaHQiLCJjYW52YXNXaWR0aCIsIndpZHRoIiwidXBkYXRlRGltZW5zaW9ucyIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJwYXJlbnRXaWR0aCIsImNsaWVudFdpZHRoIiwicGFyZW50SGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZHJhd0RvdCIsIngiLCJ5Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJjb2xvciIsInJhZGl1cyIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIk1hdGgiLCJQSSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsInByZXYiLCJjbGVhckNhbnZhcyIsInNldFRpbWVvdXQiLCJzYXZlSW1hZ2VUb1NlcnZlciIsImltYWdlRGF0YSIsImZpbGVuYW1lIiwidHlwZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb2xkZXIiLCJvayIsIkVycm9yIiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsImNhcHR1cmVOdW1iZXIiLCJjYXB0dXJlSW1hZ2UiLCJjYXB0dXJlUmVzdWx0IiwicG9zaXRpb24iLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwibWVzc2FnZSIsImhhbmRsZVJhbmRvbURvdCIsImhhbmRsZVNldFJhbmRvbSIsInRpbWVzIiwicGFyc2VJbnQiLCJkZWxheSIsInNjaGVkdWxlUmFuZG9tQ2FwdHVyZXMiLCJyZW1haW5pbmciLCJ0b3RhbCIsInRoZW4iLCJjYXRjaCIsImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJjb25kaXRpb25hbFJvdW5kIiwiZGltZW5zaW9uIiwicGVyY2VudGFnZSIsInJvdW5kIiwieExlZnRPdXRlciIsInhSaWdodE91dGVyIiwieVRvcE91dGVyIiwieUJvdHRvbU91dGVyIiwieExlZnRJbm5lciIsInhSaWdodElubmVyIiwieVRvcElubmVyIiwieUJvdHRvbUlubmVyIiwieENlbnRlciIsImZsb29yIiwieUNlbnRlciIsImxhYmVsIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzdGF0dXNJbmRpY2F0b3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwicG9pbnRzIiwibGVuZ3RoIiwiaSIsInN0YXR1c1RleHQiLCJwb2ludCIsImNhbnZhc1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3VudGRvd25FbGVtZW50IiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiaGFuZGxlU2NyZWVuQWN0aW9uIiwiYWN0aW9uVHlwZSIsImFjdGlvbkhhbmRsZXJzIiwicmFuZG9tRG90Iiwic2V0UmFuZG9tIiwiY2FsaWJyYXRlIiwiY2xlYXJBbGwiLCJ3aGl0ZVNjcmVlbkFjdGlvbnMiLCJkaXYiLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvdmVyZmxvdyIsImJvcmRlciIsInJlZiIsImRpc3BsYXkiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJ0ZXh0U2hhZG93IiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsImJveFNoYWRvdyIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsInRyYW5zZm9ybSIsInJpZ2h0IiwiYm90dG9tIiwic3NyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/WhiteScreenMain.js\n"));

/***/ })

}]);