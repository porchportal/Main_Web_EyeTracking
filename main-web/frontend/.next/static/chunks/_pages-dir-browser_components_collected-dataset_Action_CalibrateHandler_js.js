"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_components_collected-dataset_Action_CalibrateHandler_js"],{

/***/ "(pages-dir-browser)/./components/collected-dataset/Action/CalibrateHandler.js":
/*!*****************************************************************!*\
  !*** ./components/collected-dataset/Action/CalibrateHandler.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset/Action/CalibratePoints.js\");\n/* harmony import */ var _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CaptureHandler */ \"(pages-dir-browser)/./components/collected-dataset/Action/CaptureHandler.js\");\n/* harmony import */ var _DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotCaptureUtil */ \"(pages-dir-browser)/./components/collected-dataset/Action/DotCaptureUtil.js\");\n// CalibrateHandler.js - Using the existing CaptureHandler class\n\n\n\nclass CalibrateHandler {\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = \"\\n      position: fixed;\\n      top: 10px;\\n      right: 10px;\\n      background-color: rgba(0, 102, 204, 0.9);\\n      color: white;\\n      font-size: 14px;\\n      font-weight: bold;\\n      padding: 8px 12px;\\n      border-radius: 6px;\\n      z-index: 9999;\\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n    \";\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            var _this_setOutputText, _this;\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Processing point \".concat(index + 1, \"/\").concat(total);\n            }\n            // Draw the dot\n            const canvas = this.canvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            const ctx = canvas.getContext('2d');\n            (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n            // Create countdown element\n            const canvasRect = canvas.getBoundingClientRect();\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'calibrate-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(canvasRect.left + point.x, \"px;\\n        top: \").concat(canvasRect.top + point.y - 60, \"px;\\n        transform: translateX(-50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 9999;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Run countdown\n            for(let count = 3; count > 0; count--){\n                var _this_setOutputText1, _this1;\n                countdownElement.textContent = count;\n                (_this_setOutputText1 = (_this1 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this1, \"Point \".concat(index + 1, \"/\").concat(total, \" - countdown \").concat(count));\n                // Make sure dot remains visible during countdown\n                (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n                // Wait for next countdown step\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            // Show capturing indicator\n            countdownElement.textContent = \"âœ“\";\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Capturing point \".concat(index + 1, \"/\").concat(total));\n            // Remove countdown element\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Use CaptureHandler to handle the capture process\n            const captureResult = await this.captureHandler.captureAndShowPreview(this.captureCounter, this.canvasRef, point);\n            // Add null check before using the result\n            if (!captureResult) {\n                console.warn(\"No capture result for point \".concat(index + 1));\n            // You might want to set a default or retry logic here\n            }\n            // Wait for the preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2500));\n            return true;\n        } catch (err) {\n            var _this_setOutputText2, _this2;\n            console.error(\"Error processing point \".concat(index + 1, \":\"), err);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Error: \".concat(err.message);\n            }\n            (_this_setOutputText2 = (_this2 = this).setOutputText) === null || _this_setOutputText2 === void 0 ? void 0 : _this_setOutputText2.call(_this2, \"Error: \".concat(err.message));\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        if (this.toggleTopBar) {\n            this.toggleTopBar(false);\n        }\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            var _this_setOutputText, _this, _this_setOutputText1, _this1;\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Starting calibration with \".concat(this.calibrationPoints.length, \" points\"));\n            let successCount = 0;\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (success) {\n                    successCount++;\n                }\n                // Small delay between points\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            (_this_setOutputText1 = (_this1 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this1, \"Calibration completed: \".concat(successCount, \"/\").concat(this.calibrationPoints.length, \" points captured\"));\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(this.calibrationPoints.length, \" points\");\n            }\n            // Turn TopBar back on\n            if (this.toggleTopBar) {\n                this.toggleTopBar(true);\n            }\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        } catch (error) {\n            // console.error('Calibration error:', error);\n            // this.setOutputText?.(`Calibration error: ${error.message}`);\n            // if (this.statusIndicator) {\n            //   this.statusIndicator.textContent = `Error: ${error.message}`;\n            // }\n            // // Make sure we turn TopBar back on even on error\n            // if (this.toggleTopBar) {\n            //   this.toggleTopBar(true);\n            // }\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1500);\n            // Return a default object to prevent null reference errors\n            return {\n                screenImage: '',\n                webcamImage: '',\n                success: false\n            };\n        } finally{\n            this.isProcessing = false;\n            // Remove the status indicator after a delay\n            setTimeout(()=>{\n                if (this.statusIndicator && this.statusIndicator.parentNode) {\n                    this.statusIndicator.parentNode.removeChild(this.statusIndicator);\n                }\n            }, 3000);\n        }\n    }\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Create a CaptureHandler instance for handling the captures\n        this.captureHandler = new _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__[\"default\"](// Pass saveImageToServer function\n        async (imageData, filename, type, folder)=>{\n            try {\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type,\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    console.warn(\"Server responded with \".concat(response.status));\n                    return {};\n                }\n                return await response.json();\n            } catch (err) {\n                console.error(\"Error saving \".concat(type, \":\"), err);\n                return {};\n            }\n        }, // Pass setCaptureCounter function\n        (newCounter)=>{\n            if (typeof newCounter === 'function') {\n                this.captureCounter = newCounter(this.captureCounter);\n            } else {\n                this.captureCounter = newCounter;\n            }\n            if (this.setCaptureCounter) {\n                this.setCaptureCounter(this.captureCounter);\n            }\n        }, // Pass setProcessStatus function\n        (status)=>{\n            if (this.setOutputText) {\n                this.setOutputText(status);\n            }\n        }, // Pass toggleTopBar function\n        this.toggleTopBar);\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdFQUFnRTtBQUNGO0FBQ2hCO0FBQ0E7QUFFOUMsTUFBTUc7SUFzRUpDLHdCQUF3QjtRQUN0QixNQUFNQyxxQkFBcUJDLFNBQVNDLGdCQUFnQixDQUFDO1FBQ3JERixtQkFBbUJHLE9BQU8sQ0FBQ0MsQ0FBQUEsWUFBYUEsVUFBVUMsTUFBTTtRQUV4RCxNQUFNRCxZQUFZSCxTQUFTSyxhQUFhLENBQUM7UUFDekNGLFVBQVVHLFNBQVMsR0FBRztRQUN0QkgsVUFBVUksS0FBSyxDQUFDQyxPQUFPLEdBQUk7UUFhM0JSLFNBQVNTLElBQUksQ0FBQ0MsV0FBVyxDQUFDUDtRQUMxQixJQUFJLENBQUNRLGVBQWUsR0FBR1I7UUFDdkIsT0FBT0E7SUFDVDtJQUVBLE1BQU1TLHdCQUF3QkMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUNqRCxJQUFJO2dCQTBERjtZQXpEQSxJQUFJLENBQUNGLFNBQVMsT0FBT0EsTUFBTUcsQ0FBQyxLQUFLLFlBQVksT0FBT0gsTUFBTUksQ0FBQyxLQUFLLFVBQVU7Z0JBQ3hFLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUVBLElBQUksSUFBSSxDQUFDUCxlQUFlLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQ0EsZUFBZSxDQUFDUSxXQUFXLEdBQUcsb0JBQWlDSixPQUFiRCxRQUFRLEdBQUUsS0FBUyxPQUFOQztZQUN0RTtZQUVBLGVBQWU7WUFDZixNQUFNSyxTQUFTLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxPQUFPO1lBQ3JDLElBQUksQ0FBQ0YsUUFBUTtnQkFDWCxNQUFNLElBQUlGLE1BQU07WUFDbEI7WUFFQSxNQUFNSyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7WUFDOUI1QiwyREFBVUEsQ0FBQzJCLEtBQUtWLE1BQU1HLENBQUMsRUFBRUgsTUFB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QUFJLENBQUN0QyxjQUFjLEdBQUdzQyxXQUFXLElBQUksQ0FBQ3RDLGNBQWM7WUFDdEQsT0FBTztnQkFDTCxJQUFJLENBQUNBLGNBQWMsR0FBR3NDO1lBQ3hCO1lBRUEsSUFBSSxJQUFJLENBQUNmLGlCQUFpQixFQUFFO2dCQUMxQixJQUFJLENBQUNBLGlCQUFpQixDQUFDLElBQUksQ0FBQ3ZCLGNBQWM7WUFDNUM7UUFDRixHQUNBLGlDQUFpQztRQUNqQyxDQUFDb0M7WUFDQyxJQUFJLElBQUksQ0FBQzdDLGFBQWEsRUFBRTtnQkFDdEIsSUFBSSxDQUFDQSxhQUFhLENBQUM2QztZQUNyQjtRQUNGLEdBQ0EsNkJBQTZCO1FBQzdCLElBQUksQ0FBQzVCLFlBQVk7UUFHbkIsWUFBWTtRQUNaLElBQUksQ0FBQ0QsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2dDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ3BFLGVBQWUsR0FBRztJQUN6QjtBQWlPRjtBQUVBLGlFQUFlZCxnQkFBZ0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWxpYnJhdGVIYW5kbGVyLmpzIC0gVXNpbmcgdGhlIGV4aXN0aW5nIENhcHR1cmVIYW5kbGVyIGNsYXNzXG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IENhcHR1cmVIYW5kbGVyIGZyb20gJy4vQ2FwdHVyZUhhbmRsZXInO1xuaW1wb3J0IHsgZHJhd1JlZERvdCB9IGZyb20gJy4vRG90Q2FwdHVyZVV0aWwnO1xuXG5jbGFzcyBDYWxpYnJhdGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldE91dHB1dFRleHQgPSBjb25maWcuc2V0T3V0cHV0VGV4dDtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyIHx8IDE7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSBjb25maWcuY2FwdHVyZUZvbGRlciB8fCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJztcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBjb25maWcub25Db21wbGV0ZTtcblxuICAgIC8vIEFjY2VwdCBwYXNzZWQtaW4gY2FsaWJyYXRpb24gcG9pbnRzIChmcm9tIFNldENhbGlicmF0ZUFjdGlvbi5qcylcbiAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gY29uZmlnLmNhbGlicmF0aW9uUG9pbnRzIHx8IFtdO1xuXG4gICAgLy8gQ3JlYXRlIGEgQ2FwdHVyZUhhbmRsZXIgaW5zdGFuY2UgZm9yIGhhbmRsaW5nIHRoZSBjYXB0dXJlc1xuICAgIHRoaXMuY2FwdHVyZUhhbmRsZXIgPSBuZXcgQ2FwdHVyZUhhbmRsZXIoXG4gICAgICAvLyBQYXNzIHNhdmVJbWFnZVRvU2VydmVyIGZ1bmN0aW9uXG4gICAgICBhc3luYyAoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgdHlwZSwgZm9sZGVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyAke3R5cGV9OmAsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUGFzcyBzZXRDYXB0dXJlQ291bnRlciBmdW5jdGlvblxuICAgICAgKG5ld0NvdW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDb3VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IG5ld0NvdW50ZXIodGhpcy5jYXB0dXJlQ291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IG5ld0NvdW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcih0aGlzLmNhcHR1cmVDb3VudGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFBhc3Mgc2V0UHJvY2Vzc1N0YXR1cyBmdW5jdGlvblxuICAgICAgKHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAodGhpcy5zZXRPdXRwdXRUZXh0KSB7XG4gICAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0KHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIHRvZ2dsZVRvcEJhciBmdW5jdGlvblxuICAgICAgdGhpcy50b2dnbGVUb3BCYXJcbiAgICApO1xuXG4gICAgLy8gSW50ZXJuYWxzXG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRQb2ludEluZGV4ID0gMDtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gIH1cblxuICBjcmVhdGVTdGF0dXNJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJbmRpY2F0b3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJyk7XG4gICAgZXhpc3RpbmdJbmRpY2F0b3JzLmZvckVhY2goaW5kaWNhdG9yID0+IGluZGljYXRvci5yZW1vdmUoKSk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICBpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIHRvcDogMTBweDtcbiAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IGluZGljYXRvcjtcbiAgICByZXR1cm4gaW5kaWNhdG9yO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQocG9pbnQsIGluZGV4LCB0b3RhbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXBvaW50IHx8IHR5cGVvZiBwb2ludC54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9pbnQueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYWxpYnJhdGlvbiBwb2ludFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYFByb2Nlc3NpbmcgcG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9YDtcbiAgICAgIH1cblxuICAgICAgLy8gRHJhdyB0aGUgZG90XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBsZWZ0OiAke2NhbnZhc1JlY3QubGVmdCArIHBvaW50Lnh9cHg7XG4gICAgICAgIHRvcDogJHtjYW52YXNSZWN0LnRvcCArIHBvaW50LnkgLSA2MH1weDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIFJ1biBjb3VudGRvd25cbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYFBvaW50ICR7aW5kZXggKyAxfS8ke3RvdGFsfSAtIGNvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCByZW1haW5zIHZpc2libGUgZHVyaW5nIGNvdW50ZG93blxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciBuZXh0IGNvdW50ZG93biBzdGVwXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBjYXB0dXJpbmcgaW5kaWNhdG9yXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBDYXB0dXJpbmcgcG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9YCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBDYXB0dXJlSGFuZGxlciB0byBoYW5kbGUgdGhlIGNhcHR1cmUgcHJvY2Vzc1xuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IHRoaXMuY2FwdHVyZUhhbmRsZXIuY2FwdHVyZUFuZFNob3dQcmV2aWV3KFxuICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICB0aGlzLmNhbnZhc1JlZixcbiAgICAgICAgcG9pbnRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBudWxsIGNoZWNrIGJlZm9yZSB1c2luZyB0aGUgcmVzdWx0XG4gICAgICBpZiAoIWNhcHR1cmVSZXN1bHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBjYXB0dXJlIHJlc3VsdCBmb3IgcG9pbnQgJHtpbmRleCArIDF9YCk7XG4gICAgICAgIC8vIFlvdSBtaWdodCB3YW50IHRvIHNldCBhIGRlZmF1bHQgb3IgcmV0cnkgbG9naWMgaGVyZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciB0aGUgcHJldmlldyB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDI1MDApKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHBvaW50ICR7aW5kZXggKyAxfTpgLCBlcnIpO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RhcnRDYWxpYnJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cblxuXG4gICAgaWYgKHRoaXMudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kaWNhdG9yID0gdGhpcy5jcmVhdGVTdGF0dXNJbmRpY2F0b3IoKTtcbiAgICBpbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnSW5pdGlhbGl6aW5nIGNhbGlicmF0aW9uLi4uJztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHJlYWR5Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgZ2VuZXJhdGUgaWYgbm9uZSB3ZXJlIHBhc3NlZCBpblxuICAgICAgaWYgKCF0aGlzLmNhbGlicmF0aW9uUG9pbnRzIHx8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbGlicmF0aW9uUG9pbnRzIHx8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYFN0YXJ0aW5nIGNhbGlicmF0aW9uIHdpdGggJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH0gcG9pbnRzYCk7XG4gICAgICBcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnByb2Nlc3NDYWxpYnJhdGlvblBvaW50KFxuICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHNbaV0sIFxuICAgICAgICAgIGksIFxuICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTbWFsbCBkZWxheSBiZXR3ZWVuIHBvaW50c1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFR1cm4gVG9wQmFyIGJhY2sgb25cbiAgICAgIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdDYWxpYnJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAvLyB0aGlzLnNldE91dHB1dFRleHQ/LihgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIC8vIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgLy8gICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAvLyB9XG4gICAgICBcbiAgICAgIC8vIC8vIE1ha2Ugc3VyZSB3ZSB0dXJuIFRvcEJhciBiYWNrIG9uIGV2ZW4gb24gZXJyb3JcbiAgICAgIC8vIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgLy8gICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIC8vIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlIGFuZCBwcmV2aWV3OicsIGVycm9yKTtcbiAgXG4gICAgICAvLyBTaG93IGVycm9yIG1lc3NhZ2VcbiAgICAgIGlmICh0aGlzLnNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTUwMCk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBhIGRlZmF1bHQgb2JqZWN0IHRvIHByZXZlbnQgbnVsbCByZWZlcmVuY2UgZXJyb3JzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSB0aGUgc3RhdHVzIGluZGljYXRvciBhZnRlciBhIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yICYmIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbGlicmF0ZUhhbmRsZXI7Il0sIm5hbWVzIjpbImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJDYXB0dXJlSGFuZGxlciIsImRyYXdSZWREb3QiLCJDYWxpYnJhdGVIYW5kbGVyIiwiY3JlYXRlU3RhdHVzSW5kaWNhdG9yIiwiZXhpc3RpbmdJbmRpY2F0b3JzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImluZGljYXRvciIsInJlbW92ZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzdGF0dXNJbmRpY2F0b3IiLCJwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludCIsInBvaW50IiwiaW5kZXgiLCJ0b3RhbCIsIngiLCJ5IiwiRXJyb3IiLCJ0ZXh0Q29udGVudCIsImNhbnZhcyIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2FudmFzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvdW50ZG93bkVsZW1lbnQiLCJsZWZ0IiwidG9wIiwiY291bnQiLCJzZXRPdXRwdXRUZXh0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVIYW5kbGVyIiwiY2FwdHVyZUFuZFNob3dQcmV2aWV3IiwiY2FwdHVyZUNvdW50ZXIiLCJjb25zb2xlIiwid2FybiIsImVyciIsImVycm9yIiwibWVzc2FnZSIsInN0YXJ0Q2FsaWJyYXRpb24iLCJpc1Byb2Nlc3NpbmciLCJ0b2dnbGVUb3BCYXIiLCJ3aWR0aCIsImhlaWdodCIsImNhbGlicmF0aW9uUG9pbnRzIiwibGVuZ3RoIiwic3VjY2Vzc0NvdW50IiwiaSIsInN1Y2Nlc3MiLCJvbkNvbXBsZXRlIiwic2V0UHJvY2Vzc1N0YXR1cyIsIndpbmRvdyIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsImltYWdlRGF0YSIsImZpbGVuYW1lIiwidHlwZSIsImZvbGRlciIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwic3RhdHVzIiwianNvbiIsIm5ld0NvdW50ZXIiLCJjdXJyZW50UG9pbnRJbmRleCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset/Action/CalibrateHandler.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset/Action/CaptureHandler.js":
/*!***************************************************************!*\
  !*** ./components/collected-dataset/Action/CaptureHandler.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// CaptureHandler.js - With fixed capture numbering\nclass CaptureHandler {\n    // Show preview of the SAVED images for exactly 2 seconds\n    showCapturePreview(screenImage, webcamImage, dotPosition) {\n        // Create a centered preview container\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = \"\\n        position: fixed;\\n        top: 50%;\\n        left: 50%;\\n        transform: translate(-50%, -50%);\\n        display: flex;\\n        gap: 20px;\\n        background-color: rgba(0, 0, 0, 0.85);\\n        padding: 20px;\\n        border-radius: 12px;\\n        z-index: 999999;\\n        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n        opacity: 1;\\n        transition: opacity 0.3s ease;\\n      \";\n        // Function to create an image preview element\n        const createImagePreview = (imageData, label)=>{\n            if (!imageData) return null;\n            const preview = document.createElement('div');\n            preview.style.cssText = \"\\n          display: flex;\\n          flex-direction: column;\\n          align-items: center;\\n        \";\n            const img = document.createElement('img');\n            img.src = imageData;\n            img.style.cssText = \"\\n          max-width: 320px;\\n          max-height: 240px;\\n          border: 3px solid white;\\n          border-radius: 8px;\\n          background-color: #333;\\n        \";\n            // Event listeners for image loading\n            img.onload = ()=>console.log(\"\".concat(label, \" image loaded successfully\"));\n            img.onerror = (e)=>console.error(\"Error loading \".concat(label, \" image:\"), e);\n            const textLabel = document.createElement('div');\n            textLabel.textContent = label;\n            textLabel.style.cssText = \"\\n          color: white;\\n          font-size: 14px;\\n          margin-top: 10px;\\n          font-weight: bold;\\n        \";\n            preview.appendChild(img);\n            preview.appendChild(textLabel);\n            return preview;\n        };\n        // Add debug info\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = \"\\n        position: absolute;\\n        top: -30px;\\n        left: 0;\\n        width: 100%;\\n        color: white;\\n        font-size: 12px;\\n        text-align: center;\\n      \";\n        debugInfo.textContent = \"Screen: \".concat(screenImage ? 'YES' : 'NO', \", Webcam: \").concat(webcamImage ? 'YES' : 'NO');\n        previewContainer.appendChild(debugInfo);\n        // Add screen capture preview\n        const screenPreview = createImagePreview(screenImage, 'Screen Capture');\n        if (screenPreview) {\n            previewContainer.appendChild(screenPreview);\n        }\n        // Add webcam capture preview\n        const webcamPreview = createImagePreview(webcamImage, 'Webcam Capture');\n        if (webcamPreview) {\n            previewContainer.appendChild(webcamPreview);\n        }\n        // Add dot position info if available\n        if (dotPosition) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = \"Dot position: x=\".concat(Math.round(dotPosition.x), \", y=\").concat(Math.round(dotPosition.y));\n            positionInfo.style.cssText = \"\\n          color: #ffcc00;\\n          font-size: 14px;\\n          position: absolute;\\n          top: -50px;\\n          left: 0;\\n          width: 100%;\\n          text-align: center;\\n        \";\n            previewContainer.appendChild(positionInfo);\n        }\n        // Add timer countdown\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = \"\\n        position: absolute;\\n        bottom: -25px;\\n        right: 20px;\\n        color: white;\\n        font-size: 12px;\\n        background-color: rgba(0, 0, 0, 0.7);\\n        padding: 3px 8px;\\n        border-radius: 4px;\\n      \";\n        previewContainer.appendChild(timerElement);\n        // Add the preview to the document\n        document.body.appendChild(previewContainer);\n        // Start countdown timer\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Take a webcam picture and immediately stop the stream\n    async captureWebcamImage(captureNumber) {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format the filename with the current counter\n            const filename = \"webcam_\".concat(String(captureNumber).padStart(3, '0'), \".jpg\");\n            // Create a new stream with high resolution constraints\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 4096\n                    },\n                    height: {\n                        ideal: 2160\n                    },\n                    facingMode: \"user\"\n                },\n                audio: false\n            });\n            // Create a temporary video element\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Connect stream to video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get actual video dimensions\n            const videoWidth = tempVideo.videoWidth || 640;\n            const videoHeight = tempVideo.videoHeight || 480;\n            console.log(\"Capturing at resolution: \".concat(videoWidth, \"x\").concat(videoHeight));\n            // Capture the frame at full resolution\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = videoWidth;\n            tempCanvas.height = videoHeight;\n            const ctx = tempCanvas.getContext('2d');\n            ctx.drawImage(tempVideo, 0, 0, videoWidth, videoHeight);\n            // Convert to JPEG with high quality\n            const imageData = tempCanvas.toDataURL('image/jpeg', 0.95);\n            // Save the image\n            await this.saveImageToServer(imageData, filename, 'webcam', this.captureFolder);\n            // Clean up\n            stream.getTracks().forEach((track)=>track.stop());\n            tempVideo.remove();\n            return true;\n        } catch (error) {\n            console.error('Error capturing webcam image:', error);\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.remove();\n            }\n            return false;\n        }\n    }\n    // Capture screen image from canvas\n    async captureScreenImage(canvasRef, captureNumber) {\n        try {\n            // Format the filename with the current counter\n            const filename = \"screen_\".concat(String(captureNumber).padStart(3, '0'), \".jpg\");\n            const canvas = canvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas reference is null\");\n                return {\n                    imageData: null,\n                    saveResponse: null\n                };\n            }\n            // Get image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save the image\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(imageData, filename, 'screen', this.captureFolder);\n                console.log(\"Saved screen image: \".concat(filename, \", response:\"), saveResponse);\n                return {\n                    imageData,\n                    saveResponse\n                };\n            }\n            return {\n                imageData,\n                saveResponse: null\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            return {\n                imageData: null,\n                saveResponse: null\n            };\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(captureNumber, params) {\n        try {\n            // Format the filename with the current counter\n            const filename = \"parameter_\".concat(String(captureNumber).padStart(3, '0'), \".csv\");\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                ...Object.entries(params).map((param)=>{\n                    let [name, value] = param;\n                    return \"\".concat(name, \",\").concat(value);\n                })\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(csvDataUrl, filename, 'parameters', this.captureFolder);\n                console.log(\"Saved parameter CSV: \".concat(filename));\n                return saveResponse;\n            }\n            return null;\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n            return null;\n        }\n    }\n    // Main capture and show process\n    async captureAndShowPreview(captureCounter, canvasRef, position) {\n        try {\n            console.log(\"Starting capture process with counter: \".concat(captureCounter));\n            // Step 1: Capture screen image\n            const { imageData: screenImage, saveResponse: screenResponse } = await this.captureScreenImage(canvasRef, captureCounter);\n            // Get the capture number from the response if available (for continuous numbering)\n            let usedCaptureNumber = captureCounter;\n            if (screenResponse && screenResponse.captureNumber) {\n                usedCaptureNumber = screenResponse.captureNumber;\n                console.log(\"Server assigned capture number: \".concat(usedCaptureNumber));\n            }\n            // Step 2: Capture webcam image (and immediately stop stream)\n            const webcamSuccess = await this.captureWebcamImage(usedCaptureNumber);\n            // Step 3: Save parameters\n            const params = {\n                dot_x: position ? position.x : 0,\n                dot_y: position ? position.y : 0,\n                canvas_width: canvasRef.current ? canvasRef.current.width : 0,\n                canvas_height: canvasRef.current ? canvasRef.current.height : 0,\n                window_width: window.innerWidth,\n                window_height: window.innerHeight,\n                timestamp: new Date().toISOString()\n            };\n            await this.saveParameterCSV(usedCaptureNumber, params);\n            // Step 4: Increment counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server is managing numbering, use the next number\n                if (screenResponse && screenResponse.captureNumber) {\n                    this.setCaptureCounter(screenResponse.captureNumber + 1);\n                } else {\n                    this.setCaptureCounter((prev)=>prev + 1);\n                }\n            }\n            // Step 5: Update status\n            if (this.setProcessStatus) {\n                this.setProcessStatus(\"Captured with dot at: x=\".concat(position === null || position === void 0 ? void 0 : position.x, \", y=\").concat(position === null || position === void 0 ? void 0 : position.y));\n            }\n            // Step 6: Show preview using the in-memory image data\n            this.showCapturePreview(screenImage, webcamSuccess ? 'webcam_image_data' : null, position);\n            // Step 7: Show TopBar again after preview is done\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2200); // Wait longer than the preview duration\n            // Step 8: Clear status after a delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1500);\n            // Clear error message after delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        }\n    }\n    constructor(saveFunction, counterSetter, statusSetter, toggleTopBarFunction){\n        this.saveImageToServer = saveFunction;\n        this.setCaptureCounter = counterSetter;\n        this.setProcessStatus = statusSetter;\n        this.toggleTopBar = toggleTopBarFunction;\n        this.captureFolder = 'eye_tracking_captures'; // Use fixed folder name\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CaptureHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQvQWN0aW9uL0NhcHR1cmVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxtREFBbUQ7QUFFbkQsTUFBTUE7SUFTRix5REFBeUQ7SUFDekRDLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUN4RCxzQ0FBc0M7UUFDdEMsTUFBTUMsbUJBQW1CQyxTQUFTQyxhQUFhLENBQUM7UUFDaERGLGlCQUFpQkcsS0FBSyxDQUFDQyxPQUFPLEdBQUk7UUFnQmxDLDhDQUE4QztRQUM5QyxNQUFNQyxxQkFBcUIsQ0FBQ0MsV0FBV0M7WUFDckMsSUFBSSxDQUFDRCxXQUFXLE9BQU87WUFFdkIsTUFBTUUsVUFBVVAsU0FBU0MsYUFBYSxDQUFDO1lBQ3ZDTSxRQUFRTCxLQUFLLENBQUNDLE9BQU8sR0FBSTtZQU16QixNQUFNSyxNQUFNUixTQUFTQyxhQUFhLENBQUM7WUFDbkNPLElBQUlDLEdBQUcsR0FBR0o7WUFDVkcsSUFBSU4sS0FBSyxDQUFDQyxPQUFPLEdBQUk7WUFRckIsb0NBQW9DO1lBQ3BDSyxJQUFJRSxNQUFNLEdBQUcsSUFBTUMsUUFBUUMsR0FBRyxDQUFDLEdBQVMsT0FBTk4sT0FBTTtZQUN4Q0UsSUFBSUssT0FBTyxHQUFHLENBQUNDLElBQU1ILFFBQVFJLEtBQUssQ0FBQyxpQkFBdUIsT0FBTlQsT0FBTSxZQUFVUTtZQUVwRSxNQUFNRSxZQUFZaEIsU0FBU0MsYUFBYSxDQUFDO1lBQ3pDZSxVQUFVQyxXQUFXLEdBQUdYO1lBQ3hCVSxVQUFVZCxLQUFLLENBQUNDLE9BQU8sR0FBSTtZQU8zQkksUUFBUVcsV0FBVyxDQUFDVjtZQUNwQkQsUUFBUVcsV0FBVyxDQUFDRjtZQUNwQixPQUFPVDtRQUNUO1FBRUEsaUJBQWlCO1FBQ2pCLE1BQU1ZLFlBQVluQixTQUFTQyxhQUFhLENBQUM7UUFDekNrQixVQUFVakIsS0FBSyxDQUFDQyxPQUFPLEdB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LEVBQUVDLGFBQWEsRUFBRUMsWUFBWSxFQUFFQyxvQkFBb0IsQ0FBRTtRQUMzRSxJQUFJLENBQUN6RCxpQkFBaUIsR0FBR3NEO1FBQ3pCLElBQUksQ0FBQ04saUJBQWlCLEdBQUdPO1FBQ3pCLElBQUksQ0FBQ0wsZ0JBQWdCLEdBQUdNO1FBQ3hCLElBQUksQ0FBQ0wsWUFBWSxHQUFHTTtRQUNwQixJQUFJLENBQUN4RCxhQUFhLEdBQUcseUJBQXlCLHdCQUF3QjtJQUN4RTtBQWlZRjtBQUVBLGlFQUFlaEYsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0L0FjdGlvbi9DYXB0dXJlSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYXB0dXJlSGFuZGxlci5qcyAtIFdpdGggZml4ZWQgY2FwdHVyZSBudW1iZXJpbmdcblxuY2xhc3MgQ2FwdHVyZUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNhdmVGdW5jdGlvbiwgY291bnRlclNldHRlciwgc3RhdHVzU2V0dGVyLCB0b2dnbGVUb3BCYXJGdW5jdGlvbikge1xuICAgICAgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlciA9IHNhdmVGdW5jdGlvbjtcbiAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb3VudGVyU2V0dGVyO1xuICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzID0gc3RhdHVzU2V0dGVyO1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIgPSB0b2dnbGVUb3BCYXJGdW5jdGlvbjtcbiAgICAgIHRoaXMuY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnOyAvLyBVc2UgZml4ZWQgZm9sZGVyIG5hbWVcbiAgICB9XG4gIFxuICAgIC8vIFNob3cgcHJldmlldyBvZiB0aGUgU0FWRUQgaW1hZ2VzIGZvciBleGFjdGx5IDIgc2Vjb25kc1xuICAgIHNob3dDYXB0dXJlUHJldmlldyhzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSB7XG4gICAgICAvLyBDcmVhdGUgYSBjZW50ZXJlZCBwcmV2aWV3IGNvbnRhaW5lclxuICAgICAgY29uc3QgcHJldmlld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogNTAlO1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBnYXA6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGFuIGltYWdlIHByZXZpZXcgZWxlbWVudFxuICAgICAgY29uc3QgY3JlYXRlSW1hZ2VQcmV2aWV3ID0gKGltYWdlRGF0YSwgbGFiZWwpID0+IHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEpIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlRGF0YTtcbiAgICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgICAgICBtYXgtaGVpZ2h0OiAyNDBweDtcbiAgICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW50IGxpc3RlbmVycyBmb3IgaW1hZ2UgbG9hZGluZ1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gY29uc29sZS5sb2coYCR7bGFiZWx9IGltYWdlIGxvYWRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoZSkgPT4gY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyAke2xhYmVsfSBpbWFnZTpgLCBlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRleHRMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZXh0TGFiZWwudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgICAgdGV4dExhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKHRleHRMYWJlbCk7XG4gICAgICAgIHJldHVybiBwcmV2aWV3O1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGRlYnVnIGluZm9cbiAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGVidWdJbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMzBweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgZGVidWdJbmZvLnRleHRDb250ZW50ID0gYFNjcmVlbjogJHtzY3JlZW5JbWFnZSA/ICdZRVMnIDogJ05PJ30sIFdlYmNhbTogJHt3ZWJjYW1JbWFnZSA/ICdZRVMnIDogJ05PJ31gO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChkZWJ1Z0luZm8pO1xuICAgICAgXG4gICAgICAvLyBBZGQgc2NyZWVuIGNhcHR1cmUgcHJldmlld1xuICAgICAgY29uc3Qgc2NyZWVuUHJldmlldyA9IGNyZWF0ZUltYWdlUHJldmlldyhzY3JlZW5JbWFnZSwgJ1NjcmVlbiBDYXB0dXJlJyk7XG4gICAgICBpZiAoc2NyZWVuUHJldmlldykge1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHNjcmVlblByZXZpZXcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgd2ViY2FtIGNhcHR1cmUgcHJldmlld1xuICAgICAgY29uc3Qgd2ViY2FtUHJldmlldyA9IGNyZWF0ZUltYWdlUHJldmlldyh3ZWJjYW1JbWFnZSwgJ1dlYmNhbSBDYXB0dXJlJyk7XG4gICAgICBpZiAod2ViY2FtUHJldmlldykge1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgZG90IHBvc2l0aW9uIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgICBpZiAoZG90UG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHBvc2l0aW9uSW5mby50ZXh0Q29udGVudCA9IGBEb3QgcG9zaXRpb246IHg9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLngpfSwgeT0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueSl9YDtcbiAgICAgICAgcG9zaXRpb25JbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICB0b3A6IC01MHB4O1xuICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvc2l0aW9uSW5mbyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCB0aW1lciBjb3VudGRvd25cbiAgICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJzIuMHMnO1xuICAgICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm90dG9tOiAtMjVweDtcbiAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCB0aGUgcHJldmlldyB0byB0aGUgZG9jdW1lbnRcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IGNvdW50ZG93biB0aW1lclxuICAgICAgbGV0IHRpbWVMZWZ0ID0gMi4wO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICAgICAgaWYgKHRpbWVMZWZ0IDw9IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAvLyBGYWRlIG91dFxuICAgICAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgXG4gICAgICAvLyBTYWZldHkgY2xlYW51cCBhZnRlciA1IHNlY29uZHMgaW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICBcbiAgICAvLyBUYWtlIGEgd2ViY2FtIHBpY3R1cmUgYW5kIGltbWVkaWF0ZWx5IHN0b3AgdGhlIHN0cmVhbVxuICAgIGFzeW5jIGNhcHR1cmVXZWJjYW1JbWFnZShjYXB0dXJlTnVtYmVyKSB7XG4gICAgICBsZXQgc3RyZWFtID0gbnVsbDtcbiAgICAgIGxldCB0ZW1wVmlkZW8gPSBudWxsO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBGb3JtYXQgdGhlIGZpbGVuYW1lIHdpdGggdGhlIGN1cnJlbnQgY291bnRlclxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGB3ZWJjYW1fJHtTdHJpbmcoY2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYDtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdHJlYW0gd2l0aCBoaWdoIHJlc29sdXRpb24gY29uc3RyYWludHNcbiAgICAgICAgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICB3aWR0aDogeyBpZGVhbDogNDA5NiB9LFxuICAgICAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiAyMTYwIH0sXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiBcInVzZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHZpZGVvIGVsZW1lbnRcbiAgICAgICAgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgICAgIHRlbXBWaWRlby5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb25uZWN0IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50XG4gICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB2aWRlbyB0byBpbml0aWFsaXplXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWaWRlbyBsb2FkaW5nIHRpbWVkIG91dCwgY29udGludWluZyBhbnl3YXlcIik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGEgY2xlYXIgZnJhbWVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGFjdHVhbCB2aWRlbyBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IHZpZGVvV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCA2NDA7XG4gICAgICAgIGNvbnN0IHZpZGVvSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBhdCByZXNvbHV0aW9uOiAke3ZpZGVvV2lkdGh9eCR7dmlkZW9IZWlnaHR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBmcmFtZSBhdCBmdWxsIHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdmlkZW9XaWR0aDtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB2aWRlb0hlaWdodDtcbiAgICAgICAgY29uc3QgY3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRlbXBWaWRlbywgMCwgMCwgdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCB0byBKUEVHIHdpdGggaGlnaCBxdWFsaXR5XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC45NSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTYXZlIHRoZSBpbWFnZVxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGltYWdlRGF0YSwgZmlsZW5hbWUsICd3ZWJjYW0nLCB0aGlzLmNhcHR1cmVGb2xkZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYXB0dXJpbmcgd2ViY2FtIGltYWdlOicsIGVycm9yKTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBWaWRlbykge1xuICAgICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyBDYXB0dXJlIHNjcmVlbiBpbWFnZSBmcm9tIGNhbnZhc1xuICAgIGFzeW5jIGNhcHR1cmVTY3JlZW5JbWFnZShjYW52YXNSZWYsIGNhcHR1cmVOdW1iZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHNjcmVlbl8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbFwiKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGE6IG51bGwsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdGhlIGltYWdlXG4gICAgICAgIGlmICh0aGlzLnNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgY29uc3Qgc2F2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlcihpbWFnZURhdGEsIGZpbGVuYW1lLCAnc2NyZWVuJywgdGhpcy5jYXB0dXJlRm9sZGVyKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgc2NyZWVuIGltYWdlOiAke2ZpbGVuYW1lfSwgcmVzcG9uc2U6YCwgc2F2ZVJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGEsIHNhdmVSZXNwb25zZSB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBpbWFnZURhdGEsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhcHR1cmluZyBzY3JlZW4gaW1hZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgaW1hZ2VEYXRhOiBudWxsLCBzYXZlUmVzcG9uc2U6IG51bGwgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXIgQ1NWXG4gICAgYXN5bmMgc2F2ZVBhcmFtZXRlckNTVihjYXB0dXJlTnVtYmVyLCBwYXJhbXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHBhcmFtZXRlcl8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5jc3ZgO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIENTViBjb250ZW50IHdpdGggdHdvIGNvbHVtbnM6IG5hbWUgYW5kIHZhbHVlXG4gICAgICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IGAke25hbWV9LCR7dmFsdWV9YClcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgQ1NWIHRvIGRhdGEgVVJMXG4gICAgICAgIGNvbnN0IGNzdkJsb2IgPSBuZXcgQmxvYihbY3N2RGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgICAgY29uc3QgY3N2UmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNzdlJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKGNzdlJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIGNzdlJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgQ1NWIHVzaW5nIHRoZSBBUElcbiAgICAgICAgaWYgKHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICBjb25zdCBzYXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGNzdkRhdGFVcmwsIGZpbGVuYW1lLCAncGFyYW1ldGVycycsIHRoaXMuY2FwdHVyZUZvbGRlcik7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHBhcmFtZXRlciBDU1Y6ICR7ZmlsZW5hbWV9YCk7XG4gICAgICAgICAgcmV0dXJuIHNhdmVSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGNhdGNoIChjc3ZFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHBhcmFtZXRlciBDU1Y6XCIsIGNzdkVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyBNYWluIGNhcHR1cmUgYW5kIHNob3cgcHJvY2Vzc1xuICAgIGFzeW5jIGNhcHR1cmVBbmRTaG93UHJldmlldyhjYXB0dXJlQ291bnRlciwgY2FudmFzUmVmLCBwb3NpdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgcHJvY2VzcyB3aXRoIGNvdW50ZXI6ICR7Y2FwdHVyZUNvdW50ZXJ9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDE6IENhcHR1cmUgc2NyZWVuIGltYWdlXG4gICAgICAgIGNvbnN0IHsgaW1hZ2VEYXRhOiBzY3JlZW5JbWFnZSwgc2F2ZVJlc3BvbnNlOiBzY3JlZW5SZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5jYXB0dXJlU2NyZWVuSW1hZ2UoY2FudmFzUmVmLCBjYXB0dXJlQ291bnRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIGNhcHR1cmUgbnVtYmVyIGZyb20gdGhlIHJlc3BvbnNlIGlmIGF2YWlsYWJsZSAoZm9yIGNvbnRpbnVvdXMgbnVtYmVyaW5nKVxuICAgICAgICBsZXQgdXNlZENhcHR1cmVOdW1iZXIgPSBjYXB0dXJlQ291bnRlcjtcbiAgICAgICAgaWYgKHNjcmVlblJlc3BvbnNlICYmIHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgICB1c2VkQ2FwdHVyZU51bWJlciA9IHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXI7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNlcnZlciBhc3NpZ25lZCBjYXB0dXJlIG51bWJlcjogJHt1c2VkQ2FwdHVyZU51bWJlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAyOiBDYXB0dXJlIHdlYmNhbSBpbWFnZSAoYW5kIGltbWVkaWF0ZWx5IHN0b3Agc3RyZWFtKVxuICAgICAgICBjb25zdCB3ZWJjYW1TdWNjZXNzID0gYXdhaXQgdGhpcy5jYXB0dXJlV2ViY2FtSW1hZ2UodXNlZENhcHR1cmVOdW1iZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAzOiBTYXZlIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIGRvdF94OiBwb3NpdGlvbiA/IHBvc2l0aW9uLnggOiAwLFxuICAgICAgICAgIGRvdF95OiBwb3NpdGlvbiA/IHBvc2l0aW9uLnkgOiAwLFxuICAgICAgICAgIGNhbnZhc193aWR0aDogY2FudmFzUmVmLmN1cnJlbnQgPyBjYW52YXNSZWYuY3VycmVudC53aWR0aCA6IDAsXG4gICAgICAgICAgY2FudmFzX2hlaWdodDogY2FudmFzUmVmLmN1cnJlbnQgPyBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgOiAwLFxuICAgICAgICAgIHdpbmRvd193aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgd2luZG93X2hlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVQYXJhbWV0ZXJDU1YodXNlZENhcHR1cmVOdW1iZXIsIHBhcmFtcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDQ6IEluY3JlbWVudCBjb3VudGVyIGZvciBuZXh0IGNhcHR1cmVcbiAgICAgICAgaWYgKHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGlzIG1hbmFnaW5nIG51bWJlcmluZywgdXNlIHRoZSBuZXh0IG51bWJlclxuICAgICAgICAgIGlmIChzY3JlZW5SZXNwb25zZSAmJiBzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgNTogVXBkYXRlIHN0YXR1c1xuICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlZCB3aXRoIGRvdCBhdDogeD0ke3Bvc2l0aW9uPy54fSwgeT0ke3Bvc2l0aW9uPy55fWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDY6IFNob3cgcHJldmlldyB1c2luZyB0aGUgaW4tbWVtb3J5IGltYWdlIGRhdGFcbiAgICAgICAgdGhpcy5zaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbVN1Y2Nlc3MgPyAnd2ViY2FtX2ltYWdlX2RhdGEnIDogbnVsbCwgcG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA3OiBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBwcmV2aWV3IGlzIGRvbmVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjIwMCk7IC8vIFdhaXQgbG9uZ2VyIHRoYW4gdGhlIHByZXZpZXcgZHVyYXRpb25cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgODogQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlIGFuZCBwcmV2aWV3OicsIGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGVycm9yIG1lc3NhZ2UgYWZ0ZXIgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgZXhwb3J0IGRlZmF1bHQgQ2FwdHVyZUhhbmRsZXI7Il0sIm5hbWVzIjpbIkNhcHR1cmVIYW5kbGVyIiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImRvdFBvc2l0aW9uIiwicHJldmlld0NvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImNyZWF0ZUltYWdlUHJldmlldyIsImltYWdlRGF0YSIsImxhYmVsIiwicHJldmlldyIsImltZyIsInNyYyIsIm9ubG9hZCIsImNvbnNvbGUiLCJsb2ciLCJvbmVycm9yIiwiZSIsImVycm9yIiwidGV4dExhYmVsIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsImRlYnVnSW5mbyIsInNjcmVlblByZXZpZXciLCJ3ZWJjYW1QcmV2aWV3IiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwieCIsInkiLCJ0aW1lckVsZW1lbnQiLCJib2R5IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9wYWNpdHkiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9GaXhlZCIsImNhcHR1cmVXZWJjYW1JbWFnZSIsImNhcHR1cmVOdW1iZXIiLCJzdHJlYW0iLCJ0ZW1wVmlkZW8iLCJmaWxlbmFtZSIsIlN0cmluZyIsInBhZFN0YXJ0IiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwidmlkZW8iLCJ3aWR0aCIsImlkZWFsIiwiaGVpZ2h0IiwiZmFjaW5nTW9kZSIsImF1ZGlvIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwicG9zaXRpb24iLCJsZWZ0Iiwic3JjT2JqZWN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aW1lb3V0SWQiLCJ3YXJuIiwib25sb2FkZWRkYXRhIiwiY2xlYXJUaW1lb3V0IiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwidGVtcENhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJzYXZlSW1hZ2VUb1NlcnZlciIsImNhcHR1cmVGb2xkZXIiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdG9wIiwicmVtb3ZlIiwiY2FwdHVyZVNjcmVlbkltYWdlIiwiY2FudmFzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsInNhdmVSZXNwb25zZSIsInNhdmVQYXJhbWV0ZXJDU1YiLCJwYXJhbXMiLCJjc3ZEYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsIm5hbWUiLCJ2YWx1ZSIsImpvaW4iLCJjc3ZCbG9iIiwiQmxvYiIsInR5cGUiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJjc3ZFcnJvciIsImNhcHR1cmVBbmRTaG93UHJldmlldyIsImNhcHR1cmVDb3VudGVyIiwic2NyZWVuUmVzcG9uc2UiLCJ1c2VkQ2FwdHVyZU51bWJlciIsIndlYmNhbVN1Y2Nlc3MiLCJkb3RfeCIsImRvdF95IiwiY2FudmFzX3dpZHRoIiwiY2FudmFzX2hlaWdodCIsIndpbmRvd193aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJ3aW5kb3dfaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzZXRDYXB0dXJlQ291bnRlciIsInByZXYiLCJzZXRQcm9jZXNzU3RhdHVzIiwidG9nZ2xlVG9wQmFyIiwibWVzc2FnZSIsImNvbnN0cnVjdG9yIiwic2F2ZUZ1bmN0aW9uIiwiY291bnRlclNldHRlciIsInN0YXR1c1NldHRlciIsInRvZ2dsZVRvcEJhckZ1bmN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset/Action/CaptureHandler.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset/Action/DotCaptureUtil.js":
/*!***************************************************************!*\
  !*** ./components/collected-dataset/Action/DotCaptureUtil.js ***!
  \***************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDotCountdown: () => (/* binding */ createDotCountdown),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   showImagePreview: () => (/* binding */ showImagePreview)\n/* harmony export */ });\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Show preview of captured images for exactly 2 seconds\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Improved function to show preview of captured images for exactly 2 seconds\nconst showImagePreview = (screenImage, webcamImage, dotPosition)=>{\n    // Create a preview container that centers in the screen\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n      position: fixed;\\n      top: 50%;\\n      left: 50%;\\n      transform: translate(-50%, -50%);\\n      display: flex;\\n      gap: 20px;\\n      background-color: rgba(0, 0, 0, 0.85);\\n      padding: 20px;\\n      border-radius: 12px;\\n      z-index: 9999;\\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n      opacity: 1;\\n      transition: opacity 0.2s ease-in-out;\\n    \";\n    // Add screen capture preview if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.style.cssText = \"\\n        max-width: 350px;\\n        max-height: 250px;\\n        border: 3px solid white;\\n        border-radius: 8px;\\n      \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n        color: white;\\n        font-size: 14px;\\n        margin-top: 10px;\\n        font-weight: bold;\\n      \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam capture preview if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n        display: flex;\\n        flex-direction: column;\\n        align-items: center;\\n      \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.style.cssText = \"\\n        max-width: 350px;\\n        max-height: 250px;\\n        border: 3px solid white;\\n        border-radius: 8px;\\n      \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n        color: white;\\n        font-size: 14px;\\n        margin-top: 10px;\\n        font-weight: bold;\\n      \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = \"Dot position: x=\".concat(Math.round(dotPosition.x), \", y=\").concat(Math.round(dotPosition.y));\n        positionInfo.style.cssText = \"\\n        color: #ffcc00;\\n        font-size: 14px;\\n        position: absolute;\\n        top: -25px;\\n        left: 0;\\n        width: 100%;\\n        text-align: center;\\n      \";\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add timer countdown\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n      position: absolute;\\n      bottom: -25px;\\n      right: 20px;\\n      color: white;\\n      font-size: 12px;\\n      background-color: rgba(0, 0, 0, 0.7);\\n      padding: 3px 8px;\\n      border-radius: 4px;\\n    \";\n    previewContainer.appendChild(timerElement);\n    // Add the preview to the document\n    document.body.appendChild(previewContainer);\n    // Start countdown timer\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            timerElement.textContent = 'Closing...';\n            // Fade out the preview\n            previewContainer.style.opacity = '0';\n            // Remove after fade animation\n            setTimeout(()=>{\n                if (previewContainer && previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 200);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    return previewContainer;\n};\n// Other utility functions remain the same...\n// Create and append a countdown element above a dot\nconst createDotCountdown = (position, canvasRect)=>{\n    // Create the countdown element directly above the dot\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'forced-countdown';\n    // Position it above the dot (calculate absolute position considering the canvas position)\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(absoluteX, \"px;\\n      top: \").concat(absoluteY - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n// Draw a red dot on the canvas\nconst drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12;\n    // Draw the dot with a glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect to the dot\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n// Initialize the canvas for drawing\nconst initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n// Generate a random position on the canvas\nconst getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQvQWN0aW9uL0RvdENhcHR1cmVVdGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsb0JBQW9CO0FBQ3BCLHdEQUF3RDtBQUV4RCx3REFBd0Q7QUFDeEQsb0JBQW9CO0FBQ3BCLHdEQUF3RDtBQUV4RCw2RUFBNkU7QUFDdEUsTUFBTUEsbUJBQW1CLENBQUNDLGFBQWFDLGFBQWFDO0lBQ3ZELHdEQUF3RDtJQUN4RCxNQUFNQyxtQkFBbUJDLFNBQVNDLGFBQWEsQ0FBQztJQUNoREYsaUJBQWlCRyxTQUFTLEdBQUc7SUFDN0JILGlCQUFpQkksS0FBSyxDQUFDQyxPQUFPLEdBQUk7SUFnQmxDLDBDQUEwQztJQUMxQyxJQUFJUixhQUFhO1FBQ2YsTUFBTVMsZ0JBQWdCTCxTQUFTQyxhQUFhLENBQUM7UUFDN0NJLGNBQWNGLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBTS9CLE1BQU1FLFlBQVlOLFNBQVNDLGFBQWEsQ0FBQztRQUN6Q0ssVUFBVUMsR0FBRyxHQUFHWDtRQUNoQlUsVUFBVUgsS0FBSyxDQUFDQyxPQUFPLEdBQUk7UUFPM0IsTUFBTUksY0FBY1IsU0FBU0MsYUFBYSxDQUFDO1FBQzNDTyxZQUFZQyxXQUFXLEdBQUc7UUFDMUJELFlBQVlMLEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBTzdCQyxjQUFjSyxXQUFXLENBQUNKO1FBQzFCRCxjQUFjSyxXQUFXLENBQUNGO1FBQzFCVCxpQkFBaUJXLFdBQVcsQ0FBQ0w7SUFDL0I7SUFFQSwwQ0FBMEM7SUFDMUMsSUFBSVIsYUFBYTtRQUNmLE1BQU1jLGdCQUFnQlgsU0FBU0MsYUFBYSxDQUFDO1FBQzdDVSxjQUFjUixLQUFLLENBQUNDLE9BQU8sR0FBSTtRQU0vQixNQUFNUSxZQUFZWixTQUFTQyxhQUFhLENBQUM7UUFDekNXLFVBQVVMLEdBQUcsR0FBR1Y7UUFDaEJlLFVBQVVULEtBQUssQ0FBQ0MsT0FBTyxHQUFJO1FBTzNC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LG1CQUFtQixDQUFDQyxRQUFRQztJQUN2QyxJQUFJLENBQUNELFVBQVUsQ0FBQ0MsUUFBUSxPQUFPO0lBRS9CLHdDQUF3QztJQUN4Q0QsT0FBT0UsS0FBSyxHQUFHRCxPQUFPRSxXQUFXO0lBQ2pDSCxPQUFPSSxNQUFNLEdBQUdILE9BQU9JLFlBQVk7SUFFbkMsd0NBQXdDO0lBQ3hDLE1BQU1oQixNQUFNVyxPQUFPTSxVQUFVLENBQUM7SUFDOUJqQixJQUFJa0IsU0FBUyxDQUFDLEdBQUcsR0FBR1AsT0FBT0UsS0FBSyxFQUFFRixPQUFPSSxNQUFNO0lBQy9DZixJQUFJSyxTQUFTLEdBQUc7SUFDaEJMLElBQUltQixRQUFRLENBQUMsR0FBRyxHQUFHUixPQUFPRSxLQUFLLEVBQUVGLE9BQU9JLE1BQU07SUFFOUMsT0FBTztBQUNULEVBQUU7QUFFRiwyQ0FBMkM7QUFDcEMsTUFBTUssb0JBQW9CLFNBQUNUO1FBQVFVLDJFQUFVO0lBQ2xELElBQUksQ0FBQ1YsUUFBUSxPQUFPO1FBQUVqQyxHQUFHO1FBQUtDLEdBQUc7SUFBSSxHQUFHLG9CQUFvQjtJQUU1RCxNQUFNa0MsUUFBUUYsT0FBT0UsS0FBSyxJQUFJLEtBQU0seUJBQXlCO0lBQzdELE1BQU1FLFNBQVNKLE9BQU9JLE1BQU0sSUFBSSxLQUFLLDBCQUEwQjtJQUUvRCxPQUFPO1FBQ0xyQyxHQUFHRixLQUFLOEMsS0FBSyxDQUFDOUMsS0FBSytDLE1BQU0sS0FBTVYsQ0FBQUEsUUFBUSxJQUFJUSxPQUFNLEtBQU1BO1FBQ3ZEMUMsR0FBR0gsS0FBSzhDLEtBQUssQ0FBQzlDLEtBQUsrQyxNQUFNLEtBQU1SLENBQUFBLFNBQVMsSUFBSU0sT0FBTSxLQUFNQTtJQUMxRDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC9BY3Rpb24vRG90Q2FwdHVyZVV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG90Q2FwdHVyZVV0aWwuanNcbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkb3QgY2FwdHVyZSBhbmQgcHJldmlldyBkaXNwbGF5XG5cbi8vIFNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXMgZm9yIGV4YWN0bHkgMiBzZWNvbmRzXG4vLyBEb3RDYXB0dXJlVXRpbC5qc1xuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRvdCBjYXB0dXJlIGFuZCBwcmV2aWV3IGRpc3BsYXlcblxuLy8gSW1wcm92ZWQgZnVuY3Rpb24gdG8gc2hvdyBwcmV2aWV3IG9mIGNhcHR1cmVkIGltYWdlcyBmb3IgZXhhY3RseSAyIHNlY29uZHNcbmV4cG9ydCBjb25zdCBzaG93SW1hZ2VQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgZG90UG9zaXRpb24pID0+IHtcbiAgICAvLyBDcmVhdGUgYSBwcmV2aWV3IGNvbnRhaW5lciB0aGF0IGNlbnRlcnMgaW4gdGhlIHNjcmVlblxuICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYXB0dXJlLXByZXZpZXctY29udGFpbmVyJztcbiAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGdhcDogMjBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1pbi1vdXQ7XG4gICAgYDtcbiAgICBcbiAgICAvLyBBZGQgc2NyZWVuIGNhcHR1cmUgcHJldmlldyBpZiBhdmFpbGFibGVcbiAgICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICAgIGNvbnN0IHNjcmVlblByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcmVlblByZXZpZXcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNjcmVlbkltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgc2NyZWVuSW1nLnNyYyA9IHNjcmVlbkltYWdlO1xuICAgICAgc2NyZWVuSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIG1heC13aWR0aDogMzUwcHg7XG4gICAgICAgIG1heC1oZWlnaHQ6IDI1MHB4O1xuICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgc2NyZWVuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcmVlbkxhYmVsLnRleHRDb250ZW50ID0gJ1NjcmVlbiBDYXB0dXJlJztcbiAgICAgIHNjcmVlbkxhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuSW1nKTtcbiAgICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuTGFiZWwpO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChzY3JlZW5QcmV2aWV3KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHdlYmNhbSBjYXB0dXJlIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3ZWJjYW1QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWJjYW1JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHdlYmNhbUltZy5zcmMgPSB3ZWJjYW1JbWFnZTtcbiAgICAgIHdlYmNhbUltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXgtd2lkdGg6IDM1MHB4O1xuICAgICAgICBtYXgtaGVpZ2h0OiAyNTBweDtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHdlYmNhbUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3ZWJjYW1MYWJlbC50ZXh0Q29udGVudCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgICB3ZWJjYW1MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUltZyk7XG4gICAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQod2ViY2FtUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkb3QgcG9zaXRpb24gaW5mbyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZG90UG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9zaXRpb25JbmZvLnRleHRDb250ZW50ID0gYERvdCBwb3NpdGlvbjogeD0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi55KX1gO1xuICAgICAgcG9zaXRpb25JbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMjVweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvc2l0aW9uSW5mbyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aW1lciBjb3VudGRvd25cbiAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IC0yNXB4O1xuICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgIFxuICAgIC8vIEFkZCB0aGUgcHJldmlldyB0byB0aGUgZG9jdW1lbnRcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNvdW50ZG93biB0aW1lclxuICAgIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnQ2xvc2luZy4uLic7XG4gICAgICAgIFxuICAgICAgICAvLyBGYWRlIG91dCB0aGUgcHJldmlld1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZSBhbmltYXRpb25cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIgJiYgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICAgIFxuICAgIHJldHVybiBwcmV2aWV3Q29udGFpbmVyO1xuICB9O1xuICBcbiAgLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnMgcmVtYWluIHRoZSBzYW1lLi4uXG4gICAgXG4gIC8vIENyZWF0ZSBhbmQgYXBwZW5kIGEgY291bnRkb3duIGVsZW1lbnQgYWJvdmUgYSBkb3RcbiAgZXhwb3J0IGNvbnN0IGNyZWF0ZURvdENvdW50ZG93biA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICAgIC8vIENyZWF0ZSB0aGUgY291bnRkb3duIGVsZW1lbnQgZGlyZWN0bHkgYWJvdmUgdGhlIGRvdFxuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdmb3JjZWQtY291bnRkb3duJztcbiAgICBcbiAgICAvLyBQb3NpdGlvbiBpdCBhYm92ZSB0aGUgZG90IChjYWxjdWxhdGUgYWJzb2x1dGUgcG9zaXRpb24gY29uc2lkZXJpbmcgdGhlIGNhbnZhcyBwb3NpdGlvbilcbiAgICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICAgIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcbiAgICBcbiAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICAgIHRvcDogJHthYnNvbHV0ZVkgLSA2MH1weDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgIGNvbG9yOiByZWQ7XG4gICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICBcbiAgICByZXR1cm4gY291bnRkb3duRWxlbWVudDtcbiAgfTtcbiAgXG4gIC8vIERyYXcgYSByZWQgZG90IG9uIHRoZSBjYW52YXNcbiAgZXhwb3J0IGNvbnN0IGRyYXdSZWREb3QgPSAoY3R4LCB4LCB5LCByYWRpdXMgPSAxMikgPT4ge1xuICAgIC8vIERyYXcgdGhlIGRvdCB3aXRoIGEgZ2xvdyBlZmZlY3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3QgdG8gdGhlIGRvdFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH07XG4gIFxuICAvLyBJbml0aWFsaXplIHRoZSBjYW52YXMgZm9yIGRyYXdpbmdcbiAgZXhwb3J0IGNvbnN0IGluaXRpYWxpemVDYW52YXMgPSAoY2FudmFzLCBwYXJlbnQpID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhcGFyZW50KSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHBhcmVudFxuICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciBjYW52YXMgYW5kIHNldCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgLy8gR2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb24gb24gdGhlIGNhbnZhc1xuICBleHBvcnQgY29uc3QgZ2V0UmFuZG9tUG9zaXRpb24gPSAoY2FudmFzLCBwYWRkaW5nID0gNDApID0+IHtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIHsgeDogMTAwLCB5OiAxMDAgfTsgLy8gRmFsbGJhY2sgcG9zaXRpb25cbiAgICBcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCB8fCA0MDA7ICAvLyBGYWxsYmFjayBpZiB3aWR0aCBpcyAwXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCB8fCAzMDA7IC8vIEZhbGxiYWNrIGlmIGhlaWdodCBpcyAwXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh3aWR0aCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nLFxuICAgICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nXG4gICAgfTtcbiAgfTsiXSwibmFtZXMiOlsic2hvd0ltYWdlUHJldmlldyIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJkb3RQb3NpdGlvbiIsInByZXZpZXdDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJzY3JlZW5QcmV2aWV3Iiwic2NyZWVuSW1nIiwic3JjIiwic2NyZWVuTGFiZWwiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwid2ViY2FtUHJldmlldyIsIndlYmNhbUltZyIsIndlYmNhbUxhYmVsIiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwieCIsInkiLCJ0aW1lckVsZW1lbnQiLCJib2R5IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9wYWNpdHkiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9GaXhlZCIsImNyZWF0ZURvdENvdW50ZG93biIsInBvc2l0aW9uIiwiY2FudmFzUmVjdCIsImNvdW50ZG93bkVsZW1lbnQiLCJhYnNvbHV0ZVgiLCJsZWZ0IiwiYWJzb2x1dGVZIiwidG9wIiwiZHJhd1JlZERvdCIsImN0eCIsInJhZGl1cyIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImNhbnZhcyIsInBhcmVudCIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0IiwiZmlsbFJlY3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsInBhZGRpbmciLCJmbG9vciIsInJhbmRvbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset/Action/DotCaptureUtil.js\n"));

/***/ })

}]);