/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/collected-dataset-customized"],{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js":
/*!***************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CalibratePoints.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawCalibrationGrid: () => (/* binding */ drawCalibrationGrid),\n/* harmony export */   drawCalibrationPoint: () => (/* binding */ drawCalibrationPoint),\n/* harmony export */   generateCalibrationPoints: () => (/* binding */ generateCalibrationPoints)\n/* harmony export */ });\n// CalibratePoints.js\n// Utility for generating and managing calibration points on a canvas\n/**\n * Generate a grid of calibration points based on canvas dimensions\n * @param {number} width - Canvas width\n * @param {number} height - Canvas height\n * @returns {Array} Array of point objects with x,y coordinates\n */ const generateCalibrationPoints = (width, height)=>{\n    if (!width || !height || width <= 0 || height <= 0) {\n        console.error(\"generateCalibrationPoints: Invalid canvas dimensions\", {\n            width,\n            height\n        });\n        return [];\n    }\n    const conditionalRound = (dimension, percentage)=>Math.round(dimension * percentage);\n    // Outer frame (12% from edges)\n    const xLeftOuter = conditionalRound(width, 0.12);\n    const xRightOuter = width - xLeftOuter;\n    const yTopOuter = conditionalRound(height, 0.12);\n    const yBottomOuter = height - yTopOuter;\n    // Inner frame (26% from edges)\n    const xLeftInner = conditionalRound(width, 0.26);\n    const xRightInner = width - xLeftInner;\n    const yTopInner = conditionalRound(height, 0.26);\n    const yBottomInner = height - yTopInner;\n    const xCenter = Math.floor(width / 2);\n    const yCenter = Math.floor(height / 2);\n    return [\n        // Outer frame (8 points)\n        {\n            x: xLeftOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopOuter,\n            label: \"Outer Top-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yCenter,\n            label: \"Outer Middle-Left\"\n        },\n        {\n            x: xRightOuter,\n            y: yCenter,\n            label: \"Outer Middle-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Right\"\n        },\n        // Inner frame (8 points)\n        {\n            x: xLeftInner,\n            y: yTopInner,\n            label: \"Inner Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopInner,\n            label: \"Inner Top-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yTopInner,\n            label: \"Inner Top-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yCenter,\n            label: \"Inner Middle-Left\"\n        },\n        {\n            x: xRightInner,\n            y: yCenter,\n            label: \"Inner Middle-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomInner,\n            label: \"Inner Bottom-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Right\"\n        }\n    ];\n};\n/**\n * Draw a calibration point on a canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {Object} options - Optional settings (color, radius)\n * @returns {Object} Point position object {x, y}\n */ const drawCalibrationPoint = function(canvas, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (!canvas) return {\n        x,\n        y\n    };\n    const ctx = canvas.getContext('2d');\n    const color = options.color || 'red';\n    const radius = options.radius || 8;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = color;\n    ctx.fill();\n    // Glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * Draw all calibration points on a canvas (for debugging/visualization)\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Array} points - Array of point objects\n * @param {number} activeIndex - Index of the currently active point\n */ const drawCalibrationGrid = function(canvas, points) {\n    let activeIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;\n    if (!canvas || !points || !points.length) return;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    points.forEach((point, index)=>{\n        const isActive = index === activeIndex;\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, isActive ? 8 : 4, 0, Math.PI * 2);\n        ctx.fillStyle = isActive ? 'red' : 'rgba(0, 102, 204, 0.7)';\n        ctx.fill();\n        ctx.fillStyle = 'black';\n        ctx.font = '10px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(\"\".concat(index + 1), point.x, point.y);\n        if (isActive && point.label) {\n            ctx.font = '12px Arial';\n            ctx.fillText(point.label, point.x, point.y - 20);\n        }\n    });\n    // Draw connecting lines (optional)\n    ctx.beginPath();\n    ctx.moveTo(points[0].x, points[0].y);\n    for(let i = 1; i < points.length; i++){\n        ctx.lineTo(points[i].x, points[i].y);\n    }\n    ctx.strokeStyle = 'rgba(0, 102, 204, 0.3)';\n    ctx.lineWidth = 1;\n    ctx.stroke();\n};\n// Optional: Default export all for convenience\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    generateCalibrationPoints,\n    drawCalibrationPoint,\n    drawCalibrationGrid\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDckIscUVBQXFFO0FBRXJFOzs7OztDQUtDLEdBQ00sTUFBTUEsNEJBQTRCLENBQUNDLE9BQU9DO0lBQy9DLElBQUksQ0FBQ0QsU0FBUyxDQUFDQyxVQUFVRCxTQUFTLEtBQUtDLFVBQVUsR0FBRztRQUNsREMsUUFBUUMsS0FBSyxDQUFDLHdEQUF3RDtZQUFFSDtZQUFPQztRQUFPO1FBQ3RGLE9BQU8sRUFBRTtJQUNYO0lBRUEsTUFBTUcsbUJBQW1CLENBQUNDLFdBQVdDLGFBQWVDLEtBQUtDLEtBQUssQ0FBQ0gsWUFBWUM7SUFFM0UsK0JBQStCO0lBQy9CLE1BQU1HLGFBQWFMLGlCQUFpQkosT0FBTztJQUMzQyxNQUFNVSxjQUFjVixRQUFRUztJQUM1QixNQUFNRSxZQUFZUCxpQkFBaUJILFFBQVE7SUFDM0MsTUFBTVcsZUFBZVgsU0FBU1U7SUFFOUIsK0JBQStCO0lBQy9CLE1BQU1FLGFBQWFULGlCQUFpQkosT0FBTztJQUMzQyxNQUFNYyxjQUFjZCxRQUFRYTtJQUM1QixNQUFNRSxZQUFZWCxpQkFBaUJILFFBQVE7SUFDM0MsTUFBTWUsZUFBZWYsU0FBU2M7SUFFOUIsTUFBTUUsVUFBVVYsS0FBS1csS0FBSyxDQUFDbEIsUUFBUTtJQUNuQyxNQUFNbUIsVUFBVVosS0FBS1csS0FBSyxDQUFDakIsU0FBUztJQUVwQyxPQUFPO1FBQ0wseUJBQXlCO1FBQ3pCO1lBQUVtQixHQUFHWDtZQUFZWSxHQUFHVjtZQUFXVyxPQUFPO1FBQWlCO1FBQ3ZEO1lBQUVGLEdBQUdIO1lBQVNJLEdBQUdWO1lBQVdXLE9BQU87UUFBbUI7UUFDdEQ7WUFBRUYsR0FBR1Y7WUFBYVcsR0FBR1Y7WUFBV1csT0FBTztRQUFrQjtRQUN6RDtZQUFFRixHQUFHWDtZQUFZWSxHQUFHRjtZQUFTRyxPQUFPO1FBQW9CO1FBQ3hEO1lBQUVGLEdBQUdWO1lBQWFXLEdBQUdGO1lBQVNHLE9BQU87UUFBcUI7UUFDMUQ7WUFBRUYsR0FBR1g7WUFBWVksR0FBR1Q7WUFBY1UsT0FBTztRQUFvQjtRQUM3RDtZQUFFRixHQUFHSDtZQUFTSSxHQUFHVDtZQUFjVSxPQUFPO1FBQXNCO1FBQzVEO1lBQUVGLEdBQUdWO1lBQWFXLEdBQUdUO1lBQWNVLE9BQU87UUFBcUI7UUFFL0QseUJBQXlCO1FBQ3pCO1lBQUVGLEdBQUdQO1lBQVlRLEdBQUdOO1lBQVdPLE9BQU87UUFBaUI7UUFDdkQ7WUFBRUYsR0FBR0g7WUFBU0ksR0FBR047WUFBV08sT0FBTztRQUFtQjtRQUN0RDtZQUFFRixHQUFHTjtZQUFhTyxHQUFHTjtZQUFXTyxPQUFPO1FBQWtCO1FBQ3pEO1lBQUVGLEdBQUdQO1lBQVlRLEdBQUdGO1lBQVNHLE9BQU87UUFBb0I7UUFDeEQ7WUFBRUYsR0FBR047WUFBYU8sR0FBR0Y7WUFBU0csT0FBTztRQUFxQjtRQUMxRDtZQUFFRixHQUFHUDtZQUFZUSxHQUFHTDtZQUFjTSxPQUFPO1FBQW9CO1FBQzdEO1lBQUVGLEdBQUdIO1lBQVNJLEdBQUdMO1lBQWNNLE9BQU87UUFBc0I7UUFDNUQ7WUFBRUYsR0FBR047WUFBYU8sR0FBR0w7WUFBY00sT0FBTztRQUFxQjtLQUNoRTtBQUNILEVBQUU7QUFFRjs7Ozs7OztDQU9DLEdBQ00sTUFBTUMsdUJBQXVCLFNBQUNDLFFBQVFKLEdBQUdDO1FBQUdJLDJFQUFVLENBQUM7SUFDNUQsSUFBSSxDQUFDRCxRQUFRLE9BQU87UUFBRUo7UUFBR0M7SUFBRTtJQUUzQixNQUFNSyxNQUFNRixPQUFPRyxVQUFVLENBQUM7SUFDOUIsTUFBTUMsUUFBUUgsUUFBUUcsS0FBSyxJQUFJO0lBQy9CLE1BQU1DLFNBQVNKLFFBQVFJLE1BQU0sSUFBSTtJQUVqQ0gsSUFBSUksU0FBUyxDQUFDLEdBQUcsR0FBR04sT0FBT3hCLEtBQUssRUFBRXdCLE9BQU92QixNQUFNO0lBQy9DeUIsSUFBSUssU0FBUyxHQUFHO0lBQ2hCTCxJQUFJTSxRQUFRLENBQUMsR0FBRyxHQUFHUixPQUFPeEIsS0FBSyxFQUFFd0IsT0FBT3ZCLE1BQU07SUFFOUN5QixJQUFJTyxTQUFTO0lBQ2JQLElBQUlRLEdBQUcsQ0FBQ2QsR0FBR0MsR0FBR1EsUUFBUSxHQUFHdEIsS0FBSzRCLEVBQUUsR0FBRztJQUNuQ1QsSUFBSUssU0FBUyxHQUFHSDtJQUNoQkYsSUFBSVUsSUFBSTtJQUVSLGNBQWM7SUFDZFYsSUFBSU8sU0FBUztJQUNiUCxJQUFJUSxHQUFHLENBQUNkLEdBQUdDLEdBQUdRLFNBQVMsR0FBRyxHQUFHdEIsS0FBSzRCLEVBQUUsR0FBRztJQUN2Q1QsSUFBSVcsV0FBVyxHQUFHO0lBQ2xCWCxJQUFJWSxTQUFTLEdBQUc7SUFDaEJaLElBQUlhLE1BQU07SUFFVixPQUFPO1FBQUVuQjtRQUFHQztJQUFFO0FBQ2hCLEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNNLE1BQU1tQixzQkFBc0IsU0FBQ2hCLFFBQVFpQjtRQUFRQywrRUFBYyxDQUFDO0lBQ2pFLElBQUksQ0FBQ2xCLFVBQVUsQ0FBQ2lCLFVBQVUsQ0FBQ0EsT0FBT0UsTUFBTSxFQUFFO0lBRTFDLE1BQU1qQixNQUFNRixPQUFPRyxVQUFVLENBQUM7SUFDOUJELElBQUlJLFNBQVMsQ0FBQyxHQUFHLEdBQUdOLE9BQU94QixLQUFLLEVBQUV3QixPQUFPdkIsTUFBTTtJQUMvQ3lCLElBQUlLLFNBQVMsR0FBRztJQUNoQkwsSUFBSU0sUUFBUSxDQUFDLEdBQUcsR0FBR1IsT0FBT3hCLEtBQUssRUFBRXdCLE9BQU92QixNQUFNO0lBRTlDd0MsT0FBT0csT0FBTyxDQUFDLENBQUNDLE9BQU9DO1FBQ3JCLE1BQU1DLFdBQVdELFVBQVVKO1FBRTNCaEIsSUFBSU8sU0FBUztRQUNiUCxJQUFJUSxHQUFHLENBQUNXLE1BQU16QixDQUFDLEVBQUV5QixNQUFNeEIsQ0FBQyxFQUFFMEIsV0FBVyxJQUFJLEdBQUcsR0FBR3hDLEtBQUs0QixFQUFFLEdBQUc7UUFDekRULElBQUlLLFNBQVMsR0FBR2dCLFdBQVcsUUFBUTtRQUNuQ3JCLElBQUlVLElBQUk7UUFFUlYsSUFBSUssU0FBUyxHQUFHO1FBQ2hCTCxJQUFJc0IsSUFBSSxHQUFHO1FBQ1h0QixJQUFJdUIsU0FBUyxHQUFHO1FBQ2hCdkIsSUFBSXdCLFlBQVksR0FBRztRQUNuQnhCLElBQUl5QixRQUFRLENBQUMsR0FBYSxPQUFWTCxRQUFRLElBQUtELE1BQU16QixDQUFDLEVBQUV5QixNQUFNeEIsQ0FBQztRQUU3QyxJQUFJMEIsWUFBWUYsTUFBTXZCLEtBQUssRUFBRTtZQUMzQkksSUFBSXNCLElBQUksR0FBRztZQUNYdEIsSUFBSXlCLFFBQVEsQ0FBQ04sTUFBTXZCLEtBQUssRUFBRXVCLE1BQU16QixDQUFDLEVBQUV5QixNQUFNeEIsQ0FBQyxHQUFHO1FBQy9DO0lBQ0Y7SUFFQSxtQ0FBbUM7SUFDbkNLLElBQUlPLFNBQVM7SUFDYlAsSUFBSTBCLE1BQU0sQ0FBQ1gsTUFBTSxDQUFDLEVBQUUsQ0FBQ3JCLENBQUMsRUFBRXFCLE1BQU0sQ0FBQyxFQUFFLENBQUNwQixDQUFDO0lBQ25DLElBQUssSUFBSWdDLElBQUksR0FBR0EsSUFBSVosT0FBT0UsTUFBTSxFQUFFVSxJQUFLO1FBQ3RDM0IsSUFBSTRCLE1BQU0sQ0FBQ2IsTUFBTSxDQUFDWSxFQUFFLENBQUNqQyxDQUFDLEVBQUVxQixNQUFNLENBQUNZLEVBQUUsQ0FBQ2hDLENBQUM7SUFDckM7SUFDQUssSUFBSVcsV0FBVyxHQUFHO0lBQ2xCWCxJQUFJWSxTQUFTLEdBQUc7SUFDaEJaLElBQUlhLE1BQU07QUFDWixFQUFFO0FBRUYsK0NBQStDO0FBQy9DLGlFQUFlO0lBQ2J4QztJQUNBd0I7SUFDQWlCO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlUG9pbnRzLmpzXG4vLyBVdGlsaXR5IGZvciBnZW5lcmF0aW5nIGFuZCBtYW5hZ2luZyBjYWxpYnJhdGlvbiBwb2ludHMgb24gYSBjYW52YXNcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGdyaWQgb2YgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIGNhbnZhcyBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBDYW52YXMgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBDYW52YXMgaGVpZ2h0XG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHBvaW50IG9iamVjdHMgd2l0aCB4LHkgY29vcmRpbmF0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQgfHwgd2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzOiBJbnZhbGlkIGNhbnZhcyBkaW1lbnNpb25zXCIsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjb25kaXRpb25hbFJvdW5kID0gKGRpbWVuc2lvbiwgcGVyY2VudGFnZSkgPT4gTWF0aC5yb3VuZChkaW1lbnNpb24gKiBwZXJjZW50YWdlKTtcblxuICAvLyBPdXRlciBmcmFtZSAoMTIlIGZyb20gZWRnZXMpXG4gIGNvbnN0IHhMZWZ0T3V0ZXIgPSBjb25kaXRpb25hbFJvdW5kKHdpZHRoLCAwLjEyKTtcbiAgY29uc3QgeFJpZ2h0T3V0ZXIgPSB3aWR0aCAtIHhMZWZ0T3V0ZXI7XG4gIGNvbnN0IHlUb3BPdXRlciA9IGNvbmRpdGlvbmFsUm91bmQoaGVpZ2h0LCAwLjEyKTtcbiAgY29uc3QgeUJvdHRvbU91dGVyID0gaGVpZ2h0IC0geVRvcE91dGVyO1xuXG4gIC8vIElubmVyIGZyYW1lICgyNiUgZnJvbSBlZGdlcylcbiAgY29uc3QgeExlZnRJbm5lciA9IGNvbmRpdGlvbmFsUm91bmQod2lkdGgsIDAuMjYpO1xuICBjb25zdCB4UmlnaHRJbm5lciA9IHdpZHRoIC0geExlZnRJbm5lcjtcbiAgY29uc3QgeVRvcElubmVyID0gY29uZGl0aW9uYWxSb3VuZChoZWlnaHQsIDAuMjYpO1xuICBjb25zdCB5Qm90dG9tSW5uZXIgPSBoZWlnaHQgLSB5VG9wSW5uZXI7XG5cbiAgY29uc3QgeENlbnRlciA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcbiAgY29uc3QgeUNlbnRlciA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMik7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBPdXRlciBmcmFtZSAoOCBwb2ludHMpXG4gICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5VG9wT3V0ZXIsIGxhYmVsOiBcIk91dGVyIFRvcC1MZWZ0XCIgfSxcbiAgICB7IHg6IHhDZW50ZXIsIHk6IHlUb3BPdXRlciwgbGFiZWw6IFwiT3V0ZXIgVG9wLUNlbnRlclwiIH0sXG4gICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeVRvcE91dGVyLCBsYWJlbDogXCJPdXRlciBUb3AtUmlnaHRcIiB9LFxuICAgIHsgeDogeExlZnRPdXRlciwgeTogeUNlbnRlciwgbGFiZWw6IFwiT3V0ZXIgTWlkZGxlLUxlZnRcIiB9LFxuICAgIHsgeDogeFJpZ2h0T3V0ZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIk91dGVyIE1pZGRsZS1SaWdodFwiIH0sXG4gICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5Qm90dG9tT3V0ZXIsIGxhYmVsOiBcIk91dGVyIEJvdHRvbS1MZWZ0XCIgfSxcbiAgICB7IHg6IHhDZW50ZXIsIHk6IHlCb3R0b21PdXRlciwgbGFiZWw6IFwiT3V0ZXIgQm90dG9tLUNlbnRlclwiIH0sXG4gICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeUJvdHRvbU91dGVyLCBsYWJlbDogXCJPdXRlciBCb3R0b20tUmlnaHRcIiB9LFxuXG4gICAgLy8gSW5uZXIgZnJhbWUgKDggcG9pbnRzKVxuICAgIHsgeDogeExlZnRJbm5lciwgeTogeVRvcElubmVyLCBsYWJlbDogXCJJbm5lciBUb3AtTGVmdFwiIH0sXG4gICAgeyB4OiB4Q2VudGVyLCB5OiB5VG9wSW5uZXIsIGxhYmVsOiBcIklubmVyIFRvcC1DZW50ZXJcIiB9LFxuICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlUb3BJbm5lciwgbGFiZWw6IFwiSW5uZXIgVG9wLVJpZ2h0XCIgfSxcbiAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIklubmVyIE1pZGRsZS1MZWZ0XCIgfSxcbiAgICB7IHg6IHhSaWdodElubmVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJJbm5lciBNaWRkbGUtUmlnaHRcIiB9LFxuICAgIHsgeDogeExlZnRJbm5lciwgeTogeUJvdHRvbUlubmVyLCBsYWJlbDogXCJJbm5lciBCb3R0b20tTGVmdFwiIH0sXG4gICAgeyB4OiB4Q2VudGVyLCB5OiB5Qm90dG9tSW5uZXIsIGxhYmVsOiBcIklubmVyIEJvdHRvbS1DZW50ZXJcIiB9LFxuICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlCb3R0b21Jbm5lciwgbGFiZWw6IFwiSW5uZXIgQm90dG9tLVJpZ2h0XCIgfVxuICBdO1xufTtcblxuLyoqXG4gKiBEcmF3IGEgY2FsaWJyYXRpb24gcG9pbnQgb24gYSBjYW52YXNcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uYWwgc2V0dGluZ3MgKGNvbG9yLCByYWRpdXMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQb2ludCBwb3NpdGlvbiBvYmplY3Qge3gsIHl9XG4gKi9cbmV4cG9ydCBjb25zdCBkcmF3Q2FsaWJyYXRpb25Qb2ludCA9IChjYW52YXMsIHgsIHksIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIHsgeCwgeSB9O1xuXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb25zdCBjb2xvciA9IG9wdGlvbnMuY29sb3IgfHwgJ3JlZCc7XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDg7XG5cbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gIGN0eC5maWxsKCk7XG5cbiAgLy8gR2xvdyBlZmZlY3RcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gIGN0eC5zdHJva2UoKTtcblxuICByZXR1cm4geyB4LCB5IH07XG59O1xuXG4vKipcbiAqIERyYXcgYWxsIGNhbGlicmF0aW9uIHBvaW50cyBvbiBhIGNhbnZhcyAoZm9yIGRlYnVnZ2luZy92aXN1YWxpemF0aW9uKVxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIEFycmF5IG9mIHBvaW50IG9iamVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY3RpdmVJbmRleCAtIEluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHBvaW50XG4gKi9cbmV4cG9ydCBjb25zdCBkcmF3Q2FsaWJyYXRpb25HcmlkID0gKGNhbnZhcywgcG9pbnRzLCBhY3RpdmVJbmRleCA9IC0xKSA9PiB7XG4gIGlmICghY2FudmFzIHx8ICFwb2ludHMgfHwgIXBvaW50cy5sZW5ndGgpIHJldHVybjtcblxuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaW5kZXggPT09IGFjdGl2ZUluZGV4O1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgaXNBY3RpdmUgPyA4IDogNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBpc0FjdGl2ZSA/ICdyZWQnIDogJ3JnYmEoMCwgMTAyLCAyMDQsIDAuNyknO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICBjdHguZm9udCA9ICcxMHB4IEFyaWFsJztcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5maWxsVGV4dChgJHtpbmRleCArIDF9YCwgcG9pbnQueCwgcG9pbnQueSk7XG5cbiAgICBpZiAoaXNBY3RpdmUgJiYgcG9pbnQubGFiZWwpIHtcbiAgICAgIGN0eC5mb250ID0gJzEycHggQXJpYWwnO1xuICAgICAgY3R4LmZpbGxUZXh0KHBvaW50LmxhYmVsLCBwb2ludC54LCBwb2ludC55IC0gMjApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRHJhdyBjb25uZWN0aW5nIGxpbmVzIChvcHRpb25hbClcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3R4LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICB9XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDEwMiwgMjA0LCAwLjMpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gIGN0eC5zdHJva2UoKTtcbn07XG5cbi8vIE9wdGlvbmFsOiBEZWZhdWx0IGV4cG9ydCBhbGwgZm9yIGNvbnZlbmllbmNlXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMsXG4gIGRyYXdDYWxpYnJhdGlvblBvaW50LFxuICBkcmF3Q2FsaWJyYXRpb25HcmlkXG59OyJdLCJuYW1lcyI6WyJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwid2lkdGgiLCJoZWlnaHQiLCJjb25zb2xlIiwiZXJyb3IiLCJjb25kaXRpb25hbFJvdW5kIiwiZGltZW5zaW9uIiwicGVyY2VudGFnZSIsIk1hdGgiLCJyb3VuZCIsInhMZWZ0T3V0ZXIiLCJ4UmlnaHRPdXRlciIsInlUb3BPdXRlciIsInlCb3R0b21PdXRlciIsInhMZWZ0SW5uZXIiLCJ4UmlnaHRJbm5lciIsInlUb3BJbm5lciIsInlCb3R0b21Jbm5lciIsInhDZW50ZXIiLCJmbG9vciIsInlDZW50ZXIiLCJ4IiwieSIsImxhYmVsIiwiZHJhd0NhbGlicmF0aW9uUG9pbnQiLCJjYW52YXMiLCJvcHRpb25zIiwiY3R4IiwiZ2V0Q29udGV4dCIsImNvbG9yIiwicmFkaXVzIiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImRyYXdDYWxpYnJhdGlvbkdyaWQiLCJwb2ludHMiLCJhY3RpdmVJbmRleCIsImxlbmd0aCIsImZvckVhY2giLCJwb2ludCIsImluZGV4IiwiaXNBY3RpdmUiLCJmb250IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJtb3ZlVG8iLCJpIiwibGluZVRvIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js":
/*!*********************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/countSave.js ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calibrationCapture: () => (/* binding */ calibrationCapture),\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// Fixed countSave.js - Resolving redrawInterval reference error\n// Shared functionality for countdown and image capture processes\n\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(absoluteX, \"px;\\n    top: \").concat(absoluteY - 60, \"px;\\n    transform: translateX(-50%);\\n    color: red;\\n    font-size: 36px;\\n    font-weight: bold;\\n    text-shadow: 0 0 10px white, 0 0 20px white;\\n    z-index: 9999;\\n    background-color: rgba(255, 255, 255, 0.8);\\n    border: 2px solid red;\\n    border-radius: 50%;\\n    width: 50px;\\n    height: 50px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n  \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Display a preview of the captured images\n * @param {string} screenImage - Data URL of the screen image\n * @param {string} webcamImage - Data URL of the webcam image\n * @param {Object} point - {x, y} position of the dot\n */ const showCapturePreview = (screenImage, webcamImage, point)=>{\n    if (!screenImage && !webcamImage) return;\n    // Remove any existing previews\n    const existingPreviews = document.querySelectorAll('.capture-preview-container');\n    existingPreviews.forEach((preview)=>{\n        if (preview.parentNode) {\n            preview.parentNode.removeChild(preview);\n        }\n    });\n    // Create preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    display: flex;\\n    gap: 20px;\\n    background-color: rgba(0, 0, 0, 0.85);\\n    padding: 20px;\\n    border-radius: 12px;\\n    z-index: 999999;\\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n  \";\n    // Add screen image if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.alt = 'Screen Capture';\n        screenImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam image if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.alt = 'Webcam Capture';\n        webcamImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add point info\n    if (point) {\n        const pointInfo = document.createElement('div');\n        pointInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Point: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n        pointInfo.style.cssText = \"\\n      color: #ffcc00;\\n      font-size: 14px;\\n      position: absolute;\\n      top: -40px;\\n      left: 0;\\n      width: 100%;\\n      text-align: center;\\n    \";\n        previewContainer.appendChild(pointInfo);\n    }\n    // Add timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n    position: absolute;\\n    bottom: -25px;\\n    right: 20px;\\n    color: white;\\n    font-size: 12px;\\n    background-color: rgba(0, 0, 0, 0.7);\\n    padding: 3px 8px;\\n    border-radius: 4px;\\n  \";\n    previewContainer.appendChild(timerElement);\n    // Add to document\n    document.body.appendChild(previewContainer);\n    // Countdown\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            previewContainer.style.opacity = '0';\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    // Create redrawInterval for keeping dot visible during countdown\n    let redrawInterval = setInterval(()=>{\n        drawRedDot(ctx, position.x, position.y, 12, false);\n    }, 200);\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    drawRedDot(ctx, position.x, position.y, 12, false);\n                    // Clear the redrawInterval we defined above\n                    if (redrawInterval) {\n                        clearInterval(redrawInterval);\n                    }\n                    if (onComplete) {\n                        drawRedDot(ctx, position.x, position.y, 12, false);\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n * Draw a red dot on the canvas\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n * @returns {Object} - {x, y} position\n */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * Capture images at a specific point\n * @param {Object} options - Capture options\n * @returns {Promise} - Promise that resolves with the capture result\n */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[captureImages] Invalid position object:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid capture position');\n        return null;\n    }\n    try {\n        // Get highest resolution constraints\n        const constraints = await getHighestResolutionConstraints();\n        console.log('Using camera constraints:', constraints);\n        // Get a new stream with the highest resolution\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        const videoTrack = stream.getVideoTracks()[0];\n        const settings = videoTrack.getSettings();\n        console.log('Actual camera settings:', settings);\n        // Update video element with new stream\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            videoElement.srcObject = stream;\n            await videoElement.play();\n        }\n        // Call the captureImagesAtPoint with all necessary parameters\n        const result = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_0__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        console.log('Capture successful with ID:', result.captureId);\n        // Clean up the stream\n        stream.getTracks().forEach((track)=>track.stop());\n        return {\n            screenImage: (result === null || result === void 0 ? void 0 : result.screenImage) || '',\n            webcamImage: (result === null || result === void 0 ? void 0 : result.webcamImage) || '',\n            success: true,\n            captureId: result === null || result === void 0 ? void 0 : result.captureId,\n            resolution: {\n                width: settings.width,\n                height: settings.height\n            }\n        };\n    } catch (err) {\n        console.error('[captureImages] Unexpected error:', err);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: err.message\n        };\n    }\n};\n/**\n * Generate a random dot position within the canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} padding - Padding from the edges\n * @returns {Object} - {x, y} position\n */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n * Special calibration capture function that avoids problematic code paths\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ /**\n * Special calibration capture function that behaves like random dot capture\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ const calibrationCapture = async (options)=>{\n    const { canvasRef, point, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures', pointIndex, totalPoints } = options;\n    try {\n        console.log(\"Starting calibration capture for point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Get canvas\n        const canvas = canvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas reference is null in calibrationCapture\");\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: Canvas not available\");\n            return {\n                success: false\n            };\n        }\n        // Use the exact same drawing method as random dots\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, point.x, point.y);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Calibration point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Use the same countdown element creation method\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = createCountdownElement(point, canvasRect);\n        if (!countdownElement) {\n            console.error(\"Failed to create countdown element\");\n            return {\n                success: false\n            };\n        }\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, point.x, point.y, 12, false);\n        }, 200);\n        // Run the same countdown as random dot\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Point \".concat(pointIndex + 1, \"/\").concat(totalPoints, \" - countdown \").concat(count));\n            // Redraw the dot at each step to ensure it remains visible\n            drawRedDot(ctx, point.x, point.y, 12, false);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show checkmark\n        countdownElement.textContent = \"✓\";\n        // Remove countdown element\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Clear redrawInterval\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureAndPreviewProcess instead of directly calling captureImagesAtPoint\n        const captureResult = await captureAndPreviewProcess({\n            canvasRef,\n            position: point,\n            captureCounter,\n            setCaptureCounter,\n            setProcessStatus: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            captureFolder\n        });\n        // Ensure proper return even if captureResult is null\n        const safeResult = captureResult && typeof captureResult === 'object' ? captureResult : {\n            screenImage: '',\n            webcamImage: '',\n            success: false\n        };\n        return {\n            screenImage: safeResult.screenImage || '',\n            webcamImage: safeResult.webcamImage || '',\n            success: true,\n            point\n        };\n    } catch (error) {\n        console.error(\"Error in calibrationCapture:\", error);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(error.message));\n        // Always return a valid object with default values\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Complete capture and preview process\n * @param {Object} options - Process options\n */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder } = options;\n    try {\n        const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;\n        if (!canvas) {\n            console.error(\"[captureAndPreviewProcess] Canvas reference is null\");\n            if (setProcessStatus) setProcessStatus('Error: Canvas is not available');\n            return null;\n        }\n        // Draw the dot\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, position.x, position.y);\n        // Countdown before capture\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Starting countdown...',\n                isCapturing: true\n            });\n        }\n        // Create a custom countdown element\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = document.createElement('div');\n        countdownElement.className = 'calibrate-countdown';\n        countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(canvasRect.left + position.x, \"px;\\n      top: \").concat(canvasRect.top + position.y - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n        document.body.appendChild(countdownElement);\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y, 12, false);\n        }, 200);\n        // Manual countdown\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n            // Redraw dot to ensure it's visible\n            drawRedDot(ctx, position.x, position.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Change to checkmark\n        countdownElement.textContent = \"✓\";\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capturing images...',\n                countdownValue: \"Capturing...\",\n                isCapturing: true\n            });\n        }\n        // Remove countdown element and clear redrawInterval\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureImagesAtPoint from savefile.js\n        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_0__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured dot at x=\".concat(Math.round(position.x), \", y=\").concat(Math.round(position.y)));\n        }\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capture complete',\n                isCapturing: false\n            });\n        }\n        // Show TopBar again with delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"[captureAndPreviewProcess] Fatal error:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Fatal error: \".concat(error.message));\n        }\n        // Ensure TopBar is shown even on error\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        // Return a minimal valid object to prevent null reference errors\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUFBLGdFQUFnRTtBQUNoRSxpRUFBaUU7QUFDUDtBQUUxRDs7Ozs7Q0FLQyxHQUNNLE1BQU1DLHlCQUF5QixDQUFDQyxVQUFVQztJQUMvQyxJQUFJLENBQUNELFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyw4Q0FBOENMO1FBQzNELE9BQU87SUFDVDtJQUVBLE1BQU1NLHFCQUFxQkMsU0FBU0MsZ0JBQWdCLENBQUM7SUFDckRGLG1CQUFtQkcsT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHQyxNQUFNO0lBRTFDLE1BQU1DLFlBQVlYLFdBQVdZLElBQUksR0FBR2IsU0FBU0UsQ0FBQztJQUM5QyxNQUFNWSxZQUFZYixXQUFXYyxHQUFHLEdBQUdmLFNBQVNHLENBQUM7SUFFN0MsTUFBTWEsbUJBQW1CVCxTQUFTVSxhQUFhLENBQUM7SUFDaERELGlCQUFpQkUsU0FBUyxHQUFHO0lBQzdCRixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLHFDQUd4Qk4sT0FEQ0YsV0FBVSxrQkFDSSxPQUFmRSxZQUFZLElBQUc7SUFrQnhCUCxTQUFTYyxJQUFJLENBQUNDLFdBQVcsQ0FBQ047SUFDMUIsT0FBT0E7QUFDVCxFQUFFO0FBRUY7Ozs7O0NBS0MsR0FDTSxNQUFNTyxxQkFBcUIsQ0FBQ0MsYUFBYUMsYUFBYUM7SUFDM0QsSUFBSSxDQUFDRixlQUFlLENBQUNDLGFBQWE7SUFFbEMsK0JBQStCO0lBQy9CLE1BQU1FLG1CQUFtQnBCLFNBQVNDLGdCQUFnQixDQUFDO0lBQ25EbUIsaUJBQWlCbEIsT0FBTyxDQUFDbUIsQ0FBQUE7UUFDdkIsSUFBSUEsUUFBUUMsVUFBVSxFQUFFO1lB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QStCO1FBQy9CUixXQUFXO1lBQ1QsSUFBSSxPQUFPc0MsaUJBQWlCLFlBQVk7Z0JBQ3RDQSxhQUFhO1lBQ2YsT0FBTyxJQUFJLEtBQTZCLElBQUljLE9BQU9kLFlBQVksRUFBRTtnQkFDL0RjLE9BQU9kLFlBQVksQ0FBQztZQUN0QjtRQUNGLEdBQUc7UUFFSCxPQUFPc0M7SUFFVCxFQUFFLE9BQU9WLE9BQU87UUFDZGxILFFBQVFrSCxLQUFLLENBQUMsMkNBQTJDQTtRQUV6RCxJQUFJN0Isa0JBQWtCO1lBQ3BCQSxpQkFBaUIsZ0JBQThCLE9BQWQ2QixNQUFNQyxPQUFPO1FBQ2hEO1FBRUEsdUNBQXVDO1FBQ3ZDbkUsV0FBVztZQUNULElBQUksT0FBT3NDLGlCQUFpQixZQUFZO2dCQUN0Q0EsYUFBYTtZQUNmLE9BQU8sSUFBSSxLQUE2QixJQUFJYyxPQUFPZCxZQUFZLEVBQUU7Z0JBQy9EYyxPQUFPZCxZQUFZLENBQUM7WUFDdEI7UUFDRixHQUFHO1FBRUgsaUVBQWlFO1FBQ2pFLE9BQU87WUFDTGxFLGFBQWE7WUFDYkMsYUFBYTtZQUNiMEYsU0FBUztZQUNURyxPQUFPQSxNQUFNQyxPQUFPO1FBQ3RCO0lBQ0Y7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRml4ZWQgY291bnRTYXZlLmpzIC0gUmVzb2x2aW5nIHJlZHJhd0ludGVydmFsIHJlZmVyZW5jZSBlcnJvclxuLy8gU2hhcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGNvdW50ZG93biBhbmQgaW1hZ2UgY2FwdHVyZSBwcm9jZXNzZXNcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vSGVscGVyL3NhdmVmaWxlJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBkaXNwbGF5cyBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIGEgZG90IHBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtET01SZWN0fSBjYW52YXNSZWN0IC0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgb2YgdGhlIGNhbnZhc1xuICogQHJldHVybnMge0hUTUxFbGVtZW50fSAtIFRoZSBjcmVhdGVkIGNvdW50ZG93biBlbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDb3VudGRvd25FbGVtZW50ID0gKHBvc2l0aW9uLCBjYW52YXNSZWN0KSA9PiB7XG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW2NyZWF0ZUNvdW50ZG93bkVsZW1lbnRdIEludmFsaWQgcG9zaXRpb246JywgcG9zaXRpb24pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1jb3VudGRvd24sIC5mb3JjZWQtY291bnRkb3duLCAuY2VudGVyLWNvdW50ZG93bi1iYWNrdXAnKTtcbiAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuXG4gIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLng7XG4gIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcblxuICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgIHRvcDogJHthYnNvbHV0ZVkgLSA2MH1weDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgY29sb3I6IHJlZDtcbiAgICBmb250LXNpemU6IDM2cHg7XG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICB6LWluZGV4OiA5OTk5O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIHdpZHRoOiA1MHB4O1xuICAgIGhlaWdodDogNTBweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICBgO1xuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gIHJldHVybiBjb3VudGRvd25FbGVtZW50O1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IGEgcHJldmlldyBvZiB0aGUgY2FwdHVyZWQgaW1hZ2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyZWVuSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgc2NyZWVuIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViY2FtSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgd2ViY2FtIGltYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICovXG5leHBvcnQgY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgcG9pbnQpID0+IHtcbiAgaWYgKCFzY3JlZW5JbWFnZSAmJiAhd2ViY2FtSW1hZ2UpIHJldHVybjtcbiAgXG4gIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlld3NcbiAgY29uc3QgZXhpc3RpbmdQcmV2aWV3cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXB0dXJlLXByZXZpZXctY29udGFpbmVyJyk7XG4gIGV4aXN0aW5nUHJldmlld3MuZm9yRWFjaChwcmV2aWV3ID0+IHtcbiAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICBwcmV2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlldyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIENyZWF0ZSBwcmV2aWV3IGNvbnRhaW5lclxuICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByZXZpZXdDb250YWluZXIuY2xhc3NOYW1lID0gJ2NhcHR1cmUtcHJldmlldy1jb250YWluZXInO1xuICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gIGA7XG4gIFxuICAvLyBBZGQgc2NyZWVuIGltYWdlIGlmIGF2YWlsYWJsZVxuICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2NyZWVuUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgc2NyZWVuSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgc2NyZWVuSW1nLnNyYyA9IHNjcmVlbkltYWdlO1xuICAgIHNjcmVlbkltZy5hbHQgPSAnU2NyZWVuIENhcHR1cmUnO1xuICAgIHNjcmVlbkltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgc2NyZWVuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgc2NyZWVuTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBgO1xuICAgIFxuICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuSW1nKTtcbiAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHNjcmVlblByZXZpZXcpO1xuICB9XG4gIFxuICAvLyBBZGQgd2ViY2FtIGltYWdlIGlmIGF2YWlsYWJsZVxuICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd2ViY2FtUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgd2ViY2FtSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgd2ViY2FtSW1nLnNyYyA9IHdlYmNhbUltYWdlO1xuICAgIHdlYmNhbUltZy5hbHQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgIHdlYmNhbUltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgd2ViY2FtTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3ZWJjYW1MYWJlbC50ZXh0Q29udGVudCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgd2ViY2FtTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBgO1xuICAgIFxuICAgIHdlYmNhbVByZXZpZXcuYXBwZW5kQ2hpbGQod2ViY2FtSW1nKTtcbiAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUxhYmVsKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICB9XG4gIFxuICAvLyBBZGQgcG9pbnQgaW5mb1xuICBpZiAocG9pbnQpIHtcbiAgICBjb25zdCBwb2ludEluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb2ludEluZm8udGV4dENvbnRlbnQgPSBwb2ludC5sYWJlbCA/IFxuICAgICAgYCR7cG9pbnQubGFiZWx9OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWAgOlxuICAgICAgYFBvaW50OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWA7XG4gICAgICBcbiAgICBwb2ludEluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAtNDBweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBgO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9pbnRJbmZvKTtcbiAgfVxuICBcbiAgLy8gQWRkIHRpbWVyXG4gIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IC0yNXB4O1xuICAgIHJpZ2h0OiAyMHB4O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBgO1xuICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gIFxuICAvLyBBZGQgdG8gZG9jdW1lbnRcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgXG4gIC8vIENvdW50ZG93blxuICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwLjNzIGVhc2UnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgfVxuICB9LCAxMDApO1xuICBcbiAgLy8gU2FmZXR5IGNsZWFudXBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIH1cbiAgfSwgNTAwMCk7XG59O1xuXG4vKipcbiAqIFJ1bnMgYSBjb3VudGRvd24gcHJvY2VzcyB0aGF0IGRpc3BsYXlzIDMtMi0xIGFib3ZlIGEgZG90XG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgZG90XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblN0YXR1c1VwZGF0ZSAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdGF0dXMgbWVzc2FnZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGUgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICovXG5leHBvcnQgY29uc3QgcnVuQ291bnRkb3duID0gYXN5bmMgKHBvc2l0aW9uLCBjYW52YXMsIG9uU3RhdHVzVXBkYXRlLCBvbkNvbXBsZXRlKSA9PiB7XG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICBwcm9jZXNzU3RhdHVzOiBcIkludmFsaWQgZG90IHBvc2l0aW9uXCIsXG4gICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvc2l0aW9uLCBjYW52YXNSZWN0KTtcbiAgXG4gIGlmICghY291bnRkb3duRWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gQ291bnRkb3duIGVsZW1lbnQgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICBsZXQgY291bnQgPSAzO1xuICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG5cbiAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIGRvdCB2aXNpYmxlIGR1cmluZyBjb3VudGRvd25cbiAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAxMiwgZmFsc2UpO1xuICB9LCAyMDApO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNvdW50ZG93bkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY291bnQtLTtcblxuICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChjb3VudGRvd25JbnRlcnZhbCk7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ2FwdHVyaW5nIGltYWdlLi4uXCIsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcblxuICAgICAgICAgIC8vIENsZWFyIHRoZSByZWRyYXdJbnRlcnZhbCB3ZSBkZWZpbmVkIGFib3ZlXG4gICAgICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcblxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkNvdW50ZG93blwiLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCA4MDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhc1xuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQ2FudmFzIC0gV2hldGhlciB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIChkZWZhdWx0OiB0cnVlKVxuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYXdSZWREb3QgPSAoY3R4LCB4LCB5LCByYWRpdXMgPSAxMiwgY2xlYXJDYW52YXMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gIFxuICAvLyBDbGVhciB0aGUgY2FudmFzIGlmIHJlcXVlc3RlZCAoZGVmYXVsdCBiZWhhdmlvcilcbiAgaWYgKGNsZWFyQ2FudmFzKSB7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9XG4gIFxuICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGJyaWdodCByZWQgY29sb3JcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gIGN0eC5maWxsKCk7XG4gIFxuICAvLyBBZGQgZ2xvdyBlZmZlY3QgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gIGN0eC5saW5lV2lkdGggPSAzO1xuICBjdHguc3Ryb2tlKCk7XG4gIFxuICAvLyBBZGQgYSBzZWNvbmQgbGFyZ2VyIGdsb3cgZm9yIGV2ZW4gYmV0dGVyIHZpc2liaWxpdHlcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDYsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjMpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gIGN0eC5zdHJva2UoKTtcbiAgXG4gIHJldHVybiB7IHgsIHkgfTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZSBpbWFnZXMgYXQgYSBzcGVjaWZpYyBwb2ludFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDYXB0dXJlIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBjYXB0dXJlIHJlc3VsdFxuICovXG5leHBvcnQgY29uc3QgY2FwdHVyZUltYWdlcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnRlciwgXG4gICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICBjYXB0dXJlRm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcydcbiAgICB9ID0gb3B0aW9ucztcbiAgXG4gICAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tjYXB0dXJlSW1hZ2VzXSBJbnZhbGlkIHBvc2l0aW9uIG9iamVjdDonLCBwb3NpdGlvbik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oJ0Vycm9yOiBJbnZhbGlkIGNhcHR1cmUgcG9zaXRpb24nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBoaWdoZXN0IHJlc29sdXRpb24gY29uc3RyYWludHNcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cygpO1xuICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGNhbWVyYSBjb25zdHJhaW50czonLCBjb25zdHJhaW50cyk7XG4gICAgICBcbiAgICAgIC8vIEdldCBhIG5ldyBzdHJlYW0gd2l0aCB0aGUgaGlnaGVzdCByZXNvbHV0aW9uXG4gICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdBY3R1YWwgY2FtZXJhIHNldHRpbmdzOicsIHNldHRpbmdzKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHZpZGVvIGVsZW1lbnQgd2l0aCBuZXcgc3RyZWFtXG4gICAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB3aW5kb3cudmlkZW9FbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgICBpZiAodmlkZW9FbGVtZW50KSB7XG4gICAgICAgIHZpZGVvRWxlbWVudC5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIGF3YWl0IHZpZGVvRWxlbWVudC5wbGF5KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGwgdGhlIGNhcHR1cmVJbWFnZXNBdFBvaW50IHdpdGggYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgIHBvaW50OiBwb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgY2FudmFzUmVmLCBcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICB9KTtcbiAgXG4gICAgICBjb25zb2xlLmxvZygnQ2FwdHVyZSBzdWNjZXNzZnVsIHdpdGggSUQ6JywgcmVzdWx0LmNhcHR1cmVJZCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIHRoZSBzdHJlYW1cbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbkltYWdlOiByZXN1bHQ/LnNjcmVlbkltYWdlIHx8ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogcmVzdWx0Py53ZWJjYW1JbWFnZSB8fCAnJyxcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZUlkOiByZXN1bHQ/LmNhcHR1cmVJZCxcbiAgICAgICAgcmVzb2x1dGlvbjoge1xuICAgICAgICAgIHdpZHRoOiBzZXR0aW5ncy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLmhlaWdodFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignW2NhcHR1cmVJbWFnZXNdIFVuZXhwZWN0ZWQgZXJyb3I6JywgZXJyKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnIubWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSByYW5kb20gZG90IHBvc2l0aW9uIHdpdGhpbiB0aGUgY2FudmFzXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBQYWRkaW5nIGZyb20gdGhlIGVkZ2VzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHt4LCB5fSBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0UmFuZG9tUG9zaXRpb24gPSAoY2FudmFzLCBwYWRkaW5nID0gNDApID0+IHtcbiAgaWYgKCFjYW52YXMpIHJldHVybiB7IHg6IDEwMCwgeTogMTAwIH07IC8vIEZhbGxiYWNrIHBvc2l0aW9uXG4gIFxuICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCB8fCA0MDA7ICAvLyBGYWxsYmFjayBpZiB3aWR0aCBpcyAwXG4gIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgfHwgMzAwOyAvLyBGYWxsYmFjayBpZiBoZWlnaHQgaXMgMFxuICBcbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICB5OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGVpZ2h0IC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmdcbiAgfTtcbn07XG5cbi8qKlxuICogU3BlY2lhbCBjYWxpYnJhdGlvbiBjYXB0dXJlIGZ1bmN0aW9uIHRoYXQgYXZvaWRzIHByb2JsZW1hdGljIGNvZGUgcGF0aHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWxsIHRoZSBjYWxpYnJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZWQgZGF0YVxuICovXG4vKipcbiAqIFNwZWNpYWwgY2FsaWJyYXRpb24gY2FwdHVyZSBmdW5jdGlvbiB0aGF0IGJlaGF2ZXMgbGlrZSByYW5kb20gZG90IGNhcHR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWxsIHRoZSBjYWxpYnJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZWQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgY2FsaWJyYXRpb25DYXB0dXJlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb2ludCxcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLFxuICAgICAgcG9pbnRJbmRleCxcbiAgICAgIHRvdGFsUG9pbnRzXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FsaWJyYXRpb24gY2FwdHVyZSBmb3IgcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhc1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsIGluIGNhbGlicmF0aW9uQ2FwdHVyZVwiKTtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBVc2UgdGhlIGV4YWN0IHNhbWUgZHJhd2luZyBtZXRob2QgYXMgcmFuZG9tIGRvdHNcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICBcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgQ2FsaWJyYXRpb24gcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgY291bnRkb3duIGVsZW1lbnQgY3JlYXRpb24gbWV0aG9kXG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9pbnQsIGNhbnZhc1JlY3QpO1xuICAgICAgXG4gICAgICBpZiAoIWNvdW50ZG93bkVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY291bnRkb3duIGVsZW1lbnRcIik7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgZm9yIGtlZXBpbmcgdGhlIGRvdCB2aXNpYmxlXG4gICAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCAxMiwgZmFsc2UpO1xuICAgICAgfSwgMjAwKTtcbiAgXG4gICAgICAvLyBSdW4gdGhlIHNhbWUgY291bnRkb3duIGFzIHJhbmRvbSBkb3RcbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBQb2ludCAke3BvaW50SW5kZXggKyAxfS8ke3RvdGFsUG9pbnRzfSAtIGNvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVkcmF3IHRoZSBkb3QgYXQgZWFjaCBzdGVwIHRvIGVuc3VyZSBpdCByZW1haW5zIHZpc2libGVcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIDEyLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbFxuICAgICAgICBpZiAocmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgXG4gICAgICAvLyBVc2UgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIGluc3RlYWQgb2YgZGlyZWN0bHkgY2FsbGluZyBjYXB0dXJlSW1hZ2VzQXRQb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzcyh7XG4gICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgcG9zaXRpb246IHBvaW50LFxuICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzLnByb2Nlc3NTdGF0dXMgfHwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgJiYgdHlwZW9mIHN0YXR1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMucHJvY2Vzc1N0YXR1cyB8fCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICB9KTtcbiAgXG4gICAgICAvLyBFbnN1cmUgcHJvcGVyIHJldHVybiBldmVuIGlmIGNhcHR1cmVSZXN1bHQgaXMgbnVsbFxuICAgICAgY29uc3Qgc2FmZVJlc3VsdCA9IGNhcHR1cmVSZXN1bHQgJiYgdHlwZW9mIGNhcHR1cmVSZXN1bHQgPT09ICdvYmplY3QnIFxuICAgICAgICA/IGNhcHR1cmVSZXN1bHQgXG4gICAgICAgIDogeyBzY3JlZW5JbWFnZTogJycsIHdlYmNhbUltYWdlOiAnJywgc3VjY2VzczogZmFsc2UgfTtcbiAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogc2FmZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHNhZmVSZXN1bHQud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvaW50XG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYWxpYnJhdGlvbkNhcHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQWx3YXlzIHJldHVybiBhIHZhbGlkIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBDb21wbGV0ZSBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvY2VzcyBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgY2FudmFzUmVmLFxuICAgIHBvc2l0aW9uLFxuICAgIGNhcHR1cmVDb3VudGVyLFxuICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgdG9nZ2xlVG9wQmFyLFxuICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgIGNhcHR1cmVGb2xkZXJcbiAgfSA9IG9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWY/LmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBDYW52YXMgcmVmZXJlbmNlIGlzIG51bGxcIik7XG4gICAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6IENhbnZhcyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cbiAgICAvLyBDb3VudGRvd24gYmVmb3JlIGNhcHR1cmVcbiAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNvdW50ZG93bi4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjdXN0b20gY291bnRkb3duIGVsZW1lbnRcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2NhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLnh9cHg7XG4gICAgICB0b3A6ICR7Y2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55IC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG5cbiAgICAvLyBDcmVhdGUgYSByZWRyYXdJbnRlcnZhbCBmb3Iga2VlcGluZyB0aGUgZG90IHZpc2libGVcbiAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICB9LCAyMDApO1xuXG4gICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZWRyYXcgZG90IHRvIGVuc3VyZSBpdCdzIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdG8gY2hlY2ttYXJrXG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJpbmcgaW1hZ2VzLi4uJyxcbiAgICAgICAgY291bnRkb3duVmFsdWU6IFwiQ2FwdHVyaW5nLi4uXCIsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYW5kIGNsZWFyIHJlZHJhd0ludGVydmFsXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0sIDMwMCk7XG5cbiAgICAvLyBVc2UgY2FwdHVyZUltYWdlc0F0UG9pbnQgZnJvbSBzYXZlZmlsZS5qc1xuICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgY2FudmFzUmVmLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgIH0pO1xuXG4gICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIGRvdCBhdCB4PSR7TWF0aC5yb3VuZChwb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKHBvc2l0aW9uLnkpfWApO1xuICAgIH1cblxuICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyZSBjb21wbGV0ZScsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gd2l0aCBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgMjUwMCk7XG5cbiAgICByZXR1cm4gY2FwdHVyZVJlc3VsdDtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBGYXRhbCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgIFxuICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBGYXRhbCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgVG9wQmFyIGlzIHNob3duIGV2ZW4gb24gZXJyb3JcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgIH0sIDE1MDApO1xuICAgIFxuICAgIC8vIFJldHVybiBhIG1pbmltYWwgdmFsaWQgb2JqZWN0IHRvIHByZXZlbnQgbnVsbCByZWZlcmVuY2UgZXJyb3JzXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59OyJdLCJuYW1lcyI6WyJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJ4IiwieSIsImNvbnNvbGUiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicmVtb3ZlIiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsInBvaW50IiwiZXhpc3RpbmdQcmV2aWV3cyIsInByZXZpZXciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJwcmV2aWV3Q29udGFpbmVyIiwic2NyZWVuUHJldmlldyIsInNjcmVlbkltZyIsInNyYyIsImFsdCIsInNjcmVlbkxhYmVsIiwidGV4dENvbnRlbnQiLCJ3ZWJjYW1QcmV2aWV3Iiwid2ViY2FtSW1nIiwid2ViY2FtTGFiZWwiLCJwb2ludEluZm8iLCJsYWJlbCIsIk1hdGgiLCJyb3VuZCIsInRpbWVyRWxlbWVudCIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5IiwidHJhbnNpdGlvbiIsInNldFRpbWVvdXQiLCJ0b0ZpeGVkIiwicnVuQ291bnRkb3duIiwiY2FudmFzIiwib25TdGF0dXNVcGRhdGUiLCJvbkNvbXBsZXRlIiwicHJvY2Vzc1N0YXR1cyIsImNvdW50ZG93blZhbHVlIiwiaXNDYXB0dXJpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd1JlZERvdCIsImNvdW50IiwicmVkcmF3SW50ZXJ2YWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50ZG93bkludGVydmFsIiwicmFkaXVzIiwiY2xlYXJDYW52YXMiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJjYXB0dXJlSW1hZ2VzIiwib3B0aW9ucyIsImNhbnZhc1JlZiIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzZXRQcm9jZXNzU3RhdHVzIiwidG9nZ2xlVG9wQmFyIiwiY2FwdHVyZUZvbGRlciIsImNvbnN0cmFpbnRzIiwiZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cyIsImxvZyIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvVHJhY2siLCJnZXRWaWRlb1RyYWNrcyIsInNldHRpbmdzIiwiZ2V0U2V0dGluZ3MiLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwic3JjT2JqZWN0IiwicGxheSIsInJlc3VsdCIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsImNhcHR1cmVJZCIsImdldFRyYWNrcyIsInRyYWNrIiwic3RvcCIsInN1Y2Nlc3MiLCJyZXNvbHV0aW9uIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxpYnJhdGlvbkNhcHR1cmUiLCJwb2ludEluZGV4IiwidG90YWxQb2ludHMiLCJjdXJyZW50IiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsInN0YXR1cyIsInNhZmVSZXN1bHQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js":
/*!********************************************************************!*\
  !*** ./components/collected-dataset-customized/Helper/savefile.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureImagesAtPoint: () => (/* binding */ captureImagesAtPoint),\n/* harmony export */   getHighestResolutionConstraints: () => (/* binding */ getHighestResolutionConstraints),\n/* harmony export */   saveCSVToServer: () => (/* binding */ saveCSVToServer),\n/* harmony export */   saveImageToServer: () => (/* binding */ saveImageToServer)\n/* harmony export */ });\n// Helper/savefile.js - Added highest resolution webcam capture\n/**\n * Resize an image to fit within a certain size limit\n * @param {string} imageDataUrl - Base64 encoded image data\n * @param {number} maxWidth - Maximum width of the resized image\n * @param {number} maxHeight - Maximum height of the resized image\n * @param {number} quality - JPEG quality (0-1)\n * @returns {Promise<string>} - Resized image data URL\n */ const resizeImage = async function(imageDataUrl) {\n    let maxWidth = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 800, maxHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 600, quality = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85;\n    return new Promise((resolve, reject)=>{\n        try {\n            const img = new Image();\n            img.onload = ()=>{\n                // Calculate new dimensions while maintaining aspect ratio\n                let width = img.width;\n                let height = img.height;\n                if (width > maxWidth) {\n                    height = Math.round(height * (maxWidth / width));\n                    width = maxWidth;\n                }\n                if (height > maxHeight) {\n                    width = Math.round(width * (maxHeight / height));\n                    height = maxHeight;\n                }\n                // Create canvas for resizing\n                const canvas = document.createElement('canvas');\n                canvas.width = width;\n                canvas.height = height;\n                // Draw and resize image on canvas\n                const ctx = canvas.getContext('2d');\n                ctx.drawImage(img, 0, 0, width, height);\n                // Convert to JPEG with specified quality\n                const resizedDataUrl = canvas.toDataURL('image/jpeg', quality);\n                resolve(resizedDataUrl);\n            };\n            img.onerror = (err)=>reject(err);\n            img.src = imageDataUrl;\n        } catch (err) {\n            reject(err);\n        }\n    });\n};\n/**\n * Save an image or data to the server with group ID to ensure consistent numbering\n * @param {string} imageData - Base64 encoded image data\n * @param {string} filename - Filename pattern to save as\n * @param {string} type - Type of file (screen, webcam, parameters)\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveImageToServer = async function(imageData, filename, type) {\n    let folder = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'eye_tracking_captures', captureGroup = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;\n    try {\n        const response = await fetch('/api/save-capture', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                imageData,\n                filename,\n                type,\n                folder,\n                captureGroup\n            })\n        });\n        if (!response.ok) {\n            console.error(\"Server returned \".concat(response.status, \" for \").concat(type));\n            // If the error is 413 (payload too large) and it's an image, try resizing\n            if (response.status === 413 && type !== 'parameters') {\n                console.warn(\"Image too large for server (413 error), will resize and retry\");\n                // Start with higher quality and progressively reduce quality/size until it fits\n                const sizes = [\n                    {\n                        width: 1920,\n                        height: 1080,\n                        quality: 0.9\n                    },\n                    {\n                        width: 1280,\n                        height: 720,\n                        quality: 0.85\n                    },\n                    {\n                        width: 800,\n                        height: 600,\n                        quality: 0.8\n                    },\n                    {\n                        width: 640,\n                        height: 480,\n                        quality: 0.75\n                    }\n                ];\n                for (const { width, height, quality } of sizes){\n                    const resizedImage = await resizeImage(imageData, width, height, quality);\n                    try {\n                        const retryResponse = await fetch('/api/save-capture', {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify({\n                                imageData: resizedImage,\n                                filename,\n                                type,\n                                folder,\n                                captureGroup\n                            })\n                        });\n                        if (retryResponse.ok) {\n                            console.log(\"Successfully saved resized \".concat(type, \" at \").concat(width, \"x\").concat(height, \", quality \").concat(quality));\n                            return await retryResponse.json();\n                        }\n                    } catch (retryError) {\n                        console.error(\"Error during retry for \".concat(type, \":\"), retryError);\n                    }\n                }\n                return {\n                    success: false,\n                    error: \"Failed to save image even after resizing\"\n                };\n            }\n            return {\n                success: false,\n                error: \"Server returned \".concat(response.status)\n            };\n        }\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error(\"Error saving \".concat(type, \":\"), error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Save CSV data to the server\n * @param {string} csvData - CSV data\n * @param {string} filename - Filename pattern to save as\n * @param {string} folder - Folder to save in\n * @param {string} captureGroup - Unique ID for grouping files from the same capture\n * @returns {Promise<Object>} - Server response\n */ const saveCSVToServer = async function(csvData, filename) {\n    let folder = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'eye_tracking_captures', captureGroup = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    try {\n        const csvBlob = new Blob([\n            csvData\n        ], {\n            type: 'text/csv'\n        });\n        const reader = new FileReader();\n        const csvDataUrl = await new Promise((resolve)=>{\n            reader.onloadend = ()=>resolve(reader.result);\n            reader.readAsDataURL(csvBlob);\n        });\n        const result = await saveImageToServer(csvDataUrl, filename, 'parameters', folder, captureGroup);\n        return result;\n    } catch (error) {\n        console.error('Error saving CSV:', error);\n        return null;\n    }\n};\n/**\n * Get the highest resolution camera constraints supported by the device\n * @returns {Promise<MediaStreamConstraints>} - Camera constraints with highest resolution\n */ const getHighestResolutionConstraints = async ()=>{\n    // Try to get all available camera capabilities first\n    try {\n        var _videoTrack_getCapabilities;\n        // Get a temporary access to the camera\n        const tempStream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        const videoTrack = tempStream.getVideoTracks()[0];\n        // Get capabilities\n        const capabilities = (_videoTrack_getCapabilities = videoTrack.getCapabilities) === null || _videoTrack_getCapabilities === void 0 ? void 0 : _videoTrack_getCapabilities.call(videoTrack);\n        console.log(\"Camera capabilities:\", capabilities);\n        // Get current settings to check aspect ratio\n        const settings = videoTrack.getSettings();\n        console.log(\"Current camera settings:\", settings);\n        // Stop the temporary stream\n        videoTrack.stop();\n        if (capabilities && capabilities.width && capabilities.height) {\n            // Use the maximum width and height from device capabilities\n            const maxWidth = capabilities.width.max;\n            const maxHeight = capabilities.height.max;\n            // Force exact resolution instead of ideal\n            return {\n                video: {\n                    width: {\n                        exact: maxWidth\n                    },\n                    height: {\n                        exact: maxHeight\n                    },\n                    frameRate: {\n                        ideal: 30\n                    } // Try to maintain good frame rate\n                }\n            };\n        }\n    } catch (err) {\n        console.log(\"Could not get camera capabilities:\", err);\n    }\n    // Fallback: try standard resolutions in order\n    const resolutions = [\n        {\n            width: {\n                exact: 4096\n            },\n            height: {\n                exact: 2160\n            }\n        },\n        {\n            width: {\n                exact: 3840\n            },\n            height: {\n                exact: 2160\n            }\n        },\n        {\n            width: {\n                exact: 2560\n            },\n            height: {\n                exact: 1440\n            }\n        },\n        {\n            width: {\n                exact: 1920\n            },\n            height: {\n                exact: 1080\n            }\n        },\n        {\n            width: {\n                exact: 1280\n            },\n            height: {\n                exact: 720\n            }\n        },\n        {\n            width: {\n                exact: 640\n            },\n            height: {\n                exact: 480\n            }\n        },\n        {} // Default - let browser decide\n    ];\n    // Try the resolutions in order until one works\n    for (const resolution of resolutions){\n        try {\n            const constraints = {\n                video: {\n                    ...resolution,\n                    facingMode: \"user\",\n                    frameRate: {\n                        ideal: 30\n                    }\n                }\n            };\n            // Test if this resolution is supported\n            const stream = await navigator.mediaDevices.getUserMedia(constraints);\n            // Get the actual dimensions\n            const videoTrack = stream.getVideoTracks()[0];\n            const settings = videoTrack.getSettings();\n            console.log(\"Supported resolution:\", settings.width, \"x\", settings.height);\n            // Stop the test stream immediately\n            stream.getTracks().forEach((track)=>track.stop());\n            return constraints;\n        } catch (err) {\n            console.log(\"Resolution not supported: \".concat(JSON.stringify(resolution)));\n        // Continue to next resolution\n        }\n    }\n    // If nothing worked, return basic constraints\n    return {\n        video: {\n            width: {\n                exact: 1280\n            },\n            height: {\n                exact: 720\n            },\n            frameRate: {\n                ideal: 30\n            }\n        }\n    };\n};\n/**\n * Capture and save images at a specific point with consistent numbering\n * @param {Object} options - Capture options\n * @returns {Promise<Object>} - Capture results\n */ const captureImagesAtPoint = async (param)=>{\n    let { point, captureCount = 1, canvasRef, setCaptureCount, showCapturePreview } = param;\n    try {\n        const folder = 'eye_tracking_captures';\n        // Create a unique ID for this capture group\n        const captureGroupId = \"capture-\".concat(Date.now());\n        console.log(\"Generated capture group ID: \".concat(captureGroupId));\n        // File patterns for saving\n        const screenFilename = 'screen_001.jpg'; // Pattern only - server will assign number\n        const webcamFilename = 'webcam_001.jpg'; // Pattern only - server will assign number\n        const parameterFilename = 'parameter_001.csv'; // Pattern only - server will assign number\n        // For logging\n        console.log(\"Starting capture with group ID:\", captureGroupId);\n        const canvas = canvasRef.current;\n        let screenImage = null;\n        let webcamImage = null;\n        let captureNumber = null;\n        // Variables to store webcam resolution\n        let webcamWidth = 0;\n        let webcamHeight = 0;\n        // 1. Prepare all data first\n        // 1.1 Canvas/screen image\n        if (canvas) {\n            screenImage = canvas.toDataURL('image/png');\n        }\n        // 1.2 Webcam image - Try to get the highest resolution available \n        // with device's native capabilities instead of fixed values\n        let webcamImagePreview = null; // Separate lower-resolution version for preview\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            try {\n                // Use existing video element if available\n                // First check if videoTrack has settings info\n                let trackSettings = null;\n                if (videoElement.srcObject) {\n                    const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                    if (videoTrack) {\n                        trackSettings = videoTrack.getSettings();\n                        console.log(\"Video track settings:\", trackSettings);\n                    }\n                }\n                // Get dimensions from track if available, otherwise from element\n                if (trackSettings && trackSettings.width && trackSettings.height) {\n                    webcamWidth = trackSettings.width;\n                    webcamHeight = trackSettings.height;\n                    console.log(\"Using track settings dimensions: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    webcamWidth = videoElement.videoWidth || 0;\n                    webcamHeight = videoElement.videoHeight || 0;\n                    console.log(\"Using video element dimensions: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Sanity check - if both dimensions are the same, double-check\n                if (webcamWidth === webcamHeight && webcamWidth > 100) {\n                    console.warn(\"Suspicious square aspect ratio detected, double-checking dimensions\");\n                    // Try to get more reliable info\n                    if (videoElement.srcObject) {\n                        const videoTrack = videoElement.srcObject.getVideoTracks()[0];\n                        if (videoTrack) {\n                            const constraints = videoTrack.getConstraints();\n                            console.log(\"Video constraints:\", constraints);\n                            // If constraints have width/height, use those\n                            if (constraints.width && constraints.height) {\n                                if (typeof constraints.width.exact === 'number') {\n                                    webcamWidth = constraints.width.exact;\n                                } else if (typeof constraints.width.ideal === 'number') {\n                                    webcamWidth = constraints.width.ideal;\n                                }\n                                if (typeof constraints.height.exact === 'number') {\n                                    webcamHeight = constraints.height.exact;\n                                } else if (typeof constraints.height.ideal === 'number') {\n                                    webcamHeight = constraints.height.ideal;\n                                }\n                                console.log(\"Updated dimensions from constraints: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            }\n                        }\n                    }\n                }\n                // Final reality check - make sure dimensions are reasonable\n                if (webcamWidth <= 0 || webcamHeight <= 0) {\n                    console.warn(\"Invalid webcam dimensions, using defaults\");\n                    webcamWidth = 640;\n                    webcamHeight = 480;\n                }\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = webcamWidth;\n                tempCanvas.height = webcamHeight;\n                tempCanvas.getContext('2d').drawImage(videoElement, 0, 0, webcamWidth, webcamHeight);\n                // Create high-resolution version for saving\n                webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                // Create lower-resolution version for preview\n                webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                console.log(\"Webcam capture complete at resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n            } catch (err) {\n                console.error(\"Error capturing from existing video element:\", err);\n                webcamWidth = videoElement.videoWidth || 640;\n                webcamHeight = videoElement.videoHeight || 480;\n            }\n        } else {\n            try {\n                // Get highest resolution constraints for this device\n                const constraints = await getHighestResolutionConstraints();\n                console.log(\"Using camera constraints:\", constraints);\n                // Try to get stream with highest resolution\n                const stream = await navigator.mediaDevices.getUserMedia(constraints);\n                // Get the actual dimensions from the track first\n                const videoTrack = stream.getVideoTracks()[0];\n                const trackSettings = videoTrack.getSettings();\n                console.log(\"Actual camera settings:\", trackSettings);\n                // Create temporary video element to get the stream\n                const tempVideo = document.createElement('video');\n                tempVideo.srcObject = stream;\n                tempVideo.muted = true;\n                tempVideo.playsInline = true;\n                tempVideo.autoplay = true;\n                document.body.appendChild(tempVideo);\n                // Need to wait for video to be initialized\n                await new Promise((resolve)=>{\n                    tempVideo.onloadedmetadata = ()=>{\n                        tempVideo.play();\n                        resolve();\n                    };\n                    // Fallback if onloadedmetadata doesn't fire\n                    setTimeout(resolve, 1000);\n                });\n                // Wait a bit longer for the video to actually start playing\n                await new Promise((res)=>setTimeout(res, 500));\n                // Store webcam resolution - prioritize track settings over video element\n                if (trackSettings && trackSettings.width && trackSettings.height) {\n                    webcamWidth = trackSettings.width;\n                    webcamHeight = trackSettings.height;\n                    console.log(\"Using track settings for resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                } else {\n                    webcamWidth = tempVideo.videoWidth || 0;\n                    webcamHeight = tempVideo.videoHeight || 0;\n                    console.log(\"Using video element for resolution: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                }\n                // Reality check on dimensions\n                if (webcamWidth <= 0 || webcamHeight <= 0) {\n                    console.warn(\"Invalid webcam dimensions, trying to get from constraints\");\n                    if (constraints.video && typeof constraints.video === 'object') {\n                        if (constraints.video.width && constraints.video.width.exact) {\n                            webcamWidth = constraints.video.width.exact;\n                        }\n                        if (constraints.video.height && constraints.video.height.exact) {\n                            webcamHeight = constraints.video.height.exact;\n                        }\n                    }\n                    if (webcamWidth <= 0 || webcamHeight <= 0) {\n                        console.warn(\"Still invalid dimensions, using defaults\");\n                        webcamWidth = 640;\n                        webcamHeight = 480;\n                    }\n                }\n                // Final check for square aspect ratio which is usually incorrect\n                if (webcamWidth === webcamHeight && webcamWidth > 100) {\n                    var _videoTrack_getCapabilities;\n                    console.warn(\"Square aspect ratio detected, may be incorrect\");\n                    // Try to get more reliable dimensions\n                    const capabilities = (_videoTrack_getCapabilities = videoTrack.getCapabilities) === null || _videoTrack_getCapabilities === void 0 ? void 0 : _videoTrack_getCapabilities.call(videoTrack);\n                    if (capabilities && capabilities.width && capabilities.height) {\n                        if (capabilities.width.max && capabilities.height.max) {\n                            // Assume the maximum capabilities have the correct aspect ratio\n                            const aspectRatio = capabilities.width.max / capabilities.height.max;\n                            if (Math.abs(aspectRatio - 1.33) < 0.1) {\n                                webcamHeight = Math.round(webcamWidth / 1.33);\n                                console.log(\"Corrected to 4:3 aspect ratio: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            } else if (Math.abs(aspectRatio - 1.78) < 0.1) {\n                                webcamHeight = Math.round(webcamWidth / 1.78);\n                                console.log(\"Corrected to 16:9 aspect ratio: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                            }\n                        }\n                    }\n                }\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = webcamWidth;\n                tempCanvas.height = webcamHeight;\n                tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0, webcamWidth, webcamHeight);\n                // Create high-resolution version for saving\n                webcamImage = tempCanvas.toDataURL('image/jpeg', 0.95);\n                // Create lower-resolution version for preview\n                webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.85);\n                console.log(\"High-resolution webcam capture complete: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                // Clean up\n                stream.getTracks().forEach((t)=>t.stop());\n                tempVideo.remove();\n            } catch (err) {\n                console.warn(\"High-resolution webcam capture failed:\", err);\n                // Try one more time with basic constraints\n                try {\n                    const stream = await navigator.mediaDevices.getUserMedia({\n                        video: true\n                    });\n                    const videoTrack = stream.getVideoTracks()[0];\n                    const trackSettings = videoTrack.getSettings();\n                    const tempVideo = document.createElement('video');\n                    tempVideo.srcObject = stream;\n                    tempVideo.muted = true;\n                    tempVideo.playsInline = true;\n                    document.body.appendChild(tempVideo);\n                    await tempVideo.play();\n                    await new Promise((res)=>setTimeout(res, 300));\n                    // Get dimensions from track settings if available\n                    if (trackSettings && trackSettings.width && trackSettings.height) {\n                        webcamWidth = trackSettings.width;\n                        webcamHeight = trackSettings.height;\n                    } else {\n                        webcamWidth = tempVideo.videoWidth || 0;\n                        webcamHeight = tempVideo.videoHeight || 0;\n                    }\n                    // Final check for invalid dimensions\n                    if (webcamWidth <= 0 || webcamHeight <= 0) {\n                        webcamWidth = 640;\n                        webcamHeight = 480;\n                    }\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = webcamWidth;\n                    tempCanvas.height = webcamHeight;\n                    tempCanvas.getContext('2d').drawImage(tempVideo, 0, 0, webcamWidth, webcamHeight);\n                    // Create high-resolution version for saving\n                    webcamImage = tempCanvas.toDataURL('image/jpeg', 0.9);\n                    // Create lower-resolution version for preview\n                    webcamImagePreview = await resizeImage(webcamImage, 640, 480, 0.8);\n                    console.log(\"Basic webcam resolution captured: \".concat(webcamWidth, \"x\").concat(webcamHeight));\n                    stream.getTracks().forEach((t)=>t.stop());\n                    tempVideo.remove();\n                } catch (fallbackErr) {\n                    console.error(\"All webcam capture methods failed:\", fallbackErr);\n                    webcamWidth = 640;\n                    webcamHeight = 480;\n                }\n            }\n        }\n        // 1.3 Parameter data - Now including webcam resolution\n        const csvData = [\n            \"name,value\",\n            \"dot_x,\".concat(point.x),\n            \"dot_y,\".concat(point.y),\n            \"canvas_width,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.width) || 0),\n            \"canvas_height,\".concat((canvas === null || canvas === void 0 ? void 0 : canvas.height) || 0),\n            \"window_width,\".concat(window.innerWidth),\n            \"window_height,\".concat(window.innerHeight),\n            \"webcam_resolution_width,\".concat(webcamWidth),\n            \"webcam_resolution_height,\".concat(webcamHeight),\n            \"timestamp,\".concat(new Date().toISOString()),\n            \"group_id,\".concat(captureGroupId)\n        ].join('\\n');\n        // 2. Save all files with the same group ID so they get the same number\n        // 2.1 Save parameter file\n        const paramResult = await saveCSVToServer(csvData, parameterFilename, folder, captureGroupId);\n        if (paramResult && paramResult.success) {\n            captureNumber = paramResult.number;\n            console.log(\"Server assigned capture number: \".concat(captureNumber, \" for group: \").concat(captureGroupId));\n        }\n        // 2.2 Save screen image if available\n        let screenResult = null;\n        if (screenImage) {\n            screenResult = await saveImageToServer(screenImage, screenFilename, 'screen', folder, captureGroupId);\n        }\n        // 2.3 Save webcam image if available\n        let webcamResult = null;\n        if (webcamImage) {\n            webcamResult = await saveImageToServer(webcamImage, webcamFilename, 'webcam', folder, captureGroupId);\n        }\n        // 3. Show preview if needed - use the lower resolution version for preview\n        if (showCapturePreview && typeof showCapturePreview === 'function') {\n            showCapturePreview(screenImage, webcamImagePreview || webcamImage, point);\n        }\n        // 4. Increment counter for next capture\n        if (setCaptureCount && typeof setCaptureCount === 'function') {\n            setCaptureCount((prevCount)=>prevCount + 1);\n        }\n        // 5. Return results - now including webcam resolution\n        return {\n            screenImage,\n            webcamImage,\n            success: true,\n            point,\n            captureNumber,\n            groupId: captureGroupId,\n            webcamWidth,\n            webcamHeight\n        };\n    } catch (err) {\n        console.error(\"captureImagesAtPoint failed:\", err);\n        return {\n            success: false,\n            error: err.message,\n            screenImage: null,\n            webcamImage: null,\n            webcamWidth: 0,\n            webcamHeight: 0\n        };\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9IZWxwZXIvc2F2ZWZpbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLCtEQUErRDtBQUUvRDs7Ozs7OztDQU9DLEdBQ0QsTUFBTUEsY0FBYyxlQUFPQztRQUFjQyw0RUFBVyxLQUFLQyw2RUFBWSxLQUFLQywyRUFBVTtJQUNsRixPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7UUFDM0IsSUFBSTtZQUNGLE1BQU1DLE1BQU0sSUFBSUM7WUFDaEJELElBQUlFLE1BQU0sR0FBRztnQkFDWCwwREFBMEQ7Z0JBQzFELElBQUlDLFFBQVFILElBQUlHLEtBQUs7Z0JBQ3JCLElBQUlDLFNBQVNKLElBQUlJLE1BQU07Z0JBRXZCLElBQUlELFFBQVFULFVBQVU7b0JBQ3BCVSxTQUFTQyxLQUFLQyxLQUFLLENBQUNGLFNBQVVWLENBQUFBLFdBQVdTLEtBQUk7b0JBQzdDQSxRQUFRVDtnQkFDVjtnQkFFQSxJQUFJVSxTQUFTVCxXQUFXO29CQUN0QlEsUUFBUUUsS0FBS0MsS0FBSyxDQUFDSCxRQUFTUixDQUFBQSxZQUFZUyxNQUFLO29CQUM3Q0EsU0FBU1Q7Z0JBQ1g7Z0JBRUEsNkJBQTZCO2dCQUM3QixNQUFNWSxTQUFTQyxTQUFTQyxhQUFhLENBQUM7Z0JBQ3RDRixPQUFPSixLQUFLLEdBQUdBO2dCQUNmSSxPQUFPSCxNQUFNLEdBQUdBO2dCQUVoQixrQ0FBa0M7Z0JBQ2xDLE1BQU1NLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztnQkFDOUJELElBQUlFLFNBQVMsQ0FBQ1osS0FBSyxHQUFHLEdBQUdHLE9BQU9DO2dCQUVoQyx5Q0FBeUM7Z0JBQ3pDLE1BQU1TLGlCQUFpQk4sT0FBT08sU0FBUyxDQUFDLGNBQWNsQjtnQkFDdERFLFFBQVFlO1lBQ1Y7WUFFQWIsSUFBSWUsT0FBTyxHQUFHLENBQUNDLE1BQVFqQixPQUFPaUI7WUFDOUJoQixJQUFJaUIsR0FBRyxH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WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIZWxwZXIvc2F2ZWZpbGUuanMgLSBBZGRlZCBoaWdoZXN0IHJlc29sdXRpb24gd2ViY2FtIGNhcHR1cmVcblxuLyoqXG4gKiBSZXNpemUgYW4gaW1hZ2UgdG8gZml0IHdpdGhpbiBhIGNlcnRhaW4gc2l6ZSBsaW1pdFxuICogQHBhcmFtIHtzdHJpbmd9IGltYWdlRGF0YVVybCAtIEJhc2U2NCBlbmNvZGVkIGltYWdlIGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXaWR0aCAtIE1heGltdW0gd2lkdGggb2YgdGhlIHJlc2l6ZWQgaW1hZ2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhIZWlnaHQgLSBNYXhpbXVtIGhlaWdodCBvZiB0aGUgcmVzaXplZCBpbWFnZVxuICogQHBhcmFtIHtudW1iZXJ9IHF1YWxpdHkgLSBKUEVHIHF1YWxpdHkgKDAtMSlcbiAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gUmVzaXplZCBpbWFnZSBkYXRhIFVSTFxuICovXG5jb25zdCByZXNpemVJbWFnZSA9IGFzeW5jIChpbWFnZURhdGFVcmwsIG1heFdpZHRoID0gODAwLCBtYXhIZWlnaHQgPSA2MDAsIHF1YWxpdHkgPSAwLjg1KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIG5ldyBkaW1lbnNpb25zIHdoaWxlIG1haW50YWluaW5nIGFzcGVjdCByYXRpb1xuICAgICAgICBsZXQgd2lkdGggPSBpbWcud2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgaWYgKHdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAqIChtYXhXaWR0aCAvIHdpZHRoKSk7XG4gICAgICAgICAgd2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICAgIHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAqIChtYXhIZWlnaHQgLyBoZWlnaHQpKTtcbiAgICAgICAgICBoZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjYW52YXMgZm9yIHJlc2l6aW5nXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgYW5kIHJlc2l6ZSBpbWFnZSBvbiBjYW52YXNcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgdG8gSlBFRyB3aXRoIHNwZWNpZmllZCBxdWFsaXR5XG4gICAgICAgIGNvbnN0IHJlc2l6ZWREYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIHF1YWxpdHkpO1xuICAgICAgICByZXNvbHZlKHJlc2l6ZWREYXRhVXJsKTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGltZy5vbmVycm9yID0gKGVycikgPT4gcmVqZWN0KGVycik7XG4gICAgICBpbWcuc3JjID0gaW1hZ2VEYXRhVXJsO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuICB9KTtcbn07XG5cbi8qKlxuICogU2F2ZSBhbiBpbWFnZSBvciBkYXRhIHRvIHRoZSBzZXJ2ZXIgd2l0aCBncm91cCBJRCB0byBlbnN1cmUgY29uc2lzdGVudCBudW1iZXJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZURhdGEgLSBCYXNlNjQgZW5jb2RlZCBpbWFnZSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBGaWxlbmFtZSBwYXR0ZXJuIHRvIHNhdmUgYXNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBmaWxlIChzY3JlZW4sIHdlYmNhbSwgcGFyYW1ldGVycylcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb2xkZXIgLSBGb2xkZXIgdG8gc2F2ZSBpblxuICogQHBhcmFtIHtzdHJpbmd9IGNhcHR1cmVHcm91cCAtIFVuaXF1ZSBJRCBmb3IgZ3JvdXBpbmcgZmlsZXMgZnJvbSB0aGUgc2FtZSBjYXB0dXJlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFNlcnZlciByZXNwb25zZVxuICovXG5leHBvcnQgY29uc3Qgc2F2ZUltYWdlVG9TZXJ2ZXIgPSBhc3luYyAoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgdHlwZSwgZm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsIGNhcHR1cmVHcm91cCA9IG51bGwpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgaW1hZ2VEYXRhLCBcbiAgICAgICAgZmlsZW5hbWUsIFxuICAgICAgICB0eXBlLCBcbiAgICAgICAgZm9sZGVyLFxuICAgICAgICBjYXB0dXJlR3JvdXAgLy8gSW5jbHVkZSB0aGUgY2FwdHVyZSBncm91cCBJRFxuICAgICAgfSlcbiAgICB9KTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9IGZvciAke3R5cGV9YCk7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZSBlcnJvciBpcyA0MTMgKHBheWxvYWQgdG9vIGxhcmdlKSBhbmQgaXQncyBhbiBpbWFnZSwgdHJ5IHJlc2l6aW5nXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MTMgJiYgdHlwZSAhPT0gJ3BhcmFtZXRlcnMnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW1hZ2UgdG9vIGxhcmdlIGZvciBzZXJ2ZXIgKDQxMyBlcnJvciksIHdpbGwgcmVzaXplIGFuZCByZXRyeWApO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBoaWdoZXIgcXVhbGl0eSBhbmQgcHJvZ3Jlc3NpdmVseSByZWR1Y2UgcXVhbGl0eS9zaXplIHVudGlsIGl0IGZpdHNcbiAgICAgICAgY29uc3Qgc2l6ZXMgPSBbXG4gICAgICAgICAgeyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwLCBxdWFsaXR5OiAwLjkgfSxcbiAgICAgICAgICB7IHdpZHRoOiAxMjgwLCBoZWlnaHQ6IDcyMCwgcXVhbGl0eTogMC44NSB9LFxuICAgICAgICAgIHsgd2lkdGg6IDgwMCwgaGVpZ2h0OiA2MDAsIHF1YWxpdHk6IDAuOCB9LFxuICAgICAgICAgIHsgd2lkdGg6IDY0MCwgaGVpZ2h0OiA0ODAsIHF1YWxpdHk6IDAuNzUgfVxuICAgICAgICBdO1xuICAgICAgICBcbiAgICAgICAgZm9yIChjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHF1YWxpdHkgfSBvZiBzaXplcykge1xuICAgICAgICAgIGNvbnN0IHJlc2l6ZWRJbWFnZSA9IGF3YWl0IHJlc2l6ZUltYWdlKGltYWdlRGF0YSwgd2lkdGgsIGhlaWdodCwgcXVhbGl0eSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YTogcmVzaXplZEltYWdlLCBcbiAgICAgICAgICAgICAgICBmaWxlbmFtZSwgXG4gICAgICAgICAgICAgICAgdHlwZSwgXG4gICAgICAgICAgICAgICAgZm9sZGVyLFxuICAgICAgICAgICAgICAgIGNhcHR1cmVHcm91cFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChyZXRyeVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgc2F2ZWQgcmVzaXplZCAke3R5cGV9IGF0ICR7d2lkdGh9eCR7aGVpZ2h0fSwgcXVhbGl0eSAke3F1YWxpdHl9YCk7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXRyeVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChyZXRyeUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkdXJpbmcgcmV0cnkgZm9yICR7dHlwZX06YCwgcmV0cnlFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiRmFpbGVkIHRvIHNhdmUgaW1hZ2UgZXZlbiBhZnRlciByZXNpemluZ1wiIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogYFNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c31gIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyAke3R5cGV9OmAsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBTYXZlIENTViBkYXRhIHRvIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3ZEYXRhIC0gQ1NWIGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlbmFtZSAtIEZpbGVuYW1lIHBhdHRlcm4gdG8gc2F2ZSBhc1xuICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciAtIEZvbGRlciB0byBzYXZlIGluXG4gKiBAcGFyYW0ge3N0cmluZ30gY2FwdHVyZUdyb3VwIC0gVW5pcXVlIElEIGZvciBncm91cGluZyBmaWxlcyBmcm9tIHRoZSBzYW1lIGNhcHR1cmVcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gU2VydmVyIHJlc3BvbnNlXG4gKi9cbmV4cG9ydCBjb25zdCBzYXZlQ1NWVG9TZXJ2ZXIgPSBhc3luYyAoY3N2RGF0YSwgZmlsZW5hbWUsIGZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLCBjYXB0dXJlR3JvdXAgPSBudWxsKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoY3N2RGF0YVVybCwgZmlsZW5hbWUsICdwYXJhbWV0ZXJzJywgZm9sZGVyLCBjYXB0dXJlR3JvdXApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2F2aW5nIENTVjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBoaWdoZXN0IHJlc29sdXRpb24gY2FtZXJhIGNvbnN0cmFpbnRzIHN1cHBvcnRlZCBieSB0aGUgZGV2aWNlXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxNZWRpYVN0cmVhbUNvbnN0cmFpbnRzPn0gLSBDYW1lcmEgY29uc3RyYWludHMgd2l0aCBoaWdoZXN0IHJlc29sdXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMgPSBhc3luYyAoKSA9PiB7XG4gIC8vIFRyeSB0byBnZXQgYWxsIGF2YWlsYWJsZSBjYW1lcmEgY2FwYWJpbGl0aWVzIGZpcnN0XG4gIHRyeSB7XG4gICAgLy8gR2V0IGEgdGVtcG9yYXJ5IGFjY2VzcyB0byB0aGUgY2FtZXJhXG4gICAgY29uc3QgdGVtcFN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgdmlkZW86IHRydWUgfSk7XG4gICAgY29uc3QgdmlkZW9UcmFjayA9IHRlbXBTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICBcbiAgICAvLyBHZXQgY2FwYWJpbGl0aWVzXG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdmlkZW9UcmFjay5nZXRDYXBhYmlsaXRpZXM/LigpO1xuICAgIGNvbnNvbGUubG9nKFwiQ2FtZXJhIGNhcGFiaWxpdGllczpcIiwgY2FwYWJpbGl0aWVzKTtcbiAgICBcbiAgICAvLyBHZXQgY3VycmVudCBzZXR0aW5ncyB0byBjaGVjayBhc3BlY3QgcmF0aW9cbiAgICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICBjb25zb2xlLmxvZyhcIkN1cnJlbnQgY2FtZXJhIHNldHRpbmdzOlwiLCBzZXR0aW5ncyk7XG4gICAgXG4gICAgLy8gU3RvcCB0aGUgdGVtcG9yYXJ5IHN0cmVhbVxuICAgIHZpZGVvVHJhY2suc3RvcCgpO1xuICAgIFxuICAgIGlmIChjYXBhYmlsaXRpZXMgJiYgY2FwYWJpbGl0aWVzLndpZHRoICYmIGNhcGFiaWxpdGllcy5oZWlnaHQpIHtcbiAgICAgIC8vIFVzZSB0aGUgbWF4aW11bSB3aWR0aCBhbmQgaGVpZ2h0IGZyb20gZGV2aWNlIGNhcGFiaWxpdGllc1xuICAgICAgY29uc3QgbWF4V2lkdGggPSBjYXBhYmlsaXRpZXMud2lkdGgubWF4O1xuICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gY2FwYWJpbGl0aWVzLmhlaWdodC5tYXg7XG4gICAgICBcbiAgICAgIC8vIEZvcmNlIGV4YWN0IHJlc29sdXRpb24gaW5zdGVhZCBvZiBpZGVhbFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICB3aWR0aDogeyBleGFjdDogbWF4V2lkdGggfSxcbiAgICAgICAgICBoZWlnaHQ6IHsgZXhhY3Q6IG1heEhlaWdodCB9LFxuICAgICAgICAgIGZyYW1lUmF0ZTogeyBpZGVhbDogMzAgfSAvLyBUcnkgdG8gbWFpbnRhaW4gZ29vZCBmcmFtZSByYXRlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhcIkNvdWxkIG5vdCBnZXQgY2FtZXJhIGNhcGFiaWxpdGllczpcIiwgZXJyKTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IHRyeSBzdGFuZGFyZCByZXNvbHV0aW9ucyBpbiBvcmRlclxuICBjb25zdCByZXNvbHV0aW9ucyA9IFtcbiAgICB7IHdpZHRoOiB7IGV4YWN0OiA0MDk2IH0sIGhlaWdodDogeyBleGFjdDogMjE2MCB9IH0sIC8vIDRLXG4gICAgeyB3aWR0aDogeyBleGFjdDogMzg0MCB9LCBoZWlnaHQ6IHsgZXhhY3Q6IDIxNjAgfSB9LCAvLyA0SyBVSERcbiAgICB7IHdpZHRoOiB7IGV4YWN0OiAyNTYwIH0sIGhlaWdodDogeyBleGFjdDogMTQ0MCB9IH0sIC8vIDJLIFFIRFxuICAgIHsgd2lkdGg6IHsgZXhhY3Q6IDE5MjAgfSwgaGVpZ2h0OiB7IGV4YWN0OiAxMDgwIH0gfSwgLy8gRnVsbCBIRFxuICAgIHsgd2lkdGg6IHsgZXhhY3Q6IDEyODAgfSwgaGVpZ2h0OiB7IGV4YWN0OiA3MjAgfSB9LCAgLy8gSERcbiAgICB7IHdpZHRoOiB7IGV4YWN0OiA2NDAgfSwgaGVpZ2h0OiB7IGV4YWN0OiA0ODAgfSB9LCAgIC8vIFZHQVxuICAgIHt9ICAvLyBEZWZhdWx0IC0gbGV0IGJyb3dzZXIgZGVjaWRlXG4gIF07XG5cbiAgLy8gVHJ5IHRoZSByZXNvbHV0aW9ucyBpbiBvcmRlciB1bnRpbCBvbmUgd29ya3NcbiAgZm9yIChjb25zdCByZXNvbHV0aW9uIG9mIHJlc29sdXRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0ge1xuICAgICAgICB2aWRlbzoge1xuICAgICAgICAgIC4uLnJlc29sdXRpb24sXG4gICAgICAgICAgZmFjaW5nTW9kZTogXCJ1c2VyXCIsXG4gICAgICAgICAgZnJhbWVSYXRlOiB7IGlkZWFsOiAzMCB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFRlc3QgaWYgdGhpcyByZXNvbHV0aW9uIGlzIHN1cHBvcnRlZFxuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGFjdHVhbCBkaW1lbnNpb25zXG4gICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICBjb25zdCBzZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiU3VwcG9ydGVkIHJlc29sdXRpb246XCIsIHNldHRpbmdzLndpZHRoLCBcInhcIiwgc2V0dGluZ3MuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gU3RvcCB0aGUgdGVzdCBzdHJlYW0gaW1tZWRpYXRlbHlcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICBcbiAgICAgIHJldHVybiBjb25zdHJhaW50cztcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBSZXNvbHV0aW9uIG5vdCBzdXBwb3J0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkocmVzb2x1dGlvbil9YCk7XG4gICAgICAvLyBDb250aW51ZSB0byBuZXh0IHJlc29sdXRpb25cbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIG5vdGhpbmcgd29ya2VkLCByZXR1cm4gYmFzaWMgY29uc3RyYWludHNcbiAgcmV0dXJuIHsgXG4gICAgdmlkZW86IHtcbiAgICAgIHdpZHRoOiB7IGV4YWN0OiAxMjgwIH0sXG4gICAgICBoZWlnaHQ6IHsgZXhhY3Q6IDcyMCB9LFxuICAgICAgZnJhbWVSYXRlOiB7IGlkZWFsOiAzMCB9XG4gICAgfSBcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FwdHVyZSBhbmQgc2F2ZSBpbWFnZXMgYXQgYSBzcGVjaWZpYyBwb2ludCB3aXRoIGNvbnNpc3RlbnQgbnVtYmVyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENhcHR1cmUgb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBDYXB0dXJlIHJlc3VsdHNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcHR1cmVJbWFnZXNBdFBvaW50ID0gYXN5bmMgKHsgcG9pbnQsIGNhcHR1cmVDb3VudCA9IDEsIGNhbnZhc1JlZiwgc2V0Q2FwdHVyZUNvdW50LCBzaG93Q2FwdHVyZVByZXZpZXcgfSkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBjYXB0dXJlIGdyb3VwXG4gICAgY29uc3QgY2FwdHVyZUdyb3VwSWQgPSBgY2FwdHVyZS0ke0RhdGUubm93KCl9YDtcbiAgICBjb25zb2xlLmxvZyhgR2VuZXJhdGVkIGNhcHR1cmUgZ3JvdXAgSUQ6ICR7Y2FwdHVyZUdyb3VwSWR9YCk7XG4gICAgXG4gICAgLy8gRmlsZSBwYXR0ZXJucyBmb3Igc2F2aW5nXG4gICAgY29uc3Qgc2NyZWVuRmlsZW5hbWUgPSAnc2NyZWVuXzAwMS5qcGcnOyAgLy8gUGF0dGVybiBvbmx5IC0gc2VydmVyIHdpbGwgYXNzaWduIG51bWJlclxuICAgIGNvbnN0IHdlYmNhbUZpbGVuYW1lID0gJ3dlYmNhbV8wMDEuanBnJzsgIC8vIFBhdHRlcm4gb25seSAtIHNlcnZlciB3aWxsIGFzc2lnbiBudW1iZXJcbiAgICBjb25zdCBwYXJhbWV0ZXJGaWxlbmFtZSA9ICdwYXJhbWV0ZXJfMDAxLmNzdic7ICAvLyBQYXR0ZXJuIG9ubHkgLSBzZXJ2ZXIgd2lsbCBhc3NpZ24gbnVtYmVyXG4gICAgXG4gICAgLy8gRm9yIGxvZ2dpbmdcbiAgICBjb25zb2xlLmxvZyhcIlN0YXJ0aW5nIGNhcHR1cmUgd2l0aCBncm91cCBJRDpcIiwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGxldCBzY3JlZW5JbWFnZSA9IG51bGw7XG4gICAgbGV0IHdlYmNhbUltYWdlID0gbnVsbDtcbiAgICBsZXQgY2FwdHVyZU51bWJlciA9IG51bGw7XG4gICAgXG4gICAgLy8gVmFyaWFibGVzIHRvIHN0b3JlIHdlYmNhbSByZXNvbHV0aW9uXG4gICAgbGV0IHdlYmNhbVdpZHRoID0gMDtcbiAgICBsZXQgd2ViY2FtSGVpZ2h0ID0gMDtcbiAgICBcbiAgICAvLyAxLiBQcmVwYXJlIGFsbCBkYXRhIGZpcnN0XG4gICAgXG4gICAgLy8gMS4xIENhbnZhcy9zY3JlZW4gaW1hZ2VcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBzY3JlZW5JbWFnZSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgIH1cblxuICAgIC8vIDEuMiBXZWJjYW0gaW1hZ2UgLSBUcnkgdG8gZ2V0IHRoZSBoaWdoZXN0IHJlc29sdXRpb24gYXZhaWxhYmxlIFxuICAgIC8vIHdpdGggZGV2aWNlJ3MgbmF0aXZlIGNhcGFiaWxpdGllcyBpbnN0ZWFkIG9mIGZpeGVkIHZhbHVlc1xuICAgIGxldCB3ZWJjYW1JbWFnZVByZXZpZXcgPSBudWxsOyAvLyBTZXBhcmF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICBjb25zdCB2aWRlb0VsZW1lbnQgPSB3aW5kb3cudmlkZW9FbGVtZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3ZpZGVvJyk7XG4gICAgXG4gICAgaWYgKHZpZGVvRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVXNlIGV4aXN0aW5nIHZpZGVvIGVsZW1lbnQgaWYgYXZhaWxhYmxlXG4gICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHZpZGVvVHJhY2sgaGFzIHNldHRpbmdzIGluZm9cbiAgICAgICAgbGV0IHRyYWNrU2V0dGluZ3MgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgaWYgKHZpZGVvRWxlbWVudC5zcmNPYmplY3QpIHtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gdmlkZW9FbGVtZW50LnNyY09iamVjdC5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICB0cmFja1NldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJWaWRlbyB0cmFjayBzZXR0aW5nczpcIiwgdHJhY2tTZXR0aW5ncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgZGltZW5zaW9ucyBmcm9tIHRyYWNrIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZyb20gZWxlbWVudFxuICAgICAgICBpZiAodHJhY2tTZXR0aW5ncyAmJiB0cmFja1NldHRpbmdzLndpZHRoICYmIHRyYWNrU2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSB0cmFja1NldHRpbmdzLndpZHRoO1xuICAgICAgICAgIHdlYmNhbUhlaWdodCA9IHRyYWNrU2V0dGluZ3MuaGVpZ2h0O1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBVc2luZyB0cmFjayBzZXR0aW5ncyBkaW1lbnNpb25zOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIHx8IDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdmlkZW9FbGVtZW50LnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHZpZGVvIGVsZW1lbnQgZGltZW5zaW9uczogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNhbml0eSBjaGVjayAtIGlmIGJvdGggZGltZW5zaW9ucyBhcmUgdGhlIHNhbWUsIGRvdWJsZS1jaGVja1xuICAgICAgICBpZiAod2ViY2FtV2lkdGggPT09IHdlYmNhbUhlaWdodCAmJiB3ZWJjYW1XaWR0aCA+IDEwMCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlN1c3BpY2lvdXMgc3F1YXJlIGFzcGVjdCByYXRpbyBkZXRlY3RlZCwgZG91YmxlLWNoZWNraW5nIGRpbWVuc2lvbnNcIik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJ5IHRvIGdldCBtb3JlIHJlbGlhYmxlIGluZm9cbiAgICAgICAgICBpZiAodmlkZW9FbGVtZW50LnNyY09iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHZpZGVvRWxlbWVudC5zcmNPYmplY3QuZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgICAgICAgIGlmICh2aWRlb1RyYWNrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdmlkZW9UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlZpZGVvIGNvbnN0cmFpbnRzOlwiLCBjb25zdHJhaW50cyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBJZiBjb25zdHJhaW50cyBoYXZlIHdpZHRoL2hlaWdodCwgdXNlIHRob3NlXG4gICAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy53aWR0aCAmJiBjb25zdHJhaW50cy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLndpZHRoLmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgd2ViY2FtV2lkdGggPSBjb25zdHJhaW50cy53aWR0aC5leGFjdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25zdHJhaW50cy53aWR0aC5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gY29uc3RyYWludHMud2lkdGguaWRlYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc3RyYWludHMuaGVpZ2h0LmV4YWN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gY29uc3RyYWludHMuaGVpZ2h0LmV4YWN0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnN0cmFpbnRzLmhlaWdodC5pZGVhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgIHdlYmNhbUhlaWdodCA9IGNvbnN0cmFpbnRzLmhlaWdodC5pZGVhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgZGltZW5zaW9ucyBmcm9tIGNvbnN0cmFpbnRzOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmluYWwgcmVhbGl0eSBjaGVjayAtIG1ha2Ugc3VyZSBkaW1lbnNpb25zIGFyZSByZWFzb25hYmxlXG4gICAgICAgIGlmICh3ZWJjYW1XaWR0aCA8PSAwIHx8IHdlYmNhbUhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCB3ZWJjYW0gZGltZW5zaW9ucywgdXNpbmcgZGVmYXVsdHNcIik7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSA2NDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB3ZWJjYW1XaWR0aDtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCAwLCAwLCB3ZWJjYW1XaWR0aCwgd2ViY2FtSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBsb3dlci1yZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICAgICAgd2ViY2FtSW1hZ2VQcmV2aWV3ID0gYXdhaXQgcmVzaXplSW1hZ2Uod2ViY2FtSW1hZ2UsIDY0MCwgNDgwLCAwLjg1KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBXZWJjYW0gY2FwdHVyZSBjb21wbGV0ZSBhdCByZXNvbHV0aW9uOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIGZyb20gZXhpc3RpbmcgdmlkZW8gZWxlbWVudDpcIiwgZXJyKTtcbiAgICAgICAgd2ViY2FtV2lkdGggPSB2aWRlb0VsZW1lbnQudmlkZW9XaWR0aCB8fCA2NDA7XG4gICAgICAgIHdlYmNhbUhlaWdodCA9IHZpZGVvRWxlbWVudC52aWRlb0hlaWdodCB8fCA0ODA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdldCBoaWdoZXN0IHJlc29sdXRpb24gY29uc3RyYWludHMgZm9yIHRoaXMgZGV2aWNlXG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gYXdhaXQgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cygpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGNhbWVyYSBjb25zdHJhaW50czpcIiwgY29uc3RyYWludHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJ5IHRvIGdldCBzdHJlYW0gd2l0aCBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgZGltZW5zaW9ucyBmcm9tIHRoZSB0cmFjayBmaXJzdFxuICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgIGNvbnN0IHRyYWNrU2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQWN0dWFsIGNhbWVyYSBzZXR0aW5nczpcIiwgdHJhY2tTZXR0aW5ncyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgdGVtcG9yYXJ5IHZpZGVvIGVsZW1lbnQgdG8gZ2V0IHRoZSBzdHJlYW1cbiAgICAgICAgY29uc3QgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICBcbiAgICAgICAgLy8gTmVlZCB0byB3YWl0IGZvciB2aWRlbyB0byBiZSBpbml0aWFsaXplZFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICB0ZW1wVmlkZW8ub25sb2FkZWRtZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRlbXBWaWRlby5wbGF5KCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBGYWxsYmFjayBpZiBvbmxvYWRlZG1ldGFkYXRhIGRvZXNuJ3QgZmlyZVxuICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBhIGJpdCBsb25nZXIgZm9yIHRoZSB2aWRlbyB0byBhY3R1YWxseSBzdGFydCBwbGF5aW5nXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgNTAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSB3ZWJjYW0gcmVzb2x1dGlvbiAtIHByaW9yaXRpemUgdHJhY2sgc2V0dGluZ3Mgb3ZlciB2aWRlbyBlbGVtZW50XG4gICAgICAgIGlmICh0cmFja1NldHRpbmdzICYmIHRyYWNrU2V0dGluZ3Mud2lkdGggJiYgdHJhY2tTZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRyYWNrU2V0dGluZ3Mud2lkdGg7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdHJhY2tTZXR0aW5ncy5oZWlnaHQ7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHRyYWNrIHNldHRpbmdzIGZvciByZXNvbHV0aW9uOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRlbXBWaWRlby52aWRlb1dpZHRoIHx8IDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgY29uc29sZS5sb2coYFVzaW5nIHZpZGVvIGVsZW1lbnQgZm9yIHJlc29sdXRpb246ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBSZWFsaXR5IGNoZWNrIG9uIGRpbWVuc2lvbnNcbiAgICAgICAgaWYgKHdlYmNhbVdpZHRoIDw9IDAgfHwgd2ViY2FtSGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHdlYmNhbSBkaW1lbnNpb25zLCB0cnlpbmcgdG8gZ2V0IGZyb20gY29uc3RyYWludHNcIik7XG4gICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvICYmIHR5cGVvZiBjb25zdHJhaW50cy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50cy52aWRlby53aWR0aCAmJiBjb25zdHJhaW50cy52aWRlby53aWR0aC5leGFjdCkge1xuICAgICAgICAgICAgICB3ZWJjYW1XaWR0aCA9IGNvbnN0cmFpbnRzLnZpZGVvLndpZHRoLmV4YWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvLmhlaWdodCAmJiBjb25zdHJhaW50cy52aWRlby5oZWlnaHQuZXhhY3QpIHtcbiAgICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gY29uc3RyYWludHMudmlkZW8uaGVpZ2h0LmV4YWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZiAod2ViY2FtV2lkdGggPD0gMCB8fCB3ZWJjYW1IZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3RpbGwgaW52YWxpZCBkaW1lbnNpb25zLCB1c2luZyBkZWZhdWx0c1wiKTtcbiAgICAgICAgICAgIHdlYmNhbVdpZHRoID0gNjQwO1xuICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmluYWwgY2hlY2sgZm9yIHNxdWFyZSBhc3BlY3QgcmF0aW8gd2hpY2ggaXMgdXN1YWxseSBpbmNvcnJlY3RcbiAgICAgICAgaWYgKHdlYmNhbVdpZHRoID09PSB3ZWJjYW1IZWlnaHQgJiYgd2ViY2FtV2lkdGggPiAxMDApIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJTcXVhcmUgYXNwZWN0IHJhdGlvIGRldGVjdGVkLCBtYXkgYmUgaW5jb3JyZWN0XCIpO1xuICAgICAgICAgIC8vIFRyeSB0byBnZXQgbW9yZSByZWxpYWJsZSBkaW1lbnNpb25zXG4gICAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdmlkZW9UcmFjay5nZXRDYXBhYmlsaXRpZXM/LigpO1xuICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMgJiYgY2FwYWJpbGl0aWVzLndpZHRoICYmIGNhcGFiaWxpdGllcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChjYXBhYmlsaXRpZXMud2lkdGgubWF4ICYmIGNhcGFiaWxpdGllcy5oZWlnaHQubWF4KSB7XG4gICAgICAgICAgICAgIC8vIEFzc3VtZSB0aGUgbWF4aW11bSBjYXBhYmlsaXRpZXMgaGF2ZSB0aGUgY29ycmVjdCBhc3BlY3QgcmF0aW9cbiAgICAgICAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBjYXBhYmlsaXRpZXMud2lkdGgubWF4IC8gY2FwYWJpbGl0aWVzLmhlaWdodC5tYXg7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoYXNwZWN0UmF0aW8gLSAxLjMzKSA8IDAuMSkgeyAvLyBDbG9zZSB0byA0OjNcbiAgICAgICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBNYXRoLnJvdW5kKHdlYmNhbVdpZHRoIC8gMS4zMyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvcnJlY3RlZCB0byA0OjMgYXNwZWN0IHJhdGlvOiAke3dlYmNhbVdpZHRofXgke3dlYmNhbUhlaWdodH1gKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhhc3BlY3RSYXRpbyAtIDEuNzgpIDwgMC4xKSB7IC8vIENsb3NlIHRvIDE2OjlcbiAgICAgICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSBNYXRoLnJvdW5kKHdlYmNhbVdpZHRoIC8gMS43OCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvcnJlY3RlZCB0byAxNjo5IGFzcGVjdCByYXRpbzogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHdlYmNhbVdpZHRoO1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHdlYmNhbUhlaWdodDtcbiAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHdlYmNhbVdpZHRoLCB3ZWJjYW1IZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGhpZ2gtcmVzb2x1dGlvbiB2ZXJzaW9uIGZvciBzYXZpbmdcbiAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOTUpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGxvd2VyLXJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgICAgICB3ZWJjYW1JbWFnZVByZXZpZXcgPSBhd2FpdCByZXNpemVJbWFnZSh3ZWJjYW1JbWFnZSwgNjQwLCA0ODAsIDAuODUpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYEhpZ2gtcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZSBjb21wbGV0ZTogJHt3ZWJjYW1XaWR0aH14JHt3ZWJjYW1IZWlnaHR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0ID0+IHQuc3RvcCgpKTtcbiAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkhpZ2gtcmVzb2x1dGlvbiB3ZWJjYW0gY2FwdHVyZSBmYWlsZWQ6XCIsIGVycik7XG4gICAgICAgIFxuICAgICAgICAvLyBUcnkgb25lIG1vcmUgdGltZSB3aXRoIGJhc2ljIGNvbnN0cmFpbnRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcbiAgICAgICAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgICAgICAgY29uc3QgdHJhY2tTZXR0aW5ncyA9IHZpZGVvVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zdCB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgICBhd2FpdCB0ZW1wVmlkZW8ucGxheSgpO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgMzAwKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gR2V0IGRpbWVuc2lvbnMgZnJvbSB0cmFjayBzZXR0aW5ncyBpZiBhdmFpbGFibGVcbiAgICAgICAgICBpZiAodHJhY2tTZXR0aW5ncyAmJiB0cmFja1NldHRpbmdzLndpZHRoICYmIHRyYWNrU2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgICAgICB3ZWJjYW1XaWR0aCA9IHRyYWNrU2V0dGluZ3Mud2lkdGg7XG4gICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSB0cmFja1NldHRpbmdzLmhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViY2FtV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCAwO1xuICAgICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZpbmFsIGNoZWNrIGZvciBpbnZhbGlkIGRpbWVuc2lvbnNcbiAgICAgICAgICBpZiAod2ViY2FtV2lkdGggPD0gMCB8fCB3ZWJjYW1IZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgd2ViY2FtV2lkdGggPSA2NDA7XG4gICAgICAgICAgICB3ZWJjYW1IZWlnaHQgPSA0ODA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2ViY2FtV2lkdGg7XG4gICAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB3ZWJjYW1IZWlnaHQ7XG4gICAgICAgICAgdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHdlYmNhbVdpZHRoLCB3ZWJjYW1IZWlnaHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBoaWdoLXJlc29sdXRpb24gdmVyc2lvbiBmb3Igc2F2aW5nXG4gICAgICAgICAgd2ViY2FtSW1hZ2UgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGxvd2VyLXJlc29sdXRpb24gdmVyc2lvbiBmb3IgcHJldmlld1xuICAgICAgICAgIHdlYmNhbUltYWdlUHJldmlldyA9IGF3YWl0IHJlc2l6ZUltYWdlKHdlYmNhbUltYWdlLCA2NDAsIDQ4MCwgMC44KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQmFzaWMgd2ViY2FtIHJlc29sdXRpb24gY2FwdHVyZWQ6ICR7d2ViY2FtV2lkdGh9eCR7d2ViY2FtSGVpZ2h0fWApO1xuICAgICAgICAgIFxuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHQgPT4gdC5zdG9wKCkpO1xuICAgICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQWxsIHdlYmNhbSBjYXB0dXJlIG1ldGhvZHMgZmFpbGVkOlwiLCBmYWxsYmFja0Vycik7XG4gICAgICAgICAgd2ViY2FtV2lkdGggPSA2NDA7XG4gICAgICAgICAgd2ViY2FtSGVpZ2h0ID0gNDgwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMS4zIFBhcmFtZXRlciBkYXRhIC0gTm93IGluY2x1ZGluZyB3ZWJjYW0gcmVzb2x1dGlvblxuICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICBcIm5hbWUsdmFsdWVcIixcbiAgICAgIGBkb3RfeCwke3BvaW50Lnh9YCxcbiAgICAgIGBkb3RfeSwke3BvaW50Lnl9YCxcbiAgICAgIGBjYW52YXNfd2lkdGgsJHtjYW52YXM/LndpZHRoIHx8IDB9YCxcbiAgICAgIGBjYW52YXNfaGVpZ2h0LCR7Y2FudmFzPy5oZWlnaHQgfHwgMH1gLFxuICAgICAgYHdpbmRvd193aWR0aCwke3dpbmRvdy5pbm5lcldpZHRofWAsXG4gICAgICBgd2luZG93X2hlaWdodCwke3dpbmRvdy5pbm5lckhlaWdodH1gLFxuICAgICAgYHdlYmNhbV9yZXNvbHV0aW9uX3dpZHRoLCR7d2ViY2FtV2lkdGh9YCxcbiAgICAgIGB3ZWJjYW1fcmVzb2x1dGlvbl9oZWlnaHQsJHt3ZWJjYW1IZWlnaHR9YCxcbiAgICAgIGB0aW1lc3RhbXAsJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCxcbiAgICAgIGBncm91cF9pZCwke2NhcHR1cmVHcm91cElkfWBcbiAgICBdLmpvaW4oJ1xcbicpO1xuICAgIFxuICAgIC8vIDIuIFNhdmUgYWxsIGZpbGVzIHdpdGggdGhlIHNhbWUgZ3JvdXAgSUQgc28gdGhleSBnZXQgdGhlIHNhbWUgbnVtYmVyXG4gICAgXG4gICAgLy8gMi4xIFNhdmUgcGFyYW1ldGVyIGZpbGVcbiAgICBjb25zdCBwYXJhbVJlc3VsdCA9IGF3YWl0IHNhdmVDU1ZUb1NlcnZlcihjc3ZEYXRhLCBwYXJhbWV0ZXJGaWxlbmFtZSwgZm9sZGVyLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgXG4gICAgaWYgKHBhcmFtUmVzdWx0ICYmIHBhcmFtUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGNhcHR1cmVOdW1iZXIgPSBwYXJhbVJlc3VsdC5udW1iZXI7XG4gICAgICBjb25zb2xlLmxvZyhgU2VydmVyIGFzc2lnbmVkIGNhcHR1cmUgbnVtYmVyOiAke2NhcHR1cmVOdW1iZXJ9IGZvciBncm91cDogJHtjYXB0dXJlR3JvdXBJZH1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gMi4yIFNhdmUgc2NyZWVuIGltYWdlIGlmIGF2YWlsYWJsZVxuICAgIGxldCBzY3JlZW5SZXN1bHQgPSBudWxsO1xuICAgIGlmIChzY3JlZW5JbWFnZSkge1xuICAgICAgc2NyZWVuUmVzdWx0ID0gYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIoc2NyZWVuSW1hZ2UsIHNjcmVlbkZpbGVuYW1lLCAnc2NyZWVuJywgZm9sZGVyLCBjYXB0dXJlR3JvdXBJZCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDIuMyBTYXZlIHdlYmNhbSBpbWFnZSBpZiBhdmFpbGFibGVcbiAgICBsZXQgd2ViY2FtUmVzdWx0ID0gbnVsbDtcbiAgICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICAgIHdlYmNhbVJlc3VsdCA9IGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKHdlYmNhbUltYWdlLCB3ZWJjYW1GaWxlbmFtZSwgJ3dlYmNhbScsIGZvbGRlciwgY2FwdHVyZUdyb3VwSWQpO1xuICAgIH1cbiAgICBcbiAgICAvLyAzLiBTaG93IHByZXZpZXcgaWYgbmVlZGVkIC0gdXNlIHRoZSBsb3dlciByZXNvbHV0aW9uIHZlcnNpb24gZm9yIHByZXZpZXdcbiAgICBpZiAoc2hvd0NhcHR1cmVQcmV2aWV3ICYmIHR5cGVvZiBzaG93Q2FwdHVyZVByZXZpZXcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNob3dDYXB0dXJlUHJldmlldyhzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2VQcmV2aWV3IHx8IHdlYmNhbUltYWdlLCBwb2ludCk7XG4gICAgfVxuICAgIFxuICAgIC8vIDQuIEluY3JlbWVudCBjb3VudGVyIGZvciBuZXh0IGNhcHR1cmVcbiAgICBpZiAoc2V0Q2FwdHVyZUNvdW50ICYmIHR5cGVvZiBzZXRDYXB0dXJlQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNldENhcHR1cmVDb3VudChwcmV2Q291bnQgPT4gcHJldkNvdW50ICsgMSk7XG4gICAgfVxuICAgIFxuICAgIC8vIDUuIFJldHVybiByZXN1bHRzIC0gbm93IGluY2x1ZGluZyB3ZWJjYW0gcmVzb2x1dGlvblxuICAgIHJldHVybiB7XG4gICAgICBzY3JlZW5JbWFnZSxcbiAgICAgIHdlYmNhbUltYWdlLFxuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIHBvaW50LFxuICAgICAgY2FwdHVyZU51bWJlcixcbiAgICAgIGdyb3VwSWQ6IGNhcHR1cmVHcm91cElkLFxuICAgICAgd2ViY2FtV2lkdGgsXG4gICAgICB3ZWJjYW1IZWlnaHRcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiY2FwdHVyZUltYWdlc0F0UG9pbnQgZmFpbGVkOlwiLCBlcnIpO1xuICAgIHJldHVybiB7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6IGVyci5tZXNzYWdlLFxuICAgICAgc2NyZWVuSW1hZ2U6IG51bGwsXG4gICAgICB3ZWJjYW1JbWFnZTogbnVsbCxcbiAgICAgIHdlYmNhbVdpZHRoOiAwLFxuICAgICAgd2ViY2FtSGVpZ2h0OiAwXG4gICAgfTtcbiAgfVxufTsiXSwibmFtZXMiOlsicmVzaXplSW1hZ2UiLCJpbWFnZURhdGFVcmwiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInF1YWxpdHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwib25sb2FkIiwid2lkdGgiLCJoZWlnaHQiLCJNYXRoIiwicm91bmQiLCJjYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwicmVzaXplZERhdGFVcmwiLCJ0b0RhdGFVUkwiLCJvbmVycm9yIiwiZXJyIiwic3JjIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJpbWFnZURhdGEiLCJmaWxlbmFtZSIsInR5cGUiLCJmb2xkZXIiLCJjYXB0dXJlR3JvdXAiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwiZXJyb3IiLCJzdGF0dXMiLCJ3YXJuIiwic2l6ZXMiLCJyZXNpemVkSW1hZ2UiLCJyZXRyeVJlc3BvbnNlIiwibG9nIiwianNvbiIsInJldHJ5RXJyb3IiLCJzdWNjZXNzIiwicmVzdWx0IiwibWVzc2FnZSIsInNhdmVDU1ZUb1NlcnZlciIsImNzdkRhdGEiLCJjc3ZCbG9iIiwiQmxvYiIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVhZEFzRGF0YVVSTCIsImdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMiLCJ2aWRlb1RyYWNrIiwidGVtcFN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiZ2V0VmlkZW9UcmFja3MiLCJjYXBhYmlsaXRpZXMiLCJnZXRDYXBhYmlsaXRpZXMiLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwic3RvcCIsIm1heCIsImV4YWN0IiwiZnJhbWVSYXRlIiwiaWRlYWwiLCJyZXNvbHV0aW9ucyIsInJlc29sdXRpb24iLCJjb25zdHJhaW50cyIsImZhY2luZ01vZGUiLCJzdHJlYW0iLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsInBvaW50IiwiY2FwdHVyZUNvdW50IiwiY2FudmFzUmVmIiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiY2FwdHVyZUdyb3VwSWQiLCJEYXRlIiwibm93Iiwic2NyZWVuRmlsZW5hbWUiLCJ3ZWJjYW1GaWxlbmFtZSIsInBhcmFtZXRlckZpbGVuYW1lIiwiY3VycmVudCIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJjYXB0dXJlTnVtYmVyIiwid2ViY2FtV2lkdGgiLCJ3ZWJjYW1IZWlnaHQiLCJ3ZWJjYW1JbWFnZVByZXZpZXciLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwidHJhY2tTZXR0aW5ncyIsInNyY09iamVjdCIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImdldENvbnN0cmFpbnRzIiwidGVtcENhbnZhcyIsInRlbXBWaWRlbyIsIm11dGVkIiwicGxheXNJbmxpbmUiLCJhdXRvcGxheSIsImFwcGVuZENoaWxkIiwib25sb2FkZWRtZXRhZGF0YSIsInBsYXkiLCJzZXRUaW1lb3V0IiwicmVzIiwiYXNwZWN0UmF0aW8iLCJhYnMiLCJ0IiwicmVtb3ZlIiwiZmFsbGJhY2tFcnIiLCJ4IiwieSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsInRvSVNPU3RyaW5nIiwiam9pbiIsInBhcmFtUmVzdWx0IiwibnVtYmVyIiwic2NyZWVuUmVzdWx0Iiwid2ViY2FtUmVzdWx0IiwicHJldkNvdW50IiwiZ3JvdXBJZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fporchportal2%2FDesktop%2F%F0%9F%94%A5everything%2FMain_Web_EyeTracking%2Fmain-web%2Ffrontend%2Fpages%2Fcollected-dataset-customized%2Findex.js&page=%2Fcollected-dataset-customized!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fporchportal2%2FDesktop%2F%F0%9F%94%A5everything%2FMain_Web_EyeTracking%2Fmain-web%2Ffrontend%2Fpages%2Fcollected-dataset-customized%2Findex.js&page=%2Fcollected-dataset-customized! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/collected-dataset-customized\",\n      function () {\n        return __webpack_require__(/*! ./pages/collected-dataset-customized/index.js */ \"(pages-dir-browser)/./pages/collected-dataset-customized/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/collected-dataset-customized\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcz9hYnNvbHV0ZVBhZ2VQYXRoPSUyRlVzZXJzJTJGcG9yY2hwb3J0YWwyJTJGRGVza3RvcCUyRiVGMCU5RiU5NCVBNWV2ZXJ5dGhpbmclMkZNYWluX1dlYl9FeWVUcmFja2luZyUyRm1haW4td2ViJTJGZnJvbnRlbmQlMkZwYWdlcyUyRmNvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQlMkZpbmRleC5qcyZwYWdlPSUyRmNvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsd0hBQStDO0FBQ3RFO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWRcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWRcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fporchportal2%2FDesktop%2F%F0%9F%94%A5everything%2FMain_Web_EyeTracking%2Fmain-web%2Ffrontend%2Fpages%2Fcollected-dataset-customized%2Findex.js&page=%2Fcollected-dataset-customized!\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/compiled/client-only/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/next/dist/compiled/client-only/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {



/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/dynamic.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/dynamic.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    /**\n * This function lets you dynamically import a component.\n * It uses [React.lazy()](https://react.dev/reference/react/lazy) with [Suspense](https://react.dev/reference/react/Suspense) under the hood.\n *\n * Read more: [Next.js Docs: `next/dynamic`](https://nextjs.org/docs/app/building-your-application/optimizing/lazy-loading#nextdynamic)\n */ default: function() {\n        return dynamic;\n    },\n    noSSR: function() {\n        return noSSR;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst _loadablesharedruntime = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./loadable.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/loadable.shared-runtime.js\"));\nconst isServerSide = \"object\" === 'undefined';\n// Normalize loader to return the module as form { default: Component } for `React.lazy`.\n// Also for backward compatible since next/dynamic allows to resolve a component directly with loader\n// Client component reference proxy need to be converted to a module.\nfunction convertModule(mod) {\n    return {\n        default: (mod == null ? void 0 : mod.default) || mod\n    };\n}\nfunction noSSR(LoadableInitializer, loadableOptions) {\n    // Removing webpack and modules means react-loadable won't try preloading\n    delete loadableOptions.webpack;\n    delete loadableOptions.modules;\n    // This check is necessary to prevent react-loadable from initializing on the server\n    if (!isServerSide) {\n        return LoadableInitializer(loadableOptions);\n    }\n    const Loading = loadableOptions.loading;\n    // This will only be rendered on the server side\n    return ()=>/*#__PURE__*/ (0, _jsxruntime.jsx)(Loading, {\n            error: null,\n            isLoading: true,\n            pastDelay: false,\n            timedOut: false\n        });\n}\nfunction dynamic(dynamicOptions, options) {\n    let loadableFn = _loadablesharedruntime.default;\n    let loadableOptions = {\n        // A loading component is not required, so we default it\n        loading: (param)=>{\n            let { error, isLoading, pastDelay } = param;\n            if (!pastDelay) return null;\n            if (true) {\n                if (isLoading) {\n                    return null;\n                }\n                if (error) {\n                    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(\"p\", {\n                        children: [\n                            error.message,\n                            /*#__PURE__*/ (0, _jsxruntime.jsx)(\"br\", {}),\n                            error.stack\n                        ]\n                    });\n                }\n            }\n            return null;\n        }\n    };\n    // Support for direct import(), eg: dynamic(import('../hello-world'))\n    // Note that this is only kept for the edge case where someone is passing in a promise as first argument\n    // The react-loadable babel plugin will turn dynamic(import('../hello-world')) into dynamic(() => import('../hello-world'))\n    // To make sure we don't execute the import without rendering first\n    if (dynamicOptions instanceof Promise) {\n        loadableOptions.loader = ()=>dynamicOptions;\n    // Support for having import as a function, eg: dynamic(() => import('../hello-world'))\n    } else if (typeof dynamicOptions === 'function') {\n        loadableOptions.loader = dynamicOptions;\n    // Support for having first argument being options, eg: dynamic({loader: import('../hello-world')})\n    } else if (typeof dynamicOptions === 'object') {\n        loadableOptions = {\n            ...loadableOptions,\n            ...dynamicOptions\n        };\n    }\n    // Support for passing options, eg: dynamic(import('../hello-world'), {loading: () => <p>Loading something</p>})\n    loadableOptions = {\n        ...loadableOptions,\n        ...options\n    };\n    const loaderFn = loadableOptions.loader;\n    const loader = ()=>loaderFn != null ? loaderFn().then(convertModule) : Promise.resolve(convertModule(()=>null));\n    // coming from build/babel/plugins/react-loadable-plugin.js\n    if (loadableOptions.loadableGenerated) {\n        loadableOptions = {\n            ...loadableOptions,\n            ...loadableOptions.loadableGenerated\n        };\n        delete loadableOptions.loadableGenerated;\n    }\n    // support for disabling server side rendering, eg: dynamic(() => import('../hello-world'), {ssr: false}).\n    if (typeof loadableOptions.ssr === 'boolean' && !loadableOptions.ssr) {\n        delete loadableOptions.webpack;\n        delete loadableOptions.modules;\n        return noSSR(loadableFn, loadableOptions);\n    }\n    return loadableFn({\n        ...loadableOptions,\n        loader: loader\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=dynamic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9keW5hbWljLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQXdFQTs7Ozs7Q0FLQyxHQUNELE9BcUVDO2VBckV1QkE7O0lBMUJSQyxLQUFLO2VBQUxBOzs7Ozs0RUFwREU7NEZBQ0c7QUFFckIsTUFBTUMsZUFBZSxPQUFPQyxNQUFXO0FBMkJ2Qyx5RkFBeUY7QUFDekYscUdBQXFHO0FBQ3JHLHFFQUFxRTtBQUNyRSxTQUFTQyxjQUFpQkMsR0FBZ0Q7SUFDeEUsT0FBTztRQUFFQyxTQUFTLENBQUNELE9BQUFBLE9BQUFBLEtBQUFBLElBQUFBLElBQTRCQyxPQUFBQSxLQUFXRDtJQUFJO0FBQ2hFO0FBaUJPLFNBQVNKLE1BQ2RNLG1CQUFrQyxFQUNsQ0MsZUFBa0M7SUFFbEMseUVBQXlFO0lBQ3pFLE9BQU9BLGdCQUFnQkMsT0FBTztJQUM5QixPQUFPRCxnQkFBZ0JFLE9BQU87SUFFOUIsb0ZBQW9GO0lBQ3BGLElBQUksQ0FBQ1IsY0FBYztRQUNqQixPQUFPSyxvQkFBb0JDO0lBQzdCO0lBRUEsTUFBTUcsVUFBVUgsZ0JBQWdCSSxPQUFPO0lBQ3ZDLGdEQUFnRDtJQUNoRCxPQUFPLGtCQUNMLHFCQUFDRCxTQUFBQTtZQUFRRSxPQUFPO1lBQU1DLFNBQVM7WUFBQ0MsV0FBVztZQUFPQyxVQUFVOztBQUVoRTtBQVFlLFNBQVNoQixRQUN0QmlCLGNBQTZDLEVBQzdDQyxPQUEyQjtJQUUzQixJQUFJQyxhQUFhQyx1QkFBQUEsT0FBUTtJQUV6QixJQUFJWixrQkFBc0M7UUFDeEMsd0RBQXdEO1FBQ3hESSxTQUFTO2dCQUFDLEVBQUVDLEtBQUssRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUU7WUFDdkMsSUFBSSxDQUFDQSxXQUFXLE9BQU87WUFDdkIsSUFBSU0sSUFBb0IsRUFBbUI7Z0JBQ3pDLElBQUlQLFdBQVc7b0JBQ2IsT0FBTztnQkFDVDtnQkFDQSxJQUFJRCxPQUFPO29CQUNULHFCQUNFLHNCQUFDVyxLQUFBQTs7NEJBQ0VYLE1BQU1ZLE9BQU87MENBQ2QscUJBQUNDLE1BQUFBLENBQUFBOzRCQUNBYixNQUFNYyxLQUFLOzs7Z0JBR2xCO1lBQ0Y7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLHFFQUFxRTtJQUNyRSx3R0FBd0c7SUFDeEcsMkhBQTJIO0lBQzNILG1FQUFtRTtJQUNuRSxJQUFJViwwQkFBMEJXLFNBQVM7UUFDckNwQixnQkFBZ0JxQixNQUFNLEdBQUcsSUFBTVo7SUFDL0IsdUZBQXVGO0lBQ3pGLE9BQU8sSUFBSSxPQUFPQSxtQkFBbUIsWUFBWTtRQUMvQ1QsZ0JBQWdCcUIsTUFBTSxHQUFHWjtJQUN6QixtR0FBbUc7SUFDckcsT0FBTyxJQUFJLE9BQU9BLG1CQUFtQixVQUFVO1FBQzdDVCxrQkFBa0I7WUFBRSxHQUFHQSxlQUFlO1lBQUUsR0FBR1MsY0FBYztRQUFDO0lBQzVEO0lBRUEsZ0hBQWdIO0lBQ2hIVCxrQkFBa0I7UUFBRSxHQUFHQSxlQUFlO1FBQUUsR0FBR1UsT0FBTztJQUFDO0lBRW5ELE1BQU1ZLFdBQVd0QixnQkFBZ0JxQixNQUFNO0lBQ3ZDLE1BQU1BLFNBQVMsSUFDYkMsWUFBWSxPQUNSQSxXQUFXQyxJQUFJLENBQUMzQixpQkFDaEJ3QixRQUFRSSxPQUFPLENBQUM1QixjQUFjLElBQU07SUFFMUMsMkRBQTJEO0lBQzNELElBQUlJLGdCQUFnQnlCLGlCQUFpQixFQUFFO1FBQ3JDekIsa0JBQWtCO1lBQ2hCLEdBQUdBLGVBQWU7WUFDbEIsR0FBR0EsZ0JBQWdCeUIsaUJBQWlCO1FBQ3RDO1FBQ0EsT0FBT3pCLGdCQUFnQnlCLGlCQUFpQjtJQUMxQztJQUVBLDBHQUEwRztJQUMxRyxJQUFJLE9BQU96QixnQkFBZ0IwQixHQUFHLEtBQUssYUFBYSxDQUFDMUIsZ0JBQWdCMEIsR0FBRyxFQUFFO1FBQ3BFLE9BQU8xQixnQkFBZ0JDLE9BQU87UUFDOUIsT0FBT0QsZ0JBQWdCRSxPQUFPO1FBRTlCLE9BQU9ULE1BQU1rQixZQUFZWDtJQUMzQjtJQUVBLE9BQU9XLFdBQVc7UUFBRSxHQUFHWCxlQUFlO1FBQUVxQixRQUFRQTtJQUFvQjtBQUN0RSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL3NyYy9zaGFyZWQvbGliL2R5bmFtaWMudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBMb2FkYWJsZSBmcm9tICcuL2xvYWRhYmxlLnNoYXJlZC1ydW50aW1lJ1xuXG5jb25zdCBpc1NlcnZlclNpZGUgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuXG50eXBlIENvbXBvbmVudE1vZHVsZTxQID0ge30+ID0geyBkZWZhdWx0OiBSZWFjdC5Db21wb25lbnRUeXBlPFA+IH1cblxuZXhwb3J0IGRlY2xhcmUgdHlwZSBMb2FkZXJDb21wb25lbnQ8UCA9IHt9PiA9IFByb21pc2U8XG4gIFJlYWN0LkNvbXBvbmVudFR5cGU8UD4gfCBDb21wb25lbnRNb2R1bGU8UD5cbj5cblxuZXhwb3J0IGRlY2xhcmUgdHlwZSBMb2FkZXI8UCA9IHt9PiA9XG4gIHwgKCgpID0+IExvYWRlckNvbXBvbmVudDxQPilcbiAgfCBMb2FkZXJDb21wb25lbnQ8UD5cblxuZXhwb3J0IHR5cGUgTG9hZGVyTWFwID0geyBbbW9kdWxlOiBzdHJpbmddOiAoKSA9PiBMb2FkZXI8YW55PiB9XG5cbmV4cG9ydCB0eXBlIExvYWRhYmxlR2VuZXJhdGVkT3B0aW9ucyA9IHtcbiAgd2VicGFjaz8oKTogYW55XG4gIG1vZHVsZXM/KCk6IExvYWRlck1hcFxufVxuXG5leHBvcnQgdHlwZSBEeW5hbWljT3B0aW9uc0xvYWRpbmdQcm9wcyA9IHtcbiAgZXJyb3I/OiBFcnJvciB8IG51bGxcbiAgaXNMb2FkaW5nPzogYm9vbGVhblxuICBwYXN0RGVsYXk/OiBib29sZWFuXG4gIHJldHJ5PzogKCkgPT4gdm9pZFxuICB0aW1lZE91dD86IGJvb2xlYW5cbn1cblxuLy8gTm9ybWFsaXplIGxvYWRlciB0byByZXR1cm4gdGhlIG1vZHVsZSBhcyBmb3JtIHsgZGVmYXVsdDogQ29tcG9uZW50IH0gZm9yIGBSZWFjdC5sYXp5YC5cbi8vIEFsc28gZm9yIGJhY2t3YXJkIGNvbXBhdGlibGUgc2luY2UgbmV4dC9keW5hbWljIGFsbG93cyB0byByZXNvbHZlIGEgY29tcG9uZW50IGRpcmVjdGx5IHdpdGggbG9hZGVyXG4vLyBDbGllbnQgY29tcG9uZW50IHJlZmVyZW5jZSBwcm94eSBuZWVkIHRvIGJlIGNvbnZlcnRlZCB0byBhIG1vZHVsZS5cbmZ1bmN0aW9uIGNvbnZlcnRNb2R1bGU8UD4obW9kOiBSZWFjdC5Db21wb25lbnRUeXBlPFA+IHwgQ29tcG9uZW50TW9kdWxlPFA+KSB7XG4gIHJldHVybiB7IGRlZmF1bHQ6IChtb2QgYXMgQ29tcG9uZW50TW9kdWxlPFA+KT8uZGVmYXVsdCB8fCBtb2QgfVxufVxuXG5leHBvcnQgdHlwZSBEeW5hbWljT3B0aW9uczxQID0ge30+ID0gTG9hZGFibGVHZW5lcmF0ZWRPcHRpb25zICYge1xuICBsb2FkaW5nPzogKGxvYWRpbmdQcm9wczogRHluYW1pY09wdGlvbnNMb2FkaW5nUHJvcHMpID0+IFJlYWN0LlJlYWN0Tm9kZVxuICBsb2FkZXI/OiBMb2FkZXI8UD4gfCBMb2FkZXJNYXBcbiAgbG9hZGFibGVHZW5lcmF0ZWQ/OiBMb2FkYWJsZUdlbmVyYXRlZE9wdGlvbnNcbiAgc3NyPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBMb2FkYWJsZU9wdGlvbnM8UCA9IHt9PiA9IER5bmFtaWNPcHRpb25zPFA+XG5cbmV4cG9ydCB0eXBlIExvYWRhYmxlRm48UCA9IHt9PiA9IChcbiAgb3B0czogTG9hZGFibGVPcHRpb25zPFA+XG4pID0+IFJlYWN0LkNvbXBvbmVudFR5cGU8UD5cblxuZXhwb3J0IHR5cGUgTG9hZGFibGVDb21wb25lbnQ8UCA9IHt9PiA9IFJlYWN0LkNvbXBvbmVudFR5cGU8UD5cblxuZXhwb3J0IGZ1bmN0aW9uIG5vU1NSPFAgPSB7fT4oXG4gIExvYWRhYmxlSW5pdGlhbGl6ZXI6IExvYWRhYmxlRm48UD4sXG4gIGxvYWRhYmxlT3B0aW9uczogRHluYW1pY09wdGlvbnM8UD5cbik6IFJlYWN0LkNvbXBvbmVudFR5cGU8UD4ge1xuICAvLyBSZW1vdmluZyB3ZWJwYWNrIGFuZCBtb2R1bGVzIG1lYW5zIHJlYWN0LWxvYWRhYmxlIHdvbid0IHRyeSBwcmVsb2FkaW5nXG4gIGRlbGV0ZSBsb2FkYWJsZU9wdGlvbnMud2VicGFja1xuICBkZWxldGUgbG9hZGFibGVPcHRpb25zLm1vZHVsZXNcblxuICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHJlYWN0LWxvYWRhYmxlIGZyb20gaW5pdGlhbGl6aW5nIG9uIHRoZSBzZXJ2ZXJcbiAgaWYgKCFpc1NlcnZlclNpZGUpIHtcbiAgICByZXR1cm4gTG9hZGFibGVJbml0aWFsaXplcihsb2FkYWJsZU9wdGlvbnMpXG4gIH1cblxuICBjb25zdCBMb2FkaW5nID0gbG9hZGFibGVPcHRpb25zLmxvYWRpbmchXG4gIC8vIFRoaXMgd2lsbCBvbmx5IGJlIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICByZXR1cm4gKCkgPT4gKFxuICAgIDxMb2FkaW5nIGVycm9yPXtudWxsfSBpc0xvYWRpbmcgcGFzdERlbGF5PXtmYWxzZX0gdGltZWRPdXQ9e2ZhbHNlfSAvPlxuICApXG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsZXRzIHlvdSBkeW5hbWljYWxseSBpbXBvcnQgYSBjb21wb25lbnQuXG4gKiBJdCB1c2VzIFtSZWFjdC5sYXp5KCldKGh0dHBzOi8vcmVhY3QuZGV2L3JlZmVyZW5jZS9yZWFjdC9sYXp5KSB3aXRoIFtTdXNwZW5zZV0oaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L1N1c3BlbnNlKSB1bmRlciB0aGUgaG9vZC5cbiAqXG4gKiBSZWFkIG1vcmU6IFtOZXh0LmpzIERvY3M6IGBuZXh0L2R5bmFtaWNgXShodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9vcHRpbWl6aW5nL2xhenktbG9hZGluZyNuZXh0ZHluYW1pYylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZHluYW1pYzxQID0ge30+KFxuICBkeW5hbWljT3B0aW9uczogRHluYW1pY09wdGlvbnM8UD4gfCBMb2FkZXI8UD4sXG4gIG9wdGlvbnM/OiBEeW5hbWljT3B0aW9uczxQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxQPiB7XG4gIGxldCBsb2FkYWJsZUZuID0gTG9hZGFibGUgYXMgTG9hZGFibGVGbjxQPlxuXG4gIGxldCBsb2FkYWJsZU9wdGlvbnM6IExvYWRhYmxlT3B0aW9uczxQPiA9IHtcbiAgICAvLyBBIGxvYWRpbmcgY29tcG9uZW50IGlzIG5vdCByZXF1aXJlZCwgc28gd2UgZGVmYXVsdCBpdFxuICAgIGxvYWRpbmc6ICh7IGVycm9yLCBpc0xvYWRpbmcsIHBhc3REZWxheSB9KSA9PiB7XG4gICAgICBpZiAoIXBhc3REZWxheSkgcmV0dXJuIG51bGxcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChpc0xvYWRpbmcpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAge2Vycm9yLm1lc3NhZ2V9XG4gICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICB7ZXJyb3Iuc3RhY2t9XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0sXG4gIH1cblxuICAvLyBTdXBwb3J0IGZvciBkaXJlY3QgaW1wb3J0KCksIGVnOiBkeW5hbWljKGltcG9ydCgnLi4vaGVsbG8td29ybGQnKSlcbiAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgb25seSBrZXB0IGZvciB0aGUgZWRnZSBjYXNlIHdoZXJlIHNvbWVvbmUgaXMgcGFzc2luZyBpbiBhIHByb21pc2UgYXMgZmlyc3QgYXJndW1lbnRcbiAgLy8gVGhlIHJlYWN0LWxvYWRhYmxlIGJhYmVsIHBsdWdpbiB3aWxsIHR1cm4gZHluYW1pYyhpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJykpIGludG8gZHluYW1pYygoKSA9PiBpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJykpXG4gIC8vIFRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBleGVjdXRlIHRoZSBpbXBvcnQgd2l0aG91dCByZW5kZXJpbmcgZmlyc3RcbiAgaWYgKGR5bmFtaWNPcHRpb25zIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgIGxvYWRhYmxlT3B0aW9ucy5sb2FkZXIgPSAoKSA9PiBkeW5hbWljT3B0aW9uc1xuICAgIC8vIFN1cHBvcnQgZm9yIGhhdmluZyBpbXBvcnQgYXMgYSBmdW5jdGlvbiwgZWc6IGR5bmFtaWMoKCkgPT4gaW1wb3J0KCcuLi9oZWxsby13b3JsZCcpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkeW5hbWljT3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxvYWRhYmxlT3B0aW9ucy5sb2FkZXIgPSBkeW5hbWljT3B0aW9uc1xuICAgIC8vIFN1cHBvcnQgZm9yIGhhdmluZyBmaXJzdCBhcmd1bWVudCBiZWluZyBvcHRpb25zLCBlZzogZHluYW1pYyh7bG9hZGVyOiBpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJyl9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBkeW5hbWljT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICBsb2FkYWJsZU9wdGlvbnMgPSB7IC4uLmxvYWRhYmxlT3B0aW9ucywgLi4uZHluYW1pY09wdGlvbnMgfVxuICB9XG5cbiAgLy8gU3VwcG9ydCBmb3IgcGFzc2luZyBvcHRpb25zLCBlZzogZHluYW1pYyhpbXBvcnQoJy4uL2hlbGxvLXdvcmxkJyksIHtsb2FkaW5nOiAoKSA9PiA8cD5Mb2FkaW5nIHNvbWV0aGluZzwvcD59KVxuICBsb2FkYWJsZU9wdGlvbnMgPSB7IC4uLmxvYWRhYmxlT3B0aW9ucywgLi4ub3B0aW9ucyB9XG5cbiAgY29uc3QgbG9hZGVyRm4gPSBsb2FkYWJsZU9wdGlvbnMubG9hZGVyIGFzICgpID0+IExvYWRlckNvbXBvbmVudDxQPlxuICBjb25zdCBsb2FkZXIgPSAoKSA9PlxuICAgIGxvYWRlckZuICE9IG51bGxcbiAgICAgID8gbG9hZGVyRm4oKS50aGVuKGNvbnZlcnRNb2R1bGUpXG4gICAgICA6IFByb21pc2UucmVzb2x2ZShjb252ZXJ0TW9kdWxlKCgpID0+IG51bGwpKVxuXG4gIC8vIGNvbWluZyBmcm9tIGJ1aWxkL2JhYmVsL3BsdWdpbnMvcmVhY3QtbG9hZGFibGUtcGx1Z2luLmpzXG4gIGlmIChsb2FkYWJsZU9wdGlvbnMubG9hZGFibGVHZW5lcmF0ZWQpIHtcbiAgICBsb2FkYWJsZU9wdGlvbnMgPSB7XG4gICAgICAuLi5sb2FkYWJsZU9wdGlvbnMsXG4gICAgICAuLi5sb2FkYWJsZU9wdGlvbnMubG9hZGFibGVHZW5lcmF0ZWQsXG4gICAgfVxuICAgIGRlbGV0ZSBsb2FkYWJsZU9wdGlvbnMubG9hZGFibGVHZW5lcmF0ZWRcbiAgfVxuXG4gIC8vIHN1cHBvcnQgZm9yIGRpc2FibGluZyBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcsIGVnOiBkeW5hbWljKCgpID0+IGltcG9ydCgnLi4vaGVsbG8td29ybGQnKSwge3NzcjogZmFsc2V9KS5cbiAgaWYgKHR5cGVvZiBsb2FkYWJsZU9wdGlvbnMuc3NyID09PSAnYm9vbGVhbicgJiYgIWxvYWRhYmxlT3B0aW9ucy5zc3IpIHtcbiAgICBkZWxldGUgbG9hZGFibGVPcHRpb25zLndlYnBhY2tcbiAgICBkZWxldGUgbG9hZGFibGVPcHRpb25zLm1vZHVsZXNcblxuICAgIHJldHVybiBub1NTUihsb2FkYWJsZUZuLCBsb2FkYWJsZU9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gbG9hZGFibGVGbih7IC4uLmxvYWRhYmxlT3B0aW9ucywgbG9hZGVyOiBsb2FkZXIgYXMgTG9hZGVyPFA+IH0pXG59XG4iXSwibmFtZXMiOlsiZHluYW1pYyIsIm5vU1NSIiwiaXNTZXJ2ZXJTaWRlIiwid2luZG93IiwiY29udmVydE1vZHVsZSIsIm1vZCIsImRlZmF1bHQiLCJMb2FkYWJsZUluaXRpYWxpemVyIiwibG9hZGFibGVPcHRpb25zIiwid2VicGFjayIsIm1vZHVsZXMiLCJMb2FkaW5nIiwibG9hZGluZyIsImVycm9yIiwiaXNMb2FkaW5nIiwicGFzdERlbGF5IiwidGltZWRPdXQiLCJkeW5hbWljT3B0aW9ucyIsIm9wdGlvbnMiLCJsb2FkYWJsZUZuIiwiTG9hZGFibGUiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJwIiwibWVzc2FnZSIsImJyIiwic3RhY2siLCJQcm9taXNlIiwibG9hZGVyIiwibG9hZGVyRm4iLCJ0aGVuIiwicmVzb2x2ZSIsImxvYWRhYmxlR2VuZXJhdGVkIiwic3NyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/dynamic.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/loadable-context.shared-runtime.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/loadable-context.shared-runtime.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"LoadableContext\", ({\n    enumerable: true,\n    get: function() {\n        return LoadableContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst LoadableContext = _react.default.createContext(null);\nif (true) {\n    LoadableContext.displayName = 'LoadableContext';\n} //# sourceMappingURL=loadable-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sb2FkYWJsZS1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7bURBTWFBOzs7ZUFBQUE7Ozs7NEVBSks7QUFJWCxNQUFNQSxrQkFBa0JDLE9BQUFBLE9BQUssQ0FBQ0MsYUFBYSxDQUFtQjtBQUVyRSxJQUFJQyxJQUFvQixFQUFtQjtJQUN6Q0gsZ0JBQWdCTSxXQUFXLEdBQUc7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9zcmMvc2hhcmVkL2xpYi9sb2FkYWJsZS1jb250ZXh0LnNoYXJlZC1ydW50aW1lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbnR5cGUgQ2FwdHVyZUZuID0gKG1vZHVsZU5hbWU6IHN0cmluZykgPT4gdm9pZFxuXG5leHBvcnQgY29uc3QgTG9hZGFibGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxDYXB0dXJlRm4gfCBudWxsPihudWxsKVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBMb2FkYWJsZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnTG9hZGFibGVDb250ZXh0J1xufVxuIl0sIm5hbWVzIjpbIkxvYWRhYmxlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/loadable-context.shared-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dist/shared/lib/loadable.shared-runtime.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/loadable.shared-runtime.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("// TODO: Remove use of `any` type.\n/**\n@copyright (c) 2017-present James Kyle <me@thejameskyle.com>\n MIT License\n Permission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n The above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE\n*/ // https://github.com/jamiebuilds/react-loadable/blob/v5.5.0/src/index.js\n// Modified to be compatible with webpack 4 / Next.js\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\"));\nconst _loadablecontextsharedruntime = __webpack_require__(/*! ./loadable-context.shared-runtime */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/loadable-context.shared-runtime.js\");\nfunction resolve(obj) {\n    return obj && obj.default ? obj.default : obj;\n}\nconst ALL_INITIALIZERS = [];\nconst READY_INITIALIZERS = [];\nlet initialized = false;\nfunction load(loader) {\n    let promise = loader();\n    let state = {\n        loading: true,\n        loaded: null,\n        error: null\n    };\n    state.promise = promise.then((loaded)=>{\n        state.loading = false;\n        state.loaded = loaded;\n        return loaded;\n    }).catch((err)=>{\n        state.loading = false;\n        state.error = err;\n        throw err;\n    });\n    return state;\n}\nfunction createLoadableComponent(loadFn, options) {\n    var _s = $RefreshSig$(), _s1 = $RefreshSig$();\n    let opts = Object.assign({\n        loader: null,\n        loading: null,\n        delay: 200,\n        timeout: null,\n        webpack: null,\n        modules: null\n    }, options);\n    /** @type LoadableSubscription */ let subscription = null;\n    function init() {\n        if (!subscription) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            const sub = new LoadableSubscription(loadFn, opts);\n            subscription = {\n                getCurrentValue: sub.getCurrentValue.bind(sub),\n                subscribe: sub.subscribe.bind(sub),\n                retry: sub.retry.bind(sub),\n                promise: sub.promise.bind(sub)\n            };\n        }\n        return subscription.promise();\n    }\n    // Server only\n    if (false) {}\n    // Client only\n    if (!initialized && \"object\" !== 'undefined') {\n        // require.resolveWeak check is needed for environments that don't have it available like Jest\n        const moduleIds = opts.webpack && \"function\" === 'function' ? opts.webpack() : opts.modules;\n        if (moduleIds) {\n            READY_INITIALIZERS.push((ids)=>{\n                for (const moduleId of moduleIds){\n                    if (ids.includes(moduleId)) {\n                        return init();\n                    }\n                }\n            });\n        }\n    }\n    function useLoadableModule() {\n        _s();\n        init();\n        const context = _react.default.useContext(_loadablecontextsharedruntime.LoadableContext);\n        if (context && Array.isArray(opts.modules)) {\n            opts.modules.forEach((moduleName)=>{\n                context(moduleName);\n            });\n        }\n    }\n    _s(useLoadableModule, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n    function LoadableComponent(props, ref) {\n        _s1();\n        useLoadableModule();\n        const state = _react.default.useSyncExternalStore(subscription.subscribe, subscription.getCurrentValue, subscription.getCurrentValue);\n        _react.default.useImperativeHandle(ref, {\n            \"createLoadableComponent.LoadableComponent.useImperativeHandle\": ()=>({\n                    retry: subscription.retry\n                })\n        }[\"createLoadableComponent.LoadableComponent.useImperativeHandle\"], []);\n        return _react.default.useMemo({\n            \"createLoadableComponent.LoadableComponent.useMemo\": ()=>{\n                if (state.loading || state.error) {\n                    return /*#__PURE__*/ _react.default.createElement(opts.loading, {\n                        isLoading: state.loading,\n                        pastDelay: state.pastDelay,\n                        timedOut: state.timedOut,\n                        error: state.error,\n                        retry: subscription.retry\n                    });\n                } else if (state.loaded) {\n                    return /*#__PURE__*/ _react.default.createElement(resolve(state.loaded), props);\n                } else {\n                    return null;\n                }\n            }\n        }[\"createLoadableComponent.LoadableComponent.useMemo\"], [\n            props,\n            state\n        ]);\n    }\n    _s1(LoadableComponent, \"FetqI339RA+IfltT8VNzX8RMZ2Q=\", false, function() {\n        return [\n            useLoadableModule\n        ];\n    });\n    LoadableComponent.preload = ()=>init();\n    LoadableComponent.displayName = 'LoadableComponent';\n    return /*#__PURE__*/ _react.default.forwardRef(LoadableComponent);\n}\nclass LoadableSubscription {\n    promise() {\n        return this._res.promise;\n    }\n    retry() {\n        this._clearTimeouts();\n        this._res = this._loadFn(this._opts.loader);\n        this._state = {\n            pastDelay: false,\n            timedOut: false\n        };\n        const { _res: res, _opts: opts } = this;\n        if (res.loading) {\n            if (typeof opts.delay === 'number') {\n                if (opts.delay === 0) {\n                    this._state.pastDelay = true;\n                } else {\n                    this._delay = setTimeout(()=>{\n                        this._update({\n                            pastDelay: true\n                        });\n                    }, opts.delay);\n                }\n            }\n            if (typeof opts.timeout === 'number') {\n                this._timeout = setTimeout(()=>{\n                    this._update({\n                        timedOut: true\n                    });\n                }, opts.timeout);\n            }\n        }\n        this._res.promise.then(()=>{\n            this._update({});\n            this._clearTimeouts();\n        }).catch((_err)=>{\n            this._update({});\n            this._clearTimeouts();\n        });\n        this._update({});\n    }\n    _update(partial) {\n        this._state = {\n            ...this._state,\n            error: this._res.error,\n            loaded: this._res.loaded,\n            loading: this._res.loading,\n            ...partial\n        };\n        this._callbacks.forEach((callback)=>callback());\n    }\n    _clearTimeouts() {\n        clearTimeout(this._delay);\n        clearTimeout(this._timeout);\n    }\n    getCurrentValue() {\n        return this._state;\n    }\n    subscribe(callback) {\n        this._callbacks.add(callback);\n        return ()=>{\n            this._callbacks.delete(callback);\n        };\n    }\n    constructor(loadFn, opts){\n        this._loadFn = loadFn;\n        this._opts = opts;\n        this._callbacks = new Set();\n        this._delay = null;\n        this._timeout = null;\n        this.retry();\n    }\n}\nfunction Loadable(opts) {\n    return createLoadableComponent(load, opts);\n}\n_c = Loadable;\nfunction flushInitializers(initializers, ids) {\n    let promises = [];\n    while(initializers.length){\n        let init = initializers.pop();\n        promises.push(init(ids));\n    }\n    return Promise.all(promises).then(()=>{\n        if (initializers.length) {\n            return flushInitializers(initializers, ids);\n        }\n    });\n}\nLoadable.preloadAll = ()=>{\n    return new Promise((resolveInitializers, reject)=>{\n        flushInitializers(ALL_INITIALIZERS).then(resolveInitializers, reject);\n    });\n};\nLoadable.preloadReady = (ids)=>{\n    if (ids === void 0) ids = [];\n    return new Promise((resolvePreload)=>{\n        const res = ()=>{\n            initialized = true;\n            return resolvePreload();\n        };\n        // We always will resolve, errors should be handled within loading UIs.\n        flushInitializers(READY_INITIALIZERS, ids).then(res, res);\n    });\n};\nif (true) {\n    window.__NEXT_PRELOADREADY = Loadable.preloadReady;\n}\nconst _default = Loadable; //# sourceMappingURL=loadable.shared-runtime.js.map\nvar _c;\n$RefreshReg$(_c, \"Loadable\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9sb2FkYWJsZS5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0M7QUFDbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsR0FDQSx5RUFBeUU7QUFDekUscURBQXFEOzs7OzsyQ0F1UnJEOzs7ZUFBQTs7Ozs0RUFyUmtCOzBEQUNjO0FBRWhDLFNBQVNBLFFBQVFDLEdBQVE7SUFDdkIsT0FBT0EsT0FBT0EsSUFBSUMsT0FBTyxHQUFHRCxJQUFJQyxPQUFPLEdBQUdEO0FBQzVDO0FBRUEsTUFBTUUsbUJBQTBCLEVBQUU7QUFDbEMsTUFBTUMscUJBQTRCLEVBQUU7QUFDcEMsSUFBSUMsY0FBYztBQUVsQixTQUFTQyxLQUFLQyxNQUFXO0lBQ3ZCLElBQUlDLFVBQVVEO0lBRWQsSUFBSUUsUUFBYTtRQUNmQyxTQUFTO1FBQ1RDLFFBQVE7UUFDUkMsT0FBTztJQUNUO0lBRUFILE1BQU1ELE9BQU8sR0FBR0EsUUFDYkssSUFBSSxDQUFDLENBQUNGO1FBQ0xGLE1BQU1DLE9BQU8sR0FBRztRQUNoQkQsTUFBTUUsTUFBTSxHQUFHQTtRQUNmLE9BQU9BO0lBQ1QsR0FDQ0csS0FBSyxDQUFDLENBQUNDO1FBQ05OLE1BQU1DLE9BQU8sR0FBRztRQUNoQkQsTUFBTUcsS0FBSyxHQUFHRztRQUNkLE1BQU1BO0lBQ1I7SUFFRixPQUFPTjtBQUNUO0FBRUEsU0FBU08sd0JBQXdCQyxNQUFXLEVBQUVDLE9BQVk7O0lBQ3hELElBQUlDLE9BQU9DLE9BQU9DLE1BQU0sQ0FDdEI7UUFDRWQsUUFBUTtRQUNSRyxTQUFTO1FBQ1RZLE9BQU87UUFDUEMsU0FBUztRQUNUQyxTQUFTO1FBQ1RDLFNBQVM7SUFDWCxHQUNBUDtJQUdGLCtCQUErQixHQUMvQixJQUFJUSxlQUFvQjtJQUN4QixTQUFTQztRQUNQLElBQUksQ0FBQ0QsY0FBYztZQUNqQixtRUFBbUU7WUFDbkUsTUFB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QyxTQUFTUSxVQUFVLEdBQUc7SUFDcEIsT0FBTyxJQUFJRixRQUFRLENBQUNHLHFCQUFxQkM7UUFDdkNULGtCQUFrQmpGLGtCQUFrQlUsSUFBSSxDQUFDK0UscUJBQXFCQztJQUNoRTtBQUNGO0FBRUFWLFNBQVNXLFlBQVksR0FBRyxDQUFDdkQ7UUFBQUEsUUFBQUEsS0FBQUEsR0FBQUEsTUFBMkIsRUFBRTtJQUNwRCxPQUFPLElBQUlrRCxRQUFjLENBQUNNO1FBQ3hCLE1BQU0xQixNQUFNO1lBQ1ZoRSxjQUFjO1lBQ2QsT0FBTzBGO1FBQ1Q7UUFDQSx1RUFBdUU7UUFDdkVYLGtCQUFrQmhGLG9CQUFvQm1DLEtBQUsxQixJQUFJLENBQUN3RCxLQUFLQTtJQUN2RDtBQUNGO0FBUUEsSUFBSSxJQUE2QixFQUFFO0lBQ2pDbkMsT0FBTzhELG1CQUFtQixHQUFHYixTQUFTVyxZQUFZO0FBQ3BEO01BRUEsV0FBZVgiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9zcmMvc2hhcmVkL2xpYi9sb2FkYWJsZS5zaGFyZWQtcnVudGltZS50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETzogUmVtb3ZlIHVzZSBvZiBgYW55YCB0eXBlLlxuLyoqXG5AY29weXJpZ2h0IChjKSAyMDE3LXByZXNlbnQgSmFtZXMgS3lsZSA8bWVAdGhlamFtZXNreWxlLmNvbT5cbiBNSVQgTGljZW5zZVxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbmluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG5MSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG5PRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbldJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFXG4qL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2phbWllYnVpbGRzL3JlYWN0LWxvYWRhYmxlL2Jsb2IvdjUuNS4wL3NyYy9pbmRleC5qc1xuLy8gTW9kaWZpZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHdlYnBhY2sgNCAvIE5leHQuanNcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTG9hZGFibGVDb250ZXh0IH0gZnJvbSAnLi9sb2FkYWJsZS1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuXG5mdW5jdGlvbiByZXNvbHZlKG9iajogYW55KSB7XG4gIHJldHVybiBvYmogJiYgb2JqLmRlZmF1bHQgPyBvYmouZGVmYXVsdCA6IG9ialxufVxuXG5jb25zdCBBTExfSU5JVElBTElaRVJTOiBhbnlbXSA9IFtdXG5jb25zdCBSRUFEWV9JTklUSUFMSVpFUlM6IGFueVtdID0gW11cbmxldCBpbml0aWFsaXplZCA9IGZhbHNlXG5cbmZ1bmN0aW9uIGxvYWQobG9hZGVyOiBhbnkpIHtcbiAgbGV0IHByb21pc2UgPSBsb2FkZXIoKVxuXG4gIGxldCBzdGF0ZTogYW55ID0ge1xuICAgIGxvYWRpbmc6IHRydWUsXG4gICAgbG9hZGVkOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICB9XG5cbiAgc3RhdGUucHJvbWlzZSA9IHByb21pc2VcbiAgICAudGhlbigobG9hZGVkOiBhbnkpID0+IHtcbiAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZVxuICAgICAgc3RhdGUubG9hZGVkID0gbG9hZGVkXG4gICAgICByZXR1cm4gbG9hZGVkXG4gICAgfSlcbiAgICAuY2F0Y2goKGVycjogYW55KSA9PiB7XG4gICAgICBzdGF0ZS5sb2FkaW5nID0gZmFsc2VcbiAgICAgIHN0YXRlLmVycm9yID0gZXJyXG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuXG4gIHJldHVybiBzdGF0ZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2FkYWJsZUNvbXBvbmVudChsb2FkRm46IGFueSwgb3B0aW9uczogYW55KSB7XG4gIGxldCBvcHRzID0gT2JqZWN0LmFzc2lnbihcbiAgICB7XG4gICAgICBsb2FkZXI6IG51bGwsXG4gICAgICBsb2FkaW5nOiBudWxsLFxuICAgICAgZGVsYXk6IDIwMCxcbiAgICAgIHRpbWVvdXQ6IG51bGwsXG4gICAgICB3ZWJwYWNrOiBudWxsLFxuICAgICAgbW9kdWxlczogbnVsbCxcbiAgICB9LFxuICAgIG9wdGlvbnNcbiAgKVxuXG4gIC8qKiBAdHlwZSBMb2FkYWJsZVN1YnNjcmlwdGlvbiAqL1xuICBsZXQgc3Vic2NyaXB0aW9uOiBhbnkgPSBudWxsXG4gIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgaWYgKCFzdWJzY3JpcHRpb24pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIGNvbnN0IHN1YiA9IG5ldyBMb2FkYWJsZVN1YnNjcmlwdGlvbihsb2FkRm4sIG9wdHMpXG4gICAgICBzdWJzY3JpcHRpb24gPSB7XG4gICAgICAgIGdldEN1cnJlbnRWYWx1ZTogc3ViLmdldEN1cnJlbnRWYWx1ZS5iaW5kKHN1YiksXG4gICAgICAgIHN1YnNjcmliZTogc3ViLnN1YnNjcmliZS5iaW5kKHN1YiksXG4gICAgICAgIHJldHJ5OiBzdWIucmV0cnkuYmluZChzdWIpLFxuICAgICAgICBwcm9taXNlOiBzdWIucHJvbWlzZS5iaW5kKHN1YiksXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzY3JpcHRpb24ucHJvbWlzZSgpXG4gIH1cblxuICAvLyBTZXJ2ZXIgb25seVxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBBTExfSU5JVElBTElaRVJTLnB1c2goaW5pdClcbiAgfVxuXG4gIC8vIENsaWVudCBvbmx5XG4gIGlmICghaW5pdGlhbGl6ZWQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyByZXF1aXJlLnJlc29sdmVXZWFrIGNoZWNrIGlzIG5lZWRlZCBmb3IgZW52aXJvbm1lbnRzIHRoYXQgZG9uJ3QgaGF2ZSBpdCBhdmFpbGFibGUgbGlrZSBKZXN0XG4gICAgY29uc3QgbW9kdWxlSWRzID1cbiAgICAgIG9wdHMud2VicGFjayAmJiB0eXBlb2YgKHJlcXVpcmUgYXMgYW55KS5yZXNvbHZlV2VhayA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IG9wdHMud2VicGFjaygpXG4gICAgICAgIDogb3B0cy5tb2R1bGVzXG4gICAgaWYgKG1vZHVsZUlkcykge1xuICAgICAgUkVBRFlfSU5JVElBTElaRVJTLnB1c2goKGlkczogYW55KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbW9kdWxlSWQgb2YgbW9kdWxlSWRzKSB7XG4gICAgICAgICAgaWYgKGlkcy5pbmNsdWRlcyhtb2R1bGVJZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbml0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXNlTG9hZGFibGVNb2R1bGUoKSB7XG4gICAgaW5pdCgpXG5cbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChMb2FkYWJsZUNvbnRleHQpXG4gICAgaWYgKGNvbnRleHQgJiYgQXJyYXkuaXNBcnJheShvcHRzLm1vZHVsZXMpKSB7XG4gICAgICBvcHRzLm1vZHVsZXMuZm9yRWFjaCgobW9kdWxlTmFtZTogYW55KSA9PiB7XG4gICAgICAgIGNvbnRleHQobW9kdWxlTmFtZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gTG9hZGFibGVDb21wb25lbnQocHJvcHM6IGFueSwgcmVmOiBhbnkpIHtcbiAgICB1c2VMb2FkYWJsZU1vZHVsZSgpXG5cbiAgICBjb25zdCBzdGF0ZSA9IChSZWFjdCBhcyBhbnkpLnVzZVN5bmNFeHRlcm5hbFN0b3JlKFxuICAgICAgc3Vic2NyaXB0aW9uLnN1YnNjcmliZSxcbiAgICAgIHN1YnNjcmlwdGlvbi5nZXRDdXJyZW50VmFsdWUsXG4gICAgICBzdWJzY3JpcHRpb24uZ2V0Q3VycmVudFZhbHVlXG4gICAgKVxuXG4gICAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShcbiAgICAgIHJlZixcbiAgICAgICgpID0+ICh7XG4gICAgICAgIHJldHJ5OiBzdWJzY3JpcHRpb24ucmV0cnksXG4gICAgICB9KSxcbiAgICAgIFtdXG4gICAgKVxuXG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgaWYgKHN0YXRlLmxvYWRpbmcgfHwgc3RhdGUuZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQob3B0cy5sb2FkaW5nLCB7XG4gICAgICAgICAgaXNMb2FkaW5nOiBzdGF0ZS5sb2FkaW5nLFxuICAgICAgICAgIHBhc3REZWxheTogc3RhdGUucGFzdERlbGF5LFxuICAgICAgICAgIHRpbWVkT3V0OiBzdGF0ZS50aW1lZE91dCxcbiAgICAgICAgICBlcnJvcjogc3RhdGUuZXJyb3IsXG4gICAgICAgICAgcmV0cnk6IHN1YnNjcmlwdGlvbi5yZXRyeSxcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubG9hZGVkKSB7XG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KHJlc29sdmUoc3RhdGUubG9hZGVkKSwgcHJvcHMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0sIFtwcm9wcywgc3RhdGVdKVxuICB9XG5cbiAgTG9hZGFibGVDb21wb25lbnQucHJlbG9hZCA9ICgpID0+IGluaXQoKVxuICBMb2FkYWJsZUNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdMb2FkYWJsZUNvbXBvbmVudCdcblxuICByZXR1cm4gUmVhY3QuZm9yd2FyZFJlZihMb2FkYWJsZUNvbXBvbmVudClcbn1cblxuY2xhc3MgTG9hZGFibGVTdWJzY3JpcHRpb24ge1xuICBfbG9hZEZuOiBhbnlcbiAgX29wdHM6IGFueVxuICBfY2FsbGJhY2tzOiBhbnlcbiAgX2RlbGF5OiBhbnlcbiAgX3RpbWVvdXQ6IGFueVxuICBfcmVzOiBhbnlcbiAgX3N0YXRlOiBhbnlcbiAgY29uc3RydWN0b3IobG9hZEZuOiBhbnksIG9wdHM6IGFueSkge1xuICAgIHRoaXMuX2xvYWRGbiA9IGxvYWRGblxuICAgIHRoaXMuX29wdHMgPSBvcHRzXG4gICAgdGhpcy5fY2FsbGJhY2tzID0gbmV3IFNldCgpXG4gICAgdGhpcy5fZGVsYXkgPSBudWxsXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGxcblxuICAgIHRoaXMucmV0cnkoKVxuICB9XG5cbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzLnByb21pc2VcbiAgfVxuXG4gIHJldHJ5KCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dHMoKVxuICAgIHRoaXMuX3JlcyA9IHRoaXMuX2xvYWRGbih0aGlzLl9vcHRzLmxvYWRlcilcblxuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgcGFzdERlbGF5OiBmYWxzZSxcbiAgICAgIHRpbWVkT3V0OiBmYWxzZSxcbiAgICB9XG5cbiAgICBjb25zdCB7IF9yZXM6IHJlcywgX29wdHM6IG9wdHMgfSA9IHRoaXNcblxuICAgIGlmIChyZXMubG9hZGluZykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLmRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAob3B0cy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX3N0YXRlLnBhc3REZWxheSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kZWxheSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKHtcbiAgICAgICAgICAgICAgcGFzdERlbGF5OiB0cnVlLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LCBvcHRzLmRlbGF5KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy50aW1lb3V0ID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlKHsgdGltZWRPdXQ6IHRydWUgfSlcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0KVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3Jlcy5wcm9taXNlXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSh7fSlcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0cygpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChfZXJyOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKHt9KVxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXRzKClcbiAgICAgIH0pXG4gICAgdGhpcy5fdXBkYXRlKHt9KVxuICB9XG5cbiAgX3VwZGF0ZShwYXJ0aWFsOiBhbnkpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuX3N0YXRlLFxuICAgICAgZXJyb3I6IHRoaXMuX3Jlcy5lcnJvcixcbiAgICAgIGxvYWRlZDogdGhpcy5fcmVzLmxvYWRlZCxcbiAgICAgIGxvYWRpbmc6IHRoaXMuX3Jlcy5sb2FkaW5nLFxuICAgICAgLi4ucGFydGlhbCxcbiAgICB9XG4gICAgdGhpcy5fY2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrOiBhbnkpID0+IGNhbGxiYWNrKCkpXG4gIH1cblxuICBfY2xlYXJUaW1lb3V0cygpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZGVsYXkpXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gIH1cblxuICBnZXRDdXJyZW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlXG4gIH1cblxuICBzdWJzY3JpYmUoY2FsbGJhY2s6IGFueSkge1xuICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQoY2FsbGJhY2spXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuX2NhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIExvYWRhYmxlKG9wdHM6IGFueSkge1xuICByZXR1cm4gY3JlYXRlTG9hZGFibGVDb21wb25lbnQobG9hZCwgb3B0cylcbn1cblxuZnVuY3Rpb24gZmx1c2hJbml0aWFsaXplcnMoaW5pdGlhbGl6ZXJzOiBhbnksIGlkcz86IGFueSk6IGFueSB7XG4gIGxldCBwcm9taXNlcyA9IFtdXG5cbiAgd2hpbGUgKGluaXRpYWxpemVycy5sZW5ndGgpIHtcbiAgICBsZXQgaW5pdCA9IGluaXRpYWxpemVycy5wb3AoKVxuICAgIHByb21pc2VzLnB1c2goaW5pdChpZHMpKVxuICB9XG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZXJzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZsdXNoSW5pdGlhbGl6ZXJzKGluaXRpYWxpemVycywgaWRzKVxuICAgIH1cbiAgfSlcbn1cblxuTG9hZGFibGUucHJlbG9hZEFsbCA9ICgpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlSW5pdGlhbGl6ZXJzLCByZWplY3QpID0+IHtcbiAgICBmbHVzaEluaXRpYWxpemVycyhBTExfSU5JVElBTElaRVJTKS50aGVuKHJlc29sdmVJbml0aWFsaXplcnMsIHJlamVjdClcbiAgfSlcbn1cblxuTG9hZGFibGUucHJlbG9hZFJlYWR5ID0gKGlkczogKHN0cmluZyB8IG51bWJlcilbXSA9IFtdKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZVByZWxvYWQpID0+IHtcbiAgICBjb25zdCByZXMgPSAoKSA9PiB7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWVcbiAgICAgIHJldHVybiByZXNvbHZlUHJlbG9hZCgpXG4gICAgfVxuICAgIC8vIFdlIGFsd2F5cyB3aWxsIHJlc29sdmUsIGVycm9ycyBzaG91bGQgYmUgaGFuZGxlZCB3aXRoaW4gbG9hZGluZyBVSXMuXG4gICAgZmx1c2hJbml0aWFsaXplcnMoUkVBRFlfSU5JVElBTElaRVJTLCBpZHMpLnRoZW4ocmVzLCByZXMpXG4gIH0pXG59XG5cbmRlY2xhcmUgZ2xvYmFsIHtcbiAgaW50ZXJmYWNlIFdpbmRvdyB7XG4gICAgX19ORVhUX1BSRUxPQURSRUFEWT86IChpZHM/OiAoc3RyaW5nIHwgbnVtYmVyKVtdKSA9PiBQcm9taXNlPHZvaWQ+XG4gIH1cbn1cblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZID0gTG9hZGFibGUucHJlbG9hZFJlYWR5XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvYWRhYmxlXG4iXSwibmFtZXMiOlsicmVzb2x2ZSIsIm9iaiIsImRlZmF1bHQiLCJBTExfSU5JVElBTElaRVJTIiwiUkVBRFlfSU5JVElBTElaRVJTIiwiaW5pdGlhbGl6ZWQiLCJsb2FkIiwibG9hZGVyIiwicHJvbWlzZSIsInN0YXRlIiwibG9hZGluZyIsImxvYWRlZCIsImVycm9yIiwidGhlbiIsImNhdGNoIiwiZXJyIiwiY3JlYXRlTG9hZGFibGVDb21wb25lbnQiLCJsb2FkRm4iLCJvcHRpb25zIiwib3B0cyIsIk9iamVjdCIsImFzc2lnbiIsImRlbGF5IiwidGltZW91dCIsIndlYnBhY2siLCJtb2R1bGVzIiwic3Vic2NyaXB0aW9uIiwiaW5pdCIsInN1YiIsIkxvYWRhYmxlU3Vic2NyaXB0aW9uIiwiZ2V0Q3VycmVudFZhbHVlIiwiYmluZCIsInN1YnNjcmliZSIsInJldHJ5Iiwid2luZG93IiwicHVzaCIsIm1vZHVsZUlkcyIsInJlcXVpcmUiLCJyZXNvbHZlV2VhayIsImlkcyIsIm1vZHVsZUlkIiwiaW5jbHVkZXMiLCJ1c2VMb2FkYWJsZU1vZHVsZSIsImNvbnRleHQiLCJSZWFjdCIsInVzZUNvbnRleHQiLCJMb2FkYWJsZUNvbnRleHQiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwibW9kdWxlTmFtZSIsIkxvYWRhYmxlQ29tcG9uZW50IiwicHJvcHMiLCJyZWYiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJ1c2VNZW1vIiwiY3JlYXRlRWxlbWVudCIsImlzTG9hZGluZyIsInBhc3REZWxheSIsInRpbWVkT3V0IiwicHJlbG9hZCIsImRpc3BsYXlOYW1lIiwiZm9yd2FyZFJlZiIsIl9yZXMiLCJfY2xlYXJUaW1lb3V0cyIsIl9sb2FkRm4iLCJfb3B0cyIsIl9zdGF0ZSIsInJlcyIsIl9kZWxheSIsInNldFRpbWVvdXQiLCJfdXBkYXRlIiwiX3RpbWVvdXQiLCJfZXJyIiwicGFydGlhbCIsIl9jYWxsYmFja3MiLCJjYWxsYmFjayIsImNsZWFyVGltZW91dCIsImFkZCIsImRlbGV0ZSIsImNvbnN0cnVjdG9yIiwiU2V0IiwiTG9hZGFibGUiLCJmbHVzaEluaXRpYWxpemVycyIsImluaXRpYWxpemVycyIsInByb21pc2VzIiwibGVuZ3RoIiwicG9wIiwiUHJvbWlzZSIsImFsbCIsInByZWxvYWRBbGwiLCJyZXNvbHZlSW5pdGlhbGl6ZXJzIiwicmVqZWN0IiwicHJlbG9hZFJlYWR5IiwicmVzb2x2ZVByZWxvYWQiLCJfX05FWFRfUFJFTE9BRFJFQURZIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dist/shared/lib/loadable.shared-runtime.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/next/dynamic.js":
/*!**************************************!*\
  !*** ./node_modules/next/dynamic.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/dynamic */ \"(pages-dir-browser)/./node_modules/next/dist/shared/lib/dynamic.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2R5bmFtaWMuanMiLCJtYXBwaW5ncyI6IkFBQUEsMklBQXFEIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL25leHQvZHluYW1pYy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9zaGFyZWQvbGliL2R5bmFtaWMnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/next/dynamic.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/styled-jsx/dist/index/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/styled-jsx/dist/index/index.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n__webpack_require__(/*! client-only */ \"(pages-dir-browser)/./node_modules/next/dist/compiled/client-only/index.js\");\nvar React = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n        'default': e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\n_c = React__default;\n/*\nBased on Glamor's sheet\nhttps://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js\n*/ function _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nvar isProd = typeof process !== \"undefined\" && process.env && \"development\" === \"production\";\nvar isString = function(o) {\n    return Object.prototype.toString.call(o) === \"[object String]\";\n};\nvar StyleSheet = /*#__PURE__*/ function() {\n    function StyleSheet(param) {\n        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? \"stylesheet\" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;\n        invariant$1(isString(name), \"`name` must be a string\");\n        this._name = name;\n        this._deletedRulePlaceholder = \"#\" + name + \"-deleted-rule____{}\";\n        invariant$1(typeof optimizeForSpeed === \"boolean\", \"`optimizeForSpeed` must be a boolean\");\n        this._optimizeForSpeed = optimizeForSpeed;\n        this._serverSheet = undefined;\n        this._tags = [];\n        this._injected = false;\n        this._rulesCount = 0;\n        var node =  true && document.querySelector('meta[property=\"csp-nonce\"]');\n        this._nonce = node ? node.getAttribute(\"content\") : null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {\n        invariant$1(typeof bool === \"boolean\", \"`setOptimizeForSpeed` accepts a boolean\");\n        invariant$1(this._rulesCount === 0, \"optimizeForSpeed cannot be when rules have already been inserted\");\n        this.flush();\n        this._optimizeForSpeed = bool;\n        this.inject();\n    };\n    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {\n        return this._optimizeForSpeed;\n    };\n    _proto.inject = function inject() {\n        var _this = this;\n        invariant$1(!this._injected, \"sheet already injected\");\n        this._injected = true;\n        if ( true && this._optimizeForSpeed) {\n            this._tags[0] = this.makeStyleTag(this._name);\n            this._optimizeForSpeed = \"insertRule\" in this.getSheet();\n            if (!this._optimizeForSpeed) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.\");\n                }\n                this.flush();\n                this._injected = true;\n            }\n            return;\n        }\n        this._serverSheet = {\n            cssRules: [],\n            insertRule: function(rule, index) {\n                if (typeof index === \"number\") {\n                    _this._serverSheet.cssRules[index] = {\n                        cssText: rule\n                    };\n                } else {\n                    _this._serverSheet.cssRules.push({\n                        cssText: rule\n                    });\n                }\n                return index;\n            },\n            deleteRule: function(index) {\n                _this._serverSheet.cssRules[index] = null;\n            }\n        };\n    };\n    _proto.getSheetForTag = function getSheetForTag(tag) {\n        if (tag.sheet) {\n            return tag.sheet;\n        }\n        // this weirdness brought to you by firefox\n        for(var i = 0; i < document.styleSheets.length; i++){\n            if (document.styleSheets[i].ownerNode === tag) {\n                return document.styleSheets[i];\n            }\n        }\n    };\n    _proto.getSheet = function getSheet() {\n        return this.getSheetForTag(this._tags[this._tags.length - 1]);\n    };\n    _proto.insertRule = function insertRule(rule, index) {\n        invariant$1(isString(rule), \"`insertRule` accepts only strings\");\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            var sheet = this.getSheet();\n            if (typeof index !== \"number\") {\n                index = sheet.cssRules.length;\n            }\n            // this weirdness for perf, and chrome's weird bug\n            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                return -1;\n            }\n        } else {\n            var insertionPoint = this._tags[index];\n            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));\n        }\n        return this._rulesCount++;\n    };\n    _proto.replaceRule = function replaceRule(index, rule) {\n        if (this._optimizeForSpeed || \"object\" === \"undefined\") {\n            var sheet =  true ? this.getSheet() : 0;\n            if (!rule.trim()) {\n                rule = this._deletedRulePlaceholder;\n            }\n            if (!sheet.cssRules[index]) {\n                // @TBD Should we throw an error?\n                return index;\n            }\n            sheet.deleteRule(index);\n            try {\n                sheet.insertRule(rule, index);\n            } catch (error) {\n                if (!isProd) {\n                    console.warn(\"StyleSheet: illegal rule: \\n\\n\" + rule + \"\\n\\nSee https://stackoverflow.com/q/20007992 for more info\");\n                }\n                // In order to preserve the indices we insert a deleteRulePlaceholder\n                sheet.insertRule(this._deletedRulePlaceholder, index);\n            }\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"old rule at index `\" + index + \"` not found\");\n            tag.textContent = rule;\n        }\n        return index;\n    };\n    _proto.deleteRule = function deleteRule(index) {\n        if (false) {}\n        if (this._optimizeForSpeed) {\n            this.replaceRule(index, \"\");\n        } else {\n            var tag = this._tags[index];\n            invariant$1(tag, \"rule at index `\" + index + \"` not found\");\n            tag.parentNode.removeChild(tag);\n            this._tags[index] = null;\n        }\n    };\n    _proto.flush = function flush() {\n        this._injected = false;\n        this._rulesCount = 0;\n        if (true) {\n            this._tags.forEach(function(tag) {\n                return tag && tag.parentNode.removeChild(tag);\n            });\n            this._tags = [];\n        } else {}\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        if (false) {}\n        return this._tags.reduce(function(rules, tag) {\n            if (tag) {\n                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {\n                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;\n                }));\n            } else {\n                rules.push(null);\n            }\n            return rules;\n        }, []);\n    };\n    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {\n        if (cssString) {\n            invariant$1(isString(cssString), \"makeStyleTag accepts only strings as second parameter\");\n        }\n        var tag = document.createElement(\"style\");\n        if (this._nonce) tag.setAttribute(\"nonce\", this._nonce);\n        tag.type = \"text/css\";\n        tag.setAttribute(\"data-\" + name, \"\");\n        if (cssString) {\n            tag.appendChild(document.createTextNode(cssString));\n        }\n        var head = document.head || document.getElementsByTagName(\"head\")[0];\n        if (relativeToTag) {\n            head.insertBefore(tag, relativeToTag);\n        } else {\n            head.appendChild(tag);\n        }\n        return tag;\n    };\n    _createClass(StyleSheet, [\n        {\n            key: \"length\",\n            get: function get() {\n                return this._rulesCount;\n            }\n        }\n    ]);\n    return StyleSheet;\n}();\nfunction invariant$1(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheet: \" + message + \".\");\n    }\n}\nfunction hash(str) {\n    var _$hash = 5381, i = str.length;\n    while(i){\n        _$hash = _$hash * 33 ^ str.charCodeAt(--i);\n    }\n    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed\n   * integers. Since we want the results to be always positive, convert the\n   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;\n}\nvar stringHash = hash;\nvar sanitize = function(rule) {\n    return rule.replace(/\\/style/gi, \"\\\\/style\");\n};\nvar cache = {};\n/**\n * computeId\n *\n * Compute and memoize a jsx id from a basedId and optionally props.\n */ function computeId(baseId, props) {\n    if (!props) {\n        return \"jsx-\" + baseId;\n    }\n    var propsToString = String(props);\n    var key = baseId + propsToString;\n    if (!cache[key]) {\n        cache[key] = \"jsx-\" + stringHash(baseId + \"-\" + propsToString);\n    }\n    return cache[key];\n}\n/**\n * computeSelector\n *\n * Compute and memoize dynamic selectors.\n */ function computeSelector(id, css) {\n    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;\n    // Sanitize SSR-ed CSS.\n    // Client side code doesn't need to be sanitized since we use\n    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).\n    if (false) {}\n    var idcss = id + css;\n    if (!cache[idcss]) {\n        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);\n    }\n    return cache[idcss];\n}\nfunction mapRulesToStyle(cssRules, options) {\n    if (options === void 0) options = {};\n    return cssRules.map(function(args) {\n        var id = args[0];\n        var css = args[1];\n        return /*#__PURE__*/ React__default[\"default\"].createElement(\"style\", {\n            id: \"__\" + id,\n            // Avoid warnings upon render with a key\n            key: \"__\" + id,\n            nonce: options.nonce ? options.nonce : undefined,\n            dangerouslySetInnerHTML: {\n                __html: css\n            }\n        });\n    });\n}\nvar StyleSheetRegistry = /*#__PURE__*/ function() {\n    function StyleSheetRegistry(param) {\n        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;\n        this._sheet = styleSheet || new StyleSheet({\n            name: \"styled-jsx\",\n            optimizeForSpeed: optimizeForSpeed\n        });\n        this._sheet.inject();\n        if (styleSheet && typeof optimizeForSpeed === \"boolean\") {\n            this._sheet.setOptimizeForSpeed(optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    }\n    var _proto = StyleSheetRegistry.prototype;\n    _proto.add = function add(props) {\n        var _this = this;\n        if (undefined === this._optimizeForSpeed) {\n            this._optimizeForSpeed = Array.isArray(props.children);\n            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);\n            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();\n        }\n        if ( true && !this._fromServer) {\n            this._fromServer = this.selectFromServer();\n            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {\n                acc[tagName] = 0;\n                return acc;\n            }, {});\n        }\n        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;\n        // Deduping: just increase the instances count.\n        if (styleId in this._instancesCounts) {\n            this._instancesCounts[styleId] += 1;\n            return;\n        }\n        var indices = rules.map(function(rule) {\n            return _this._sheet.insertRule(rule);\n        }) // Filter out invalid rules\n        .filter(function(index) {\n            return index !== -1;\n        });\n        this._indices[styleId] = indices;\n        this._instancesCounts[styleId] = 1;\n    };\n    _proto.remove = function remove(props) {\n        var _this = this;\n        var styleId = this.getIdAndRules(props).styleId;\n        invariant(styleId in this._instancesCounts, \"styleId: `\" + styleId + \"` not found\");\n        this._instancesCounts[styleId] -= 1;\n        if (this._instancesCounts[styleId] < 1) {\n            var tagFromServer = this._fromServer && this._fromServer[styleId];\n            if (tagFromServer) {\n                tagFromServer.parentNode.removeChild(tagFromServer);\n                delete this._fromServer[styleId];\n            } else {\n                this._indices[styleId].forEach(function(index) {\n                    return _this._sheet.deleteRule(index);\n                });\n                delete this._indices[styleId];\n            }\n            delete this._instancesCounts[styleId];\n        }\n    };\n    _proto.update = function update(props, nextProps) {\n        this.add(nextProps);\n        this.remove(props);\n    };\n    _proto.flush = function flush() {\n        this._sheet.flush();\n        this._sheet.inject();\n        this._fromServer = undefined;\n        this._indices = {};\n        this._instancesCounts = {};\n    };\n    _proto.cssRules = function cssRules() {\n        var _this = this;\n        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {\n            return [\n                styleId,\n                _this._fromServer[styleId]\n            ];\n        }) : [];\n        var cssRules = this._sheet.cssRules();\n        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {\n            return [\n                styleId,\n                _this._indices[styleId].map(function(index) {\n                    return cssRules[index].cssText;\n                }).join(_this._optimizeForSpeed ? \"\" : \"\\n\")\n            ];\n        }) // filter out empty rules\n        .filter(function(rule) {\n            return Boolean(rule[1]);\n        }));\n    };\n    _proto.styles = function styles(options) {\n        return mapRulesToStyle(this.cssRules(), options);\n    };\n    _proto.getIdAndRules = function getIdAndRules(props) {\n        var css = props.children, dynamic = props.dynamic, id = props.id;\n        if (dynamic) {\n            var styleId = computeId(id, dynamic);\n            return {\n                styleId: styleId,\n                rules: Array.isArray(css) ? css.map(function(rule) {\n                    return computeSelector(styleId, rule);\n                }) : [\n                    computeSelector(styleId, css)\n                ]\n            };\n        }\n        return {\n            styleId: computeId(id),\n            rules: Array.isArray(css) ? css : [\n                css\n            ]\n        };\n    };\n    /**\n   * selectFromServer\n   *\n   * Collects style tags from the document with id __jsx-XXX\n   */ _proto.selectFromServer = function selectFromServer() {\n        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^=\"__jsx-\"]'));\n        return elements.reduce(function(acc, element) {\n            var id = element.id.slice(2);\n            acc[id] = element;\n            return acc;\n        }, {});\n    };\n    return StyleSheetRegistry;\n}();\nfunction invariant(condition, message) {\n    if (!condition) {\n        throw new Error(\"StyleSheetRegistry: \" + message + \".\");\n    }\n}\nvar StyleSheetContext = /*#__PURE__*/ React.createContext(null);\nStyleSheetContext.displayName = \"StyleSheetContext\";\nfunction createStyleRegistry() {\n    return new StyleSheetRegistry();\n}\nfunction StyleRegistry(param) {\n    _s();\n    var configuredRegistry = param.registry, children = param.children;\n    var rootRegistry = React.useContext(StyleSheetContext);\n    var ref = React.useState({\n        \"StyleRegistry.useState[ref]\": function() {\n            return rootRegistry || configuredRegistry || createStyleRegistry();\n        }\n    }[\"StyleRegistry.useState[ref]\"]), registry = ref[0];\n    return /*#__PURE__*/ React__default[\"default\"].createElement(StyleSheetContext.Provider, {\n        value: registry\n    }, children);\n}\n_s(StyleRegistry, \"F6PIZFsaWgcE6rBNmd+Zkq3zRoY=\");\n_c1 = StyleRegistry;\nfunction useStyleRegistry() {\n    _s1();\n    return React.useContext(StyleSheetContext);\n}\n_s1(useStyleRegistry, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.\n// https://github.com/reactwg/react-18/discussions/110\nvar useInsertionEffect = React__default[\"default\"].useInsertionEffect || React__default[\"default\"].useLayoutEffect;\nvar defaultRegistry =  true ? createStyleRegistry() : 0;\nfunction JSXStyle(props) {\n    _s2();\n    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();\n    // If `registry` does not exist, we do nothing here.\n    if (!registry) {\n        return null;\n    }\n    if (false) {}\n    useInsertionEffect({\n        \"JSXStyle.useInsertionEffect\": function() {\n            registry.add(props);\n            return ({\n                \"JSXStyle.useInsertionEffect\": function() {\n                    registry.remove(props);\n                }\n            })[\"JSXStyle.useInsertionEffect\"];\n        // props.children can be string[], will be striped since id is identical\n        }\n    }[\"JSXStyle.useInsertionEffect\"], [\n        props.id,\n        String(props.dynamic)\n    ]);\n    return null;\n}\n_s2(JSXStyle, \"48Sqj1BUqkshsPdz6NEWXDn8pF4=\", false, function() {\n    return [\n        useStyleRegistry,\n        useInsertionEffect\n    ];\n});\n_c2 = JSXStyle;\nJSXStyle.dynamic = function(info) {\n    return info.map(function(tagInfo) {\n        var baseId = tagInfo[0];\n        var props = tagInfo[1];\n        return computeId(baseId, props);\n    }).join(\" \");\n};\nexports.StyleRegistry = StyleRegistry;\nexports.createStyleRegistry = createStyleRegistry;\nexports.style = JSXStyle;\nexports.useStyleRegistry = useStyleRegistry;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"React__default\");\n$RefreshReg$(_c1, \"StyleRegistry\");\n$RefreshReg$(_c2, \"JSXStyle\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L2Rpc3QvaW5kZXgvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7O0FBQUFBLG1CQUFPQSxDQUFDLCtGQUFhO0FBQ3JCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDLGdFQUFPO0FBRTNCLFNBQVNFLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsaUJBQWlCLFdBQVcsR0FBRUYsc0JBQXNCRDs7QUFFeEQ7OztBQUdBLEdBQUcsU0FBU0ksa0JBQWtCQyxNQUFNLEVBQUVDLEtBQUs7SUFDdkMsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUlELE1BQU1FLE1BQU0sRUFBRUQsSUFBSTtRQUNqQyxJQUFJRSxhQUFhSCxLQUFLLENBQUNDLEVBQUU7UUFDekJFLFdBQVdDLFVBQVUsR0FBR0QsV0FBV0MsVUFBVSxJQUFJO1FBQ2pERCxXQUFXRSxZQUFZLEdBQUc7UUFDMUIsSUFBSSxXQUFXRixZQUFZQSxXQUFXRyxRQUFRLEdBQUc7UUFDakRDLE9BQU9DLGNBQWMsQ0FBQ1QsUUFBUUksV0FBV00sR0FBRyxFQUFFTjtJQUNsRDtBQUNKO0FBQ0EsU0FBU08sYUFBYUMsV0FBVyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDdEQsSUFBSUQsWUFBWWQsa0JBQWtCYSxZQUFZRyxTQUFTLEVBQUVGO0lBQ3pELElBQUlDLGFBQWFmLGtCQUFrQmEsYUFBYUU7SUFDaEQsT0FBT0Y7QUFDWDtBQUNBLElBQUlJLFNBQVMsT0FBT0MsT0FBT0EsS0FBSyxlQUFlQSxPQUFPQSxDQUFDQyxHQUFHLElBQUlELGtCQUF5QjtBQUN2RixJQUFJRSxXQUFXLFNBQVNDLENBQUM7SUFDckIsT0FBT1osT0FBT08sU0FBUyxDQUFDTSxRQUFRLENBQUNDLElBQUksQ0FBQ0YsT0FBTztBQUNqRDtBQUNBLElBQUlH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QzlCZ0IsYUFBYSxHQUFHSDtBQUNoQkcsd0JBQXdCLEdBQUdQIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvZGlzdC9pbmRleC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCdjbGllbnQtb25seScpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0TGVnYWN5IChlKSB7IHJldHVybiBlICYmIHR5cGVvZiBlID09PSAnb2JqZWN0JyAmJiAnZGVmYXVsdCcgaW4gZSA/IGUgOiB7ICdkZWZhdWx0JzogZSB9OyB9XG5cbnZhciBSZWFjdF9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUmVhY3QpO1xuXG4vKlxuQmFzZWQgb24gR2xhbW9yJ3Mgc2hlZXRcbmh0dHBzOi8vZ2l0aHViLmNvbS90aHJlZXBvaW50b25lL2dsYW1vci9ibG9iLzY2N2I0ODBkMzFiMzcyMWE5MDUwMjFiMjZlMTI5MGNlOTJjYTI4Nzkvc3JjL3NoZWV0LmpzXG4qLyBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbnZhciBpc1Byb2QgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCI7XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbihvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbn07XG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVTaGVldChwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9uYW1lID0gcmVmLm5hbWUsIG5hbWUgPSBfbmFtZSA9PT0gdm9pZCAwID8gXCJzdHlsZXNoZWV0XCIgOiBfbmFtZSwgX29wdGltaXplRm9yU3BlZWQgPSByZWYub3B0aW1pemVGb3JTcGVlZCwgb3B0aW1pemVGb3JTcGVlZCA9IF9vcHRpbWl6ZUZvclNwZWVkID09PSB2b2lkIDAgPyBpc1Byb2QgOiBfb3B0aW1pemVGb3JTcGVlZDtcbiAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcobmFtZSksIFwiYG5hbWVgIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyID0gXCIjXCIgKyBuYW1lICsgXCItZGVsZXRlZC1ydWxlX19fX3t9XCI7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBvcHRpbWl6ZUZvclNwZWVkID09PSBcImJvb2xlYW5cIiwgXCJgb3B0aW1pemVGb3JTcGVlZGAgbXVzdCBiZSBhIGJvb2xlYW5cIik7XG4gICAgICAgIHRoaXMuX29wdGltaXplRm9yU3BlZWQgPSBvcHRpbWl6ZUZvclNwZWVkO1xuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xuICAgICAgICB0aGlzLl9pbmplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ydWxlc0NvdW50ID0gMDtcbiAgICAgICAgdmFyIG5vZGUgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgICAgICAgdGhpcy5fbm9uY2UgPSBub2RlID8gbm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRPcHRpbWl6ZUZvclNwZWVkID0gZnVuY3Rpb24gc2V0T3B0aW1pemVGb3JTcGVlZChib29sKSB7XG4gICAgICAgIGludmFyaWFudCQxKHR5cGVvZiBib29sID09PSBcImJvb2xlYW5cIiwgXCJgc2V0T3B0aW1pemVGb3JTcGVlZGAgYWNjZXB0cyBhIGJvb2xlYW5cIik7XG4gICAgICAgIGludmFyaWFudCQxKHRoaXMuX3J1bGVzQ291bnQgPT09IDAsIFwib3B0aW1pemVGb3JTcGVlZCBjYW5ub3QgYmUgd2hlbiBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZFwiKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gYm9vbDtcbiAgICAgICAgdGhpcy5pbmplY3QoKTtcbiAgICB9O1xuICAgIF9wcm90by5pc09wdGltaXplRm9yU3BlZWQgPSBmdW5jdGlvbiBpc09wdGltaXplRm9yU3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkO1xuICAgIH07XG4gICAgX3Byb3RvLmluamVjdCA9IGZ1bmN0aW9uIGluamVjdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaW52YXJpYW50JDEoIXRoaXMuX2luamVjdGVkLCBcInNoZWV0IGFscmVhZHkgaW5qZWN0ZWRcIik7XG4gICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5fdGFnc1swXSA9IHRoaXMubWFrZVN0eWxlVGFnKHRoaXMuX25hbWUpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IFwiaW5zZXJ0UnVsZVwiIGluIHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IG9wdGltaXplRm9yU3BlZWQgbW9kZSBub3Qgc3VwcG9ydGVkIGZhbGxpbmcgYmFjayB0byBzdGFuZGFyZCBtb2RlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2luamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldCA9IHtcbiAgICAgICAgICAgIGNzc1J1bGVzOiBbXSxcbiAgICAgICAgICAgIGluc2VydFJ1bGU6IGZ1bmN0aW9uKHJ1bGUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXNbaW5kZXhdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dDogcnVsZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1RleHQ6IHJ1bGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWxldGVSdWxlOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlc1tpbmRleF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmdldFNoZWV0Rm9yVGFnID0gZnVuY3Rpb24gZ2V0U2hlZXRGb3JUYWcodGFnKSB7XG4gICAgICAgIGlmICh0YWcuc2hlZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZG9jdW1lbnQuc3R5bGVTaGVldHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U2hlZXQgPSBmdW5jdGlvbiBnZXRTaGVldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2hlZXRGb3JUYWcodGhpcy5fdGFnc1t0aGlzLl90YWdzLmxlbmd0aCAtIDFdKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlLCBpbmRleCkge1xuICAgICAgICBpbnZhcmlhbnQkMShpc1N0cmluZyhydWxlKSwgXCJgaW5zZXJ0UnVsZWAgYWNjZXB0cyBvbmx5IHN0cmluZ3NcIik7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLl9zZXJ2ZXJTaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IHRoaXMuZ2V0U2hlZXQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMgd2VpcmRuZXNzIGZvciBwZXJmLCBhbmQgY2hyb21lJ3Mgd2VpcmQgYnVnXG4gICAgICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDAwNzk5Mi9jaHJvbWUtc3VkZGVubHktc3RvcHBlZC1hY2NlcHRpbmctaW5zZXJ0cnVsZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Byb2QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiU3R5bGVTaGVldDogaWxsZWdhbCBydWxlOiBcXG5cXG5cIiArIHJ1bGUgKyBcIlxcblxcblNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMjAwMDc5OTIgZm9yIG1vcmUgaW5mb1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc2VydGlvblBvaW50ID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLl90YWdzLnB1c2godGhpcy5tYWtlU3R5bGVUYWcodGhpcy5fbmFtZSwgcnVsZSwgaW5zZXJ0aW9uUG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcnVsZXNDb3VudCsrO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VSdWxlID0gZnVuY3Rpb24gcmVwbGFjZVJ1bGUoaW5kZXgsIHJ1bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGltaXplRm9yU3BlZWQgfHwgdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFyIHNoZWV0ID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMuZ2V0U2hlZXQoKSA6IHRoaXMuX3NlcnZlclNoZWV0O1xuICAgICAgICAgICAgaWYgKCFydWxlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHJ1bGUgPSB0aGlzLl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaGVldC5jc3NSdWxlc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAvLyBAVEJEIFNob3VsZCB3ZSB0aHJvdyBhbiBlcnJvcj9cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBpbmRleCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghaXNQcm9kKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlN0eWxlU2hlZXQ6IGlsbGVnYWwgcnVsZTogXFxuXFxuXCIgKyBydWxlICsgXCJcXG5cXG5TZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzIwMDA3OTkyIGZvciBtb3JlIGluZm9cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXNlcnZlIHRoZSBpbmRpY2VzIHdlIGluc2VydCBhIGRlbGV0ZVJ1bGVQbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgIHNoZWV0Lmluc2VydFJ1bGUodGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IHRoaXMuX3RhZ3NbaW5kZXhdO1xuICAgICAgICAgICAgaW52YXJpYW50JDEodGFnLCBcIm9sZCBydWxlIGF0IGluZGV4IGBcIiArIGluZGV4ICsgXCJgIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIHRhZy50ZXh0Q29udGVudCA9IHJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2ZXJTaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fb3B0aW1pemVGb3JTcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXBsYWNlUnVsZShpbmRleCwgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdGhpcy5fdGFnc1tpbmRleF07XG4gICAgICAgICAgICBpbnZhcmlhbnQkMSh0YWcsIFwicnVsZSBhdCBpbmRleCBgXCIgKyBpbmRleCArIFwiYCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgdGhpcy5fdGFnc1tpbmRleF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgdGhpcy5faW5qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcnVsZXNDb3VudCA9IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLl90YWdzLmZvckVhY2goZnVuY3Rpb24odGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZyAmJiB0YWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YWcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl90YWdzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaW1wbGVyIG9uIHNlcnZlclxuICAgICAgICAgICAgdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNzc1J1bGVzID0gZnVuY3Rpb24gY3NzUnVsZXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVyU2hlZXQuY3NzUnVsZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3MucmVkdWNlKGZ1bmN0aW9uKHJ1bGVzLCB0YWcpIHtcbiAgICAgICAgICAgIGlmICh0YWcpIHtcbiAgICAgICAgICAgICAgICBydWxlcyA9IHJ1bGVzLmNvbmNhdChBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoX3RoaXMuZ2V0U2hlZXRGb3JUYWcodGFnKS5jc3NSdWxlcywgZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVsZS5jc3NUZXh0ID09PSBfdGhpcy5fZGVsZXRlZFJ1bGVQbGFjZWhvbGRlciA/IG51bGwgOiBydWxlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVsZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydWxlcztcbiAgICAgICAgfSwgW10pO1xuICAgIH07XG4gICAgX3Byb3RvLm1ha2VTdHlsZVRhZyA9IGZ1bmN0aW9uIG1ha2VTdHlsZVRhZyhuYW1lLCBjc3NTdHJpbmcsIHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgaWYgKGNzc1N0cmluZykge1xuICAgICAgICAgICAgaW52YXJpYW50JDEoaXNTdHJpbmcoY3NzU3RyaW5nKSwgXCJtYWtlU3R5bGVUYWcgYWNjZXB0cyBvbmx5IHN0cmluZ3MgYXMgc2Vjb25kIHBhcmFtZXRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAodGhpcy5fbm9uY2UpIHRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCB0aGlzLl9ub25jZSk7XG4gICAgICAgIHRhZy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuICAgICAgICB0YWcuc2V0QXR0cmlidXRlKFwiZGF0YS1cIiArIG5hbWUsIFwiXCIpO1xuICAgICAgICBpZiAoY3NzU3RyaW5nKSB7XG4gICAgICAgICAgICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXTtcbiAgICAgICAgaWYgKHJlbGF0aXZlVG9UYWcpIHtcbiAgICAgICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHRhZywgcmVsYXRpdmVUb1RhZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9O1xuICAgIF9jcmVhdGVDbGFzcyhTdHlsZVNoZWV0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ydWxlc0NvdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5mdW5jdGlvbiBpbnZhcmlhbnQkMShjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0OiBcIiArIG1lc3NhZ2UgKyBcIi5cIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIHZhciBfJGhhc2ggPSA1MzgxLCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKXtcbiAgICAgICAgXyRoYXNoID0gXyRoYXNoICogMzMgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICAvKiBKYXZhU2NyaXB0IGRvZXMgYml0d2lzZSBvcGVyYXRpb25zIChsaWtlIFhPUiwgYWJvdmUpIG9uIDMyLWJpdCBzaWduZWRcbiAgICogaW50ZWdlcnMuIFNpbmNlIHdlIHdhbnQgdGhlIHJlc3VsdHMgdG8gYmUgYWx3YXlzIHBvc2l0aXZlLCBjb252ZXJ0IHRoZVxuICAgKiBzaWduZWQgaW50IHRvIGFuIHVuc2lnbmVkIGJ5IGRvaW5nIGFuIHVuc2lnbmVkIGJpdHNoaWZ0LiAqLyByZXR1cm4gXyRoYXNoID4+PiAwO1xufVxudmFyIHN0cmluZ0hhc2ggPSBoYXNoO1xuXG52YXIgc2FuaXRpemUgPSBmdW5jdGlvbihydWxlKSB7XG4gICAgcmV0dXJuIHJ1bGUucmVwbGFjZSgvXFwvc3R5bGUvZ2ksIFwiXFxcXC9zdHlsZVwiKTtcbn07XG52YXIgY2FjaGUgPSB7fTtcbi8qKlxuICogY29tcHV0ZUlkXG4gKlxuICogQ29tcHV0ZSBhbmQgbWVtb2l6ZSBhIGpzeCBpZCBmcm9tIGEgYmFzZWRJZCBhbmQgb3B0aW9uYWxseSBwcm9wcy5cbiAqLyBmdW5jdGlvbiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIFwianN4LVwiICsgYmFzZUlkO1xuICAgIH1cbiAgICB2YXIgcHJvcHNUb1N0cmluZyA9IFN0cmluZyhwcm9wcyk7XG4gICAgdmFyIGtleSA9IGJhc2VJZCArIHByb3BzVG9TdHJpbmc7XG4gICAgaWYgKCFjYWNoZVtrZXldKSB7XG4gICAgICAgIGNhY2hlW2tleV0gPSBcImpzeC1cIiArIHN0cmluZ0hhc2goYmFzZUlkICsgXCItXCIgKyBwcm9wc1RvU3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG59XG4vKipcbiAqIGNvbXB1dGVTZWxlY3RvclxuICpcbiAqIENvbXB1dGUgYW5kIG1lbW9pemUgZHluYW1pYyBzZWxlY3RvcnMuXG4gKi8gZnVuY3Rpb24gY29tcHV0ZVNlbGVjdG9yKGlkLCBjc3MpIHtcbiAgICB2YXIgc2VsZWN0b1BsYWNlaG9sZGVyUmVnZXhwID0gL19fanN4LXN0eWxlLWR5bmFtaWMtc2VsZWN0b3IvZztcbiAgICAvLyBTYW5pdGl6ZSBTU1ItZWQgQ1NTLlxuICAgIC8vIENsaWVudCBzaWRlIGNvZGUgZG9lc24ndCBuZWVkIHRvIGJlIHNhbml0aXplZCBzaW5jZSB3ZSB1c2VcbiAgICAvLyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSAoZGV2KSBhbmQgdGhlIENTU09NIGFwaSBzaGVldC5pbnNlcnRSdWxlIChwcm9kKS5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgPSBzYW5pdGl6ZShjc3MpO1xuICAgIH1cbiAgICB2YXIgaWRjc3MgPSBpZCArIGNzcztcbiAgICBpZiAoIWNhY2hlW2lkY3NzXSkge1xuICAgICAgICBjYWNoZVtpZGNzc10gPSBjc3MucmVwbGFjZShzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAsIGlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlW2lkY3NzXTtcbn1cblxuZnVuY3Rpb24gbWFwUnVsZXNUb1N0eWxlKGNzc1J1bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBjc3NSdWxlcy5tYXAoZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgaWQgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgY3NzID0gYXJnc1sxXTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiLCB7XG4gICAgICAgICAgICBpZDogXCJfX1wiICsgaWQsXG4gICAgICAgICAgICAvLyBBdm9pZCB3YXJuaW5ncyB1cG9uIHJlbmRlciB3aXRoIGEga2V5XG4gICAgICAgICAgICBrZXk6IFwiX19cIiArIGlkLFxuICAgICAgICAgICAgbm9uY2U6IG9wdGlvbnMubm9uY2UgPyBvcHRpb25zLm5vbmNlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgICAgICAgICAgICBfX2h0bWw6IGNzc1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbnZhciBTdHlsZVNoZWV0UmVnaXN0cnkgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXRSZWdpc3RyeShwYXJhbSkge1xuICAgICAgICB2YXIgcmVmID0gcGFyYW0gPT09IHZvaWQgMCA/IHt9IDogcGFyYW0sIF9zdHlsZVNoZWV0ID0gcmVmLnN0eWxlU2hlZXQsIHN0eWxlU2hlZXQgPSBfc3R5bGVTaGVldCA9PT0gdm9pZCAwID8gbnVsbCA6IF9zdHlsZVNoZWV0LCBfb3B0aW1pemVGb3JTcGVlZCA9IHJlZi5vcHRpbWl6ZUZvclNwZWVkLCBvcHRpbWl6ZUZvclNwZWVkID0gX29wdGltaXplRm9yU3BlZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGltaXplRm9yU3BlZWQ7XG4gICAgICAgIHRoaXMuX3NoZWV0ID0gc3R5bGVTaGVldCB8fCBuZXcgU3R5bGVTaGVldCh7XG4gICAgICAgICAgICBuYW1lOiBcInN0eWxlZC1qc3hcIixcbiAgICAgICAgICAgIG9wdGltaXplRm9yU3BlZWQ6IG9wdGltaXplRm9yU3BlZWRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NoZWV0LmluamVjdCgpO1xuICAgICAgICBpZiAoc3R5bGVTaGVldCAmJiB0eXBlb2Ygb3B0aW1pemVGb3JTcGVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoZWV0LnNldE9wdGltaXplRm9yU3BlZWQob3B0aW1pemVGb3JTcGVlZCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gdGhpcy5fc2hlZXQuaXNPcHRpbWl6ZUZvclNwZWVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRSZWdpc3RyeS5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpbWl6ZUZvclNwZWVkID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICB0aGlzLl9zaGVldC5zZXRPcHRpbWl6ZUZvclNwZWVkKHRoaXMuX29wdGltaXplRm9yU3BlZWQpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW1pemVGb3JTcGVlZCA9IHRoaXMuX3NoZWV0LmlzT3B0aW1pemVGb3JTcGVlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICF0aGlzLl9mcm9tU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mcm9tU2VydmVyID0gdGhpcy5zZWxlY3RGcm9tU2VydmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5yZWR1Y2UoZnVuY3Rpb24oYWNjLCB0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgYWNjW3RhZ05hbWVdID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmdldElkQW5kUnVsZXMocHJvcHMpLCBzdHlsZUlkID0gcmVmLnN0eWxlSWQsIHJ1bGVzID0gcmVmLnJ1bGVzO1xuICAgICAgICAvLyBEZWR1cGluZzoganVzdCBpbmNyZWFzZSB0aGUgaW5zdGFuY2VzIGNvdW50LlxuICAgICAgICBpZiAoc3R5bGVJZCBpbiB0aGlzLl9pbnN0YW5jZXNDb3VudHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSArPSAxO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRpY2VzID0gcnVsZXMubWFwKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fc2hlZXQuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgfSkvLyBGaWx0ZXIgb3V0IGludmFsaWQgcnVsZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4ICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0gPSBpbmRpY2VzO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gPSAxO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3R5bGVJZCA9IHRoaXMuZ2V0SWRBbmRSdWxlcyhwcm9wcykuc3R5bGVJZDtcbiAgICAgICAgaW52YXJpYW50KHN0eWxlSWQgaW4gdGhpcy5faW5zdGFuY2VzQ291bnRzLCBcInN0eWxlSWQ6IGBcIiArIHN0eWxlSWQgKyBcImAgbm90IGZvdW5kXCIpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHNbc3R5bGVJZF0gLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXSA8IDEpIHtcbiAgICAgICAgICAgIHZhciB0YWdGcm9tU2VydmVyID0gdGhpcy5fZnJvbVNlcnZlciAmJiB0aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdO1xuICAgICAgICAgICAgaWYgKHRhZ0Zyb21TZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB0YWdGcm9tU2VydmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGFnRnJvbVNlcnZlcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2Zyb21TZXJ2ZXJbc3R5bGVJZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luZGljZXNbc3R5bGVJZF0uZm9yRWFjaChmdW5jdGlvbihpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuX3NoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pbmRpY2VzW3N0eWxlSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2luc3RhbmNlc0NvdW50c1tzdHlsZUlkXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgbmV4dFByb3BzKSB7XG4gICAgICAgIHRoaXMuYWRkKG5leHRQcm9wcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKHByb3BzKTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaCA9IGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICB0aGlzLl9zaGVldC5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9zaGVldC5pbmplY3QoKTtcbiAgICAgICAgdGhpcy5fZnJvbVNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5faW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLl9pbnN0YW5jZXNDb3VudHMgPSB7fTtcbiAgICB9O1xuICAgIF9wcm90by5jc3NSdWxlcyA9IGZ1bmN0aW9uIGNzc1J1bGVzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZnJvbVNlcnZlciA9IHRoaXMuX2Zyb21TZXJ2ZXIgPyBPYmplY3Qua2V5cyh0aGlzLl9mcm9tU2VydmVyKS5tYXAoZnVuY3Rpb24oc3R5bGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBzdHlsZUlkLFxuICAgICAgICAgICAgICAgIF90aGlzLl9mcm9tU2VydmVyW3N0eWxlSWRdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgICB2YXIgY3NzUnVsZXMgPSB0aGlzLl9zaGVldC5jc3NSdWxlcygpO1xuICAgICAgICByZXR1cm4gZnJvbVNlcnZlci5jb25jYXQoT2JqZWN0LmtleXModGhpcy5faW5kaWNlcykubWFwKGZ1bmN0aW9uKHN0eWxlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgc3R5bGVJZCxcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5kaWNlc1tzdHlsZUlkXS5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNzc1J1bGVzW2luZGV4XS5jc3NUZXh0O1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oX3RoaXMuX29wdGltaXplRm9yU3BlZWQgPyBcIlwiIDogXCJcXG5cIilcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLy8gZmlsdGVyIG91dCBlbXB0eSBydWxlc1xuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKHJ1bGVbMV0pO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3R5bGVzID0gZnVuY3Rpb24gc3R5bGVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG1hcFJ1bGVzVG9TdHlsZSh0aGlzLmNzc1J1bGVzKCksIG9wdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldElkQW5kUnVsZXMgPSBmdW5jdGlvbiBnZXRJZEFuZFJ1bGVzKHByb3BzKSB7XG4gICAgICAgIHZhciBjc3MgPSBwcm9wcy5jaGlsZHJlbiwgZHluYW1pYyA9IHByb3BzLmR5bmFtaWMsIGlkID0gcHJvcHMuaWQ7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGVJZCA9IGNvbXB1dGVJZChpZCwgZHluYW1pYyk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgcnVsZXM6IEFycmF5LmlzQXJyYXkoY3NzKSA/IGNzcy5tYXAoZnVuY3Rpb24ocnVsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHV0ZVNlbGVjdG9yKHN0eWxlSWQsIHJ1bGUpO1xuICAgICAgICAgICAgICAgIH0pIDogW1xuICAgICAgICAgICAgICAgICAgICBjb21wdXRlU2VsZWN0b3Ioc3R5bGVJZCwgY3NzKVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0eWxlSWQ6IGNvbXB1dGVJZChpZCksXG4gICAgICAgICAgICBydWxlczogQXJyYXkuaXNBcnJheShjc3MpID8gY3NzIDogW1xuICAgICAgICAgICAgICAgIGNzc1xuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAqIHNlbGVjdEZyb21TZXJ2ZXJcbiAgICpcbiAgICogQ29sbGVjdHMgc3R5bGUgdGFncyBmcm9tIHRoZSBkb2N1bWVudCB3aXRoIGlkIF9fanN4LVhYWFxuICAgKi8gX3Byb3RvLnNlbGVjdEZyb21TZXJ2ZXIgPSBmdW5jdGlvbiBzZWxlY3RGcm9tU2VydmVyKCkge1xuICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaWRePVwiX19qc3gtXCJdJykpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gZWxlbWVudC5pZC5zbGljZSgyKTtcbiAgICAgICAgICAgIGFjY1tpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlU2hlZXRSZWdpc3RyeTtcbn0oKTtcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHlsZVNoZWV0UmVnaXN0cnk6IFwiICsgbWVzc2FnZSArIFwiLlwiKTtcbiAgICB9XG59XG52YXIgU3R5bGVTaGVldENvbnRleHQgPSAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5TdHlsZVNoZWV0Q29udGV4dC5kaXNwbGF5TmFtZSA9IFwiU3R5bGVTaGVldENvbnRleHRcIjtcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlUmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTdHlsZVNoZWV0UmVnaXN0cnkoKTtcbn1cbmZ1bmN0aW9uIFN0eWxlUmVnaXN0cnkocGFyYW0pIHtcbiAgICB2YXIgY29uZmlndXJlZFJlZ2lzdHJ5ID0gcGFyYW0ucmVnaXN0cnksIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW47XG4gICAgdmFyIHJvb3RSZWdpc3RyeSA9IFJlYWN0LnVzZUNvbnRleHQoU3R5bGVTaGVldENvbnRleHQpO1xuICAgIHZhciByZWYgPSBSZWFjdC51c2VTdGF0ZShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJvb3RSZWdpc3RyeSB8fCBjb25maWd1cmVkUmVnaXN0cnkgfHwgY3JlYXRlU3R5bGVSZWdpc3RyeSgpO1xuICAgIH0pLCByZWdpc3RyeSA9IHJlZlswXTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTdHlsZVNoZWV0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcmVnaXN0cnlcbiAgICB9LCBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiB1c2VTdHlsZVJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBSZWFjdC51c2VDb250ZXh0KFN0eWxlU2hlZXRDb250ZXh0KTtcbn1cblxuLy8gT3B0LWludG8gdGhlIG5ldyBgdXNlSW5zZXJ0aW9uRWZmZWN0YCBBUEkgaW4gUmVhY3QgMTgsIGZhbGxiYWNrIHRvIGB1c2VMYXlvdXRFZmZlY3RgLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0d2cvcmVhY3QtMTgvZGlzY3Vzc2lvbnMvMTEwXG52YXIgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gUmVhY3RfX2RlZmF1bHRbXCJkZWZhdWx0XCJdLnVzZUluc2VydGlvbkVmZmVjdCB8fCBSZWFjdF9fZGVmYXVsdFtcImRlZmF1bHRcIl0udXNlTGF5b3V0RWZmZWN0O1xudmFyIGRlZmF1bHRSZWdpc3RyeSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBjcmVhdGVTdHlsZVJlZ2lzdHJ5KCkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBKU1hTdHlsZShwcm9wcykge1xuICAgIHZhciByZWdpc3RyeSA9IGRlZmF1bHRSZWdpc3RyeSA/IGRlZmF1bHRSZWdpc3RyeSA6IHVzZVN0eWxlUmVnaXN0cnkoKTtcbiAgICAvLyBJZiBgcmVnaXN0cnlgIGRvZXMgbm90IGV4aXN0LCB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgaWYgKCFyZWdpc3RyeSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHVzZUluc2VydGlvbkVmZmVjdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmVnaXN0cnkuYWRkKHByb3BzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmVnaXN0cnkucmVtb3ZlKHByb3BzKTtcbiAgICAgICAgfTtcbiAgICAvLyBwcm9wcy5jaGlsZHJlbiBjYW4gYmUgc3RyaW5nW10sIHdpbGwgYmUgc3RyaXBlZCBzaW5jZSBpZCBpcyBpZGVudGljYWxcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLmlkLFxuICAgICAgICBTdHJpbmcocHJvcHMuZHluYW1pYylcbiAgICBdKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cbkpTWFN0eWxlLmR5bmFtaWMgPSBmdW5jdGlvbihpbmZvKSB7XG4gICAgcmV0dXJuIGluZm8ubWFwKGZ1bmN0aW9uKHRhZ0luZm8pIHtcbiAgICAgICAgdmFyIGJhc2VJZCA9IHRhZ0luZm9bMF07XG4gICAgICAgIHZhciBwcm9wcyA9IHRhZ0luZm9bMV07XG4gICAgICAgIHJldHVybiBjb21wdXRlSWQoYmFzZUlkLCBwcm9wcyk7XG4gICAgfSkuam9pbihcIiBcIik7XG59O1xuXG5leHBvcnRzLlN0eWxlUmVnaXN0cnkgPSBTdHlsZVJlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGVTdHlsZVJlZ2lzdHJ5ID0gY3JlYXRlU3R5bGVSZWdpc3RyeTtcbmV4cG9ydHMuc3R5bGUgPSBKU1hTdHlsZTtcbmV4cG9ydHMudXNlU3R5bGVSZWdpc3RyeSA9IHVzZVN0eWxlUmVnaXN0cnk7XG4iXSwibmFtZXMiOlsicmVxdWlyZSIsIlJlYWN0IiwiX2ludGVyb3BEZWZhdWx0TGVnYWN5IiwiZSIsIlJlYWN0X19kZWZhdWx0IiwiX2RlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImkiLCJsZW5ndGgiLCJkZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJrZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsImlzUHJvZCIsInByb2Nlc3MiLCJlbnYiLCJpc1N0cmluZyIsIm8iLCJ0b1N0cmluZyIsImNhbGwiLCJTdHlsZVNoZWV0IiwicGFyYW0iLCJyZWYiLCJfbmFtZSIsIm5hbWUiLCJfb3B0aW1pemVGb3JTcGVlZCIsIm9wdGltaXplRm9yU3BlZWQiLCJpbnZhcmlhbnQkMSIsIl9kZWxldGVkUnVsZVBsYWNlaG9sZGVyIiwiX3NlcnZlclNoZWV0IiwidW5kZWZpbmVkIiwiX3RhZ3MiLCJfaW5qZWN0ZWQiLCJfcnVsZXNDb3VudCIsIm5vZGUiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJfbm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJfcHJvdG8iLCJzZXRPcHRpbWl6ZUZvclNwZWVkIiwiYm9vbCIsImZsdXNoIiwiaW5qZWN0IiwiaXNPcHRpbWl6ZUZvclNwZWVkIiwiX3RoaXMiLCJtYWtlU3R5bGVUYWciLCJnZXRTaGVldCIsImNvbnNvbGUiLCJ3YXJuIiwiY3NzUnVsZXMiLCJpbnNlcnRSdWxlIiwicnVsZSIsImluZGV4IiwiY3NzVGV4dCIsInB1c2giLCJkZWxldGVSdWxlIiwiZ2V0U2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsInN0eWxlU2hlZXRzIiwib3duZXJOb2RlIiwiZXJyb3IiLCJpbnNlcnRpb25Qb2ludCIsInJlcGxhY2VSdWxlIiwidHJpbSIsInRleHRDb250ZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiZm9yRWFjaCIsInJlZHVjZSIsInJ1bGVzIiwiY29uY2F0IiwiQXJyYXkiLCJtYXAiLCJjc3NTdHJpbmciLCJyZWxhdGl2ZVRvVGFnIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInR5cGUiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiaGVhZCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwiaW5zZXJ0QmVmb3JlIiwiZ2V0IiwiY29uZGl0aW9uIiwibWVzc2FnZSIsIkVycm9yIiwiaGFzaCIsInN0ciIsIl8kaGFzaCIsImNoYXJDb2RlQXQiLCJzdHJpbmdIYXNoIiwic2FuaXRpemUiLCJyZXBsYWNlIiwiY2FjaGUiLCJjb21wdXRlSWQiLCJiYXNlSWQiLCJwcm9wc1RvU3RyaW5nIiwiU3RyaW5nIiwiY29tcHV0ZVNlbGVjdG9yIiwiaWQiLCJjc3MiLCJzZWxlY3RvUGxhY2Vob2xkZXJSZWdleHAiLCJpZGNzcyIsIm1hcFJ1bGVzVG9TdHlsZSIsIm9wdGlvbnMiLCJhcmdzIiwibm9uY2UiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsIl9faHRtbCIsIlN0eWxlU2hlZXRSZWdpc3RyeSIsIl9zdHlsZVNoZWV0Iiwic3R5bGVTaGVldCIsIl9zaGVldCIsIl9mcm9tU2VydmVyIiwiX2luZGljZXMiLCJfaW5zdGFuY2VzQ291bnRzIiwiYWRkIiwiaXNBcnJheSIsImNoaWxkcmVuIiwic2VsZWN0RnJvbVNlcnZlciIsImtleXMiLCJhY2MiLCJ0YWdOYW1lIiwiZ2V0SWRBbmRSdWxlcyIsInN0eWxlSWQiLCJpbmRpY2VzIiwiZmlsdGVyIiwicmVtb3ZlIiwiaW52YXJpYW50IiwidGFnRnJvbVNlcnZlciIsInVwZGF0ZSIsIm5leHRQcm9wcyIsImZyb21TZXJ2ZXIiLCJqb2luIiwiQm9vbGVhbiIsInN0eWxlcyIsImR5bmFtaWMiLCJlbGVtZW50cyIsInNsaWNlIiwicXVlcnlTZWxlY3RvckFsbCIsImVsZW1lbnQiLCJTdHlsZVNoZWV0Q29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJkaXNwbGF5TmFtZSIsImNyZWF0ZVN0eWxlUmVnaXN0cnkiLCJTdHlsZVJlZ2lzdHJ5IiwiY29uZmlndXJlZFJlZ2lzdHJ5IiwicmVnaXN0cnkiLCJyb290UmVnaXN0cnkiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJQcm92aWRlciIsInZhbHVlIiwidXNlU3R5bGVSZWdpc3RyeSIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImRlZmF1bHRSZWdpc3RyeSIsIkpTWFN0eWxlIiwiaW5mbyIsInRhZ0luZm8iLCJleHBvcnRzIiwic3R5bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/styled-jsx/dist/index/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/styled-jsx/style.js":
/*!******************************************!*\
  !*** ./node_modules/styled-jsx/style.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! ./dist/index */ \"(pages-dir-browser)/./node_modules/styled-jsx/dist/index/index.js\").style;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdHlsZWQtanN4L3N0eWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsbUlBQThDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvbm9kZV9tb2R1bGVzL3N0eWxlZC1qc3gvc3R5bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvaW5kZXgnKS5zdHlsZVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwic3R5bGUiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/styled-jsx/style.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Memoize button configurations\n    const buttons = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[buttons]\": ()=>[\n                {\n                    text: \"Set Random\",\n                    abbreviatedText: \"SRandom\",\n                    onClick: handleSetRandom,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"Random Dot\",\n                    abbreviatedText: \"Random\",\n                    onClick: handleRandomDot,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"Set Calibrate\",\n                    abbreviatedText: \"Calibrate\",\n                    onClick: handleSetCalibrate,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"Clear All\",\n                    abbreviatedText: \"Clear\",\n                    onClick: handleClearAll\n                },\n                {\n                    divider: true\n                },\n                {\n                    text: \"Draw Head pose\",\n                    abbreviatedText: \"Head pose\",\n                    onClick: handleToggleHeadPose,\n                    active: showHeadPose\n                },\n                {\n                    text: \"Show Bounding Box\",\n                    abbreviatedText: \"☐ Box\",\n                    onClick: handleToggleBoundingBox,\n                    active: showBoundingBox\n                },\n                {\n                    text: isCameraActive ? \"Stop Camera\" : \"Show Preview\",\n                    abbreviatedText: isCameraActive ? \"Stop\" : \"Preview\",\n                    onClick: {\n                        \"ActionButtonGroupInner.useMemo[buttons]\": ()=>{\n                            if (!isCameraActive && !triggerCameraAccess(true)) {\n                                setShowPermissionPopup(true);\n                            } else {\n                                handleToggleCamera();\n                            }\n                        }\n                    }[\"ActionButtonGroupInner.useMemo[buttons]\"],\n                    active: isCameraActive,\n                    disabled: isCapturing\n                },\n                {\n                    text: \"😷 Show Mask\",\n                    abbreviatedText: \"😷 Mask\",\n                    onClick: handleToggleMask,\n                    active: showMask\n                },\n                {\n                    text: \"Parameters\",\n                    abbreviatedText: \"Values\",\n                    onClick: handleToggleParameters,\n                    active: showParameters\n                }\n            ]\n    }[\"ActionButtonGroupInner.useMemo[buttons]\"], [\n        isCapturing,\n        showHeadPose,\n        showBoundingBox,\n        isCameraActive,\n        showMask,\n        showParameters\n    ]);\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times) || 1);\n                    setDelaySeconds(Number(userSettings.delay) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times) || 1);\n                            setDelaySeconds(Number(userSettings.delay) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times !== undefined) {\n                                const newTimes = Number(times) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay !== undefined) {\n                                const newDelay = Number(delay) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    const initializeCanvas = (canvas, parent)=>{\n        if (!canvas || !parent) {\n            // console.warn('[initializeCanvas] Canvas or parent is null', { canvas, parent });\n            return false;\n        }\n        try {\n            // Set canvas dimensions to match parent\n            canvas.width = parent.clientWidth || 800;\n            canvas.height = parent.clientHeight || 600;\n            // Clear canvas and set white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // console.log(`Canvas initialized with dimensions: ${canvas.width}x${canvas.height}`);\n            return true;\n        } catch (error) {\n            console.error('[initializeCanvas] Error initializing canvas:', error);\n            return false;\n        }\n    };\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas = ()=>{\n        // Try multiple methods to find the canvas\n        if (canvasRef.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef.current;\n        }\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef.current = window.whiteScreenCanvas;\n            return window.whiteScreenCanvas;\n        }\n        if (typeof document !== 'undefined') {\n            // Try multiple selectors to find the canvas\n            const selectors = [\n                '.tracking-canvas',\n                'canvas',\n                '#tracking-canvas'\n            ];\n            for (const selector of selectors){\n                const canvasElement = document.querySelector(selector);\n                if (canvasElement) {\n                    console.log(\"Found canvas via selector: \".concat(selector));\n                    canvasRef.current = canvasElement;\n                    if (true) {\n                        window.whiteScreenCanvas = canvasElement;\n                    }\n                    return canvasElement;\n                }\n            }\n        }\n        console.error(\"No canvas found through any method\");\n        return null;\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        // First initialize with parent dimensions\n        const parent = canvas.parentElement || document.body;\n        initializeCanvas(canvas, parent);\n        // Then force fullscreen styling\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '5';\n        // Force dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear and prepare canvas again\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas set to fullscreen: \".concat(canvas.width, \"x\").concat(canvas.height));\n    };\n    const restoreCanvasSize = (canvas)=>{\n        // Restore original canvas styling\n        canvas.style.position = '';\n        canvas.style.top = '';\n        canvas.style.left = '';\n        canvas.style.width = '100%';\n        canvas.style.height = '100%';\n        canvas.style.zIndex = '';\n        // Restore original dimensions\n        if (canvas.parentElement) {\n            initializeCanvas(canvas, canvas.parentElement);\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas, originalParent, originalStyle)=>{\n        if (!canvas || !originalParent) return;\n        // Append the canvas back to its original parent if needed\n        if (canvas.parentElement !== originalParent) {\n            originalParent.appendChild(canvas);\n        }\n        // Restore the inline styles saved earlier\n        canvas.style.position = originalStyle.position;\n        canvas.style.top = originalStyle.top;\n        canvas.style.left = originalStyle.left;\n        canvas.style.width = originalStyle.width;\n        canvas.style.height = originalStyle.height;\n        canvas.style.zIndex = originalStyle.zIndex;\n        // Reset the dimensions based on the parent element's size or fallback defaults\n        canvas.width = originalParent.clientWidth || 800;\n        canvas.height = originalParent.clientHeight || 600;\n        // Clear the canvas and fill with a white background\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ // Modified handleDotProcess function with improved dot and countdown alignment\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get canvas reference with retries\n            let canvas = null;\n            let retryCount = 0;\n            const maxRetries = 3;\n            while(!canvas && retryCount < maxRetries){\n                canvas = getMainCanvas();\n                if (!canvas) {\n                    console.warn(\"Canvas not found, retry \".concat(retryCount + 1, \"/\").concat(maxRetries));\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    retryCount++;\n                }\n            }\n            if (!canvas) {\n                throw new Error(\"Canvas not available after multiple retries\");\n            }\n            // Save original state for restoration\n            const originalParent = canvas.parentElement;\n            const originalStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Prepare canvas for fullscreen display\n            document.body.appendChild(canvas);\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            // Clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            let keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            // Important: Position the countdown centered directly over the dot\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Clear redraw interval\n            clearInterval(keepDotVisibleInterval);\n            // Restore canvas to original state\n            if (originalParent && canvas.parentElement !== originalParent) {\n                originalParent.appendChild(canvas);\n            }\n            canvas.style.position = originalStyle.position || '';\n            canvas.style.top = originalStyle.top || '';\n            canvas.style.left = originalStyle.left || '';\n            canvas.style.width = originalStyle.width || '100%';\n            canvas.style.height = originalStyle.height || '100%';\n            canvas.style.zIndex = originalStyle.zIndex || '';\n            // Reset dimensions\n            if (originalParent) {\n                canvas.width = originalParent.clientWidth || 800;\n                canvas.height = originalParent.clientHeight || 600;\n            }\n            // Clear canvas\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 2000);\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            // Show TopBar again if there's an error\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n            return {\n                success: false,\n                error: error.message\n            };\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"✓\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            // Restore canvas to original parent and styling - Only if canvas was successfully initialized\n            if (canvas) {\n                try {\n                    // Try to find original parent\n                    if (originalCanvasParent && canvas.parentElement !== originalCanvasParent) {\n                        originalCanvasParent.appendChild(canvas);\n                    } else if (!originalCanvasParent) {\n                        // Fallback to looking for a container element\n                        const possibleParent = document.querySelector('.canvas-container');\n                        if (possibleParent && canvas.parentElement !== possibleParent) {\n                            possibleParent.appendChild(canvas);\n                        }\n                    }\n                    // Restore styling\n                    canvas.style.position = originalCanvasStyle.position || '';\n                    canvas.style.top = originalCanvasStyle.top || '';\n                    canvas.style.left = originalCanvasStyle.left || '';\n                    canvas.style.width = originalCanvasStyle.width || '100%';\n                    canvas.style.height = originalCanvasStyle.height || '100%';\n                    canvas.style.zIndex = originalCanvasStyle.zIndex || '';\n                    // Reset dimensions based on parent\n                    const parent = canvas.parentElement;\n                    if (parent) {\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                    } else {\n                        canvas.width = 800;\n                        canvas.height = 600;\n                    }\n                    // Clear canvas with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas restored to original state\");\n                } catch (e) {\n                    console.error(\"Error restoring canvas:\", e);\n                }\n            }\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        // Use the consolidated function with random position\n        await handleDotProcess({\n            useRandomPosition: true,\n            onStatusUpdate: (status)=>{\n                if (status.processStatus) setProcessStatus(status.processStatus);\n                if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n            },\n            toggleTopBar: (show)=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', show);\n                }\n            },\n            triggerCameraAccess,\n            setIsCapturing,\n            captureCount,\n            setCaptureCount: setCaptureCount,\n            postCountdownDelay: 1000\n        });\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        clearCanvas();\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1421,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1420,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1425,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1424,\n                columnNumber: 9\n            }, undefined),\n            (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"ActionButtonGroupInner.useMemo\": ()=>(processStatus || remainingCaptures > 0 || countdownValue) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"status-display mt-4 p-2 bg-blue-50 rounded-md\",\n                        children: [\n                            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-blue-800\",\n                                children: processStatus\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1434,\n                                columnNumber: 15\n                            }, undefined),\n                            remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-sm font-medium text-yellow-600\",\n                                children: [\n                                    \"Remaining: \",\n                                    remainingCaptures\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1437,\n                                columnNumber: 15\n                            }, undefined),\n                            countdownValue && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"text-2xl font-bold text-red-600\",\n                                children: countdownValue\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                lineNumber: 1440,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1432,\n                        columnNumber: 11\n                    }, undefined)\n            }[\"ActionButtonGroupInner.useMemo\"], [\n                processStatus,\n                remainingCaptures,\n                countdownValue\n            ]),\n            showCanvas && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"canvas-container mt-4\",\n                style: {\n                    position: 'relative',\n                    width: '100%',\n                    height: '40vh',\n                    minHeight: '300px',\n                    border: '1px solid #e0e0e0',\n                    backgroundColor: 'white',\n                    borderRadius: '4px',\n                    overflow: 'hidden'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                        ref: canvasRef,\n                        className: \"tracking-canvas\",\n                        id: \"tracking-canvas\",\n                        style: {\n                            width: '100%',\n                            height: '100%',\n                            display: 'block' // Ensure canvas is displayed as block\n                        },\n                        onLoad: (e)=>{\n                            // Initialize canvas when it loads\n                            const canvas = e.target;\n                            if (canvas) {\n                                canvasRef.current = canvas;\n                                if (true) {\n                                    window.whiteScreenCanvas = canvas;\n                                }\n                                // Initialize canvas with white background\n                                const ctx = canvas.getContext('2d');\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                            }\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1461,\n                        columnNumber: 11\n                    }, undefined),\n                    countdownValue && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"dot-countdown\",\n                        style: {\n                            position: 'absolute',\n                            left: \"\".concat(currentDot.x - 15, \"px\"),\n                            top: \"\".concat(currentDot.y - 40, \"px\"),\n                            color: 'red',\n                            fontSize: '28px',\n                            fontWeight: 'bold'\n                        },\n                        children: countdownValue\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                        lineNumber: 1488,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1448,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1532,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1542,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1560,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1573,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1552,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1522,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1507,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1418,\n        columnNumber: 5\n    }, undefined);\n}, \"Ns1C2Zu4YEn8CGqdNt7gJxrbOrQ=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1595,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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bmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9hY3Rpb25CdXR0b24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgZm9yd2FyZFJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgXG4gIHNob3dDYXB0dXJlUHJldmlldywgXG4gIGRyYXdSZWREb3QsIFxuICBnZXRSYW5kb21Qb3NpdGlvbixcbiAgY3JlYXRlQ291bnRkb3duRWxlbWVudCxcbiAgcnVuQ291bnRkb3duXG59IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZSc7XG5pbXBvcnQgeyB1c2VSb3V0ZXIgfSBmcm9tICduZXh0L3JvdXRlcic7XG5pbXBvcnQgeyB1c2VBZG1pblNldHRpbmdzIH0gZnJvbSAnLi9hZG1pblNldHRpbmdzJztcblxuLy8gQWRkIGRlZXAgY29tcGFyaXNvbiB1dGlsaXR5XG5jb25zdCBpc0VxdWFsID0gKG9iajEsIG9iajIpID0+IHtcbiAgaWYgKG9iajEgPT09IG9iajIpIHJldHVybiB0cnVlO1xuICBpZiAodHlwZW9mIG9iajEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmoyICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICBpZiAob2JqMSA9PT0gbnVsbCB8fCBvYmoyID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIFxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIFxuICByZXR1cm4ga2V5czEuZXZlcnkoa2V5ID0+IFxuICAgIGtleXMyLmluY2x1ZGVzKGtleSkgJiYgaXNFcXVhbChvYmoxW2tleV0sIG9iajJba2V5XSlcbiAgKTtcbn07XG5cbi8vIENyZWF0ZSBhIGJhc2ljIEFjdGlvbkJ1dHRvbiBjb21wb25lbnQgd2l0aCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbiA9ICh7IHRleHQsIGFiYnJldmlhdGVkVGV4dCwgb25DbGljaywgY3VzdG9tQ2xhc3MgPSAnJywgZGlzYWJsZWQgPSBmYWxzZSwgYWN0aXZlID0gZmFsc2UgfSkgPT4ge1xuICBjb25zdCBbaXNBYmJyZXZpYXRlZCwgc2V0SXNBYmJyZXZpYXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHsgc2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MoKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnRlciwgc2V0Q2FwdHVyZUNvdW50ZXJdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtwcm9jZXNzU3RhdHVzLCBzZXRQcm9jZXNzU3RhdHVzXSA9IHVzZVN0YXRlKCcnKTtcblxuICAvLyBNZW1vaXplIGJ1dHRvbiBwcm9wcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlLXJlbmRlcnNcbiAgY29uc3QgYnV0dG9uUHJvcHMgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgY2xhc3NOYW1lOiBgYWN0aW9uLWJ1dHRvbiAke2N1c3RvbUNsYXNzfSAke2lzQWJicmV2aWF0ZWQgPyAnYWJicmV2aWF0ZWQnIDogJyd9ICR7YWN0aXZlID8gJ2FjdGl2ZScgOiAnJ31gLFxuICAgIG9uQ2xpY2ssXG4gICAgZGlzYWJsZWQsXG4gICAgdGl0bGU6IHRleHRcbiAgfSksIFtjdXN0b21DbGFzcywgaXNBYmJyZXZpYXRlZCwgYWN0aXZlLCBvbkNsaWNrLCBkaXNhYmxlZCwgdGV4dF0pO1xuXG4gIC8vIENoZWNrIHdpbmRvdyBzaXplIGFuZCBzZXQgYWJicmV2aWF0ZWQgbW9kZSB3aXRoIGRlYm91bmNlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgbGV0IHRpbWVvdXRJZDtcbiAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBzZXRJc0FiYnJldmlhdGVkKHdpZHRoIDwgNzY4KTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfTtcbiAgICBcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICBoYW5kbGVSZXNpemUoKTsgLy8gSW5pdGlhbCBjYWxsXG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEFkZCBlZmZlY3QgdG8gbGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXMgd2l0aCBvcHRpbWl6YXRpb25cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIGlmIChuZXdVc2VySWQgIT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uIHsuLi5idXR0b25Qcm9wc30+XG4gICAgICB7aXNBYmJyZXZpYXRlZCA/IGFiYnJldmlhdGVkVGV4dCA6IHRleHR9XG4gICAgICB7cHJvY2Vzc1N0YXR1cyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicHJvY2Vzcy1zdGF0dXNcIj5cbiAgICAgICAgICB7cHJvY2Vzc1N0YXR1c31cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvYnV0dG9uPlxuICApO1xufTtcblxuLy8gQ3JlYXRlIHRoZSBBY3Rpb25CdXR0b25Hcm91cCBjb21wb25lbnQgd2l0aCBjbGllbnQtc2lkZSBvbmx5IHJlbmRlcmluZyBhbmQgb3B0aW1pemF0aW9uXG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cElubmVyID0gZm9yd2FyZFJlZigoeyB0cmlnZ2VyQ2FtZXJhQWNjZXNzLCBpc0NvbXBhY3RNb2RlLCBvbkFjdGlvbkNsaWNrIH0sIHJlZikgPT4ge1xuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MocmVmKTtcbiAgXG4gIC8vIFN0YXRlIGZvciBidXR0b24gYWN0aW9uc1xuICBjb25zdCBbcmFuZG9tVGltZXMsIHNldFJhbmRvbVRpbWVzXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbZGVsYXlTZWNvbmRzLCBzZXREZWxheVNlY29uZHNdID0gdXNlU3RhdGUoMyk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbY291bnRkb3duVmFsdWUsIHNldENvdW50ZG93blZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY3VycmVudERvdCwgc2V0Q3VycmVudERvdF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2NhbGlicmF0aW9uUG9pbnRzLCBzZXRDYWxpYnJhdGlvblBvaW50c10gPSB1c2VTdGF0ZShbXSk7XG4gIGNvbnN0IFtjdXJyZW50Q2FsaWJyYXRpb25JbmRleCwgc2V0Q3VycmVudENhbGlicmF0aW9uSW5kZXhdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtyZW1haW5pbmdDYXB0dXJlcywgc2V0UmVtYWluaW5nQ2FwdHVyZXNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtzaG93Q2FudmFzLCBzZXRTaG93Q2FudmFzXSA9IHVzZVN0YXRlKHRydWUpO1xuICBcbiAgLy8gVHJhY2sgdGhlIGNhcHR1cmUgY291bnRcbiAgY29uc3QgW2NhbGlicmF0aW9uSGFuZGxlciwgc2V0Q2FsaWJyYXRpb25IYW5kbGVyXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FwdHVyZUNvdW50LCBzZXRDYXB0dXJlQ291bnRdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBcbiAgLy8gVG9nZ2xlIHN0YXRlc1xuICBjb25zdCBbc2hvd0hlYWRQb3NlLCBzZXRTaG93SGVhZFBvc2VdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0JvdW5kaW5nQm94LCBzZXRTaG93Qm91bmRpbmdCb3hdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd01hc2ssIHNldFNob3dNYXNrXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dQYXJhbWV0ZXJzLCBzZXRTaG93UGFyYW1ldGVyc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0NhbWVyYUFjdGl2ZSwgc2V0SXNDYW1lcmFBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1Blcm1pc3Npb25Qb3B1cCwgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50VXNlcklkLCBzZXRDdXJyZW50VXNlcklkXSA9IHVzZVN0YXRlKCdkZWZhdWx0Jyk7XG5cbiAgLy8gQWRkIGNhY2hlIGZvciBzZXR0aW5nc1xuICBjb25zdCBzZXR0aW5nc0NhY2hlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG4gIGNvbnN0IGxhc3RTZXR0aW5nc1VwZGF0ZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIGNvbmZpZ3VyYXRpb25zXG4gIGNvbnN0IGJ1dHRvbnMgPSB1c2VNZW1vKCgpID0+IFtcbiAgICB7IFxuICAgICAgdGV4dDogXCJTZXQgUmFuZG9tXCIsIFxuICAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIlNSYW5kb21cIiwgXG4gICAgICBvbkNsaWNrOiBoYW5kbGVTZXRSYW5kb20sXG4gICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmdcbiAgICB9LFxuICAgIHsgXG4gICAgICB0ZXh0OiBcIlJhbmRvbSBEb3RcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiUmFuZG9tXCIsIFxuICAgICAgb25DbGljazogaGFuZGxlUmFuZG9tRG90LFxuICAgICAgZGlzYWJsZWQ6IGlzQ2FwdHVyaW5nIFxuICAgIH0sXG4gICAgeyBcbiAgICAgIHRleHQ6IFwiU2V0IENhbGlicmF0ZVwiLCBcbiAgICAgIGFiYnJldmlhdGVkVGV4dDogXCJDYWxpYnJhdGVcIiwgXG4gICAgICBvbkNsaWNrOiBoYW5kbGVTZXRDYWxpYnJhdGUsXG4gICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmcgXG4gICAgfSxcbiAgICB7IFxuICAgICAgdGV4dDogXCJDbGVhciBBbGxcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiQ2xlYXJcIiwgXG4gICAgICBvbkNsaWNrOiBoYW5kbGVDbGVhckFsbFxuICAgIH0sXG4gICAgeyBkaXZpZGVyOiB0cnVlIH0sXG4gICAgeyBcbiAgICAgIHRleHQ6IFwiRHJhdyBIZWFkIHBvc2VcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwiSGVhZCBwb3NlXCIsIFxuICAgICAgb25DbGljazogaGFuZGxlVG9nZ2xlSGVhZFBvc2UsXG4gICAgICBhY3RpdmU6IHNob3dIZWFkUG9zZVxuICAgIH0sXG4gICAgeyBcbiAgICAgIHRleHQ6IFwiU2hvdyBCb3VuZGluZyBCb3hcIiwgXG4gICAgICBhYmJyZXZpYXRlZFRleHQ6IFwi4piQIEJveFwiLCBcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94LFxuICAgICAgYWN0aXZlOiBzaG93Qm91bmRpbmdCb3hcbiAgICB9LFxuICAgIHsgXG4gICAgICB0ZXh0OiBpc0NhbWVyYUFjdGl2ZSA/IFwiU3RvcCBDYW1lcmFcIiA6IFwiU2hvdyBQcmV2aWV3XCIsIFxuICAgICAgYWJicmV2aWF0ZWRUZXh0OiBpc0NhbWVyYUFjdGl2ZSA/IFwiU3RvcFwiIDogXCJQcmV2aWV3XCIsIFxuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICBpZiAoIWlzQ2FtZXJhQWN0aXZlICYmICF0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpKSB7XG4gICAgICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVUb2dnbGVDYW1lcmEoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFjdGl2ZTogaXNDYW1lcmFBY3RpdmUsXG4gICAgICBkaXNhYmxlZDogaXNDYXB0dXJpbmdcbiAgICB9LFxuICAgIHsgXG4gICAgICB0ZXh0OiBcIvCfmLcgU2hvdyBNYXNrXCIsIFxuICAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIvCfmLcgTWFza1wiLCBcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZU1hc2ssXG4gICAgICBhY3RpdmU6IHNob3dNYXNrXG4gICAgfSxcbiAgICB7IFxuICAgICAgdGV4dDogXCJQYXJhbWV0ZXJzXCIsIFxuICAgICAgYWJicmV2aWF0ZWRUZXh0OiBcIlZhbHVlc1wiLCBcbiAgICAgIG9uQ2xpY2s6IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMsXG4gICAgICBhY3RpdmU6IHNob3dQYXJhbWV0ZXJzXG4gICAgfVxuICBdLCBbaXNDYXB0dXJpbmcsIHNob3dIZWFkUG9zZSwgc2hvd0JvdW5kaW5nQm94LCBpc0NhbWVyYUFjdGl2ZSwgc2hvd01hc2ssIHNob3dQYXJhbWV0ZXJzXSk7XG5cbiAgLy8gT3B0aW1pemUgc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdKSB7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldChjdXJyZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc0VxdWFsKGNhY2hlZFNldHRpbmdzLCB1c2VyU2V0dGluZ3MpKSB7XG4gICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXMpIHx8IDEpO1xuICAgICAgICBzZXREZWxheVNlY29uZHMoTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheSkgfHwgMyk7XG4gICAgICAgIHNldHRpbmdzQ2FjaGUuY3VycmVudC5zZXQoY3VycmVudFVzZXJJZCwgdXNlclNldHRpbmdzKTtcbiAgICAgICAgbGFzdFNldHRpbmdzVXBkYXRlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIERhdGUubm93KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3NldHRpbmdzLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciB1c2VyIElEIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICd1c2VySWRDaGFuZ2UnKSB7XG4gICAgICAgIGNvbnN0IG5ld1VzZXJJZCA9IGV2ZW50LmRldGFpbC51c2VySWQ7XG4gICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgLy8gVXBkYXRlIHNldHRpbmdzIGZvciBuZXcgdXNlclxuICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3NbbmV3VXNlcklkXSkge1xuICAgICAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzW25ld1VzZXJJZF07XG4gICAgICAgICAgc2V0UmFuZG9tVGltZXMoTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lcykgfHwgMSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXkpIHx8IDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCB0aW1lcywgZGVsYXkgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGlmICh0aW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUaW1lcyA9IE51bWJlcih0aW1lcykgfHwgMTtcbiAgICAgICAgICAgIHNldFJhbmRvbVRpbWVzKG5ld1RpbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlbGF5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlbGF5ID0gTnVtYmVyKGRlbGF5KSB8fCAzO1xuICAgICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKG5ld0RlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE1ha2UgZnVuY3Rpb25zIGdsb2JhbGx5IGFjY2Vzc2libGUgYXMgYSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyA9IHtcbiAgICAgICAgaGFuZGxlUmFuZG9tRG90LFxuICAgICAgICBoYW5kbGVTZXRSYW5kb20sXG4gICAgICAgIGhhbmRsZVNldENhbGlicmF0ZSxcbiAgICAgICAgaGFuZGxlQ2xlYXJBbGxcbiAgICAgIH07XG4gICAgICAvLyBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbiBmdW5jdGlvbnMgZXhwb3NlZCB0byB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnM7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICAvLyBGdW5jdGlvbiB0byBnZXQgY29udHJvbCB2YWx1ZXMgZnJvbSBUb3BCYXJcbiAgICBjb25zdCB1cGRhdGVDb250cm9sVmFsdWVzID0gKCkgPT4ge1xuICAgICAgLy8gR2V0IHRoZSB0aW1lIGlucHV0IGVsZW1lbnRcbiAgICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgY29uc3QgdGltZVZhbHVlID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4odGltZVZhbHVlKSAmJiB0aW1lVmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHJhbmRvbVRpbWVzIHRvOicsIHRpbWVWYWx1ZSk7XG4gICAgICAgICAgc2V0UmFuZG9tVGltZXModGltZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGRlbGF5IGlucHV0IGVsZW1lbnRcbiAgICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgY29uc3QgZGVsYXlWYWx1ZSA9IHBhcnNlSW50KGRlbGF5SW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihkZWxheVZhbHVlKSAmJiBkZWxheVZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBkZWxheVNlY29uZHMgdG86JywgZGVsYXlWYWx1ZSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKGRlbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBjb250cm9sIGlucHV0c1xuICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICBcbiAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICB0aW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB0aW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTsgLy8gQWxzbyBsaXN0ZW4gZm9yIGlucHV0IGV2ZW50c1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIGRlbGF5SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTsgLy8gQWxzbyBsaXN0ZW4gZm9yIGlucHV0IGV2ZW50c1xuICAgIH1cbiAgICBcbiAgICAvLyBJbml0aWFsIHVwZGF0ZVxuICAgIHVwZGF0ZUNvbnRyb2xWYWx1ZXMoKTtcbiAgICBcbiAgICAvLyBDbGVhbnVwIGV2ZW50IGxpc3RlbmVyc1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgIHRpbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGRlbGF5SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICAgIGRlbGF5SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgY29uc3QgaW5pdGlhbGl6ZUNhbnZhcyA9IChjYW52YXMsIHBhcmVudCkgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFwYXJlbnQpIHtcbiAgICAgIC8vIGNvbnNvbGUud2FybignW2luaXRpYWxpemVDYW52YXNdIENhbnZhcyBvciBwYXJlbnQgaXMgbnVsbCcsIHsgY2FudmFzLCBwYXJlbnQgfSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggcGFyZW50XG4gICAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXMgYW5kIHNldCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBDYW52YXMgaW5pdGlhbGl6ZWQgd2l0aCBkaW1lbnNpb25zOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tpbml0aWFsaXplQ2FudmFzXSBFcnJvciBpbml0aWFsaXppbmcgY2FudmFzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWFpbiBjYW52YXMgLSBpbXByb3ZlZCB0byBiZSBtb3JlIHJlbGlhYmxlXG4gIGNvbnN0IGdldE1haW5DYW52YXMgPSAoKSA9PiB7XG4gICAgLy8gVHJ5IG11bHRpcGxlIG1ldGhvZHMgdG8gZmluZCB0aGUgY2FudmFzXG4gICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGRpcmVjdCBjYW52YXNSZWYuY3VycmVudCByZWZlcmVuY2VcIik7XG4gICAgICByZXR1cm4gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiVXNpbmcgZ2xvYmFsIHdoaXRlU2NyZWVuQ2FudmFzIHJlZmVyZW5jZVwiKTtcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gd2luZG93LndoaXRlU2NyZWVuQ2FudmFzO1xuICAgICAgcmV0dXJuIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVHJ5IG11bHRpcGxlIHNlbGVjdG9ycyB0byBmaW5kIHRoZSBjYW52YXNcbiAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IFsnLnRyYWNraW5nLWNhbnZhcycsICdjYW52YXMnLCAnI3RyYWNraW5nLWNhbnZhcyddO1xuICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBzZWxlY3RvcnMpIHtcbiAgICAgICAgY29uc3QgY2FudmFzRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBpZiAoY2FudmFzRWxlbWVudCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBjYW52YXMgdmlhIHNlbGVjdG9yOiAke3NlbGVjdG9yfWApO1xuICAgICAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzRWxlbWVudDtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhc0VsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYW52YXNFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUuZXJyb3IoXCJObyBjYW52YXMgZm91bmQgdGhyb3VnaCBhbnkgbWV0aG9kXCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCBtYWtlQ2FudmFzRnVsbHNjcmVlbiA9IChjYW52YXMpID0+IHtcbiAgICAvLyBGaXJzdCBpbml0aWFsaXplIHdpdGggcGFyZW50IGRpbWVuc2lvbnNcbiAgICBjb25zdCBwYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIGluaXRpYWxpemVDYW52YXMoY2FudmFzLCBwYXJlbnQpO1xuICAgIFxuICAgIC8vIFRoZW4gZm9yY2UgZnVsbHNjcmVlbiBzdHlsaW5nXG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICc1JztcbiAgICBcbiAgICAvLyBGb3JjZSBkaW1lbnNpb25zIHRvIG1hdGNoIHdpbmRvd1xuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgYW5kIHByZXBhcmUgY2FudmFzIGFnYWluXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBDYW52YXMgc2V0IHRvIGZ1bGxzY3JlZW46ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gIH07XG4gIGNvbnN0IHJlc3RvcmVDYW52YXNTaXplID0gKGNhbnZhcykgPT4ge1xuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgY2FudmFzIHN0eWxpbmdcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICBjYW52YXMuc3R5bGUudG9wID0gJyc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnJztcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJyc7XG4gICAgXG4gICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBkaW1lbnNpb25zXG4gICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICBpbml0aWFsaXplQ2FudmFzKGNhbnZhcywgY2FudmFzLnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWQgPSAoKSA9PiB7XG4gICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cChmYWxzZSk7XG4gICAgaWYgKHRyaWdnZXJDYW1lcmFBY2Nlc3MpIHtcbiAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3ModHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEhhbmRsZXIgdG8gY2FuY2VsIHBlcm1pc3Npb24gcG9wdXBcbiAgY29uc3QgaGFuZGxlUGVybWlzc2lvbkRlbmllZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gcmVzdG9yZSB0aGUgY2FudmFzIHRvIGl0cyBvcmlnaW5hbCBwYXJlbnQgYW5kIHN0eWxpbmdcbiAgY29uc3QgcmVzdG9yZUNhbnZhcyA9IChjYW52YXMsIG9yaWdpbmFsUGFyZW50LCBvcmlnaW5hbFN0eWxlKSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIW9yaWdpbmFsUGFyZW50KSByZXR1cm47XG5cbiAgICAvLyBBcHBlbmQgdGhlIGNhbnZhcyBiYWNrIHRvIGl0cyBvcmlnaW5hbCBwYXJlbnQgaWYgbmVlZGVkXG4gICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBvcmlnaW5hbFBhcmVudCkge1xuICAgICAgb3JpZ2luYWxQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVzdG9yZSB0aGUgaW5saW5lIHN0eWxlcyBzYXZlZCBlYXJsaWVyXG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gb3JpZ2luYWxTdHlsZS5wb3NpdGlvbjtcbiAgICBjYW52YXMuc3R5bGUudG9wID0gb3JpZ2luYWxTdHlsZS50b3A7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSBvcmlnaW5hbFN0eWxlLmxlZnQ7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gb3JpZ2luYWxTdHlsZS53aWR0aDtcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxTdHlsZS5oZWlnaHQ7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IG9yaWdpbmFsU3R5bGUuekluZGV4O1xuICAgIFxuICAgIC8vIFJlc2V0IHRoZSBkaW1lbnNpb25zIGJhc2VkIG9uIHRoZSBwYXJlbnQgZWxlbWVudCdzIHNpemUgb3IgZmFsbGJhY2sgZGVmYXVsdHNcbiAgICBjYW52YXMud2lkdGggPSBvcmlnaW5hbFBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgY2FudmFzLmhlaWdodCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBhbmQgZmlsbCB3aXRoIGEgd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfTtcblxuXG4gIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJObyBjYW52YXMgZm91bmQgZm9yIGNsZWFyaW5nXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgc2V0Q3VycmVudERvdChudWxsKTtcbiAgfTtcbiAgLy8gQWRkIHRoaXMgZnVuY3Rpb24gdG8gYWN0aW9uQnV0dG9uLmpzXG5cbiAgLyoqXG4gICAqIENvbnNvbGlkYXRlZCBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgdGhlIGVudGlyZSBkb3QgcHJvY2VzczogZHJhd2luZywgY291bnRkb3duLCBjYXB0dXJlLCBhbmQgcHJldmlld1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5wb3NpdGlvbiAtIHt4LCB5fSBjb29yZGluYXRlcyB3aGVyZSB0byBkcmF3IHRoZSBkb3RcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5vblN0YXR1c1VwZGF0ZSAtIENhbGxiYWNrIGZvciBzdGF0dXMgdXBkYXRlc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnRvZ2dsZVRvcEJhciAtIEZ1bmN0aW9uIHRvIHRvZ2dsZSB0b3AgYmFyIHZpc2liaWxpdHlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50cmlnZ2VyQ2FtZXJhQWNjZXNzIC0gRnVuY3Rpb24gdG8gZW5zdXJlIGNhbWVyYSBpcyBhdmFpbGFibGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRJc0NhcHR1cmluZyAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjYXB0dXJpbmcgc3RhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMuY2FwdHVyZUNvdW50IC0gQ3VycmVudCBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRDYXB0dXJlQ291bnQgLSBGdW5jdGlvbiB0byB1cGRhdGUgdGhlIGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbnMudXNlUmFuZG9tUG9zaXRpb24gLSBXaGV0aGVyIHRvIGdlbmVyYXRlIGEgcmFuZG9tIHBvc2l0aW9uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IC0gUmVzdWx0IG9iamVjdCB3aXRoIGNhcHR1cmUgZGF0YVxuICAgKi9cbiAgLy8gTW9kaWZpZWQgaGFuZGxlRG90UHJvY2VzcyBmdW5jdGlvbiB3aXRoIGltcHJvdmVkIGRvdCBhbmQgY291bnRkb3duIGFsaWdubWVudFxuICBjb25zdCBoYW5kbGVEb3RQcm9jZXNzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgIHNldElzQ2FwdHVyaW5nLFxuICAgICAgY2FwdHVyZUNvdW50LFxuICAgICAgc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgdXNlUmFuZG9tUG9zaXRpb24gPSBmYWxzZSxcbiAgICAgIHBvc3RDb3VudGRvd25EZWxheSA9IDUwMCBcbiAgICB9ID0gb3B0aW9ucztcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzaG93aW5nIHRoZSBkb3RcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGVcbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogdXNlUmFuZG9tUG9zaXRpb24gPyAnR2VuZXJhdGluZyByYW5kb20gZG90Li4uJyA6ICdTdGFydGluZyBkb3QgcHJvY2Vzcy4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgVUkgdXBkYXRlcyB0byB0YWtlIGVmZmVjdFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FudmFzIHJlZmVyZW5jZSB3aXRoIHJldHJpZXNcbiAgICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICAgICAgY29uc3QgbWF4UmV0cmllcyA9IDM7XG4gICAgICBcbiAgICAgIHdoaWxlICghY2FudmFzICYmIHJldHJ5Q291bnQgPCBtYXhSZXRyaWVzKSB7XG4gICAgICAgIGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhbnZhcyBub3QgZm91bmQsIHJldHJ5ICR7cmV0cnlDb3VudCArIDF9LyR7bWF4UmV0cmllc31gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgYXZhaWxhYmxlIGFmdGVyIG11bHRpcGxlIHJldHJpZXNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNhdmUgb3JpZ2luYWwgc3RhdGUgZm9yIHJlc3RvcmF0aW9uXG4gICAgICBjb25zdCBvcmlnaW5hbFBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgY29uc3Qgb3JpZ2luYWxTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgdG9wOiBjYW52YXMuc3R5bGUudG9wLFxuICAgICAgICBsZWZ0OiBjYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICB6SW5kZXg6IGNhbnZhcy5zdHlsZS56SW5kZXhcbiAgICAgIH07XG5cbiAgICAgIC8vIFByZXBhcmUgY2FudmFzIGZvciBmdWxsc2NyZWVuIGRpc3BsYXlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgIFxuICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93IGV4YWN0bHlcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBHZXQgcG9zaXRpb24gZm9yIHRoZSBkb3QgLSBlaXRoZXIgdXNlIHByb3ZpZGVkIHBvc2l0aW9uIG9yIGdlbmVyYXRlIHJhbmRvbSBvbmVcbiAgICAgIGNvbnN0IGRvdFBvc2l0aW9uID0gdXNlUmFuZG9tUG9zaXRpb24gXG4gICAgICAgID8gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCkgXG4gICAgICAgIDogcG9zaXRpb247XG4gICAgICBcbiAgICAgIGlmICghZG90UG9zaXRpb24gfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBkb3RQb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRvdCBwb3NpdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRHJhdyB0aGUgZG90XG4gICAgICBjb25zdCBkb3RSYWRpdXMgPSAxMjtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgbGV0IGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIH0sIDUwKTsgIC8vIE1vcmUgZnJlcXVlbnQgdXBkYXRlcyBmb3IgcmVsaWFiaWxpdHlcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgY291bnRkb3duIGVsZW1lbnQgZGlyZWN0bHkgb24gdG9wIG9mIHRoZSBkb3RcbiAgICAgIC8vIEltcG9ydGFudDogUG9zaXRpb24gdGhlIGNvdW50ZG93biBjZW50ZXJlZCBkaXJlY3RseSBvdmVyIHRoZSBkb3RcbiAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGxlZnQ6ICR7ZG90UG9zaXRpb24ueH1weDtcbiAgICAgICAgdG9wOiAke2RvdFBvc2l0aW9uLnl9cHg7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIFxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBgQ291bnRkb3duOiAke2NvdW50fWAsXG4gICAgICAgICAgY291bnRkb3duVmFsdWU6IGNvdW50LFxuICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVkcmF3IHRoZSBkb3QgZm9yIHJlbGlhYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZGl0aW9uYWwgcmVkcmF3IGR1cmluZyBjb3VudGRvd24gdG8gZW5zdXJlIHZpc2liaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGFmdGVyIGNvdW50ZG93biBjb21wbGV0ZXNcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBwb3N0Q291bnRkb3duRGVsYXkpKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICBwb2ludDogZG90UG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50LFxuICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgIGNsZWFySW50ZXJ2YWwoa2VlcERvdFZpc2libGVJbnRlcnZhbCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgY2FudmFzIHRvIG9yaWdpbmFsIHN0YXRlXG4gICAgICBpZiAob3JpZ2luYWxQYXJlbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IG9yaWdpbmFsUGFyZW50KSB7XG4gICAgICAgIG9yaWdpbmFsUGFyZW50LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IG9yaWdpbmFsU3R5bGUucG9zaXRpb24gfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gb3JpZ2luYWxTdHlsZS50b3AgfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsU3R5bGUubGVmdCB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9yaWdpbmFsU3R5bGUud2lkdGggfHwgJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IG9yaWdpbmFsU3R5bGUuaGVpZ2h0IHx8ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBvcmlnaW5hbFN0eWxlLnpJbmRleCB8fCAnJztcbiAgICAgIFxuICAgICAgLy8gUmVzZXQgZGltZW5zaW9uc1xuICAgICAgaWYgKG9yaWdpbmFsUGFyZW50KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IG9yaWdpbmFsUGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJlIGNvbXBsZXRlZCcsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMjAwMCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZVJlc3VsdFxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlRG90UHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBEZWNsYXJlIHRoZXNlIHZhcmlhYmxlcyBPVVRTSURFIHRoZSB0cnkgYmxvY2tcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBsZXQgb3JpZ2luYWxDYW52YXNQYXJlbnQgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1N0eWxlID0ge307XG4gICAgbGV0IHN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0U2hvd0NhbnZhcyh0cnVlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoXCJTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLlwiKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgVUkgdXBkYXRlcyB0byB0YWtlIGVmZmVjdFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FudmFzIHJlZmVyZW5jZVxuICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIkVycm9yOiBDYW52YXMgbm90IGZvdW5kXCIpO1xuICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBwYXJlbnQgYW5kIHN0eWxlXG4gICAgICBvcmlnaW5hbENhbnZhc1BhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgb3JpZ2luYWxDYW52YXNTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgdG9wOiBjYW52YXMuc3R5bGUudG9wLFxuICAgICAgICBsZWZ0OiBjYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICB6SW5kZXg6IGNhbnZhcy5zdHlsZS56SW5kZXhcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIE1vdmUgY2FudmFzIHRvIGJvZHkgZm9yIG1heGltdW0gcmVsaWFiaWxpdHlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBjYW52YXMgZnVsbHNjcmVlbiB3aXRoIGZpeGVkIHBvc2l0aW9uaW5nXG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgICBcbiAgICAgIC8vIFNldCBkaW1lbnNpb25zIHRvIG1hdGNoIHdpbmRvdyBleGFjdGx5XG4gICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHNldCB0byBmdWxsc2NyZWVuOiAke2NhbnZhc1dpZHRofXgke2NhbnZhc0hlaWdodH1gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNvbnRleHRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cyBiYXNlZCBvbiB0aGUgY2FudmFzIHNpemVcbiAgICAgIGNvbnN0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cycpO1xuICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIFxuICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN0YXR1c0luZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbjogSW5pdGlhbGl6aW5nLi4uJztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGlzcGxheXNcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBjYW52YXMgaWYgZGltZW5zaW9ucyBjaGFuZ2VkXG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FudmFzIGRpbWVuc2lvbnMgY2hhbmdlZC4gUmVzZXR0aW5nIHRvICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYm9keSBhbmQgaW4gZnVsbHNjcmVlbiBtb2RlXG4gICAgICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgICAgY29uc3QgcmFkaXVzID0gMTQ7IC8vIFNsaWdodGx5IGxhcmdlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBmdW5jdGlvbiBmb3IgdGhpcyBwb2ludFxuICAgICAgICBjb25zdCByZWRyYXdDdXJyZW50RG90ID0gKCkgPT4ge1xuICAgICAgICAgIC8vIFZlcmlmeSBjYW52YXMgZGltZW5zaW9ucyBhbmQgcGFyZW50XG4gICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5XG4gICAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZHJhdyBkb3Qgd2l0aG91dCBjbGVhcmluZ1xuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHJlZHJhdyBpbnRlcnZhbCAtIG1vcmUgZnJlcXVlbnQgdXBkYXRlcyBmb3IgcmVsaWFibGUgZG90IHZpc2liaWxpdHlcbiAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwocmVkcmF3Q3VycmVudERvdCwgNTApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nOyAvLyBDb25zaXN0ZW50IGNsYXNzIG5hbWVcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICBsZWZ0OiAke3BvaW50Lnh9cHg7XG4gICAgICAgICAgdG9wOiAke3BvaW50LnkgLSA2MH1weDtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofTogQ291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVkcmF3IGFnYWluIGhhbGZ3YXkgdGhyb3VnaCB0aGUgd2FpdCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGFmdGVyIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcblxuICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFudWFsIGZvcmNlIHJlZHJhdyBvbmUgbW9yZSB0aW1lIGp1c3QgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICB9XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgcmVkcmF3IGludGVydmFsXG4gICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yICYmIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIGNhbnZhcyB0byBvcmlnaW5hbCBwYXJlbnQgYW5kIHN0eWxpbmcgLSBPbmx5IGlmIGNhbnZhcyB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkXG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgb3JpZ2luYWwgcGFyZW50XG4gICAgICAgICAgaWYgKG9yaWdpbmFsQ2FudmFzUGFyZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBvcmlnaW5hbENhbnZhc1BhcmVudCkge1xuICAgICAgICAgICAgb3JpZ2luYWxDYW52YXNQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFvcmlnaW5hbENhbnZhc1BhcmVudCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gbG9va2luZyBmb3IgYSBjb250YWluZXIgZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgcG9zc2libGVQYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUGFyZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBwb3NzaWJsZVBhcmVudCkge1xuICAgICAgICAgICAgICBwb3NzaWJsZVBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXN0b3JlIHN0eWxpbmdcbiAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbENhbnZhc1N0eWxlLnBvc2l0aW9uIHx8ICcnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSBvcmlnaW5hbENhbnZhc1N0eWxlLnRvcCB8fCAnJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IG9yaWdpbmFsQ2FudmFzU3R5bGUubGVmdCB8fCAnJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBvcmlnaW5hbENhbnZhc1N0eWxlLndpZHRoIHx8ICcxMDAlJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gb3JpZ2luYWxDYW52YXNTdHlsZS5oZWlnaHQgfHwgJzEwMCUnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBvcmlnaW5hbENhbnZhc1N0eWxlLnpJbmRleCB8fCAnJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZXNldCBkaW1lbnNpb25zIGJhc2VkIG9uIHBhcmVudFxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodCB8fCA2MDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IDgwMDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSA2MDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coXCJDYW52YXMgcmVzdG9yZWQgdG8gb3JpZ2luYWwgc3RhdGVcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVzdG9yaW5nIGNhbnZhczpcIiwgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBBbHdheXMgZ2V0IHRoZSBsYXRlc3Qgc2V0dGluZ3MgZnJvbSBjb250ZXh0IGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5ncyAmJiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSA/IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdIDoge307XG4gICAgICBjb25zdCB0aW1lcyA9IE51bWJlcih1c2VyU2V0dGluZ3MudGltZXMpIHx8IE51bWJlcihyYW5kb21UaW1lcykgfHwgMTtcbiAgICAgIGNvbnN0IGRlbGF5ID0gTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheSkgfHwgTnVtYmVyKGRlbGF5U2Vjb25kcykgfHwgMztcblxuICAgICAgLy8gTG9nIGN1cnJlbnQgc2V0dGluZ3MgYmVmb3JlIHN0YXJ0aW5nXG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgU2V0IFJhbmRvbSB3aXRoIHNldHRpbmdzOicsIHtcbiAgICAgICAgcmFuZG9tVGltZXMsXG4gICAgICAgIGRlbGF5U2Vjb25kcyxcbiAgICAgICAgY3VycmVudFVzZXJJZCxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgIHVzZXJTZXR0aW5ncyxcbiAgICAgICAgdGltZXMsXG4gICAgICAgIGRlbGF5XG4gICAgICB9KTtcblxuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgU3RhcnRpbmcgJHt0aW1lc30gcmFuZG9tIGNhcHR1cmVzIHdpdGggJHtkZWxheX1zIGRlbGF5Li4uYCk7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIGNhcHR1cmVzIGluIHNlcXVlbmNlXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgY3VycmVudEluZGV4ID0gMTsgY3VycmVudEluZGV4IDw9IHRpbWVzOyBjdXJyZW50SW5kZXgrKykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMgLSBjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlICR7Y3VycmVudEluZGV4fSBvZiAke3RpbWVzfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIGhhbmRsZURvdFByb2Nlc3MgZm9yIGVhY2ggY2FwdHVyZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgICAgICB1c2VSYW5kb21Qb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9LyR7dGltZXN9OiAke3N0YXR1cy5wcm9jZXNzU3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IFRvcEJhciBhZnRlciB0aGUgbGFzdCBjYXB0dXJlXG4gICAgICAgICAgICBpZiAoc2hvdyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHNob3cgeWV0IGZvciBpbnRlcm1lZGlhdGUgY2FwdHVyZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoc2hvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgICAgIHNldElzQ2FwdHVyaW5nOiAoY2FwdHVyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCBjYXB0dXJpbmcgdG8gZmFsc2UgYWZ0ZXIgYWxsIGNhcHR1cmVzXG4gICAgICAgICAgICBpZiAoIWNhcHR1cmluZyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIFN0YXkgaW4gY2FwdHVyaW5nIHN0YXRlIGJldHdlZW4gZG90c1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoY2FwdHVyaW5nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiA4MDBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgY2FwdHVyZSAke2N1cnJlbnRJbmRleH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG1heSBoYXZlIGZhaWxlZDpgLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgLSBidXQgb25seSBpZiB0aGVyZSBhcmUgbW9yZSBjYXB0dXJlcyB0byBnb1xuICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IGNhcHR1cmVzIHN1Y2Nlc3NmdWxgKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgICAgY29uc29sZS5sb2coYENvbXBsZXRlZCBhbGwgY2FwdHVyZXM6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBzdWNjZXNzZnVsYCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJhbmRvbSBzZXF1ZW5jZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUmFuZG9tIHNlcXVlbmNlIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGhhbmRsZVJhbmRvbURvdCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBVc2UgdGhlIGNvbnNvbGlkYXRlZCBmdW5jdGlvbiB3aXRoIHJhbmRvbSBwb3NpdGlvblxuICAgIGF3YWl0IGhhbmRsZURvdFByb2Nlc3Moe1xuICAgICAgdXNlUmFuZG9tUG9zaXRpb246IHRydWUsXG4gICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICBpZiAoc3RhdHVzLmlzQ2FwdHVyaW5nICE9PSB1bmRlZmluZWQpIHNldElzQ2FwdHVyaW5nKHN0YXR1cy5pc0NhcHR1cmluZyk7XG4gICAgICB9LFxuICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiAxMDAwXG4gICAgfSk7XG4gIH07XG4gIFxuXG4gIC8vIExvYWQgY2FsaWJyYXRpb24gc2V0dXBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcblxuICAgIGNvbnN0IHNldHVwQ2FsaWJyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHQ6IENhbGlicmF0ZUhhbmRsZXIgfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyJyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW52YXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgc2V0dXBDYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIG1ha2VDYW52YXNGdWxsc2NyZWVuKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NhbnZhcyBzaXplOicsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0dlbmVyYXRlZCBjYWxpYnJhdGlvbiBwb2ludHM6JywgcG9pbnRzKTtcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25Qb2ludHMocG9pbnRzKTtcbiAgICBcbiAgICAgICAgY29uc3QgY2FsaWJyYXRlSGFuZGxlciA9IG5ldyBDYWxpYnJhdGVIYW5kbGVyKHtcbiAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgY2FsaWJyYXRpb25Qb2ludHM6IHBvaW50cyxcbiAgICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiBvbkFjdGlvbkNsaWNrPy4oJ3RvZ2dsZVRvcEJhcicsIHNob3cpLFxuICAgICAgICAgIHNldE91dHB1dFRleHQ6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudGVyOiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld0NvdW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KHByZXYgPT4gbmV3Q291bnRlcihwcmV2KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQobmV3Q291bnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyxcbiAgICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgICAgICBzZXRDYWxpYnJhdGlvbkhhbmRsZXIoe1xuICAgICAgICAgIGhhbmRsZUFjdGlvbjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbi4uLicpO1xuICAgICAgICAgICAgYXdhaXQgY2FsaWJyYXRlSGFuZGxlci5zdGFydENhbGlicmF0aW9uKCk7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgIHJlc3RvcmVDYW52YXNTaXplKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbml0aWFsaXppbmcgY2FsaWJyYXRpb246JywgZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0dXBDYWxpYnJhdGlvbigpO1xuICB9LCBbY2FwdHVyZUNvdW50LCBvbkFjdGlvbkNsaWNrXSk7XG4gIFxuICAvLyBDbGVhciBBbGwgQnV0dG9uIC0gUmVzZXQgZXZlcnl0aGluZ1xuICBjb25zdCBoYW5kbGVDbGVhckFsbCA9ICgpID0+IHtcbiAgICBjbGVhckNhbnZhcygpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSBIZWFkIFBvc2UgdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVIZWFkUG9zZSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdIZWFkUG9zZVN0YXRlID0gIXNob3dIZWFkUG9zZTtcbiAgICBzZXRTaG93SGVhZFBvc2UobmV3SGVhZFBvc2VTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgSGVhZCBwb3NlIHZpc3VhbGl6YXRpb24gJHtuZXdIZWFkUG9zZVN0YXRlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnaGVhZFBvc2UnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93SGVhZFBvc2U6IG5ld0hlYWRQb3NlU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBoZWFkIHBvc2U6ICR7bmV3SGVhZFBvc2VTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEJvdW5kaW5nIEJveCB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94ID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0JvdW5kaW5nQm94U3RhdGUgPSAhc2hvd0JvdW5kaW5nQm94O1xuICAgIHNldFNob3dCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveFN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBCb3VuZGluZyBib3ggJHtuZXdCb3VuZGluZ0JveFN0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdib3VuZGluZ0JveCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dCb3VuZGluZ0JveDogbmV3Qm91bmRpbmdCb3hTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGJvdW5kaW5nIGJveDogJHtuZXdCb3VuZGluZ0JveFN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgTWFzayB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZU1hc2sgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFza1N0YXRlID0gIXNob3dNYXNrO1xuICAgIHNldFNob3dNYXNrKG5ld01hc2tTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgTWFzayAke25ld01hc2tTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnbWFzaycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dNYXNrOiBuZXdNYXNrU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBtYXNrOiAke25ld01hc2tTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIFBhcmFtZXRlcnMgZGlzcGxheVxuICBjb25zdCBoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld1BhcmFtZXRlcnNTdGF0ZSA9ICFzaG93UGFyYW1ldGVycztcbiAgICBzZXRTaG93UGFyYW1ldGVycyhuZXdQYXJhbWV0ZXJzU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYFBhcmFtZXRlcnMgJHtuZXdQYXJhbWV0ZXJzU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3BhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93UGFyYW1ldGVyczogbmV3UGFyYW1ldGVyc1N0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgcGFyYW1ldGVyczogJHtuZXdQYXJhbWV0ZXJzU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBjYW1lcmEgcHJldmlld1xuICBjb25zdCBoYW5kbGVUb2dnbGVDYW1lcmEgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Q2FtZXJhU3RhdGUgPSAhaXNDYW1lcmFBY3RpdmU7XG4gICAgc2V0SXNDYW1lcmFBY3RpdmUobmV3Q2FtZXJhU3RhdGUpO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHdpdGggJ3ByZXZpZXcnIGFjdGlvblxuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdwcmV2aWV3JywgbmV3Q2FtZXJhU3RhdGUpOyAvLyBQYXNzIHRoZSBuZXcgc3RhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IHRyaWdnZXIgaWYgbm8gYWN0aW9uIGhhbmRsZXJcbiAgICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHR1cm5pbmcgb24gY2FtZXJhLCBlbnN1cmUgd2UgYXBwbHkgY3VycmVudCB2aXN1YWxpemF0aW9uIHNldHRpbmdzXG4gICAgaWYgKG5ld0NhbWVyYVN0YXRlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgLy8gV2FpdCBhIHNob3J0IG1vbWVudCB0byBlbnN1cmUgdGhlIHZpZGVvIGVsZW1lbnQgaXMgcmVhZHlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgc2hvd0hlYWRQb3NlLFxuICAgICAgICAgICAgc2hvd0JvdW5kaW5nQm94LFxuICAgICAgICAgICAgc2hvd01hc2ssXG4gICAgICAgICAgICBzaG93UGFyYW1ldGVyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYmFjayBidXR0b24gaGFuZGxlclxuICBjb25zdCBoYW5kbGVHb0JhY2sgPSAoKSA9PiB7XG4gICAgcm91dGVyLnB1c2goJy8nKTtcbiAgfTtcblxuICAvLyBNb2JpbGUgbGF5b3V0IC0gMng1IGdyaWRcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAge2lzQ29tcGFjdE1vZGUgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMiBtYi00XCI+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTJcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIHsvKiBTdGF0dXMgZGlzcGxheSB3aXRoIG1lbW9pemF0aW9uICovfVxuICAgICAge3VzZU1lbW8oKCkgPT4gKFxuICAgICAgICAocHJvY2Vzc1N0YXR1cyB8fCByZW1haW5pbmdDYXB0dXJlcyA+IDAgfHwgY291bnRkb3duVmFsdWUpICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN0YXR1cy1kaXNwbGF5IG10LTQgcC0yIGJnLWJsdWUtNTAgcm91bmRlZC1tZFwiPlxuICAgICAgICAgICAge3Byb2Nlc3NTdGF0dXMgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1ibHVlLTgwMFwiPntwcm9jZXNzU3RhdHVzfTwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtyZW1haW5pbmdDYXB0dXJlcyA+IDAgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gZm9udC1tZWRpdW0gdGV4dC15ZWxsb3ctNjAwXCI+UmVtYWluaW5nOiB7cmVtYWluaW5nQ2FwdHVyZXN9PC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2NvdW50ZG93blZhbHVlICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC1yZWQtNjAwXCI+e2NvdW50ZG93blZhbHVlfTwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKVxuICAgICAgKSwgW3Byb2Nlc3NTdGF0dXMsIHJlbWFpbmluZ0NhcHR1cmVzLCBjb3VudGRvd25WYWx1ZV0pfVxuICAgICAgXG4gICAgICB7LyogQ2FudmFzIGZvciBkcmF3aW5nIGRvdHMgKi99XG4gICAgICB7c2hvd0NhbnZhcyAmJiAoXG4gICAgICAgIDxkaXYgXG4gICAgICAgICAgY2xhc3NOYW1lPVwiY2FudmFzLWNvbnRhaW5lciBtdC00XCIgXG4gICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICc0MHZoJyxcbiAgICAgICAgICAgIG1pbkhlaWdodDogJzMwMHB4JyxcbiAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjZTBlMGUwJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGNhbnZhcyBcbiAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidHJhY2tpbmctY2FudmFzXCJcbiAgICAgICAgICAgIGlkPVwidHJhY2tpbmctY2FudmFzXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgIGRpc3BsYXk6ICdibG9jaycgLy8gRW5zdXJlIGNhbnZhcyBpcyBkaXNwbGF5ZWQgYXMgYmxvY2tcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBvbkxvYWQ9eyhlKSA9PiB7XG4gICAgICAgICAgICAgIC8vIEluaXRpYWxpemUgY2FudmFzIHdoZW4gaXQgbG9hZHNcbiAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZS50YXJnZXQ7XG4gICAgICAgICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogT3ZlcmxheSBmb3IgY291bnRkb3duIG9uIGRvdCAqL31cbiAgICAgICAgICB7Y291bnRkb3duVmFsdWUgJiYgY3VycmVudERvdCAmJiAoXG4gICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJkb3QtY291bnRkb3duXCJcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICBsZWZ0OiBgJHtjdXJyZW50RG90LnggLSAxNX1weGAsXG4gICAgICAgICAgICAgICAgdG9wOiBgJHtjdXJyZW50RG90LnkgLSA0MH1weGAsXG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMjhweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIFxuICAgICAgey8qIENhbWVyYSBQZXJtaXNzaW9uIFBvcHVwICovfVxuICAgICAge3Nob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMTVcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWRpYWxvZ1wiIFxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aDMgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDE1cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENhbWVyYSBBY2Nlc3MgUmVxdWlyZWRcbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tbWVzc2FnZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICBnYXA6ICcxMHB4J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7XG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFxuICBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiA8QWN0aW9uQnV0dG9uR3JvdXBJbm5lciB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPilcbiksIHsgc3NyOiBmYWxzZSB9KTtcbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgQWN0aW9uQnV0dG9uR3JvdXBcbi8vIGNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoQWN0aW9uQnV0dG9uR3JvdXBJbm5lciksIHsgc3NyOiBmYWxzZSB9KTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWN0aW9uQnV0dG9uUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59XG5cbmV4cG9ydCB7IEFjdGlvbkJ1dHRvbiwgQWN0aW9uQnV0dG9uR3JvdXAgfTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImR5bmFtaWMiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInJ1bkNvdW50ZG93biIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwidXNlUm91dGVyIiwidXNlQWRtaW5TZXR0aW5ncyIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsIkFjdGlvbkJ1dHRvbiIsInRleHQiLCJhYmJyZXZpYXRlZFRleHQiLCJvbkNsaWNrIiwiY3VzdG9tQ2xhc3MiLCJkaXNhYmxlZCIsImFjdGl2ZSIsImlzQWJicmV2aWF0ZWQiLCJzZXRJc0FiYnJldmlhdGVkIiwic2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJidXR0b25Qcm9wcyIsImNsYXNzTmFtZSIsInRpdGxlIiwidGltZW91dElkIiwiaGFuZGxlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJ0eXBlIiwibmV3VXNlcklkIiwidXNlcklkIiwiYnV0dG9uIiwiZGl2IiwiQWN0aW9uQnV0dG9uR3JvdXBJbm5lciIsInJlZiIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsInJvdXRlciIsInVwZGF0ZVNldHRpbmdzIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbnZhc1JlZiIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJjdXJyZW50Q2FsaWJyYXRpb25JbmRleCIsInNldEN1cnJlbnRDYWxpYnJhdGlvbkluZGV4IiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzZXRSZW1haW5pbmdDYXB0dXJlcyIsInNob3dDYW52YXMiLCJzZXRTaG93Q2FudmFzIiwiY2FsaWJyYXRpb25IYW5kbGVyIiwic2V0Q2FsaWJyYXRpb25IYW5kbGVyIiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0hlYWRQb3NlIiwic2V0U2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2V0U2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzZXRTaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2V0U2hvd1BhcmFtZXRlcnMiLCJpc0NhbWVyYUFjdGl2ZSIsInNldElzQ2FtZXJhQWN0aXZlIiwic2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldFNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXR0aW5nc0NhY2hlIiwiTWFwIiwibGFzdFNldHRpbmdzVXBkYXRlIiwiYnV0dG9ucyIsImhhbmRsZVNldFJhbmRvbSIsImhhbmRsZVJhbmRvbURvdCIsImhhbmRsZVNldENhbGlicmF0ZSIsImhhbmRsZUNsZWFyQWxsIiwiZGl2aWRlciIsImhhbmRsZVRvZ2dsZUhlYWRQb3NlIiwiaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3giLCJoYW5kbGVUb2dnbGVDYW1lcmEiLCJoYW5kbGVUb2dnbGVNYXNrIiwiaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyIsInVzZXJTZXR0aW5ncyIsImNhY2hlZFNldHRpbmdzIiwiY3VycmVudCIsImdldCIsIk51bWJlciIsInRpbWVzIiwiZGVsYXkiLCJzZXQiLCJEYXRlIiwibm93IiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJ1bmRlZmluZWQiLCJuZXdUaW1lcyIsIm5ld0RlbGF5IiwiYWN0aW9uQnV0dG9uRnVuY3Rpb25zIiwidXBkYXRlQ29udHJvbFZhbHVlcyIsInRpbWVJbnB1dCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInRpbWVWYWx1ZSIsInBhcnNlSW50IiwidmFsdWUiLCJpc05hTiIsImNvbnNvbGUiLCJsb2ciLCJkZWxheUlucHV0IiwiZGVsYXlWYWx1ZSIsImluaXRpYWxpemVDYW52YXMiLCJjYW52YXMiLCJwYXJlbnQiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImVycm9yIiwiZ2V0TWFpbkNhbnZhcyIsIndoaXRlU2NyZWVuQ2FudmFzIiwic2VsZWN0b3JzIiwic2VsZWN0b3IiLCJjYW52YXNFbGVtZW50IiwibWFrZUNhbnZhc0Z1bGxzY3JlZW4iLCJwYXJlbnRFbGVtZW50IiwiYm9keSIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiekluZGV4IiwiaW5uZXJIZWlnaHQiLCJyZXN0b3JlQ2FudmFzU2l6ZSIsImhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCIsImhhbmRsZVBlcm1pc3Npb25EZW5pZWQiLCJyZXN0b3JlQ2FudmFzIiwib3JpZ2luYWxQYXJlbnQiLCJvcmlnaW5hbFN0eWxlIiwiYXBwZW5kQ2hpbGQiLCJjbGVhckNhbnZhcyIsIndhcm4iLCJoYW5kbGVEb3RQcm9jZXNzIiwib3B0aW9ucyIsIm9uU3RhdHVzVXBkYXRlIiwidG9nZ2xlVG9wQmFyIiwidXNlUmFuZG9tUG9zaXRpb24iLCJwb3N0Q291bnRkb3duRGVsYXkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJldHJ5Q291bnQiLCJtYXhSZXRyaWVzIiwiRXJyb3IiLCJjYW52YXNXaWR0aCIsImNhbnZhc0hlaWdodCIsImRvdFBvc2l0aW9uIiwieCIsInkiLCJkb3RSYWRpdXMiLCJrZWVwRG90VmlzaWJsZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJleGlzdGluZ0NvdW50ZG93bnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjc3NUZXh0IiwiY291bnQiLCJ0ZXh0Q29udGVudCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsImNsZWFySW50ZXJ2YWwiLCJzdWNjZXNzIiwibWVzc2FnZSIsIm9yaWdpbmFsQ2FudmFzUGFyZW50Iiwib3JpZ2luYWxDYW52YXNTdHlsZSIsInN0YXR1c0luZGljYXRvciIsImN1cnJlbnRSZWRyYXdJbnRlcnZhbCIsInBvaW50cyIsInN1Y2Nlc3NDb3VudCIsImkiLCJyYWRpdXMiLCJyZWRyYXdDdXJyZW50RG90Iiwic2NyZWVuSW1hZ2UiLCJwb3NzaWJsZVBhcmVudCIsImUiLCJjdXJyZW50SW5kZXgiLCJyZXN1bHQiLCJzdGF0dXMiLCJzaG93IiwiY2FwdHVyaW5nIiwic2V0dXBDYWxpYnJhdGlvbiIsImRlZmF1bHQiLCJDYWxpYnJhdGVIYW5kbGVyIiwiY2FsaWJyYXRlSGFuZGxlciIsInNldE91dHB1dFRleHQiLCJuZXdDb3VudGVyIiwicHJldiIsImNhcHR1cmVGb2xkZXIiLCJvbkNvbXBsZXRlIiwiaGFuZGxlQWN0aW9uIiwic3RhcnRDYWxpYnJhdGlvbiIsImVyciIsIm5ld0hlYWRQb3NlU3RhdGUiLCJ2aWRlb1Byb2Nlc3NvciIsInVwZGF0ZU9wdGlvbnMiLCJuZXdCb3VuZGluZ0JveFN0YXRlIiwibmV3TWFza1N0YXRlIiwibmV3UGFyYW1ldGVyc1N0YXRlIiwibmV3Q2FtZXJhU3RhdGUiLCJoYW5kbGVHb0JhY2siLCJwdXNoIiwibWluSGVpZ2h0IiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyUmFkaXVzIiwib3ZlcmZsb3ciLCJpZCIsImRpc3BsYXkiLCJvbkxvYWQiLCJ0YXJnZXQiLCJjb2xvciIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJoMyIsIm1hcmdpbiIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiY3Vyc29yIiwiQWN0aW9uQnV0dG9uR3JvdXAiLCJwcm9wcyIsInNzciIsIkFjdGlvbkJ1dHRvblBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js":
/*!****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/adminSettings.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ AdminSettings),\n/* harmony export */   useAdminSettings: () => (/* binding */ useAdminSettings)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\nvar _s = $RefreshSig$();\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Add debounce utility\nconst debounce = (func, wait)=>{\n    let timeout;\n    return function executedFunction() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        const later = ()=>{\n            clearTimeout(timeout);\n            func(...args);\n        };\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n    };\n};\n// Helper function to safely access localStorage\nconst getLocalStorage = (key)=>{\n    if (false) {}\n    try {\n        return localStorage.getItem(key);\n    } catch (error) {\n        console.warn('Error accessing localStorage:', error);\n        return null;\n    }\n};\n// Helper function to safely set localStorage\nconst setLocalStorage = (key, value)=>{\n    if (false) {}\n    try {\n        localStorage.setItem(key, value);\n    } catch (error) {\n        console.warn('Error setting localStorage:', error);\n    }\n};\nconst useAdminSettings = (ref)=>{\n    _s();\n    const [settings, setSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        \"useAdminSettings.useState\": ()=>{\n            // Initialize from localStorage on mount, safely\n            return getLocalStorage('currentUserId');\n        }\n    }[\"useAdminSettings.useState\"]);\n    const [isTopBarUpdated, setIsTopBarUpdated] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const initialized = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const pollingInterval = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [lastUpdateTime, setLastUpdateTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    // Constants for timing\n    const MIN_UPDATE_INTERVAL = 2000; // 2 seconds minimum between updates\n    const CACHE_DURATION = 30000; // 30 seconds cache duration\n    const POLLING_INTERVAL = 5000; // 5 seconds polling interval\n    // Cache and state tracking\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const pendingUpdates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    const isUpdating = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const lastKnownSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Map());\n    // Debug logging for settings changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            console.log('AdminSettings - Current Settings:', settings);\n            console.log('AdminSettings - Current User ID:', currentUserId);\n            console.log('AdminSettings - Is TopBar Updated:', isTopBarUpdated);\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId,\n        isTopBarUpdated\n    ]);\n    // Helper: Fetch settings for a user from backend with enhanced caching\n    const fetchSettingsForUser = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAdminSettings.useCallback[fetchSettingsForUser]\": async (userId)=>{\n            if (!userId) return;\n            // Check cache first\n            const cachedSettings = settingsCache.current.get(userId);\n            const lastUpdate = lastSettingsUpdate.current.get(userId);\n            const now = Date.now();\n            // If we have cached settings and they're recent enough, use them\n            if (cachedSettings && lastUpdate && now - lastUpdate < CACHE_DURATION) {\n                console.log('[AdminSettings] Using cached settings for user:', userId);\n                return cachedSettings;\n            }\n            // If there's already a pending update, return the cached value\n            if (pendingUpdates.current.has(userId)) {\n                console.log('[AdminSettings] Pending update exists, using cached value');\n                return cachedSettings;\n            }\n            // If an update is in progress, return the cached value\n            if (isUpdating.current) {\n                console.log('[AdminSettings] Update in progress, using cached value');\n                return cachedSettings;\n            }\n            try {\n                isUpdating.current = true;\n                pendingUpdates.current.set(userId, true);\n                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json',\n                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                    }\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch({\n                        \"useAdminSettings.useCallback[fetchSettingsForUser]\": ()=>({})\n                    }[\"useAdminSettings.useCallback[fetchSettingsForUser]\"]);\n                    throw new Error(errorData.detail || 'Failed to fetch settings');\n                }\n                const result = await response.json();\n                const newSettings = result.data || {};\n                // Compare with last known settings\n                const lastKnown = lastKnownSettings.current.get(userId);\n                const hasChanged = !isEqual(lastKnown, newSettings);\n                if (hasChanged) {\n                    console.log('[AdminSettings] Settings changed, updating...');\n                    setSettings({\n                        \"useAdminSettings.useCallback[fetchSettingsForUser]\": (prev)=>({\n                                ...prev,\n                                [userId]: newSettings\n                            })\n                    }[\"useAdminSettings.useCallback[fetchSettingsForUser]\"]);\n                    setCurrentSettings(newSettings);\n                    // Update caches\n                    settingsCache.current.set(userId, newSettings);\n                    lastSettingsUpdate.current.set(userId, now);\n                    lastKnownSettings.current.set(userId, newSettings);\n                    // Update TopBar if ref provided\n                    if (ref && ref.current && ref.current.setCaptureSettings) {\n                        ref.current.setCaptureSettings(newSettings);\n                        setIsTopBarUpdated(true);\n                    }\n                } else {\n                    console.log('[AdminSettings] Settings unchanged, skipping update');\n                }\n                setError(null);\n                return newSettings;\n            } catch (error) {\n                console.error('[AdminSettings] Error fetching settings:', error);\n                setError(error.message);\n                return cachedSettings; // Return cached settings on error\n            } finally{\n                isUpdating.current = false;\n                pendingUpdates.current.delete(userId);\n            }\n        }\n    }[\"useAdminSettings.useCallback[fetchSettingsForUser]\"], [\n        ref\n    ]);\n    // Debounced version of fetchSettingsForUser\n    const debouncedFetchSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(debounce({\n        \"useAdminSettings.useCallback[debouncedFetchSettings]\": (userId)=>{\n            fetchSettingsForUser(userId);\n        }\n    }[\"useAdminSettings.useCallback[debouncedFetchSettings]\"], 1000), [\n        fetchSettingsForUser\n    ]);\n    // Polling for settings updates with value-based optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (!currentUserId) return;\n            const fetchSettings = {\n                \"useAdminSettings.useEffect.fetchSettings\": async ()=>{\n                    const now = Date.now();\n                    if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                        return;\n                    }\n                    try {\n                        await debouncedFetchSettings(currentUserId);\n                        setLastUpdateTime(now);\n                    } catch (error) {\n                        console.error('[AdminSettings] Polling error:', error);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.fetchSettings\"];\n            // Initial fetch\n            fetchSettings();\n            // Set up polling with value-based interval\n            pollingInterval.current = setInterval(fetchSettings, POLLING_INTERVAL);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>{\n                    if (pollingInterval.current) {\n                        clearInterval(pollingInterval.current);\n                    }\n                }\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        lastUpdateTime,\n        debouncedFetchSettings\n    ]);\n    // Listen for userId changes (from index.js navigation)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"useAdminSettings.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.userId) {\n                        console.log('[handleUserIdChange] userId:', event.detail.userId);\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        setLocalStorage('currentUserId', newUserId);\n                        fetchSettingsForUser(newUserId);\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        ref\n    ]);\n    // Initial settings fetch on mount if we have a user ID\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (currentUserId && !initialized.current) {\n                fetchSettingsForUser(currentUserId);\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId\n    ]);\n    // Effect to handle index.js update after TopBar is updated\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (isTopBarUpdated) {\n                const event = new CustomEvent('settingsUpdated', {\n                    detail: {\n                        type: 'settings',\n                        userId: currentUserId,\n                        settings: settings[currentUserId]\n                    }\n                });\n                window.dispatchEvent(event);\n                setIsTopBarUpdated(false);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        isTopBarUpdated,\n        currentUserId,\n        settings\n    ]);\n    // Load settings from localStorage on mount (optional, fallback)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            try {\n                const savedSettings = getLocalStorage('adminSettings');\n                if (savedSettings) {\n                    const parsedSettings = JSON.parse(savedSettings);\n                    setSettings(parsedSettings);\n                }\n            } catch (error) {\n                console.warn('Error loading settings from localStorage:', error);\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], []);\n    // Save settings to localStorage when they change (optional)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (initialized.current) {\n                try {\n                    setLocalStorage('adminSettings', JSON.stringify(settings));\n                } catch (error) {\n                    console.warn('Error saving settings to localStorage:', error);\n                }\n            } else {\n                initialized.current = true;\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings\n    ]);\n    // Update settings when they change in the context\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            if (settings && currentUserId) {\n                console.log('[settings useEffect] currentUserId:', currentUserId); // Debug log\n                const userSettings = settings[currentUserId];\n                if (userSettings) {\n                    setCurrentSettings(userSettings);\n                // Optionally update UI elements if needed\n                }\n            }\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for settings updates from admin page (captureSettingsUpdate event)\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAdminSettings.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"useAdminSettings.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        console.log('[handleSettingsUpdate] userId:', userId, 'currentUserId:', currentUserId); // Debug log\n                        if (userId === currentUserId) {\n                            const newSettings = {\n                                ...currentSettings,\n                                times: times !== undefined ? Number(times) : currentSettings.times,\n                                delay: delay !== undefined ? Number(delay) : currentSettings.delay\n                            };\n                            setCurrentSettings(newSettings);\n                            setSettings({\n                                \"useAdminSettings.useEffect.handleSettingsUpdate\": (prev)=>({\n                                        ...prev,\n                                        [userId]: newSettings\n                                    })\n                            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"]);\n                            updateSettings(newSettings, userId);\n                        }\n                    }\n                }\n            }[\"useAdminSettings.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"useAdminSettings.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"useAdminSettings.useEffect\"];\n        }\n    }[\"useAdminSettings.useEffect\"], [\n        currentUserId,\n        currentSettings\n    ]);\n    // Update settings for a user with value-based optimization\n    const updateSettings = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useAdminSettings.useCallback[updateSettings]\": async (newSettings, userId)=>{\n            if (!userId) return;\n            const now = Date.now();\n            if (now - lastUpdateTime < MIN_UPDATE_INTERVAL) {\n                console.log('[updateSettings] Skipping update - too soon after last update');\n                return;\n            }\n            const updatedSettings = {\n                ...settings[userId],\n                ...newSettings\n            };\n            // Compare with last known settings\n            const lastKnown = lastKnownSettings.current.get(userId);\n            const hasChanged = !isEqual(lastKnown, updatedSettings);\n            if (!hasChanged) {\n                console.log('[updateSettings] Settings unchanged, skipping update');\n                return;\n            }\n            try {\n                isUpdating.current = true;\n                pendingUpdates.current.set(userId, true);\n                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                    },\n                    body: JSON.stringify(updatedSettings)\n                });\n                if (!response.ok) {\n                    const errorData = await response.json().catch({\n                        \"useAdminSettings.useCallback[updateSettings]\": ()=>({})\n                    }[\"useAdminSettings.useCallback[updateSettings]\"]);\n                    throw new Error(errorData.detail || 'Failed to save settings');\n                }\n                const result = await response.json();\n                const finalSettings = result.data || updatedSettings;\n                // Update state and caches\n                setSettings({\n                    \"useAdminSettings.useCallback[updateSettings]\": (prev)=>({\n                            ...prev,\n                            [userId]: finalSettings\n                        })\n                }[\"useAdminSettings.useCallback[updateSettings]\"]);\n                setCurrentSettings(finalSettings);\n                settingsCache.current.set(userId, finalSettings);\n                lastSettingsUpdate.current.set(userId, now);\n                lastKnownSettings.current.set(userId, finalSettings);\n                setLastUpdateTime(now);\n                setError(null);\n            } catch (error) {\n                setError(error.message);\n            } finally{\n                isUpdating.current = false;\n                pendingUpdates.current.delete(userId);\n            }\n        }\n    }[\"useAdminSettings.useCallback[updateSettings]\"], [\n        settings,\n        lastUpdateTime\n    ]);\n    // Upload and update image for a user\n    const updateImage = async (userId, base64Image)=>{\n        console.log('[updateImage] userId:', userId); // Debug log\n        if (!userId || !base64Image) return;\n        try {\n            const response = await fetch(\"/api/data-center/image?user_id=\".concat(userId), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                },\n                body: JSON.stringify({\n                    image: base64Image\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json().catch(()=>({}));\n                throw new Error(errorData.detail || 'Failed to upload image');\n            }\n            // Optionally, fetch settings again to get updated image info\n            await fetchSettingsForUser(userId);\n            setError(null);\n            return true;\n        } catch (error) {\n            setError(error.message);\n            return false;\n        }\n    };\n    return {\n        settings,\n        currentSettings,\n        currentUserId,\n        error,\n        updateSettings: fetchSettingsForUser\n    };\n};\n_s(useAdminSettings, \"HR1aFfgBiUAZ7ZTKtNm9Y6L9tLc=\");\n// Add default export component\nfunction AdminSettings() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c = AdminSettings;\nvar _c;\n$RefreshReg$(_c, \"AdminSettings\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUU7QUFFakUsOEJBQThCO0FBQzlCLE1BQU1JLFVBQVUsQ0FBQ0MsTUFBTUM7SUFDckIsSUFBSUQsU0FBU0MsTUFBTSxPQUFPO0lBQzFCLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9DLFNBQVMsVUFBVSxPQUFPO0lBQ2pFLElBQUlELFNBQVMsUUFBUUMsU0FBUyxNQUFNLE9BQU87SUFFM0MsTUFBTUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSjtJQUMxQixNQUFNSyxRQUFRRixPQUFPQyxJQUFJLENBQUNIO0lBRTFCLElBQUlDLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFLE9BQU87SUFFMUMsT0FBT0osTUFBTUssS0FBSyxDQUFDQyxDQUFBQSxNQUNqQkgsTUFBTUksUUFBUSxDQUFDRCxRQUFRVCxRQUFRQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO0FBRXZEO0FBRUEsdUJBQXVCO0FBQ3ZCLE1BQU1FLFdBQVcsQ0FBQ0MsTUFBTUM7SUFDdEIsSUFBSUM7SUFDSixPQUFPLFNBQVNDO1FBQWlCO1lBQUdDLEtBQUgsdUJBQU87O1FBQ3RDLE1BQU1DLFFBQVE7WUFDWkMsYUFBYUo7WUFDYkYsUUFBUUk7UUFDVjtRQUNBRSxhQUFhSjtRQUNiQSxVQUFVSyxXQUFXRixPQUFPSjtJQUM5QjtBQUNGO0FBRUEsZ0RBQWdEO0FBQ2hELE1BQU1PLGtCQUFrQixDQUFDWDtJQUN2QixJQUFJLEtBQTZCLEVBQUUsRUFBWTtJQUMvQyxJQUFJO1FBQ0YsT0FBT1ksYUFBYUMsT0FBTyxDQUFDYjtJQUM5QixFQUFFLE9BQU9jLE9BQU87UUFDZEMsUUFBUUMsSUFBSSxDQUFDLGlDQUFpQ0Y7UUFDOUMsT0FBTztJQUNUO0FBQ0Y7QUFFQSw2Q0FB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S0FBS0UsU0FBUyxDQUFDO29CQUFFYyxPQUFPRDtnQkFBWTtZQUM1QztZQUNBLElBQUksQ0FBQ25ELFNBQVNNLEVBQUUsRUFBRTtnQkFDaEIsTUFBTUMsWUFBWSxNQUFNUCxTQUFTUSxJQUFJLEdBQUdDLEtBQUssQ0FBQyxJQUFPLEVBQUM7Z0JBQ3RELE1BQU0sSUFBSUMsTUFBTUgsVUFBVUksTUFBTSxJQUFJO1lBQ3RDO1lBQ0EsNkRBQTZEO1lBQzdELE1BQU1yQixxQkFBcUJDO1lBQzNCbEIsU0FBUztZQUNULE9BQU87UUFDVCxFQUFFLE9BQU9kLE9BQU87WUFDZGMsU0FBU2QsTUFBTTRELE9BQU87WUFDdEIsT0FBTztRQUNUO0lBQ0Y7SUFFQSxPQUFPO1FBQ0xwRDtRQUNBUztRQUNBUDtRQUNBVjtRQUNBc0YsZ0JBQWdCdkQ7SUFDbEI7QUFDRixFQUFFO0dBN1ZXekI7QUErVmIsK0JBQStCO0FBQ2hCLFNBQVN3RjtJQUN0QixPQUFPLE1BQU0sOERBQThEO0FBQzdFO0tBRndCQSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWRtaW5TZXR0aW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuLy8gQWRkIGRlYm91bmNlIHV0aWxpdHlcbmNvbnN0IGRlYm91bmNlID0gKGZ1bmMsIHdhaXQpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiBleGVjdXRlZEZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBsYXRlciA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgfTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICB9O1xufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhZmVseSBhY2Nlc3MgbG9jYWxTdG9yYWdlXG5jb25zdCBnZXRMb2NhbFN0b3JhZ2UgPSAoa2V5KSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuIG51bGw7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdFcnJvciBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHNhZmVseSBzZXQgbG9jYWxTdG9yYWdlXG5jb25zdCBzZXRMb2NhbFN0b3JhZ2UgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHNldHRpbmcgbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHVzZUFkbWluU2V0dGluZ3MgPSAocmVmKSA9PiB7XG4gIGNvbnN0IFtzZXR0aW5ncywgc2V0U2V0dGluZ3NdID0gdXNlU3RhdGUoe30pO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgoKSA9PiB7XG4gICAgLy8gSW5pdGlhbGl6ZSBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudCwgc2FmZWx5XG4gICAgcmV0dXJuIGdldExvY2FsU3RvcmFnZSgnY3VycmVudFVzZXJJZCcpO1xuICB9KTtcbiAgY29uc3QgW2lzVG9wQmFyVXBkYXRlZCwgc2V0SXNUb3BCYXJVcGRhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50U2V0dGluZ3MsIHNldEN1cnJlbnRTZXR0aW5nc10gPSB1c2VTdGF0ZSh7fSk7XG4gIGNvbnN0IFtsYXN0VXBkYXRlVGltZSwgc2V0TGFzdFVwZGF0ZVRpbWVdID0gdXNlU3RhdGUoMCk7XG4gIFxuICAvLyBDb25zdGFudHMgZm9yIHRpbWluZ1xuICBjb25zdCBNSU5fVVBEQVRFX0lOVEVSVkFMID0gMjAwMDsgLy8gMiBzZWNvbmRzIG1pbmltdW0gYmV0d2VlbiB1cGRhdGVzXG4gIGNvbnN0IENBQ0hFX0RVUkFUSU9OID0gMzAwMDA7IC8vIDMwIHNlY29uZHMgY2FjaGUgZHVyYXRpb25cbiAgY29uc3QgUE9MTElOR19JTlRFUlZBTCA9IDUwMDA7IC8vIDUgc2Vjb25kcyBwb2xsaW5nIGludGVydmFsXG4gIFxuICAvLyBDYWNoZSBhbmQgc3RhdGUgdHJhY2tpbmdcbiAgY29uc3Qgc2V0dGluZ3NDYWNoZSA9IHVzZVJlZihuZXcgTWFwKCkpO1xuICBjb25zdCBsYXN0U2V0dGluZ3NVcGRhdGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgcGVuZGluZ1VwZGF0ZXMgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgaXNVcGRhdGluZyA9IHVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGxhc3RLbm93blNldHRpbmdzID0gdXNlUmVmKG5ldyBNYXAoKSk7XG5cbiAgLy8gRGVidWcgbG9nZ2luZyBmb3Igc2V0dGluZ3MgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdBZG1pblNldHRpbmdzIC0gQ3VycmVudCBTZXR0aW5nczonLCBzZXR0aW5ncyk7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBDdXJyZW50IFVzZXIgSUQ6JywgY3VycmVudFVzZXJJZCk7XG4gICAgY29uc29sZS5sb2coJ0FkbWluU2V0dGluZ3MgLSBJcyBUb3BCYXIgVXBkYXRlZDonLCBpc1RvcEJhclVwZGF0ZWQpO1xuICB9LCBbc2V0dGluZ3MsIGN1cnJlbnRVc2VySWQsIGlzVG9wQmFyVXBkYXRlZF0pO1xuXG4gIC8vIEhlbHBlcjogRmV0Y2ggc2V0dGluZ3MgZm9yIGEgdXNlciBmcm9tIGJhY2tlbmQgd2l0aCBlbmhhbmNlZCBjYWNoaW5nXG4gIGNvbnN0IGZldGNoU2V0dGluZ3NGb3JVc2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgIGlmICghdXNlcklkKSByZXR1cm47XG5cbiAgICAvLyBDaGVjayBjYWNoZSBmaXJzdFxuICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldCh1c2VySWQpO1xuICAgIGNvbnN0IGxhc3RVcGRhdGUgPSBsYXN0U2V0dGluZ3NVcGRhdGUuY3VycmVudC5nZXQodXNlcklkKTtcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBjYWNoZWQgc2V0dGluZ3MgYW5kIHRoZXkncmUgcmVjZW50IGVub3VnaCwgdXNlIHRoZW1cbiAgICBpZiAoY2FjaGVkU2V0dGluZ3MgJiYgbGFzdFVwZGF0ZSAmJiAobm93IC0gbGFzdFVwZGF0ZSA8IENBQ0hFX0RVUkFUSU9OKSkge1xuICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBVc2luZyBjYWNoZWQgc2V0dGluZ3MgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICAgIHJldHVybiBjYWNoZWRTZXR0aW5ncztcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHVwZGF0ZSwgcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWVcbiAgICBpZiAocGVuZGluZ1VwZGF0ZXMuY3VycmVudC5oYXModXNlcklkKSkge1xuICAgICAgY29uc29sZS5sb2coJ1tBZG1pblNldHRpbmdzXSBQZW5kaW5nIHVwZGF0ZSBleGlzdHMsIHVzaW5nIGNhY2hlZCB2YWx1ZScpO1xuICAgICAgcmV0dXJuIGNhY2hlZFNldHRpbmdzO1xuICAgIH1cblxuICAgIC8vIElmIGFuIHVwZGF0ZSBpcyBpbiBwcm9ncmVzcywgcmV0dXJuIHRoZSBjYWNoZWQgdmFsdWVcbiAgICBpZiAoaXNVcGRhdGluZy5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIFVwZGF0ZSBpbiBwcm9ncmVzcywgdXNpbmcgY2FjaGVkIHZhbHVlJyk7XG4gICAgICByZXR1cm4gY2FjaGVkU2V0dGluZ3M7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzVXBkYXRpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICBwZW5kaW5nVXBkYXRlcy5jdXJyZW50LnNldCh1c2VySWQsIHRydWUpO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZmV0Y2ggc2V0dGluZ3MnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc3QgbmV3U2V0dGluZ3MgPSByZXN1bHQuZGF0YSB8fCB7fTtcbiAgICAgIFxuICAgICAgLy8gQ29tcGFyZSB3aXRoIGxhc3Qga25vd24gc2V0dGluZ3NcbiAgICAgIGNvbnN0IGxhc3RLbm93biA9IGxhc3RLbm93blNldHRpbmdzLmN1cnJlbnQuZ2V0KHVzZXJJZCk7XG4gICAgICBjb25zdCBoYXNDaGFuZ2VkID0gIWlzRXF1YWwobGFzdEtub3duLCBuZXdTZXR0aW5ncyk7XG4gICAgICBcbiAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbQWRtaW5TZXR0aW5nc10gU2V0dGluZ3MgY2hhbmdlZCwgdXBkYXRpbmcuLi4nKTtcbiAgICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgW3VzZXJJZF06IG5ld1NldHRpbmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBjYWNoZXNcbiAgICAgICAgc2V0dGluZ3NDYWNoZS5jdXJyZW50LnNldCh1c2VySWQsIG5ld1NldHRpbmdzKTtcbiAgICAgICAgbGFzdFNldHRpbmdzVXBkYXRlLmN1cnJlbnQuc2V0KHVzZXJJZCwgbm93KTtcbiAgICAgICAgbGFzdEtub3duU2V0dGluZ3MuY3VycmVudC5zZXQodXNlcklkLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgVG9wQmFyIGlmIHJlZiBwcm92aWRlZFxuICAgICAgICBpZiAocmVmICYmIHJlZi5jdXJyZW50ICYmIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncykge1xuICAgICAgICAgIHJlZi5jdXJyZW50LnNldENhcHR1cmVTZXR0aW5ncyhuZXdTZXR0aW5ncyk7XG4gICAgICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnW0FkbWluU2V0dGluZ3NdIFNldHRpbmdzIHVuY2hhbmdlZCwgc2tpcHBpbmcgdXBkYXRlJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgcmV0dXJuIG5ld1NldHRpbmdzO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbQWRtaW5TZXR0aW5nc10gRXJyb3IgZmV0Y2hpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgICByZXR1cm4gY2FjaGVkU2V0dGluZ3M7IC8vIFJldHVybiBjYWNoZWQgc2V0dGluZ3Mgb24gZXJyb3JcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNVcGRhdGluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBwZW5kaW5nVXBkYXRlcy5jdXJyZW50LmRlbGV0ZSh1c2VySWQpO1xuICAgIH1cbiAgfSwgW3JlZl0pO1xuXG4gIC8vIERlYm91bmNlZCB2ZXJzaW9uIG9mIGZldGNoU2V0dGluZ3NGb3JVc2VyXG4gIGNvbnN0IGRlYm91bmNlZEZldGNoU2V0dGluZ3MgPSB1c2VDYWxsYmFjayhcbiAgICBkZWJvdW5jZSgodXNlcklkKSA9PiB7XG4gICAgICBmZXRjaFNldHRpbmdzRm9yVXNlcih1c2VySWQpO1xuICAgIH0sIDEwMDApLFxuICAgIFtmZXRjaFNldHRpbmdzRm9yVXNlcl1cbiAgKTtcblxuICAvLyBQb2xsaW5nIGZvciBzZXR0aW5ncyB1cGRhdGVzIHdpdGggdmFsdWUtYmFzZWQgb3B0aW1pemF0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50VXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgZmV0Y2hTZXR0aW5ncyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gbGFzdFVwZGF0ZVRpbWUgPCBNSU5fVVBEQVRFX0lOVEVSVkFMKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZGVib3VuY2VkRmV0Y2hTZXR0aW5ncyhjdXJyZW50VXNlcklkKTtcbiAgICAgICAgc2V0TGFzdFVwZGF0ZVRpbWUobm93KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tBZG1pblNldHRpbmdzXSBQb2xsaW5nIGVycm9yOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSW5pdGlhbCBmZXRjaFxuICAgIGZldGNoU2V0dGluZ3MoKTtcbiAgICBcbiAgICAvLyBTZXQgdXAgcG9sbGluZyB3aXRoIHZhbHVlLWJhc2VkIGludGVydmFsXG4gICAgcG9sbGluZ0ludGVydmFsLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChmZXRjaFNldHRpbmdzLCBQT0xMSU5HX0lOVEVSVkFMKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHBvbGxpbmdJbnRlcnZhbC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocG9sbGluZ0ludGVydmFsLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkLCBsYXN0VXBkYXRlVGltZSwgZGVib3VuY2VkRmV0Y2hTZXR0aW5nc10pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlcklkIGNoYW5nZXMgKGZyb20gaW5kZXguanMgbmF2aWdhdGlvbilcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVVc2VySWRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnVzZXJJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVVzZXJJZENoYW5nZV0gdXNlcklkOicsIGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIHNldExvY2FsU3RvcmFnZSgnY3VycmVudFVzZXJJZCcsIG5ld1VzZXJJZCk7XG4gICAgICAgIGZldGNoU2V0dGluZ3NGb3JVc2VyKG5ld1VzZXJJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gIH0sIFtyZWZdKTtcblxuICAvLyBJbml0aWFsIHNldHRpbmdzIGZldGNoIG9uIG1vdW50IGlmIHdlIGhhdmUgYSB1c2VyIElEXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRVc2VySWQgJiYgIWluaXRpYWxpemVkLmN1cnJlbnQpIHtcbiAgICAgIGZldGNoU2V0dGluZ3NGb3JVc2VyKGN1cnJlbnRVc2VySWQpO1xuICAgICAgaW5pdGlhbGl6ZWQuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIEVmZmVjdCB0byBoYW5kbGUgaW5kZXguanMgdXBkYXRlIGFmdGVyIFRvcEJhciBpcyB1cGRhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzVG9wQmFyVXBkYXRlZCkge1xuICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ3NldHRpbmdzVXBkYXRlZCcsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgdHlwZTogJ3NldHRpbmdzJyxcbiAgICAgICAgICB1c2VySWQ6IGN1cnJlbnRVc2VySWQsXG4gICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgc2V0SXNUb3BCYXJVcGRhdGVkKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtpc1RvcEJhclVwZGF0ZWQsIGN1cnJlbnRVc2VySWQsIHNldHRpbmdzXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZSBvbiBtb3VudCAob3B0aW9uYWwsIGZhbGxiYWNrKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzYXZlZFNldHRpbmdzID0gZ2V0TG9jYWxTdG9yYWdlKCdhZG1pblNldHRpbmdzJyk7XG4gICAgICBpZiAoc2F2ZWRTZXR0aW5ncykge1xuICAgICAgICBjb25zdCBwYXJzZWRTZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2F2ZWRTZXR0aW5ncyk7XG4gICAgICAgIHNldFNldHRpbmdzKHBhcnNlZFNldHRpbmdzKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvciBsb2FkaW5nIHNldHRpbmdzIGZyb20gbG9jYWxTdG9yYWdlOicsIGVycm9yKTtcbiAgICB9XG4gIH0sIFtdKTtcblxuICAvLyBTYXZlIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZSB3aGVuIHRoZXkgY2hhbmdlIChvcHRpb25hbClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaW5pdGlhbGl6ZWQuY3VycmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0TG9jYWxTdG9yYWdlKCdhZG1pblNldHRpbmdzJywgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXJyb3Igc2F2aW5nIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZTonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXRpYWxpemVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gVXBkYXRlIHNldHRpbmdzIHdoZW4gdGhleSBjaGFuZ2UgaW4gdGhlIGNvbnRleHRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2V0dGluZ3MgJiYgY3VycmVudFVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1tzZXR0aW5ncyB1c2VFZmZlY3RdIGN1cnJlbnRVc2VySWQ6JywgY3VycmVudFVzZXJJZCk7IC8vIERlYnVnIGxvZ1xuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbY3VycmVudFVzZXJJZF07XG4gICAgICBpZiAodXNlclNldHRpbmdzKSB7XG4gICAgICAgIHNldEN1cnJlbnRTZXR0aW5ncyh1c2VyU2V0dGluZ3MpO1xuICAgICAgICAvLyBPcHRpb25hbGx5IHVwZGF0ZSBVSSBlbGVtZW50cyBpZiBuZWVkZWRcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3Igc2V0dGluZ3MgdXBkYXRlcyBmcm9tIGFkbWluIHBhZ2UgKGNhcHR1cmVTZXR0aW5nc1VwZGF0ZSBldmVudClcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzLCBkZWxheSB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICBjb25zb2xlLmxvZygnW2hhbmRsZVNldHRpbmdzVXBkYXRlXSB1c2VySWQ6JywgdXNlcklkLCAnY3VycmVudFVzZXJJZDonLCBjdXJyZW50VXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgICAgIGlmICh1c2VySWQgPT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBjb25zdCBuZXdTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIC4uLmN1cnJlbnRTZXR0aW5ncyxcbiAgICAgICAgICAgIHRpbWVzOiB0aW1lcyAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKHRpbWVzKSA6IGN1cnJlbnRTZXR0aW5ncy50aW1lcyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheSAhPT0gdW5kZWZpbmVkID8gTnVtYmVyKGRlbGF5KSA6IGN1cnJlbnRTZXR0aW5ncy5kZWxheVxuICAgICAgICAgIH07XG4gICAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKG5ld1NldHRpbmdzKTtcbiAgICAgICAgICBzZXRTZXR0aW5ncyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBuZXdTZXR0aW5ncyB9KSk7XG4gICAgICAgICAgdXBkYXRlU2V0dGluZ3MobmV3U2V0dGluZ3MsIHVzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gIH0sIFtjdXJyZW50VXNlcklkLCBjdXJyZW50U2V0dGluZ3NdKTtcblxuICAvLyBVcGRhdGUgc2V0dGluZ3MgZm9yIGEgdXNlciB3aXRoIHZhbHVlLWJhc2VkIG9wdGltaXphdGlvblxuICBjb25zdCB1cGRhdGVTZXR0aW5ncyA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdTZXR0aW5ncywgdXNlcklkKSA9PiB7XG4gICAgaWYgKCF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0VXBkYXRlVGltZSA8IE1JTl9VUERBVEVfSU5URVJWQUwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbdXBkYXRlU2V0dGluZ3NdIFNraXBwaW5nIHVwZGF0ZSAtIHRvbyBzb29uIGFmdGVyIGxhc3QgdXBkYXRlJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdXBkYXRlZFNldHRpbmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3NbdXNlcklkXSxcbiAgICAgIC4uLm5ld1NldHRpbmdzXG4gICAgfTtcblxuICAgIC8vIENvbXBhcmUgd2l0aCBsYXN0IGtub3duIHNldHRpbmdzXG4gICAgY29uc3QgbGFzdEtub3duID0gbGFzdEtub3duU2V0dGluZ3MuY3VycmVudC5nZXQodXNlcklkKTtcbiAgICBjb25zdCBoYXNDaGFuZ2VkID0gIWlzRXF1YWwobGFzdEtub3duLCB1cGRhdGVkU2V0dGluZ3MpO1xuXG4gICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICBjb25zb2xlLmxvZygnW3VwZGF0ZVNldHRpbmdzXSBTZXR0aW5ncyB1bmNoYW5nZWQsIHNraXBwaW5nIHVwZGF0ZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBpc1VwZGF0aW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgcGVuZGluZ1VwZGF0ZXMuY3VycmVudC5zZXQodXNlcklkLCB0cnVlKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1cGRhdGVkU2V0dGluZ3MpXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gc2F2ZSBzZXR0aW5ncycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zdCBmaW5hbFNldHRpbmdzID0gcmVzdWx0LmRhdGEgfHwgdXBkYXRlZFNldHRpbmdzO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdGUgYW5kIGNhY2hlc1xuICAgICAgc2V0U2V0dGluZ3MocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogZmluYWxTZXR0aW5ncyB9KSk7XG4gICAgICBzZXRDdXJyZW50U2V0dGluZ3MoZmluYWxTZXR0aW5ncyk7XG4gICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KHVzZXJJZCwgZmluYWxTZXR0aW5ncyk7XG4gICAgICBsYXN0U2V0dGluZ3NVcGRhdGUuY3VycmVudC5zZXQodXNlcklkLCBub3cpO1xuICAgICAgbGFzdEtub3duU2V0dGluZ3MuY3VycmVudC5zZXQodXNlcklkLCBmaW5hbFNldHRpbmdzKTtcbiAgICAgIHNldExhc3RVcGRhdGVUaW1lKG5vdyk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzVXBkYXRpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgICAgcGVuZGluZ1VwZGF0ZXMuY3VycmVudC5kZWxldGUodXNlcklkKTtcbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgbGFzdFVwZGF0ZVRpbWVdKTtcblxuICAvLyBVcGxvYWQgYW5kIHVwZGF0ZSBpbWFnZSBmb3IgYSB1c2VyXG4gIGNvbnN0IHVwZGF0ZUltYWdlID0gYXN5bmMgKHVzZXJJZCwgYmFzZTY0SW1hZ2UpID0+IHtcbiAgICBjb25zb2xlLmxvZygnW3VwZGF0ZUltYWdlXSB1c2VySWQ6JywgdXNlcklkKTsgLy8gRGVidWcgbG9nXG4gICAgaWYgKCF1c2VySWQgfHwgIWJhc2U2NEltYWdlKSByZXR1cm47XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvaW1hZ2U/dXNlcl9pZD0ke3VzZXJJZH1gLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGltYWdlOiBiYXNlNjRJbWFnZSB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5kZXRhaWwgfHwgJ0ZhaWxlZCB0byB1cGxvYWQgaW1hZ2UnKTtcbiAgICAgIH1cbiAgICAgIC8vIE9wdGlvbmFsbHksIGZldGNoIHNldHRpbmdzIGFnYWluIHRvIGdldCB1cGRhdGVkIGltYWdlIGluZm9cbiAgICAgIGF3YWl0IGZldGNoU2V0dGluZ3NGb3JVc2VyKHVzZXJJZCk7XG4gICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBzZXRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXR0aW5ncyxcbiAgICBjdXJyZW50U2V0dGluZ3MsXG4gICAgY3VycmVudFVzZXJJZCxcbiAgICBlcnJvcixcbiAgICB1cGRhdGVTZXR0aW5nczogZmV0Y2hTZXR0aW5nc0ZvclVzZXJcbiAgfTtcbn07XG5cbi8vIEFkZCBkZWZhdWx0IGV4cG9ydCBjb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFkbWluU2V0dGluZ3MoKSB7XG4gIHJldHVybiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xufSJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiaXNFcXVhbCIsIm9iajEiLCJvYmoyIiwia2V5czEiLCJPYmplY3QiLCJrZXlzIiwia2V5czIiLCJsZW5ndGgiLCJldmVyeSIsImtleSIsImluY2x1ZGVzIiwiZGVib3VuY2UiLCJmdW5jIiwid2FpdCIsInRpbWVvdXQiLCJleGVjdXRlZEZ1bmN0aW9uIiwiYXJncyIsImxhdGVyIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImdldExvY2FsU3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwic2V0TG9jYWxTdG9yYWdlIiwidmFsdWUiLCJzZXRJdGVtIiwidXNlQWRtaW5TZXR0aW5ncyIsInJlZiIsInNldHRpbmdzIiwic2V0U2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzVG9wQmFyVXBkYXRlZCIsInNldElzVG9wQmFyVXBkYXRlZCIsInNldEVycm9yIiwiaW5pdGlhbGl6ZWQiLCJwb2xsaW5nSW50ZXJ2YWwiLCJjdXJyZW50U2V0dGluZ3MiLCJzZXRDdXJyZW50U2V0dGluZ3MiLCJsYXN0VXBkYXRlVGltZSIsInNldExhc3RVcGRhdGVUaW1lIiwiTUlOX1VQREFURV9JTlRFUlZBTCIsIkNBQ0hFX0RVUkFUSU9OIiwiUE9MTElOR19JTlRFUlZBTCIsInNldHRpbmdzQ2FjaGUiLCJNYXAiLCJsYXN0U2V0dGluZ3NVcGRhdGUiLCJwZW5kaW5nVXBkYXRlcyIsImlzVXBkYXRpbmciLCJsYXN0S25vd25TZXR0aW5ncyIsImxvZyIsImZldGNoU2V0dGluZ3NGb3JVc2VyIiwidXNlcklkIiwiY2FjaGVkU2V0dGluZ3MiLCJjdXJyZW50IiwiZ2V0IiwibGFzdFVwZGF0ZSIsIm5vdyIsIkRhdGUiLCJoYXMiLCJzZXQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfS0VZIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJFcnJvciIsImRldGFpbCIsInJlc3VsdCIsIm5ld1NldHRpbmdzIiwiZGF0YSIsImxhc3RLbm93biIsImhhc0NoYW5nZWQiLCJwcmV2Iiwic2V0Q2FwdHVyZVNldHRpbmdzIiwibWVzc2FnZSIsImRlbGV0ZSIsImRlYm91bmNlZEZldGNoU2V0dGluZ3MiLCJmZXRjaFNldHRpbmdzIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJuZXdVc2VySWQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkN1c3RvbUV2ZW50IiwidHlwZSIsImRpc3BhdGNoRXZlbnQiLCJzYXZlZFNldHRpbmdzIiwicGFyc2VkU2V0dGluZ3MiLCJKU09OIiwicGFyc2UiLCJzdHJpbmdpZnkiLCJ1c2VyU2V0dGluZ3MiLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsInRpbWVzIiwiZGVsYXkiLCJ1bmRlZmluZWQiLCJOdW1iZXIiLCJ1cGRhdGVTZXR0aW5ncyIsInVwZGF0ZWRTZXR0aW5ncyIsIm1ldGhvZCIsImJvZHkiLCJmaW5hbFNldHRpbmdzIiwidXBkYXRlSW1hZ2UiLCJiYXNlNjRJbWFnZSIsImltYWdlIiwiQWRtaW5TZXR0aW5ncyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/displayResponse.js":
/*!******************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/displayResponse.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nconst DisplayResponse = (param)=>{\n    let { width, height, distance, isVisible = true } = param;\n    _s();\n    // Animation state for visibility transitions\n    const [animationState, setAnimationState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(isVisible ? 'visible' : 'hidden');\n    // Update animation state when visibility changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"DisplayResponse.useEffect\": ()=>{\n            setAnimationState(isVisible ? 'visible' : 'hidden');\n        }\n    }[\"DisplayResponse.useEffect\"], [\n        isVisible\n    ]);\n    // Format values with units and handle missing values\n    const formattedWidth = width || '---';\n    const formattedHeight = height || '---';\n    const formattedDistance = distance || '---';\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"metrics-display \".concat(animationState),\n        style: {\n            position: 'absolute',\n            right: '20px',\n            top: '80px',\n            backgroundColor: 'rgba(0, 102, 204, 0.8)',\n            color: 'white',\n            padding: '10px 15px',\n            borderRadius: '8px',\n            fontSize: '14px',\n            fontFamily: 'monospace',\n            boxShadow: '0 2px 10px rgba(0, 0, 0, 0.3)',\n            transition: 'all 0.3s ease',\n            opacity: animationState === 'visible' ? 1 : 0,\n            transform: animationState === 'visible' ? 'translateX(0)' : 'translateX(50px)',\n            pointerEvents: animationState === 'visible' ? 'auto' : 'none',\n            zIndex: 100\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"metrics-header\",\n                style: {\n                    display: 'flex',\n                    justifyContent: 'space-between',\n                    alignItems: 'center',\n                    marginBottom: '8px',\n                    borderBottom: '1px solid rgba(255, 255, 255, 0.3)',\n                    paddingBottom: '5px'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        style: {\n                            fontWeight: 'bold'\n                        },\n                        children: \"Display Metrics\"\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"metrics-indicator\",\n                        style: {\n                            width: '10px',\n                            height: '10px',\n                            borderRadius: '50%',\n                            backgroundColor: '#00ff00',\n                            boxShadow: '0 0 5px rgba(0, 255, 0, 0.8)'\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                        lineNumber: 52,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                lineNumber: 40,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"metrics-content\",\n                style: {\n                    lineHeight: '1.5'\n                },\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    display: 'inline-block',\n                                    width: '80px'\n                                },\n                                children: \"Width:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 69,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    fontWeight: 'bold'\n                                },\n                                children: formattedWidth\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 70,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    opacity: 0.8,\n                                    fontSize: '12px'\n                                },\n                                children: \" pixels\"\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 71,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                        lineNumber: 68,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    display: 'inline-block',\n                                    width: '80px'\n                                },\n                                children: \"Height:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 74,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    fontWeight: 'bold'\n                                },\n                                children: formattedHeight\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 75,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    opacity: 0.8,\n                                    fontSize: '12px'\n                                },\n                                children: \" pixels\"\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 76,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                        lineNumber: 73,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    display: 'inline-block',\n                                    width: '80px'\n                                },\n                                children: \"Distance:\"\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 79,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    fontWeight: 'bold'\n                                },\n                                children: formattedDistance\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 80,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                style: {\n                                    opacity: 0.8,\n                                    fontSize: '12px'\n                                },\n                                children: \" cm\"\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                                lineNumber: 81,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                        lineNumber: 78,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/displayResponse.js\",\n        lineNumber: 18,\n        columnNumber: 5\n    }, undefined);\n};\n_s(DisplayResponse, \"mi6lEmDyIHWSMf9dWknMjCAipTM=\");\n_c = DisplayResponse;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DisplayResponse);\nvar _c;\n$RefreshReg$(_c, \"DisplayResponse\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvZGlzcGxheVJlc3BvbnNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUQ7QUFFbkQsTUFBTUcsa0JBQWtCO1FBQUMsRUFBRUMsS0FBSyxFQUFFQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxJQUFJLEVBQUU7O0lBQ3BFLDZDQUE2QztJQUM3QyxNQUFNLENBQUNDLGdCQUFnQkMsa0JBQWtCLEdBQUdSLCtDQUFRQSxDQUFDTSxZQUFZLFlBQVk7SUFFN0UsaURBQWlEO0lBQ2pETCxnREFBU0E7cUNBQUM7WUFDUk8sa0JBQWtCRixZQUFZLFlBQVk7UUFDNUM7b0NBQUc7UUFBQ0E7S0FBVTtJQUVkLHFEQUFxRDtJQUNyRCxNQUFNRyxpQkFBaUJOLFNBQVM7SUFDaEMsTUFBTU8sa0JBQWtCTixVQUFVO0lBQ2xDLE1BQU1PLG9CQUFvQk4sWUFBWTtJQUV0QyxxQkFDRSw4REFBQ087UUFDQ0MsV0FBVyxtQkFBa0MsT0FBZk47UUFDOUJPLE9BQU87WUFDTEMsVUFBVTtZQUNWQyxPQUFPO1lBQ1BDLEtBQUs7WUFDTEMsaUJBQWlCO1lBQ2pCQyxPQUFPO1lBQ1BDLFNBQVM7WUFDVEMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZDLFlBQVk7WUFDWkMsV0FBVztZQUNYQyxZQUFZO1lBQ1pDLFNBQVNuQixtQkFBbUIsWUFBWSxJQUFJO1lBQzVDb0IsV0FBV3BCLG1CQUFtQixZQUMxQixrQkFDQTtZQUNKcUIsZUFBZXJCLG1CQUFtQixZQUFZLFNBQVM7WUFDdkRzQixRQUFRO1FBQ1Y7OzBCQUVBLDhEQUFDakI7Z0JBQ0NDLFdBQVU7Z0JBQ1ZDLE9BQU87b0JBQ0xnQixTQUFTO29CQUNUQyxnQkFBZ0I7b0JBQ2hCQyxZQUFZO29CQUNaQyxjQUFjO29CQUNkQyxjQUFjO29CQUNkQyxlQUFlO2dCQUNqQjs7a0NBRUEsOERBQUNDO3dCQUFLdEIsT0FBTzs0QkFBRXVCLFlBQVk7d0JBQU87a0NBQUc7Ozs7OztrQ0FDckMsOERBQUN6Qjt3QkFDQ0MsV0FBVTt3QkFDVkMsT0FBTzs0QkFDTFgsT0FBTzs0QkFDUEMsUUFBUTs0QkFDUmlCLGNBQWM7NEJBQ2RILGlCQUFpQjs0QkFDakJNLFdBQVc7d0JBQ2I7Ozs7Ozs7Ozs7OzswQkFJSiw4REFBQ1o7Z0JBQ0NDLFdBQVU7Z0JBQ1ZDLE9BQU87b0JBQUV3QixZQUFZO2dCQUFNOztrQ0FFM0IsOERBQUNDOzswQ0FDQyw4REFBQ0g7Z0NBQUt0QixPQUFPO29DQUFFZ0IsU0FBUztvQ0FBZ0IzQixPQUFPO2dDQUFPOzBDQUFHOzs7Ozs7MENBQ3pELDhEQUFDaUM7Z0NBQUt0QixPQUFPO29DQUFFdUIsWUFBWTtnQ0FBTzswQ0FBSTVCOzs7Ozs7MENBQ3RDLDhEQUFDMkI7Z0NBQUt0QixPQUFPO29DQUFFWSxTQUFTO29DQUFLSixVQUFVO2dDQUFPOzBDQUFHOzs7Ozs7Ozs7Ozs7a0NBRW5ELDhEQUFDaUI7OzBDQUNDLDhEQUFDSDtnQ0FBS3RCLE9BQU87b0NBQUVnQixTQUFTO29DQUFnQjNCLE9BQU87Z0NBQU87MENBQUc7Ozs7OzswQ0FDekQsOERBQUNpQztnQ0FBS3RCLE9BQU87b0NBQUV1QixZQUFZO2dDQUFPOzBDQUFJM0I7Ozs7OzswQ0FDdEMsOERBQUMwQjtnQ0FBS3RCLE9BQU87b0NBQUVZLFNBQVM7b0NBQUtKLFVBQVU7Z0NBQU87MENBQUc7Ozs7Ozs7Ozs7OztrQ0FFbkQsOERBQUNpQjs7MENBQ0MsOERBQUNIO2dDQUFLdEIsT0FBTztvQ0FBRWdCLFNBQVM7b0NBQWdCM0IsT0FBTztnQ0FBTzswQ0FBRzs7Ozs7OzBDQUN6RCw4REFBQ2lDO2dDQUFLdEIsT0FBTztvQ0FBRXVCLFlBQVk7Z0NBQU87MENBQUkxQjs7Ozs7OzBDQUN0Qyw4REFBQ3lCO2dDQUFLdEIsT0FBTztvQ0FBRVksU0FBUztvQ0FBS0osVUFBVTtnQ0FBTzswQ0FBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzNEO0dBbkZNcEI7S0FBQUE7QUFxRk4saUVBQWVBLGVBQWVBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2Rpc3BsYXlSZXNwb25zZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgRGlzcGxheVJlc3BvbnNlID0gKHsgd2lkdGgsIGhlaWdodCwgZGlzdGFuY2UsIGlzVmlzaWJsZSA9IHRydWUgfSkgPT4ge1xuICAvLyBBbmltYXRpb24gc3RhdGUgZm9yIHZpc2liaWxpdHkgdHJhbnNpdGlvbnNcbiAgY29uc3QgW2FuaW1hdGlvblN0YXRlLCBzZXRBbmltYXRpb25TdGF0ZV0gPSB1c2VTdGF0ZShpc1Zpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJyk7XG4gIFxuICAvLyBVcGRhdGUgYW5pbWF0aW9uIHN0YXRlIHdoZW4gdmlzaWJpbGl0eSBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0QW5pbWF0aW9uU3RhdGUoaXNWaXNpYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpO1xuICB9LCBbaXNWaXNpYmxlXSk7XG4gIFxuICAvLyBGb3JtYXQgdmFsdWVzIHdpdGggdW5pdHMgYW5kIGhhbmRsZSBtaXNzaW5nIHZhbHVlc1xuICBjb25zdCBmb3JtYXR0ZWRXaWR0aCA9IHdpZHRoIHx8ICctLS0nO1xuICBjb25zdCBmb3JtYXR0ZWRIZWlnaHQgPSBoZWlnaHQgfHwgJy0tLSc7XG4gIGNvbnN0IGZvcm1hdHRlZERpc3RhbmNlID0gZGlzdGFuY2UgfHwgJy0tLSc7XG4gIFxuICByZXR1cm4gKFxuICAgIDxkaXYgXG4gICAgICBjbGFzc05hbWU9e2BtZXRyaWNzLWRpc3BsYXkgJHthbmltYXRpb25TdGF0ZX1gfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHJpZ2h0OiAnMjBweCcsXG4gICAgICAgIHRvcDogJzgwcHgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDEwMiwgMjA0LCAwLjgpJyxcbiAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgIHBhZGRpbmc6ICcxMHB4IDE1cHgnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAgICAgICAgYm94U2hhZG93OiAnMCAycHggMTBweCByZ2JhKDAsIDAsIDAsIDAuMyknLFxuICAgICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuM3MgZWFzZScsXG4gICAgICAgIG9wYWNpdHk6IGFuaW1hdGlvblN0YXRlID09PSAndmlzaWJsZScgPyAxIDogMCxcbiAgICAgICAgdHJhbnNmb3JtOiBhbmltYXRpb25TdGF0ZSA9PT0gJ3Zpc2libGUnIFxuICAgICAgICAgID8gJ3RyYW5zbGF0ZVgoMCknIFxuICAgICAgICAgIDogJ3RyYW5zbGF0ZVgoNTBweCknLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiBhbmltYXRpb25TdGF0ZSA9PT0gJ3Zpc2libGUnID8gJ2F1dG8nIDogJ25vbmUnLFxuICAgICAgICB6SW5kZXg6IDEwMFxuICAgICAgfX1cbiAgICA+XG4gICAgICA8ZGl2IFxuICAgICAgICBjbGFzc05hbWU9XCJtZXRyaWNzLWhlYWRlclwiXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYmV0d2VlbicsXG4gICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgbWFyZ2luQm90dG9tOiAnOHB4JyxcbiAgICAgICAgICBib3JkZXJCb3R0b206ICcxcHggc29saWQgcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjMpJyxcbiAgICAgICAgICBwYWRkaW5nQm90dG9tOiAnNXB4J1xuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+RGlzcGxheSBNZXRyaWNzPC9zcGFuPlxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cIm1ldHJpY3MtaW5kaWNhdG9yXCJcbiAgICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICAgIHdpZHRoOiAnMTBweCcsIFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTBweCcsIFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJywgXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDBmZjAwJyxcbiAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCA1cHggcmdiYSgwLCAyNTUsIDAsIDAuOCknXG4gICAgICAgICAgfX0gXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIFxuICAgICAgPGRpdiBcbiAgICAgICAgY2xhc3NOYW1lPVwibWV0cmljcy1jb250ZW50XCJcbiAgICAgICAgc3R5bGU9e3sgbGluZUhlaWdodDogJzEuNScgfX1cbiAgICAgID5cbiAgICAgICAgPHA+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIHdpZHRoOiAnODBweCcgfX0+V2lkdGg6PC9zcGFuPiBcbiAgICAgICAgICA8c3BhbiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcgfX0+e2Zvcm1hdHRlZFdpZHRofTwvc3Bhbj4gXG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgb3BhY2l0eTogMC44LCBmb250U2l6ZTogJzEycHgnIH19PiBwaXhlbHM8L3NwYW4+XG4gICAgICAgIDwvcD5cbiAgICAgICAgPHA+XG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZGlzcGxheTogJ2lubGluZS1ibG9jaycsIHdpZHRoOiAnODBweCcgfX0+SGVpZ2h0Ojwvc3Bhbj4gXG4gICAgICAgICAgPHNwYW4gc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnIH19Pntmb3JtYXR0ZWRIZWlnaHR9PC9zcGFuPiBcbiAgICAgICAgICA8c3BhbiBzdHlsZT17eyBvcGFjaXR5OiAwLjgsIGZvbnRTaXplOiAnMTJweCcgfX0+IHBpeGVsczwvc3Bhbj5cbiAgICAgICAgPC9wPlxuICAgICAgICA8cD5cbiAgICAgICAgICA8c3BhbiBzdHlsZT17eyBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJywgd2lkdGg6ICc4MHB4JyB9fT5EaXN0YW5jZTo8L3NwYW4+IFxuICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IGZvbnRXZWlnaHQ6ICdib2xkJyB9fT57Zm9ybWF0dGVkRGlzdGFuY2V9PC9zcGFuPiBcbiAgICAgICAgICA8c3BhbiBzdHlsZT17eyBvcGFjaXR5OiAwLjgsIGZvbnRTaXplOiAnMTJweCcgfX0+IGNtPC9zcGFuPlxuICAgICAgICA8L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERpc3BsYXlSZXNwb25zZTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIkRpc3BsYXlSZXNwb25zZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGlzdGFuY2UiLCJpc1Zpc2libGUiLCJhbmltYXRpb25TdGF0ZSIsInNldEFuaW1hdGlvblN0YXRlIiwiZm9ybWF0dGVkV2lkdGgiLCJmb3JtYXR0ZWRIZWlnaHQiLCJmb3JtYXR0ZWREaXN0YW5jZSIsImRpdiIsImNsYXNzTmFtZSIsInN0eWxlIiwicG9zaXRpb24iLCJyaWdodCIsInRvcCIsImJhY2tncm91bmRDb2xvciIsImNvbG9yIiwicGFkZGluZyIsImJvcmRlclJhZGl1cyIsImZvbnRTaXplIiwiZm9udEZhbWlseSIsImJveFNoYWRvdyIsInRyYW5zaXRpb24iLCJvcGFjaXR5IiwidHJhbnNmb3JtIiwicG9pbnRlckV2ZW50cyIsInpJbmRleCIsImRpc3BsYXkiLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJtYXJnaW5Cb3R0b20iLCJib3JkZXJCb3R0b20iLCJwYWRkaW5nQm90dG9tIiwic3BhbiIsImZvbnRXZWlnaHQiLCJsaW5lSGVpZ2h0IiwicCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/displayResponse.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/topBar.js":
/*!*********************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/topBar.js ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! styled-jsx/style */ \"(pages-dir-browser)/./node_modules/styled-jsx/style.js\");\n/* harmony import */ var styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(styled_jsx_style__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n/* harmony import */ var _utils_consentManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/consentManager */ \"(pages-dir-browser)/./utils/consentManager.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n// Improved debounce function\nconst debounce = (func, wait)=>{\n    let timeout;\n    let lastArgs;\n    let lastThis;\n    return function executedFunction() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        lastArgs = args;\n        lastThis = this;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(()=>{\n            timeout = null;\n            func.apply(lastThis, lastArgs);\n        }, wait);\n    };\n};\nconst TopBar = (param)=>{\n    let { onButtonClick, onCameraAccess, outputText, onOutputChange, onToggleTopBar, onToggleMetrics, canvasRef, isTopBarShown = true, isCanvasVisible = true } = param;\n    _s();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter)();\n    const [canvasStatus, setCanvasStatus] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(isCanvasVisible);\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_4__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(true);\n    const [currentSettings, setCurrentSettings] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        times: 1,\n        delay: 3\n    });\n    const isUpdatingRef = (0,react__WEBPACK_IMPORTED_MODULE_2__.useRef)(false);\n    // Memoized function to fetch settings\n    const fetchSettings = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"TopBar.useCallback[fetchSettings]\": async (userId)=>{\n            if (!userId || isUpdatingRef.current) return;\n            try {\n                isUpdatingRef.current = true;\n                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                    headers: {\n                        'Accept': 'application/json',\n                        'Content-Type': 'application/json',\n                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error('Failed to fetch settings');\n                }\n                const userSettings = await response.json();\n                if (userSettings && (userSettings.times || userSettings.delay)) {\n                    setCurrentSettings(userSettings);\n                    if (updateSettings) {\n                        await updateSettings(userSettings, userId);\n                    }\n                }\n            } catch (error) {\n                console.error('TopBar - Error fetching settings:', error);\n            } finally{\n                isUpdatingRef.current = false;\n            }\n        }\n    }[\"TopBar.useCallback[fetchSettings]\"], [\n        updateSettings\n    ]);\n    // Debounced save settings function\n    const debouncedSaveSettings = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)(debounce({\n        \"TopBar.useCallback[debouncedSaveSettings]\": async (userId, newSettings)=>{\n            if (!userId || isUpdatingRef.current) return;\n            try {\n                isUpdatingRef.current = true;\n                const response = await fetch(\"/api/data-center/settings/\".concat(userId), {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'X-API-Key': process.env.NEXT_PUBLIC_API_KEY\n                    },\n                    body: JSON.stringify(newSettings)\n                });\n                if (!response.ok) {\n                    throw new Error('Failed to save settings to backend');\n                }\n                const latestSettings = await response.json();\n                setCurrentSettings(latestSettings);\n                if (updateSettings) {\n                    await updateSettings(latestSettings, userId);\n                }\n            } catch (error) {\n                console.error('TopBar - Error saving settings:', error);\n            } finally{\n                isUpdatingRef.current = false;\n            }\n        }\n    }[\"TopBar.useCallback[debouncedSaveSettings]\"], 500), [\n        updateSettings\n    ]);\n    // Initialize user ID and fetch initial settings\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"TopBar.useEffect\": ()=>{\n            const initializeUserId = {\n                \"TopBar.useEffect.initializeUserId\": async ()=>{\n                    const userId = (0,_utils_consentManager__WEBPACK_IMPORTED_MODULE_5__.getOrCreateUserId)();\n                    if (userId) {\n                        setCurrentUserId(userId);\n                        await fetchSettings(userId);\n                        setIsLoading(false);\n                    }\n                }\n            }[\"TopBar.useEffect.initializeUserId\"];\n            initializeUserId();\n        }\n    }[\"TopBar.useEffect\"], [\n        fetchSettings\n    ]);\n    // Update canvas status when prop changes\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"TopBar.useEffect\": ()=>{\n            setCanvasStatus(isCanvasVisible);\n        }\n    }[\"TopBar.useEffect\"], [\n        isCanvasVisible\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"TopBar.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"TopBar.useEffect.handleUserIdChange\": async (event)=>{\n                    var _event_detail;\n                    if ((_event_detail = event.detail) === null || _event_detail === void 0 ? void 0 : _event_detail.userId) {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        await fetchSettings(newUserId);\n                    }\n                }\n            }[\"TopBar.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"TopBar.useEffect\": ()=>window.removeEventListener('userIdChange', handleUserIdChange)\n            })[\"TopBar.useEffect\"];\n        }\n    }[\"TopBar.useEffect\"], [\n        fetchSettings\n    ]);\n    // Listen for settings updates from admin page\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"TopBar.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"TopBar.useEffect.handleSettingsUpdate\": (event)=>{\n                    var _event_detail;\n                    if (((_event_detail = event.detail) === null || _event_detail === void 0 ? void 0 : _event_detail.type) === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        // Only update if values have actually changed\n                        if (times !== currentSettings.times || delay !== currentSettings.delay) {\n                            const newSettings = {\n                                times: Number(times) || currentSettings.times,\n                                delay: Number(delay) || currentSettings.delay\n                            };\n                            debouncedSaveSettings(userId, newSettings);\n                        }\n                    }\n                }\n            }[\"TopBar.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"TopBar.useEffect\": ()=>window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate)\n            })[\"TopBar.useEffect\"];\n        }\n    }[\"TopBar.useEffect\"], [\n        currentSettings,\n        debouncedSaveSettings\n    ]);\n    // Handle settings change\n    const handleSettingsChange = (0,react__WEBPACK_IMPORTED_MODULE_2__.useCallback)({\n        \"TopBar.useCallback[handleSettingsChange]\": async (newSettings)=>{\n            if (!currentUserId) return;\n            debouncedSaveSettings(currentUserId, newSettings);\n        }\n    }[\"TopBar.useCallback[handleSettingsChange]\"], [\n        currentUserId,\n        debouncedSaveSettings\n    ]);\n    const handleButtonClick = (actionType)=>{\n        if (onButtonClick) {\n            onButtonClick(actionType);\n        }\n    };\n    const handleToggleTopBar = ()=>{\n        onToggleTopBar(!isTopBarShown);\n    };\n    const handleToggleMetrics = ()=>{\n        onToggleMetrics();\n    };\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    const statusMessage = \"TopBar \".concat(isTopBarShown ? 'shown' : 'hidden', \", Canvas: \").concat(canvasStatus ? 'Visible' : 'Hidden');\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"jsx-8fd840df60237147\" + \" \" + \"topbar\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-8fd840df60237147\" + \" \" + \"topbar-left\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-8fd840df60237147\" + \" \" + \"logo\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"jsx-8fd840df60237147\" + \" \" + \"logo-text\",\n                            children: \"Logo\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                            lineNumber: 195,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                        lineNumber: 194,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-8fd840df60237147\" + \" \" + \"controls-container\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"jsx-8fd840df60237147\" + \" \" + \"control-group\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"jsx-8fd840df60237147\" + \" \" + \"control-label\",\n                                        children: \"Time(s):\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                        lineNumber: 200,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"jsx-8fd840df60237147\" + \" \" + \"control-input\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"control-input-field\",\n                                            children: currentSettings.times\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 202,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                        lineNumber: 201,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, \"times-\".concat(currentSettings.times, \"-\").concat(Date.now()), true, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                lineNumber: 199,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"jsx-8fd840df60237147\" + \" \" + \"control-group\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"jsx-8fd840df60237147\" + \" \" + \"control-label\",\n                                        children: \"Delay(s):\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                        lineNumber: 207,\n                                        columnNumber: 13\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"jsx-8fd840df60237147\" + \" \" + \"control-input\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"control-input-field\",\n                                            children: currentSettings.delay\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 209,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                        lineNumber: 208,\n                                        columnNumber: 13\n                                    }, undefined)\n                                ]\n                            }, \"delay-\".concat(currentSettings.delay, \"-\").concat(Date.now()), true, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                lineNumber: 206,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                        lineNumber: 198,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                lineNumber: 193,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-8fd840df60237147\" + \" \" + \"topbar-middle\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"jsx-8fd840df60237147\" + \" \" + \"button-groups\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"jsx-8fd840df60237147\" + \" \" + \"button-group\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"jsx-8fd840df60237147\" + \" \" + \"button-row\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: handleGoBack,\n                                            title: \"Go back to home page\",\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn back-button\",\n                                            children: \"← Back\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 219,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('setRandom'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Set Random\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 227,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('calibrate'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Set Calibrate\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 233,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 218,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        marginRight: '80px'\n                                    },\n                                    className: \"jsx-8fd840df60237147\" + \" \" + \"button-row\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('randomDot'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Random Dot\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 242,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('clearAll'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Clear All\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 248,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 241,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                            lineNumber: 217,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"jsx-8fd840df60237147\" + \" \" + \"topbar-divider\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                            lineNumber: 257,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"jsx-8fd840df60237147\" + \" \" + \"button-group\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"jsx-8fd840df60237147\" + \" \" + \"button-row\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('headPose'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Draw Head pose\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 261,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('boundingBox'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Show Bounding Box\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 267,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 260,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"jsx-8fd840df60237147\" + \" \" + \"button-row\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('preview'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Show Preview\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 276,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('mask'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"\\uD83D\\uDE0A Show Mask\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 282,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                            onClick: ()=>handleButtonClick('parameters'),\n                                            className: \"jsx-8fd840df60237147\" + \" \" + \"btn\",\n                                            children: \"Parameters\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                            lineNumber: 288,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 275,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                            lineNumber: 259,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                    lineNumber: 216,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                lineNumber: 215,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"jsx-8fd840df60237147\" + \" \" + \"topbar-right\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-8fd840df60237147\" + \" \" + \"notes-container\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            title: \"Processing Output\",\n                            className: \"jsx-8fd840df60237147\" + \" \" + \"output-display\",\n                            children: [\n                                statusMessage,\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"br\", {\n                                    className: \"jsx-8fd840df60237147\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 306,\n                                    columnNumber: 13\n                                }, undefined),\n                                outputText || \"Processing output will appear here...\"\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                            lineNumber: 301,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                        lineNumber: 300,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"jsx-8fd840df60237147\" + \" \" + \"control-buttons\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleToggleTopBar,\n                                title: \"Toggle TopBar\",\n                                style: {\n                                    padding: '5px 10px',\n                                    backgroundColor: '#0066cc',\n                                    color: 'white',\n                                    border: 'none',\n                                    borderRadius: '4px',\n                                    fontSize: '16px',\n                                    cursor: 'pointer',\n                                    marginRight: '5px'\n                                },\n                                className: \"jsx-8fd840df60237147\" + \" \" + \"icon-btn menu-btn\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"jsx-8fd840df60237147\" + \" \" + \"icon-text\",\n                                    children: \"≡\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 327,\n                                    columnNumber: 13\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                lineNumber: 312,\n                                columnNumber: 11\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleToggleMetrics,\n                                title: \"Toggle Metrics\",\n                                style: {\n                                    padding: '5px 10px',\n                                    backgroundColor: '#ff9900',\n                                    color: 'white',\n                                    border: 'none',\n                                    borderRadius: '4px',\n                                    fontSize: '16px',\n                                    cursor: 'pointer'\n                                },\n                                className: \"jsx-8fd840df60237147\" + \" \" + \"icon-btn alert-btn\",\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: \"jsx-8fd840df60237147\" + \" \" + \"icon-text\",\n                                    children: \"!\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                    lineNumber: 344,\n                                    columnNumber: 13\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                                lineNumber: 330,\n                                columnNumber: 11\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                        lineNumber: 311,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n                lineNumber: 299,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((styled_jsx_style__WEBPACK_IMPORTED_MODULE_1___default()), {\n                id: \"8fd840df60237147\",\n                children: \".active-toggle.jsx-8fd840df60237147{-webkit-transform:scale(1.2);-moz-transform:scale(1.2);-ms-transform:scale(1.2);-o-transform:scale(1.2);transform:scale(1.2);-webkit-transition:all.3s ease;-moz-transition:all.3s ease;-o-transition:all.3s ease;transition:all.3s ease}.icon-btn.jsx-8fd840df60237147{-webkit-transition:all.2s ease;-moz-transition:all.2s ease;-o-transition:all.2s ease;transition:all.2s ease}.icon-btn.jsx-8fd840df60237147:hover{opacity:.8}\"\n            }, void 0, false, void 0, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/components-gui/topBar.js\",\n        lineNumber: 192,\n        columnNumber: 5\n    }, undefined);\n};\n_s(TopBar, \"+PJxubFPEBNl7PqFKDFtDmvceqs=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_3__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_4__.useAdminSettings\n    ];\n});\n_c = TopBar;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TopBar);\nvar _c;\n$RefreshReg$(_c, \"TopBar\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvdG9wQmFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RTtBQUNoQztBQUNXO0FBQ2U7QUFFbEUsNkJBQTZCO0FBQzdCLE1BQU1RLFdBQVcsQ0FBQ0MsTUFBTUM7SUFDdEIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlDO0lBRUosT0FBTyxTQUFTQztRQUFpQjtZQUFHQyxLQUFILHVCQUFPOztRQUN0Q0gsV0FBV0c7UUFDWEYsV0FBVyxJQUFJO1FBRWYsSUFBSUYsU0FBUztZQUNYSyxhQUFhTDtRQUNmO1FBRUFBLFVBQVVNLFdBQVc7WUFDbkJOLFVBQVU7WUFDVkYsS0FBS1MsS0FBSyxDQUFDTCxVQUFVRDtRQUN2QixHQUFHRjtJQUNMO0FBQ0Y7QUFFQSxNQUFNUyxTQUFTO1FBQUMsRUFDZEMsYUFBYSxFQUNiQyxjQUFjLEVBQ2RDLFVBQVUsRUFDVkMsY0FBYyxFQUNkQyxjQUFjLEVBQ2RDLGVBQWUsRUFDZkMsU0FBUyxFQUNUQyxnQkFBZ0IsSUFBSSxFQUNwQkMsa0JBQWtCLElBQUksRUFDdkI7O0lBQ0MsTUFBTUMsU0FBU3hCLHNEQUFTQTtJQUN4QixNQUFNLENBQUN5QixjQUFjQyxnQkFBZ0IsR0FBRzlCLCtDQUFRQSxDQUFDMkI7SUFDakQsTUFBTSxFQUFFSSxRQUFRLEVBQUVDLGNBQWMsRUFBRSxHQUFHM0IsZ0VBQWdCQTtJQUNyRCxNQUFNLENBQUM0QixlQUFlQyxpQkFBaUIsR0FBR2xDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ21DLFdBQVdDLGFBQWEsR0FBR3BDLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ3FDLGlCQUFpQkMsbUJBQW1CLEdBQUd0QywrQ0FBUUEsQ0FBQztRQUFFdUMsT0FBTztRQUFHQyxPQUFPO0lBQUU7SUFDNUUsTUFBTUMsZ0JBQWdCdEMsNkNBQU1BLENBQUM7SUFF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QkFBaUI7b0NBQ2pCQyxPQUFPO29DQUNQQyxRQUFRO29DQUNSQyxjQUFjO29DQUNkQyxVQUFVO29DQUNWQyxRQUFRO2dDQUNWOzBFQVhVOzBDQWFWLDRFQUFDZjs4RUFBZTs4Q0FBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJ4QztHQWxWTW5FOztRQVdXZCxrREFBU0E7UUFFYUMsNERBQWdCQTs7O0tBYmpEYTtBQW9WTixpRUFBZUEsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvdG9wQmFyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9yb3V0ZXInO1xuaW1wb3J0IHsgdXNlQWRtaW5TZXR0aW5ncyB9IGZyb20gJy4vYWRtaW5TZXR0aW5ncyc7XG5pbXBvcnQgeyBnZXRPckNyZWF0ZVVzZXJJZCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NvbnNlbnRNYW5hZ2VyJztcblxuLy8gSW1wcm92ZWQgZGVib3VuY2UgZnVuY3Rpb25cbmNvbnN0IGRlYm91bmNlID0gKGZ1bmMsIHdhaXQpID0+IHtcbiAgbGV0IHRpbWVvdXQ7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IGxhc3RUaGlzO1xuICBcbiAgcmV0dXJuIGZ1bmN0aW9uIGV4ZWN1dGVkRnVuY3Rpb24oLi4uYXJncykge1xuICAgIGxhc3RBcmdzID0gYXJncztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgXG4gICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gICAgXG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBmdW5jLmFwcGx5KGxhc3RUaGlzLCBsYXN0QXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG59O1xuXG5jb25zdCBUb3BCYXIgPSAoeyBcbiAgb25CdXR0b25DbGljayxcbiAgb25DYW1lcmFBY2Nlc3MsXG4gIG91dHB1dFRleHQsXG4gIG9uT3V0cHV0Q2hhbmdlLFxuICBvblRvZ2dsZVRvcEJhcixcbiAgb25Ub2dnbGVNZXRyaWNzLFxuICBjYW52YXNSZWYsXG4gIGlzVG9wQmFyU2hvd24gPSB0cnVlLFxuICBpc0NhbnZhc1Zpc2libGUgPSB0cnVlXG59KSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCBbY2FudmFzU3RhdHVzLCBzZXRDYW52YXNTdGF0dXNdID0gdXNlU3RhdGUoaXNDYW52YXNWaXNpYmxlKTtcbiAgY29uc3QgeyBzZXR0aW5ncywgdXBkYXRlU2V0dGluZ3MgfSA9IHVzZUFkbWluU2V0dGluZ3MoKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2N1cnJlbnRTZXR0aW5ncywgc2V0Q3VycmVudFNldHRpbmdzXSA9IHVzZVN0YXRlKHsgdGltZXM6IDEsIGRlbGF5OiAzIH0pO1xuICBjb25zdCBpc1VwZGF0aW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcblxuICAvLyBNZW1vaXplZCBmdW5jdGlvbiB0byBmZXRjaCBzZXR0aW5nc1xuICBjb25zdCBmZXRjaFNldHRpbmdzID0gdXNlQ2FsbGJhY2soYXN5bmMgKHVzZXJJZCkgPT4ge1xuICAgIGlmICghdXNlcklkIHx8IGlzVXBkYXRpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBpc1VwZGF0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke3VzZXJJZH1gLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVlcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggc2V0dGluZ3MnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgaWYgKHVzZXJTZXR0aW5ncyAmJiAodXNlclNldHRpbmdzLnRpbWVzIHx8IHVzZXJTZXR0aW5ncy5kZWxheSkpIHtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIGlmICh1cGRhdGVTZXR0aW5ncykge1xuICAgICAgICAgIGF3YWl0IHVwZGF0ZVNldHRpbmdzKHVzZXJTZXR0aW5ncywgdXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUb3BCYXIgLSBFcnJvciBmZXRjaGluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzVXBkYXRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW3VwZGF0ZVNldHRpbmdzXSk7XG5cbiAgLy8gRGVib3VuY2VkIHNhdmUgc2V0dGluZ3MgZnVuY3Rpb25cbiAgY29uc3QgZGVib3VuY2VkU2F2ZVNldHRpbmdzID0gdXNlQ2FsbGJhY2soXG4gICAgZGVib3VuY2UoYXN5bmMgKHVzZXJJZCwgbmV3U2V0dGluZ3MpID0+IHtcbiAgICAgIGlmICghdXNlcklkIHx8IGlzVXBkYXRpbmdSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBpc1VwZGF0aW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7dXNlcklkfWAsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ1gtQVBJLUtleSc6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9LRVlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5ld1NldHRpbmdzKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2F2ZSBzZXR0aW5ncyB0byBiYWNrZW5kJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXRlc3RTZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2V0Q3VycmVudFNldHRpbmdzKGxhdGVzdFNldHRpbmdzKTtcbiAgICAgICAgaWYgKHVwZGF0ZVNldHRpbmdzKSB7XG4gICAgICAgICAgYXdhaXQgdXBkYXRlU2V0dGluZ3MobGF0ZXN0U2V0dGluZ3MsIHVzZXJJZCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1RvcEJhciAtIEVycm9yIHNhdmluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc1VwZGF0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LCA1MDApLFxuICAgIFt1cGRhdGVTZXR0aW5nc11cbiAgKTtcblxuICAvLyBJbml0aWFsaXplIHVzZXIgSUQgYW5kIGZldGNoIGluaXRpYWwgc2V0dGluZ3NcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsaXplVXNlcklkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdXNlcklkID0gZ2V0T3JDcmVhdGVVc2VySWQoKTtcbiAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgc2V0Q3VycmVudFVzZXJJZCh1c2VySWQpO1xuICAgICAgICBhd2FpdCBmZXRjaFNldHRpbmdzKHVzZXJJZCk7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0aWFsaXplVXNlcklkKCk7XG4gIH0sIFtmZXRjaFNldHRpbmdzXSk7XG5cbiAgLy8gVXBkYXRlIGNhbnZhcyBzdGF0dXMgd2hlbiBwcm9wIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRDYW52YXNTdGF0dXMoaXNDYW52YXNWaXNpYmxlKTtcbiAgfSwgW2lzQ2FudmFzVmlzaWJsZV0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsPy51c2VySWQpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgc2V0Q3VycmVudFVzZXJJZChuZXdVc2VySWQpO1xuICAgICAgICBhd2FpdCBmZXRjaFNldHRpbmdzKG5ld1VzZXJJZCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgfSwgW2ZldGNoU2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXMgZnJvbSBhZG1pbiBwYWdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWw/LnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCB0aW1lcywgZGVsYXkgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIGlmIHZhbHVlcyBoYXZlIGFjdHVhbGx5IGNoYW5nZWRcbiAgICAgICAgaWYgKHRpbWVzICE9PSBjdXJyZW50U2V0dGluZ3MudGltZXMgfHwgZGVsYXkgIT09IGN1cnJlbnRTZXR0aW5ncy5kZWxheSkge1xuICAgICAgICAgIGNvbnN0IG5ld1NldHRpbmdzID0ge1xuICAgICAgICAgICAgdGltZXM6IE51bWJlcih0aW1lcykgfHwgY3VycmVudFNldHRpbmdzLnRpbWVzLFxuICAgICAgICAgICAgZGVsYXk6IE51bWJlcihkZWxheSkgfHwgY3VycmVudFNldHRpbmdzLmRlbGF5XG4gICAgICAgICAgfTtcbiAgICAgICAgICBkZWJvdW5jZWRTYXZlU2V0dGluZ3ModXNlcklkLCBuZXdTZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgfSwgW2N1cnJlbnRTZXR0aW5ncywgZGVib3VuY2VkU2F2ZVNldHRpbmdzXSk7XG5cbiAgLy8gSGFuZGxlIHNldHRpbmdzIGNoYW5nZVxuICBjb25zdCBoYW5kbGVTZXR0aW5nc0NoYW5nZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdTZXR0aW5ncykgPT4ge1xuICAgIGlmICghY3VycmVudFVzZXJJZCkgcmV0dXJuO1xuICAgIGRlYm91bmNlZFNhdmVTZXR0aW5ncyhjdXJyZW50VXNlcklkLCBuZXdTZXR0aW5ncyk7XG4gIH0sIFtjdXJyZW50VXNlcklkLCBkZWJvdW5jZWRTYXZlU2V0dGluZ3NdKTtcblxuICBjb25zdCBoYW5kbGVCdXR0b25DbGljayA9IChhY3Rpb25UeXBlKSA9PiB7XG4gICAgaWYgKG9uQnV0dG9uQ2xpY2spIHtcbiAgICAgIG9uQnV0dG9uQ2xpY2soYWN0aW9uVHlwZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZVRvcEJhciA9ICgpID0+IHtcbiAgICBvblRvZ2dsZVRvcEJhcighaXNUb3BCYXJTaG93bik7XG4gIH07XG4gIFxuICBjb25zdCBoYW5kbGVUb2dnbGVNZXRyaWNzID0gKCkgPT4ge1xuICAgIG9uVG9nZ2xlTWV0cmljcygpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUdvQmFjayA9ICgpID0+IHtcbiAgICByb3V0ZXIucHVzaCgnLycpO1xuICB9O1xuXG4gIGNvbnN0IHN0YXR1c01lc3NhZ2UgPSBgVG9wQmFyICR7aXNUb3BCYXJTaG93biA/ICdzaG93bicgOiAnaGlkZGVuJ30sIENhbnZhczogJHtjYW52YXNTdGF0dXMgPyAnVmlzaWJsZScgOiAnSGlkZGVuJ31gO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ0b3BiYXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9wYmFyLWxlZnRcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2dvXCI+XG4gICAgICAgICAgPGgxIGNsYXNzTmFtZT1cImxvZ28tdGV4dFwiPkxvZ288L2gxPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzLWNvbnRhaW5lclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbC1ncm91cFwiIGtleT17YHRpbWVzLSR7Y3VycmVudFNldHRpbmdzLnRpbWVzfS0ke0RhdGUubm93KCl9YH0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJjb250cm9sLWxhYmVsXCI+VGltZShzKTo8L3NwYW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2wtaW5wdXRcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY29udHJvbC1pbnB1dC1maWVsZFwiPntjdXJyZW50U2V0dGluZ3MudGltZXN9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250cm9sLWdyb3VwXCIga2V5PXtgZGVsYXktJHtjdXJyZW50U2V0dGluZ3MuZGVsYXl9LSR7RGF0ZS5ub3coKX1gfT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNvbnRyb2wtbGFiZWxcIj5EZWxheShzKTo8L3NwYW4+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2wtaW5wdXRcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY29udHJvbC1pbnB1dC1maWVsZFwiPntjdXJyZW50U2V0dGluZ3MuZGVsYXl9PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9wYmFyLW1pZGRsZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1ncm91cHNcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1ncm91cFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJidXR0b24tcm93XCI+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuIGJhY2stYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVHb0JhY2t9XG4gICAgICAgICAgICAgICAgdGl0bGU9XCJHbyBiYWNrIHRvIGhvbWUgcGFnZVwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICDihpAgQmFja1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVCdXR0b25DbGljaygnc2V0UmFuZG9tJyl9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBTZXQgUmFuZG9tXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0blwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQnV0dG9uQ2xpY2soJ2NhbGlicmF0ZScpfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgU2V0IENhbGlicmF0ZVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1yb3dcIiBzdHlsZT17eyBtYXJnaW5SaWdodDogJzgwcHgnIH19PlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0blwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQnV0dG9uQ2xpY2soJ3JhbmRvbURvdCcpfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgUmFuZG9tIERvdFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG5cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUJ1dHRvbkNsaWNrKCdjbGVhckFsbCcpfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ2xlYXIgQWxsXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0b3BiYXItZGl2aWRlclwiPjwvZGl2PlxuICAgICAgICAgIFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLWdyb3VwXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJ1dHRvbi1yb3dcIj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG5cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUJ1dHRvbkNsaWNrKCdoZWFkUG9zZScpfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgRHJhdyBIZWFkIHBvc2VcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuXCJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBoYW5kbGVCdXR0b25DbGljaygnYm91bmRpbmdCb3gnKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFNob3cgQm91bmRpbmcgQm94XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLXJvd1wiPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0blwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gaGFuZGxlQnV0dG9uQ2xpY2soJ3ByZXZpZXcnKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIFNob3cgUHJldmlld1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG5cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUJ1dHRvbkNsaWNrKCdtYXNrJyl9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICDwn5iKIFNob3cgTWFza1xuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJidG5cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGhhbmRsZUJ1dHRvbkNsaWNrKCdwYXJhbWV0ZXJzJyl9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICBcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9wYmFyLXJpZ2h0XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibm90ZXMtY29udGFpbmVyXCI+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm91dHB1dC1kaXNwbGF5XCJcbiAgICAgICAgICAgIHRpdGxlPVwiUHJvY2Vzc2luZyBPdXRwdXRcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtzdGF0dXNNZXNzYWdlfVxuICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICB7b3V0cHV0VGV4dCB8fCBcIlByb2Nlc3Npbmcgb3V0cHV0IHdpbGwgYXBwZWFyIGhlcmUuLi5cIn1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2wtYnV0dG9uc1wiPlxuICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJpY29uLWJ0biBtZW51LWJ0blwiXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVUb2dnbGVUb3BCYXJ9XG4gICAgICAgICAgICB0aXRsZT1cIlRvZ2dsZSBUb3BCYXJcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcGFkZGluZzogJzVweCAxMHB4JyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwNjZjYycsXG4gICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAnNXB4J1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpY29uLXRleHRcIj7iiaE8L3NwYW4+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgXG4gICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImljb24tYnRuIGFsZXJ0LWJ0blwiXG4gICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVUb2dnbGVNZXRyaWNzfVxuICAgICAgICAgICAgdGl0bGU9XCJUb2dnbGUgTWV0cmljc1wiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwYWRkaW5nOiAnNXB4IDEwcHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZmY5OTAwJyxcbiAgICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpY29uLXRleHRcIj4hPC9zcGFuPlxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICA8c3R5bGUganN4PntgXG4gICAgICAgIC5hY3RpdmUtdG9nZ2xlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7XG4gICAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLmljb24tYnRuIHtcbiAgICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4ycyBlYXNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAuaWNvbi1idG46aG92ZXIge1xuICAgICAgICAgIG9wYWNpdHk6IDAuODtcbiAgICAgICAgfVxuICAgICAgYH08L3N0eWxlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVG9wQmFyOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlQ2FsbGJhY2siLCJ1c2VSZWYiLCJ1c2VSb3V0ZXIiLCJ1c2VBZG1pblNldHRpbmdzIiwiZ2V0T3JDcmVhdGVVc2VySWQiLCJkZWJvdW5jZSIsImZ1bmMiLCJ3YWl0IiwidGltZW91dCIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJleGVjdXRlZEZ1bmN0aW9uIiwiYXJncyIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhcHBseSIsIlRvcEJhciIsIm9uQnV0dG9uQ2xpY2siLCJvbkNhbWVyYUFjY2VzcyIsIm91dHB1dFRleHQiLCJvbk91dHB1dENoYW5nZSIsIm9uVG9nZ2xlVG9wQmFyIiwib25Ub2dnbGVNZXRyaWNzIiwiY2FudmFzUmVmIiwiaXNUb3BCYXJTaG93biIsImlzQ2FudmFzVmlzaWJsZSIsInJvdXRlciIsImNhbnZhc1N0YXR1cyIsInNldENhbnZhc1N0YXR1cyIsInNldHRpbmdzIiwidXBkYXRlU2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzTG9hZGluZyIsInNldElzTG9hZGluZyIsImN1cnJlbnRTZXR0aW5ncyIsInNldEN1cnJlbnRTZXR0aW5ncyIsInRpbWVzIiwiZGVsYXkiLCJpc1VwZGF0aW5nUmVmIiwiZmV0Y2hTZXR0aW5ncyIsInVzZXJJZCIsImN1cnJlbnQiLCJyZXNwb25zZSIsImZldGNoIiwiaGVhZGVycyIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfS0VZIiwib2siLCJFcnJvciIsInVzZXJTZXR0aW5ncyIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJkZWJvdW5jZWRTYXZlU2V0dGluZ3MiLCJuZXdTZXR0aW5ncyIsIm1ldGhvZCIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwibGF0ZXN0U2V0dGluZ3MiLCJpbml0aWFsaXplVXNlcklkIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJuZXdVc2VySWQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVNldHRpbmdzVXBkYXRlIiwidHlwZSIsIk51bWJlciIsImhhbmRsZVNldHRpbmdzQ2hhbmdlIiwiaGFuZGxlQnV0dG9uQ2xpY2siLCJhY3Rpb25UeXBlIiwiaGFuZGxlVG9nZ2xlVG9wQmFyIiwiaGFuZGxlVG9nZ2xlTWV0cmljcyIsImhhbmRsZUdvQmFjayIsInB1c2giLCJzdGF0dXNNZXNzYWdlIiwiZGl2IiwiaDEiLCJzcGFuIiwiRGF0ZSIsIm5vdyIsImJ1dHRvbiIsIm9uQ2xpY2siLCJ0aXRsZSIsInN0eWxlIiwibWFyZ2luUmlnaHQiLCJiciIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsImJvcmRlciIsImJvcmRlclJhZGl1cyIsImZvbnRTaXplIiwiY3Vyc29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/topBar.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/index.js":
/*!*****************************************************!*\
  !*** ./pages/collected-dataset-customized/index.js ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CollectedDatasetPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/head */ \"(pages-dir-browser)/./node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_gui_topBar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components-gui/topBar */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/topBar.js\");\n/* harmony import */ var _components_gui_displayResponse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components-gui/displayResponse */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/displayResponse.js\");\n/* harmony import */ var _components_gui_actionButton__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components-gui/actionButton */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../components/consent/ConsentContext */ \"(pages-dir-browser)/./components/consent/ConsentContext.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_9__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// Modified index.js - Fixing canvas reference issues\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n// import { generateCalibrationPoints } from '../../components/collected-dataset-customized/Action/CalibratePoints';\n\n\n// Dynamically load the video processor component (not the hook directly)\nconst VideoProcessorComponent = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_pages_collected-dataset-customized_components-gui_VideoProcessorComponent_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/VideoProcessorComponent */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/VideoProcessorComponent.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"pages/collected-dataset-customized/index.js -> \" + \"./components-gui/VideoProcessorComponent\"\n        ]\n    },\n    ssr: false\n});\n_c = VideoProcessorComponent;\n// Dynamically import the camera component with SSR disabled\nconst DynamicCameraAccess = next_dynamic__WEBPACK_IMPORTED_MODULE_3___default()(()=>__webpack_require__.e(/*! import() */ \"_pages-dir-browser_pages_collected-dataset-customized_components-gui_cameraAccess_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./components-gui/cameraAccess */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/cameraAccess.js\")), {\n    loadableGenerated: {\n        modules: [\n            \"pages/collected-dataset-customized/index.js -> \" + \"./components-gui/cameraAccess\"\n        ]\n    },\n    ssr: false,\n    loading: ()=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            style: {\n                position: 'absolute',\n                top: '50%',\n                left: '50%',\n                transform: 'translate(-50%, -50%)',\n                width: '480px',\n                height: '360px',\n                backgroundColor: '#f0f8ff',\n                border: '2px solid #0066cc',\n                borderRadius: '8px',\n                display: 'flex',\n                flexDirection: 'column',\n                justifyContent: 'center',\n                alignItems: 'center',\n                textAlign: 'center',\n                zIndex: 999\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    style: {\n                        fontSize: '48px',\n                        marginBottom: '15px'\n                    },\n                    children: \"\\uD83D\\uDCF7\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 42,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    style: {\n                        fontSize: '16px',\n                        fontWeight: 'bold',\n                        color: '#0066cc'\n                    },\n                    children: \"Loading camera...\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 43,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n            lineNumber: 25,\n            columnNumber: 7\n        }, undefined)\n});\n_c1 = DynamicCameraAccess;\nfunction CollectedDatasetPage() {\n    _s();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_9__.useRouter)();\n    const { userId: consentUserId } = (0,_components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_8__.useConsent)();\n    const [userData, setUserData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isHydrated, setIsHydrated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [backendStatus, setBackendStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('checking');\n    const [showTopBar, setShowTopBar] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showWarning, setShowWarning] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [warningMessage, setWarningMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [statusMessage, setStatusMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [outputText, setOutputText] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [showMetrics, setShowMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [cameraPermissionGranted, setCameraPermissionGranted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showCamera, setShowCamera] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showCameraPlaceholder, setShowCameraPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [windowSize, setWindowSize] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0,\n        percentage: 100\n    });\n    const [metrics, setMetrics] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: '---',\n        height: '---',\n        distance: '---'\n    });\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [captureFolder, setCaptureFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [showSettings, setShowSettings] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Refs\n    const previewAreaRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const actionButtonGroupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Set hydrated state after mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            setIsHydrated(true);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Load user data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const loadUserData = {\n                \"CollectedDatasetPage.useEffect.loadUserData\": async ()=>{\n                    if (!router.isReady) return;\n                    try {\n                        if (router.query.userData) {\n                            const parsedData = JSON.parse(router.query.userData);\n                            setUserData(parsedData);\n                            return;\n                        }\n                        if (router.query.userId) {\n                            const response = await fetch(\"/user-preferences/\".concat(router.query.userId), {\n                                headers: {\n                                    'Accept': 'application/json',\n                                    'Content-Type': 'application/json',\n                                    'X-API-Key': process.env.NEXT_PUBLIC_API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV'\n                                }\n                            });\n                            if (!response.ok) {\n                                throw new Error('Failed to fetch user data');\n                            }\n                            const data = await response.json();\n                            setUserData(data);\n                        }\n                    } catch (err) {\n                        console.error('Error loading user data:', err);\n                        setError(err.message);\n                    } finally{\n                        setIsLoading(false);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.loadUserData\"];\n            loadUserData();\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        router.isReady,\n        router.query\n    ]);\n    // Check backend connection\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const checkBackendConnection = {\n                \"CollectedDatasetPage.useEffect.checkBackendConnection\": async ()=>{\n                    try {\n                        const response = await fetch('/api/check-backend-connection');\n                        const data = await response.json();\n                        setBackendStatus(data.connected ? 'connected' : 'disconnected');\n                    } catch (error) {\n                        console.error('Error checking backend connection:', error);\n                        setBackendStatus('disconnected');\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.checkBackendConnection\"];\n            if (isHydrated) {\n                checkBackendConnection();\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Update window size\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const updateDimensions = {\n                \"CollectedDatasetPage.useEffect.updateDimensions\": ()=>{\n                    if (previewAreaRef.current) {\n                        const width = previewAreaRef.current.offsetWidth;\n                        const height = previewAreaRef.current.offsetHeight;\n                        const screenPercentage = window.innerWidth / window.screen.width * 100;\n                        setMetrics({\n                            \"CollectedDatasetPage.useEffect.updateDimensions\": (prev)=>({\n                                    ...prev,\n                                    width,\n                                    height\n                                })\n                        }[\"CollectedDatasetPage.useEffect.updateDimensions\"]);\n                        setWindowSize({\n                            width: window.innerWidth,\n                            height: window.innerHeight,\n                            percentage: Math.round(screenPercentage)\n                        });\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.updateDimensions\"];\n            if (isHydrated) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                return ({\n                    \"CollectedDatasetPage.useEffect\": ()=>window.removeEventListener('resize', updateDimensions)\n                })[\"CollectedDatasetPage.useEffect\"];\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Initialize settings based on user data\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (userData && consentUserId) {\n                console.log('Initializing settings for user:', consentUserId, userData);\n                // Initialize user-specific settings\n                if (userData.preferences) {\n                    const { preferences } = userData;\n                    // Update camera settings if available\n                    if (preferences.cameraSettings) {\n                        const { showHeadPose, showBoundingBox, showMask, showParameters } = preferences.cameraSettings;\n                        setShowHeadPose(showHeadPose || false);\n                        setShowBoundingBox(showBoundingBox || false);\n                        setShowMask(showMask || false);\n                        setShowParameters(showParameters || false);\n                    }\n                    // Update other settings as needed\n                    if (preferences.metrics) {\n                        setShowMetrics(preferences.metrics.show || true);\n                    }\n                    if (preferences.topBar) {\n                        setShowTopBar(preferences.topBar.show || true);\n                    }\n                }\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        userData,\n        consentUserId\n    ]);\n    // Improved get canvas function that tries multiple methods\n    const getMainCanvas = ()=>{\n        // Method 1: Check if we have a direct reference\n        if (canvasRef.current) {\n            console.log(\"Using direct canvasRef.current reference\");\n            return canvasRef.current;\n        }\n        // Method 2: Try to get global reference\n        if ( true && window.whiteScreenCanvas) {\n            console.log(\"Using global whiteScreenCanvas reference\");\n            canvasRef.current = window.whiteScreenCanvas; // Update our ref\n            return window.whiteScreenCanvas;\n        }\n        // Method 3: Try to find via DOM\n        if (typeof document !== 'undefined') {\n            const canvasElement = document.querySelector('.tracking-canvas');\n            if (canvasElement) {\n                console.log(\"Found canvas via DOM selector\");\n                canvasRef.current = canvasElement; // Update our ref\n                if (true) {\n                    window.whiteScreenCanvas = canvasElement; // Update global ref too\n                }\n                return canvasElement;\n            }\n        }\n        console.warn(\"No canvas found via any method\");\n        return null;\n    };\n    // Check if we're on the client or server\n    const isClient = \"object\" !== 'undefined';\n    // Add effect to initialize canvas and make it globally available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Debug info to verify canvas size and availability\n            const canvas = canvasRef.current;\n            if (canvas) {\n                console.log(\"Index.js: Canvas initialized\", {\n                    width: canvas.width,\n                    height: canvas.height\n                });\n                // Make canvas EXPLICITLY available globally\n                window.whiteScreenCanvas = canvas;\n                // Also store canvas dimensions\n                window.canvasDimensions = {\n                    width: canvas.width,\n                    height: canvas.height\n                };\n            } else {\n                console.warn(\"Canvas reference is not available during initialization\");\n            }\n            // Expose canvas initialization function globally\n            window.initializeCanvas = ({\n                \"CollectedDatasetPage.useEffect\": (canvas, parent)=>{\n                    if (!canvas || !parent) {\n                        console.warn('[initializeCanvas] Canvas or parent is null', {\n                            canvas,\n                            parent\n                        });\n                        return false;\n                    }\n                    try {\n                        // Set canvas dimensions to match parent\n                        canvas.width = parent.clientWidth || 800;\n                        canvas.height = parent.clientHeight || 600;\n                        // Clear canvas and set white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        console.log(\"Canvas initialized with dimensions: \".concat(canvas.width, \"x\").concat(canvas.height));\n                        // Update global reference\n                        window.whiteScreenCanvas = canvas;\n                        window.canvasDimensions = {\n                            width: canvas.width,\n                            height: canvas.height\n                        };\n                        return true;\n                    } catch (error) {\n                        console.error('[initializeCanvas] Error initializing canvas:', error);\n                        return false;\n                    }\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n            // Check canvas visibility and force initialization after a brief delay\n            setTimeout({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    const canvas = getMainCanvas();\n                    if (canvas) {\n                        const rect = canvas.getBoundingClientRect();\n                        console.log(\"Canvas initial visibility check:\", {\n                            dimensions: \"\".concat(canvas.width, \"x\").concat(canvas.height),\n                            rectSize: \"\".concat(rect.width, \"x\").concat(rect.height),\n                            isVisible: rect.width > 0 && rect.height > 0\n                        });\n                        // Force initialization if needed\n                        adjustCanvasDimensions();\n                    } else {\n                        console.warn(\"Canvas not found during visibility check\");\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect\"], 500);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    delete window.whiteScreenCanvas;\n                    delete window.canvasDimensions;\n                    delete window.initializeCanvas;\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Improved canvas dimensions adjustment\n    const adjustCanvasDimensions = ()=>{\n        if (!isClient || !isHydrated || !previewAreaRef.current) return;\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found to adjust dimensions\");\n            return;\n        }\n        const container = previewAreaRef.current;\n        // Get the size of the preview area\n        const rect = container.getBoundingClientRect();\n        // Calculate proper height based on top bar visibility\n        const topBarHeight = showTopBar ? 120 : 0; // Adjust this value based on your top bar's actual height\n        console.log(\"Adjusting canvas dimensions\", {\n            containerWidth: rect.width,\n            containerHeight: rect.height,\n            topBarVisible: showTopBar,\n            calculatedHeight: rect.height\n        });\n        // Set canvas dimensions to match container size with top bar adjustment\n        canvas.width = rect.width;\n        canvas.height = rect.height;\n        // Clear the canvas\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Fill with white background\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        console.log(\"Canvas dimensions adjusted: \".concat(canvas.width, \"x\").concat(canvas.height));\n        // Update global reference with current dimensions\n        window.whiteScreenCanvas = canvas;\n        window.canvasDimensions = {\n            width: canvas.width,\n            height: canvas.height\n        };\n    };\n    // Create a capture folder on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!captureFolder && isClient && isHydrated) {\n                const timestamp = new Date().toISOString().replace(/[:\\.]/g, '-');\n                setCaptureFolder(\"session_\".concat(timestamp));\n                console.log(\"Created capture folder: session_\".concat(timestamp));\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        captureFolder,\n        isClient,\n        isHydrated\n    ]);\n    // Check backend connection on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return; // Skip on server or before hydration\n            const checkBackendConnection = {\n                \"CollectedDatasetPage.useEffect.checkBackendConnection\": async ()=>{\n                    try {\n                        const response = await fetch('/api/check-backend-connection');\n                        const data = await response.json();\n                        setBackendStatus(data.connected ? 'connected' : 'disconnected');\n                        console.log(\"Backend connection: \".concat(data.connected ? 'OK' : 'Failed'));\n                        // Show status in output text\n                        setOutputText(\"Backend \".concat(data.connected ? 'connected' : 'disconnected - using mock mode'));\n                    } catch (error) {\n                        console.error('Error checking backend connection:', error);\n                        setBackendStatus('disconnected');\n                        setOutputText('Backend disconnected - using mock mode');\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.checkBackendConnection\"];\n            checkBackendConnection();\n            // Welcome message after backend check\n            setTimeout({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    setOutputText('Camera system ready. Click \"Show Preview\" to start camera.');\n                }\n            }[\"CollectedDatasetPage.useEffect\"], 2000);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Add styles to document head for button highlighting\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Create a style element\n            const style = document.createElement('style');\n            style.textContent = \"\\n      @keyframes pulse {\\n        0% { box-shadow: 0 0 0 0 rgba(0, 102, 204, 0.7); }\\n        70% { box-shadow: 0 0 0 10px rgba(0, 102, 204, 0); }\\n        100% { box-shadow: 0 0 0 0 rgba(0, 102, 204, 0); }\\n      }\\n      \\n      @keyframes fadeIn {\\n        from { opacity: 0; transform: translateY(-10px); }\\n        to { opacity: 1; transform: translateY(0); }\\n      }\\n      \\n      .btn-highlight {\\n        animation: pulse 1.5s infinite;\\n        background-color: #0099ff !important;\\n        color: white !important;\\n        transform: scale(1.05);\\n        transition: all 0.3s ease;\\n      }\\n      \\n      .warning-banner {\\n        animation: fadeIn 0.3s ease-in-out;\\n      }\\n    \";\n            document.head.appendChild(style);\n            // Clean up\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    document.head.removeChild(style);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Make toggleTopBar function available globally\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (!isClient || !isHydrated) return;\n            // Make toggleTopBar available to other components\n            window.toggleTopBar = ({\n                \"CollectedDatasetPage.useEffect\": (show)=>{\n                    setShowTopBar(show);\n                    // Also hide metrics when hiding the top bar\n                    if (!show) {\n                        setShowMetrics(false);\n                    }\n                    // Adjust canvas dimensions after toggling\n                    setTimeout(adjustCanvasDimensions, 100);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    // Clean up\n                    delete window.toggleTopBar;\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        isHydrated\n    ]);\n    // Toggle camera function\n    const toggleCamera = (shouldEnable)=>{\n        if (!isClient || !isHydrated) return;\n        if (shouldEnable) {\n            setShowCamera(true);\n            setShowCameraPlaceholder(false);\n            setOutputText('Camera preview started');\n        } else {\n            setShowCamera(false);\n            setShowCameraPlaceholder(false);\n            setOutputText('Camera preview stopped');\n        }\n    };\n    // Handler for action button clicks\n    const handleActionButtonClick = (actionType, params)=>{\n        if (!isClient || !isHydrated) return;\n        // Special case for toggling the top bar\n        if (actionType === 'toggleTopBar') {\n            // const newTopBarState = value !== undefined ? !!value : !showTopBar;\n            let newTopBarState;\n            if (typeof params === 'boolean') {\n                newTopBarState = params;\n            } else if (params && typeof params.value !== 'undefined') {\n                newTopBarState = !!params.value;\n            } else {\n                newTopBarState = !showTopBar;\n            }\n            setShowTopBar(newTopBarState);\n            // Also hide metrics when hiding the top bar\n            if (!newTopBarState) {\n                setShowMetrics(false);\n            }\n            setOutputText(\"TopBar \".concat(newTopBarState ? 'shown' : 'hidden').concat(!newTopBarState ? ', Metrics hidden' : ''));\n            // Adjust canvas dimensions after toggling\n            setTimeout(adjustCanvasDimensions, 100);\n            return;\n        }\n        const canvas = getMainCanvas();\n        setShowWarning(false);\n        // Clear any existing warnings\n        const safeParams = params || {};\n        // Use safeParams instead of controlValues\n        const randomTimes = safeParams.randomTimes || 1;\n        const delaySeconds = safeParams.delaySeconds || 3;\n        switch(actionType){\n            case 'preview':\n                // Toggle camera state\n                if (showCamera) {\n                    toggleCamera(false);\n                } else if (cameraPermissionGranted) {\n                    toggleCamera(true);\n                } else {\n                    // Otherwise show permission popup\n                    setShowPermissionPopup(true);\n                    setOutputText('Opening camera preview');\n                    setShowCameraPlaceholder(true);\n                }\n                break;\n            case 'setRandom':\n                setOutputText('Starting random sequence...');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                // Use the imported module approach - similar to calibrate\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleSetRandom) {\n                    // Use the reference method if available\n                    console.log('Using ActionButtonGroup ref method for Set Random');\n                    actionButtonGroupRef.current.handleSetRandom();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleSetRandom === 'function') {\n                    // Fallback to global method\n                    console.log('Using global bridge method for Set Random');\n                    window.actionButtonFunctions.handleSetRandom();\n                } else {\n                    // Make sure we have a canvas to work with\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for random sequence\");\n                        setOutputText(\"Error: Canvas not available for random sequence\");\n                        setShowTopBar(true);\n                        return;\n                    }\n                    // Get control values from the TopBar\n                    const timeInput = document.querySelector('.control-input-field');\n                    const delayInput = document.querySelectorAll('.control-input-field')[1];\n                    // Default values if inputs can't be found\n                    let times = 1;\n                    let delay = 3;\n                    // Parse input values if available\n                    if (timeInput) {\n                        const parsedTime = parseInt(timeInput.value, 10);\n                        if (!isNaN(parsedTime) && parsedTime > 0) {\n                            times = parsedTime;\n                        }\n                    }\n                    if (delayInput) {\n                        const parsedDelay = parseInt(delayInput.value, 10);\n                        if (!isNaN(parsedDelay) && parsedDelay > 0) {\n                            delay = parsedDelay;\n                        }\n                    }\n                    // Load all required modules first, then proceed with execution\n                    Promise.all([\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\"))\n                    ]).then(async (param)=>{\n                        let [countSaveModule, savefileModule] = param;\n                        // Destructure the imported modules\n                        const { getRandomPosition, drawRedDot, runCountdown, showCapturePreview } = countSaveModule;\n                        const { captureImagesAtPoint } = savefileModule;\n                        try {\n                            // Process all captures sequentially\n                            let successCount = 0;\n                            let currentCapture = 1;\n                            while(currentCapture <= times){\n                                // Update status for current capture\n                                setOutputText(\"Capture \".concat(currentCapture, \" of \").concat(times));\n                                // Clear canvas before each capture\n                                const ctx = canvas.getContext('2d');\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                // Generate random position for this capture\n                                const position = getRandomPosition(canvas, 20);\n                                // Draw the dot\n                                drawRedDot(ctx, position.x, position.y);\n                                // Create a redrawInterval to ensure dot stays visible\n                                let redrawInterval = setInterval(()=>{\n                                    drawRedDot(ctx, position.x, position.y, 12, false);\n                                }, 200);\n                                // Run countdown and wait for it to complete\n                                await new Promise((resolve)=>{\n                                    runCountdown(position, canvas, (status)=>{\n                                        // Update UI based on status\n                                        if (status.processStatus) {\n                                            setOutputText(\"Capture \".concat(currentCapture, \"/\").concat(times, \": \").concat(status.processStatus));\n                                        }\n                                    }, resolve // This will be called when countdown completes\n                                    );\n                                });\n                                // Clear redrawInterval after countdown\n                                clearInterval(redrawInterval);\n                                // Wait briefly after countdown\n                                await new Promise((resolve)=>setTimeout(resolve, 500));\n                                // Capture images at this point\n                                try {\n                                    const captureResult = await captureImagesAtPoint({\n                                        point: position,\n                                        captureCount: captureCounter,\n                                        canvasRef: {\n                                            current: canvas\n                                        },\n                                        setCaptureCount: setCaptureCounter,\n                                        showCapturePreview\n                                    });\n                                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                        successCount++;\n                                    }\n                                    // Increment counter\n                                    setCaptureCounter((prev)=>prev + 1);\n                                } catch (error) {\n                                    console.error(\"Error capturing point \".concat(currentCapture, \":\"), error);\n                                }\n                                // Wait between captures for the specified delay time\n                                if (currentCapture < times) {\n                                    setOutputText(\"Waiting \".concat(delay, \"s before next capture...\"));\n                                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                                }\n                                // Move to next capture\n                                currentCapture++;\n                            }\n                            // Sequence complete\n                            setOutputText(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n                        } catch (error) {\n                            console.error(\"Random sequence error:\", error);\n                            setOutputText(\"Random sequence error: \".concat(error.message));\n                        } finally{\n                            // Show TopBar again\n                            setTimeout(()=>setShowTopBar(true), 2000);\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to import required modules:\", error);\n                        setOutputText(\"Error: \".concat(error.message));\n                        setShowTopBar(true);\n                    });\n                }\n                break;\n            case 'randomDot':\n                setOutputText('Random dot action triggered');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                console.log('Attempting to access Random Dot functionality');\n                // Use the random dot functionality from actionButton.js by delegating to ActionButtonGroup\n                // This assumes you have a ref to the ActionButtonGroup component\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleRandomDot) {\n                    console.log('Using ref method');\n                    actionButtonGroupRef.current.handleRandomDot();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleRandomDot === 'function') {\n                    console.log('Using global bridge method');\n                    window.actionButtonFunctions.handleRandomDot();\n                } else {\n                    // Fallback implementation\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for random dot action\");\n                        setOutputText(\"Error: Canvas not available for random dot\");\n                        setShowTopBar(true); // Show TopBar again if there's an error\n                        break;\n                    }\n                    const parent = previewAreaRef.current;\n                    if (!parent) {\n                        console.error(\"Parent not found for canvas\");\n                        setOutputText(\"Error: Canvas parent not available\");\n                        setShowTopBar(true);\n                        break;\n                    }\n                    // Initialize canvas explicitly\n                    canvas.width = parent.clientWidth || 800;\n                    canvas.height = parent.clientHeight || 600;\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    console.log(\"Canvas ready for random dot: \".concat(canvas.width, \"x\").concat(canvas.height));\n                    // Update global reference\n                    window.whiteScreenCanvas = canvas;\n                    // Generate random position\n                    const position = (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.getRandomPosition)(canvas, 20);\n                    // Draw the dot using the imported function\n                    const dot = (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.drawRedDot)(ctx, position.x, position.y, 8, false);\n                    console.log(\"Random dot drawn at: \".concat(position.x, \", \").concat(position.y));\n                    // Start a countdown for capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.runCountdown)(position, canvas, (status)=>{\n                        // Update UI based on status\n                        if (status.processStatus) {\n                            setOutputText(status.processStatus);\n                        }\n                    }, ()=>{\n                        // Enable camera before capture\n                        // triggerCameraAccess(true);\n                        // Wait briefly for camera to initialize\n                        setTimeout(()=>{\n                            // Use the directly imported captureImagesAtPoint from the Helper/savefile.js\n                            Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\")).then((param)=>{\n                                let { captureImagesAtPoint } = param;\n                                captureImagesAtPoint({\n                                    point: position,\n                                    captureCount: captureCounter,\n                                    canvasRef: {\n                                        current: canvas\n                                    },\n                                    setCaptureCount: setCaptureCounter,\n                                    showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_7__.showCapturePreview\n                                }).then(()=>{\n                                    setCaptureCounter((prev)=>prev + 1);\n                                    // Show TopBar again after capture\n                                    setTimeout(()=>{\n                                        setShowTopBar(true);\n                                    }, 2200);\n                                }).catch((err)=>{\n                                    console.error(\"Error capturing images:\", err);\n                                    setOutputText(\"Error: \".concat(err.message));\n                                    setShowTopBar(true);\n                                });\n                            }).catch((err)=>{\n                                console.error(\"Error importing savefile module:\", err);\n                                setOutputText(\"Error: \".concat(err.message));\n                                setShowTopBar(true);\n                            });\n                        }, 500);\n                    });\n                }\n                break;\n            case 'headPose':\n                const newHeadPoseState = !showHeadPose;\n                setShowHeadPose(newHeadPoseState);\n                setOutputText(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n                if (newHeadPoseState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newHeadPoseState && !showBoundingBox && !showMask && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showHeadPose: newHeadPoseState\n                    });\n                }\n                break;\n            case 'boundingBox':\n                const newBoundingBoxState = !showBoundingBox;\n                setShowBoundingBox(newBoundingBoxState);\n                setOutputText(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n                if (newBoundingBoxState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newBoundingBoxState && !showHeadPose && !showMask && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showBoundingBox: newBoundingBoxState\n                    });\n                }\n                break;\n            case 'mask':\n                const newMaskState = !showMask;\n                setShowMask(newMaskState);\n                setOutputText(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n                if (newMaskState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newMaskState && !showHeadPose && !showBoundingBox && !showParameters) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showMask: newMaskState\n                    });\n                }\n                break;\n            case 'parameters':\n                const newParametersState = !showParameters;\n                setShowParameters(newParametersState);\n                setOutputText(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n                if (newParametersState && !showCamera) {\n                    setShowCameraPlaceholder(true);\n                } else if (!newParametersState && !showHeadPose && !showBoundingBox && !showMask) {\n                    setShowCameraPlaceholder(false);\n                }\n                // Update processor options if camera is active\n                if (showCamera && window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        ...window.videoProcessor.options,\n                        showParameters: newParametersState\n                    });\n                }\n                break;\n            // Fixed calibrate case handler in index.js\n            case 'calibrate':\n                setOutputText('Starting calibration sequence...');\n                setShowTopBar(false);\n                if (showCamera) {\n                    toggleCamera(false);\n                }\n                if (actionButtonGroupRef.current && actionButtonGroupRef.current.handleSetCalibrate) {\n                    // Use the reference method if available\n                    console.log('Using ActionButtonGroup ref method for calibration');\n                    actionButtonGroupRef.current.handleSetCalibrate();\n                } else if ( true && window.actionButtonFunctions && typeof window.actionButtonFunctions.handleSetCalibrate === 'function') {\n                    // Fallback to global method\n                    console.log('Using global bridge method for calibration');\n                    window.actionButtonFunctions.handleSetCalibrate();\n                } else {\n                    // Make sure we have a canvas to work with\n                    const canvas = getMainCanvas();\n                    if (!canvas) {\n                        console.error(\"Canvas not found for calibration\");\n                        setOutputText(\"Error: Canvas not available for calibration\");\n                        setShowTopBar(true);\n                        return;\n                    }\n                    // Load all required modules first, then proceed with execution\n                    Promise.all([\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\")),\n                        Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\"))\n                    ]).then(async (param)=>{\n                        let [calibratePointsModule, countSaveModule, savefileModule] = param;\n                        // Destructure the imported modules\n                        const { generateCalibrationPoints } = calibratePointsModule;\n                        const { drawRedDot, runCountdown, showCapturePreview } = countSaveModule;\n                        const { captureImagesAtPoint } = savefileModule;\n                        try {\n                            // Generate calibration points\n                            const points = generateCalibrationPoints(canvas.width, canvas.height);\n                            if (!points || points.length === 0) {\n                                throw new Error(\"Failed to generate calibration points\");\n                            }\n                            // Create status indicator\n                            const statusIndicator = document.createElement('div');\n                            statusIndicator.className = 'calibrate-status-indicator';\n                            statusIndicator.style.cssText = \"\\n                position: fixed;\\n                top: 10px;\\n                right: 10px;\\n                background-color: rgba(0, 102, 204, 0.9);\\n                color: white;\\n                font-size: 14px;\\n                font-weight: bold;\\n                padding: '8px 12px';\\n                border-radius: 6px;\\n                z-index: 9999;\\n                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n              \";\n                            statusIndicator.textContent = 'Calibration: Initializing...';\n                            document.body.appendChild(statusIndicator);\n                            // Access webcam before starting calibration if available\n                            if (typeof triggerCameraAccess === 'function') {\n                                triggerCameraAccess(true);\n                                await new Promise((resolve)=>setTimeout(resolve, 500));\n                            }\n                            // Process points sequentially\n                            let successCount = 0;\n                            for(let i = 0; i < points.length; i++){\n                                const point = points[i];\n                                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                                setOutputText(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                                // Clear the canvas before drawing new point\n                                const ctx = canvas.getContext('2d');\n                                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                                ctx.fillStyle = 'white';\n                                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                                // Draw the dot\n                                drawRedDot(ctx, point.x, point.y);\n                                // Run countdown\n                                await new Promise((resolve)=>{\n                                    runCountdown(point, canvas, (status)=>{\n                                        if (status.processStatus) {\n                                            setOutputText(status.processStatus);\n                                        }\n                                    }, resolve // This will be called when countdown completes\n                                    );\n                                });\n                                // Capture images at this point\n                                try {\n                                    const captureResult = await captureImagesAtPoint({\n                                        point: point,\n                                        captureCount: captureCounter,\n                                        canvasRef: {\n                                            current: canvas\n                                        },\n                                        setCaptureCount: setCaptureCounter,\n                                        showCapturePreview: showCapturePreview\n                                    });\n                                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                        successCount++;\n                                    }\n                                    // Increment counter\n                                    setCaptureCounter((prev)=>prev + 1);\n                                } catch (error) {\n                                    console.error(\"Error capturing point \".concat(i + 1, \":\"), error);\n                                }\n                                // Wait between points\n                                await new Promise((resolve)=>setTimeout(resolve, 1200));\n                            }\n                            // Calibration complete\n                            statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                            setOutputText(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                            // Remove the status indicator after a delay\n                            setTimeout(()=>{\n                                if (statusIndicator.parentNode) {\n                                    statusIndicator.parentNode.removeChild(statusIndicator);\n                                }\n                            }, 3000);\n                        } catch (error) {\n                            console.error(\"Calibration error:\", error);\n                            setOutputText(\"Calibration error: \".concat(error.message));\n                        } finally{\n                            // Show TopBar again\n                            setTimeout(()=>setShowTopBar(true), 2000);\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Failed to import required modules:\", error);\n                        setOutputText(\"Calibration error: \".concat(error.message));\n                        setShowTopBar(true);\n                    });\n                }\n                break;\n            case 'clearAll':\n                // Clear canvas\n                // const canvas = getMainCanvas();\n                if (canvas) {\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    setOutputText('Canvas cleared');\n                }\n                break;\n            default:\n                setOutputText(\"Action triggered: \".concat(actionType));\n        }\n    };\n    const handlePermissionAccepted = ()=>{\n        if (!isClient || !isHydrated) return;\n        setShowPermissionPopup(false);\n        setCameraPermissionGranted(true);\n        toggleCamera(true);\n    };\n    const handlePermissionDenied = ()=>{\n        if (!isClient || !isHydrated) return;\n        setShowPermissionPopup(false);\n        setShowCameraPlaceholder(false);\n        setOutputText('Camera permission denied');\n    };\n    const handleCameraClose = ()=>{\n        if (!isClient || !isHydrated) return;\n        toggleCamera(false);\n    };\n    const handleCameraReady = (dimensions)=>{\n        if (!isClient || !isHydrated) return;\n        setMetrics({\n            width: dimensions.width,\n            height: dimensions.height,\n            distance: dimensions.distance || '---'\n        });\n        setOutputText(\"Camera ready: \".concat(dimensions.width, \"x\").concat(dimensions.height));\n    };\n    // Toggle top bar function\n    const toggleTopBar = (show)=>{\n        const newTopBarState = show !== undefined ? show : !showTopBar;\n        setShowTopBar(newTopBarState);\n        // Also hide metrics when hiding the top bar\n        if (!newTopBarState) {\n            setShowMetrics(false);\n        }\n        setOutputText(\"TopBar \".concat(newTopBarState ? 'shown' : 'hidden').concat(!newTopBarState ? ', Metrics hidden' : ''));\n        // Wait for state update and DOM changes, then adjust canvas\n        setTimeout(adjustCanvasDimensions, 100);\n    };\n    // Toggle metrics function\n    const toggleMetrics = ()=>{\n        if (showTopBar) {\n            setShowMetrics((prev)=>!prev);\n            setOutputText(\"Metrics \".concat(!showMetrics ? 'shown' : 'hidden'));\n        } else {\n            // If topBar is hidden, we can't show metrics\n            setOutputText('Cannot show metrics when TopBar is hidden');\n        }\n    };\n    // Function to trigger camera access\n    const triggerCameraAccess = (forceEnable)=>{\n        if (forceEnable) {\n            // Try to enable camera directly\n            if (window.videoProcessor) {\n                setShowCamera(true);\n                setShowCameraPlaceholder(false);\n                setCameraPermissionGranted(true);\n                // Start video processing with current options\n                window.videoProcessor.startVideoProcessing({\n                    showHeadPose,\n                    showBoundingBox,\n                    showMask,\n                    showParameters,\n                    showProcessedImage: true\n                });\n                return true;\n            }\n            return false;\n        }\n        // Just toggle current state if not forcing\n        if (cameraPermissionGranted) {\n            toggleCamera(!showCamera);\n            return true;\n        } else {\n            setShowPermissionPopup(true);\n            return false;\n        }\n    };\n    // Dynamic class to reflect current window size\n    const getSizeClass = ()=>{\n        const { percentage } = windowSize;\n        if (percentage < 35) return 'window-size-tiny';\n        if (percentage < 50) return 'window-size-small';\n        if (percentage < 70) return 'window-size-medium';\n        return 'window-size-large';\n    };\n    // Add this function to handle settings visibility\n    const handleSettingsVisibility = (isVisible)=>{\n        setShowSettings(isVisible);\n    };\n    // Add this effect to listen for settings visibility changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleSettingsMessage = {\n                \"CollectedDatasetPage.useEffect.handleSettingsMessage\": (event)=>{\n                    if (event.data.type === 'SHOW_SETTINGS') {\n                        setShowSettings(event.data.show);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleSettingsMessage\"];\n            window.addEventListener('message', handleSettingsMessage);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('message', handleSettingsMessage);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"CollectedDatasetPage.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        setCurrentUserId(event.detail.userId);\n                        // Dispatch event to update settings for the new user\n                        const event = new CustomEvent('captureSettingsUpdate', {\n                            detail: {\n                                type: 'captureSettings',\n                                userId: event.detail.userId\n                            }\n                        });\n                        window.dispatchEvent(event);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], []);\n    // Initialize settings when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (consentUserId) {\n                // Set the current user ID\n                setCurrentUserId(consentUserId);\n                // Dispatch event to update settings for this user\n                const event = new CustomEvent('captureSettingsUpdate', {\n                    detail: {\n                        type: 'captureSettings',\n                        userId: consentUserId\n                    }\n                });\n                window.dispatchEvent(event);\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Load settings from backend when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const loadSettings = {\n                \"CollectedDatasetPage.useEffect.loadSettings\": async ()=>{\n                    if (!consentUserId) return;\n                    try {\n                        const response = await fetch(\"/api/data-center/settings/\".concat(consentUserId));\n                        if (!response.ok) {\n                            throw new Error('Failed to load settings');\n                        }\n                        const loadedSettings = await response.json();\n                        // Wait for the component to be mounted and ref to be initialized\n                        const waitForRef = {\n                            \"CollectedDatasetPage.useEffect.loadSettings.waitForRef\": function() {\n                                let retries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 5;\n                                if (actionButtonGroupRef.current && typeof actionButtonGroupRef.current.updateSettings === 'function') {\n                                    // Update the settings for this user\n                                    actionButtonGroupRef.current.updateSettings(loadedSettings);\n                                    // Dispatch event to update UI\n                                    const event = new CustomEvent('captureSettingsUpdate', {\n                                        detail: {\n                                            type: 'captureSettings',\n                                            userId: consentUserId,\n                                            times: loadedSettings.times,\n                                            delay: loadedSettings.delay\n                                        }\n                                    });\n                                    window.dispatchEvent(event);\n                                } else if (retries > 0) {\n                                    setTimeout({\n                                        \"CollectedDatasetPage.useEffect.loadSettings.waitForRef\": ()=>waitForRef(retries - 1)\n                                    }[\"CollectedDatasetPage.useEffect.loadSettings.waitForRef\"], 500);\n                                } else {\n                                    console.warn('ActionButtonGroup ref not initialized after retries');\n                                }\n                            }\n                        }[\"CollectedDatasetPage.useEffect.loadSettings.waitForRef\"];\n                        waitForRef();\n                    } catch (error) {\n                        console.error('Error loading settings:', error);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.loadSettings\"];\n            // Add a small delay to ensure components are mounted\n            setTimeout(loadSettings, 1000);\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Add polling for real-time updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const fetchUpdates = {\n                \"CollectedDatasetPage.useEffect.fetchUpdates\": async ()=>{\n                    if (!consentUserId) return;\n                    try {\n                        const response = await fetch(\"/api/data-center/settings/\".concat(consentUserId));\n                        if (!response.ok) throw new Error('Failed to fetch settings');\n                        const settings = await response.json();\n                        if (actionButtonGroupRef.current && actionButtonGroupRef.current.updateSettings) {\n                            actionButtonGroupRef.current.updateSettings(settings);\n                        }\n                    // You can add image fetching logic here if needed\n                    } catch (error) {\n                        console.error('Error fetching updates:', error);\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.fetchUpdates\"];\n            // Initial fetch\n            fetchUpdates();\n            // Set up polling interval\n            const interval = setInterval(fetchUpdates, 3000);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    clearInterval(interval);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Add event listeners for settings and image updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"CollectedDatasetPage.useEffect.handleSettingsUpdate\": (event)=>{\n                    var _event_detail, _event_detail1;\n                    if (((_event_detail = event.detail) === null || _event_detail === void 0 ? void 0 : _event_detail.type) === 'captureSettings' && ((_event_detail1 = event.detail) === null || _event_detail1 === void 0 ? void 0 : _event_detail1.userId) === consentUserId) {\n                        const { times, delay } = event.detail;\n                        if (actionButtonGroupRef.current && actionButtonGroupRef.current.updateSettings) {\n                            actionButtonGroupRef.current.updateSettings({\n                                times,\n                                delay\n                            });\n                        }\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleSettingsUpdate\"];\n            const handleImageUpdate = {\n                \"CollectedDatasetPage.useEffect.handleImageUpdate\": (event)=>{\n                    var _event_detail, _event_detail1;\n                    if (((_event_detail = event.detail) === null || _event_detail === void 0 ? void 0 : _event_detail.type) === 'image' && ((_event_detail1 = event.detail) === null || _event_detail1 === void 0 ? void 0 : _event_detail1.userId) === consentUserId) {\n                        const { image } = event.detail;\n                    // Update image in the UI if needed\n                    // You can add your image update logic here\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleImageUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            window.addEventListener('imageUpdate', handleImageUpdate);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                    window.removeEventListener('imageUpdate', handleImageUpdate);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId\n    ]);\n    // Load settings for a specific user\n    const loadSettings = async (userId)=>{\n        try {\n            console.log('Loading settings for user:', userId);\n            const response = await fetch(\"/api/data-center/settings/\".concat(userId));\n            if (!response.ok) throw new Error('Failed to fetch settings');\n            const userSettings = await response.json();\n            console.log('Fetched settings:', userSettings);\n            // Dispatch settings update event\n            const event = new CustomEvent('captureSettingsUpdate', {\n                detail: {\n                    type: 'captureSettings',\n                    userId,\n                    ...userSettings\n                }\n            });\n            window.dispatchEvent(event);\n        } catch (error) {\n            console.error('Error loading settings:', error);\n        }\n    };\n    // Handle user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            if (consentUserId && consentUserId !== currentUserId) {\n                console.log('User ID changed in index.js:', consentUserId);\n                setCurrentUserId(consentUserId);\n                // Dispatch event to notify other components\n                const event = new CustomEvent('userIdChange', {\n                    detail: {\n                        userId: consentUserId\n                    }\n                });\n                window.dispatchEvent(event);\n                // Load settings for the new user\n                loadSettings(consentUserId);\n            }\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        consentUserId,\n        currentUserId\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CollectedDatasetPage.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"CollectedDatasetPage.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times, delay } = event.detail;\n                        if (userId === currentUserId) {\n                            // Update the settings for this user\n                            if (actionButtonGroupRef.current && actionButtonGroupRef.current.updateSettings) {\n                                actionButtonGroupRef.current.updateSettings({\n                                    times: times || 1,\n                                    delay: delay || 3\n                                });\n                            }\n                        }\n                    }\n                }\n            }[\"CollectedDatasetPage.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"CollectedDatasetPage.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"CollectedDatasetPage.useEffect\"];\n        }\n    }[\"CollectedDatasetPage.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"main-container \".concat(getSizeClass()),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_2___default()), {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                        children: \"Camera Dataset Collection\"\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1371,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"meta\", {\n                        name: \"viewport\",\n                        content: \"width=device-width, initial-scale=1\"\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1372,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1370,\n                columnNumber: 7\n            }, this),\n            isHydrated && backendStatus === 'disconnected' && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    padding: '6px 0',\n                    backgroundColor: '#ffe0b2',\n                    color: '#e65100',\n                    textAlign: 'center',\n                    fontSize: '14px',\n                    fontWeight: 'bold',\n                    zIndex: 1100\n                },\n                children: \"⚠️ Backend disconnected. Hurry up, Make ONLINE please and Using mock mode\"\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1377,\n                columnNumber: 9\n            }, this),\n            isHydrated && showWarning && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"warning-banner\",\n                style: {\n                    position: 'fixed',\n                    top: showTopBar ? backendStatus === 'disconnected' ? '32px' : '60px' : '0',\n                    left: '0',\n                    width: '100%',\n                    backgroundColor: '#ffeb3b',\n                    color: '#333',\n                    padding: '10px',\n                    textAlign: 'center',\n                    boxShadow: '0 2px 4px rgba(0,0,0,0.2)',\n                    zIndex: 1010,\n                    animation: 'fadeIn 0.3s ease-in-out'\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                    children: [\n                        \"⚠️ \",\n                        warningMessage\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 1409,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1396,\n                columnNumber: 9\n            }, this),\n            isLoading ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"loading-container\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: \"Loading user settings...\"\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                    lineNumber: 1415,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                lineNumber: 1414,\n                columnNumber: 9\n            }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    isHydrated && isClient && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(VideoProcessorComponent, {}, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1420,\n                        columnNumber: 38\n                    }, this),\n                    showTopBar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_topBar__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                        onButtonClick: handleActionButtonClick,\n                        onCameraAccess: ()=>setShowPermissionPopup(true),\n                        outputText: statusMessage || outputText,\n                        onOutputChange: (text)=>setOutputText(text),\n                        onToggleTopBar: toggleTopBar,\n                        onToggleMetrics: toggleMetrics,\n                        canvasRef: canvasRef\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1424,\n                        columnNumber: 13\n                    }, this),\n                    !showTopBar && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"restore-button-container\",\n                        style: {\n                            position: 'fixed',\n                            top: '10px',\n                            right: '10px',\n                            zIndex: 1000\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            className: \"restore-btn\",\n                            onClick: ()=>toggleTopBar(true),\n                            title: \"Show TopBar and Metrics\",\n                            style: {\n                                padding: '5px 10px',\n                                background: '#0066cc',\n                                color: 'white',\n                                border: 'none',\n                                borderRadius: '4px',\n                                fontSize: '16px',\n                                cursor: 'pointer'\n                            },\n                            children: \"≡\"\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                            lineNumber: 1443,\n                            columnNumber: 15\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1437,\n                        columnNumber: 13\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        ref: previewAreaRef,\n                        className: \"camera-preview-area\",\n                        style: {\n                            height: showTopBar ? 'calc(100vh - 120px)' : '100vh',\n                            marginTop: backendStatus === 'disconnected' ? '32px' : '0',\n                            position: 'relative',\n                            backgroundColor: '#f5f5f5',\n                            overflow: 'hidden'\n                        },\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"camera-action-buttons-container\",\n                                style: {\n                                    position: 'absolute',\n                                    bottom: '20px',\n                                    left: '50%',\n                                    transform: 'translateX(-50%)',\n                                    zIndex: 10,\n                                    maxWidth: '600px',\n                                    width: '100%',\n                                    padding: '0 20px'\n                                },\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_actionButton__WEBPACK_IMPORTED_MODULE_6__.ActionButtonGroup, {\n                                    ref: actionButtonGroupRef,\n                                    triggerCameraAccess: triggerCameraAccess,\n                                    isCompactMode: windowSize.width < 768,\n                                    onActionClick: handleActionButtonClick\n                                }, void 0, false, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1485,\n                                    columnNumber: 15\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1475,\n                                columnNumber: 13\n                            }, this),\n                            !showCamera ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"camera-preview-message\",\n                                        style: {\n                                            padding: '20px',\n                                            textAlign: 'center',\n                                            position: showTopBar ? 'relative' : 'absolute',\n                                            width: '100%',\n                                            zIndex: 5\n                                        },\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                children: \"Camera preview will appear here\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                                lineNumber: 1502,\n                                                columnNumber: 19\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"camera-size-indicator\",\n                                                children: [\n                                                    \"Current window: \",\n                                                    windowSize.percentage,\n                                                    \"% of screen width\"\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                                lineNumber: 1503,\n                                                columnNumber: 19\n                                            }, this),\n                                            isHydrated && showCameraPlaceholder && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"camera-placeholder-square\",\n                                                style: {\n                                                    width: '180px',\n                                                    height: '135px',\n                                                    margin: '20px auto',\n                                                    border: '2px dashed #666',\n                                                    borderRadius: '4px',\n                                                    backgroundColor: '#f5f5f5',\n                                                    display: 'flex',\n                                                    alignItems: 'center',\n                                                    justifyContent: 'center'\n                                                },\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    style: {\n                                                        fontSize: '1.5rem'\n                                                    },\n                                                    children: \"\\uD83D\\uDCF7\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                                    lineNumber: 1521,\n                                                    columnNumber: 23\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                                lineNumber: 1507,\n                                                columnNumber: 21\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1495,\n                                        columnNumber: 17\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"canvas-container\",\n                                        style: {\n                                            position: 'absolute',\n                                            top: 0,\n                                            left: 0,\n                                            width: '100%',\n                                            height: '100%',\n                                            backgroundColor: 'white',\n                                            overflow: 'hidden',\n                                            border: 'none',\n                                            zIndex: 10\n                                        }\n                                    }, void 0, false, {\n                                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                        lineNumber: 1527,\n                                        columnNumber: 17\n                                    }, this)\n                                ]\n                            }, void 0, true) : null,\n                            isHydrated && showMetrics && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_gui_displayResponse__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                width: metrics.width,\n                                height: metrics.height,\n                                distance: metrics.distance,\n                                isVisible: showMetrics\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1556,\n                                columnNumber: 15\n                            }, this),\n                            isHydrated && isClient && showCamera && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DynamicCameraAccess, {\n                                isShowing: showCamera,\n                                onClose: handleCameraClose,\n                                onCameraReady: handleCameraReady,\n                                showHeadPose: showHeadPose,\n                                showBoundingBox: showBoundingBox,\n                                showMask: showMask,\n                                showParameters: showParameters,\n                                videoRef: videoRef\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1566,\n                                columnNumber: 15\n                            }, this),\n                            isHydrated && isClient && showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"camera-permission-popup\",\n                                style: {\n                                    position: 'fixed',\n                                    top: 0,\n                                    left: 0,\n                                    width: '100%',\n                                    height: '100%',\n                                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                                    display: 'flex',\n                                    justifyContent: 'center',\n                                    alignItems: 'center',\n                                    zIndex: 2000\n                                },\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"camera-permission-dialog\",\n                                    style: {\n                                        width: '400px',\n                                        backgroundColor: 'white',\n                                        borderRadius: '8px',\n                                        padding: '20px',\n                                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: \"camera-permission-title\",\n                                            style: {\n                                                margin: '0 0 15px',\n                                                fontSize: '18px',\n                                                fontWeight: 'bold'\n                                            },\n                                            children: \"Camera Access Required\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1599,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: \"camera-permission-message\",\n                                            style: {\n                                                margin: '0 0 20px',\n                                                fontSize: '14px',\n                                                lineHeight: '1.4'\n                                            },\n                                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                                        }, void 0, false, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1604,\n                                            columnNumber: 19\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: \"camera-permission-buttons\",\n                                            style: {\n                                                display: 'flex',\n                                                justifyContent: 'flex-end',\n                                                gap: '10px'\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: handlePermissionDenied,\n                                                    className: \"camera-btn\",\n                                                    style: {\n                                                        padding: '8px 16px',\n                                                        backgroundColor: '#f0f0f0',\n                                                        border: 'none',\n                                                        borderRadius: '4px',\n                                                        cursor: 'pointer'\n                                                    },\n                                                    children: \"Cancel\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                                    lineNumber: 1617,\n                                                    columnNumber: 21\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    onClick: handlePermissionAccepted,\n                                                    className: \"camera-btn\",\n                                                    style: {\n                                                        padding: '8px 16px',\n                                                        backgroundColor: '#0066cc',\n                                                        color: 'white',\n                                                        border: 'none',\n                                                        borderRadius: '4px',\n                                                        cursor: 'pointer'\n                                                    },\n                                                    children: \"Continue\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                                    lineNumber: 1630,\n                                                    columnNumber: 21\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                            lineNumber: 1612,\n                                            columnNumber: 19\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                    lineNumber: 1592,\n                                    columnNumber: 17\n                                }, this)\n                            }, void 0, false, {\n                                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                                lineNumber: 1580,\n                                columnNumber: 15\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n                        lineNumber: 1463,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset-customized/index.js\",\n        lineNumber: 1369,\n        columnNumber: 5\n    }, this);\n}\n_s(CollectedDatasetPage, \"dPRoW5+9h6WED+2wlVkeXYK1P7Y=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_9__.useRouter,\n        _components_consent_ConsentContext__WEBPACK_IMPORTED_MODULE_8__.useConsent\n    ];\n});\n_c2 = CollectedDatasetPage;\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"VideoProcessorComponent\");\n$RefreshReg$(_c1, \"DynamicCameraAccess\");\n$RefreshReg$(_c2, \"CollectedDatasetPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxREFBcUQ7OztBQUNNO0FBQzlCO0FBQ007QUFDVTtBQUNrQjtBQUNHO0FBQ3FHO0FBQ3ZLLG9IQUFvSDtBQUMvQztBQUM3QjtBQUV4Qyx5RUFBeUU7QUFDekUsTUFBTWdCLDBCQUEwQlgsbURBQU9BLENBQ3JDLElBQU0sa1ZBQWtEOzs7Ozs7SUFDdERZLEtBQUs7O0tBRkhEO0FBS04sNERBQTREO0FBQzVELE1BQU1FLHNCQUFzQmIsbURBQU9BLENBQ2pDLElBQU0saVRBQXVDOzs7Ozs7SUFFM0NZLEtBQUs7SUFDTEUsU0FBUyxrQkFDUCw4REFBQ0M7WUFBSUMsT0FBTztnQkFDVkMsVUFBVTtnQkFDVkMsS0FBSztnQkFDTEMsTUFBTTtnQkFDTkMsV0FBVztnQkFDWEMsT0FBTztnQkFDUEMsUUFBUTtnQkFDUkMsaUJBQWlCO2dCQUNqQkMsUUFBUTtnQkFDUkMsY0FBYztnQkFDZEMsU0FBUztnQkFDVEMsZUFBZTtnQkFDZkMsZ0JBQWdCO2dCQUNoQkMsWUFBWTtnQkFDWkMsV0FBVztnQkFDWEMsUUFBUTtZQUNWOzs4QkFDRSw4REFBQ2hCO29CQUFJQyxPQUFPO3dCQUFFZ0IsVUFBVTt3QkFBUUMsY0FBYztvQkFBTzs4QkFBRzs7Ozs7OzhCQUN4RCw4REFBQ0M7b0JBQUVsQixPQUFPO3dCQUFFZ0IsVUFBVTt3QkFBUUcsWUFBWTt3QkFBUUMsT0FBTztvQkFBVTs4QkFBRzs7Ozs7Ozs7Ozs7OztNQXZCeEV2QjtBQStCUyxTQUFTd0I7O0lBQ3RCLE1BQU1DLFNBQVM1QixzREFBU0E7SUFDeEIsTUFBTSxFQUFFNkIsUUFBUUMsYUFBYSxFQUFFLEdBQUcvQiw4RUFBVUE7SUFDNUMsTUFBTSxDQUFDZ0MsVUFBVUMsWUFBWSxHQUFHOUMsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxDQUFDK0MsV0FBV0MsYUFBYSxHQUFHaEQsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDaUQsT0FBT0MsU0FBUyxHQUFHbEQsK0NBQVFBLENBQUM7SUFDbkMsTUFBTSxDQUFDbUQsWUFBWUMsY0FBYyxHQUFHcEQsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDcUQsZUFBZUMsaUJBQWlCLEdBQUd0RCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUN1RCxZQUFZQyxjQUFjLEdBQUd4RCwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUN5RCxhQUFhQyxlQUFlLEdBQUcxRCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUMyRCxnQkFBZ0JDLGtCQUFrQixHQUFHNUQsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDNkQsZUFBZUMsaUJBQWlCLEdBQUc5RCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUMrRCxZQUFZQyxjQUFjLEdBQUdoRSwrQ0FBUUEsQ0FBQztJQUM3QyxNQUFNLENBQUNpRSxhQUFhQyxlQUFlLEdBQUdsRSwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNtRSxxQkFBcUJDLHVCQUF1QixHQUFHcEUsK0NBQVFBLENBQUM7SUFDL0QsTUFBTSxDQUFDcUUseUJBQXlCQywyQkFBMkIsR0FBR3RFLCtDQUFRQSxDQUFDO0lBQ3ZFLE1BQU0sQ0FBQ3VFLFlBQVlDLGNBQWMsR0FBR3hFLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ3lFLHVCQUF1QkMseUJBQXlCLEdBQUcxRSwrQ0FBUUEsQ0FBQztJQUNuRSxNQUFNLENBQUMyRSxjQUFjQyxnQkFBZ0IsR0FBRzVFLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQzZFLGlCQUFpQkMsbUJBQW1CLEdBQUc5RSwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUMrRSxVQUFVQyxZQUFZLEdBQUdoRiwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUNpRixnQkFBZ0JDLGtCQUFrQixHQUFHbEYsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDbUYsWUFBWUMsY0FBYyxHQUFHcEYsK0NBQVFBLENBQUM7UUFBRXlCLE9BQU87UUFBR0MsUUFBUTtRQUFHMkQsWUFBWTtJQUFJO0lBQ3BGLE1BQU0sQ0FBQ0MsU0FBU0MsV0FBVyxHQUFHdkYsK0NBQVFBLENBQUM7UUFBRXlCLE9BQU87UUFBT0MsUUFBUTtRQUFPOEQsVUFBVTtJQUFNO0lBQ3RGLE1BQU0sQ0FBQ0MsZ0JBQWdCQyxrQkFBa0IsR0FBRzFGLCtDQUFRQSxDQUFDO0lBQ3JELE1BQU0sQ0FBQzJGLGVBQWVDLGlCQUFpQixHQUFHNUYsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDNkYsZUFBZUMsaUJBQWlCLEdBQUc5RiwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUMrRixjQUFjQyxnQkFBZ0IsR0FBR2hHLCtDQUFRQSxDQUFDO0lBRWpELE9BQU87SUFDUCxNQUFNaUcsaUJBQWlCL0YsNkNBQU1BLENBQUM7SUFDOUIsTUFBTWdHLFlBQVloRyw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNaUcsV0FBV2pHLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU1rRyx1QkFBdUJsRyw2Q0FBTUEsQ0FBQztJQUVwQyxpQ0FBaUM7SUFDakNELGdEQUFTQTswQ0FBQztZQUNSbUQsY0FBYztRQUNoQjt5Q0FBRyxFQUFFO0lBRUwsaUJBQWlCO0lBQ2pCbkQsZ0RBQVNBOzBDQUFDO1lBQ1IsTUFBTW9HOytEQUFlO29CQUNuQixJQUFJLENBQUMzRCxPQUFPNEQsT0FBTyxFQUFFO29CQUVyQixJQUFJO3dCQUNGLElBQUk1RCxPQUFPNkQsS0FBSyxDQUFDMUQsUUFBUSxFQUFFOzRCQUN6QixNQUFNMkQsYUFBYUMsS0FBS0MsS0FBSyxDQUFDaEUsT0FBTzZELEtBQUssQ0FBQzFELFFBQVE7NEJBQ25EQyxZQUFZMEQ7NEJBQ1o7d0JBQ0Y7d0JBRUEsSUFBSTlELE9BQU82RCxLQUFLLENBQUM1RCxNQUFNLEVBQUU7NEJBQ3ZCLE1BQU1nRSxXQUFXLE1BQU1DLE1BQU0scUJBQXlDLE9BQXBCbEUsT0FBTzZELEtBQUssQ0FBQzVELE1BQU0sR0FBSTtnQ0FDdkVrRSxTQUFTO29DQUNQLFVBQVU7b0NBQ1YsZ0JBQWdCO29DQUNoQixhQUFhQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLG1CQUFtQixJQUFJO2dDQUNsRDs0QkFDRjs0QkFDQSxJQUFJLENBQUNMLFNBQVNNLEVBQUUsRUFBRTtnQ0FDaEIsTUFBTSxJQUFJQyxNQUFNOzRCQUNsQjs0QkFDQSxNQUFNQyxPQUFPLE1BQU1SLFNBQVNTLElBQUk7NEJBQ2hDdEUsWUFBWXFFO3dCQUNkO29CQUNGLEVBQUUsT0FBT0UsS0FBSzt3QkFDWkMsUUFBUXJFLEtBQUssQ0FBQyw0QkFBNEJvRTt3QkFDMUNuRSxTQUFTbUUsSUFBSUUsT0FBTztvQkFDdEIsU0FBVTt3QkFDUnZFLGFBQWE7b0JBQ2Y7Z0JBQ0Y7O1lBRUFxRDtRQUNGO3lDQUFHO1FBQUMzRCxPQUFPNEQsT0FBTztRQUFFNUQsT0FBTzZELEtBQUs7S0FBQztJQUVqQywyQkFBMkI7SUFDM0J0RyxnREFBU0E7MENBQUM7WUFDUixNQUFNdUg7eUVBQXlCO29CQUM3QixJQUFJO3dCQUNGLE1BQU1iLFdBQVcsTUFBTUMsTUFBTTt3QkFDN0IsTUFBTU8sT0FBTyxNQUFNUixTQUFTUyxJQUFJO3dCQUNoQzlELGlCQUFpQjZELEtBQUtNLFNBQVMsR0FBRyxjQUFjO29CQUNsRCxFQUFFLE9BQU94RSxPQUFPO3dCQUNkcUUsUUFBUXJFLEtBQUssQ0FBQyxzQ0FBc0NBO3dCQUNwREssaUJBQWlCO29CQUNuQjtnQkFDRjs7WUFFQSxJQUFJSCxZQUFZO2dCQUNkcUU7WUFDRjtRQUNGO3lDQUFHO1FBQUNyRTtLQUFXO0lBRWYscUJBQXFCO0lBQ3JCbEQsZ0RBQVNBOzBDQUFDO1lBQ1IsTUFBTXlIO21FQUFtQjtvQkFDdkIsSUFBSXpCLGVBQWUwQixPQUFPLEVBQUU7d0JBQzFCLE1BQU1sRyxRQUFRd0UsZUFBZTBCLE9BQU8sQ0FBQ0MsV0FBVzt3QkFDaEQsTUFBTWxHLFNBQVN1RSxlQUFlMEIsT0FBTyxDQUFDRSxZQUFZO3dCQUNsRCxNQUFNQyxtQkFBbUIsT0FBUUUsVUFBVSxHQUFHRCxPQUFPRSxNQUFNLENBQUN4RyxLQUFLLEdBQUk7d0JBRXJFOEQ7K0VBQVcyQyxDQUFBQSxPQUFTO29DQUFFLEdBQUdBLElBQUk7b0NBQUV6RztvQ0FBT0M7Z0NBQU87O3dCQUM3QzBELGNBQWM7NEJBQ1ozRCxPQUFPc0csT0FBT0MsVUFBVTs0QkFDeEJ0RyxRQUFRcUcsT0FBT0ksV0FBVzs0QkFDMUI5QyxZQUFZK0MsS0FBS0MsS0FBSyxDQUFDUDt3QkFDekI7b0JBQ0Y7Z0JBQ0Y7O1lBRUEsSUFBSTNFLFlBQVk7Z0JBQ2R1RTtnQkFDQUssT0FBT08sZ0JBQWdCLENBQUMsVUFBVVo7Z0JBQ2xDO3NEQUFPLElBQU1LLE9BQU9RLG1CQUFtQixDQUFDLFVBQVViOztZQUNwRDtRQUNGO3lDQUFHO1FBQUN2RTtLQUFXO0lBRWYseUNBQXlDO0lBQ3pDbEQsZ0RBQVNBOzBDQUFDO1lBQ1IsSUFBSTRDLFlBQVlELGVBQWU7Z0JBQzdCMEUsUUFBUWtCLEdBQUcsQ0FBQyxtQ0FBbUM1RixlQUFlQztnQkFFOUQsb0NBQW9DO2dCQUNwQyxJQUFJQSxTQUFTNEYsV0FBVyxFQUFFO29CQUN4QixNQUFNLEVBQUVBLFdBQVcsRUFBRSxHQUFHNUY7b0JBRXhCLHNDQUFzQztvQkFDdEMsSUFBSTRGLFlBQVlDLGNBQWMsRUFBRTt3QkFDOUIsTUFBTSxFQUFFL0QsWUFBWSxFQUFFRSxlQUFlLEVBQUVFLFFBQVEsRUFBRUUsY0FBYyxFQUFFLEdBQUd3RCxZQUFZQyxjQUFjO3dCQUM5RjlELGdCQUFnQkQsZ0JBQWdCO3dCQUNoQ0csbUJBQW1CRCxtQkFBbUI7d0JBQ3RDRyxZQUFZRCxZQUFZO3dCQUN4Qkcsa0JBQWtCRCxrQkFBa0I7b0JBQ3RDO29CQUVBLGtDQUFrQztvQkFDbEMsSUFBSXdELFlBQVluRCxPQUFPLEVBQUU7d0JBQ3ZCcEIsZUFBZXVFLFlBQVluRCxPQUFPLENBQUNxRCxJQUFJLElBQUk7b0JBQzdDO29CQUVBLElBQUlGLFlBQVlHLE1BQU0sRUFBRTt3QkFDdEJwRixjQUFjaUYsWUFBWUcsTUFBTSxDQUFDRCxJQUFJLElBQUk7b0JBQzNDO2dCQUNGO1lBQ0Y7UUFDRjt5Q0FBRztRQUFDOUY7UUFBVUQ7S0FBYztJQUU1QiwyREFBMkQ7SUFDM0QsTUFBTWlHLGdCQUFnQjtRQUNwQixnREFBZ0Q7UUFDaEQsSUFBSTNDLFVBQVV5QixPQUFPLEVBQUU7WUFDckJMLFFBQVFrQixHQUFHLENBQUM7WUFDWixPQUFPdEMsVUFBVXlCLE9BQU87UUFDMUI7UUFFQSx3Q0FBd0M7UUFDeEMsSUFBSSxLQUE2QixJQUFJSSxPQUFPZSxpQkFBaUIsRUFBRTtZQUM3RHhCLFFBQVFrQixHQUFHLENBQUM7WUFDWnRDLFVBQVV5QixPQUFPLEdBQUdJLE9BQU9lLGlCQUFpQixFQUFFLGlCQUFpQjtZQUMvRCxPQUFPZixPQUFPZSxpQkFBaUI7UUFDakM7UUFFQSxnQ0FBZ0M7UUFDaEMsSUFBSSxPQUFPQyxhQUFhLGFBQWE7WUFDbkMsTUFBTUMsZ0JBQWdCRCxTQUFTRSxhQUFhLENBQUM7WUFDN0MsSUFBSUQsZUFBZTtnQkFDakIxQixRQUFRa0IsR0FBRyxDQUFDO2dCQUNadEMsVUFBVXlCLE9BQU8sR0FBR3FCLGVBQWUsaUJBQWlCO2dCQUNwRCxJQUFJLElBQTZCLEVBQUU7b0JBQ2pDakIsT0FBT2UsaUJBQWlCLEdBQUdFLGVBQWUsd0JBQXdCO2dCQUNwRTtnQkFDQSxPQUFPQTtZQUNUO1FBQ0Y7UUFFQTFCLFFBQVE0QixJQUFJLENBQUM7UUFDYixPQUFPO0lBQ1Q7SUFFQSx5Q0FBeUM7SUFDekMsTUFBTUMsV0FBVyxhQUFrQjtJQUVuQyxpRUFBaUU7SUFDakVsSixnREFBU0E7MENBQUM7WUFDUixJQUFJLENBQUNrSixZQUFZLENBQUNoRyxZQUFZO1lBRTlCLG9EQUFvRDtZQUNwRCxNQUFNaUcsU0FBU2xELFVBQVV5QixPQUFPO1lBQ2hDLElBQUl5QixRQUFRO2dCQUNWOUIsUUFBUWtCLEdBQUcsQ0FBQyxnQ0FBZ0M7b0JBQzFDL0csT0FBTzJILE9BQU8zSCxLQUFLO29CQUNuQkMsUUFBUTBILE9BQU8xSCxNQUFNO2dCQUN2QjtnQkFFQSw0Q0FBNEM7Z0JBQzVDcUcsT0FBT2UsaUJBQWlCLEdBQUdNO2dCQUUzQiwrQkFBK0I7Z0JBQy9CckIsT0FBT3NCLGdCQUFnQixHQUFHO29CQUN4QjVILE9BQU8ySCxPQUFPM0gsS0FBSztvQkFDbkJDLFFBQVEwSCxPQUFPMUgsTUFBTTtnQkFDdkI7WUFDRixPQUFPO2dCQUNMNEYsUUFBUTRCLElBQUksQ0FBQztZQUNmO1lBRUEsaURBQWlEO1lBQ2pEbkIsT0FBT3VCLGdCQUFnQjtrREFBRyxDQUFDRixRQUFRRztvQkFDakMsSUFBSSxDQUFDSCxVQUFVLENBQUNHLFFBQVE7d0JBQ3RCakMsUUFBUTRCLElBQUksQ0FBQywrQ0FBK0M7NEJBQUVFOzRCQUFRRzt3QkFBTzt3QkFDN0UsT0FBTztvQkFDVDtvQkFFQSxJQUFJO3dCQUNGLHdDQUF3Qzt3QkFDeENILE9BQU8zSCxLQUFLLEdBQUc4SCxPQUFPQyxXQUFXLElBQUk7d0JBQ3JDSixPQUFPMUgsTUFBTSxHQUFHNkgsT0FBT0UsWUFBWSxJQUFJO3dCQUV2Qyx3Q0FBd0M7d0JBQ3hDLE1BQU1DLE1BQU1OLE9BQU9PLFVBQVUsQ0FBQzt3QkFDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdSLE9BQU8zSCxLQUFLLEVBQUUySCxPQUFPMUgsTUFBTTt3QkFDL0NnSSxJQUFJRyxTQUFTLEdBQUc7d0JBQ2hCSCxJQUFJSSxRQUFRLENBQUMsR0FBRyxHQUFHVixPQUFPM0gsS0FBSyxFQUFFMkgsT0FBTzFILE1BQU07d0JBRTlDNEYsUUFBUWtCLEdBQUcsQ0FBQyx1Q0FBdURZLE9BQWhCQSxPQUFPM0gsS0FBSyxFQUFDLEtBQWlCLE9BQWQySCxPQUFPMUgsTUFBTTt3QkFFaEYsMEJBQTBCO3dCQUMxQnFHLE9BQU9lLGlCQUFpQixHQUFHTTt3QkFDM0JyQixPQUFPc0IsZ0JBQWdCLEdBQUc7NEJBQ3hCNUgsT0FBTzJILE9BQU8zSCxLQUFLOzRCQUNuQkMsUUFBUTBILE9BQU8xSCxNQUFNO3dCQUN2Qjt3QkFFQSxPQUFPO29CQUNULEVBQUUsT0FBT3VCLE9BQU87d0JBQ2RxRSxRQUFRckUsS0FBSyxDQUFDLGlEQUFpREE7d0JBQy9ELE9BQU87b0JBQ1Q7Z0JBQ0Y7O1lBRUEsdUVBQXVFO1lBQ3ZFOEc7a0RBQVc7b0JBQ1QsTUFBTVgsU0FBU1A7b0JBQ2YsSUFBSU8sUUFBUTt3QkFDVixNQUFNWSxPQUFPWixPQUFPYSxxQkFBcUI7d0JBQ3pDM0MsUUFBUWtCLEdBQUcsQ0FBQyxvQ0FBb0M7NEJBQzlDMEIsWUFBWSxHQUFtQmQsT0FBaEJBLE9BQU8zSCxLQUFLLEVBQUMsS0FBaUIsT0FBZDJILE9BQU8xSCxNQUFNOzRCQUM1Q3lJLFVBQVUsR0FBaUJILE9BQWRBLEtBQUt2SSxLQUFLLEVBQUMsS0FBZSxPQUFadUksS0FBS3RJLE1BQU07NEJBQ3RDMEksV0FBWUosS0FBS3ZJLEtBQUssR0FBRyxLQUFLdUksS0FBS3RJLE1BQU0sR0FBRzt3QkFDOUM7d0JBRUEsaUNBQWlDO3dCQUNqQzJJO29CQUNGLE9BQU87d0JBQ0wvQyxRQUFRNEIsSUFBSSxDQUFDO29CQUNmO2dCQUNGO2lEQUFHO1lBRUg7a0RBQU87b0JBQ0wsT0FBT25CLE9BQU9lLGlCQUFpQjtvQkFDL0IsT0FBT2YsT0FBT3NCLGdCQUFnQjtvQkFDOUIsT0FBT3RCLE9BQU91QixnQkFBZ0I7Z0JBQ2hDOztRQUNGO3lDQUFHO1FBQUNuRztLQUFXO0lBQ2Ysd0NBQXdDO0lBQ3hDLE1BQU1rSCx5QkFBeUI7UUFDN0IsSUFBSSxDQUFDbEIsWUFBWSxDQUFDaEcsY0FBYyxDQUFDOEMsZUFBZTBCLE9BQU8sRUFBRTtRQUV6RCxNQUFNeUIsU0FBU1A7UUFDZixJQUFJLENBQUNPLFFBQVE7WUFDWDlCLFFBQVE0QixJQUFJLENBQUM7WUFDYjtRQUNGO1FBRUEsTUFBTW9CLFlBQVlyRSxlQUFlMEIsT0FBTztRQUV4QyxtQ0FBbUM7UUFDbkMsTUFBTXFDLE9BQU9NLFVBQVVMLHFCQUFxQjtRQUU1QyxzREFBc0Q7UUFDdEQsTUFBTU0sZUFBZWhILGFBQWEsTUFBTSxHQUFHLDBEQUEwRDtRQUVyRytELFFBQVFrQixHQUFHLENBQUMsK0JBQStCO1lBQ3pDZ0MsZ0JBQWdCUixLQUFLdkksS0FBSztZQUMxQmdKLGlCQUFpQlQsS0FBS3RJLE1BQU07WUFDNUJnSixlQUFlbkg7WUFDZm9ILGtCQUFrQlgsS0FBS3RJLE1BQU07UUFDL0I7UUFFQSx3RUFBd0U7UUFDeEUwSCxPQUFPM0gsS0FBSyxHQUFHdUksS0FBS3ZJLEtBQUs7UUFDekIySCxPQUFPMUgsTUFBTSxHQUFHc0ksS0FBS3RJLE1BQU07UUFFM0IsbUJBQW1CO1FBQ25CLE1BQU1nSSxNQUFNTixPQUFPTyxVQUFVLENBQUM7UUFDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdSLE9BQU8zSCxLQUFLLEVBQUUySCxPQUFPMUgsTUFBTTtRQUUvQyw2QkFBNkI7UUFDN0JnSSxJQUFJRyxTQUFTLEdBQUc7UUFDaEJILElBQUlJLFFBQVEsQ0FBQyxHQUFHLEdBQUdWLE9BQU8zSCxLQUFLLEVBQUUySCxPQUFPMUgsTUFBTTtRQUU5QzRGLFFBQVFrQixHQUFHLENBQUMsK0JBQStDWSxPQUFoQkEsT0FBTzNILEtBQUssRUFBQyxLQUFpQixPQUFkMkgsT0FBTzFILE1BQU07UUFFeEUsa0RBQWtEO1FBQ2xEcUcsT0FBT2UsaUJBQWlCLEdBQUdNO1FBQzNCckIsT0FBT3NCLGdCQUFnQixHQUFHO1lBQ3hCNUgsT0FBTzJILE9BQU8zSCxLQUFLO1lBQ25CQyxRQUFRMEgsT0FBTzFILE1BQU07UUFDdkI7SUFDRjtJQUVBLDZDQUE2QztJQUM3Q3pCLGdEQUFTQTswQ0FBQztZQUNSLElBQUksQ0FBQzBGLGlCQUFpQndELFlBQVloRyxZQUFZO2dCQUM1QyxNQUFNeUgsWUFBWSxJQUFJQyxPQUFPQyxXQUFXLEdBQUdDLE9BQU8sQ0FBQyxVQUFVO2dCQUM3RG5GLGlCQUFpQixXQUFxQixPQUFWZ0Y7Z0JBQzVCdEQsUUFBUWtCLEdBQUcsQ0FBQyxtQ0FBNkMsT0FBVm9DO1lBQ2pEO1FBQ0Y7eUNBQUc7UUFBQ2pGO1FBQWV3RDtRQUFVaEc7S0FBVztJQUV4QyxvQ0FBb0M7SUFDcENsRCxnREFBU0E7MENBQUM7WUFDUixJQUFJLENBQUNrSixZQUFZLENBQUNoRyxZQUFZLFFBQVEscUNBQXFDO1lBRTNFLE1BQU1xRTt5RUFBeUI7b0JBQzdCLElBQUk7d0JBQ0YsTUFBTWIsV0FBVyxNQUFNQyxNQUFNO3dCQUM3QixNQUFNTyxPQUFPLE1BQU1SLFNBQVNTLElBQUk7d0JBQ2hDOUQsaUJBQWlCNkQsS0FBS00sU0FBUyxHQUFHLGNBQWM7d0JBQ2hESCxRQUFRa0IsR0FBRyxDQUFDLHVCQUF3RCxPQUFqQ3JCLEtBQUtNLFNBQVMsR0FBRyxPQUFPO3dCQUUzRCw2QkFBNkI7d0JBQzdCekQsY0FBYyxXQUEyRSxPQUFoRW1ELEtBQUtNLFNBQVMsR0FBRyxjQUFjO29CQUMxRCxFQUFFLE9BQU94RSxPQUFPO3dCQUNkcUUsUUFBUXJFLEtBQUssQ0FBQyxzQ0FBc0NBO3dCQUNwREssaUJBQWlCO3dCQUNqQlUsY0FBYztvQkFDaEI7Z0JBQ0Y7O1lBRUF3RDtZQUVBLHNDQUFzQztZQUN0Q3VDO2tEQUFXO29CQUNUL0YsY0FBYztnQkFDaEI7aURBQUc7UUFDTDt5Q0FBRztRQUFDYjtLQUFXO0lBRWYsc0RBQXNEO0lBQ3REbEQsZ0RBQVNBOzBDQUFDO1lBQ1IsSUFBSSxDQUFDa0osWUFBWSxDQUFDaEcsWUFBWTtZQUU5Qix5QkFBeUI7WUFDekIsTUFBTS9CLFFBQVEySCxTQUFTaUMsYUFBYSxDQUFDO1lBQ3JDNUosTUFBTTZKLFdBQVcsR0FBSTtZQXdCckJsQyxTQUFTbUMsSUFBSSxDQUFDQyxXQUFXLENBQUMvSjtZQUUxQixXQUFXO1lBQ1g7a0RBQU87b0JBQ0wySCxTQUFTbUMsSUFBSSxDQUFDRSxXQUFXLENBQUNoSztnQkFDNUI7O1FBQ0Y7eUNBQUc7UUFBQytCO0tBQVc7SUFFZixnREFBZ0Q7SUFDaERsRCxnREFBU0E7MENBQUM7WUFDUixJQUFJLENBQUNrSixZQUFZLENBQUNoRyxZQUFZO1lBRTlCLGtEQUFrRDtZQUNsRDRFLE9BQU9zRCxZQUFZO2tEQUFHLENBQUMxQztvQkFDckJuRixjQUFjbUY7b0JBRWQsNENBQTRDO29CQUM1QyxJQUFJLENBQUNBLE1BQU07d0JBQ1R6RSxlQUFlO29CQUNqQjtvQkFFQSwwQ0FBMEM7b0JBQzFDNkYsV0FBV00sd0JBQXdCO2dCQUNyQzs7WUFFQTtrREFBTztvQkFDTCxXQUFXO29CQUNYLE9BQU90QyxPQUFPc0QsWUFBWTtnQkFDNUI7O1FBQ0Y7eUNBQUc7UUFBQ2xJO0tBQVc7SUFFZix5QkFBeUI7SUFDekIsTUFBTW1JLGVBQWUsQ0FBQ0M7UUFDcEIsSUFBSSxDQUFDcEMsWUFBWSxDQUFDaEcsWUFBWTtRQUU5QixJQUFJb0ksY0FBYztZQUNoQi9HLGNBQWM7WUFDZEUseUJBQXlCO1lBQ3pCVixjQUFjO1FBQ2hCLE9BQU87WUFDTFEsY0FBYztZQUNkRSx5QkFBeUI7WUFDekJWLGNBQWM7UUFDaEI7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNd0gsMEJBQTBCLENBQUNDLFlBQVlDO1FBQzNDLElBQUksQ0FBQ3ZDLFlBQVksQ0FBQ2hHLFlBQVk7UUFFOUIsd0NBQXdDO1FBQ3hDLElBQUlzSSxlQUFlLGdCQUFnQjtZQUNqQyxzRUFBc0U7WUFDdEUsSUFBSUU7WUFFSixJQUFJLE9BQU9ELFdBQVcsV0FBVztnQkFDL0JDLGlCQUFpQkQ7WUFDbkIsT0FBTyxJQUFJQSxVQUFVLE9BQU9BLE9BQU9FLEtBQUssS0FBSyxhQUFhO2dCQUN4REQsaUJBQWlCLENBQUMsQ0FBQ0QsT0FBT0UsS0FBSztZQUNqQyxPQUFPO2dCQUNMRCxpQkFBaUIsQ0FBQ3BJO1lBQ3BCO1lBQ0FDLGNBQWNtSTtZQUVkLDRDQUE0QztZQUM1QyxJQUFJLENBQUNBLGdCQUFnQjtnQkFDbkJ6SCxlQUFlO1lBQ2pCO1lBRUFGLGNBQWMsVUFBZ0QsT0FBdEMySCxpQkFBaUIsVUFBVSxVQUFxRCxPQUExQyxDQUFDQSxpQkFBaUIscUJBQXFCO1lBRXJHLDBDQUEwQztZQUMxQzVCLFdBQVdNLHdCQUF3QjtZQUNuQztRQUNGO1FBQ0EsTUFBTWpCLFNBQVNQO1FBQ2ZuRixlQUFlO1FBRWYsOEJBQThCO1FBQzlCLE1BQU1tSSxhQUFhSCxVQUFVLENBQUM7UUFFOUIsMENBQTBDO1FBQzFDLE1BQU1JLGNBQWNELFdBQVdDLFdBQVcsSUFBSTtRQUM5QyxNQUFNQyxlQUFlRixXQUFXRSxZQUFZLElBQUk7UUFFaEQsT0FBUU47WUFDTixLQUFLO2dCQUNILHNCQUFzQjtnQkFDdEIsSUFBSWxILFlBQVk7b0JBQ2QrRyxhQUFhO2dCQUNmLE9BQU8sSUFBSWpILHlCQUF5QjtvQkFDbENpSCxhQUFhO2dCQUNmLE9BQU87b0JBQ0wsa0NBQWtDO29CQUNsQ2xILHVCQUF1QjtvQkFDdkJKLGNBQWM7b0JBQ2RVLHlCQUF5QjtnQkFDM0I7Z0JBQ0E7WUFFRixLQUFLO2dCQUNIVixjQUFjO2dCQUNkUixjQUFjO2dCQUNkLElBQUllLFlBQVk7b0JBQ2QrRyxhQUFhO2dCQUNmO2dCQUNBLDBEQUEwRDtnQkFDMUQsSUFBSWxGLHFCQUFxQnVCLE9BQU8sSUFBSXZCLHFCQUFxQnVCLE9BQU8sQ0FBQ3FFLGVBQWUsRUFBRTtvQkFDaEYsd0NBQXdDO29CQUN4QzFFLFFBQVFrQixHQUFHLENBQUM7b0JBQ1pwQyxxQkFBcUJ1QixPQUFPLENBQUNxRSxlQUFlO2dCQUM5QyxPQUNLLElBQUksS0FBNkIsSUFBSWpFLE9BQU9rRSxxQkFBcUIsSUFDcEUsT0FBT2xFLE9BQU9rRSxxQkFBcUIsQ0FBQ0QsZUFBZSxLQUFLLFlBQVk7b0JBQ3BFLDRCQUE0QjtvQkFDNUIxRSxRQUFRa0IsR0FBRyxDQUFDO29CQUNaVCxPQUFPa0UscUJBQXFCLENBQUNELGVBQWU7Z0JBQzlDLE9BQ0s7b0JBQ0gsMENBQTBDO29CQUMxQyxNQUFNNUMsU0FBU1A7b0JBQ2YsSUFBSSxDQUFDTyxRQUFRO3dCQUNYOUIsUUFBUXJFLEtBQUssQ0FBQzt3QkFDZGUsY0FBYzt3QkFDZFIsY0FBYzt3QkFDZDtvQkFDRjtvQkFFQSxxQ0FBcUM7b0JBQ3JDLE1BQU0wSSxZQUFZbkQsU0FBU0UsYUFBYSxDQUFDO29CQUN6QyxNQUFNa0QsYUFBYXBELFNBQVNxRCxnQkFBZ0IsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO29CQUV2RSwwQ0FBMEM7b0JBQzFDLElBQUlDLFFBQVE7b0JBQ1osSUFBSUMsUUFBUTtvQkFFWixrQ0FBa0M7b0JBQ2xDLElBQUlKLFdBQVc7d0JBQ2IsTUFBTUssYUFBYUMsU0FBU04sVUFBVU4sS0FBSyxFQUFFO3dCQUM3QyxJQUFJLENBQUNhLE1BQU1GLGVBQWVBLGFBQWEsR0FBRzs0QkFDeENGLFFBQVFFO3dCQUNWO29CQUNGO29CQUVBLElBQUlKLFlBQVk7d0JBQ2QsTUFBTU8sY0FBY0YsU0FBU0wsV0FBV1AsS0FBSyxFQUFFO3dCQUMvQyxJQUFJLENBQUNhLE1BQU1DLGdCQUFnQkEsY0FBYyxHQUFHOzRCQUMxQ0osUUFBUUk7d0JBQ1Y7b0JBQ0Y7b0JBRUEsK0RBQStEO29CQUMvREMsUUFBUUMsR0FBRyxDQUFDO3dCQUNWLCtPQUF3RTt3QkFDeEUsNk9BQXVFO3FCQUN4RSxFQUFFQyxJQUFJLENBQUM7NEJBQU8sQ0FDYkMsaUJBQ0FDLGVBQ0Q7d0JBQ0MsbUNBQW1DO3dCQUNuQyxNQUFNLEVBQUVwTSxpQkFBaUIsRUFBRUQsVUFBVSxFQUFFRSxZQUFZLEVBQUVKLGtCQUFrQixFQUFFLEdBQUdzTTt3QkFDNUUsTUFBTSxFQUFFck0sb0JBQW9CLEVBQUUsR0FBR3NNO3dCQUVqQyxJQUFJOzRCQUNGLG9DQUFvQzs0QkFDcEMsSUFBSUMsZUFBZTs0QkFDbkIsSUFBSUMsaUJBQWlCOzRCQUVyQixNQUFPQSxrQkFBa0JaLE1BQU87Z0NBQzlCLG9DQUFvQztnQ0FDcENySSxjQUFjLFdBQWdDcUksT0FBckJZLGdCQUFlLFFBQVksT0FBTlo7Z0NBRTlDLG1DQUFtQztnQ0FDbkMsTUFBTTNDLE1BQU1OLE9BQU9PLFVBQVUsQ0FBQztnQ0FDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdSLE9BQU8zSCxLQUFLLEVBQUUySCxPQUFPMUgsTUFBTTtnQ0FDL0NnSSxJQUFJRyxTQUFTLEdBQUc7Z0NBQ2hCSCxJQUFJSSxRQUFRLENBQUMsR0FBRyxHQUFHVixPQUFPM0gsS0FBSyxFQUFFMkgsT0FBTzFILE1BQU07Z0NBRTlDLDRDQUE0QztnQ0FDNUMsTUFBTUwsV0FBV1Ysa0JBQWtCeUksUUFBUTtnQ0FFM0MsZUFBZTtnQ0FDZjFJLFdBQVdnSixLQUFLckksU0FBUzZMLENBQUMsRUFBRTdMLFNBQVM4TCxDQUFDO2dDQUV0QyxzREFBc0Q7Z0NBQ3RELElBQUlDLGlCQUFpQkMsWUFBWTtvQ0FDL0IzTSxXQUFXZ0osS0FBS3JJLFNBQVM2TCxDQUFDLEVBQUU3TCxTQUFTOEwsQ0FBQyxFQUFFLElBQUk7Z0NBQzlDLEdBQUc7Z0NBRUgsNENBQTRDO2dDQUM1QyxNQUFNLElBQUlSLFFBQVFXLENBQUFBO29DQUNoQjFNLGFBQ0VTLFVBQ0ErSCxRQUNBLENBQUNtRTt3Q0FDQyw0QkFBNEI7d0NBQzVCLElBQUlBLE9BQU9DLGFBQWEsRUFBRTs0Q0FDeEJ4SixjQUFjLFdBQTZCcUksT0FBbEJZLGdCQUFlLEtBQWFNLE9BQVZsQixPQUFNLE1BQXlCLE9BQXJCa0IsT0FBT0MsYUFBYTt3Q0FDM0U7b0NBQ0YsR0FDQUYsUUFBUSwrQ0FBK0M7O2dDQUUzRDtnQ0FFQSx1Q0FBdUM7Z0NBQ3ZDRyxjQUFjTDtnQ0FFZCwrQkFBK0I7Z0NBQy9CLE1BQU0sSUFBSVQsUUFBUVcsQ0FBQUEsVUFBV3ZELFdBQVd1RCxTQUFTO2dDQUVqRCwrQkFBK0I7Z0NBQy9CLElBQUk7b0NBQ0YsTUFBTUksZ0JBQWdCLE1BQU1qTixxQkFBcUI7d0NBQy9Da04sT0FBT3RNO3dDQUNQdU0sY0FBY25JO3dDQUNkUyxXQUFXOzRDQUFFeUIsU0FBU3lCO3dDQUFPO3dDQUM3QnlFLGlCQUFpQm5JO3dDQUNqQmxGO29DQUNGO29DQUVBLElBQUlrTixpQkFBa0JBLENBQUFBLGNBQWNJLFdBQVcsSUFBSUosY0FBY0ssT0FBTyxHQUFHO3dDQUN6RWY7b0NBQ0Y7b0NBRUEsb0JBQW9CO29DQUNwQnRILGtCQUFrQndDLENBQUFBLE9BQVFBLE9BQU87Z0NBQ25DLEVBQUUsT0FBT2pGLE9BQU87b0NBQ2RxRSxRQUFRckUsS0FBSyxDQUFDLHlCQUF3QyxPQUFmZ0ssZ0JBQWUsTUFBSWhLO2dDQUM1RDtnQ0FFQSxxREFBcUQ7Z0NBQ3JELElBQUlnSyxpQkFBaUJaLE9BQU87b0NBQzFCckksY0FBYyxXQUFpQixPQUFOc0ksT0FBTTtvQ0FDL0IsTUFBTSxJQUFJSyxRQUFRVyxDQUFBQSxVQUFXdkQsV0FBV3VELFNBQVNoQixRQUFRO2dDQUMzRDtnQ0FFQSx1QkFBdUI7Z0NBQ3ZCVzs0QkFDRjs0QkFFQSxvQkFBb0I7NEJBQ3BCakosY0FBYyxzQ0FBc0RxSSxPQUFoQlcsY0FBYSxLQUFTLE9BQU5YLE9BQU07d0JBRTVFLEVBQUUsT0FBT3BKLE9BQU87NEJBQ2RxRSxRQUFRckUsS0FBSyxDQUFDLDBCQUEwQkE7NEJBQ3hDZSxjQUFjLDBCQUF3QyxPQUFkZixNQUFNc0UsT0FBTzt3QkFDdkQsU0FBVTs0QkFDUixvQkFBb0I7NEJBQ3BCd0MsV0FBVyxJQUFNdkcsY0FBYyxPQUFPO3dCQUN4QztvQkFDRixHQUFHd0ssS0FBSyxDQUFDL0ssQ0FBQUE7d0JBQ1BxRSxRQUFRckUsS0FBSyxDQUFDLHNDQUFzQ0E7d0JBQ3BEZSxjQUFjLFVBQXdCLE9BQWRmLE1BQU1zRSxPQUFPO3dCQUNyQy9ELGNBQWM7b0JBQ2hCO2dCQUNGO2dCQUNBO1lBRUYsS0FBSztnQkFDSFEsY0FBYztnQkFDZFIsY0FBYztnQkFDZCxJQUFJZSxZQUFZO29CQUNkK0csYUFBYTtnQkFDZjtnQkFDQWhFLFFBQVFrQixHQUFHLENBQUM7Z0JBRVosMkZBQTJGO2dCQUMzRixpRUFBaUU7Z0JBQ2pFLElBQUlwQyxxQkFBcUJ1QixPQUFPLElBQUl2QixxQkFBcUJ1QixPQUFPLENBQUNzRyxlQUFlLEVBQUU7b0JBQ2hGM0csUUFBUWtCLEdBQUcsQ0FBQztvQkFDWnBDLHFCQUFxQnVCLE9BQU8sQ0FBQ3NHLGVBQWU7Z0JBQzlDLE9BQU8sSUFBSSxLQUE2QixJQUFJbEcsT0FBT2tFLHFCQUFxQixJQUN0RSxPQUFPbEUsT0FBT2tFLHFCQUFxQixDQUFDZ0MsZUFBZSxLQUFLLFlBQVk7b0JBQ3BFM0csUUFBUWtCLEdBQUcsQ0FBQztvQkFDWlQsT0FBT2tFLHFCQUFxQixDQUFDZ0MsZUFBZTtnQkFDOUMsT0FBTztvQkFDTCwwQkFBMEI7b0JBQzFCLE1BQU03RSxTQUFTUDtvQkFDZixJQUFJLENBQUNPLFFBQVE7d0JBQ1g5QixRQUFRckUsS0FBSyxDQUFDO3dCQUNkZSxjQUFjO3dCQUNkUixjQUFjLE9BQU8sd0NBQXdDO3dCQUM3RDtvQkFDRjtvQkFFQSxNQUFNK0YsU0FBU3RELGVBQWUwQixPQUFPO29CQUNyQyxJQUFJLENBQUM0QixRQUFRO3dCQUNYakMsUUFBUXJFLEtBQUssQ0FBQzt3QkFDZGUsY0FBYzt3QkFDZFIsY0FBYzt3QkFDZDtvQkFDRjtvQkFFQSwrQkFBK0I7b0JBQy9CNEYsT0FBTzNILEtBQUssR0FBRzhILE9BQU9DLFdBQVcsSUFBSTtvQkFDckNKLE9BQU8xSCxNQUFNLEdBQUc2SCxPQUFPRSxZQUFZLElBQUk7b0JBQ3ZDLE1BQU1DLE1BQU1OLE9BQU9PLFVBQVUsQ0FBQztvQkFDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdSLE9BQU8zSCxLQUFLLEVBQUUySCxPQUFPMUgsTUFBTTtvQkFDL0NnSSxJQUFJRyxTQUFTLEdBQUc7b0JBQ2hCSCxJQUFJSSxRQUFRLENBQUMsR0FBRyxHQUFHVixPQUFPM0gsS0FBSyxFQUFFMkgsT0FBTzFILE1BQU07b0JBRTlDNEYsUUFBUWtCLEdBQUcsQ0FBQyxnQ0FBZ0RZLE9BQWhCQSxPQUFPM0gsS0FBSyxFQUFDLEtBQWlCLE9BQWQySCxPQUFPMUgsTUFBTTtvQkFFekUsMEJBQTBCO29CQUMxQnFHLE9BQU9lLGlCQUFpQixHQUFHTTtvQkFFM0IsMkJBQTJCO29CQUMzQixNQUFNL0gsV0FBV1YsNEdBQWlCQSxDQUFDeUksUUFBUTtvQkFFM0MsMkNBQTJDO29CQUMzQyxNQUFNOEUsTUFBTXhOLHFHQUFVQSxDQUFDZ0osS0FBS3JJLFNBQVM2TCxDQUFDLEVBQUU3TCxTQUFTOEwsQ0FBQyxFQUFFLEdBQUc7b0JBQ3ZEN0YsUUFBUWtCLEdBQUcsQ0FBQyx3QkFBdUNuSCxPQUFmQSxTQUFTNkwsQ0FBQyxFQUFDLE1BQWUsT0FBWDdMLFNBQVM4TCxDQUFDO29CQUU3RCxnQ0FBZ0M7b0JBQ2hDdk0sdUdBQVlBLENBQ1ZTLFVBQ0ErSCxRQUNBLENBQUNtRTt3QkFDQyw0QkFBNEI7d0JBQzVCLElBQUlBLE9BQU9DLGFBQWEsRUFBRTs0QkFDeEJ4SixjQUFjdUosT0FBT0MsYUFBYTt3QkFDcEM7b0JBQ0YsR0FDQTt3QkFDRSwrQkFBK0I7d0JBQy9CLDZCQUE2Qjt3QkFFN0Isd0NBQXdDO3dCQUN4Q3pELFdBQVc7NEJBQ1QsNkVBQTZFOzRCQUM3RSw2T0FBdUUsQ0FBQzhDLElBQUksQ0FBQztvQ0FBQyxFQUFFcE0sb0JBQW9CLEVBQUU7Z0NBQ3BHQSxxQkFBcUI7b0NBQ25Ca04sT0FBT3RNO29DQUNQdU0sY0FBY25JO29DQUNkUyxXQUFXO3dDQUFFeUIsU0FBU3lCO29DQUFPO29DQUM3QnlFLGlCQUFpQm5JO29DQUNqQmxGLGtCQUFrQkEsMkdBQUFBO2dDQUNwQixHQUFHcU0sSUFBSSxDQUFDO29DQUNObkgsa0JBQWtCd0MsQ0FBQUEsT0FBUUEsT0FBTztvQ0FFakMsa0NBQWtDO29DQUNsQzZCLFdBQVc7d0NBQ1R2RyxjQUFjO29DQUNoQixHQUFHO2dDQUNMLEdBQUd3SyxLQUFLLENBQUMzRyxDQUFBQTtvQ0FDUEMsUUFBUXJFLEtBQUssQ0FBQywyQkFBMkJvRTtvQ0FDekNyRCxjQUFjLFVBQXNCLE9BQVpxRCxJQUFJRSxPQUFPO29DQUNuQy9ELGNBQWM7Z0NBQ2hCOzRCQUNGLEdBQUd3SyxLQUFLLENBQUMzRyxDQUFBQTtnQ0FDUEMsUUFBUXJFLEtBQUssQ0FBQyxvQ0FBb0NvRTtnQ0FDbERyRCxjQUFjLFVBQXNCLE9BQVpxRCxJQUFJRSxPQUFPO2dDQUNuQy9ELGNBQWM7NEJBQ2hCO3dCQUNGLEdBQUc7b0JBQ0w7Z0JBRUo7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILE1BQU0ySyxtQkFBbUIsQ0FBQ3hKO2dCQUMxQkMsZ0JBQWdCdUo7Z0JBQ2hCbkssY0FBYywyQkFBcUUsT0FBMUNtSyxtQkFBbUIsWUFBWTtnQkFDeEUsSUFBSUEsb0JBQW9CLENBQUM1SixZQUFZO29CQUNuQ0cseUJBQXlCO2dCQUMzQixPQUFPLElBQUksQ0FBQ3lKLG9CQUFvQixDQUFDdEosbUJBQW1CLENBQUNFLFlBQVksQ0FBQ0UsZ0JBQWdCO29CQUNoRlAseUJBQXlCO2dCQUMzQjtnQkFFQSwrQ0FBK0M7Z0JBQy9DLElBQUlILGNBQWN3RCxPQUFPcUcsY0FBYyxFQUFFO29CQUN2Q3JHLE9BQU9xRyxjQUFjLENBQUNDLGFBQWEsQ0FBQzt3QkFDbEMsR0FBR3RHLE9BQU9xRyxjQUFjLENBQUNFLE9BQU87d0JBQ2hDM0osY0FBY3dKO29CQUNoQjtnQkFDRjtnQkFDQTtZQUVGLEtBQUs7Z0JBQ0gsTUFBTUksc0JBQXNCLENBQUMxSjtnQkFDN0JDLG1CQUFtQnlKO2dCQUNuQnZLLGNBQWMsZ0JBQXlELE9BQXpDdUssc0JBQXNCLFVBQVU7Z0JBQzlELElBQUlBLHVCQUF1QixDQUFDaEssWUFBWTtvQkFDdENHLHlCQUF5QjtnQkFDM0IsT0FBTyxJQUFJLENBQUM2Six1QkFBdUIsQ0FBQzVKLGdCQUFnQixDQUFDSSxZQUFZLENBQUNFLGdCQUFnQjtvQkFDaEZQLHlCQUF5QjtnQkFDM0I7Z0JBRUEsK0NBQStDO2dCQUMvQyxJQUFJSCxjQUFjd0QsT0FBT3FHLGNBQWMsRUFBRTtvQkFDdkNyRyxPQUFPcUcsY0FBYyxDQUFDQyxhQUFhLENBQUM7d0JBQ2xDLEdBQUd0RyxPQUFPcUcsY0FBYyxDQUFDRSxPQUFPO3dCQUNoQ3pKLGlCQUFpQjBKO29CQUNuQjtnQkFDRjtnQkFDQTtZQUVGLEtBQUs7Z0JBQ0gsTUFBTUMsZUFBZSxDQUFDeko7Z0JBQ3RCQyxZQUFZd0o7Z0JBQ1p4SyxjQUFjLFFBQTBDLE9BQWxDd0ssZUFBZSxVQUFVO2dCQUMvQyxJQUFJQSxnQkFBZ0IsQ0FBQ2pLLFlBQVk7b0JBQy9CRyx5QkFBeUI7Z0JBQzNCLE9BQU8sSUFBSSxDQUFDOEosZ0JBQWdCLENBQUM3SixnQkFBZ0IsQ0FBQ0UsbUJBQW1CLENBQUNJLGdCQUFnQjtvQkFDaEZQLHlCQUF5QjtnQkFDM0I7Z0JBRUEsK0NBQStDO2dCQUMvQyxJQUFJSCxjQUFjd0QsT0FBT3FHLGNBQWMsRUFBRTtvQkFDdkNyRyxPQUFPcUcsY0FBYyxDQUFDQyxhQUFhLENBQUM7d0JBQ2xDLEdBQUd0RyxPQUFPcUcsY0FBYyxDQUFDRSxPQUFPO3dCQUNoQ3ZKLFVBQVV5SjtvQkFDWjtnQkFDRjtnQkFDQTtZQUVGLEtBQUs7Z0JBQ0gsTUFBTUMscUJBQXFCLENBQUN4SjtnQkFDNUJDLGtCQUFrQnVKO2dCQUNsQnpLLGNBQWMsY0FBc0QsT0FBeEN5SyxxQkFBcUIsVUFBVTtnQkFDM0QsSUFBSUEsc0JBQXNCLENBQUNsSyxZQUFZO29CQUNyQ0cseUJBQXlCO2dCQUMzQixPQUFPLElBQUksQ0FBQytKLHNCQUFzQixDQUFDOUosZ0JBQWdCLENBQUNFLG1CQUFtQixDQUFDRSxVQUFVO29CQUNoRkwseUJBQXlCO2dCQUMzQjtnQkFFQSwrQ0FBK0M7Z0JBQy9DLElBQUlILGNBQWN3RCxPQUFPcUcsY0FBYyxFQUFFO29CQUN2Q3JHLE9BQU9xRyxjQUFjLENBQUNDLGFBQWEsQ0FBQzt3QkFDbEMsR0FBR3RHLE9BQU9xRyxjQUFjLENBQUNFLE9BQU87d0JBQ2hDckosZ0JBQWdCd0o7b0JBQ2xCO2dCQUNGO2dCQUNBO1lBRUYsMkNBQTJDO1lBQzNDLEtBQUs7Z0JBQ0h6SyxjQUFjO2dCQUNkUixjQUFjO2dCQUNkLElBQUllLFlBQVk7b0JBQ2QrRyxhQUFhO2dCQUNmO2dCQUNBLElBQUlsRixxQkFBcUJ1QixPQUFPLElBQUl2QixxQkFBcUJ1QixPQUFPLENBQUMrRyxrQkFBa0IsRUFBRTtvQkFDbkYsd0NBQXdDO29CQUN4Q3BILFFBQVFrQixHQUFHLENBQUM7b0JBQ1pwQyxxQkFBcUJ1QixPQUFPLENBQUMrRyxrQkFBa0I7Z0JBQ2pELE9BQ0ssSUFBSSxLQUE2QixJQUFJM0csT0FBT2tFLHFCQUFxQixJQUNwRSxPQUFPbEUsT0FBT2tFLHFCQUFxQixDQUFDeUMsa0JBQWtCLEtBQUssWUFBWTtvQkFDdkUsNEJBQTRCO29CQUM1QnBILFFBQVFrQixHQUFHLENBQUM7b0JBQ1pULE9BQU9rRSxxQkFBcUIsQ0FBQ3lDLGtCQUFrQjtnQkFDakQsT0FDSztvQkFDSCwwQ0FBMEM7b0JBQzFDLE1BQU10RixTQUFTUDtvQkFDZixJQUFJLENBQUNPLFFBQVE7d0JBQ1g5QixRQUFRckUsS0FBSyxDQUFDO3dCQUNkZSxjQUFjO3dCQUNkUixjQUFjO3dCQUNkO29CQUNGO29CQUVBLCtEQUErRDtvQkFDL0RtSixRQUFRQyxHQUFHLENBQUM7d0JBQ1YsMlBBQThFO3dCQUM5RSwrT0FBd0U7d0JBQ3hFLDZPQUF1RTtxQkFDeEUsRUFBRUMsSUFBSSxDQUFDOzRCQUFPLENBQ2I4Qix1QkFDQTdCLGlCQUNBQyxlQUNEO3dCQUNDLG1DQUFtQzt3QkFDbkMsTUFBTSxFQUFFNkIseUJBQXlCLEVBQUUsR0FBR0Q7d0JBQ3RDLE1BQU0sRUFBRWpPLFVBQVUsRUFBRUUsWUFBWSxFQUFFSixrQkFBa0IsRUFBRSxHQUFHc007d0JBQ3pELE1BQU0sRUFBRXJNLG9CQUFvQixFQUFFLEdBQUdzTTt3QkFFakMsSUFBSTs0QkFDRiw4QkFBOEI7NEJBQzlCLE1BQU04QixTQUFTRCwwQkFBMEJ4RixPQUFPM0gsS0FBSyxFQUFFMkgsT0FBTzFILE1BQU07NEJBRXBFLElBQUksQ0FBQ21OLFVBQVVBLE9BQU9DLE1BQU0sS0FBSyxHQUFHO2dDQUNsQyxNQUFNLElBQUk1SCxNQUFNOzRCQUNsQjs0QkFFQSwwQkFBMEI7NEJBQzFCLE1BQU02SCxrQkFBa0JoRyxTQUFTaUMsYUFBYSxDQUFDOzRCQUMvQytELGdCQUFnQkMsU0FBUyxHQUFHOzRCQUM1QkQsZ0JBQWdCM04sS0FBSyxDQUFDNk4sT0FBTyxHQUFJOzRCQWFqQ0YsZ0JBQWdCOUQsV0FBVyxHQUFHOzRCQUM5QmxDLFNBQVNtRyxJQUFJLENBQUMvRCxXQUFXLENBQUM0RDs0QkFFMUIseURBQXlEOzRCQUN6RCxJQUFJLE9BQU9JLHdCQUF3QixZQUFZO2dDQUM3Q0Esb0JBQW9CO2dDQUNwQixNQUFNLElBQUl4QyxRQUFRVyxDQUFBQSxVQUFXdkQsV0FBV3VELFNBQVM7NEJBQ25EOzRCQUVBLDhCQUE4Qjs0QkFDOUIsSUFBSU4sZUFBZTs0QkFFbkIsSUFBSyxJQUFJb0MsSUFBSSxHQUFHQSxJQUFJUCxPQUFPQyxNQUFNLEVBQUVNLElBQUs7Z0NBQ3RDLE1BQU16QixRQUFRa0IsTUFBTSxDQUFDTyxFQUFFO2dDQUV2QkwsZ0JBQWdCOUQsV0FBVyxHQUFHLHNCQUErQjRELE9BQVRPLElBQUksR0FBRSxLQUFpQixPQUFkUCxPQUFPQyxNQUFNO2dDQUMxRTlLLGNBQWMsZ0NBQXlDNkssT0FBVE8sSUFBSSxHQUFFLEtBQWlCLE9BQWRQLE9BQU9DLE1BQU07Z0NBRXBFLDRDQUE0QztnQ0FDNUMsTUFBTXBGLE1BQU1OLE9BQU9PLFVBQVUsQ0FBQztnQ0FDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdSLE9BQU8zSCxLQUFLLEVBQUUySCxPQUFPMUgsTUFBTTtnQ0FDL0NnSSxJQUFJRyxTQUFTLEdBQUc7Z0NBQ2hCSCxJQUFJSSxRQUFRLENBQUMsR0FBRyxHQUFHVixPQUFPM0gsS0FBSyxFQUFFMkgsT0FBTzFILE1BQU07Z0NBRTlDLGVBQWU7Z0NBQ2ZoQixXQUFXZ0osS0FBS2lFLE1BQU1ULENBQUMsRUFBRVMsTUFBTVIsQ0FBQztnQ0FFaEMsZ0JBQWdCO2dDQUNoQixNQUFNLElBQUlSLFFBQVFXLENBQUFBO29DQUNoQjFNLGFBQ0UrTSxPQUNBdkUsUUFDQSxDQUFDbUU7d0NBQ0MsSUFBSUEsT0FBT0MsYUFBYSxFQUFFOzRDQUN4QnhKLGNBQWN1SixPQUFPQyxhQUFhO3dDQUNwQztvQ0FDRixHQUNBRixRQUFRLCtDQUErQzs7Z0NBRTNEO2dDQUVBLCtCQUErQjtnQ0FDL0IsSUFBSTtvQ0FDRixNQUFNSSxnQkFBZ0IsTUFBTWpOLHFCQUFxQjt3Q0FDL0NrTixPQUFPQTt3Q0FDUEMsY0FBY25JO3dDQUNkUyxXQUFXOzRDQUFFeUIsU0FBU3lCO3dDQUFPO3dDQUM3QnlFLGlCQUFpQm5JO3dDQUNqQmxGLG9CQUFvQkE7b0NBQ3RCO29DQUVBLElBQUlrTixpQkFBa0JBLENBQUFBLGNBQWNJLFdBQVcsSUFBSUosY0FBY0ssT0FBTyxHQUFHO3dDQUN6RWY7b0NBQ0Y7b0NBRUEsb0JBQW9CO29DQUNwQnRILGtCQUFrQndDLENBQUFBLE9BQVFBLE9BQU87Z0NBQ25DLEVBQUUsT0FBT2pGLE9BQU87b0NBQ2RxRSxRQUFRckUsS0FBSyxDQUFDLHlCQUE2QixPQUFKbU0sSUFBRSxHQUFFLE1BQUluTTtnQ0FDakQ7Z0NBRUEsc0JBQXNCO2dDQUN0QixNQUFNLElBQUkwSixRQUFRVyxDQUFBQSxVQUFXdkQsV0FBV3VELFNBQVM7NEJBQ25EOzRCQUVBLHVCQUF1Qjs0QkFDdkJ5QixnQkFBZ0I5RCxXQUFXLEdBQUcseUJBQXlDNEQsT0FBaEI3QixjQUFhLEtBQWlCLE9BQWQ2QixPQUFPQyxNQUFNLEVBQUM7NEJBQ3JGOUssY0FBYywwQkFBMEM2SyxPQUFoQjdCLGNBQWEsS0FBaUIsT0FBZDZCLE9BQU9DLE1BQU0sRUFBQzs0QkFFdEUsNENBQTRDOzRCQUM1Qy9FLFdBQVc7Z0NBQ1QsSUFBSWdGLGdCQUFnQk0sVUFBVSxFQUFFO29DQUM5Qk4sZ0JBQWdCTSxVQUFVLENBQUNqRSxXQUFXLENBQUMyRDtnQ0FDekM7NEJBQ0YsR0FBRzt3QkFDTCxFQUFFLE9BQU85TCxPQUFPOzRCQUNkcUUsUUFBUXJFLEtBQUssQ0FBQyxzQkFBc0JBOzRCQUNwQ2UsY0FBYyxzQkFBb0MsT0FBZGYsTUFBTXNFLE9BQU87d0JBQ25ELFNBQVU7NEJBQ1Isb0JBQW9COzRCQUNwQndDLFdBQVcsSUFBTXZHLGNBQWMsT0FBTzt3QkFDeEM7b0JBQ0YsR0FBR3dLLEtBQUssQ0FBQy9LLENBQUFBO3dCQUNQcUUsUUFBUXJFLEtBQUssQ0FBQyxzQ0FBc0NBO3dCQUNwRGUsY0FBYyxzQkFBb0MsT0FBZGYsTUFBTXNFLE9BQU87d0JBQ2pEL0QsY0FBYztvQkFDaEI7Z0JBQ0Y7Z0JBQ0E7WUFFRixLQUFLO2dCQUNILGVBQWU7Z0JBQ2Ysa0NBQWtDO2dCQUNsQyxJQUFJNEYsUUFBUTtvQkFDVixNQUFNTSxNQUFNTixPQUFPTyxVQUFVLENBQUM7b0JBQzlCRCxJQUFJRSxTQUFTLENBQUMsR0FBRyxHQUFHUixPQUFPM0gsS0FBSyxFQUFFMkgsT0FBTzFILE1BQU07b0JBQy9DZ0ksSUFBSUcsU0FBUyxHQUFHO29CQUNoQkgsSUFBSUksUUFBUSxDQUFDLEdBQUcsR0FBR1YsT0FBTzNILEtBQUssRUFBRTJILE9BQU8xSCxNQUFNO29CQUM5Q3NDLGNBQWM7Z0JBQ2hCO2dCQUNBO1lBRUY7Z0JBQ0VBLGNBQWMscUJBQWdDLE9BQVh5SDtRQUN2QztJQUNGO0lBRUEsTUFBTTZELDJCQUEyQjtRQUMvQixJQUFJLENBQUNuRyxZQUFZLENBQUNoRyxZQUFZO1FBRTlCaUIsdUJBQXVCO1FBQ3ZCRSwyQkFBMkI7UUFDM0JnSCxhQUFhO0lBQ2Y7SUFFQSxNQUFNaUUseUJBQXlCO1FBQzdCLElBQUksQ0FBQ3BHLFlBQVksQ0FBQ2hHLFlBQVk7UUFFOUJpQix1QkFBdUI7UUFDdkJNLHlCQUF5QjtRQUN6QlYsY0FBYztJQUNoQjtJQUVBLE1BQU13TCxvQkFBb0I7UUFDeEIsSUFBSSxDQUFDckcsWUFBWSxDQUFDaEcsWUFBWTtRQUU5Qm1JLGFBQWE7SUFDZjtJQUVBLE1BQU1tRSxvQkFBb0IsQ0FBQ3ZGO1FBQ3pCLElBQUksQ0FBQ2YsWUFBWSxDQUFDaEcsWUFBWTtRQUU5Qm9DLFdBQVc7WUFDVDlELE9BQU95SSxXQUFXekksS0FBSztZQUN2QkMsUUFBUXdJLFdBQVd4SSxNQUFNO1lBQ3pCOEQsVUFBVTBFLFdBQVcxRSxRQUFRLElBQUk7UUFDbkM7UUFDQXhCLGNBQWMsaUJBQXFDa0csT0FBcEJBLFdBQVd6SSxLQUFLLEVBQUMsS0FBcUIsT0FBbEJ5SSxXQUFXeEksTUFBTTtJQUN0RTtJQUVBLDBCQUEwQjtJQUMxQixNQUFNMkosZUFBZSxDQUFDMUM7UUFDcEIsTUFBTWdELGlCQUFpQmhELFNBQVMrRyxZQUFZL0csT0FBTyxDQUFDcEY7UUFDcERDLGNBQWNtSTtRQUVkLDRDQUE0QztRQUM1QyxJQUFJLENBQUNBLGdCQUFnQjtZQUNuQnpILGVBQWU7UUFDakI7UUFFQUYsY0FBYyxVQUFnRCxPQUF0QzJILGlCQUFpQixVQUFVLFVBQXFELE9BQTFDLENBQUNBLGlCQUFpQixxQkFBcUI7UUFFckcsNERBQTREO1FBQzVENUIsV0FBV00sd0JBQXdCO0lBQ3JDO0lBRUEsMEJBQTBCO0lBQzFCLE1BQU1zRixnQkFBZ0I7UUFDcEIsSUFBSXBNLFlBQVk7WUFDZFcsZUFBZWdFLENBQUFBLE9BQVEsQ0FBQ0E7WUFDeEJsRSxjQUFjLFdBQTZDLE9BQWxDLENBQUNDLGNBQWMsVUFBVTtRQUNwRCxPQUFPO1lBQ0wsNkNBQTZDO1lBQzdDRCxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxvQ0FBb0M7SUFDcEMsTUFBTW1MLHNCQUFzQixDQUFDUztRQUMzQixJQUFJQSxhQUFhO1lBQ2YsZ0NBQWdDO1lBQ2hDLElBQUk3SCxPQUFPcUcsY0FBYyxFQUFFO2dCQUN6QjVKLGNBQWM7Z0JBQ2RFLHlCQUF5QjtnQkFDekJKLDJCQUEyQjtnQkFFM0IsOENBQThDO2dCQUM5Q3lELE9BQU9xRyxjQUFjLENBQUN5QixvQkFBb0IsQ0FBQztvQkFDekNsTDtvQkFDQUU7b0JBQ0FFO29CQUNBRTtvQkFDQTZLLG9CQUFvQjtnQkFDdEI7Z0JBRUEsT0FBTztZQUNUO1lBQ0EsT0FBTztRQUNUO1FBRUEsMkNBQTJDO1FBQzNDLElBQUl6TCx5QkFBeUI7WUFDM0JpSCxhQUFhLENBQUMvRztZQUNkLE9BQU87UUFDVCxPQUFPO1lBQ0xILHVCQUF1QjtZQUN2QixPQUFPO1FBQ1Q7SUFDRjtJQUVBLCtDQUErQztJQUMvQyxNQUFNMkwsZUFBZTtRQUNuQixNQUFNLEVBQUUxSyxVQUFVLEVBQUUsR0FBR0Y7UUFDdkIsSUFBSUUsYUFBYSxJQUFJLE9BQU87UUFDNUIsSUFBSUEsYUFBYSxJQUFJLE9BQU87UUFDNUIsSUFBSUEsYUFBYSxJQUFJLE9BQU87UUFDNUIsT0FBTztJQUNUO0lBRUEsa0RBQWtEO0lBQ2xELE1BQU0ySywyQkFBMkIsQ0FBQzVGO1FBQ2hDcEUsZ0JBQWdCb0U7SUFDbEI7SUFFQSw0REFBNEQ7SUFDNURuSyxnREFBU0E7MENBQUM7WUFDUixNQUFNZ1E7d0VBQXdCLENBQUNDO29CQUM3QixJQUFJQSxNQUFNL0ksSUFBSSxDQUFDZ0osSUFBSSxLQUFLLGlCQUFpQjt3QkFDdkNuSyxnQkFBZ0JrSyxNQUFNL0ksSUFBSSxDQUFDd0IsSUFBSTtvQkFDakM7Z0JBQ0Y7O1lBRUFaLE9BQU9PLGdCQUFnQixDQUFDLFdBQVcySDtZQUNuQztrREFBTztvQkFDTGxJLE9BQU9RLG1CQUFtQixDQUFDLFdBQVcwSDtnQkFDeEM7O1FBQ0Y7eUNBQUcsRUFBRTtJQUVMLDZCQUE2QjtJQUM3QmhRLGdEQUFTQTswQ0FBQztZQUNSLE1BQU1tUTtxRUFBcUIsQ0FBQ0Y7b0JBQzFCLElBQUlBLE1BQU1HLE1BQU0sSUFBSUgsTUFBTUcsTUFBTSxDQUFDRixJQUFJLEtBQUssZ0JBQWdCO3dCQUN4RHJLLGlCQUFpQm9LLE1BQU1HLE1BQU0sQ0FBQzFOLE1BQU07d0JBQ3BDLHFEQUFxRDt3QkFDckQsTUFBTXVOLFFBQVEsSUFBSUksWUFBWSx5QkFBeUI7NEJBQ3JERCxRQUFRO2dDQUNORixNQUFNO2dDQUNOeE4sUUFBUXVOLE1BQU1HLE1BQU0sQ0FBQzFOLE1BQU07NEJBQzdCO3dCQUNGO3dCQUNBb0YsT0FBT3dJLGFBQWEsQ0FBQ0w7b0JBQ3ZCO2dCQUNGOztZQUVBbkksT0FBT08sZ0JBQWdCLENBQUMsZ0JBQWdCOEg7WUFDeEM7a0RBQU87b0JBQ0xySSxPQUFPUSxtQkFBbUIsQ0FBQyxnQkFBZ0I2SDtnQkFDN0M7O1FBQ0Y7eUNBQUcsRUFBRTtJQUVMLDRDQUE0QztJQUM1Q25RLGdEQUFTQTswQ0FBQztZQUNSLElBQUkyQyxlQUFlO2dCQUNqQiwwQkFBMEI7Z0JBQzFCa0QsaUJBQWlCbEQ7Z0JBRWpCLGtEQUFrRDtnQkFDbEQsTUFBTXNOLFFBQVEsSUFBSUksWUFBWSx5QkFBeUI7b0JBQ3JERCxRQUFRO3dCQUNORixNQUFNO3dCQUNOeE4sUUFBUUM7b0JBQ1Y7Z0JBQ0Y7Z0JBQ0FtRixPQUFPd0ksYUFBYSxDQUFDTDtZQUN2QjtRQUNGO3lDQUFHO1FBQUN0TjtLQUFjO0lBRWxCLG1EQUFtRDtJQUNuRDNDLGdEQUFTQTswQ0FBQztZQUNSLE1BQU11UTsrREFBZTtvQkFDbkIsSUFBSSxDQUFDNU4sZUFBZTtvQkFFcEIsSUFBSTt3QkFDRixNQUFNK0QsV0FBVyxNQUFNQyxNQUFNLDZCQUEyQyxPQUFkaEU7d0JBQzFELElBQUksQ0FBQytELFNBQVNNLEVBQUUsRUFBRTs0QkFDaEIsTUFBTSxJQUFJQyxNQUFNO3dCQUNsQjt3QkFDQSxNQUFNdUosaUJBQWlCLE1BQU05SixTQUFTUyxJQUFJO3dCQUUxQyxpRUFBaUU7d0JBQ2pFLE1BQU1zSjtzRkFBYTtvQ0FBQ0MsMkVBQVU7Z0NBQzVCLElBQUl2SyxxQkFBcUJ1QixPQUFPLElBQUksT0FBT3ZCLHFCQUFxQnVCLE9BQU8sQ0FBQ2lKLGNBQWMsS0FBSyxZQUFZO29DQUNyRyxvQ0FBb0M7b0NBQ3BDeEsscUJBQXFCdUIsT0FBTyxDQUFDaUosY0FBYyxDQUFDSDtvQ0FFNUMsOEJBQThCO29DQUM5QixNQUFNUCxRQUFRLElBQUlJLFlBQVkseUJBQXlCO3dDQUNyREQsUUFBUTs0Q0FDTkYsTUFBTTs0Q0FDTnhOLFFBQVFDOzRDQUNSeUosT0FBT29FLGVBQWVwRSxLQUFLOzRDQUMzQkMsT0FBT21FLGVBQWVuRSxLQUFLO3dDQUM3QjtvQ0FDRjtvQ0FDQXZFLE9BQU93SSxhQUFhLENBQUNMO2dDQUN2QixPQUFPLElBQUlTLFVBQVUsR0FBRztvQ0FDdEI1RztrR0FBVyxJQUFNMkcsV0FBV0MsVUFBVTtpR0FBSTtnQ0FDNUMsT0FBTztvQ0FDTHJKLFFBQVE0QixJQUFJLENBQUM7Z0NBQ2Y7NEJBQ0Y7O3dCQUVBd0g7b0JBQ0YsRUFBRSxPQUFPek4sT0FBTzt3QkFDZHFFLFFBQVFyRSxLQUFLLENBQUMsMkJBQTJCQTtvQkFDM0M7Z0JBQ0Y7O1lBRUEscURBQXFEO1lBQ3JEOEcsV0FBV3lHLGNBQWM7UUFDM0I7eUNBQUc7UUFBQzVOO0tBQWM7SUFFbEIsb0NBQW9DO0lBQ3BDM0MsZ0RBQVNBOzBDQUFDO1lBQ1IsTUFBTTRROytEQUFlO29CQUNuQixJQUFJLENBQUNqTyxlQUFlO29CQUVwQixJQUFJO3dCQUNGLE1BQU0rRCxXQUFXLE1BQU1DLE1BQU0sNkJBQTJDLE9BQWRoRTt3QkFDMUQsSUFBSSxDQUFDK0QsU0FBU00sRUFBRSxFQUFFLE1BQU0sSUFBSUMsTUFBTTt3QkFFbEMsTUFBTTRKLFdBQVcsTUFBTW5LLFNBQVNTLElBQUk7d0JBQ3BDLElBQUloQixxQkFBcUJ1QixPQUFPLElBQUl2QixxQkFBcUJ1QixPQUFPLENBQUNpSixjQUFjLEVBQUU7NEJBQy9FeEsscUJBQXFCdUIsT0FBTyxDQUFDaUosY0FBYyxDQUFDRTt3QkFDOUM7b0JBRUEsa0RBQWtEO29CQUNwRCxFQUFFLE9BQU83TixPQUFPO3dCQUNkcUUsUUFBUXJFLEtBQUssQ0FBQywyQkFBMkJBO29CQUMzQztnQkFDRjs7WUFFQSxnQkFBZ0I7WUFDaEI0TjtZQUVBLDBCQUEwQjtZQUMxQixNQUFNRSxXQUFXMUQsWUFBWXdELGNBQWM7WUFFM0M7a0RBQU87b0JBQ0xwRCxjQUFjc0Q7Z0JBQ2hCOztRQUNGO3lDQUFHO1FBQUNuTztLQUFjO0lBRWxCLHFEQUFxRDtJQUNyRDNDLGdEQUFTQTswQ0FBQztZQUNSLE1BQU0rUTt1RUFBdUIsQ0FBQ2Q7d0JBQ3hCQSxlQUE0Q0E7b0JBQWhELElBQUlBLEVBQUFBLGdCQUFBQSxNQUFNRyxNQUFNLGNBQVpILG9DQUFBQSxjQUFjQyxJQUFJLE1BQUsscUJBQXFCRCxFQUFBQSxpQkFBQUEsTUFBTUcsTUFBTSxjQUFaSCxxQ0FBQUEsZUFBY3ZOLE1BQU0sTUFBS0MsZUFBZTt3QkFDdEYsTUFBTSxFQUFFeUosS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBRzRELE1BQU1HLE1BQU07d0JBQ3JDLElBQUlqSyxxQkFBcUJ1QixPQUFPLElBQUl2QixxQkFBcUJ1QixPQUFPLENBQUNpSixjQUFjLEVBQUU7NEJBQy9FeEsscUJBQXFCdUIsT0FBTyxDQUFDaUosY0FBYyxDQUFDO2dDQUFFdkU7Z0NBQU9DOzRCQUFNO3dCQUM3RDtvQkFDRjtnQkFDRjs7WUFFQSxNQUFNMkU7b0VBQW9CLENBQUNmO3dCQUNyQkEsZUFBa0NBO29CQUF0QyxJQUFJQSxFQUFBQSxnQkFBQUEsTUFBTUcsTUFBTSxjQUFaSCxvQ0FBQUEsY0FBY0MsSUFBSSxNQUFLLFdBQVdELEVBQUFBLGlCQUFBQSxNQUFNRyxNQUFNLGNBQVpILHFDQUFBQSxlQUFjdk4sTUFBTSxNQUFLQyxlQUFlO3dCQUM1RSxNQUFNLEVBQUVzTyxLQUFLLEVBQUUsR0FBR2hCLE1BQU1HLE1BQU07b0JBQzlCLG1DQUFtQztvQkFDbkMsMkNBQTJDO29CQUM3QztnQkFDRjs7WUFFQXRJLE9BQU9PLGdCQUFnQixDQUFDLHlCQUF5QjBJO1lBQ2pEakosT0FBT08sZ0JBQWdCLENBQUMsZUFBZTJJO1lBRXZDO2tEQUFPO29CQUNMbEosT0FBT1EsbUJBQW1CLENBQUMseUJBQXlCeUk7b0JBQ3BEakosT0FBT1EsbUJBQW1CLENBQUMsZUFBZTBJO2dCQUM1Qzs7UUFDRjt5Q0FBRztRQUFDck87S0FBYztJQUVsQixvQ0FBb0M7SUFDcEMsTUFBTTROLGVBQWUsT0FBTzdOO1FBQzFCLElBQUk7WUFDRjJFLFFBQVFrQixHQUFHLENBQUMsOEJBQThCN0Y7WUFDMUMsTUFBTWdFLFdBQVcsTUFBTUMsTUFBTSw2QkFBb0MsT0FBUGpFO1lBQzFELElBQUksQ0FBQ2dFLFNBQVNNLEVBQUUsRUFBRSxNQUFNLElBQUlDLE1BQU07WUFFbEMsTUFBTWlLLGVBQWUsTUFBTXhLLFNBQVNTLElBQUk7WUFDeENFLFFBQVFrQixHQUFHLENBQUMscUJBQXFCMkk7WUFFakMsaUNBQWlDO1lBQ2pDLE1BQU1qQixRQUFRLElBQUlJLFlBQVkseUJBQXlCO2dCQUNyREQsUUFBUTtvQkFDTkYsTUFBTTtvQkFDTnhOO29CQUNBLEdBQUd3TyxZQUFZO2dCQUNqQjtZQUNGO1lBQ0FwSixPQUFPd0ksYUFBYSxDQUFDTDtRQUN2QixFQUFFLE9BQU9qTixPQUFPO1lBQ2RxRSxRQUFRckUsS0FBSyxDQUFDLDJCQUEyQkE7UUFDM0M7SUFDRjtJQUVBLHlCQUF5QjtJQUN6QmhELGdEQUFTQTswQ0FBQztZQUNSLElBQUkyQyxpQkFBaUJBLGtCQUFrQmlELGVBQWU7Z0JBQ3BEeUIsUUFBUWtCLEdBQUcsQ0FBQyxnQ0FBZ0M1RjtnQkFDNUNrRCxpQkFBaUJsRDtnQkFFakIsNENBQTRDO2dCQUM1QyxNQUFNc04sUUFBUSxJQUFJSSxZQUFZLGdCQUFnQjtvQkFDNUNELFFBQVE7d0JBQUUxTixRQUFRQztvQkFBYztnQkFDbEM7Z0JBQ0FtRixPQUFPd0ksYUFBYSxDQUFDTDtnQkFFckIsaUNBQWlDO2dCQUNqQ00sYUFBYTVOO1lBQ2Y7UUFDRjt5Q0FBRztRQUFDQTtRQUFlaUQ7S0FBYztJQUVqQyw4QkFBOEI7SUFDOUI1RixnREFBU0E7MENBQUM7WUFDUixNQUFNK1E7dUVBQXVCLENBQUNkO29CQUM1QixJQUFJQSxNQUFNRyxNQUFNLElBQUlILE1BQU1HLE1BQU0sQ0FBQ0YsSUFBSSxLQUFLLG1CQUFtQjt3QkFDM0QsTUFBTSxFQUFFeE4sTUFBTSxFQUFFMEosS0FBSyxFQUFFQyxLQUFLLEVBQUUsR0FBRzRELE1BQU1HLE1BQU07d0JBQzdDLElBQUkxTixXQUFXa0QsZUFBZTs0QkFDNUIsb0NBQW9DOzRCQUNwQyxJQUFJTyxxQkFBcUJ1QixPQUFPLElBQUl2QixxQkFBcUJ1QixPQUFPLENBQUNpSixjQUFjLEVBQUU7Z0NBQy9FeEsscUJBQXFCdUIsT0FBTyxDQUFDaUosY0FBYyxDQUFDO29DQUMxQ3ZFLE9BQU9BLFNBQVM7b0NBQ2hCQyxPQUFPQSxTQUFTO2dDQUNsQjs0QkFDRjt3QkFDRjtvQkFDRjtnQkFDRjs7WUFFQXZFLE9BQU9PLGdCQUFnQixDQUFDLHlCQUF5QjBJO1lBQ2pEO2tEQUFPO29CQUNMakosT0FBT1EsbUJBQW1CLENBQUMseUJBQXlCeUk7Z0JBQ3REOztRQUNGO3lDQUFHO1FBQUNuTDtLQUFjO0lBRWxCLHFCQUNFLDhEQUFDMUU7UUFBSTZOLFdBQVcsa0JBQWlDLE9BQWZlOzswQkFDaEMsOERBQUM1UCxrREFBSUE7O2tDQUNILDhEQUFDaVI7a0NBQU07Ozs7OztrQ0FDUCw4REFBQ0M7d0JBQUtDLE1BQUs7d0JBQVdDLFNBQVE7Ozs7Ozs7Ozs7OztZQUkvQnBPLGNBQWNFLGtCQUFrQixnQ0FDL0IsOERBQUNsQztnQkFBSUMsT0FBTztvQkFDVkMsVUFBVTtvQkFDVkMsS0FBSztvQkFDTEMsTUFBTTtvQkFDTkUsT0FBTztvQkFDUCtQLFNBQVM7b0JBQ1Q3UCxpQkFBaUI7b0JBQ2pCYSxPQUFPO29CQUNQTixXQUFXO29CQUNYRSxVQUFVO29CQUNWRyxZQUFZO29CQUNaSixRQUFRO2dCQUNWOzBCQUFHOzs7Ozs7WUFNSmdCLGNBQWNNLDZCQUNiLDhEQUFDdEM7Z0JBQUk2TixXQUFVO2dCQUFpQjVOLE9BQU87b0JBQ3JDQyxVQUFVO29CQUNWQyxLQUFLaUMsYUFBY0Ysa0JBQWtCLGlCQUFpQixTQUFTLFNBQVU7b0JBQ3pFOUIsTUFBTTtvQkFDTkUsT0FBTztvQkFDUEUsaUJBQWlCO29CQUNqQmEsT0FBTztvQkFDUGdQLFNBQVM7b0JBQ1R0UCxXQUFXO29CQUNYdVAsV0FBVztvQkFDWHRQLFFBQVE7b0JBQ1J1UCxXQUFXO2dCQUNiOzBCQUNFLDRFQUFDQzs7d0JBQU87d0JBQUloTzs7Ozs7Ozs7Ozs7O1lBSWZaLDBCQUNDLDhEQUFDNUI7Z0JBQUk2TixXQUFVOzBCQUNiLDRFQUFDMU07OEJBQUU7Ozs7Ozs7Ozs7cUNBR0w7O29CQUVHYSxjQUFjZ0csMEJBQVksOERBQUNwSTs7Ozs7b0JBRzNCd0MsNEJBQ0MsOERBQUNsRCw4REFBTUE7d0JBQ0x1UixlQUFlcEc7d0JBQ2ZxRyxnQkFBZ0IsSUFBTXpOLHVCQUF1Qjt3QkFDN0NMLFlBQVlGLGlCQUFpQkU7d0JBQzdCK04sZ0JBQWdCLENBQUNDLE9BQVMvTixjQUFjK047d0JBQ3hDQyxnQkFBZ0IzRzt3QkFDaEI0RyxpQkFBaUJ0Qzt3QkFDakJ6SixXQUFXQTs7Ozs7O29CQUtkLENBQUMzQyw0QkFDQSw4REFBQ3BDO3dCQUFJNk4sV0FBVTt3QkFBMkI1TixPQUFPOzRCQUMvQ0MsVUFBVTs0QkFDVkMsS0FBSzs0QkFDTDRRLE9BQU87NEJBQ1AvUCxRQUFRO3dCQUNWO2tDQUNFLDRFQUFDZ1E7NEJBQ0NuRCxXQUFVOzRCQUNWb0QsU0FBUyxJQUFNL0csYUFBYTs0QkFDNUIrRixPQUFNOzRCQUNOaFEsT0FBTztnQ0FDTG9RLFNBQVM7Z0NBQ1RhLFlBQVk7Z0NBQ1o3UCxPQUFPO2dDQUNQWixRQUFRO2dDQUNSQyxjQUFjO2dDQUNkTyxVQUFVO2dDQUNWa1EsUUFBUTs0QkFDVjtzQ0FDRDs7Ozs7Ozs7Ozs7a0NBT0wsOERBQUNuUjt3QkFDQ29SLEtBQUt0TTt3QkFDTCtJLFdBQVU7d0JBQ1Y1TixPQUFPOzRCQUNMTSxRQUFRNkIsYUFBYSx3QkFBd0I7NEJBQzdDaVAsV0FBV25QLGtCQUFrQixpQkFBaUIsU0FBUzs0QkFDdkRoQyxVQUFVOzRCQUNWTSxpQkFBaUI7NEJBQ2pCOFEsVUFBVTt3QkFDWjs7MENBR0EsOERBQUN0UjtnQ0FBSTZOLFdBQVU7Z0NBQWtDNU4sT0FBTztvQ0FDdERDLFVBQVU7b0NBQ1ZxUixRQUFRO29DQUNSblIsTUFBTTtvQ0FDTkMsV0FBVztvQ0FDWFcsUUFBUTtvQ0FDUndRLFVBQVU7b0NBQ1ZsUixPQUFPO29DQUNQK1AsU0FBUztnQ0FDWDswQ0FDRSw0RUFBQ2pSLDJFQUFpQkE7b0NBQ2hCZ1MsS0FBS25NO29DQUNMK0kscUJBQXFCQTtvQ0FDckJ5RCxlQUFlek4sV0FBVzFELEtBQUssR0FBRztvQ0FDbENvUixlQUFlckg7Ozs7Ozs7Ozs7OzRCQUlsQixDQUFDakgsMkJBQ0E7O2tEQUNFLDhEQUFDcEQ7d0NBQUk2TixXQUFVO3dDQUF5QjVOLE9BQU87NENBQzdDb1EsU0FBUzs0Q0FDVHRQLFdBQVc7NENBQ1hiLFVBQVVrQyxhQUFhLGFBQWE7NENBQ3BDOUIsT0FBTzs0Q0FDUFUsUUFBUTt3Q0FDVjs7MERBQ0UsOERBQUNHOzBEQUFFOzs7Ozs7MERBQ0gsOERBQUNBO2dEQUFFME0sV0FBVTs7b0RBQXdCO29EQUFpQjdKLFdBQVdFLFVBQVU7b0RBQUM7Ozs7Ozs7NENBRzNFbEMsY0FBY3NCLHVDQUNiLDhEQUFDdEQ7Z0RBQ0M2TixXQUFVO2dEQUNWNU4sT0FBTztvREFDTEssT0FBTztvREFDUEMsUUFBUTtvREFDUm9SLFFBQVE7b0RBQ1JsUixRQUFRO29EQUNSQyxjQUFjO29EQUNkRixpQkFBaUI7b0RBQ2pCRyxTQUFTO29EQUNURyxZQUFZO29EQUNaRCxnQkFBZ0I7Z0RBQ2xCOzBEQUVBLDRFQUFDYjtvREFBSUMsT0FBTzt3REFBRWdCLFVBQVU7b0RBQVM7OERBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7O2tEQU0xQyw4REFBQ2pCO3dDQUNDNk4sV0FBVTt3Q0FDVjVOLE9BQU87NENBQ0xDLFVBQVU7NENBQ1ZDLEtBQUs7NENBQ0xDLE1BQU07NENBQ05FLE9BQU87NENBQ1BDLFFBQVE7NENBQ1JDLGlCQUFpQjs0Q0FDakI4USxVQUFVOzRDQUNWN1EsUUFBUTs0Q0FDUk8sUUFBUTt3Q0FDVjs7Ozs7OzsrQ0FhRjs0QkFHSGdCLGNBQWNjLDZCQUNiLDhEQUFDM0QsdUVBQWVBO2dDQUNkbUIsT0FBTzZELFFBQVE3RCxLQUFLO2dDQUNwQkMsUUFBUTRELFFBQVE1RCxNQUFNO2dDQUN0QjhELFVBQVVGLFFBQVFFLFFBQVE7Z0NBQzFCNEUsV0FBV25HOzs7Ozs7NEJBS2RkLGNBQWNnRyxZQUFZNUUsNEJBQ3pCLDhEQUFDdEQ7Z0NBQ0M4UixXQUFXeE87Z0NBQ1h5TyxTQUFTeEQ7Z0NBQ1R5RCxlQUFleEQ7Z0NBQ2Y5SyxjQUFjQTtnQ0FDZEUsaUJBQWlCQTtnQ0FDakJFLFVBQVVBO2dDQUNWRSxnQkFBZ0JBO2dDQUNoQmtCLFVBQVVBOzs7Ozs7NEJBS2JoRCxjQUFjZ0csWUFBWWhGLHFDQUN6Qiw4REFBQ2hEO2dDQUFJNk4sV0FBVTtnQ0FBMEI1TixPQUFPO29DQUM5Q0MsVUFBVTtvQ0FDVkMsS0FBSztvQ0FDTEMsTUFBTTtvQ0FDTkUsT0FBTztvQ0FDUEMsUUFBUTtvQ0FDUkMsaUJBQWlCO29DQUNqQkcsU0FBUztvQ0FDVEUsZ0JBQWdCO29DQUNoQkMsWUFBWTtvQ0FDWkUsUUFBUTtnQ0FDVjswQ0FDRSw0RUFBQ2hCO29DQUFJNk4sV0FBVTtvQ0FBMkI1TixPQUFPO3dDQUMvQ0ssT0FBTzt3Q0FDUEUsaUJBQWlCO3dDQUNqQkUsY0FBYzt3Q0FDZDJQLFNBQVM7d0NBQ1RDLFdBQVc7b0NBQ2I7O3NEQUNFLDhEQUFDeUI7NENBQUdsRSxXQUFVOzRDQUEwQjVOLE9BQU87Z0RBQzdDMFIsUUFBUTtnREFDUjFRLFVBQVU7Z0RBQ1ZHLFlBQVk7NENBQ2Q7c0RBQUc7Ozs7OztzREFDSCw4REFBQ0Q7NENBQUUwTSxXQUFVOzRDQUE0QjVOLE9BQU87Z0RBQzlDMFIsUUFBUTtnREFDUjFRLFVBQVU7Z0RBQ1YrUSxZQUFZOzRDQUNkO3NEQUFHOzs7Ozs7c0RBSUgsOERBQUNoUzs0Q0FBSTZOLFdBQVU7NENBQTRCNU4sT0FBTztnREFDaERVLFNBQVM7Z0RBQ1RFLGdCQUFnQjtnREFDaEJvUixLQUFLOzRDQUNQOzs4REFDRSw4REFBQ2pCO29EQUNDQyxTQUFTN0M7b0RBQ1RQLFdBQVU7b0RBQ1Y1TixPQUFPO3dEQUNMb1EsU0FBUzt3REFDVDdQLGlCQUFpQjt3REFDakJDLFFBQVE7d0RBQ1JDLGNBQWM7d0RBQ2R5USxRQUFRO29EQUNWOzhEQUNEOzs7Ozs7OERBR0QsOERBQUNIO29EQUNDQyxTQUFTOUM7b0RBQ1ROLFdBQVU7b0RBQ1Y1TixPQUFPO3dEQUNMb1EsU0FBUzt3REFDVDdQLGlCQUFpQjt3REFDakJhLE9BQU87d0RBQ1BaLFFBQVE7d0RBQ1JDLGNBQWM7d0RBQ2R5USxRQUFRO29EQUNWOzhEQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWXJCO0dBbGtEd0I3UDs7UUFDUDNCLGtEQUFTQTtRQUNVRCwwRUFBVUE7OztNQUZ0QjRCIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNb2RpZmllZCBpbmRleC5qcyAtIEZpeGluZyBjYW52YXMgcmVmZXJlbmNlIGlzc3Vlc1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBIZWFkIGZyb20gJ25leHQvaGVhZCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IFRvcEJhciBmcm9tICcuL2NvbXBvbmVudHMtZ3VpL3RvcEJhcic7XG5pbXBvcnQgRGlzcGxheVJlc3BvbnNlIGZyb20gJy4vY29tcG9uZW50cy1ndWkvZGlzcGxheVJlc3BvbnNlJztcbmltcG9ydCB7IEFjdGlvbkJ1dHRvbkdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzLWd1aS9hY3Rpb25CdXR0b24nO1xuaW1wb3J0IHsgc2hvd0NhcHR1cmVQcmV2aWV3LCBjYXB0dXJlSW1hZ2VzQXRQb2ludCwgZHJhd1JlZERvdCwgZ2V0UmFuZG9tUG9zaXRpb24sIHJ1bkNvdW50ZG93biB9IGZyb20gJy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlJztcbi8vIGltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyB1c2VDb25zZW50IH0gZnJvbSAnLi4vLi4vY29tcG9uZW50cy9jb25zZW50L0NvbnNlbnRDb250ZXh0JztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcblxuLy8gRHluYW1pY2FsbHkgbG9hZCB0aGUgdmlkZW8gcHJvY2Vzc29yIGNvbXBvbmVudCAobm90IHRoZSBob29rIGRpcmVjdGx5KVxuY29uc3QgVmlkZW9Qcm9jZXNzb3JDb21wb25lbnQgPSBkeW5hbWljKFxuICAoKSA9PiBpbXBvcnQoJy4vY29tcG9uZW50cy1ndWkvVmlkZW9Qcm9jZXNzb3JDb21wb25lbnQnKSxcbiAgeyBzc3I6IGZhbHNlIH1cbik7XG5cbi8vIER5bmFtaWNhbGx5IGltcG9ydCB0aGUgY2FtZXJhIGNvbXBvbmVudCB3aXRoIFNTUiBkaXNhYmxlZFxuY29uc3QgRHluYW1pY0NhbWVyYUFjY2VzcyA9IGR5bmFtaWMoXG4gICgpID0+IGltcG9ydCgnLi9jb21wb25lbnRzLWd1aS9jYW1lcmFBY2Nlc3MnKSxcbiAgeyBcbiAgICBzc3I6IGZhbHNlLFxuICAgIGxvYWRpbmc6ICgpID0+IChcbiAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxuICAgICAgICB3aWR0aDogJzQ4MHB4JyxcbiAgICAgICAgaGVpZ2h0OiAnMzYwcHgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmOGZmJyxcbiAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkICMwMDY2Y2MnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB6SW5kZXg6IDk5OVxuICAgICAgfX0+XG4gICAgICAgIDxkaXYgc3R5bGU9e3sgZm9udFNpemU6ICc0OHB4JywgbWFyZ2luQm90dG9tOiAnMTVweCcgfX0+8J+TtzwvZGl2PlxuICAgICAgICA8cCBzdHlsZT17eyBmb250U2l6ZTogJzE2cHgnLCBmb250V2VpZ2h0OiAnYm9sZCcsIGNvbG9yOiAnIzAwNjZjYycgfX0+XG4gICAgICAgICAgTG9hZGluZyBjYW1lcmEuLi5cbiAgICAgICAgPC9wPlxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2xsZWN0ZWREYXRhc2V0UGFnZSgpIHtcbiAgY29uc3Qgcm91dGVyID0gdXNlUm91dGVyKCk7XG4gIGNvbnN0IHsgdXNlcklkOiBjb25zZW50VXNlcklkIH0gPSB1c2VDb25zZW50KCk7XG4gIGNvbnN0IFt1c2VyRGF0YSwgc2V0VXNlckRhdGFdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2lzSHlkcmF0ZWQsIHNldElzSHlkcmF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbYmFja2VuZFN0YXR1cywgc2V0QmFja2VuZFN0YXR1c10gPSB1c2VTdGF0ZSgnY2hlY2tpbmcnKTtcbiAgY29uc3QgW3Nob3dUb3BCYXIsIHNldFNob3dUb3BCYXJdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzaG93V2FybmluZywgc2V0U2hvd1dhcm5pbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbd2FybmluZ01lc3NhZ2UsIHNldFdhcm5pbmdNZXNzYWdlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3N0YXR1c01lc3NhZ2UsIHNldFN0YXR1c01lc3NhZ2VdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbb3V0cHV0VGV4dCwgc2V0T3V0cHV0VGV4dF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtzaG93TWV0cmljcywgc2V0U2hvd01ldHJpY3NdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzaG93UGVybWlzc2lvblBvcHVwLCBzZXRTaG93UGVybWlzc2lvblBvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhbWVyYVBlcm1pc3Npb25HcmFudGVkLCBzZXRDYW1lcmFQZXJtaXNzaW9uR3JhbnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93Q2FtZXJhLCBzZXRTaG93Q2FtZXJhXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dDYW1lcmFQbGFjZWhvbGRlciwgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dIZWFkUG9zZSwgc2V0U2hvd0hlYWRQb3NlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dCb3VuZGluZ0JveCwgc2V0U2hvd0JvdW5kaW5nQm94XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Nob3dNYXNrLCBzZXRTaG93TWFza10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGFyYW1ldGVycywgc2V0U2hvd1BhcmFtZXRlcnNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbd2luZG93U2l6ZSwgc2V0V2luZG93U2l6ZV0gPSB1c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHBlcmNlbnRhZ2U6IDEwMCB9KTtcbiAgY29uc3QgW21ldHJpY3MsIHNldE1ldHJpY3NdID0gdXNlU3RhdGUoeyB3aWR0aDogJy0tLScsIGhlaWdodDogJy0tLScsIGRpc3RhbmNlOiAnLS0tJyB9KTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2NhcHR1cmVGb2xkZXIsIHNldENhcHR1cmVGb2xkZXJdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuICBjb25zdCBbc2hvd1NldHRpbmdzLCBzZXRTaG93U2V0dGluZ3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFJlZnNcbiAgY29uc3QgcHJldmlld0FyZWFSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFjdGlvbkJ1dHRvbkdyb3VwUmVmID0gdXNlUmVmKG51bGwpO1xuXG4gIC8vIFNldCBoeWRyYXRlZCBzdGF0ZSBhZnRlciBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldElzSHlkcmF0ZWQodHJ1ZSk7XG4gIH0sIFtdKTtcblxuICAvLyBMb2FkIHVzZXIgZGF0YVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWRVc2VyRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghcm91dGVyLmlzUmVhZHkpIHJldHVybjtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJvdXRlci5xdWVyeS51c2VyRGF0YSkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKHJvdXRlci5xdWVyeS51c2VyRGF0YSk7XG4gICAgICAgICAgc2V0VXNlckRhdGEocGFyc2VkRGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdXRlci5xdWVyeS51c2VySWQpIHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvdXNlci1wcmVmZXJlbmNlcy8ke3JvdXRlci5xdWVyeS51c2VySWR9YCwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAnWC1BUEktS2V5JzogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0tFWSB8fCAnQTFCMkMzRDQtRTVGNi03ODkwLUdISUotS0xNTk9QUVJTVFVWJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHVzZXIgZGF0YScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHNldFVzZXJEYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB1c2VyIGRhdGE6JywgZXJyKTtcbiAgICAgICAgc2V0RXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgbG9hZFVzZXJEYXRhKCk7XG4gIH0sIFtyb3V0ZXIuaXNSZWFkeSwgcm91dGVyLnF1ZXJ5XSk7XG5cbiAgLy8gQ2hlY2sgYmFja2VuZCBjb25uZWN0aW9uXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hlY2stYmFja2VuZC1jb25uZWN0aW9uJyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNldEJhY2tlbmRTdGF0dXMoZGF0YS5jb25uZWN0ZWQgPyAnY29ubmVjdGVkJyA6ICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIGJhY2tlbmQgY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgICAgIHNldEJhY2tlbmRTdGF0dXMoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoaXNIeWRyYXRlZCkge1xuICAgICAgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbigpO1xuICAgIH1cbiAgfSwgW2lzSHlkcmF0ZWRdKTtcblxuICAvLyBVcGRhdGUgd2luZG93IHNpemVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgaWYgKHByZXZpZXdBcmVhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwcmV2aWV3QXJlYVJlZi5jdXJyZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwcmV2aWV3QXJlYVJlZi5jdXJyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3Qgc2NyZWVuUGVyY2VudGFnZSA9ICh3aW5kb3cuaW5uZXJXaWR0aCAvIHdpbmRvdy5zY3JlZW4ud2lkdGgpICogMTAwO1xuICAgICAgICBcbiAgICAgICAgc2V0TWV0cmljcyhwcmV2ID0+ICh7IC4uLnByZXYsIHdpZHRoLCBoZWlnaHQgfSkpO1xuICAgICAgICBzZXRXaW5kb3dTaXplKHtcbiAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgcGVyY2VudGFnZTogTWF0aC5yb3VuZChzY3JlZW5QZXJjZW50YWdlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKGlzSHlkcmF0ZWQpIHtcbiAgICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgIHJldHVybiAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgfVxuICB9LCBbaXNIeWRyYXRlZF0pO1xuXG4gIC8vIEluaXRpYWxpemUgc2V0dGluZ3MgYmFzZWQgb24gdXNlciBkYXRhXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHVzZXJEYXRhICYmIGNvbnNlbnRVc2VySWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgc2V0dGluZ3MgZm9yIHVzZXI6JywgY29uc2VudFVzZXJJZCwgdXNlckRhdGEpO1xuICAgICAgXG4gICAgICAvLyBJbml0aWFsaXplIHVzZXItc3BlY2lmaWMgc2V0dGluZ3NcbiAgICAgIGlmICh1c2VyRGF0YS5wcmVmZXJlbmNlcykge1xuICAgICAgICBjb25zdCB7IHByZWZlcmVuY2VzIH0gPSB1c2VyRGF0YTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBjYW1lcmEgc2V0dGluZ3MgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChwcmVmZXJlbmNlcy5jYW1lcmFTZXR0aW5ncykge1xuICAgICAgICAgIGNvbnN0IHsgc2hvd0hlYWRQb3NlLCBzaG93Qm91bmRpbmdCb3gsIHNob3dNYXNrLCBzaG93UGFyYW1ldGVycyB9ID0gcHJlZmVyZW5jZXMuY2FtZXJhU2V0dGluZ3M7XG4gICAgICAgICAgc2V0U2hvd0hlYWRQb3NlKHNob3dIZWFkUG9zZSB8fCBmYWxzZSk7XG4gICAgICAgICAgc2V0U2hvd0JvdW5kaW5nQm94KHNob3dCb3VuZGluZ0JveCB8fCBmYWxzZSk7XG4gICAgICAgICAgc2V0U2hvd01hc2soc2hvd01hc2sgfHwgZmFsc2UpO1xuICAgICAgICAgIHNldFNob3dQYXJhbWV0ZXJzKHNob3dQYXJhbWV0ZXJzIHx8IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIG90aGVyIHNldHRpbmdzIGFzIG5lZWRlZFxuICAgICAgICBpZiAocHJlZmVyZW5jZXMubWV0cmljcykge1xuICAgICAgICAgIHNldFNob3dNZXRyaWNzKHByZWZlcmVuY2VzLm1ldHJpY3Muc2hvdyB8fCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHByZWZlcmVuY2VzLnRvcEJhcikge1xuICAgICAgICAgIHNldFNob3dUb3BCYXIocHJlZmVyZW5jZXMudG9wQmFyLnNob3cgfHwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIFt1c2VyRGF0YSwgY29uc2VudFVzZXJJZF0pO1xuXG4gIC8vIEltcHJvdmVkIGdldCBjYW52YXMgZnVuY3Rpb24gdGhhdCB0cmllcyBtdWx0aXBsZSBtZXRob2RzXG4gIGNvbnN0IGdldE1haW5DYW52YXMgPSAoKSA9PiB7XG4gICAgLy8gTWV0aG9kIDE6IENoZWNrIGlmIHdlIGhhdmUgYSBkaXJlY3QgcmVmZXJlbmNlXG4gICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGRpcmVjdCBjYW52YXNSZWYuY3VycmVudCByZWZlcmVuY2VcIik7XG4gICAgICByZXR1cm4gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ldGhvZCAyOiBUcnkgdG8gZ2V0IGdsb2JhbCByZWZlcmVuY2VcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGdsb2JhbCB3aGl0ZVNjcmVlbkNhbnZhcyByZWZlcmVuY2VcIik7XG4gICAgICBjYW52YXNSZWYuY3VycmVudCA9IHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhczsgLy8gVXBkYXRlIG91ciByZWZcbiAgICAgIHJldHVybiB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ldGhvZCAzOiBUcnkgdG8gZmluZCB2aWEgRE9NXG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBpZiAoY2FudmFzRWxlbWVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkZvdW5kIGNhbnZhcyB2aWEgRE9NIHNlbGVjdG9yXCIpO1xuICAgICAgICBjYW52YXNSZWYuY3VycmVudCA9IGNhbnZhc0VsZW1lbnQ7IC8vIFVwZGF0ZSBvdXIgcmVmXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhc0VsZW1lbnQ7IC8vIFVwZGF0ZSBnbG9iYWwgcmVmIHRvb1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW52YXNFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLndhcm4oXCJObyBjYW52YXMgZm91bmQgdmlhIGFueSBtZXRob2RcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIFxuICAvLyBDaGVjayBpZiB3ZSdyZSBvbiB0aGUgY2xpZW50IG9yIHNlcnZlclxuICBjb25zdCBpc0NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICBcbiAgLy8gQWRkIGVmZmVjdCB0byBpbml0aWFsaXplIGNhbnZhcyBhbmQgbWFrZSBpdCBnbG9iYWxseSBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gRGVidWcgaW5mbyB0byB2ZXJpZnkgY2FudmFzIHNpemUgYW5kIGF2YWlsYWJpbGl0eVxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiSW5kZXguanM6IENhbnZhcyBpbml0aWFsaXplZFwiLCB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1ha2UgY2FudmFzIEVYUExJQ0lUTFkgYXZhaWxhYmxlIGdsb2JhbGx5XG4gICAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG4gICAgICBcbiAgICAgIC8vIEFsc28gc3RvcmUgY2FudmFzIGRpbWVuc2lvbnNcbiAgICAgIHdpbmRvdy5jYW52YXNEaW1lbnNpb25zID0ge1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgaW5pdGlhbGl6YXRpb25cIik7XG4gICAgfVxuICAgIFxuICAgIC8vIEV4cG9zZSBjYW52YXMgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb24gZ2xvYmFsbHlcbiAgICB3aW5kb3cuaW5pdGlhbGl6ZUNhbnZhcyA9IChjYW52YXMsIHBhcmVudCkgPT4ge1xuICAgICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tpbml0aWFsaXplQ2FudmFzXSBDYW52YXMgb3IgcGFyZW50IGlzIG51bGwnLCB7IGNhbnZhcywgcGFyZW50IH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICAgICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIGFuZCBzZXQgd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgQ2FudmFzIGluaXRpYWxpemVkIHdpdGggZGltZW5zaW9uczogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgcmVmZXJlbmNlXG4gICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgICAgd2luZG93LmNhbnZhc0RpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW2luaXRpYWxpemVDYW52YXNdIEVycm9yIGluaXRpYWxpemluZyBjYW52YXM6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBDaGVjayBjYW52YXMgdmlzaWJpbGl0eSBhbmQgZm9yY2UgaW5pdGlhbGl6YXRpb24gYWZ0ZXIgYSBicmllZiBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNhbnZhcyBpbml0aWFsIHZpc2liaWxpdHkgY2hlY2s6XCIsIHtcbiAgICAgICAgICBkaW1lbnNpb25zOiBgJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gLFxuICAgICAgICAgIHJlY3RTaXplOiBgJHtyZWN0LndpZHRofXgke3JlY3QuaGVpZ2h0fWAsXG4gICAgICAgICAgaXNWaXNpYmxlOiAocmVjdC53aWR0aCA+IDAgJiYgcmVjdC5oZWlnaHQgPiAwKVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZvcmNlIGluaXRpYWxpemF0aW9uIGlmIG5lZWRlZFxuICAgICAgICBhZGp1c3RDYW52YXNEaW1lbnNpb25zKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJDYW52YXMgbm90IGZvdW5kIGR1cmluZyB2aXNpYmlsaXR5IGNoZWNrXCIpO1xuICAgICAgfVxuICAgIH0sIDUwMCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlbGV0ZSB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgICBkZWxldGUgd2luZG93LmNhbnZhc0RpbWVuc2lvbnM7XG4gICAgICBkZWxldGUgd2luZG93LmluaXRpYWxpemVDYW52YXM7XG4gICAgfTtcbiAgfSwgW2lzSHlkcmF0ZWRdKTtcbiAgLy8gSW1wcm92ZWQgY2FudmFzIGRpbWVuc2lvbnMgYWRqdXN0bWVudFxuICBjb25zdCBhZGp1c3RDYW52YXNEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQgfHwgIXByZXZpZXdBcmVhUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGNhbnZhcyBmb3VuZCB0byBhZGp1c3QgZGltZW5zaW9uc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29udGFpbmVyID0gcHJldmlld0FyZWFSZWYuY3VycmVudDtcbiAgICBcbiAgICAvLyBHZXQgdGhlIHNpemUgb2YgdGhlIHByZXZpZXcgYXJlYVxuICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHByb3BlciBoZWlnaHQgYmFzZWQgb24gdG9wIGJhciB2aXNpYmlsaXR5XG4gICAgY29uc3QgdG9wQmFySGVpZ2h0ID0gc2hvd1RvcEJhciA/IDEyMCA6IDA7IC8vIEFkanVzdCB0aGlzIHZhbHVlIGJhc2VkIG9uIHlvdXIgdG9wIGJhcidzIGFjdHVhbCBoZWlnaHRcbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIkFkanVzdGluZyBjYW52YXMgZGltZW5zaW9uc1wiLCB7XG4gICAgICBjb250YWluZXJXaWR0aDogcmVjdC53aWR0aCxcbiAgICAgIGNvbnRhaW5lckhlaWdodDogcmVjdC5oZWlnaHQsXG4gICAgICB0b3BCYXJWaXNpYmxlOiBzaG93VG9wQmFyLFxuICAgICAgY2FsY3VsYXRlZEhlaWdodDogcmVjdC5oZWlnaHRcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggY29udGFpbmVyIHNpemUgd2l0aCB0b3AgYmFyIGFkanVzdG1lbnRcbiAgICBjYW52YXMud2lkdGggPSByZWN0LndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgY2FudmFzXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIEZpbGwgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYENhbnZhcyBkaW1lbnNpb25zIGFkanVzdGVkOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBnbG9iYWwgcmVmZXJlbmNlIHdpdGggY3VycmVudCBkaW1lbnNpb25zXG4gICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgIHdpbmRvdy5jYW52YXNEaW1lbnNpb25zID0ge1xuICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgY2FwdHVyZSBmb2xkZXIgb24gY29tcG9uZW50IG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjYXB0dXJlRm9sZGVyICYmIGlzQ2xpZW50ICYmIGlzSHlkcmF0ZWQpIHtcbiAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bOlxcLl0vZywgJy0nKTtcbiAgICAgIHNldENhcHR1cmVGb2xkZXIoYHNlc3Npb25fJHt0aW1lc3RhbXB9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgQ3JlYXRlZCBjYXB0dXJlIGZvbGRlcjogc2Vzc2lvbl8ke3RpbWVzdGFtcH1gKTtcbiAgICB9XG4gIH0sIFtjYXB0dXJlRm9sZGVyLCBpc0NsaWVudCwgaXNIeWRyYXRlZF0pO1xuICBcbiAgLy8gQ2hlY2sgYmFja2VuZCBjb25uZWN0aW9uIG9uIG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuOyAvLyBTa2lwIG9uIHNlcnZlciBvciBiZWZvcmUgaHlkcmF0aW9uXG4gICAgXG4gICAgY29uc3QgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvY2hlY2stYmFja2VuZC1jb25uZWN0aW9uJyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHNldEJhY2tlbmRTdGF0dXMoZGF0YS5jb25uZWN0ZWQgPyAnY29ubmVjdGVkJyA6ICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgY29uc29sZS5sb2coYEJhY2tlbmQgY29ubmVjdGlvbjogJHtkYXRhLmNvbm5lY3RlZCA/ICdPSycgOiAnRmFpbGVkJ31gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgc3RhdHVzIGluIG91dHB1dCB0ZXh0XG4gICAgICAgIHNldE91dHB1dFRleHQoYEJhY2tlbmQgJHtkYXRhLmNvbm5lY3RlZCA/ICdjb25uZWN0ZWQnIDogJ2Rpc2Nvbm5lY3RlZCAtIHVzaW5nIG1vY2sgbW9kZSd9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBiYWNrZW5kIGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgICBzZXRCYWNrZW5kU3RhdHVzKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgc2V0T3V0cHV0VGV4dCgnQmFja2VuZCBkaXNjb25uZWN0ZWQgLSB1c2luZyBtb2NrIG1vZGUnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbigpO1xuICAgIFxuICAgIC8vIFdlbGNvbWUgbWVzc2FnZSBhZnRlciBiYWNrZW5kIGNoZWNrXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRPdXRwdXRUZXh0KCdDYW1lcmEgc3lzdGVtIHJlYWR5LiBDbGljayBcIlNob3cgUHJldmlld1wiIHRvIHN0YXJ0IGNhbWVyYS4nKTtcbiAgICB9LCAyMDAwKTtcbiAgfSwgW2lzSHlkcmF0ZWRdKTtcblxuICAvLyBBZGQgc3R5bGVzIHRvIGRvY3VtZW50IGhlYWQgZm9yIGJ1dHRvbiBoaWdobGlnaHRpbmdcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgc3R5bGUgZWxlbWVudFxuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IGBcbiAgICAgIEBrZXlmcmFtZXMgcHVsc2Uge1xuICAgICAgICAwJSB7IGJveC1zaGFkb3c6IDAgMCAwIDAgcmdiYSgwLCAxMDIsIDIwNCwgMC43KTsgfVxuICAgICAgICA3MCUgeyBib3gtc2hhZG93OiAwIDAgMCAxMHB4IHJnYmEoMCwgMTAyLCAyMDQsIDApOyB9XG4gICAgICAgIDEwMCUgeyBib3gtc2hhZG93OiAwIDAgMCAwIHJnYmEoMCwgMTAyLCAyMDQsIDApOyB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIEBrZXlmcmFtZXMgZmFkZUluIHtcbiAgICAgICAgZnJvbSB7IG9wYWNpdHk6IDA7IHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtMTBweCk7IH1cbiAgICAgICAgdG8geyBvcGFjaXR5OiAxOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7IH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmJ0bi1oaWdobGlnaHQge1xuICAgICAgICBhbmltYXRpb246IHB1bHNlIDEuNXMgaW5maW5pdGU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDk5ZmYgIWltcG9ydGFudDtcbiAgICAgICAgY29sb3I6IHdoaXRlICFpbXBvcnRhbnQ7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4wNSk7XG4gICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC53YXJuaW5nLWJhbm5lciB7XG4gICAgICAgIGFuaW1hdGlvbjogZmFkZUluIDAuM3MgZWFzZS1pbi1vdXQ7XG4gICAgICB9XG4gICAgYDtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICB9O1xuICB9LCBbaXNIeWRyYXRlZF0pO1xuICBcbiAgLy8gTWFrZSB0b2dnbGVUb3BCYXIgZnVuY3Rpb24gYXZhaWxhYmxlIGdsb2JhbGx5XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIE1ha2UgdG9nZ2xlVG9wQmFyIGF2YWlsYWJsZSB0byBvdGhlciBjb21wb25lbnRzXG4gICAgd2luZG93LnRvZ2dsZVRvcEJhciA9IChzaG93KSA9PiB7XG4gICAgICBzZXRTaG93VG9wQmFyKHNob3cpO1xuICAgICAgXG4gICAgICAvLyBBbHNvIGhpZGUgbWV0cmljcyB3aGVuIGhpZGluZyB0aGUgdG9wIGJhclxuICAgICAgaWYgKCFzaG93KSB7XG4gICAgICAgIHNldFNob3dNZXRyaWNzKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRqdXN0IGNhbnZhcyBkaW1lbnNpb25zIGFmdGVyIHRvZ2dsaW5nXG4gICAgICBzZXRUaW1lb3V0KGFkanVzdENhbnZhc0RpbWVuc2lvbnMsIDEwMCk7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgIGRlbGV0ZSB3aW5kb3cudG9nZ2xlVG9wQmFyO1xuICAgIH07XG4gIH0sIFtpc0h5ZHJhdGVkXSk7XG5cbiAgLy8gVG9nZ2xlIGNhbWVyYSBmdW5jdGlvblxuICBjb25zdCB0b2dnbGVDYW1lcmEgPSAoc2hvdWxkRW5hYmxlKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIGlmIChzaG91bGRFbmFibGUpIHtcbiAgICAgIHNldFNob3dDYW1lcmEodHJ1ZSk7XG4gICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgc2V0T3V0cHV0VGV4dCgnQ2FtZXJhIHByZXZpZXcgc3RhcnRlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTaG93Q2FtZXJhKGZhbHNlKTtcbiAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICBzZXRPdXRwdXRUZXh0KCdDYW1lcmEgcHJldmlldyBzdG9wcGVkJyk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gSGFuZGxlciBmb3IgYWN0aW9uIGJ1dHRvbiBjbGlja3NcbiAgY29uc3QgaGFuZGxlQWN0aW9uQnV0dG9uQ2xpY2sgPSAoYWN0aW9uVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdG9nZ2xpbmcgdGhlIHRvcCBiYXJcbiAgICBpZiAoYWN0aW9uVHlwZSA9PT0gJ3RvZ2dsZVRvcEJhcicpIHtcbiAgICAgIC8vIGNvbnN0IG5ld1RvcEJhclN0YXRlID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/ICEhdmFsdWUgOiAhc2hvd1RvcEJhcjtcbiAgICAgIGxldCBuZXdUb3BCYXJTdGF0ZTtcbiAgICBcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgbmV3VG9wQmFyU3RhdGUgPSBwYXJhbXM7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBuZXdUb3BCYXJTdGF0ZSA9ICEhcGFyYW1zLnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3VG9wQmFyU3RhdGUgPSAhc2hvd1RvcEJhcjtcbiAgICAgIH1cbiAgICAgIHNldFNob3dUb3BCYXIobmV3VG9wQmFyU3RhdGUpO1xuICAgICAgXG4gICAgICAvLyBBbHNvIGhpZGUgbWV0cmljcyB3aGVuIGhpZGluZyB0aGUgdG9wIGJhclxuICAgICAgaWYgKCFuZXdUb3BCYXJTdGF0ZSkge1xuICAgICAgICBzZXRTaG93TWV0cmljcyhmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldE91dHB1dFRleHQoYFRvcEJhciAke25ld1RvcEJhclN0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfSR7IW5ld1RvcEJhclN0YXRlID8gJywgTWV0cmljcyBoaWRkZW4nIDogJyd9YCk7XG4gICAgICBcbiAgICAgIC8vIEFkanVzdCBjYW52YXMgZGltZW5zaW9ucyBhZnRlciB0b2dnbGluZ1xuICAgICAgc2V0VGltZW91dChhZGp1c3RDYW52YXNEaW1lbnNpb25zLCAxMDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgc2V0U2hvd1dhcm5pbmcoZmFsc2UpO1xuICAgIFxuICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB3YXJuaW5nc1xuICAgIGNvbnN0IHNhZmVQYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIFxuICAgIC8vIFVzZSBzYWZlUGFyYW1zIGluc3RlYWQgb2YgY29udHJvbFZhbHVlc1xuICAgIGNvbnN0IHJhbmRvbVRpbWVzID0gc2FmZVBhcmFtcy5yYW5kb21UaW1lcyB8fCAxO1xuICAgIGNvbnN0IGRlbGF5U2Vjb25kcyA9IHNhZmVQYXJhbXMuZGVsYXlTZWNvbmRzIHx8IDM7XG5cbiAgICBzd2l0Y2ggKGFjdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByZXZpZXcnOlxuICAgICAgICAvLyBUb2dnbGUgY2FtZXJhIHN0YXRlXG4gICAgICAgIGlmIChzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgdG9nZ2xlQ2FtZXJhKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYW1lcmFQZXJtaXNzaW9uR3JhbnRlZCkge1xuICAgICAgICAgIHRvZ2dsZUNhbWVyYSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2Ugc2hvdyBwZXJtaXNzaW9uIHBvcHVwXG4gICAgICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgICAgICAgICBzZXRPdXRwdXRUZXh0KCdPcGVuaW5nIGNhbWVyYSBwcmV2aWV3Jyk7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIGNhc2UgJ3NldFJhbmRvbSc6XG4gICAgICAgIHNldE91dHB1dFRleHQoJ1N0YXJ0aW5nIHJhbmRvbSBzZXF1ZW5jZS4uLicpO1xuICAgICAgICBzZXRTaG93VG9wQmFyKGZhbHNlKTtcbiAgICAgICAgaWYgKHNob3dDYW1lcmEpIHtcbiAgICAgICAgICB0b2dnbGVDYW1lcmEoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSB0aGUgaW1wb3J0ZWQgbW9kdWxlIGFwcHJvYWNoIC0gc2ltaWxhciB0byBjYWxpYnJhdGVcbiAgICAgICAgaWYgKGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQgJiYgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC5oYW5kbGVTZXRSYW5kb20pIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHJlZmVyZW5jZSBtZXRob2QgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIEFjdGlvbkJ1dHRvbkdyb3VwIHJlZiBtZXRob2QgZm9yIFNldCBSYW5kb20nKTtcbiAgICAgICAgICBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LmhhbmRsZVNldFJhbmRvbSgpO1xuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zICYmIFxuICAgICAgICAgIHR5cGVvZiB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zLmhhbmRsZVNldFJhbmRvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGdsb2JhbCBtZXRob2RcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgZ2xvYmFsIGJyaWRnZSBtZXRob2QgZm9yIFNldCBSYW5kb20nKTtcbiAgICAgICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zLmhhbmRsZVNldFJhbmRvbSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2FudmFzIHRvIHdvcmsgd2l0aFxuICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyBub3QgZm91bmQgZm9yIHJhbmRvbSBzZXF1ZW5jZVwiKTtcbiAgICAgICAgICAgIHNldE91dHB1dFRleHQoXCJFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGUgZm9yIHJhbmRvbSBzZXF1ZW5jZVwiKTtcbiAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdldCBjb250cm9sIHZhbHVlcyBmcm9tIHRoZSBUb3BCYXJcbiAgICAgICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZCcpO1xuICAgICAgICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY29udHJvbC1pbnB1dC1maWVsZCcpWzFdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWVzIGlmIGlucHV0cyBjYW4ndCBiZSBmb3VuZFxuICAgICAgICAgIGxldCB0aW1lcyA9IDE7XG4gICAgICAgICAgbGV0IGRlbGF5ID0gMztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBQYXJzZSBpbnB1dCB2YWx1ZXMgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkVGltZSA9IHBhcnNlSW50KHRpbWVJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc05hTihwYXJzZWRUaW1lKSAmJiBwYXJzZWRUaW1lID4gMCkge1xuICAgICAgICAgICAgICB0aW1lcyA9IHBhcnNlZFRpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREZWxheSA9IHBhcnNlSW50KGRlbGF5SW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VkRGVsYXkpICYmIHBhcnNlZERlbGF5ID4gMCkge1xuICAgICAgICAgICAgICBkZWxheSA9IHBhcnNlZERlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb2FkIGFsbCByZXF1aXJlZCBtb2R1bGVzIGZpcnN0LCB0aGVuIHByb2NlZWQgd2l0aCBleGVjdXRpb25cbiAgICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlJyksXG4gICAgICAgICAgICBpbXBvcnQoJy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9IZWxwZXIvc2F2ZWZpbGUnKVxuICAgICAgICAgIF0pLnRoZW4oYXN5bmMgKFtcbiAgICAgICAgICAgIGNvdW50U2F2ZU1vZHVsZSxcbiAgICAgICAgICAgIHNhdmVmaWxlTW9kdWxlXG4gICAgICAgICAgXSkgPT4ge1xuICAgICAgICAgICAgLy8gRGVzdHJ1Y3R1cmUgdGhlIGltcG9ydGVkIG1vZHVsZXNcbiAgICAgICAgICAgIGNvbnN0IHsgZ2V0UmFuZG9tUG9zaXRpb24sIGRyYXdSZWREb3QsIHJ1bkNvdW50ZG93biwgc2hvd0NhcHR1cmVQcmV2aWV3IH0gPSBjb3VudFNhdmVNb2R1bGU7XG4gICAgICAgICAgICBjb25zdCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gPSBzYXZlZmlsZU1vZHVsZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhbGwgY2FwdHVyZXMgc2VxdWVudGlhbGx5XG4gICAgICAgICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICAgICAgICBsZXQgY3VycmVudENhcHR1cmUgPSAxO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDYXB0dXJlIDw9IHRpbWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgY3VycmVudCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgQ2FwdHVyZSAke2N1cnJlbnRDYXB0dXJlfSBvZiAke3RpbWVzfWApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENsZWFyIGNhbnZhcyBiZWZvcmUgZWFjaCBjYXB0dXJlXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvbiBmb3IgdGhpcyBjYXB0dXJlXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBSdW4gY291bnRkb3duIGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZVxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgcnVuQ291bnRkb3duKFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIFVJIGJhc2VkIG9uIHN0YXR1c1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgQ2FwdHVyZSAke2N1cnJlbnRDYXB0dXJlfS8ke3RpbWVzfTogJHtzdGF0dXMucHJvY2Vzc1N0YXR1c31gKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGNvdW50ZG93biBjb21wbGV0ZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgcmVkcmF3SW50ZXJ2YWwgYWZ0ZXIgY291bnRkb3duXG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gV2FpdCBicmllZmx5IGFmdGVyIGNvdW50ZG93blxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgY291bnRlclxuICAgICAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhcHR1cmluZyBwb2ludCAke2N1cnJlbnRDYXB0dXJlfTpgLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBjYXB0dXJlcyBmb3IgdGhlIHNwZWNpZmllZCBkZWxheSB0aW1lXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDYXB0dXJlIDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSAqIDEwMDApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gTW92ZSB0byBuZXh0IGNhcHR1cmVcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2FwdHVyZSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBTZXF1ZW5jZSBjb21wbGV0ZVxuICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBjYXB0dXJlcyBzdWNjZXNzZnVsYCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJhbmRvbSBzZXF1ZW5jZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBSYW5kb20gc2VxdWVuY2UgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0U2hvd1RvcEJhcih0cnVlKSwgMjAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbXBvcnQgcmVxdWlyZWQgbW9kdWxlczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3JhbmRvbURvdCc6XG4gICAgICAgIHNldE91dHB1dFRleHQoJ1JhbmRvbSBkb3QgYWN0aW9uIHRyaWdnZXJlZCcpO1xuICAgICAgICBzZXRTaG93VG9wQmFyKGZhbHNlKTtcbiAgICAgICAgaWYgKHNob3dDYW1lcmEpIHtcbiAgICAgICAgICB0b2dnbGVDYW1lcmEoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIGFjY2VzcyBSYW5kb20gRG90IGZ1bmN0aW9uYWxpdHknKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSB0aGUgcmFuZG9tIGRvdCBmdW5jdGlvbmFsaXR5IGZyb20gYWN0aW9uQnV0dG9uLmpzIGJ5IGRlbGVnYXRpbmcgdG8gQWN0aW9uQnV0dG9uR3JvdXBcbiAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHlvdSBoYXZlIGEgcmVmIHRvIHRoZSBBY3Rpb25CdXR0b25Hcm91cCBjb21wb25lbnRcbiAgICAgICAgaWYgKGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQgJiYgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC5oYW5kbGVSYW5kb21Eb3QpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgcmVmIG1ldGhvZCcpO1xuICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQuaGFuZGxlUmFuZG9tRG90KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyAmJiBcbiAgICAgICAgICB0eXBlb2Ygd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucy5oYW5kbGVSYW5kb21Eb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXNpbmcgZ2xvYmFsIGJyaWRnZSBtZXRob2QnKTtcbiAgICAgICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zLmhhbmRsZVJhbmRvbURvdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIG5vdCBmb3VuZCBmb3IgcmFuZG9tIGRvdCBhY3Rpb25cIik7XG4gICAgICAgICAgICBzZXRPdXRwdXRUZXh0KFwiRXJyb3I6IENhbnZhcyBub3QgYXZhaWxhYmxlIGZvciByYW5kb20gZG90XCIpO1xuICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTsgLy8gU2hvdyBUb3BCYXIgYWdhaW4gaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHByZXZpZXdBcmVhUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQYXJlbnQgbm90IGZvdW5kIGZvciBjYW52YXNcIik7XG4gICAgICAgICAgICBzZXRPdXRwdXRUZXh0KFwiRXJyb3I6IENhbnZhcyBwYXJlbnQgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgZXhwbGljaXRseVxuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHJlYWR5IGZvciByYW5kb20gZG90OiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgcmVmZXJlbmNlXG4gICAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvblxuICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyB0aGUgZG90IHVzaW5nIHRoZSBpbXBvcnRlZCBmdW5jdGlvblxuICAgICAgICAgIGNvbnN0IGRvdCA9IGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCA4LCBmYWxzZSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFJhbmRvbSBkb3QgZHJhd24gYXQ6ICR7cG9zaXRpb24ueH0sICR7cG9zaXRpb24ueX1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGFydCBhIGNvdW50ZG93biBmb3IgY2FwdHVyZVxuICAgICAgICAgIHJ1bkNvdW50ZG93bihcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgVUkgYmFzZWQgb24gc3RhdHVzXG4gICAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICAgIHNldE91dHB1dFRleHQoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBFbmFibGUgY2FtZXJhIGJlZm9yZSBjYXB0dXJlXG4gICAgICAgICAgICAgIC8vIHRyaWdnZXJDYW1lcmFBY2Nlc3ModHJ1ZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBXYWl0IGJyaWVmbHkgZm9yIGNhbWVyYSB0byBpbml0aWFsaXplXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGlyZWN0bHkgaW1wb3J0ZWQgY2FwdHVyZUltYWdlc0F0UG9pbnQgZnJvbSB0aGUgSGVscGVyL3NhdmVmaWxlLmpzXG4gICAgICAgICAgICAgICAgaW1wb3J0KCcuLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJykudGhlbigoeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50OiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGNhcHR1cmVcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgc2V0U2hvd1RvcEJhcih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMjIwMCk7XG4gICAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIGltYWdlczpcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGltcG9ydGluZyBzYXZlZmlsZSBtb2R1bGU6XCIsIGVycik7XG4gICAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2hlYWRQb3NlJzpcbiAgICAgICAgY29uc3QgbmV3SGVhZFBvc2VTdGF0ZSA9ICFzaG93SGVhZFBvc2U7XG4gICAgICAgIHNldFNob3dIZWFkUG9zZShuZXdIZWFkUG9zZVN0YXRlKTtcbiAgICAgICAgc2V0T3V0cHV0VGV4dChgSGVhZCBwb3NlIHZpc3VhbGl6YXRpb24gJHtuZXdIZWFkUG9zZVN0YXRlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKTtcbiAgICAgICAgaWYgKG5ld0hlYWRQb3NlU3RhdGUgJiYgIXNob3dDYW1lcmEpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIW5ld0hlYWRQb3NlU3RhdGUgJiYgIXNob3dCb3VuZGluZ0JveCAmJiAhc2hvd01hc2sgJiYgIXNob3dQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHByb2Nlc3NvciBvcHRpb25zIGlmIGNhbWVyYSBpcyBhY3RpdmVcbiAgICAgICAgaWYgKHNob3dDYW1lcmEgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgLi4ud2luZG93LnZpZGVvUHJvY2Vzc29yLm9wdGlvbnMsXG4gICAgICAgICAgICBzaG93SGVhZFBvc2U6IG5ld0hlYWRQb3NlU3RhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdib3VuZGluZ0JveCc6XG4gICAgICAgIGNvbnN0IG5ld0JvdW5kaW5nQm94U3RhdGUgPSAhc2hvd0JvdW5kaW5nQm94O1xuICAgICAgICBzZXRTaG93Qm91bmRpbmdCb3gobmV3Qm91bmRpbmdCb3hTdGF0ZSk7XG4gICAgICAgIHNldE91dHB1dFRleHQoYEJvdW5kaW5nIGJveCAke25ld0JvdW5kaW5nQm94U3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgICAgIGlmIChuZXdCb3VuZGluZ0JveFN0YXRlICYmICFzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdCb3VuZGluZ0JveFN0YXRlICYmICFzaG93SGVhZFBvc2UgJiYgIXNob3dNYXNrICYmICFzaG93UGFyYW1ldGVycykge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9ucyBpZiBjYW1lcmEgaXMgYWN0aXZlXG4gICAgICAgIGlmIChzaG93Q2FtZXJhICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgIC4uLndpbmRvdy52aWRlb1Byb2Nlc3Nvci5vcHRpb25zLFxuICAgICAgICAgICAgc2hvd0JvdW5kaW5nQm94OiBuZXdCb3VuZGluZ0JveFN0YXRlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgY2FzZSAnbWFzayc6XG4gICAgICAgIGNvbnN0IG5ld01hc2tTdGF0ZSA9ICFzaG93TWFzaztcbiAgICAgICAgc2V0U2hvd01hc2sobmV3TWFza1N0YXRlKTtcbiAgICAgICAgc2V0T3V0cHV0VGV4dChgTWFzayAke25ld01hc2tTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICAgICAgaWYgKG5ld01hc2tTdGF0ZSAmJiAhc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICghbmV3TWFza1N0YXRlICYmICFzaG93SGVhZFBvc2UgJiYgIXNob3dCb3VuZGluZ0JveCAmJiAhc2hvd1BhcmFtZXRlcnMpIHtcbiAgICAgICAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJvY2Vzc29yIG9wdGlvbnMgaWYgY2FtZXJhIGlzIGFjdGl2ZVxuICAgICAgICBpZiAoc2hvd0NhbWVyYSAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICAuLi53aW5kb3cudmlkZW9Qcm9jZXNzb3Iub3B0aW9ucyxcbiAgICAgICAgICAgIHNob3dNYXNrOiBuZXdNYXNrU3RhdGVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICAgXG4gICAgICBjYXNlICdwYXJhbWV0ZXJzJzpcbiAgICAgICAgY29uc3QgbmV3UGFyYW1ldGVyc1N0YXRlID0gIXNob3dQYXJhbWV0ZXJzO1xuICAgICAgICBzZXRTaG93UGFyYW1ldGVycyhuZXdQYXJhbWV0ZXJzU3RhdGUpO1xuICAgICAgICBzZXRPdXRwdXRUZXh0KGBQYXJhbWV0ZXJzICR7bmV3UGFyYW1ldGVyc1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgICAgICBpZiAobmV3UGFyYW1ldGVyc1N0YXRlICYmICFzaG93Q2FtZXJhKSB7XG4gICAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCFuZXdQYXJhbWV0ZXJzU3RhdGUgJiYgIXNob3dIZWFkUG9zZSAmJiAhc2hvd0JvdW5kaW5nQm94ICYmICFzaG93TWFzaykge1xuICAgICAgICAgIHNldFNob3dDYW1lcmFQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9ucyBpZiBjYW1lcmEgaXMgYWN0aXZlXG4gICAgICAgIGlmIChzaG93Q2FtZXJhICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgICAgIC4uLndpbmRvdy52aWRlb1Byb2Nlc3Nvci5vcHRpb25zLFxuICAgICAgICAgICAgc2hvd1BhcmFtZXRlcnM6IG5ld1BhcmFtZXRlcnNTdGF0ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBcbiAgICAgIC8vIEZpeGVkIGNhbGlicmF0ZSBjYXNlIGhhbmRsZXIgaW4gaW5kZXguanNcbiAgICAgIGNhc2UgJ2NhbGlicmF0ZSc6XG4gICAgICAgIHNldE91dHB1dFRleHQoJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyk7XG4gICAgICAgIHNldFNob3dUb3BCYXIoZmFsc2UpO1xuICAgICAgICBpZiAoc2hvd0NhbWVyYSkge1xuICAgICAgICAgIHRvZ2dsZUNhbWVyYShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQgJiYgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC5oYW5kbGVTZXRDYWxpYnJhdGUpIHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHJlZmVyZW5jZSBtZXRob2QgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIEFjdGlvbkJ1dHRvbkdyb3VwIHJlZiBtZXRob2QgZm9yIGNhbGlicmF0aW9uJyk7XG4gICAgICAgICAgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC5oYW5kbGVTZXRDYWxpYnJhdGUoKTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyAmJiBcbiAgICAgICAgICB0eXBlb2Ygd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucy5oYW5kbGVTZXRDYWxpYnJhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBnbG9iYWwgbWV0aG9kXG4gICAgICAgICAgY29uc29sZS5sb2coJ1VzaW5nIGdsb2JhbCBicmlkZ2UgbWV0aG9kIGZvciBjYWxpYnJhdGlvbicpO1xuICAgICAgICAgIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMuaGFuZGxlU2V0Q2FsaWJyYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBjYW52YXMgdG8gd29yayB3aXRoXG4gICAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIG5vdCBmb3VuZCBmb3IgY2FsaWJyYXRpb25cIik7XG4gICAgICAgICAgICBzZXRPdXRwdXRUZXh0KFwiRXJyb3I6IENhbnZhcyBub3QgYXZhaWxhYmxlIGZvciBjYWxpYnJhdGlvblwiKTtcbiAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIExvYWQgYWxsIHJlcXVpcmVkIG1vZHVsZXMgZmlyc3QsIHRoZW4gcHJvY2VlZCB3aXRoIGV4ZWN1dGlvblxuICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9DYWxpYnJhdGVQb2ludHMnKSxcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnKSxcbiAgICAgICAgICAgIGltcG9ydCgnLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0hlbHBlci9zYXZlZmlsZScpXG4gICAgICAgICAgXSkudGhlbihhc3luYyAoW1xuICAgICAgICAgICAgY2FsaWJyYXRlUG9pbnRzTW9kdWxlLFxuICAgICAgICAgICAgY291bnRTYXZlTW9kdWxlLFxuICAgICAgICAgICAgc2F2ZWZpbGVNb2R1bGVcbiAgICAgICAgICBdKSA9PiB7XG4gICAgICAgICAgICAvLyBEZXN0cnVjdHVyZSB0aGUgaW1wb3J0ZWQgbW9kdWxlc1xuICAgICAgICAgICAgY29uc3QgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gPSBjYWxpYnJhdGVQb2ludHNNb2R1bGU7XG4gICAgICAgICAgICBjb25zdCB7IGRyYXdSZWREb3QsIHJ1bkNvdW50ZG93biwgc2hvd0NhcHR1cmVQcmV2aWV3IH0gPSBjb3VudFNhdmVNb2R1bGU7XG4gICAgICAgICAgICBjb25zdCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gPSBzYXZlZmlsZU1vZHVsZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXG4gICAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBDcmVhdGUgc3RhdHVzIGluZGljYXRvclxuICAgICAgICAgICAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgICAgICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCc7XG4gICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgICAgICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgICAgICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgICAgICAgYDtcbiAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBY2Nlc3Mgd2ViY2FtIGJlZm9yZSBzdGFydGluZyBjYWxpYnJhdGlvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0cmlnZ2VyQ2FtZXJhQWNjZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFByb2Nlc3MgcG9pbnRzIHNlcXVlbnRpYWxseVxuICAgICAgICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIG5ldyBwb2ludFxuICAgICAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUnVuIGNvdW50ZG93blxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgICAgcnVuQ291bnRkb3duKFxuICAgICAgICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUgLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIGNvdW50ZG93biBjb21wbGV0ZXNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3OiBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgY291bnRlclxuICAgICAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNhcHR1cmluZyBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEyMDApKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgICAgICAgICBzZXRPdXRwdXRUZXh0KGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FsaWJyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0U2hvd1RvcEJhcih0cnVlKSwgMjAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBpbXBvcnQgcmVxdWlyZWQgbW9kdWxlczpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgc2V0T3V0cHV0VGV4dChgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHNldFNob3dUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgY2FzZSAnY2xlYXJBbGwnOlxuICAgICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgICAgLy8gY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIHNldE91dHB1dFRleHQoJ0NhbnZhcyBjbGVhcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2V0T3V0cHV0VGV4dChgQWN0aW9uIHRyaWdnZXJlZDogJHthY3Rpb25UeXBlfWApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKCFpc0NsaWVudCB8fCAhaXNIeWRyYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICAgIHNldENhbWVyYVBlcm1pc3Npb25HcmFudGVkKHRydWUpO1xuICAgIHRvZ2dsZUNhbWVyYSh0cnVlKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVQZXJtaXNzaW9uRGVuaWVkID0gKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBzZXRTaG93Q2FtZXJhUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgIHNldE91dHB1dFRleHQoJ0NhbWVyYSBwZXJtaXNzaW9uIGRlbmllZCcpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNhbWVyYUNsb3NlID0gKCkgPT4ge1xuICAgIGlmICghaXNDbGllbnQgfHwgIWlzSHlkcmF0ZWQpIHJldHVybjtcbiAgICBcbiAgICB0b2dnbGVDYW1lcmEoZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNhbWVyYVJlYWR5ID0gKGRpbWVuc2lvbnMpID0+IHtcbiAgICBpZiAoIWlzQ2xpZW50IHx8ICFpc0h5ZHJhdGVkKSByZXR1cm47XG4gICAgXG4gICAgc2V0TWV0cmljcyh7XG4gICAgICB3aWR0aDogZGltZW5zaW9ucy53aWR0aCxcbiAgICAgIGhlaWdodDogZGltZW5zaW9ucy5oZWlnaHQsXG4gICAgICBkaXN0YW5jZTogZGltZW5zaW9ucy5kaXN0YW5jZSB8fCAnLS0tJ1xuICAgIH0pO1xuICAgIHNldE91dHB1dFRleHQoYENhbWVyYSByZWFkeTogJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWApO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSB0b3AgYmFyIGZ1bmN0aW9uXG4gIGNvbnN0IHRvZ2dsZVRvcEJhciA9IChzaG93KSA9PiB7XG4gICAgY29uc3QgbmV3VG9wQmFyU3RhdGUgPSBzaG93ICE9PSB1bmRlZmluZWQgPyBzaG93IDogIXNob3dUb3BCYXI7XG4gICAgc2V0U2hvd1RvcEJhcihuZXdUb3BCYXJTdGF0ZSk7XG4gICAgXG4gICAgLy8gQWxzbyBoaWRlIG1ldHJpY3Mgd2hlbiBoaWRpbmcgdGhlIHRvcCBiYXJcbiAgICBpZiAoIW5ld1RvcEJhclN0YXRlKSB7XG4gICAgICBzZXRTaG93TWV0cmljcyhmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIHNldE91dHB1dFRleHQoYFRvcEJhciAke25ld1RvcEJhclN0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfSR7IW5ld1RvcEJhclN0YXRlID8gJywgTWV0cmljcyBoaWRkZW4nIDogJyd9YCk7XG4gICAgXG4gICAgLy8gV2FpdCBmb3Igc3RhdGUgdXBkYXRlIGFuZCBET00gY2hhbmdlcywgdGhlbiBhZGp1c3QgY2FudmFzXG4gICAgc2V0VGltZW91dChhZGp1c3RDYW52YXNEaW1lbnNpb25zLCAxMDApO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSBtZXRyaWNzIGZ1bmN0aW9uXG4gIGNvbnN0IHRvZ2dsZU1ldHJpY3MgPSAoKSA9PiB7XG4gICAgaWYgKHNob3dUb3BCYXIpIHtcbiAgICAgIHNldFNob3dNZXRyaWNzKHByZXYgPT4gIXByZXYpO1xuICAgICAgc2V0T3V0cHV0VGV4dChgTWV0cmljcyAkeyFzaG93TWV0cmljcyA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdG9wQmFyIGlzIGhpZGRlbiwgd2UgY2FuJ3Qgc2hvdyBtZXRyaWNzXG4gICAgICBzZXRPdXRwdXRUZXh0KCdDYW5ub3Qgc2hvdyBtZXRyaWNzIHdoZW4gVG9wQmFyIGlzIGhpZGRlbicpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGdW5jdGlvbiB0byB0cmlnZ2VyIGNhbWVyYSBhY2Nlc3NcbiAgY29uc3QgdHJpZ2dlckNhbWVyYUFjY2VzcyA9IChmb3JjZUVuYWJsZSkgPT4ge1xuICAgIGlmIChmb3JjZUVuYWJsZSkge1xuICAgICAgLy8gVHJ5IHRvIGVuYWJsZSBjYW1lcmEgZGlyZWN0bHlcbiAgICAgIGlmICh3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgc2V0U2hvd0NhbWVyYSh0cnVlKTtcbiAgICAgICAgc2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyKGZhbHNlKTtcbiAgICAgICAgc2V0Q2FtZXJhUGVybWlzc2lvbkdyYW50ZWQodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCB2aWRlbyBwcm9jZXNzaW5nIHdpdGggY3VycmVudCBvcHRpb25zXG4gICAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci5zdGFydFZpZGVvUHJvY2Vzc2luZyh7XG4gICAgICAgICAgc2hvd0hlYWRQb3NlLFxuICAgICAgICAgIHNob3dCb3VuZGluZ0JveCxcbiAgICAgICAgICBzaG93TWFzayxcbiAgICAgICAgICBzaG93UGFyYW1ldGVycyxcbiAgICAgICAgICBzaG93UHJvY2Vzc2VkSW1hZ2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgLy8gSnVzdCB0b2dnbGUgY3VycmVudCBzdGF0ZSBpZiBub3QgZm9yY2luZ1xuICAgIGlmIChjYW1lcmFQZXJtaXNzaW9uR3JhbnRlZCkge1xuICAgICAgdG9nZ2xlQ2FtZXJhKCFzaG93Q2FtZXJhKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICAvLyBEeW5hbWljIGNsYXNzIHRvIHJlZmxlY3QgY3VycmVudCB3aW5kb3cgc2l6ZVxuICBjb25zdCBnZXRTaXplQ2xhc3MgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBwZXJjZW50YWdlIH0gPSB3aW5kb3dTaXplO1xuICAgIGlmIChwZXJjZW50YWdlIDwgMzUpIHJldHVybiAnd2luZG93LXNpemUtdGlueSc7XG4gICAgaWYgKHBlcmNlbnRhZ2UgPCA1MCkgcmV0dXJuICd3aW5kb3ctc2l6ZS1zbWFsbCc7XG4gICAgaWYgKHBlcmNlbnRhZ2UgPCA3MCkgcmV0dXJuICd3aW5kb3ctc2l6ZS1tZWRpdW0nO1xuICAgIHJldHVybiAnd2luZG93LXNpemUtbGFyZ2UnO1xuICB9O1xuXG4gIC8vIEFkZCB0aGlzIGZ1bmN0aW9uIHRvIGhhbmRsZSBzZXR0aW5ncyB2aXNpYmlsaXR5XG4gIGNvbnN0IGhhbmRsZVNldHRpbmdzVmlzaWJpbGl0eSA9IChpc1Zpc2libGUpID0+IHtcbiAgICBzZXRTaG93U2V0dGluZ3MoaXNWaXNpYmxlKTtcbiAgfTtcblxuICAvLyBBZGQgdGhpcyBlZmZlY3QgdG8gbGlzdGVuIGZvciBzZXR0aW5ncyB2aXNpYmlsaXR5IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc01lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kYXRhLnR5cGUgPT09ICdTSE9XX1NFVFRJTkdTJykge1xuICAgICAgICBzZXRTaG93U2V0dGluZ3MoZXZlbnQuZGF0YS5zaG93KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVTZXR0aW5nc01lc3NhZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZVNldHRpbmdzTWVzc2FnZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKGV2ZW50LmRldGFpbC51c2VySWQpO1xuICAgICAgICAvLyBEaXNwYXRjaCBldmVudCB0byB1cGRhdGUgc2V0dGluZ3MgZm9yIHRoZSBuZXcgdXNlclxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2FwdHVyZVNldHRpbmdzVXBkYXRlJywge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgdHlwZTogJ2NhcHR1cmVTZXR0aW5ncycsXG4gICAgICAgICAgICB1c2VySWQ6IGV2ZW50LmRldGFpbC51c2VySWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBzZXR0aW5ncyB3aGVuIGNvbXBvbmVudCBtb3VudHNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoY29uc2VudFVzZXJJZCkge1xuICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IHVzZXIgSURcbiAgICAgIHNldEN1cnJlbnRVc2VySWQoY29uc2VudFVzZXJJZCk7XG4gICAgICBcbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50IHRvIHVwZGF0ZSBzZXR0aW5ncyBmb3IgdGhpcyB1c2VyXG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2FwdHVyZVNldHRpbmdzVXBkYXRlJywge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICB0eXBlOiAnY2FwdHVyZVNldHRpbmdzJyxcbiAgICAgICAgICB1c2VySWQ6IGNvbnNlbnRVc2VySWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuICB9LCBbY29uc2VudFVzZXJJZF0pO1xuXG4gIC8vIExvYWQgc2V0dGluZ3MgZnJvbSBiYWNrZW5kIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGxvYWRTZXR0aW5ncyA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghY29uc2VudFVzZXJJZCkgcmV0dXJuO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAvYXBpL2RhdGEtY2VudGVyL3NldHRpbmdzLyR7Y29uc2VudFVzZXJJZH1gKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgc2V0dGluZ3MnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsb2FkZWRTZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjb21wb25lbnQgdG8gYmUgbW91bnRlZCBhbmQgcmVmIHRvIGJlIGluaXRpYWxpemVkXG4gICAgICAgIGNvbnN0IHdhaXRGb3JSZWYgPSAocmV0cmllcyA9IDUpID0+IHtcbiAgICAgICAgICBpZiAoYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudCAmJiB0eXBlb2YgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC51cGRhdGVTZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXR0aW5ncyBmb3IgdGhpcyB1c2VyXG4gICAgICAgICAgICBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LnVwZGF0ZVNldHRpbmdzKGxvYWRlZFNldHRpbmdzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRGlzcGF0Y2ggZXZlbnQgdG8gdXBkYXRlIFVJXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY2FwdHVyZVNldHRpbmdzVXBkYXRlJywge1xuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2FwdHVyZVNldHRpbmdzJyxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IGNvbnNlbnRVc2VySWQsXG4gICAgICAgICAgICAgICAgdGltZXM6IGxvYWRlZFNldHRpbmdzLnRpbWVzLFxuICAgICAgICAgICAgICAgIGRlbGF5OiBsb2FkZWRTZXR0aW5ncy5kZWxheVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJldHJpZXMgPiAwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHdhaXRGb3JSZWYocmV0cmllcyAtIDEpLCA1MDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0FjdGlvbkJ1dHRvbkdyb3VwIHJlZiBub3QgaW5pdGlhbGl6ZWQgYWZ0ZXIgcmV0cmllcycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHdhaXRGb3JSZWYoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBlbnN1cmUgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgIHNldFRpbWVvdXQobG9hZFNldHRpbmdzLCAxMDAwKTtcbiAgfSwgW2NvbnNlbnRVc2VySWRdKTtcblxuICAvLyBBZGQgcG9sbGluZyBmb3IgcmVhbC10aW1lIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaFVwZGF0ZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIWNvbnNlbnRVc2VySWQpIHJldHVybjtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgL2FwaS9kYXRhLWNlbnRlci9zZXR0aW5ncy8ke2NvbnNlbnRVc2VySWR9YCk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHNldHRpbmdzJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQgJiYgYWN0aW9uQnV0dG9uR3JvdXBSZWYuY3VycmVudC51cGRhdGVTZXR0aW5ncykge1xuICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQudXBkYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWW91IGNhbiBhZGQgaW1hZ2UgZmV0Y2hpbmcgbG9naWMgaGVyZSBpZiBuZWVkZWRcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVwZGF0ZXM6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJbml0aWFsIGZldGNoXG4gICAgZmV0Y2hVcGRhdGVzKCk7XG5cbiAgICAvLyBTZXQgdXAgcG9sbGluZyBpbnRlcnZhbFxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoZmV0Y2hVcGRhdGVzLCAzMDAwKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICB9O1xuICB9LCBbY29uc2VudFVzZXJJZF0pO1xuXG4gIC8vIEFkZCBldmVudCBsaXN0ZW5lcnMgZm9yIHNldHRpbmdzIGFuZCBpbWFnZSB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWw/LnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnICYmIGV2ZW50LmRldGFpbD8udXNlcklkID09PSBjb25zZW50VXNlcklkKSB7XG4gICAgICAgIGNvbnN0IHsgdGltZXMsIGRlbGF5IH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGlmIChhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50ICYmIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQudXBkYXRlU2V0dGluZ3MpIHtcbiAgICAgICAgICBhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50LnVwZGF0ZVNldHRpbmdzKHsgdGltZXMsIGRlbGF5IH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUltYWdlVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsPy50eXBlID09PSAnaW1hZ2UnICYmIGV2ZW50LmRldGFpbD8udXNlcklkID09PSBjb25zZW50VXNlcklkKSB7XG4gICAgICAgIGNvbnN0IHsgaW1hZ2UgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgLy8gVXBkYXRlIGltYWdlIGluIHRoZSBVSSBpZiBuZWVkZWRcbiAgICAgICAgLy8gWW91IGNhbiBhZGQgeW91ciBpbWFnZSB1cGRhdGUgbG9naWMgaGVyZVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpbWFnZVVwZGF0ZScsIGhhbmRsZUltYWdlVXBkYXRlKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ltYWdlVXBkYXRlJywgaGFuZGxlSW1hZ2VVcGRhdGUpO1xuICAgIH07XG4gIH0sIFtjb25zZW50VXNlcklkXSk7XG5cbiAgLy8gTG9hZCBzZXR0aW5ncyBmb3IgYSBzcGVjaWZpYyB1c2VyXG4gIGNvbnN0IGxvYWRTZXR0aW5ncyA9IGFzeW5jICh1c2VySWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0xvYWRpbmcgc2V0dGluZ3MgZm9yIHVzZXI6JywgdXNlcklkKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYC9hcGkvZGF0YS1jZW50ZXIvc2V0dGluZ3MvJHt1c2VySWR9YCk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBzZXR0aW5ncycpO1xuICAgICAgXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hlZCBzZXR0aW5nczonLCB1c2VyU2V0dGluZ3MpO1xuICAgICAgXG4gICAgICAvLyBEaXNwYXRjaCBzZXR0aW5ncyB1cGRhdGUgZXZlbnRcbiAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCB7XG4gICAgICAgIGRldGFpbDoge1xuICAgICAgICAgIHR5cGU6ICdjYXB0dXJlU2V0dGluZ3MnLFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAuLi51c2VyU2V0dGluZ3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIYW5kbGUgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGNvbnNlbnRVc2VySWQgJiYgY29uc2VudFVzZXJJZCAhPT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgY29uc29sZS5sb2coJ1VzZXIgSUQgY2hhbmdlZCBpbiBpbmRleC5qczonLCBjb25zZW50VXNlcklkKTtcbiAgICAgIHNldEN1cnJlbnRVc2VySWQoY29uc2VudFVzZXJJZCk7XG4gICAgICBcbiAgICAgIC8vIERpc3BhdGNoIGV2ZW50IHRvIG5vdGlmeSBvdGhlciBjb21wb25lbnRzXG4gICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgndXNlcklkQ2hhbmdlJywge1xuICAgICAgICBkZXRhaWw6IHsgdXNlcklkOiBjb25zZW50VXNlcklkIH1cbiAgICAgIH0pO1xuICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgXG4gICAgICAvLyBMb2FkIHNldHRpbmdzIGZvciB0aGUgbmV3IHVzZXJcbiAgICAgIGxvYWRTZXR0aW5ncyhjb25zZW50VXNlcklkKTtcbiAgICB9XG4gIH0sIFtjb25zZW50VXNlcklkLCBjdXJyZW50VXNlcklkXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCB0aW1lcywgZGVsYXkgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc2V0dGluZ3MgZm9yIHRoaXMgdXNlclxuICAgICAgICAgIGlmIChhY3Rpb25CdXR0b25Hcm91cFJlZi5jdXJyZW50ICYmIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQudXBkYXRlU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGFjdGlvbkJ1dHRvbkdyb3VwUmVmLmN1cnJlbnQudXBkYXRlU2V0dGluZ3Moe1xuICAgICAgICAgICAgICB0aW1lczogdGltZXMgfHwgMSxcbiAgICAgICAgICAgICAgZGVsYXk6IGRlbGF5IHx8IDNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FwdHVyZVNldHRpbmdzVXBkYXRlJywgaGFuZGxlU2V0dGluZ3NVcGRhdGUpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50VXNlcklkXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17YG1haW4tY29udGFpbmVyICR7Z2V0U2l6ZUNsYXNzKCl9YH0+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPkNhbWVyYSBEYXRhc2V0IENvbGxlY3Rpb248L3RpdGxlPlxuICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTFcIiAvPlxuICAgICAgPC9IZWFkPlxuICAgICAgXG4gICAgICB7LyogQmFja2VuZCBjb25uZWN0aW9uIHN0YXR1cyBiYW5uZXIgKi99XG4gICAgICB7aXNIeWRyYXRlZCAmJiBiYWNrZW5kU3RhdHVzID09PSAnZGlzY29ubmVjdGVkJyAmJiAoXG4gICAgICAgIDxkaXYgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIHBhZGRpbmc6ICc2cHggMCcsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZTBiMicsXG4gICAgICAgICAgY29sb3I6ICcjZTY1MTAwJyxcbiAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgIHpJbmRleDogMTEwMFxuICAgICAgICB9fT5cbiAgICAgICAgICDimqDvuI8gQmFja2VuZCBkaXNjb25uZWN0ZWQuIEh1cnJ5IHVwLCBNYWtlIE9OTElORSBwbGVhc2UgYW5kIFVzaW5nIG1vY2sgbW9kZVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICBcbiAgICAgIHsvKiBXYXJuaW5nIG1lc3NhZ2UgYmFubmVyICovfVxuICAgICAge2lzSHlkcmF0ZWQgJiYgc2hvd1dhcm5pbmcgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIndhcm5pbmctYmFubmVyXCIgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICB0b3A6IHNob3dUb3BCYXIgPyAoYmFja2VuZFN0YXR1cyA9PT0gJ2Rpc2Nvbm5lY3RlZCcgPyAnMzJweCcgOiAnNjBweCcpIDogJzAnLFxuICAgICAgICAgIGxlZnQ6ICcwJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyNmZmViM2InLFxuICAgICAgICAgIGNvbG9yOiAnIzMzMycsXG4gICAgICAgICAgcGFkZGluZzogJzEwcHgnLFxuICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgYm94U2hhZG93OiAnMCAycHggNHB4IHJnYmEoMCwwLDAsMC4yKScsXG4gICAgICAgICAgekluZGV4OiAxMDEwLFxuICAgICAgICAgIGFuaW1hdGlvbjogJ2ZhZGVJbiAwLjNzIGVhc2UtaW4tb3V0J1xuICAgICAgICB9fT5cbiAgICAgICAgICA8c3Ryb25nPuKaoO+4jyB7d2FybmluZ01lc3NhZ2V9PC9zdHJvbmc+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cblxuICAgICAge2lzTG9hZGluZyA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJsb2FkaW5nLWNvbnRhaW5lclwiPlxuICAgICAgICAgIDxwPkxvYWRpbmcgdXNlciBzZXR0aW5ncy4uLjwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogKFxuICAgICAgICA8PlxuICAgICAgICAgIHsvKiBMb2FkIHRoZSB2aWRlbyBwcm9jZXNzb3IgY29tcG9uZW50ICovfVxuICAgICAgICAgIHtpc0h5ZHJhdGVkICYmIGlzQ2xpZW50ICYmIDxWaWRlb1Byb2Nlc3NvckNvbXBvbmVudCAvPn1cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogVG9wQmFyIGNvbXBvbmVudCB3aXRoIG9uQnV0dG9uQ2xpY2sgaGFuZGxlciAtIGNvbmRpdGlvbmFsbHkgcmVuZGVyZWQgKi99XG4gICAgICAgICAge3Nob3dUb3BCYXIgJiYgKFxuICAgICAgICAgICAgPFRvcEJhciBcbiAgICAgICAgICAgICAgb25CdXR0b25DbGljaz17aGFuZGxlQWN0aW9uQnV0dG9uQ2xpY2t9XG4gICAgICAgICAgICAgIG9uQ2FtZXJhQWNjZXNzPXsoKSA9PiBzZXRTaG93UGVybWlzc2lvblBvcHVwKHRydWUpfVxuICAgICAgICAgICAgICBvdXRwdXRUZXh0PXtzdGF0dXNNZXNzYWdlIHx8IG91dHB1dFRleHR9XG4gICAgICAgICAgICAgIG9uT3V0cHV0Q2hhbmdlPXsodGV4dCkgPT4gc2V0T3V0cHV0VGV4dCh0ZXh0KX1cbiAgICAgICAgICAgICAgb25Ub2dnbGVUb3BCYXI9e3RvZ2dsZVRvcEJhcn1cbiAgICAgICAgICAgICAgb25Ub2dnbGVNZXRyaWNzPXt0b2dnbGVNZXRyaWNzfVxuICAgICAgICAgICAgICBjYW52YXNSZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgICBcbiAgICAgICAgICB7LyogU2hvdyByZXN0b3JlIGJ1dHRvbiB3aGVuIFRvcEJhciBpcyBoaWRkZW4gLSBwb3NpdGlvbmVkIGF0IHRvcCByaWdodCAqL31cbiAgICAgICAgICB7IXNob3dUb3BCYXIgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyZXN0b3JlLWJ1dHRvbi1jb250YWluZXJcIiBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgdG9wOiAnMTBweCcsXG4gICAgICAgICAgICAgIHJpZ2h0OiAnMTBweCcsXG4gICAgICAgICAgICAgIHpJbmRleDogMTAwMFxuICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicmVzdG9yZS1idG5cIlxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHRvZ2dsZVRvcEJhcih0cnVlKX1cbiAgICAgICAgICAgICAgICB0aXRsZT1cIlNob3cgVG9wQmFyIGFuZCBNZXRyaWNzXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzVweCAxMHB4JyxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIOKJoVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG5cbiAgICAgICAgICB7LyogTWFpbiBwcmV2aWV3IGFyZWEgKi99XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIHJlZj17cHJldmlld0FyZWFSZWZ9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcHJldmlldy1hcmVhXCJcbiAgICAgICAgICAgIHN0eWxlPXt7IFxuICAgICAgICAgICAgICBoZWlnaHQ6IHNob3dUb3BCYXIgPyAnY2FsYygxMDB2aCAtIDEyMHB4KScgOiAnMTAwdmgnLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGJhY2tlbmRTdGF0dXMgPT09ICdkaXNjb25uZWN0ZWQnID8gJzMycHgnIDogJzAnLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2Y1ZjVmNScsXG4gICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7LyogQWN0aW9uIGJ1dHRvbnMgZm9yIGNhbWVyYSBjb250cm9sIC0gbW92ZWQgb3V0c2lkZSBjb25kaXRpb25hbCByZW5kZXJpbmcgKi99XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbWVyYS1hY3Rpb24tYnV0dG9ucy1jb250YWluZXJcIiBzdHlsZT17eyBcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgIGJvdHRvbTogJzIwcHgnLFxuICAgICAgICAgICAgICBsZWZ0OiAnNTAlJyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtNTAlKScsXG4gICAgICAgICAgICAgIHpJbmRleDogMTAsXG4gICAgICAgICAgICAgIG1heFdpZHRoOiAnNjAwcHgnLFxuICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnMCAyMHB4J1xuICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgIDxBY3Rpb25CdXR0b25Hcm91cFxuICAgICAgICAgICAgICAgIHJlZj17YWN0aW9uQnV0dG9uR3JvdXBSZWZ9XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcz17dHJpZ2dlckNhbWVyYUFjY2Vzc31cbiAgICAgICAgICAgICAgICBpc0NvbXBhY3RNb2RlPXt3aW5kb3dTaXplLndpZHRoIDwgNzY4fVxuICAgICAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2s9e2hhbmRsZUFjdGlvbkJ1dHRvbkNsaWNrfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHshc2hvd0NhbWVyYSA/IChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbWVyYS1wcmV2aWV3LW1lc3NhZ2VcIiBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBzaG93VG9wQmFyID8gJ3JlbGF0aXZlJyA6ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICAgekluZGV4OiA1XG4gICAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgICA8cD5DYW1lcmEgcHJldmlldyB3aWxsIGFwcGVhciBoZXJlPC9wPlxuICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiY2FtZXJhLXNpemUtaW5kaWNhdG9yXCI+Q3VycmVudCB3aW5kb3c6IHt3aW5kb3dTaXplLnBlcmNlbnRhZ2V9JSBvZiBzY3JlZW4gd2lkdGg8L3A+XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIHsvKiBDYW1lcmEgcGxhY2Vob2xkZXIgc3F1YXJlIC0gc21hbGwgdmVyc2lvbiAqL31cbiAgICAgICAgICAgICAgICAgIHtpc0h5ZHJhdGVkICYmIHNob3dDYW1lcmFQbGFjZWhvbGRlciAmJiAoXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBsYWNlaG9sZGVyLXNxdWFyZVwiXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTgwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTM1cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMjBweCBhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJzJweCBkYXNoZWQgIzY2NicsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2Y1ZjVmNScsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJ1xuICAgICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGZvbnRTaXplOiAnMS41cmVtJyB9fT7wn5O3PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB7LyogQ2FudmFzIGZvciBleWUgdHJhY2tpbmcgZG90cyAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FudmFzLWNvbnRhaW5lclwiIFxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3sgXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLCBcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiAxMCBcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgey8qIDxjYW52YXMgXG4gICAgICAgICAgICAgICAgICAgIHJlZj17Y2FudmFzUmVmfVxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0cmFja2luZy1jYW52YXNcIlxuICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBcbiAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLCBcbiAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snIFxuICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgLz4gKi99XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKSA6IG51bGx9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHsvKiBNZXRyaWNzIGluZm8gLSBjb25kaXRpb25hbGx5IHJlbmRlcmVkICovfVxuICAgICAgICAgICAge2lzSHlkcmF0ZWQgJiYgc2hvd01ldHJpY3MgJiYgKFxuICAgICAgICAgICAgICA8RGlzcGxheVJlc3BvbnNlIFxuICAgICAgICAgICAgICAgIHdpZHRoPXttZXRyaWNzLndpZHRofSBcbiAgICAgICAgICAgICAgICBoZWlnaHQ9e21ldHJpY3MuaGVpZ2h0fSBcbiAgICAgICAgICAgICAgICBkaXN0YW5jZT17bWV0cmljcy5kaXN0YW5jZX1cbiAgICAgICAgICAgICAgICBpc1Zpc2libGU9e3Nob3dNZXRyaWNzfVxuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgey8qIENhbWVyYSBjb21wb25lbnQgLSB1c2luZyBjbGllbnQtb25seSB2ZXJzaW9uICovfVxuICAgICAgICAgICAge2lzSHlkcmF0ZWQgJiYgaXNDbGllbnQgJiYgc2hvd0NhbWVyYSAmJiAoXG4gICAgICAgICAgICAgIDxEeW5hbWljQ2FtZXJhQWNjZXNzXG4gICAgICAgICAgICAgICAgaXNTaG93aW5nPXtzaG93Q2FtZXJhfSBcbiAgICAgICAgICAgICAgICBvbkNsb3NlPXtoYW5kbGVDYW1lcmFDbG9zZX1cbiAgICAgICAgICAgICAgICBvbkNhbWVyYVJlYWR5PXtoYW5kbGVDYW1lcmFSZWFkeX1cbiAgICAgICAgICAgICAgICBzaG93SGVhZFBvc2U9e3Nob3dIZWFkUG9zZX1cbiAgICAgICAgICAgICAgICBzaG93Qm91bmRpbmdCb3g9e3Nob3dCb3VuZGluZ0JveH1cbiAgICAgICAgICAgICAgICBzaG93TWFzaz17c2hvd01hc2t9XG4gICAgICAgICAgICAgICAgc2hvd1BhcmFtZXRlcnM9e3Nob3dQYXJhbWV0ZXJzfVxuICAgICAgICAgICAgICAgIHZpZGVvUmVmPXt2aWRlb1JlZn1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHsvKiBDYW1lcmEgcGVybWlzc2lvbiBwb3B1cCAqL31cbiAgICAgICAgICAgIHtpc0h5ZHJhdGVkICYmIGlzQ2xpZW50ICYmIHNob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICB6SW5kZXg6IDIwMDBcbiAgICAgICAgICAgICAgfX0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1kaWFsb2dcIiBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCA0cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yKSdcbiAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi10aXRsZVwiIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAxNXB4JyxcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6ICcxOHB4JyxcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgICAgICB9fT5DYW1lcmEgQWNjZXNzIFJlcXVpcmVkPC9oMz5cbiAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLW1lc3NhZ2VcIiBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMjBweCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgICAgICB9fT5cbiAgICAgICAgICAgICAgICAgICAgVGhpcyBhcHBsaWNhdGlvbiBuZWVkcyBhY2Nlc3MgdG8geW91ciBjYW1lcmEgdG8gZnVuY3Rpb24gcHJvcGVybHkuIFxuICAgICAgICAgICAgICAgICAgICBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1idXR0b25zXCIgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgZ2FwOiAnMTBweCdcbiAgICAgICAgICAgICAgICAgIH19PlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJIZWFkIiwiZHluYW1pYyIsIlRvcEJhciIsIkRpc3BsYXlSZXNwb25zZSIsIkFjdGlvbkJ1dHRvbkdyb3VwIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJkcmF3UmVkRG90IiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJydW5Db3VudGRvd24iLCJ1c2VDb25zZW50IiwidXNlUm91dGVyIiwiVmlkZW9Qcm9jZXNzb3JDb21wb25lbnQiLCJzc3IiLCJEeW5hbWljQ2FtZXJhQWNjZXNzIiwibG9hZGluZyIsImRpdiIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwidHJhbnNmb3JtIiwid2lkdGgiLCJoZWlnaHQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJib3JkZXJSYWRpdXMiLCJkaXNwbGF5IiwiZmxleERpcmVjdGlvbiIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsInRleHRBbGlnbiIsInpJbmRleCIsImZvbnRTaXplIiwibWFyZ2luQm90dG9tIiwicCIsImZvbnRXZWlnaHQiLCJjb2xvciIsIkNvbGxlY3RlZERhdGFzZXRQYWdlIiwicm91dGVyIiwidXNlcklkIiwiY29uc2VudFVzZXJJZCIsInVzZXJEYXRhIiwic2V0VXNlckRhdGEiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJlcnJvciIsInNldEVycm9yIiwiaXNIeWRyYXRlZCIsInNldElzSHlkcmF0ZWQiLCJiYWNrZW5kU3RhdHVzIiwic2V0QmFja2VuZFN0YXR1cyIsInNob3dUb3BCYXIiLCJzZXRTaG93VG9wQmFyIiwic2hvd1dhcm5pbmciLCJzZXRTaG93V2FybmluZyIsIndhcm5pbmdNZXNzYWdlIiwic2V0V2FybmluZ01lc3NhZ2UiLCJzdGF0dXNNZXNzYWdlIiwic2V0U3RhdHVzTWVzc2FnZSIsIm91dHB1dFRleHQiLCJzZXRPdXRwdXRUZXh0Iiwic2hvd01ldHJpY3MiLCJzZXRTaG93TWV0cmljcyIsInNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXRTaG93UGVybWlzc2lvblBvcHVwIiwiY2FtZXJhUGVybWlzc2lvbkdyYW50ZWQiLCJzZXRDYW1lcmFQZXJtaXNzaW9uR3JhbnRlZCIsInNob3dDYW1lcmEiLCJzZXRTaG93Q2FtZXJhIiwic2hvd0NhbWVyYVBsYWNlaG9sZGVyIiwic2V0U2hvd0NhbWVyYVBsYWNlaG9sZGVyIiwic2hvd0hlYWRQb3NlIiwic2V0U2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2V0U2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzZXRTaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2V0U2hvd1BhcmFtZXRlcnMiLCJ3aW5kb3dTaXplIiwic2V0V2luZG93U2l6ZSIsInBlcmNlbnRhZ2UiLCJtZXRyaWNzIiwic2V0TWV0cmljcyIsImRpc3RhbmNlIiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsImNhcHR1cmVGb2xkZXIiLCJzZXRDYXB0dXJlRm9sZGVyIiwiY3VycmVudFVzZXJJZCIsInNldEN1cnJlbnRVc2VySWQiLCJzaG93U2V0dGluZ3MiLCJzZXRTaG93U2V0dGluZ3MiLCJwcmV2aWV3QXJlYVJlZiIsImNhbnZhc1JlZiIsInZpZGVvUmVmIiwiYWN0aW9uQnV0dG9uR3JvdXBSZWYiLCJsb2FkVXNlckRhdGEiLCJpc1JlYWR5IiwicXVlcnkiLCJwYXJzZWREYXRhIiwiSlNPTiIsInBhcnNlIiwicmVzcG9uc2UiLCJmZXRjaCIsImhlYWRlcnMiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX0tFWSIsIm9rIiwiRXJyb3IiLCJkYXRhIiwianNvbiIsImVyciIsImNvbnNvbGUiLCJtZXNzYWdlIiwiY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiIsImNvbm5lY3RlZCIsInVwZGF0ZURpbWVuc2lvbnMiLCJjdXJyZW50Iiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJzY3JlZW5QZXJjZW50YWdlIiwid2luZG93IiwiaW5uZXJXaWR0aCIsInNjcmVlbiIsInByZXYiLCJpbm5lckhlaWdodCIsIk1hdGgiLCJyb3VuZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibG9nIiwicHJlZmVyZW5jZXMiLCJjYW1lcmFTZXR0aW5ncyIsInNob3ciLCJ0b3BCYXIiLCJnZXRNYWluQ2FudmFzIiwid2hpdGVTY3JlZW5DYW52YXMiLCJkb2N1bWVudCIsImNhbnZhc0VsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwid2FybiIsImlzQ2xpZW50IiwiY2FudmFzIiwiY2FudmFzRGltZW5zaW9ucyIsImluaXRpYWxpemVDYW52YXMiLCJwYXJlbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInNldFRpbWVvdXQiLCJyZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZGltZW5zaW9ucyIsInJlY3RTaXplIiwiaXNWaXNpYmxlIiwiYWRqdXN0Q2FudmFzRGltZW5zaW9ucyIsImNvbnRhaW5lciIsInRvcEJhckhlaWdodCIsImNvbnRhaW5lcldpZHRoIiwiY29udGFpbmVySGVpZ2h0IiwidG9wQmFyVmlzaWJsZSIsImNhbGN1bGF0ZWRIZWlnaHQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwiY3JlYXRlRWxlbWVudCIsInRleHRDb250ZW50IiwiaGVhZCIsImFwcGVuZENoaWxkIiwicmVtb3ZlQ2hpbGQiLCJ0b2dnbGVUb3BCYXIiLCJ0b2dnbGVDYW1lcmEiLCJzaG91bGRFbmFibGUiLCJoYW5kbGVBY3Rpb25CdXR0b25DbGljayIsImFjdGlvblR5cGUiLCJwYXJhbXMiLCJuZXdUb3BCYXJTdGF0ZSIsInZhbHVlIiwic2FmZVBhcmFtcyIsInJhbmRvbVRpbWVzIiwiZGVsYXlTZWNvbmRzIiwiaGFuZGxlU2V0UmFuZG9tIiwiYWN0aW9uQnV0dG9uRnVuY3Rpb25zIiwidGltZUlucHV0IiwiZGVsYXlJbnB1dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0aW1lcyIsImRlbGF5IiwicGFyc2VkVGltZSIsInBhcnNlSW50IiwiaXNOYU4iLCJwYXJzZWREZWxheSIsIlByb21pc2UiLCJhbGwiLCJ0aGVuIiwiY291bnRTYXZlTW9kdWxlIiwic2F2ZWZpbGVNb2R1bGUiLCJzdWNjZXNzQ291bnQiLCJjdXJyZW50Q2FwdHVyZSIsIngiLCJ5IiwicmVkcmF3SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInJlc29sdmUiLCJzdGF0dXMiLCJwcm9jZXNzU3RhdHVzIiwiY2xlYXJJbnRlcnZhbCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsImNhdGNoIiwiaGFuZGxlUmFuZG9tRG90IiwiZG90IiwibmV3SGVhZFBvc2VTdGF0ZSIsInZpZGVvUHJvY2Vzc29yIiwidXBkYXRlT3B0aW9ucyIsIm9wdGlvbnMiLCJuZXdCb3VuZGluZ0JveFN0YXRlIiwibmV3TWFza1N0YXRlIiwibmV3UGFyYW1ldGVyc1N0YXRlIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwiY2FsaWJyYXRlUG9pbnRzTW9kdWxlIiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsInBvaW50cyIsImxlbmd0aCIsInN0YXR1c0luZGljYXRvciIsImNsYXNzTmFtZSIsImNzc1RleHQiLCJib2R5IiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsImkiLCJwYXJlbnROb2RlIiwiaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkIiwiaGFuZGxlUGVybWlzc2lvbkRlbmllZCIsImhhbmRsZUNhbWVyYUNsb3NlIiwiaGFuZGxlQ2FtZXJhUmVhZHkiLCJ1bmRlZmluZWQiLCJ0b2dnbGVNZXRyaWNzIiwiZm9yY2VFbmFibGUiLCJzdGFydFZpZGVvUHJvY2Vzc2luZyIsInNob3dQcm9jZXNzZWRJbWFnZSIsImdldFNpemVDbGFzcyIsImhhbmRsZVNldHRpbmdzVmlzaWJpbGl0eSIsImhhbmRsZVNldHRpbmdzTWVzc2FnZSIsImV2ZW50IiwidHlwZSIsImhhbmRsZVVzZXJJZENoYW5nZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsImxvYWRTZXR0aW5ncyIsImxvYWRlZFNldHRpbmdzIiwid2FpdEZvclJlZiIsInJldHJpZXMiLCJ1cGRhdGVTZXR0aW5ncyIsImZldGNoVXBkYXRlcyIsInNldHRpbmdzIiwiaW50ZXJ2YWwiLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsImhhbmRsZUltYWdlVXBkYXRlIiwiaW1hZ2UiLCJ1c2VyU2V0dGluZ3MiLCJ0aXRsZSIsIm1ldGEiLCJuYW1lIiwiY29udGVudCIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJhbmltYXRpb24iLCJzdHJvbmciLCJvbkJ1dHRvbkNsaWNrIiwib25DYW1lcmFBY2Nlc3MiLCJvbk91dHB1dENoYW5nZSIsInRleHQiLCJvblRvZ2dsZVRvcEJhciIsIm9uVG9nZ2xlTWV0cmljcyIsInJpZ2h0IiwiYnV0dG9uIiwib25DbGljayIsImJhY2tncm91bmQiLCJjdXJzb3IiLCJyZWYiLCJtYXJnaW5Ub3AiLCJvdmVyZmxvdyIsImJvdHRvbSIsIm1heFdpZHRoIiwiaXNDb21wYWN0TW9kZSIsIm9uQWN0aW9uQ2xpY2siLCJtYXJnaW4iLCJpc1Nob3dpbmciLCJvbkNsb3NlIiwib25DYW1lcmFSZWFkeSIsImgzIiwibGluZUhlaWdodCIsImdhcCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/index.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["pages/_app","main"], () => (__webpack_exec__("(pages-dir-browser)/./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fporchportal2%2FDesktop%2F%F0%9F%94%A5everything%2FMain_Web_EyeTracking%2Fmain-web%2Ffrontend%2Fpages%2Fcollected-dataset-customized%2Findex.js&page=%2Fcollected-dataset-customized!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);