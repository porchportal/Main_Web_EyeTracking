"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset_components-gui_cameraAccess_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/cameraAccess.js":
/*!****************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/cameraAccess.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n// cameraAccess.js\n\nvar _s = $RefreshSig$();\n\nconst CameraAccess = (param)=>{\n    let { isShowing, onClose, onCameraReady, showHeadPose = false, showBoundingBox = false, showMask = false, showParameters = false } = param;\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [stream, setStream] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [errorMessage, setErrorMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [fps, setFps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const fpsTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const processingInterval = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [isVideoReady, setIsVideoReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentResolution, setCurrentResolution] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('low');\n    const resolutionTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Start camera on component mount if isShowing is true\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (isShowing) {\n                startCamera();\n            } else {\n                stopCamera();\n            }\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    stopCamera();\n                    if (resolutionTimerRef.current) {\n                        clearTimeout(resolutionTimerRef.current);\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Setup FPS counter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            fpsTimerRef.current = setInterval({\n                \"CameraAccess.useEffect\": ()=>{\n                    setFps({\n                        \"CameraAccess.useEffect\": (prevFps)=>{\n                            // Simple mock for fps counter\n                            const newFps = Math.floor(Math.random() * 10) + 25; // Random between 25-35 fps\n                            return newFps;\n                        }\n                    }[\"CameraAccess.useEffect\"]);\n                }\n            }[\"CameraAccess.useEffect\"], 1000);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    if (fpsTimerRef.current) {\n                        clearInterval(fpsTimerRef.current);\n                    }\n                    if (processingInterval.current) {\n                        clearInterval(processingInterval.current);\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Update dimensions when container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            const updateDimensions = {\n                \"CameraAccess.useEffect.updateDimensions\": ()=>{\n                    if (containerRef.current) {\n                        const { width, height } = containerRef.current.getBoundingClientRect();\n                        setDimensions({\n                            width,\n                            height\n                        });\n                    }\n                }\n            }[\"CameraAccess.useEffect.updateDimensions\"];\n            updateDimensions();\n            window.addEventListener('resize', updateDimensions);\n            return ({\n                \"CameraAccess.useEffect\": ()=>window.removeEventListener('resize', updateDimensions)\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Handle video element ready state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing || !videoRef.current || !stream) return;\n            const video = videoRef.current;\n            const handleLoadedMetadata = {\n                \"CameraAccess.useEffect.handleLoadedMetadata\": ()=>{\n                    console.log('Video metadata loaded');\n                    setIsVideoReady(true);\n                    // Get video dimensions\n                    const videoWidth = video.videoWidth || 640;\n                    const videoHeight = video.videoHeight || 480;\n                    console.log(\"Video dimensions: \".concat(videoWidth, \"x\").concat(videoHeight));\n                    // Setup canvas for processing\n                    if (canvasRef.current) {\n                        // Store actual dimensions for capture\n                        canvasRef.current.width = videoWidth;\n                        canvasRef.current.height = videoHeight;\n                        // Set display size to maintain aspect ratio\n                        const aspectRatio = videoWidth / videoHeight;\n                        const containerWidth = dimensions.width;\n                        const containerHeight = containerWidth / aspectRatio;\n                        canvasRef.current.style.width = \"\".concat(containerWidth, \"px\");\n                        canvasRef.current.style.height = \"\".concat(containerHeight, \"px\");\n                    }\n                    // Start processing frames\n                    startProcessing();\n                    // Notify parent component that camera is ready\n                    if (onCameraReady) {\n                        onCameraReady({\n                            width: videoWidth,\n                            height: videoHeight\n                        });\n                    }\n                }\n            }[\"CameraAccess.useEffect.handleLoadedMetadata\"];\n            video.addEventListener('loadedmetadata', handleLoadedMetadata);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        stream,\n        dimensions,\n        isShowing,\n        onCameraReady\n    ]);\n    // Handle resolution upgrade\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing || !stream || currentResolution === 'high') return;\n            const upgradeResolution = {\n                \"CameraAccess.useEffect.upgradeResolution\": async ()=>{\n                    try {\n                        // Stop current tracks\n                        stream.getTracks().forEach({\n                            \"CameraAccess.useEffect.upgradeResolution\": (track)=>track.stop()\n                        }[\"CameraAccess.useEffect.upgradeResolution\"]);\n                        // Request higher resolution\n                        const newStream = await navigator.mediaDevices.getUserMedia({\n                            video: {\n                                width: {\n                                    ideal: 1280\n                                },\n                                height: {\n                                    ideal: 720\n                                },\n                                facingMode: \"user\"\n                            },\n                            audio: false\n                        });\n                        // Update stream and resolution state\n                        setStream(newStream);\n                        setCurrentResolution('high');\n                        // Apply new stream to video element\n                        if (videoRef.current) {\n                            videoRef.current.srcObject = newStream;\n                        }\n                        console.log('Camera resolution upgraded to high');\n                    } catch (error) {\n                        console.error('Error upgrading camera resolution:', error);\n                    // Keep using current resolution if upgrade fails\n                    }\n                }\n            }[\"CameraAccess.useEffect.upgradeResolution\"];\n            // Schedule resolution upgrade after 2 seconds\n            resolutionTimerRef.current = setTimeout(upgradeResolution, 2000);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    if (resolutionTimerRef.current) {\n                        clearTimeout(resolutionTimerRef.current);\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        stream,\n        isShowing,\n        currentResolution\n    ]);\n    const startCamera = async ()=>{\n        setErrorMessage('');\n        setIsVideoReady(false);\n        setCurrentResolution('low');\n        try {\n            console.log('Starting camera access with low resolution...');\n            // Start with low resolution for quick preview\n            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 320,\n                        max: 640\n                    },\n                    height: {\n                        ideal: 240,\n                        max: 480\n                    },\n                    facingMode: \"user\"\n                },\n                audio: false\n            });\n            console.log('Low resolution camera access granted!');\n            // Store the stream\n            setStream(mediaStream);\n            // Apply stream to video element\n            if (videoRef.current) {\n                // Critical attributes for cross-browser compatibility\n                videoRef.current.playsInline = true;\n                videoRef.current.muted = true;\n                videoRef.current.autoplay = true;\n                // Apply stream to video element\n                videoRef.current.srcObject = mediaStream;\n                try {\n                    // Explicitly try to play the video\n                    await videoRef.current.play();\n                    console.log('Video playing successfully!');\n                } catch (playError) {\n                    console.error('Error playing video:', playError);\n                    setErrorMessage('Unable to start video stream. Please try again.');\n                }\n            } else {\n                throw new Error('Video element not found');\n            }\n        } catch (error) {\n            console.error('Camera access error:', error);\n            // Handle specific error types\n            if (error.name === 'NotAllowedError') {\n                setErrorMessage('Camera access denied. Please check browser permissions and try again.');\n            } else if (error.name === 'NotFoundError') {\n                setErrorMessage('No camera detected. Please connect a camera and try again.');\n            } else if (error.name === 'NotReadableError') {\n                setErrorMessage('Camera is being used by another application.');\n            } else {\n                setErrorMessage(\"Camera error: \".concat(error.message || 'Unknown error'));\n            }\n        }\n    };\n    const stopCamera = ()=>{\n        // Stop all tracks in the stream\n        if (stream) {\n            stream.getTracks().forEach((track)=>track.stop());\n            setStream(null);\n        }\n        // Clear video source\n        if (videoRef.current) {\n            videoRef.current.srcObject = null;\n        }\n        // Clear processing interval\n        if (processingInterval.current) {\n            clearInterval(processingInterval.current);\n            processingInterval.current = null;\n        }\n        setIsVideoReady(false);\n    };\n    const startProcessing = ()=>{\n        if (!canvasRef.current || !videoRef.current || !isVideoReady) return;\n        const video = videoRef.current;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Use high resolution for processing canvas regardless of current video resolution\n        const processingWidth = 1280;\n        const processingHeight = 720;\n        // Set canvas to high resolution for processing\n        canvas.width = processingWidth;\n        canvas.height = processingHeight;\n        // Start processing frames at ~30fps\n        processingInterval.current = setInterval(()=>{\n            if (video.readyState !== 4) return;\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Save the current context state\n            ctx.save();\n            // Flip the context horizontally to mirror the video\n            ctx.translate(canvas.width, 0);\n            ctx.scale(-1, 1);\n            // Draw video frame to canvas at high resolution\n            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n            // Restore the context state\n            ctx.restore();\n            // Simulate face detection (90% chance of face detected)\n            const faceDetected = Math.random() > 0.1;\n            // Draw visualizations based on enabled options\n            if (faceDetected) {\n                if (showBoundingBox) {\n                    drawBoundingBox(ctx, canvas);\n                }\n                if (showHeadPose) {\n                    drawHeadPose(ctx, canvas);\n                }\n                if (showMask) {\n                    drawFaceMask(ctx, canvas);\n                }\n            }\n            // Display parameters if enabled\n            if (showParameters) {\n                drawParameters(ctx, canvas, faceDetected);\n            }\n        }, 33); // ~30fps\n    };\n    // Helper function to draw bounding box\n    const drawBoundingBox = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const boxWidth = canvas.width * 0.6;\n        const boxHeight = canvas.height * 0.8;\n        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);\n    };\n    // Helper function to draw head pose axes\n    const drawHeadPose = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const time = Date.now() / 1000;\n        const length = canvas.width * 0.1;\n        // X axis (red)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX + length * Math.sin(time), centerY);\n        ctx.strokeStyle = 'red';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        // Y axis (green)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX, centerY + length * Math.sin(time + 1));\n        ctx.strokeStyle = 'green';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        // Z axis (blue)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX + length / 2 * Math.sin(time + 2), centerY - length / 2 * Math.cos(time + 2));\n        ctx.strokeStyle = 'blue';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n    };\n    // Helper function to draw face mask\n    const drawFaceMask = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const radius = Math.min(canvas.width, canvas.height) * 0.2;\n        // Draw mask\n        ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        ctx.fill();\n        // Draw eyes\n        const eyeRadius = radius * 0.2;\n        const eyeOffsetX = radius * 0.3;\n        const eyeOffsetY = radius * 0.1;\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n        // Left eye\n        ctx.beginPath();\n        ctx.arc(centerX - eyeOffsetX, centerY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);\n        ctx.fill();\n        // Right eye\n        ctx.beginPath();\n        ctx.arc(centerX + eyeOffsetX, centerY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);\n        ctx.fill();\n    };\n    // Helper function to draw parameters\n    const drawParameters = (ctx, canvas, faceDetected)=>{\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(5, canvas.height - 60, 150, 50);\n        ctx.font = '12px Arial';\n        ctx.fillStyle = 'white';\n        ctx.fillText(\"Resolution: \".concat(canvas.width, \"x\").concat(canvas.height), 10, canvas.height - 40);\n        ctx.fillText(\"FPS: \".concat(fps), 10, canvas.height - 25);\n        ctx.fillText(\"Face: \".concat(faceDetected ? 'Detected' : 'Not Detected'), 10, canvas.height - 10);\n    };\n    if (!isShowing) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            width: '30vw',\n            height: '30vh',\n            backgroundColor: 'white',\n            borderRadius: '8px',\n            boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',\n            overflow: 'hidden',\n            zIndex: 1000\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                ref: videoRef,\n                style: {\n                    width: '100%',\n                    height: '100%',\n                    objectFit: 'cover',\n                    transform: 'scaleX(-1)',\n                    opacity: 0 // Keep video hidden but functional\n                },\n                playsInline: true,\n                muted: true,\n                autoPlay: true\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 431,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    zIndex: 1\n                }\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 444,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: onClose,\n                style: {\n                    position: 'absolute',\n                    top: '10px',\n                    right: '10px',\n                    padding: '8px 12px',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    color: 'white',\n                    border: 'none',\n                    borderRadius: '4px',\n                    cursor: 'pointer',\n                    zIndex: 2\n                },\n                children: \"Close\"\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 455,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n        lineNumber: 415,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CameraAccess, \"wd4nzW0Z3dEon2PaRW7IllOnGQY=\");\n_c = CameraAccess;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CameraAccess);\nvar _c;\n$RefreshReg$(_c, \"CameraAccess\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL2NhbWVyYUFjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGtCQUFrQjs7O0FBQ3lDO0FBRTNELE1BQU1JLGVBQWU7UUFBQyxFQUNwQkMsU0FBUyxFQUNUQyxPQUFPLEVBQ1BDLGFBQWEsRUFDYkMsZUFBZSxLQUFLLEVBQ3BCQyxrQkFBa0IsS0FBSyxFQUN2QkMsV0FBVyxLQUFLLEVBQ2hCQyxpQkFBaUIsS0FBSyxFQUN2Qjs7SUFDQyxNQUFNQyxXQUFXViw2Q0FBTUEsQ0FBQztJQUN4QixNQUFNVyxZQUFZWCw2Q0FBTUEsQ0FBQztJQUN6QixNQUFNWSxlQUFlWiw2Q0FBTUEsQ0FBQztJQUM1QixNQUFNLENBQUNhLFFBQVFDLFVBQVUsR0FBR2IsK0NBQVFBLENBQUM7SUFDckMsTUFBTSxDQUFDYyxjQUFjQyxnQkFBZ0IsR0FBR2YsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDZ0IsS0FBS0MsT0FBTyxHQUFHakIsK0NBQVFBLENBQUM7SUFDL0IsTUFBTWtCLGNBQWNuQiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNb0IscUJBQXFCcEIsNkNBQU1BLENBQUM7SUFDbEMsTUFBTSxDQUFDcUIsWUFBWUMsY0FBYyxHQUFHckIsK0NBQVFBLENBQUM7UUFBRXNCLE9BQU87UUFBR0MsUUFBUTtJQUFFO0lBQ25FLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUMwQixtQkFBbUJDLHFCQUFxQixHQUFHM0IsK0NBQVFBLENBQUM7SUFDM0QsTUFBTTRCLHFCQUFxQjdCLDZDQUFNQSxDQUFDO0lBRWxDLHVEQUF1RDtJQUN2REQsZ0RBQVNBO2tDQUFDO1lBQ1IsSUFBSUksV0FBVztnQkFDYjJCO1lBQ0YsT0FBTztnQkFDTEM7WUFDRjtZQUVBOzBDQUFPO29CQUNMQTtvQkFDQSxJQUFJRixtQkFBbUJHLE9B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QUlaLE9BQU8xRCxNQUFNLEdBQUc7SUFDMUY7SUFFQSxJQUFJLENBQUNyQixXQUFXO1FBQ2QsT0FBTztJQUNUO0lBRUEscUJBQ0UsOERBQUM2SDtRQUNDQyxLQUFLckg7UUFDTDJDLE9BQU87WUFDTDJFLFVBQVU7WUFDVkMsS0FBSztZQUNMQyxNQUFNO1lBQ05DLFdBQVc7WUFDWDlHLE9BQU87WUFDUEMsUUFBUTtZQUNSOEcsaUJBQWlCO1lBQ2pCQyxjQUFjO1lBQ2RDLFdBQVc7WUFDWEMsVUFBVTtZQUNWQyxRQUFRO1FBQ1Y7OzBCQUVBLDhEQUFDNUY7Z0JBQ0NtRixLQUFLdkg7Z0JBQ0w2QyxPQUFPO29CQUNMaEMsT0FBTztvQkFDUEMsUUFBUTtvQkFDUm1ILFdBQVc7b0JBQ1hOLFdBQVc7b0JBQ1hPLFNBQVMsRUFBRSxtQ0FBbUM7Z0JBQ2hEO2dCQUNBbEUsV0FBVztnQkFDWEMsS0FBSztnQkFDTGtFLFFBQVE7Ozs7OzswQkFFViw4REFBQzNEO2dCQUNDK0MsS0FBS3RIO2dCQUNMNEMsT0FBTztvQkFDTDJFLFVBQVU7b0JBQ1ZDLEtBQUs7b0JBQ0xDLE1BQU07b0JBQ043RyxPQUFPO29CQUNQQyxRQUFRO29CQUNSa0gsUUFBUTtnQkFDVjs7Ozs7OzBCQUVGLDhEQUFDSTtnQkFDQ0MsU0FBUzNJO2dCQUNUbUQsT0FBTztvQkFDTDJFLFVBQVU7b0JBQ1ZDLEtBQUs7b0JBQ0xhLE9BQU87b0JBQ1BDLFNBQVM7b0JBQ1RYLGlCQUFpQjtvQkFDakJZLE9BQU87b0JBQ1BDLFFBQVE7b0JBQ1JaLGNBQWM7b0JBQ2RhLFFBQVE7b0JBQ1JWLFFBQVE7Z0JBQ1Y7MEJBQ0Q7Ozs7Ozs7Ozs7OztBQUtQO0dBdGRNeEk7S0FBQUE7QUF3ZE4saUVBQWVBLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9jYW1lcmFBY2Nlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY2FtZXJhQWNjZXNzLmpzXG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBDYW1lcmFBY2Nlc3MgPSAoeyBcbiAgaXNTaG93aW5nLCBcbiAgb25DbG9zZSwgXG4gIG9uQ2FtZXJhUmVhZHksXG4gIHNob3dIZWFkUG9zZSA9IGZhbHNlLFxuICBzaG93Qm91bmRpbmdCb3ggPSBmYWxzZSxcbiAgc2hvd01hc2sgPSBmYWxzZSxcbiAgc2hvd1BhcmFtZXRlcnMgPSBmYWxzZVxufSkgPT4ge1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtzdHJlYW0sIHNldFN0cmVhbV0gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgW2Vycm9yTWVzc2FnZSwgc2V0RXJyb3JNZXNzYWdlXSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW2Zwcywgc2V0RnBzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBmcHNUaW1lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgcHJvY2Vzc2luZ0ludGVydmFsID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbZGltZW5zaW9ucywgc2V0RGltZW5zaW9uc10gPSB1c2VTdGF0ZSh7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gIGNvbnN0IFtpc1ZpZGVvUmVhZHksIHNldElzVmlkZW9SZWFkeV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtjdXJyZW50UmVzb2x1dGlvbiwgc2V0Q3VycmVudFJlc29sdXRpb25dID0gdXNlU3RhdGUoJ2xvdycpO1xuICBjb25zdCByZXNvbHV0aW9uVGltZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIFxuICAvLyBTdGFydCBjYW1lcmEgb24gY29tcG9uZW50IG1vdW50IGlmIGlzU2hvd2luZyBpcyB0cnVlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzU2hvd2luZykge1xuICAgICAgc3RhcnRDYW1lcmEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcENhbWVyYSgpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcENhbWVyYSgpO1xuICAgICAgaWYgKHJlc29sdXRpb25UaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFyVGltZW91dChyZXNvbHV0aW9uVGltZXJSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzU2hvd2luZ10pO1xuXG4gIC8vIFNldHVwIEZQUyBjb3VudGVyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1Nob3dpbmcpIHJldHVybjtcbiAgICBcbiAgICBmcHNUaW1lclJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2V0RnBzKHByZXZGcHMgPT4ge1xuICAgICAgICAvLyBTaW1wbGUgbW9jayBmb3IgZnBzIGNvdW50ZXJcbiAgICAgICAgY29uc3QgbmV3RnBzID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApICsgMjU7IC8vIFJhbmRvbSBiZXR3ZWVuIDI1LTM1IGZwc1xuICAgICAgICByZXR1cm4gbmV3RnBzO1xuICAgICAgfSk7XG4gICAgfSwgMTAwMCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChmcHNUaW1lclJlZi5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoZnBzVGltZXJSZWYuY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChwcm9jZXNzaW5nSW50ZXJ2YWwuY3VycmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzU2hvd2luZ10pO1xuXG4gIC8vIFVwZGF0ZSBkaW1lbnNpb25zIHdoZW4gY29udGFpbmVyIHNpemUgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTaG93aW5nKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgIGlmIChjb250YWluZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvbnRhaW5lclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBzZXREaW1lbnNpb25zKHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICB9LCBbaXNTaG93aW5nXSk7XG5cbiAgLy8gSGFuZGxlIHZpZGVvIGVsZW1lbnQgcmVhZHkgc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU2hvd2luZyB8fCAhdmlkZW9SZWYuY3VycmVudCB8fCAhc3RyZWFtKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdmlkZW8gPSB2aWRlb1JlZi5jdXJyZW50O1xuICAgIFxuICAgIGNvbnN0IGhhbmRsZUxvYWRlZE1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1ZpZGVvIG1ldGFkYXRhIGxvYWRlZCcpO1xuICAgICAgc2V0SXNWaWRlb1JlYWR5KHRydWUpO1xuICAgICAgXG4gICAgICAvLyBHZXQgdmlkZW8gZGltZW5zaW9uc1xuICAgICAgY29uc3QgdmlkZW9XaWR0aCA9IHZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgY29uc3QgdmlkZW9IZWlnaHQgPSB2aWRlby52aWRlb0hlaWdodCB8fCA0ODA7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBWaWRlbyBkaW1lbnNpb25zOiAke3ZpZGVvV2lkdGh9eCR7dmlkZW9IZWlnaHR9YCk7XG4gICAgICBcbiAgICAgIC8vIFNldHVwIGNhbnZhcyBmb3IgcHJvY2Vzc2luZ1xuICAgICAgaWYgKGNhbnZhc1JlZi5jdXJyZW50KSB7XG4gICAgICAgIC8vIFN0b3JlIGFjdHVhbCBkaW1lbnNpb25zIGZvciBjYXB0dXJlXG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LndpZHRoID0gdmlkZW9XaWR0aDtcbiAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgZGlzcGxheSBzaXplIHRvIG1haW50YWluIGFzcGVjdCByYXRpb1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHZpZGVvV2lkdGggLyB2aWRlb0hlaWdodDtcbiAgICAgICAgY29uc3QgY29udGFpbmVyV2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICBjb25zdCBjb250YWluZXJIZWlnaHQgPSBjb250YWluZXJXaWR0aCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICBcbiAgICAgICAgY2FudmFzUmVmLmN1cnJlbnQuc3R5bGUud2lkdGggPSBgJHtjb250YWluZXJXaWR0aH1weGA7XG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LnN0eWxlLmhlaWdodCA9IGAke2NvbnRhaW5lckhlaWdodH1weGA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmcgZnJhbWVzXG4gICAgICBzdGFydFByb2Nlc3NpbmcoKTtcbiAgICAgIFxuICAgICAgLy8gTm90aWZ5IHBhcmVudCBjb21wb25lbnQgdGhhdCBjYW1lcmEgaXMgcmVhZHlcbiAgICAgIGlmIChvbkNhbWVyYVJlYWR5KSB7XG4gICAgICAgIG9uQ2FtZXJhUmVhZHkoe1xuICAgICAgICAgIHdpZHRoOiB2aWRlb1dpZHRoLFxuICAgICAgICAgIGhlaWdodDogdmlkZW9IZWlnaHRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgaGFuZGxlTG9hZGVkTWV0YWRhdGEpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB2aWRlby5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGhhbmRsZUxvYWRlZE1ldGFkYXRhKTtcbiAgICB9O1xuICB9LCBbc3RyZWFtLCBkaW1lbnNpb25zLCBpc1Nob3dpbmcsIG9uQ2FtZXJhUmVhZHldKTtcblxuICAvLyBIYW5kbGUgcmVzb2x1dGlvbiB1cGdyYWRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1Nob3dpbmcgfHwgIXN0cmVhbSB8fCBjdXJyZW50UmVzb2x1dGlvbiA9PT0gJ2hpZ2gnKSByZXR1cm47XG5cbiAgICBjb25zdCB1cGdyYWRlUmVzb2x1dGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFN0b3AgY3VycmVudCB0cmFja3NcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlcXVlc3QgaGlnaGVyIHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgbmV3U3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICB3aWR0aDogeyBpZGVhbDogMTI4MCB9LFxuICAgICAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiA3MjAgfSxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6IFwidXNlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdWRpbzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgc3RyZWFtIGFuZCByZXNvbHV0aW9uIHN0YXRlXG4gICAgICAgIHNldFN0cmVhbShuZXdTdHJlYW0pO1xuICAgICAgICBzZXRDdXJyZW50UmVzb2x1dGlvbignaGlnaCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgbmV3IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50XG4gICAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgdmlkZW9SZWYuY3VycmVudC5zcmNPYmplY3QgPSBuZXdTdHJlYW07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdDYW1lcmEgcmVzb2x1dGlvbiB1cGdyYWRlZCB0byBoaWdoJyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGdyYWRpbmcgY2FtZXJhIHJlc29sdXRpb246JywgZXJyb3IpO1xuICAgICAgICAvLyBLZWVwIHVzaW5nIGN1cnJlbnQgcmVzb2x1dGlvbiBpZiB1cGdyYWRlIGZhaWxzXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNjaGVkdWxlIHJlc29sdXRpb24gdXBncmFkZSBhZnRlciAyIHNlY29uZHNcbiAgICByZXNvbHV0aW9uVGltZXJSZWYuY3VycmVudCA9IHNldFRpbWVvdXQodXBncmFkZVJlc29sdXRpb24sIDIwMDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocmVzb2x1dGlvblRpbWVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHJlc29sdXRpb25UaW1lclJlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbc3RyZWFtLCBpc1Nob3dpbmcsIGN1cnJlbnRSZXNvbHV0aW9uXSk7XG5cbiAgY29uc3Qgc3RhcnRDYW1lcmEgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0RXJyb3JNZXNzYWdlKCcnKTtcbiAgICBzZXRJc1ZpZGVvUmVhZHkoZmFsc2UpO1xuICAgIHNldEN1cnJlbnRSZXNvbHV0aW9uKCdsb3cnKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIGNhbWVyYSBhY2Nlc3Mgd2l0aCBsb3cgcmVzb2x1dGlvbi4uLicpO1xuICAgICAgXG4gICAgICAvLyBTdGFydCB3aXRoIGxvdyByZXNvbHV0aW9uIGZvciBxdWljayBwcmV2aWV3XG4gICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICB3aWR0aDogeyBpZGVhbDogMzIwLCBtYXg6IDY0MCB9LFxuICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogMjQwLCBtYXg6IDQ4MCB9LFxuICAgICAgICAgIGZhY2luZ01vZGU6IFwidXNlclwiXG4gICAgICAgIH0sXG4gICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdMb3cgcmVzb2x1dGlvbiBjYW1lcmEgYWNjZXNzIGdyYW50ZWQhJyk7XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIHRoZSBzdHJlYW1cbiAgICAgIHNldFN0cmVhbShtZWRpYVN0cmVhbSk7XG4gICAgICBcbiAgICAgIC8vIEFwcGx5IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50XG4gICAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xuICAgICAgICAvLyBDcml0aWNhbCBhdHRyaWJ1dGVzIGZvciBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHlcbiAgICAgICAgdmlkZW9SZWYuY3VycmVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHZpZGVvUmVmLmN1cnJlbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB2aWRlb1JlZi5jdXJyZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFwcGx5IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50XG4gICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEV4cGxpY2l0bHkgdHJ5IHRvIHBsYXkgdGhlIHZpZGVvXG4gICAgICAgICAgYXdhaXQgdmlkZW9SZWYuY3VycmVudC5wbGF5KCk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1ZpZGVvIHBsYXlpbmcgc3VjY2Vzc2Z1bGx5IScpO1xuICAgICAgICB9IGNhdGNoIChwbGF5RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwbGF5aW5nIHZpZGVvOicsIHBsYXlFcnJvcik7XG4gICAgICAgICAgc2V0RXJyb3JNZXNzYWdlKCdVbmFibGUgdG8gc3RhcnQgdmlkZW8gc3RyZWFtLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpZGVvIGVsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbWVyYSBhY2Nlc3MgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgZXJyb3IgdHlwZXNcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICBzZXRFcnJvck1lc3NhZ2UoJ0NhbWVyYSBhY2Nlc3MgZGVuaWVkLiBQbGVhc2UgY2hlY2sgYnJvd3NlciBwZXJtaXNzaW9ucyBhbmQgdHJ5IGFnYWluLicpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgc2V0RXJyb3JNZXNzYWdlKCdObyBjYW1lcmEgZGV0ZWN0ZWQuIFBsZWFzZSBjb25uZWN0IGEgY2FtZXJhIGFuZCB0cnkgYWdhaW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJykge1xuICAgICAgICBzZXRFcnJvck1lc3NhZ2UoJ0NhbWVyYSBpcyBiZWluZyB1c2VkIGJ5IGFub3RoZXIgYXBwbGljYXRpb24uJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRFcnJvck1lc3NhZ2UoYENhbWVyYSBlcnJvcjogJHtlcnJvci5tZXNzYWdlIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc3RvcENhbWVyYSA9ICgpID0+IHtcbiAgICAvLyBTdG9wIGFsbCB0cmFja3MgaW4gdGhlIHN0cmVhbVxuICAgIGlmIChzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICBzZXRTdHJlYW0obnVsbCk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIHZpZGVvIHNvdXJjZVxuICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICB2aWRlb1JlZi5jdXJyZW50LnNyY09iamVjdCA9IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIHByb2Nlc3NpbmcgaW50ZXJ2YWxcbiAgICBpZiAocHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQpO1xuICAgICAgcHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc1ZpZGVvUmVhZHkoZmFsc2UpO1xuICB9O1xuXG4gIGNvbnN0IHN0YXJ0UHJvY2Vzc2luZyA9ICgpID0+IHtcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50IHx8ICF2aWRlb1JlZi5jdXJyZW50IHx8ICFpc1ZpZGVvUmVhZHkpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB2aWRlbyA9IHZpZGVvUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gVXNlIGhpZ2ggcmVzb2x1dGlvbiBmb3IgcHJvY2Vzc2luZyBjYW52YXMgcmVnYXJkbGVzcyBvZiBjdXJyZW50IHZpZGVvIHJlc29sdXRpb25cbiAgICBjb25zdCBwcm9jZXNzaW5nV2lkdGggPSAxMjgwO1xuICAgIGNvbnN0IHByb2Nlc3NpbmdIZWlnaHQgPSA3MjA7XG4gICAgXG4gICAgLy8gU2V0IGNhbnZhcyB0byBoaWdoIHJlc29sdXRpb24gZm9yIHByb2Nlc3NpbmdcbiAgICBjYW52YXMud2lkdGggPSBwcm9jZXNzaW5nV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHByb2Nlc3NpbmdIZWlnaHQ7XG4gICAgXG4gICAgLy8gU3RhcnQgcHJvY2Vzc2luZyBmcmFtZXMgYXQgfjMwZnBzXG4gICAgcHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodmlkZW8ucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXNcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBjb250ZXh0IHN0YXRlXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgXG4gICAgICAvLyBGbGlwIHRoZSBjb250ZXh0IGhvcml6b250YWxseSB0byBtaXJyb3IgdGhlIHZpZGVvXG4gICAgICBjdHgudHJhbnNsYXRlKGNhbnZhcy53aWR0aCwgMCk7XG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xuICAgICAgXG4gICAgICAvLyBEcmF3IHZpZGVvIGZyYW1lIHRvIGNhbnZhcyBhdCBoaWdoIHJlc29sdXRpb25cbiAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW8sIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgdGhlIGNvbnRleHQgc3RhdGVcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBcbiAgICAgIC8vIFNpbXVsYXRlIGZhY2UgZGV0ZWN0aW9uICg5MCUgY2hhbmNlIG9mIGZhY2UgZGV0ZWN0ZWQpXG4gICAgICBjb25zdCBmYWNlRGV0ZWN0ZWQgPSBNYXRoLnJhbmRvbSgpID4gMC4xO1xuICAgICAgXG4gICAgICAvLyBEcmF3IHZpc3VhbGl6YXRpb25zIGJhc2VkIG9uIGVuYWJsZWQgb3B0aW9uc1xuICAgICAgaWYgKGZhY2VEZXRlY3RlZCkge1xuICAgICAgICBpZiAoc2hvd0JvdW5kaW5nQm94KSB7XG4gICAgICAgICAgZHJhd0JvdW5kaW5nQm94KGN0eCwgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHNob3dIZWFkUG9zZSkge1xuICAgICAgICAgIGRyYXdIZWFkUG9zZShjdHgsIGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzaG93TWFzaykge1xuICAgICAgICAgIGRyYXdGYWNlTWFzayhjdHgsIGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGlzcGxheSBwYXJhbWV0ZXJzIGlmIGVuYWJsZWRcbiAgICAgIGlmIChzaG93UGFyYW1ldGVycykge1xuICAgICAgICBkcmF3UGFyYW1ldGVycyhjdHgsIGNhbnZhcywgZmFjZURldGVjdGVkKTtcbiAgICAgIH1cbiAgICB9LCAzMyk7IC8vIH4zMGZwc1xuICB9O1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRyYXcgYm91bmRpbmcgYm94XG4gIGNvbnN0IGRyYXdCb3VuZGluZ0JveCA9IChjdHgsIGNhbnZhcykgPT4ge1xuICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBjYW52YXMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBib3hXaWR0aCA9IGNhbnZhcy53aWR0aCAqIDAuNjtcbiAgICBjb25zdCBib3hIZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICogMC44O1xuICAgIFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCAwLCAwLjcpJztcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHguc3Ryb2tlUmVjdChcbiAgICAgIGNlbnRlclggLSBib3hXaWR0aC8yLCBcbiAgICAgIGNlbnRlclkgLSBib3hIZWlnaHQvMiwgXG4gICAgICBib3hXaWR0aCwgXG4gICAgICBib3hIZWlnaHRcbiAgICApO1xuICB9O1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRyYXcgaGVhZCBwb3NlIGF4ZXNcbiAgY29uc3QgZHJhd0hlYWRQb3NlID0gKGN0eCwgY2FudmFzKSA9PiB7XG4gICAgY29uc3QgY2VudGVyWCA9IGNhbnZhcy53aWR0aCAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IGNhbnZhcy5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgICBjb25zdCBsZW5ndGggPSBjYW52YXMud2lkdGggKiAwLjE7XG4gICAgXG4gICAgLy8gWCBheGlzIChyZWQpXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgY3R4LmxpbmVUbyhjZW50ZXJYICsgbGVuZ3RoICogTWF0aC5zaW4odGltZSksIGNlbnRlclkpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBZIGF4aXMgKGdyZWVuKVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKGNlbnRlclgsIGNlbnRlclkpO1xuICAgIGN0eC5saW5lVG8oY2VudGVyWCwgY2VudGVyWSArIGxlbmd0aCAqIE1hdGguc2luKHRpbWUgKyAxKSk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgXG4gICAgLy8gWiBheGlzIChibHVlKVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKGNlbnRlclgsIGNlbnRlclkpO1xuICAgIGN0eC5saW5lVG8oXG4gICAgICBjZW50ZXJYICsgbGVuZ3RoLzIgKiBNYXRoLnNpbih0aW1lICsgMiksIFxuICAgICAgY2VudGVyWSAtIGxlbmd0aC8yICogTWF0aC5jb3ModGltZSArIDIpXG4gICAgKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9O1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRyYXcgZmFjZSBtYXNrXG4gIGNvbnN0IGRyYXdGYWNlTWFzayA9IChjdHgsIGNhbnZhcykgPT4ge1xuICAgIGNvbnN0IGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBjYW52YXMuaGVpZ2h0IC8gMjtcbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1pbihjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpICogMC4yO1xuICAgIFxuICAgIC8vIERyYXcgbWFza1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgwLCAyNTUsIDI1NSwgMC4yKSc7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBEcmF3IGV5ZXNcbiAgICBjb25zdCBleWVSYWRpdXMgPSByYWRpdXMgKiAwLjI7XG4gICAgY29uc3QgZXllT2Zmc2V0WCA9IHJhZGl1cyAqIDAuMztcbiAgICBjb25zdCBleWVPZmZzZXRZID0gcmFkaXVzICogMC4xO1xuICAgIFxuICAgIGN0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJztcbiAgICBcbiAgICAvLyBMZWZ0IGV5ZVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKGNlbnRlclggLSBleWVPZmZzZXRYLCBjZW50ZXJZIC0gZXllT2Zmc2V0WSwgZXllUmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBSaWdodCBleWVcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhjZW50ZXJYICsgZXllT2Zmc2V0WCwgY2VudGVyWSAtIGV5ZU9mZnNldFksIGV5ZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsKCk7XG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZHJhdyBwYXJhbWV0ZXJzXG4gIGNvbnN0IGRyYXdQYXJhbWV0ZXJzID0gKGN0eCwgY2FudmFzLCBmYWNlRGV0ZWN0ZWQpID0+IHtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC43KSc7XG4gICAgY3R4LmZpbGxSZWN0KDUsIGNhbnZhcy5oZWlnaHQgLSA2MCwgMTUwLCA1MCk7XG4gICAgXG4gICAgY3R4LmZvbnQgPSAnMTJweCBBcmlhbCc7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxUZXh0KGBSZXNvbHV0aW9uOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWAsIDEwLCBjYW52YXMuaGVpZ2h0IC0gNDApO1xuICAgIGN0eC5maWxsVGV4dChgRlBTOiAke2Zwc31gLCAxMCwgY2FudmFzLmhlaWdodCAtIDI1KTtcbiAgICBjdHguZmlsbFRleHQoYEZhY2U6ICR7ZmFjZURldGVjdGVkID8gJ0RldGVjdGVkJyA6ICdOb3QgRGV0ZWN0ZWQnfWAsIDEwLCBjYW52YXMuaGVpZ2h0IC0gMTApO1xuICB9O1xuXG4gIGlmICghaXNTaG93aW5nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgXG4gICAgICByZWY9e2NvbnRhaW5lclJlZn1cbiAgICAgIHN0eWxlPXt7IFxuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgbGVmdDogJzUwJScsXG4gICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKScsXG4gICAgICAgIHdpZHRoOiAnMzB2dycsIC8vIDMwJSBvZiB2aWV3cG9ydCB3aWR0aFxuICAgICAgICBoZWlnaHQ6ICczMHZoJywgLy8gMzAlIG9mIHZpZXdwb3J0IGhlaWdodFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgIGJveFNoYWRvdzogJzAgNHB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMiknLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIHpJbmRleDogMTAwMFxuICAgICAgfX1cbiAgICA+XG4gICAgICA8dmlkZW9cbiAgICAgICAgcmVmPXt2aWRlb1JlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIG9iamVjdEZpdDogJ2NvdmVyJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ICdzY2FsZVgoLTEpJywgLy8gRmxpcCBob3Jpem9udGFsbHlcbiAgICAgICAgICBvcGFjaXR5OiAwIC8vIEtlZXAgdmlkZW8gaGlkZGVuIGJ1dCBmdW5jdGlvbmFsXG4gICAgICAgIH19XG4gICAgICAgIHBsYXlzSW5saW5lXG4gICAgICAgIG11dGVkXG4gICAgICAgIGF1dG9QbGF5XG4gICAgICAvPlxuICAgICAgPGNhbnZhc1xuICAgICAgICByZWY9e2NhbnZhc1JlZn1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25DbGljaz17b25DbG9zZX1cbiAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICB0b3A6ICcxMHB4JyxcbiAgICAgICAgICByaWdodDogJzEwcHgnLFxuICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTJweCcsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJyxcbiAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgIHpJbmRleDogMlxuICAgICAgICB9fVxuICAgICAgPlxuICAgICAgICBDbG9zZVxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYW1lcmFBY2Nlc3M7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJDYW1lcmFBY2Nlc3MiLCJpc1Nob3dpbmciLCJvbkNsb3NlIiwib25DYW1lcmFSZWFkeSIsInNob3dIZWFkUG9zZSIsInNob3dCb3VuZGluZ0JveCIsInNob3dNYXNrIiwic2hvd1BhcmFtZXRlcnMiLCJ2aWRlb1JlZiIsImNhbnZhc1JlZiIsImNvbnRhaW5lclJlZiIsInN0cmVhbSIsInNldFN0cmVhbSIsImVycm9yTWVzc2FnZSIsInNldEVycm9yTWVzc2FnZSIsImZwcyIsInNldEZwcyIsImZwc1RpbWVyUmVmIiwicHJvY2Vzc2luZ0ludGVydmFsIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJ3aWR0aCIsImhlaWdodCIsImlzVmlkZW9SZWFkeSIsInNldElzVmlkZW9SZWFkeSIsImN1cnJlbnRSZXNvbHV0aW9uIiwic2V0Q3VycmVudFJlc29sdXRpb24iLCJyZXNvbHV0aW9uVGltZXJSZWYiLCJzdGFydENhbWVyYSIsInN0b3BDYW1lcmEiLCJjdXJyZW50IiwiY2xlYXJUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJwcmV2RnBzIiwibmV3RnBzIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiY2xlYXJJbnRlcnZhbCIsInVwZGF0ZURpbWVuc2lvbnMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInZpZGVvIiwiaGFuZGxlTG9hZGVkTWV0YWRhdGEiLCJjb25zb2xlIiwibG9nIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJjb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsInN0eWxlIiwic3RhcnRQcm9jZXNzaW5nIiwidXBncmFkZVJlc29sdXRpb24iLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdG9wIiwibmV3U3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiaWRlYWwiLCJmYWNpbmdNb2RlIiwiYXVkaW8iLCJzcmNPYmplY3QiLCJlcnJvciIsInNldFRpbWVvdXQiLCJtZWRpYVN0cmVhbSIsIm1heCIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJhdXRvcGxheSIsInBsYXkiLCJwbGF5RXJyb3IiLCJFcnJvciIsIm5hbWUiLCJtZXNzYWdlIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsInByb2Nlc3NpbmdXaWR0aCIsInByb2Nlc3NpbmdIZWlnaHQiLCJyZWFkeVN0YXRlIiwiY2xlYXJSZWN0Iiwic2F2ZSIsInRyYW5zbGF0ZSIsInNjYWxlIiwiZHJhd0ltYWdlIiwicmVzdG9yZSIsImZhY2VEZXRlY3RlZCIsImRyYXdCb3VuZGluZ0JveCIsImRyYXdIZWFkUG9zZSIsImRyYXdGYWNlTWFzayIsImRyYXdQYXJhbWV0ZXJzIiwiY2VudGVyWCIsImNlbnRlclkiLCJib3hXaWR0aCIsImJveEhlaWdodCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlUmVjdCIsInRpbWUiLCJEYXRlIiwibm93IiwibGVuZ3RoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic2luIiwic3Ryb2tlIiwiY29zIiwicmFkaXVzIiwibWluIiwiZmlsbFN0eWxlIiwiYXJjIiwiUEkiLCJmaWxsIiwiZXllUmFkaXVzIiwiZXllT2Zmc2V0WCIsImV5ZU9mZnNldFkiLCJmaWxsUmVjdCIsImZvbnQiLCJmaWxsVGV4dCIsImRpdiIsInJlZiIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInRyYW5zZm9ybSIsImJhY2tncm91bmRDb2xvciIsImJvcmRlclJhZGl1cyIsImJveFNoYWRvdyIsIm92ZXJmbG93IiwiekluZGV4Iiwib2JqZWN0Rml0Iiwib3BhY2l0eSIsImF1dG9QbGF5IiwiYnV0dG9uIiwib25DbGljayIsInJpZ2h0IiwicGFkZGluZyIsImNvbG9yIiwiYm9yZGVyIiwiY3Vyc29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/cameraAccess.js\n"));

/***/ })

}]);