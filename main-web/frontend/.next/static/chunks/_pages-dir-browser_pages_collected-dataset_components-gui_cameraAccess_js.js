"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset_components-gui_cameraAccess_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset/components-gui/cameraAccess.js":
/*!****************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/cameraAccess.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_gui_Helper_savefile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components-gui/Helper/savefile */ \"(pages-dir-browser)/./pages/collected-dataset/components-gui/Helper/savefile.js\");\n// cameraAccess.js\n\nvar _s = $RefreshSig$();\n\n\nconst CameraAccess = (param)=>{\n    let { isShowing, onClose, onCameraReady, showHeadPose = false, showBoundingBox = false, showMask = false, showParameters = false } = param;\n    _s();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const wsRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [stream, setStream] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [errorMessage, setErrorMessage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [fps, setFps] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const fpsTimerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const processingInterval = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [dimensions, setDimensions] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        width: 0,\n        height: 0\n    });\n    const [isVideoReady, setIsVideoReady] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [processingResults, setProcessingResults] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const frameQueue = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const isProcessing = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // WebSocket connection\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            const ws = new WebSocket('ws://localhost:8000/ws/video');\n            wsRef.current = ws;\n            ws.onopen = ({\n                \"CameraAccess.useEffect\": ()=>{\n                    console.log('WebSocket connected');\n                }\n            })[\"CameraAccess.useEffect\"];\n            ws.onmessage = ({\n                \"CameraAccess.useEffect\": (event)=>{\n                    try {\n                        const result = JSON.parse(event.data);\n                        setProcessingResults(result);\n                        drawResults(result);\n                    } catch (error) {\n                        console.error('Error parsing WebSocket message:', error);\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n            ws.onerror = ({\n                \"CameraAccess.useEffect\": (error)=>{\n                    console.error('WebSocket error:', error);\n                }\n            })[\"CameraAccess.useEffect\"];\n            ws.onclose = ({\n                \"CameraAccess.useEffect\": ()=>{\n                    console.log('WebSocket disconnected');\n                }\n            })[\"CameraAccess.useEffect\"];\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    if (wsRef.current) {\n                        wsRef.current.close();\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Frame capture and processing\n    const captureAndProcessFrame = ()=>{\n        if (!videoRef.current || !canvasRef.current || !isVideoReady || !wsRef.current) return;\n        const video = videoRef.current;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Save the current context state\n        ctx.save();\n        // Flip the context horizontally to mirror the video\n        ctx.translate(canvas.width, 0);\n        ctx.scale(-1, 1);\n        // Draw video frame to canvas at high resolution\n        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        // Restore the context state\n        ctx.restore();\n        // Convert canvas to blob with high quality\n        canvas.toBlob((blob)=>{\n            if (blob && wsRef.current && wsRef.current.readyState === WebSocket.OPEN) {\n                // Send frame to backend\n                wsRef.current.send(blob);\n            }\n        }, 'image/jpeg', 0.95);\n    };\n    // Draw processing results\n    const drawResults = (results)=>{\n        if (!canvasRef.current || !results) return;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Draw bounding box if available\n        if (results.bounding_box && showBoundingBox) {\n            const { x, y, width, height } = results.bounding_box;\n            ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(x, y, width, height);\n        }\n        // Draw head pose if available\n        if (results.head_pose && showHeadPose) {\n            const { pitch, yaw, roll } = results.head_pose;\n            // Draw head pose visualization\n            drawHeadPose(ctx, canvas, pitch, yaw, roll);\n        }\n        // Draw face mask if available\n        if (results.face_mask && showMask) {\n            const { points } = results.face_mask;\n            drawFaceMask(ctx, canvas, points);\n        }\n        // Draw parameters if enabled\n        if (showParameters) {\n            drawParameters(ctx, canvas, results);\n        }\n    };\n    // Start camera with highest resolution\n    const startCamera = async ()=>{\n        setErrorMessage('');\n        setIsVideoReady(false);\n        try {\n            console.log('Starting camera access with highest resolution...');\n            // Get highest resolution constraints\n            const constraints = await (0,_components_gui_Helper_savefile__WEBPACK_IMPORTED_MODULE_2__.getHighestResolutionConstraints)();\n            console.log('Using camera constraints:', constraints);\n            const mediaStream = await navigator.mediaDevices.getUserMedia({\n                ...constraints,\n                audio: false\n            });\n            console.log('High resolution camera access granted!');\n            setStream(mediaStream);\n            if (videoRef.current) {\n                videoRef.current.playsInline = true;\n                videoRef.current.muted = true;\n                videoRef.current.autoplay = true;\n                videoRef.current.srcObject = mediaStream;\n                try {\n                    await videoRef.current.play();\n                    console.log('Video playing successfully!');\n                    // Start frame processing\n                    processingInterval.current = setInterval(captureAndProcessFrame, 33); // ~30fps\n                } catch (playError) {\n                    console.error('Error playing video:', playError);\n                    setErrorMessage('Unable to start video stream. Please try again.');\n                }\n            }\n        } catch (error) {\n            console.error('Camera access error:', error);\n            setErrorMessage(\"Camera error: \".concat(error.message || 'Unknown error'));\n        }\n    };\n    const stopCamera = ()=>{\n        // Stop all tracks in the stream\n        if (stream) {\n            stream.getTracks().forEach((track)=>track.stop());\n            setStream(null);\n        }\n        // Clear video source\n        if (videoRef.current) {\n            videoRef.current.srcObject = null;\n        }\n        // Clear processing interval\n        if (processingInterval.current) {\n            clearInterval(processingInterval.current);\n            processingInterval.current = null;\n        }\n        setIsVideoReady(false);\n    };\n    // Start camera on component mount if isShowing is true\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (isShowing) {\n                startCamera();\n            } else {\n                stopCamera();\n            }\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    stopCamera();\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Setup FPS counter\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            fpsTimerRef.current = setInterval({\n                \"CameraAccess.useEffect\": ()=>{\n                    setFps({\n                        \"CameraAccess.useEffect\": (prevFps)=>{\n                            // Simple mock for fps counter\n                            const newFps = Math.floor(Math.random() * 10) + 25; // Random between 25-35 fps\n                            return newFps;\n                        }\n                    }[\"CameraAccess.useEffect\"]);\n                }\n            }[\"CameraAccess.useEffect\"], 1000);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    if (fpsTimerRef.current) {\n                        clearInterval(fpsTimerRef.current);\n                    }\n                    if (processingInterval.current) {\n                        clearInterval(processingInterval.current);\n                    }\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Update dimensions when container size changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing) return;\n            const updateDimensions = {\n                \"CameraAccess.useEffect.updateDimensions\": ()=>{\n                    if (containerRef.current) {\n                        const { width, height } = containerRef.current.getBoundingClientRect();\n                        setDimensions({\n                            width,\n                            height\n                        });\n                    }\n                }\n            }[\"CameraAccess.useEffect.updateDimensions\"];\n            updateDimensions();\n            window.addEventListener('resize', updateDimensions);\n            return ({\n                \"CameraAccess.useEffect\": ()=>window.removeEventListener('resize', updateDimensions)\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        isShowing\n    ]);\n    // Handle video element ready state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"CameraAccess.useEffect\": ()=>{\n            if (!isShowing || !videoRef.current || !stream) return;\n            const video = videoRef.current;\n            const handleLoadedMetadata = {\n                \"CameraAccess.useEffect.handleLoadedMetadata\": ()=>{\n                    console.log('Video metadata loaded');\n                    setIsVideoReady(true);\n                    // Get video dimensions\n                    const videoWidth = video.videoWidth || 640;\n                    const videoHeight = video.videoHeight || 480;\n                    console.log(\"Video dimensions: \".concat(videoWidth, \"x\").concat(videoHeight));\n                    // Setup canvas for processing\n                    if (canvasRef.current) {\n                        // Store actual dimensions for capture\n                        canvasRef.current.width = videoWidth;\n                        canvasRef.current.height = videoHeight;\n                        // Set display size to maintain aspect ratio\n                        const aspectRatio = videoWidth / videoHeight;\n                        const containerWidth = dimensions.width;\n                        const containerHeight = containerWidth / aspectRatio;\n                        canvasRef.current.style.width = \"\".concat(containerWidth, \"px\");\n                        canvasRef.current.style.height = \"\".concat(containerHeight, \"px\");\n                    }\n                    // Start processing frames\n                    startProcessing();\n                    // Notify parent component that camera is ready\n                    if (onCameraReady) {\n                        onCameraReady({\n                            width: videoWidth,\n                            height: videoHeight\n                        });\n                    }\n                }\n            }[\"CameraAccess.useEffect.handleLoadedMetadata\"];\n            video.addEventListener('loadedmetadata', handleLoadedMetadata);\n            return ({\n                \"CameraAccess.useEffect\": ()=>{\n                    video.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                }\n            })[\"CameraAccess.useEffect\"];\n        }\n    }[\"CameraAccess.useEffect\"], [\n        stream,\n        isShowing,\n        dimensions,\n        onCameraReady\n    ]);\n    const startProcessing = ()=>{\n        if (!canvasRef.current || !videoRef.current || !isVideoReady) return;\n        const video = videoRef.current;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Start processing frames at ~30fps\n        processingInterval.current = setInterval(()=>{\n            if (video.readyState !== 4) return;\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            // Save the current context state\n            ctx.save();\n            // Flip the context horizontally to mirror the video\n            ctx.translate(canvas.width, 0);\n            ctx.scale(-1, 1);\n            // Draw video frame to canvas at high resolution\n            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n            // Restore the context state\n            ctx.restore();\n            // Simulate face detection (90% chance of face detected)\n            const faceDetected = Math.random() > 0.1;\n            // Draw visualizations based on enabled options\n            if (faceDetected) {\n                if (showBoundingBox) {\n                    drawBoundingBox(ctx, canvas);\n                }\n                if (showHeadPose) {\n                    drawHeadPose(ctx, canvas);\n                }\n                if (showMask) {\n                    drawFaceMask(ctx, canvas);\n                }\n            }\n            // Display parameters if enabled\n            if (showParameters) {\n                drawParameters(ctx, canvas, faceDetected);\n            }\n        }, 33); // ~30fps\n    };\n    // Helper function to draw bounding box\n    const drawBoundingBox = (ctx, canvas)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const boxWidth = canvas.width * 0.6;\n        const boxHeight = canvas.height * 0.8;\n        ctx.strokeStyle = 'rgba(255, 255, 0, 0.7)';\n        ctx.lineWidth = 2;\n        ctx.strokeRect(centerX - boxWidth / 2, centerY - boxHeight / 2, boxWidth, boxHeight);\n    };\n    // Helper function to draw head pose axes\n    const drawHeadPose = (ctx, canvas, pitch, yaw, roll)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const time = Date.now() / 1000;\n        const length = canvas.width * 0.1;\n        // X axis (red)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX + length * Math.sin(time), centerY);\n        ctx.strokeStyle = 'red';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        // Y axis (green)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX, centerY + length * Math.sin(time + 1));\n        ctx.strokeStyle = 'green';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n        // Z axis (blue)\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.lineTo(centerX + length / 2 * Math.sin(time + 2), centerY - length / 2 * Math.cos(time + 2));\n        ctx.strokeStyle = 'blue';\n        ctx.lineWidth = 3;\n        ctx.stroke();\n    };\n    // Helper function to draw face mask\n    const drawFaceMask = (ctx, canvas, points)=>{\n        const centerX = canvas.width / 2;\n        const centerY = canvas.height / 2;\n        const radius = Math.min(canvas.width, canvas.height) * 0.2;\n        // Draw mask\n        ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';\n        ctx.beginPath();\n        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);\n        ctx.fill();\n        // Draw eyes\n        const eyeRadius = radius * 0.2;\n        const eyeOffsetX = radius * 0.3;\n        const eyeOffsetY = radius * 0.1;\n        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';\n        // Left eye\n        ctx.beginPath();\n        ctx.arc(centerX - eyeOffsetX, centerY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);\n        ctx.fill();\n        // Right eye\n        ctx.beginPath();\n        ctx.arc(centerX + eyeOffsetX, centerY - eyeOffsetY, eyeRadius, 0, Math.PI * 2);\n        ctx.fill();\n    };\n    // Helper function to draw parameters\n    const drawParameters = (ctx, canvas, faceDetected)=>{\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(5, canvas.height - 60, 150, 50);\n        ctx.font = '12px Arial';\n        ctx.fillStyle = 'white';\n        ctx.fillText(\"Resolution: \".concat(canvas.width, \"x\").concat(canvas.height), 10, canvas.height - 40);\n        ctx.fillText(\"FPS: \".concat(fps), 10, canvas.height - 25);\n        ctx.fillText(\"Face: \".concat(faceDetected ? 'Detected' : 'Not Detected'), 10, canvas.height - 10);\n    };\n    if (!isShowing) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: containerRef,\n        style: {\n            position: 'fixed',\n            top: '50%',\n            left: '50%',\n            transform: 'translate(-50%, -50%)',\n            width: '30vw',\n            height: '30vh',\n            backgroundColor: 'white',\n            borderRadius: '8px',\n            boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',\n            overflow: 'hidden',\n            zIndex: 1000\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                ref: videoRef,\n                style: {\n                    width: '100%',\n                    height: '100%',\n                    objectFit: 'cover',\n                    transform: 'scaleX(-1)',\n                    opacity: 0 // Keep video hidden but functional\n                },\n                playsInline: true,\n                muted: true,\n                autoPlay: true\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 464,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                ref: canvasRef,\n                style: {\n                    position: 'absolute',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    zIndex: 1\n                }\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 477,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                onClick: onClose,\n                style: {\n                    position: 'absolute',\n                    top: '10px',\n                    right: '10px',\n                    padding: '8px 12px',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    color: 'white',\n                    border: 'none',\n                    borderRadius: '4px',\n                    cursor: 'pointer',\n                    zIndex: 2\n                },\n                children: \"Close\"\n            }, void 0, false, {\n                fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n                lineNumber: 488,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/cameraAccess.js\",\n        lineNumber: 448,\n        columnNumber: 5\n    }, undefined);\n};\n_s(CameraAccess, \"u5Ewra5gvjrc3MgRHXM+m/A4jTU=\");\n_c = CameraAccess;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CameraAccess);\nvar _c;\n$RefreshReg$(_c, \"CameraAccess\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL2NhbWVyYUFjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxrQkFBa0I7OztBQUN5QztBQUN5QjtBQUVwRixNQUFNSyxlQUFlO1FBQUMsRUFDcEJDLFNBQVMsRUFDVEMsT0FBTyxFQUNQQyxhQUFhLEVBQ2JDLGVBQWUsS0FBSyxFQUNwQkMsa0JBQWtCLEtBQUssRUFDdkJDLFdBQVcsS0FBSyxFQUNoQkMsaUJBQWlCLEtBQUssRUFDdkI7O0lBQ0MsTUFBTUMsV0FBV1gsNkNBQU1BLENBQUM7SUFDeEIsTUFBTVksWUFBWVosNkNBQU1BLENBQUM7SUFDekIsTUFBTWEsZUFBZWIsNkNBQU1BLENBQUM7SUFDNUIsTUFBTWMsUUFBUWQsNkNBQU1BLENBQUM7SUFDckIsTUFBTSxDQUFDZSxRQUFRQyxVQUFVLEdBQUdmLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0sQ0FBQ2dCLGNBQWNDLGdCQUFnQixHQUFHakIsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDa0IsS0FBS0MsT0FBTyxHQUFHbkIsK0NBQVFBLENBQUM7SUFDL0IsTUFBTW9CLGNBQWNyQiw2Q0FBTUEsQ0FBQztJQUMzQixNQUFNc0IscUJBQXFCdEIsNkNBQU1BLENBQUM7SUFDbEMsTUFBTSxDQUFDdUIsWUFBWUMsY0FBYyxHQUFHdkIsK0NBQVFBLENBQUM7UUFBRXdCLE9BQU87UUFBR0MsUUFBUTtJQUFFO0lBQ25FLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUczQiwrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUM0QixtQkFBbUJDLHFCQUFxQixHQUFHN0IsK0NBQVFBLENBQUM7SUFDM0QsTUFBTThCLGFBQWEvQiw2Q0FBTUEsQ0FBQyxFQUFFO0lBQzVCLE1BQU1nQyxlQUFlaEMsNkNBQU1BLENBQUM7SUFFNUIsdUJBQXVCO0lBQ3ZCRCxnREFBU0E7a0NBQUM7WUFDUixJQUFJLENB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YWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL2NhbWVyYUFjY2Vzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjYW1lcmFBY2Nlc3MuanNcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzIH0gZnJvbSAnLi4vY29tcG9uZW50cy1ndWkvSGVscGVyL3NhdmVmaWxlJztcblxuY29uc3QgQ2FtZXJhQWNjZXNzID0gKHsgXG4gIGlzU2hvd2luZywgXG4gIG9uQ2xvc2UsIFxuICBvbkNhbWVyYVJlYWR5LFxuICBzaG93SGVhZFBvc2UgPSBmYWxzZSxcbiAgc2hvd0JvdW5kaW5nQm94ID0gZmFsc2UsXG4gIHNob3dNYXNrID0gZmFsc2UsXG4gIHNob3dQYXJhbWV0ZXJzID0gZmFsc2Vcbn0pID0+IHtcbiAgY29uc3QgdmlkZW9SZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCB3c1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW3N0cmVhbSwgc2V0U3RyZWFtXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbZXJyb3JNZXNzYWdlLCBzZXRFcnJvck1lc3NhZ2VdID0gdXNlU3RhdGUoJycpO1xuICBjb25zdCBbZnBzLCBzZXRGcHNdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IGZwc1RpbWVyUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwcm9jZXNzaW5nSW50ZXJ2YWwgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IHVzZVN0YXRlKHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgY29uc3QgW2lzVmlkZW9SZWFkeSwgc2V0SXNWaWRlb1JlYWR5XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Byb2Nlc3NpbmdSZXN1bHRzLCBzZXRQcm9jZXNzaW5nUmVzdWx0c10gPSB1c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgZnJhbWVRdWV1ZSA9IHVzZVJlZihbXSk7XG4gIGNvbnN0IGlzUHJvY2Vzc2luZyA9IHVzZVJlZihmYWxzZSk7XG4gIFxuICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTaG93aW5nKSByZXR1cm47XG5cbiAgICBjb25zdCB3cyA9IG5ldyBXZWJTb2NrZXQoJ3dzOi8vbG9jYWxob3N0OjgwMDAvd3MvdmlkZW8nKTtcbiAgICB3c1JlZi5jdXJyZW50ID0gd3M7XG5cbiAgICB3cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnV2ViU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgIH07XG5cbiAgICB3cy5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgIHNldFByb2Nlc3NpbmdSZXN1bHRzKHJlc3VsdCk7XG4gICAgICAgIGRyYXdSZXN1bHRzKHJlc3VsdCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIFdlYlNvY2tldCBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd3Mub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yKTtcbiAgICB9O1xuXG4gICAgd3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdXZWJTb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgfTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAod3NSZWYuY3VycmVudCkge1xuICAgICAgICB3c1JlZi5jdXJyZW50LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzU2hvd2luZ10pO1xuXG4gIC8vIEZyYW1lIGNhcHR1cmUgYW5kIHByb2Nlc3NpbmdcbiAgY29uc3QgY2FwdHVyZUFuZFByb2Nlc3NGcmFtZSA9ICgpID0+IHtcbiAgICBpZiAoIXZpZGVvUmVmLmN1cnJlbnQgfHwgIWNhbnZhc1JlZi5jdXJyZW50IHx8ICFpc1ZpZGVvUmVhZHkgfHwgIXdzUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIGNvbnN0IHZpZGVvID0gdmlkZW9SZWYuY3VycmVudDtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIENsZWFyIGNhbnZhc1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgY29udGV4dCBzdGF0ZVxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICAvLyBGbGlwIHRoZSBjb250ZXh0IGhvcml6b250YWxseSB0byBtaXJyb3IgdGhlIHZpZGVvXG4gICAgY3R4LnRyYW5zbGF0ZShjYW52YXMud2lkdGgsIDApO1xuICAgIGN0eC5zY2FsZSgtMSwgMSk7XG5cbiAgICAvLyBEcmF3IHZpZGVvIGZyYW1lIHRvIGNhbnZhcyBhdCBoaWdoIHJlc29sdXRpb25cbiAgICBjdHguZHJhd0ltYWdlKHZpZGVvLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgLy8gUmVzdG9yZSB0aGUgY29udGV4dCBzdGF0ZVxuICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAvLyBDb252ZXJ0IGNhbnZhcyB0byBibG9iIHdpdGggaGlnaCBxdWFsaXR5XG4gICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgaWYgKGJsb2IgJiYgd3NSZWYuY3VycmVudCAmJiB3c1JlZi5jdXJyZW50LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgIC8vIFNlbmQgZnJhbWUgdG8gYmFja2VuZFxuICAgICAgICB3c1JlZi5jdXJyZW50LnNlbmQoYmxvYik7XG4gICAgICB9XG4gICAgfSwgJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgfTtcblxuICAvLyBEcmF3IHByb2Nlc3NpbmcgcmVzdWx0c1xuICBjb25zdCBkcmF3UmVzdWx0cyA9IChyZXN1bHRzKSA9PiB7XG4gICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCAhcmVzdWx0cykgcmV0dXJuO1xuXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBEcmF3IGJvdW5kaW5nIGJveCBpZiBhdmFpbGFibGVcbiAgICBpZiAocmVzdWx0cy5ib3VuZGluZ19ib3ggJiYgc2hvd0JvdW5kaW5nQm94KSB7XG4gICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHJlc3VsdHMuYm91bmRpbmdfYm94O1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjgpJztcbiAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgY3R4LnN0cm9rZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBoZWFkIHBvc2UgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHJlc3VsdHMuaGVhZF9wb3NlICYmIHNob3dIZWFkUG9zZSkge1xuICAgICAgY29uc3QgeyBwaXRjaCwgeWF3LCByb2xsIH0gPSByZXN1bHRzLmhlYWRfcG9zZTtcbiAgICAgIC8vIERyYXcgaGVhZCBwb3NlIHZpc3VhbGl6YXRpb25cbiAgICAgIGRyYXdIZWFkUG9zZShjdHgsIGNhbnZhcywgcGl0Y2gsIHlhdywgcm9sbCk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBmYWNlIG1hc2sgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHJlc3VsdHMuZmFjZV9tYXNrICYmIHNob3dNYXNrKSB7XG4gICAgICBjb25zdCB7IHBvaW50cyB9ID0gcmVzdWx0cy5mYWNlX21hc2s7XG4gICAgICBkcmF3RmFjZU1hc2soY3R4LCBjYW52YXMsIHBvaW50cyk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBwYXJhbWV0ZXJzIGlmIGVuYWJsZWRcbiAgICBpZiAoc2hvd1BhcmFtZXRlcnMpIHtcbiAgICAgIGRyYXdQYXJhbWV0ZXJzKGN0eCwgY2FudmFzLCByZXN1bHRzKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gU3RhcnQgY2FtZXJhIHdpdGggaGlnaGVzdCByZXNvbHV0aW9uXG4gIGNvbnN0IHN0YXJ0Q2FtZXJhID0gYXN5bmMgKCkgPT4ge1xuICAgIHNldEVycm9yTWVzc2FnZSgnJyk7XG4gICAgc2V0SXNWaWRlb1JlYWR5KGZhbHNlKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgY2FtZXJhIGFjY2VzcyB3aXRoIGhpZ2hlc3QgcmVzb2x1dGlvbi4uLicpO1xuXG4gICAgICAvLyBHZXQgaGlnaGVzdCByZXNvbHV0aW9uIGNvbnN0cmFpbnRzXG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IGdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBjYW1lcmEgY29uc3RyYWludHM6JywgY29uc3RyYWludHMpO1xuXG4gICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgLi4uY29uc3RyYWludHMsXG4gICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdIaWdoIHJlc29sdXRpb24gY2FtZXJhIGFjY2VzcyBncmFudGVkIScpO1xuICAgICAgc2V0U3RyZWFtKG1lZGlhU3RyZWFtKTtcblxuICAgICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgdmlkZW9SZWYuY3VycmVudC5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHZpZGVvUmVmLmN1cnJlbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB2aWRlb1JlZi5jdXJyZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgdmlkZW9SZWYuY3VycmVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHZpZGVvUmVmLmN1cnJlbnQucGxheSgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdWaWRlbyBwbGF5aW5nIHN1Y2Nlc3NmdWxseSEnKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTdGFydCBmcmFtZSBwcm9jZXNzaW5nXG4gICAgICAgICAgcHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChjYXB0dXJlQW5kUHJvY2Vzc0ZyYW1lLCAzMyk7IC8vIH4zMGZwc1xuICAgICAgICB9IGNhdGNoIChwbGF5RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwbGF5aW5nIHZpZGVvOicsIHBsYXlFcnJvcik7XG4gICAgICAgICAgc2V0RXJyb3JNZXNzYWdlKCdVbmFibGUgdG8gc3RhcnQgdmlkZW8gc3RyZWFtLiBQbGVhc2UgdHJ5IGFnYWluLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbWVyYSBhY2Nlc3MgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgc2V0RXJyb3JNZXNzYWdlKGBDYW1lcmEgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZSB8fCAnVW5rbm93biBlcnJvcid9YCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHN0b3BDYW1lcmEgPSAoKSA9PiB7XG4gICAgLy8gU3RvcCBhbGwgdHJhY2tzIGluIHRoZSBzdHJlYW1cbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgc2V0U3RyZWFtKG51bGwpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciB2aWRlbyBzb3VyY2VcbiAgICBpZiAodmlkZW9SZWYuY3VycmVudCkge1xuICAgICAgdmlkZW9SZWYuY3VycmVudC5zcmNPYmplY3QgPSBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhciBwcm9jZXNzaW5nIGludGVydmFsXG4gICAgaWYgKHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50KSB7XG4gICAgICBjbGVhckludGVydmFsKHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50KTtcbiAgICAgIHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNWaWRlb1JlYWR5KGZhbHNlKTtcbiAgfTtcblxuICAvLyBTdGFydCBjYW1lcmEgb24gY29tcG9uZW50IG1vdW50IGlmIGlzU2hvd2luZyBpcyB0cnVlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzU2hvd2luZykge1xuICAgICAgc3RhcnRDYW1lcmEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcENhbWVyYSgpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc3RvcENhbWVyYSgpO1xuICAgIH07XG4gIH0sIFtpc1Nob3dpbmddKTtcblxuICAvLyBTZXR1cCBGUFMgY291bnRlclxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNTaG93aW5nKSByZXR1cm47XG4gICAgXG4gICAgZnBzVGltZXJSZWYuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHNldEZwcyhwcmV2RnBzID0+IHtcbiAgICAgICAgLy8gU2ltcGxlIG1vY2sgZm9yIGZwcyBjb3VudGVyXG4gICAgICAgIGNvbnN0IG5ld0ZwcyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSArIDI1OyAvLyBSYW5kb20gYmV0d2VlbiAyNS0zNSBmcHNcbiAgICAgICAgcmV0dXJuIG5ld0ZwcztcbiAgICAgIH0pO1xuICAgIH0sIDEwMDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoZnBzVGltZXJSZWYuY3VycmVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKGZwc1RpbWVyUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgaWYgKHByb2Nlc3NpbmdJbnRlcnZhbC5jdXJyZW50KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocHJvY2Vzc2luZ0ludGVydmFsLmN1cnJlbnQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtpc1Nob3dpbmddKTtcblxuICAvLyBVcGRhdGUgZGltZW5zaW9ucyB3aGVuIGNvbnRhaW5lciBzaXplIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzU2hvd2luZykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHVwZGF0ZURpbWVuc2lvbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoY29udGFpbmVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb250YWluZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgc2V0RGltZW5zaW9ucyh7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgfSwgW2lzU2hvd2luZ10pO1xuXG4gIC8vIEhhbmRsZSB2aWRlbyBlbGVtZW50IHJlYWR5IHN0YXRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1Nob3dpbmcgfHwgIXZpZGVvUmVmLmN1cnJlbnQgfHwgIXN0cmVhbSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHZpZGVvID0gdmlkZW9SZWYuY3VycmVudDtcbiAgICBcbiAgICBjb25zdCBoYW5kbGVMb2FkZWRNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdWaWRlbyBtZXRhZGF0YSBsb2FkZWQnKTtcbiAgICAgIHNldElzVmlkZW9SZWFkeSh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IHZpZGVvIGRpbWVuc2lvbnNcbiAgICAgIGNvbnN0IHZpZGVvV2lkdGggPSB2aWRlby52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgIGNvbnN0IHZpZGVvSGVpZ2h0ID0gdmlkZW8udmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgVmlkZW8gZGltZW5zaW9uczogJHt2aWRlb1dpZHRofXgke3ZpZGVvSGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBTZXR1cCBjYW52YXMgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGlmIChjYW52YXNSZWYuY3VycmVudCkge1xuICAgICAgICAvLyBTdG9yZSBhY3R1YWwgZGltZW5zaW9ucyBmb3IgY2FwdHVyZVxuICAgICAgICBjYW52YXNSZWYuY3VycmVudC53aWR0aCA9IHZpZGVvV2lkdGg7XG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCA9IHZpZGVvSGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGRpc3BsYXkgc2l6ZSB0byBtYWludGFpbiBhc3BlY3QgcmF0aW9cbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSB2aWRlb1dpZHRoIC8gdmlkZW9IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcldpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgY29uc3QgY29udGFpbmVySGVpZ2h0ID0gY29udGFpbmVyV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgXG4gICAgICAgIGNhbnZhc1JlZi5jdXJyZW50LnN0eWxlLndpZHRoID0gYCR7Y29udGFpbmVyV2lkdGh9cHhgO1xuICAgICAgICBjYW52YXNSZWYuY3VycmVudC5zdHlsZS5oZWlnaHQgPSBgJHtjb250YWluZXJIZWlnaHR9cHhgO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTdGFydCBwcm9jZXNzaW5nIGZyYW1lc1xuICAgICAgc3RhcnRQcm9jZXNzaW5nKCk7XG4gICAgICBcbiAgICAgIC8vIE5vdGlmeSBwYXJlbnQgY29tcG9uZW50IHRoYXQgY2FtZXJhIGlzIHJlYWR5XG4gICAgICBpZiAob25DYW1lcmFSZWFkeSkge1xuICAgICAgICBvbkNhbWVyYVJlYWR5KHtcbiAgICAgICAgICB3aWR0aDogdmlkZW9XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHZpZGVvSGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGhhbmRsZUxvYWRlZE1ldGFkYXRhKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBoYW5kbGVMb2FkZWRNZXRhZGF0YSk7XG4gICAgfTtcbiAgfSwgW3N0cmVhbSwgaXNTaG93aW5nLCBkaW1lbnNpb25zLCBvbkNhbWVyYVJlYWR5XSk7XG5cbiAgY29uc3Qgc3RhcnRQcm9jZXNzaW5nID0gKCkgPT4ge1xuICAgIGlmICghY2FudmFzUmVmLmN1cnJlbnQgfHwgIXZpZGVvUmVmLmN1cnJlbnQgfHwgIWlzVmlkZW9SZWFkeSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHZpZGVvID0gdmlkZW9SZWYuY3VycmVudDtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBcbiAgICAvLyBTdGFydCBwcm9jZXNzaW5nIGZyYW1lcyBhdCB+MzBmcHNcbiAgICBwcm9jZXNzaW5nSW50ZXJ2YWwuY3VycmVudCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh2aWRlby5yZWFkeVN0YXRlICE9PSA0KSByZXR1cm47XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhc1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGNvbnRleHQgc3RhdGVcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBcbiAgICAgIC8vIEZsaXAgdGhlIGNvbnRleHQgaG9yaXpvbnRhbGx5IHRvIG1pcnJvciB0aGUgdmlkZW9cbiAgICAgIGN0eC50cmFuc2xhdGUoY2FudmFzLndpZHRoLCAwKTtcbiAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XG4gICAgICBcbiAgICAgIC8vIERyYXcgdmlkZW8gZnJhbWUgdG8gY2FudmFzIGF0IGhpZ2ggcmVzb2x1dGlvblxuICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSB0aGUgY29udGV4dCBzdGF0ZVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIFxuICAgICAgLy8gU2ltdWxhdGUgZmFjZSBkZXRlY3Rpb24gKDkwJSBjaGFuY2Ugb2YgZmFjZSBkZXRlY3RlZClcbiAgICAgIGNvbnN0IGZhY2VEZXRlY3RlZCA9IE1hdGgucmFuZG9tKCkgPiAwLjE7XG4gICAgICBcbiAgICAgIC8vIERyYXcgdmlzdWFsaXphdGlvbnMgYmFzZWQgb24gZW5hYmxlZCBvcHRpb25zXG4gICAgICBpZiAoZmFjZURldGVjdGVkKSB7XG4gICAgICAgIGlmIChzaG93Qm91bmRpbmdCb3gpIHtcbiAgICAgICAgICBkcmF3Qm91bmRpbmdCb3goY3R4LCBjYW52YXMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoc2hvd0hlYWRQb3NlKSB7XG4gICAgICAgICAgZHJhd0hlYWRQb3NlKGN0eCwgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHNob3dNYXNrKSB7XG4gICAgICAgICAgZHJhd0ZhY2VNYXNrKGN0eCwgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEaXNwbGF5IHBhcmFtZXRlcnMgaWYgZW5hYmxlZFxuICAgICAgaWYgKHNob3dQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGRyYXdQYXJhbWV0ZXJzKGN0eCwgY2FudmFzLCBmYWNlRGV0ZWN0ZWQpO1xuICAgICAgfVxuICAgIH0sIDMzKTsgLy8gfjMwZnBzXG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZHJhdyBib3VuZGluZyBib3hcbiAgY29uc3QgZHJhd0JvdW5kaW5nQm94ID0gKGN0eCwgY2FudmFzKSA9PiB7XG4gICAgY29uc3QgY2VudGVyWCA9IGNhbnZhcy53aWR0aCAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IGNhbnZhcy5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IGJveFdpZHRoID0gY2FudmFzLndpZHRoICogMC42O1xuICAgIGNvbnN0IGJveEhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKiAwLjg7XG4gICAgXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDAsIDAuNyknO1xuICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgIGN0eC5zdHJva2VSZWN0KFxuICAgICAgY2VudGVyWCAtIGJveFdpZHRoLzIsIFxuICAgICAgY2VudGVyWSAtIGJveEhlaWdodC8yLCBcbiAgICAgIGJveFdpZHRoLCBcbiAgICAgIGJveEhlaWdodFxuICAgICk7XG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZHJhdyBoZWFkIHBvc2UgYXhlc1xuICBjb25zdCBkcmF3SGVhZFBvc2UgPSAoY3R4LCBjYW52YXMsIHBpdGNoLCB5YXcsIHJvbGwpID0+IHtcbiAgICBjb25zdCBjZW50ZXJYID0gY2FudmFzLndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgdGltZSA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNvbnN0IGxlbmd0aCA9IGNhbnZhcy53aWR0aCAqIDAuMTtcbiAgICBcbiAgICAvLyBYIGF4aXMgKHJlZClcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICBjdHgubGluZVRvKGNlbnRlclggKyBsZW5ndGggKiBNYXRoLnNpbih0aW1lKSwgY2VudGVyWSk7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JlZCc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIFkgYXhpcyAoZ3JlZW4pXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgY3R4LmxpbmVUbyhjZW50ZXJYLCBjZW50ZXJZICsgbGVuZ3RoICogTWF0aC5zaW4odGltZSArIDEpKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBaIGF4aXMgKGJsdWUpXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oY2VudGVyWCwgY2VudGVyWSk7XG4gICAgY3R4LmxpbmVUbyhcbiAgICAgIGNlbnRlclggKyBsZW5ndGgvMiAqIE1hdGguc2luKHRpbWUgKyAyKSwgXG4gICAgICBjZW50ZXJZIC0gbGVuZ3RoLzIgKiBNYXRoLmNvcyh0aW1lICsgMilcbiAgICApO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH07XG4gIFxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZHJhdyBmYWNlIG1hc2tcbiAgY29uc3QgZHJhd0ZhY2VNYXNrID0gKGN0eCwgY2FudmFzLCBwb2ludHMpID0+IHtcbiAgICBjb25zdCBjZW50ZXJYID0gY2FudmFzLndpZHRoIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gY2FudmFzLmhlaWdodCAvIDI7XG4gICAgY29uc3QgcmFkaXVzID0gTWF0aC5taW4oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KSAqIDAuMjtcbiAgICBcbiAgICAvLyBEcmF3IG1hc2tcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwgMjU1LCAyNTUsIDAuMiknO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gRHJhdyBleWVzXG4gICAgY29uc3QgZXllUmFkaXVzID0gcmFkaXVzICogMC4yO1xuICAgIGNvbnN0IGV5ZU9mZnNldFggPSByYWRpdXMgKiAwLjM7XG4gICAgY29uc3QgZXllT2Zmc2V0WSA9IHJhZGl1cyAqIDAuMTtcbiAgICBcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KSc7XG4gICAgXG4gICAgLy8gTGVmdCBleWVcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyhjZW50ZXJYIC0gZXllT2Zmc2V0WCwgY2VudGVyWSAtIGV5ZU9mZnNldFksIGV5ZVJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gUmlnaHQgZXllXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoY2VudGVyWCArIGV5ZU9mZnNldFgsIGNlbnRlclkgLSBleWVPZmZzZXRZLCBleWVSYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbCgpO1xuICB9O1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGRyYXcgcGFyYW1ldGVyc1xuICBjb25zdCBkcmF3UGFyYW1ldGVycyA9IChjdHgsIGNhbnZhcywgZmFjZURldGVjdGVkKSA9PiB7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuNyknO1xuICAgIGN0eC5maWxsUmVjdCg1LCBjYW52YXMuaGVpZ2h0IC0gNjAsIDE1MCwgNTApO1xuICAgIFxuICAgIGN0eC5mb250ID0gJzEycHggQXJpYWwnO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsVGV4dChgUmVzb2x1dGlvbjogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gLCAxMCwgY2FudmFzLmhlaWdodCAtIDQwKTtcbiAgICBjdHguZmlsbFRleHQoYEZQUzogJHtmcHN9YCwgMTAsIGNhbnZhcy5oZWlnaHQgLSAyNSk7XG4gICAgY3R4LmZpbGxUZXh0KGBGYWNlOiAke2ZhY2VEZXRlY3RlZCA/ICdEZXRlY3RlZCcgOiAnTm90IERldGVjdGVkJ31gLCAxMCwgY2FudmFzLmhlaWdodCAtIDEwKTtcbiAgfTtcblxuICBpZiAoIWlzU2hvd2luZykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IFxuICAgICAgcmVmPXtjb250YWluZXJSZWZ9XG4gICAgICBzdHlsZT17eyBcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxuICAgICAgICB3aWR0aDogJzMwdncnLCAvLyAzMCUgb2Ygdmlld3BvcnQgd2lkdGhcbiAgICAgICAgaGVpZ2h0OiAnMzB2aCcsIC8vIDMwJSBvZiB2aWV3cG9ydCBoZWlnaHRcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc4cHgnLFxuICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJyxcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB6SW5kZXg6IDEwMDBcbiAgICAgIH19XG4gICAgPlxuICAgICAgPHZpZGVvXG4gICAgICAgIHJlZj17dmlkZW9SZWZ9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICBvYmplY3RGaXQ6ICdjb3ZlcicsXG4gICAgICAgICAgdHJhbnNmb3JtOiAnc2NhbGVYKC0xKScsIC8vIEZsaXAgaG9yaXpvbnRhbGx5XG4gICAgICAgICAgb3BhY2l0eTogMCAvLyBLZWVwIHZpZGVvIGhpZGRlbiBidXQgZnVuY3Rpb25hbFxuICAgICAgICB9fVxuICAgICAgICBwbGF5c0lubGluZVxuICAgICAgICBtdXRlZFxuICAgICAgICBhdXRvUGxheVxuICAgICAgLz5cbiAgICAgIDxjYW52YXNcbiAgICAgICAgcmVmPXtjYW52YXNSZWZ9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgICA8YnV0dG9uXG4gICAgICAgIG9uQ2xpY2s9e29uQ2xvc2V9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAnMTBweCcsXG4gICAgICAgICAgcmlnaHQ6ICcxMHB4JyxcbiAgICAgICAgICBwYWRkaW5nOiAnOHB4IDEycHgnLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICB6SW5kZXg6IDJcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgQ2xvc2VcbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgQ2FtZXJhQWNjZXNzOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cyIsIkNhbWVyYUFjY2VzcyIsImlzU2hvd2luZyIsIm9uQ2xvc2UiLCJvbkNhbWVyYVJlYWR5Iiwic2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzaG93UGFyYW1ldGVycyIsInZpZGVvUmVmIiwiY2FudmFzUmVmIiwiY29udGFpbmVyUmVmIiwid3NSZWYiLCJzdHJlYW0iLCJzZXRTdHJlYW0iLCJlcnJvck1lc3NhZ2UiLCJzZXRFcnJvck1lc3NhZ2UiLCJmcHMiLCJzZXRGcHMiLCJmcHNUaW1lclJlZiIsInByb2Nlc3NpbmdJbnRlcnZhbCIsImRpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJpc1ZpZGVvUmVhZHkiLCJzZXRJc1ZpZGVvUmVhZHkiLCJwcm9jZXNzaW5nUmVzdWx0cyIsInNldFByb2Nlc3NpbmdSZXN1bHRzIiwiZnJhbWVRdWV1ZSIsImlzUHJvY2Vzc2luZyIsIndzIiwiV2ViU29ja2V0IiwiY3VycmVudCIsIm9ub3BlbiIsImNvbnNvbGUiLCJsb2ciLCJvbm1lc3NhZ2UiLCJldmVudCIsInJlc3VsdCIsIkpTT04iLCJwYXJzZSIsImRhdGEiLCJkcmF3UmVzdWx0cyIsImVycm9yIiwib25lcnJvciIsIm9uY2xvc2UiLCJjbG9zZSIsImNhcHR1cmVBbmRQcm9jZXNzRnJhbWUiLCJ2aWRlbyIsImNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJzYXZlIiwidHJhbnNsYXRlIiwic2NhbGUiLCJkcmF3SW1hZ2UiLCJyZXN0b3JlIiwidG9CbG9iIiwiYmxvYiIsInJlYWR5U3RhdGUiLCJPUEVOIiwic2VuZCIsInJlc3VsdHMiLCJib3VuZGluZ19ib3giLCJ4IiwieSIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlUmVjdCIsImhlYWRfcG9zZSIsInBpdGNoIiwieWF3Iiwicm9sbCIsImRyYXdIZWFkUG9zZSIsImZhY2VfbWFzayIsInBvaW50cyIsImRyYXdGYWNlTWFzayIsImRyYXdQYXJhbWV0ZXJzIiwic3RhcnRDYW1lcmEiLCJjb25zdHJhaW50cyIsIm1lZGlhU3RyZWFtIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwiYXVkaW8iLCJwbGF5c0lubGluZSIsIm11dGVkIiwiYXV0b3BsYXkiLCJzcmNPYmplY3QiLCJwbGF5Iiwic2V0SW50ZXJ2YWwiLCJwbGF5RXJyb3IiLCJtZXNzYWdlIiwic3RvcENhbWVyYSIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJjbGVhckludGVydmFsIiwicHJldkZwcyIsIm5ld0ZwcyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsInVwZGF0ZURpbWVuc2lvbnMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZUxvYWRlZE1ldGFkYXRhIiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJjb250YWluZXJXaWR0aCIsImNvbnRhaW5lckhlaWdodCIsInN0eWxlIiwic3RhcnRQcm9jZXNzaW5nIiwiZmFjZURldGVjdGVkIiwiZHJhd0JvdW5kaW5nQm94IiwiY2VudGVyWCIsImNlbnRlclkiLCJib3hXaWR0aCIsImJveEhlaWdodCIsInRpbWUiLCJEYXRlIiwibm93IiwibGVuZ3RoIiwiYmVnaW5QYXRoIiwibW92ZVRvIiwibGluZVRvIiwic2luIiwic3Ryb2tlIiwiY29zIiwicmFkaXVzIiwibWluIiwiZmlsbFN0eWxlIiwiYXJjIiwiUEkiLCJmaWxsIiwiZXllUmFkaXVzIiwiZXllT2Zmc2V0WCIsImV5ZU9mZnNldFkiLCJmaWxsUmVjdCIsImZvbnQiLCJmaWxsVGV4dCIsImRpdiIsInJlZiIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInRyYW5zZm9ybSIsImJhY2tncm91bmRDb2xvciIsImJvcmRlclJhZGl1cyIsImJveFNoYWRvdyIsIm92ZXJmbG93IiwiekluZGV4Iiwib2JqZWN0Rml0Iiwib3BhY2l0eSIsImF1dG9QbGF5IiwiYnV0dG9uIiwib25DbGljayIsInJpZ2h0IiwicGFkZGluZyIsImNvbG9yIiwiYm9yZGVyIiwiY3Vyc29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset/components-gui/cameraAccess.js\n"));

/***/ })

}]);