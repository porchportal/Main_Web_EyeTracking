"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_pages_collected-dataset-customized_components-gui_VideoProcessorComponent_js"],{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/VideoProcessorComponent.js":
/*!**************************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/VideoProcessorComponent.js ***!
  \**************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _videoProcessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./videoProcessor */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/videoProcessor.js\");\n// components-gui/VideoProcessorComponent.js\nvar _s = $RefreshSig$();\n\n\nconst VideoProcessorComponent = ()=>{\n    _s();\n    const processor = (0,_videoProcessor__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"VideoProcessorComponent.useEffect\": ()=>{\n            if (processor) {\n                window.videoProcessor = processor;\n            }\n        }\n    }[\"VideoProcessorComponent.useEffect\"], [\n        processor\n    ]);\n    return null;\n};\n_s(VideoProcessorComponent, \"4qTwpRhcYgUZuXAoa/25We3ueMo=\", false, function() {\n    return [\n        _videoProcessor__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n    ];\n});\n_c = VideoProcessorComponent;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VideoProcessorComponent);\nvar _c;\n$RefreshReg$(_c, \"VideoProcessorComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvVmlkZW9Qcm9jZXNzb3JDb21wb25lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLDRDQUE0Qzs7QUFDSDtBQUNRO0FBRWpELE1BQU1HLDBCQUEwQjs7SUFDOUIsTUFBTUMsWUFBWUYsMkRBQWlCQTtJQUVuQ0QsZ0RBQVNBOzZDQUFDO1lBQ1IsSUFBSUcsV0FBVztnQkFDYkMsT0FBT0MsY0FBYyxHQUFHRjtZQUMxQjtRQUNGOzRDQUFHO1FBQUNBO0tBQVU7SUFFZCxPQUFPO0FBQ1Q7R0FWTUQ7O1FBQ2NELHVEQUFpQkE7OztLQUQvQkM7QUFZTixpRUFBZUEsdUJBQXVCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9WaWRlb1Byb2Nlc3NvckNvbXBvbmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21wb25lbnRzLWd1aS9WaWRlb1Byb2Nlc3NvckNvbXBvbmVudC5qc1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VWaWRlb1Byb2Nlc3NvciBmcm9tICcuL3ZpZGVvUHJvY2Vzc29yJztcblxuY29uc3QgVmlkZW9Qcm9jZXNzb3JDb21wb25lbnQgPSAoKSA9PiB7XG4gIGNvbnN0IHByb2Nlc3NvciA9IHVzZVZpZGVvUHJvY2Vzc29yKCk7XG4gIFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICB9XG4gIH0sIFtwcm9jZXNzb3JdKTtcbiAgXG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVmlkZW9Qcm9jZXNzb3JDb21wb25lbnQ7Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwidXNlVmlkZW9Qcm9jZXNzb3IiLCJWaWRlb1Byb2Nlc3NvckNvbXBvbmVudCIsInByb2Nlc3NvciIsIndpbmRvdyIsInZpZGVvUHJvY2Vzc29yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/VideoProcessorComponent.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/videoProcessor.js":
/*!*****************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/videoProcessor.js ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// videoProcessor.js\nvar _s = $RefreshSig$();\n\nconst useVideoProcessor = ()=>{\n    _s();\n    const [isProcessing, setIsProcessing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [processingResults, setProcessingResults] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [processingError, setProcessingError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [backendAvailable, setBackendAvailable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const streamRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const processingIntervalRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const [options, setOptions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        showHeadPose: false,\n        showBoundingBox: false,\n        showMask: false,\n        showParameters: false,\n        showProcessedImage: false\n    });\n    // Check backend connection on mount\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useVideoProcessor.useEffect\": ()=>{\n            const checkBackendConnection = {\n                \"useVideoProcessor.useEffect.checkBackendConnection\": async ()=>{\n                    try {\n                        const response = await fetch('/api/check-backend-connection');\n                        const data = await response.json();\n                        setBackendAvailable(data.connected);\n                        console.log(\"Backend connection: \".concat(data.connected ? 'OK' : 'Failed'));\n                    } catch (error) {\n                        console.error('Error checking backend connection:', error);\n                        setBackendAvailable(false);\n                    }\n                }\n            }[\"useVideoProcessor.useEffect.checkBackendConnection\"];\n            checkBackendConnection();\n        }\n    }[\"useVideoProcessor.useEffect\"], []);\n    /**\n   * Start video processing with backend\n   */ const startVideoProcessing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useVideoProcessor.useCallback[startVideoProcessing]\": async function() {\n            let newOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            if (isProcessing) {\n                // If already processing, just update options\n                updateOptions(newOptions);\n                return;\n            }\n            setProcessingError(null);\n            // Update options\n            updateOptions(newOptions);\n            try {\n                // Request camera access\n                const mediaStream = await navigator.mediaDevices.getUserMedia({\n                    video: true,\n                    audio: false\n                });\n                // Store stream for later cleanup\n                streamRef.current = mediaStream;\n                // If we have a video element reference, attach the stream\n                if (videoRef.current) {\n                    videoRef.current.srcObject = mediaStream;\n                    try {\n                        await videoRef.current.play();\n                        console.log('Video playing successfully');\n                    } catch (playError) {\n                        console.error('Error playing video:', playError);\n                        setProcessingError(\"Failed to play video: \".concat(playError.message));\n                        stopVideoProcessing();\n                        return;\n                    }\n                }\n                setIsProcessing(true);\n                // Start the frame processing interval\n                processingIntervalRef.current = setInterval({\n                    \"useVideoProcessor.useCallback[startVideoProcessing]\": ()=>{\n                        processCurrentFrame();\n                    }\n                }[\"useVideoProcessor.useCallback[startVideoProcessing]\"], 200); // Process a frame every 200ms (5fps) to reduce server load\n            } catch (error) {\n                console.error('Error starting video processing:', error);\n                setProcessingError(\"Failed to access camera: \".concat(error.message));\n                stopVideoProcessing();\n            }\n        }\n    }[\"useVideoProcessor.useCallback[startVideoProcessing]\"], [\n        isProcessing\n    ]);\n    /**\n   * Update processing options\n   */ const updateOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useVideoProcessor.useCallback[updateOptions]\": function() {\n            let newOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            setOptions({\n                \"useVideoProcessor.useCallback[updateOptions]\": (prevOptions)=>{\n                    const updatedOptions = {\n                        ...prevOptions,\n                        ...newOptions\n                    };\n                    // If we're already processing, update the backend with new options on next frame\n                    if (isProcessing) {\n                        // We don't need to call processCurrentFrame explicitly here\n                        // since it's handled by the interval\n                        console.log('Options updated, will be applied on next frame:', updatedOptions);\n                    }\n                    return updatedOptions;\n                }\n            }[\"useVideoProcessor.useCallback[updateOptions]\"]);\n        }\n    }[\"useVideoProcessor.useCallback[updateOptions]\"], [\n        isProcessing\n    ]);\n    /**\n   * Stop video processing\n   */ const stopVideoProcessing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useVideoProcessor.useCallback[stopVideoProcessing]\": ()=>{\n            // Clear the processing interval\n            if (processingIntervalRef.current) {\n                clearInterval(processingIntervalRef.current);\n                processingIntervalRef.current = null;\n            }\n            // Stop all tracks in the media stream\n            if (streamRef.current) {\n                streamRef.current.getTracks().forEach({\n                    \"useVideoProcessor.useCallback[stopVideoProcessing]\": (track)=>{\n                        track.stop();\n                    }\n                }[\"useVideoProcessor.useCallback[stopVideoProcessing]\"]);\n                streamRef.current = null;\n            }\n            // Clear video source\n            if (videoRef.current) {\n                videoRef.current.srcObject = null;\n            }\n            setIsProcessing(false);\n            setProcessingResults(null);\n        }\n    }[\"useVideoProcessor.useCallback[stopVideoProcessing]\"], []);\n    /**\n   * Toggle video processing\n   */ const toggleVideoProcessing = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useVideoProcessor.useCallback[toggleVideoProcessing]\": function() {\n            let newOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            if (isProcessing) {\n                stopVideoProcessing();\n            } else {\n                startVideoProcessing(newOptions);\n            }\n        }\n    }[\"useVideoProcessor.useCallback[toggleVideoProcessing]\"], [\n        isProcessing,\n        startVideoProcessing,\n        stopVideoProcessing\n    ]);\n    /**\n   * Process the current video frame\n   */ const processCurrentFrame = async ()=>{\n        if (!videoRef.current || !streamRef.current || !isProcessing) return;\n        try {\n            // Create a canvas to capture the current frame\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            // Set canvas size to match video dimensions\n            canvas.width = videoRef.current.videoWidth;\n            canvas.height = videoRef.current.videoHeight;\n            // Draw the current video frame to the canvas\n            context.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);\n            // Convert canvas to blob (JPEG format with 0.8 quality)\n            const blob = await new Promise((resolve)=>{\n                canvas.toBlob(resolve, 'image/jpeg', 0.8);\n            });\n            if (!blob) {\n                console.error('Failed to capture frame');\n                return;\n            }\n            // Create form data for the API request\n            const formData = new FormData();\n            formData.append('file', blob, 'frame.jpg');\n            // Add processing options - explicitly convert booleans to strings\n            // This is important for proper transmission to the backend\n            formData.append('showHeadPose', options.showHeadPose.toString());\n            formData.append('showBoundingBox', options.showBoundingBox.toString());\n            formData.append('showMask', options.showMask.toString());\n            formData.append('showParameters', options.showParameters.toString());\n            // Log what's being sent to the backend for debugging\n            console.log('Sending options to backend:', {\n                showHeadPose: options.showHeadPose,\n                showBoundingBox: options.showBoundingBox,\n                showMask: options.showMask,\n                showParameters: options.showParameters\n            });\n            // Send to backend API\n            const response = await fetch('/api/process-frame', {\n                method: 'POST',\n                body: formData\n            });\n            if (!response.ok) {\n                throw new Error(\"Server error: \".concat(response.status));\n            }\n            const result = await response.json();\n            if (result.success) {\n                setProcessingResults(result);\n                // If we have a processed image, display it\n                if (result.image && options.showProcessedImage && canvasRef.current) {\n                    displayProcessedImage(result.image, canvasRef.current);\n                }\n                return result;\n            } else {\n                console.error('Processing failed:', result.error);\n                return null;\n            }\n        } catch (error) {\n            console.error('Error processing frame:', error);\n            setProcessingError(\"Processing error: \".concat(error.message));\n            return null;\n        }\n    };\n    /**\n   * Display the processed image in a canvas element\n   */ const displayProcessedImage = (base64Image, canvas)=>{\n        if (!canvas || !base64Image) return;\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n        img.onload = ()=>{\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n        };\n        img.src = \"data:image/jpeg;base64,\".concat(base64Image);\n    };\n    return {\n        isProcessing,\n        processingResults,\n        processingError,\n        backendAvailable,\n        videoRef,\n        canvasRef,\n        options,\n        startVideoProcessing,\n        stopVideoProcessing,\n        toggleVideoProcessing,\n        updateOptions,\n        processCurrentFrame\n    };\n};\n_s(useVideoProcessor, \"u2MWV/hjU38QNWSIC9RLKH4xC+c=\");\n// Make sure to export the hook as default\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useVideoProcessor);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvdmlkZW9Qcm9jZXNzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0JBQW9COztBQUM2QztBQUVqRSxNQUFNSSxvQkFBb0I7O0lBQ3hCLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUdOLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ08sbUJBQW1CQyxxQkFBcUIsR0FBR1IsK0NBQVFBLENBQUM7SUFDM0QsTUFBTSxDQUFDUyxpQkFBaUJDLG1CQUFtQixHQUFHViwrQ0FBUUEsQ0FBQztJQUN2RCxNQUFNLENBQUNXLGtCQUFrQkMsb0JBQW9CLEdBQUdaLCtDQUFRQSxDQUFDO0lBQ3pELE1BQU1hLFdBQVdaLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU1hLFlBQVliLDZDQUFNQSxDQUFDO0lBQ3pCLE1BQU1jLHdCQUF3QmQsNkNBQU1BLENBQUM7SUFDckMsTUFBTWUsWUFBWWYsNkNBQU1BLENBQUM7SUFDekIsTUFBTSxDQUFDZ0IsU0FBU0MsV0FBVyxHQUFHbEIsK0NBQVFBLENBQUM7UUFDckNtQixjQUFjO1FBQ2RDLGlCQUFpQjtRQUNqQkMsVUFBVTtRQUNWQyxnQkFBZ0I7UUFDaEJDLG9CQUFvQjtJQUN0QjtJQUVBLG9DQUFvQztJQUNwQ3BCLGdEQUFTQTt1Q0FBQztZQUNSLE1BQU1xQjtzRUFBeUI7b0JBQzdCLElBQUk7d0JBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNO3dCQUM3QixNQUFNQyxPQUFPLE1BQU1GLFNBQVNHLElBQUk7d0JBQ2hDaEIsb0JBQW9CZSxLQUFLRSxTQUFTO3dCQUNsQ0MsUUFBUUMsR0FBRyxDQUFDLHVCQUF3RCxPQUFqQ0osS0FBS0UsU0FBUyxHQUFHLE9BQU87b0JBQzdELEVBQUUsT0FBT0csT0FBTzt3QkFDZEYsUUFBUUUsS0FBSyxDQUFDLHNDQUFzQ0E7d0JBQ3BEcEIsb0JBQW9CO29CQUN0Qjtn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SyxFQUFFTCxPQUFPTyxNQUFNO1FBQ3REO1FBRUFzQixJQUFJSSxHQUFHLEdBQUcsMEJBQXNDLE9BQVpOO0lBQ3RDO0lBRUEsT0FBTztRQUNMaEY7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUc7UUFDQUM7UUFDQWdCO1FBQ0FjO1FBQ0FVO1FBQ0F0QjtRQUNBYztJQUNGO0FBQ0Y7R0FqUU03QztBQW1RTiwwQ0FBMEM7QUFDMUMsaUVBQWVBLGlCQUFpQkEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvdmlkZW9Qcm9jZXNzb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmlkZW9Qcm9jZXNzb3IuanNcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IHVzZVZpZGVvUHJvY2Vzc29yID0gKCkgPT4ge1xuICBjb25zdCBbaXNQcm9jZXNzaW5nLCBzZXRJc1Byb2Nlc3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcHJvY2Vzc2luZ1Jlc3VsdHMsIHNldFByb2Nlc3NpbmdSZXN1bHRzXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcHJvY2Vzc2luZ0Vycm9yLCBzZXRQcm9jZXNzaW5nRXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtiYWNrZW5kQXZhaWxhYmxlLCBzZXRCYWNrZW5kQXZhaWxhYmxlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3Qgc3RyZWFtUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBwcm9jZXNzaW5nSW50ZXJ2YWxSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IGNhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgW29wdGlvbnMsIHNldE9wdGlvbnNdID0gdXNlU3RhdGUoe1xuICAgIHNob3dIZWFkUG9zZTogZmFsc2UsXG4gICAgc2hvd0JvdW5kaW5nQm94OiBmYWxzZSxcbiAgICBzaG93TWFzazogZmFsc2UsXG4gICAgc2hvd1BhcmFtZXRlcnM6IGZhbHNlLFxuICAgIHNob3dQcm9jZXNzZWRJbWFnZTogZmFsc2VcbiAgfSk7XG4gIFxuICAvLyBDaGVjayBiYWNrZW5kIGNvbm5lY3Rpb24gb24gbW91bnRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBjaGVja0JhY2tlbmRDb25uZWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9jaGVjay1iYWNrZW5kLWNvbm5lY3Rpb24nKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgc2V0QmFja2VuZEF2YWlsYWJsZShkYXRhLmNvbm5lY3RlZCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBCYWNrZW5kIGNvbm5lY3Rpb246ICR7ZGF0YS5jb25uZWN0ZWQgPyAnT0snIDogJ0ZhaWxlZCd9YCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBiYWNrZW5kIGNvbm5lY3Rpb246JywgZXJyb3IpO1xuICAgICAgICBzZXRCYWNrZW5kQXZhaWxhYmxlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY2hlY2tCYWNrZW5kQ29ubmVjdGlvbigpO1xuICB9LCBbXSk7XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHZpZGVvIHByb2Nlc3Npbmcgd2l0aCBiYWNrZW5kXG4gICAqL1xuICBjb25zdCBzdGFydFZpZGVvUHJvY2Vzc2luZyA9IHVzZUNhbGxiYWNrKGFzeW5jIChuZXdPcHRpb25zID0ge30pID0+IHtcbiAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAvLyBJZiBhbHJlYWR5IHByb2Nlc3NpbmcsIGp1c3QgdXBkYXRlIG9wdGlvbnNcbiAgICAgIHVwZGF0ZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldFByb2Nlc3NpbmdFcnJvcihudWxsKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgb3B0aW9uc1xuICAgIHVwZGF0ZU9wdGlvbnMobmV3T3B0aW9ucyk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlcXVlc3QgY2FtZXJhIGFjY2Vzc1xuICAgICAgY29uc3QgbWVkaWFTdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhdWRpbzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTdG9yZSBzdHJlYW0gZm9yIGxhdGVyIGNsZWFudXBcbiAgICAgIHN0cmVhbVJlZi5jdXJyZW50ID0gbWVkaWFTdHJlYW07XG4gICAgICBcbiAgICAgIC8vIElmIHdlIGhhdmUgYSB2aWRlbyBlbGVtZW50IHJlZmVyZW5jZSwgYXR0YWNoIHRoZSBzdHJlYW1cbiAgICAgIGlmICh2aWRlb1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHZpZGVvUmVmLmN1cnJlbnQucGxheSgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdWaWRlbyBwbGF5aW5nIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9IGNhdGNoIChwbGF5RXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwbGF5aW5nIHZpZGVvOicsIHBsYXlFcnJvcik7XG4gICAgICAgICAgc2V0UHJvY2Vzc2luZ0Vycm9yKGBGYWlsZWQgdG8gcGxheSB2aWRlbzogJHtwbGF5RXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICBzdG9wVmlkZW9Qcm9jZXNzaW5nKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgdGhlIGZyYW1lIHByb2Nlc3NpbmcgaW50ZXJ2YWxcbiAgICAgIHByb2Nlc3NpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBwcm9jZXNzQ3VycmVudEZyYW1lKCk7XG4gICAgICB9LCAyMDApOyAvLyBQcm9jZXNzIGEgZnJhbWUgZXZlcnkgMjAwbXMgKDVmcHMpIHRvIHJlZHVjZSBzZXJ2ZXIgbG9hZFxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN0YXJ0aW5nIHZpZGVvIHByb2Nlc3Npbmc6JywgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc2luZ0Vycm9yKGBGYWlsZWQgdG8gYWNjZXNzIGNhbWVyYTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgc3RvcFZpZGVvUHJvY2Vzc2luZygpO1xuICAgIH1cbiAgfSwgW2lzUHJvY2Vzc2luZ10pO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgcHJvY2Vzc2luZyBvcHRpb25zXG4gICAqL1xuICBjb25zdCB1cGRhdGVPcHRpb25zID0gdXNlQ2FsbGJhY2soKG5ld09wdGlvbnMgPSB7fSkgPT4ge1xuICAgIHNldE9wdGlvbnMocHJldk9wdGlvbnMgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlZE9wdGlvbnMgPSB7XG4gICAgICAgIC4uLnByZXZPcHRpb25zLFxuICAgICAgICAuLi5uZXdPcHRpb25zXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHByb2Nlc3NpbmcsIHVwZGF0ZSB0aGUgYmFja2VuZCB3aXRoIG5ldyBvcHRpb25zIG9uIG5leHQgZnJhbWVcbiAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjYWxsIHByb2Nlc3NDdXJyZW50RnJhbWUgZXhwbGljaXRseSBoZXJlXG4gICAgICAgIC8vIHNpbmNlIGl0J3MgaGFuZGxlZCBieSB0aGUgaW50ZXJ2YWxcbiAgICAgICAgY29uc29sZS5sb2coJ09wdGlvbnMgdXBkYXRlZCwgd2lsbCBiZSBhcHBsaWVkIG9uIG5leHQgZnJhbWU6JywgdXBkYXRlZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdXBkYXRlZE9wdGlvbnM7XG4gICAgfSk7XG4gIH0sIFtpc1Byb2Nlc3NpbmddKTtcblxuICAvKipcbiAgICogU3RvcCB2aWRlbyBwcm9jZXNzaW5nXG4gICAqL1xuICBjb25zdCBzdG9wVmlkZW9Qcm9jZXNzaW5nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIC8vIENsZWFyIHRoZSBwcm9jZXNzaW5nIGludGVydmFsXG4gICAgaWYgKHByb2Nlc3NpbmdJbnRlcnZhbFJlZi5jdXJyZW50KSB7XG4gICAgICBjbGVhckludGVydmFsKHByb2Nlc3NpbmdJbnRlcnZhbFJlZi5jdXJyZW50KTtcbiAgICAgIHByb2Nlc3NpbmdJbnRlcnZhbFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gU3RvcCBhbGwgdHJhY2tzIGluIHRoZSBtZWRpYSBzdHJlYW1cbiAgICBpZiAoc3RyZWFtUmVmLmN1cnJlbnQpIHtcbiAgICAgIHN0cmVhbVJlZi5jdXJyZW50LmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9KTtcbiAgICAgIHN0cmVhbVJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgdmlkZW8gc291cmNlXG4gICAgaWYgKHZpZGVvUmVmLmN1cnJlbnQpIHtcbiAgICAgIHZpZGVvUmVmLmN1cnJlbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICBzZXRQcm9jZXNzaW5nUmVzdWx0cyhudWxsKTtcbiAgfSwgW10pO1xuXG4gIC8qKlxuICAgKiBUb2dnbGUgdmlkZW8gcHJvY2Vzc2luZ1xuICAgKi9cbiAgY29uc3QgdG9nZ2xlVmlkZW9Qcm9jZXNzaW5nID0gdXNlQ2FsbGJhY2soKG5ld09wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmIChpc1Byb2Nlc3NpbmcpIHtcbiAgICAgIHN0b3BWaWRlb1Byb2Nlc3NpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRWaWRlb1Byb2Nlc3NpbmcobmV3T3B0aW9ucyk7XG4gICAgfVxuICB9LCBbaXNQcm9jZXNzaW5nLCBzdGFydFZpZGVvUHJvY2Vzc2luZywgc3RvcFZpZGVvUHJvY2Vzc2luZ10pO1xuXG4gIC8qKlxuICAgKiBQcm9jZXNzIHRoZSBjdXJyZW50IHZpZGVvIGZyYW1lXG4gICAqL1xuICBjb25zdCBwcm9jZXNzQ3VycmVudEZyYW1lID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdmlkZW9SZWYuY3VycmVudCB8fCAhc3RyZWFtUmVmLmN1cnJlbnQgfHwgIWlzUHJvY2Vzc2luZykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDcmVhdGUgYSBjYW52YXMgdG8gY2FwdHVyZSB0aGUgY3VycmVudCBmcmFtZVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIC8vIFNldCBjYW52YXMgc2l6ZSB0byBtYXRjaCB2aWRlbyBkaW1lbnNpb25zXG4gICAgICBjYW52YXMud2lkdGggPSB2aWRlb1JlZi5jdXJyZW50LnZpZGVvV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW9SZWYuY3VycmVudC52aWRlb0hlaWdodDtcbiAgICAgIFxuICAgICAgLy8gRHJhdyB0aGUgY3VycmVudCB2aWRlbyBmcmFtZSB0byB0aGUgY2FudmFzXG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSh2aWRlb1JlZi5jdXJyZW50LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IGNhbnZhcyB0byBibG9iIChKUEVHIGZvcm1hdCB3aXRoIDAuOCBxdWFsaXR5KVxuICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjYW52YXMudG9CbG9iKHJlc29sdmUsICdpbWFnZS9qcGVnJywgMC44KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIWJsb2IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNhcHR1cmUgZnJhbWUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgZm9ybSBkYXRhIGZvciB0aGUgQVBJIHJlcXVlc3RcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCAnZnJhbWUuanBnJyk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBwcm9jZXNzaW5nIG9wdGlvbnMgLSBleHBsaWNpdGx5IGNvbnZlcnQgYm9vbGVhbnMgdG8gc3RyaW5nc1xuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHByb3BlciB0cmFuc21pc3Npb24gdG8gdGhlIGJhY2tlbmRcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd0hlYWRQb3NlJywgb3B0aW9ucy5zaG93SGVhZFBvc2UudG9TdHJpbmcoKSk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dCb3VuZGluZ0JveCcsIG9wdGlvbnMuc2hvd0JvdW5kaW5nQm94LnRvU3RyaW5nKCkpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdzaG93TWFzaycsIG9wdGlvbnMuc2hvd01hc2sudG9TdHJpbmcoKSk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dQYXJhbWV0ZXJzJywgb3B0aW9ucy5zaG93UGFyYW1ldGVycy50b1N0cmluZygpKTtcbiAgICAgIFxuICAgICAgLy8gTG9nIHdoYXQncyBiZWluZyBzZW50IHRvIHRoZSBiYWNrZW5kIGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUubG9nKCdTZW5kaW5nIG9wdGlvbnMgdG8gYmFja2VuZDonLCB7XG4gICAgICAgIHNob3dIZWFkUG9zZTogb3B0aW9ucy5zaG93SGVhZFBvc2UsXG4gICAgICAgIHNob3dCb3VuZGluZ0JveDogb3B0aW9ucy5zaG93Qm91bmRpbmdCb3gsXG4gICAgICAgIHNob3dNYXNrOiBvcHRpb25zLnNob3dNYXNrLFxuICAgICAgICBzaG93UGFyYW1ldGVyczogb3B0aW9ucy5zaG93UGFyYW1ldGVyc1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNlbmQgdG8gYmFja2VuZCBBUElcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcHJvY2Vzcy1mcmFtZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGJvZHk6IGZvcm1EYXRhXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHNldFByb2Nlc3NpbmdSZXN1bHRzKHJlc3VsdCk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJvY2Vzc2VkIGltYWdlLCBkaXNwbGF5IGl0XG4gICAgICAgIGlmIChyZXN1bHQuaW1hZ2UgJiYgb3B0aW9ucy5zaG93UHJvY2Vzc2VkSW1hZ2UgJiYgY2FudmFzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBkaXNwbGF5UHJvY2Vzc2VkSW1hZ2UocmVzdWx0LmltYWdlLCBjYW52YXNSZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9jZXNzaW5nIGZhaWxlZDonLCByZXN1bHQuZXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcHJvY2Vzc2luZyBmcmFtZTonLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzaW5nRXJyb3IoYFByb2Nlc3NpbmcgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRGlzcGxheSB0aGUgcHJvY2Vzc2VkIGltYWdlIGluIGEgY2FudmFzIGVsZW1lbnRcbiAgICovXG4gIGNvbnN0IGRpc3BsYXlQcm9jZXNzZWRJbWFnZSA9IChiYXNlNjRJbWFnZSwgY2FudmFzKSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIWJhc2U2NEltYWdlKSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IGBkYXRhOmltYWdlL2pwZWc7YmFzZTY0LCR7YmFzZTY0SW1hZ2V9YDtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGlzUHJvY2Vzc2luZyxcbiAgICBwcm9jZXNzaW5nUmVzdWx0cyxcbiAgICBwcm9jZXNzaW5nRXJyb3IsXG4gICAgYmFja2VuZEF2YWlsYWJsZSxcbiAgICB2aWRlb1JlZixcbiAgICBjYW52YXNSZWYsXG4gICAgb3B0aW9ucyxcbiAgICBzdGFydFZpZGVvUHJvY2Vzc2luZyxcbiAgICBzdG9wVmlkZW9Qcm9jZXNzaW5nLFxuICAgIHRvZ2dsZVZpZGVvUHJvY2Vzc2luZyxcbiAgICB1cGRhdGVPcHRpb25zLFxuICAgIHByb2Nlc3NDdXJyZW50RnJhbWVcbiAgfTtcbn07XG5cbi8vIE1ha2Ugc3VyZSB0byBleHBvcnQgdGhlIGhvb2sgYXMgZGVmYXVsdFxuZXhwb3J0IGRlZmF1bHQgdXNlVmlkZW9Qcm9jZXNzb3I7Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VWaWRlb1Byb2Nlc3NvciIsImlzUHJvY2Vzc2luZyIsInNldElzUHJvY2Vzc2luZyIsInByb2Nlc3NpbmdSZXN1bHRzIiwic2V0UHJvY2Vzc2luZ1Jlc3VsdHMiLCJwcm9jZXNzaW5nRXJyb3IiLCJzZXRQcm9jZXNzaW5nRXJyb3IiLCJiYWNrZW5kQXZhaWxhYmxlIiwic2V0QmFja2VuZEF2YWlsYWJsZSIsInZpZGVvUmVmIiwic3RyZWFtUmVmIiwicHJvY2Vzc2luZ0ludGVydmFsUmVmIiwiY2FudmFzUmVmIiwib3B0aW9ucyIsInNldE9wdGlvbnMiLCJzaG93SGVhZFBvc2UiLCJzaG93Qm91bmRpbmdCb3giLCJzaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2hvd1Byb2Nlc3NlZEltYWdlIiwiY2hlY2tCYWNrZW5kQ29ubmVjdGlvbiIsInJlc3BvbnNlIiwiZmV0Y2giLCJkYXRhIiwianNvbiIsImNvbm5lY3RlZCIsImNvbnNvbGUiLCJsb2ciLCJlcnJvciIsInN0YXJ0VmlkZW9Qcm9jZXNzaW5nIiwibmV3T3B0aW9ucyIsInVwZGF0ZU9wdGlvbnMiLCJtZWRpYVN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJjdXJyZW50Iiwic3JjT2JqZWN0IiwicGxheSIsInBsYXlFcnJvciIsIm1lc3NhZ2UiLCJzdG9wVmlkZW9Qcm9jZXNzaW5nIiwic2V0SW50ZXJ2YWwiLCJwcm9jZXNzQ3VycmVudEZyYW1lIiwicHJldk9wdGlvbnMiLCJ1cGRhdGVkT3B0aW9ucyIsImNsZWFySW50ZXJ2YWwiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdG9wIiwidG9nZ2xlVmlkZW9Qcm9jZXNzaW5nIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY29udGV4dCIsImdldENvbnRleHQiLCJ3aWR0aCIsInZpZGVvV2lkdGgiLCJoZWlnaHQiLCJ2aWRlb0hlaWdodCIsImRyYXdJbWFnZSIsImJsb2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRvQmxvYiIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJ0b1N0cmluZyIsIm1ldGhvZCIsImJvZHkiLCJvayIsIkVycm9yIiwic3RhdHVzIiwicmVzdWx0Iiwic3VjY2VzcyIsImltYWdlIiwiZGlzcGxheVByb2Nlc3NlZEltYWdlIiwiYmFzZTY0SW1hZ2UiLCJjdHgiLCJpbWciLCJJbWFnZSIsIm9ubG9hZCIsImNsZWFyUmVjdCIsInNyYyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/videoProcessor.js\n"));

/***/ })

}]);