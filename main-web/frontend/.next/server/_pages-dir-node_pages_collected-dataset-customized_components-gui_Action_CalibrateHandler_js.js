"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_pages_collected-dataset-customized_components-gui_Action_CalibrateHandler_js";
exports.ids = ["_pages-dir-node_pages_collected-dataset-customized_components-gui_Action_CalibrateHandler_js"];
exports.modules = {

/***/ "(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/CalibrateHandler.js":
/*!**************************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/Action/CalibrateHandler.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/CalibratePoints.js\");\n/* harmony import */ var _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CaptureHandler */ \"(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/CaptureHandler.js\");\n/* harmony import */ var _DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotCaptureUtil */ \"(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/DotCaptureUtil.js\");\n// CalibrateHandler.js - Using the existing CaptureHandler class\n\n\n\nclass CalibrateHandler {\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Create a CaptureHandler instance for handling the captures\n        this.captureHandler = new _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__[\"default\"](// Pass saveImageToServer function\n        async (imageData, filename, type, folder)=>{\n            try {\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type,\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    console.warn(`Server responded with ${response.status}`);\n                    return {};\n                }\n                return await response.json();\n            } catch (err) {\n                console.error(`Error saving ${type}:`, err);\n                return {};\n            }\n        }, // Pass setCaptureCounter function\n        (newCounter)=>{\n            if (typeof newCounter === 'function') {\n                this.captureCounter = newCounter(this.captureCounter);\n            } else {\n                this.captureCounter = newCounter;\n            }\n            if (this.setCaptureCounter) {\n                this.setCaptureCounter(this.captureCounter);\n            }\n        }, // Pass setProcessStatus function\n        (status)=>{\n            if (this.setOutputText) {\n                this.setOutputText(status);\n            }\n        }, // Pass toggleTopBar function\n        this.toggleTopBar);\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      background-color: rgba(0, 102, 204, 0.9);\n      color: white;\n      font-size: 14px;\n      font-weight: bold;\n      padding: 8px 12px;\n      border-radius: 6px;\n      z-index: 9999;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n    `;\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Processing point ${index + 1}/${total}`;\n            }\n            // Draw the dot\n            const canvas = this.canvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            const ctx = canvas.getContext('2d');\n            (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n            // Create countdown element\n            const canvasRect = canvas.getBoundingClientRect();\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'calibrate-countdown';\n            countdownElement.style.cssText = `\n        position: fixed;\n        left: ${canvasRect.left + point.x}px;\n        top: ${canvasRect.top + point.y - 60}px;\n        transform: translateX(-50%);\n        color: red;\n        font-size: 36px;\n        font-weight: bold;\n        text-shadow: 0 0 10px white, 0 0 20px white;\n        z-index: 9999;\n        background-color: rgba(255, 255, 255, 0.8);\n        border: 2px solid red;\n        border-radius: 50%;\n        width: 50px;\n        height: 50px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n      `;\n            document.body.appendChild(countdownElement);\n            // Run countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                this.setOutputText?.(`Point ${index + 1}/${total} - countdown ${count}`);\n                // Make sure dot remains visible during countdown\n                (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n                // Wait for next countdown step\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            // Show capturing indicator\n            countdownElement.textContent = \"âœ“\";\n            this.setOutputText?.(`Capturing point ${index + 1}/${total}`);\n            // Remove countdown element\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Use CaptureHandler to handle the capture process\n            const captureResult = await this.captureHandler.captureAndShowPreview(this.captureCounter, this.canvasRef, point);\n            // Add null check before using the result\n            if (!captureResult) {\n                console.warn(`No capture result for point ${index + 1}`);\n            // You might want to set a default or retry logic here\n            }\n            // Wait for the preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2500));\n            return true;\n        } catch (err) {\n            console.error(`Error processing point ${index + 1}:`, err);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Error: ${err.message}`;\n            }\n            this.setOutputText?.(`Error: ${err.message}`);\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        if (this.toggleTopBar) {\n            this.toggleTopBar(false);\n        }\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            this.setOutputText?.(`Starting calibration with ${this.calibrationPoints.length} points`);\n            let successCount = 0;\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (success) {\n                    successCount++;\n                }\n                // Small delay between points\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            this.setOutputText?.(`Calibration completed: ${successCount}/${this.calibrationPoints.length} points captured`);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Calibration complete: ${successCount}/${this.calibrationPoints.length} points`;\n            }\n            // Turn TopBar back on\n            if (this.toggleTopBar) {\n                this.toggleTopBar(true);\n            }\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        } catch (error) {\n            // console.error('Calibration error:', error);\n            // this.setOutputText?.(`Calibration error: ${error.message}`);\n            // if (this.statusIndicator) {\n            //   this.statusIndicator.textContent = `Error: ${error.message}`;\n            // }\n            // // Make sure we turn TopBar back on even on error\n            // if (this.toggleTopBar) {\n            //   this.toggleTopBar(true);\n            // }\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 1500);\n            // Return a default object to prevent null reference errors\n            return {\n                screenImage: '',\n                webcamImage: '',\n                success: false\n            };\n        } finally{\n            this.isProcessing = false;\n            // Remove the status indicator after a delay\n            setTimeout(()=>{\n                if (this.statusIndicator && this.statusIndicator.parentNode) {\n                    this.statusIndicator.parentNode.removeChild(this.statusIndicator);\n                }\n            }, 3000);\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGdFQUFnRTtBQUNGO0FBQ2hCO0FBQ0E7QUFFOUMsTUFBTUc7SUFDSkMsWUFBWUMsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0MsU0FBUyxHQUFHRCxPQUFPQyxTQUFTO1FBQ2pDLElBQUksQ0FBQ0MsWUFBWSxHQUFHRixPQUFPRSxZQUFZO1FBQ3ZDLElBQUksQ0FBQ0MsYUFBYSxHQUFHSCxPQUFPRyxhQUFhO1FBQ3pDLElBQUksQ0FBQ0MsY0FBYyxHQUFHSixPQUFPSSxjQUFjLElBQUk7UUFDL0MsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0wsT0FBT0ssaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0MsYUFBYSxHQUFHTixPQUFPTSxhQUFhLElBQUk7UUFDN0MsSUFBSSxDQUFDQyxVQUFVLEdBQUdQLE9BQU9PLFVBQVU7UUFFbkMsbUVBQW1FO1FBQ25FLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdSLE9BQU9RLGlCQUFpQixJQUFJLEVBQUU7UUFFdkQsNkRBQTZEO1FBQzdELElBQUksQ0FBQ0MsY0FBYyxHQUFHLElBQUliLHVEQUFjQSxDQUN0QyxrQ0FBa0M7UUFDbEMsT0FBT2MsV0FBV0MsVUFBVUMsTUFBTUM7WUFDaEMsSUFBSTtnQkFDRixNQUFNQyxXQUFXLE1BQU1DLE1BQU0scUJBQXFCO29CQUNoREMsUUFBUTtvQkFDUkMsU0FBUzt3QkFDUCxnQkFBZ0I7b0JBQ2xCO29CQUNBQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQ25CVjt3QkFDQUM7d0JBQ0FDO3dCQUNBQyxRQUFRLElBQUksQ0FBQ1AsYUFBYTtvQkFDNUI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDUSxTQUFTTyxFQUFFLEVBQUU7b0JBQ2hCQyxRQUFRQyxJQUFJLENBQUMsQ0FBQyxzQkFBc0Is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LElBQUksQ0FBQ2tELGdCQUFnQixFQUFFO2dCQUN6QixJQUFJLENBQUNBLGdCQUFnQixDQUFDLFlBQVlsRCxNQUFNMEMsT0FBTztZQUNqRDtZQUVBLCtDQUErQztZQUMvQ0wsV0FBVztnQkFDVCxJQUFJLE9BQU8sSUFBSSxDQUFDOUQsWUFBWSxLQUFLLFlBQVk7b0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO2dCQUNwQixPQUFPLElBQUksS0FBb0QsRUFBRSxFQUVoRTtZQUNILEdBQUc7WUFFSCwyREFBMkQ7WUFDM0QsT0FBTztnQkFDTDZFLGFBQWE7Z0JBQ2JDLGFBQWE7Z0JBQ2JKLFNBQVM7WUFDWDtRQUNGLFNBQVU7WUFDUixJQUFJLENBQUMvQyxZQUFZLEdBQUc7WUFFcEIsNENBQTRDO1lBQzVDbUMsV0FBVztnQkFDVCxJQUFJLElBQUksQ0FBQ2pDLGVBQWUsSUFBSSxJQUFJLENBQUNBLGVBQWUsQ0FBQ2tDLFVBQVUsRUFBRTtvQkFDM0QsSUFBSSxDQUFDbEMsZUFBZSxDQUFDa0MsVUFBVSxDQUFDQyxXQUFXLENBQUMsSUFBSSxDQUFDbkMsZUFBZTtnQkFDbEU7WUFDRixHQUFHO1FBQ0w7SUFDRjtBQUNGO0FBRUEsaUVBQWVqQyxnQkFBZ0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENhbGlicmF0ZUhhbmRsZXIuanMgLSBVc2luZyB0aGUgZXhpc3RpbmcgQ2FwdHVyZUhhbmRsZXIgY2xhc3NcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgQ2FwdHVyZUhhbmRsZXIgZnJvbSAnLi9DYXB0dXJlSGFuZGxlcic7XG5pbXBvcnQgeyBkcmF3UmVkRG90IH0gZnJvbSAnLi9Eb3RDYXB0dXJlVXRpbCc7XG5cbmNsYXNzIENhbGlicmF0ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0T3V0cHV0VGV4dCA9IGNvbmZpZy5zZXRPdXRwdXRUZXh0O1xuICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBjb25maWcuY2FwdHVyZUNvdW50ZXIgfHwgMTtcbiAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyID0gY29uZmlnLnNldENhcHR1cmVDb3VudGVyO1xuICAgIHRoaXMuY2FwdHVyZUZvbGRlciA9IGNvbmZpZy5jYXB0dXJlRm9sZGVyIHx8ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IGNvbmZpZy5vbkNvbXBsZXRlO1xuXG4gICAgLy8gQWNjZXB0IHBhc3NlZC1pbiBjYWxpYnJhdGlvbiBwb2ludHMgKGZyb20gU2V0Q2FsaWJyYXRlQWN0aW9uLmpzKVxuICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBjb25maWcuY2FsaWJyYXRpb25Qb2ludHMgfHwgW107XG5cbiAgICAvLyBDcmVhdGUgYSBDYXB0dXJlSGFuZGxlciBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGNhcHR1cmVzXG4gICAgdGhpcy5jYXB0dXJlSGFuZGxlciA9IG5ldyBDYXB0dXJlSGFuZGxlcihcbiAgICAgIC8vIFBhc3Mgc2F2ZUltYWdlVG9TZXJ2ZXIgZnVuY3Rpb25cbiAgICAgIGFzeW5jIChpbWFnZURhdGEsIGZpbGVuYW1lLCB0eXBlLCBmb2xkZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBmb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nICR7dHlwZX06YCwgZXJyKTtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIHNldENhcHR1cmVDb3VudGVyIGZ1bmN0aW9uXG4gICAgICAobmV3Q291bnRlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0NvdW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gbmV3Q291bnRlcih0aGlzLmNhcHR1cmVDb3VudGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gbmV3Q291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHRoaXMuY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUGFzcyBzZXRQcm9jZXNzU3RhdHVzIGZ1bmN0aW9uXG4gICAgICAoc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNldE91dHB1dFRleHQpIHtcbiAgICAgICAgICB0aGlzLnNldE91dHB1dFRleHQoc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFBhc3MgdG9nZ2xlVG9wQmFyIGZ1bmN0aW9uXG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhclxuICAgICk7XG5cbiAgICAvLyBJbnRlcm5hbHNcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFBvaW50SW5kZXggPSAwO1xuICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgfVxuXG4gIGNyZWF0ZVN0YXR1c0luZGljYXRvcigpIHtcbiAgICBjb25zdCBleGlzdGluZ0luZGljYXRvcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InKTtcbiAgICBleGlzdGluZ0luZGljYXRvcnMuZm9yRWFjaChpbmRpY2F0b3IgPT4gaW5kaWNhdG9yLnJlbW92ZSgpKTtcblxuICAgIGNvbnN0IGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGluZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgIGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiAxMHB4O1xuICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBwYWRkaW5nOiA4cHggMTJweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbmRpY2F0b3IpO1xuICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yID0gaW5kaWNhdG9yO1xuICAgIHJldHVybiBpbmRpY2F0b3I7XG4gIH1cblxuICBhc3luYyBwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludChwb2ludCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcG9pbnQgfHwgdHlwZW9mIHBvaW50LnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb2ludC55ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGlicmF0aW9uIHBvaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgUHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gO1xuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1jb3VudGRvd24nO1xuICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGxlZnQ6ICR7Y2FudmFzUmVjdC5sZWZ0ICsgcG9pbnQueH1weDtcbiAgICAgICAgdG9wOiAke2NhbnZhc1JlY3QudG9wICsgcG9pbnQueSAtIDYwfXB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gUnVuIGNvdW50ZG93blxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgUG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9IC0gY291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgZG90IHJlbWFpbnMgdmlzaWJsZSBkdXJpbmcgY291bnRkb3duXG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIG5leHQgY291bnRkb3duIHN0ZXBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IGNhcHR1cmluZyBpbmRpY2F0b3JcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhcHR1cmluZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIENhcHR1cmVIYW5kbGVyIHRvIGhhbmRsZSB0aGUgY2FwdHVyZSBwcm9jZXNzXG4gICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgdGhpcy5jYXB0dXJlSGFuZGxlci5jYXB0dXJlQW5kU2hvd1ByZXZpZXcoXG4gICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHRoaXMuY2FudmFzUmVmLFxuICAgICAgICBwb2ludFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIG51bGwgY2hlY2sgYmVmb3JlIHVzaW5nIHRoZSByZXN1bHRcbiAgICAgIGlmICghY2FwdHVyZVJlc3VsdCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIGNhcHR1cmUgcmVzdWx0IGZvciBwb2ludCAke2luZGV4ICsgMX1gKTtcbiAgICAgICAgLy8gWW91IG1pZ2h0IHdhbnQgdG8gc2V0IGEgZGVmYXVsdCBvciByZXRyeSBsb2dpYyBoZXJlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcmV2aWV3IHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjUwMCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgcG9pbnQgJHtpbmRleCArIDF9OmAsIGVycik7XG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdGFydENhbGlicmF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcblxuXG5cbiAgICBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRpY2F0b3IgPSB0aGlzLmNyZWF0ZVN0YXR1c0luZGljYXRvcigpO1xuICAgIGluZGljYXRvci50ZXh0Q29udGVudCA9ICdJbml0aWFsaXppbmcgY2FsaWJyYXRpb24uLi4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcyB8fCBjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBub3QgcmVhZHknKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBnZW5lcmF0ZSBpZiBub25lIHdlcmUgcGFzc2VkIGluXG4gICAgICBpZiAoIXRoaXMuY2FsaWJyYXRpb25Qb2ludHMgfHwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBpZiAoIXRoaXMuY2FsaWJyYXRpb25Qb2ludHMgfHwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgU3RhcnRpbmcgY2FsaWJyYXRpb24gd2l0aCAke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHNgKTtcbiAgICAgIFxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMucHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQoXG4gICAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50c1tpXSwgXG4gICAgICAgICAgaSwgXG4gICAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNtYWxsIGRlbGF5IGJldHdlZW4gcG9pbnRzXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHVybiBUb3BCYXIgYmFjayBvblxuICAgICAgaWYgKHRoaXMudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0NhbGlicmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIC8vIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgLy8gaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAvLyAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIC8vIH1cbiAgICAgIFxuICAgICAgLy8gLy8gTWFrZSBzdXJlIHdlIHR1cm4gVG9wQmFyIGJhY2sgb24gZXZlbiBvbiBlcnJvclxuICAgICAgLy8gaWYgKHRoaXMudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAvLyAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgLy8gfVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGNhcHR1cmUgYW5kIHByZXZpZXc6JywgZXJyb3IpO1xuICBcbiAgICAgIC8vIFNob3cgZXJyb3IgbWVzc2FnZVxuICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGV2ZW4gaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxNTAwKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGEgZGVmYXVsdCBvYmplY3QgdG8gcHJldmVudCBudWxsIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6ICcnLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHRoZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IgJiYgdGhpcy5zdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDAwKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FsaWJyYXRlSGFuZGxlcjsiXSwibmFtZXMiOlsiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsIkNhcHR1cmVIYW5kbGVyIiwiZHJhd1JlZERvdCIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImNhbnZhc1JlZiIsInRvZ2dsZVRvcEJhciIsInNldE91dHB1dFRleHQiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsIm9uQ29tcGxldGUiLCJjYWxpYnJhdGlvblBvaW50cyIsImNhcHR1cmVIYW5kbGVyIiwiaW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ0eXBlIiwiZm9sZGVyIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiY29uc29sZSIsIndhcm4iLCJzdGF0dXMiLCJqc29uIiwiZXJyIiwiZXJyb3IiLCJuZXdDb3VudGVyIiwiaXNQcm9jZXNzaW5nIiwiY3VycmVudFBvaW50SW5kZXgiLCJzdGF0dXNJbmRpY2F0b3IiLCJjcmVhdGVTdGF0dXNJbmRpY2F0b3IiLCJleGlzdGluZ0luZGljYXRvcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaW5kaWNhdG9yIiwicmVtb3ZlIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsImFwcGVuZENoaWxkIiwicHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQiLCJwb2ludCIsImluZGV4IiwidG90YWwiLCJ4IiwieSIsIkVycm9yIiwidGV4dENvbnRlbnQiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNhbnZhc1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3VudGRvd25FbGVtZW50IiwibGVmdCIsInRvcCIsImNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVBbmRTaG93UHJldmlldyIsIm1lc3NhZ2UiLCJzdGFydENhbGlicmF0aW9uIiwid2lkdGgiLCJoZWlnaHQiLCJsZW5ndGgiLCJzdWNjZXNzQ291bnQiLCJpIiwic3VjY2VzcyIsInNldFByb2Nlc3NTdGF0dXMiLCJ3aW5kb3ciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/CalibrateHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/CaptureHandler.js":
/*!************************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/Action/CaptureHandler.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// CaptureHandler.js - With fixed capture numbering\nclass CaptureHandler {\n    constructor(saveFunction, counterSetter, statusSetter, toggleTopBarFunction){\n        this.saveImageToServer = saveFunction;\n        this.setCaptureCounter = counterSetter;\n        this.setProcessStatus = statusSetter;\n        this.toggleTopBar = toggleTopBarFunction;\n        this.captureFolder = 'eye_tracking_captures'; // Use fixed folder name\n    }\n    // Show preview of the SAVED images for exactly 2 seconds\n    showCapturePreview(screenImage, webcamImage, dotPosition) {\n        // Create a centered preview container\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = `\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: flex;\n        gap: 20px;\n        background-color: rgba(0, 0, 0, 0.85);\n        padding: 20px;\n        border-radius: 12px;\n        z-index: 999999;\n        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n        opacity: 1;\n        transition: opacity 0.3s ease;\n      `;\n        // Function to create an image preview element\n        const createImagePreview = (imageData, label)=>{\n            if (!imageData) return null;\n            const preview = document.createElement('div');\n            preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n            const img = document.createElement('img');\n            img.src = imageData;\n            img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n            // Event listeners for image loading\n            img.onload = ()=>console.log(`${label} image loaded successfully`);\n            img.onerror = (e)=>console.error(`Error loading ${label} image:`, e);\n            const textLabel = document.createElement('div');\n            textLabel.textContent = label;\n            textLabel.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n            preview.appendChild(img);\n            preview.appendChild(textLabel);\n            return preview;\n        };\n        // Add debug info\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = `\n        position: absolute;\n        top: -30px;\n        left: 0;\n        width: 100%;\n        color: white;\n        font-size: 12px;\n        text-align: center;\n      `;\n        debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n        previewContainer.appendChild(debugInfo);\n        // Add screen capture preview\n        const screenPreview = createImagePreview(screenImage, 'Screen Capture');\n        if (screenPreview) {\n            previewContainer.appendChild(screenPreview);\n        }\n        // Add webcam capture preview\n        const webcamPreview = createImagePreview(webcamImage, 'Webcam Capture');\n        if (webcamPreview) {\n            previewContainer.appendChild(webcamPreview);\n        }\n        // Add dot position info if available\n        if (dotPosition) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n            positionInfo.style.cssText = `\n          color: #ffcc00;\n          font-size: 14px;\n          position: absolute;\n          top: -50px;\n          left: 0;\n          width: 100%;\n          text-align: center;\n        `;\n            previewContainer.appendChild(positionInfo);\n        }\n        // Add timer countdown\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = `\n        position: absolute;\n        bottom: -25px;\n        right: 20px;\n        color: white;\n        font-size: 12px;\n        background-color: rgba(0, 0, 0, 0.7);\n        padding: 3px 8px;\n        border-radius: 4px;\n      `;\n        previewContainer.appendChild(timerElement);\n        // Add the preview to the document\n        document.body.appendChild(previewContainer);\n        // Start countdown timer\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Take a webcam picture and immediately stop the stream\n    async captureWebcamImage(captureNumber) {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format the filename with the current counter\n            const filename = `webcam_${String(captureNumber).padStart(3, '0')}.jpg`;\n            // Create a new stream with high resolution constraints\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 4096\n                    },\n                    height: {\n                        ideal: 2160\n                    },\n                    facingMode: \"user\"\n                },\n                audio: false\n            });\n            // Create a temporary video element\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Connect stream to video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get actual video dimensions\n            const videoWidth = tempVideo.videoWidth || 640;\n            const videoHeight = tempVideo.videoHeight || 480;\n            console.log(`Capturing at resolution: ${videoWidth}x${videoHeight}`);\n            // Capture the frame at full resolution\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = videoWidth;\n            tempCanvas.height = videoHeight;\n            const ctx = tempCanvas.getContext('2d');\n            ctx.drawImage(tempVideo, 0, 0, videoWidth, videoHeight);\n            // Convert to JPEG with high quality\n            const imageData = tempCanvas.toDataURL('image/jpeg', 0.95);\n            // Save the image\n            await this.saveImageToServer(imageData, filename, 'webcam', this.captureFolder);\n            // Clean up\n            stream.getTracks().forEach((track)=>track.stop());\n            tempVideo.remove();\n            return true;\n        } catch (error) {\n            console.error('Error capturing webcam image:', error);\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.remove();\n            }\n            return false;\n        }\n    }\n    // Capture screen image from canvas\n    async captureScreenImage(canvasRef, captureNumber) {\n        try {\n            // Format the filename with the current counter\n            const filename = `screen_${String(captureNumber).padStart(3, '0')}.jpg`;\n            const canvas = canvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas reference is null\");\n                return {\n                    imageData: null,\n                    saveResponse: null\n                };\n            }\n            // Get image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save the image\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(imageData, filename, 'screen', this.captureFolder);\n                console.log(`Saved screen image: ${filename}, response:`, saveResponse);\n                return {\n                    imageData,\n                    saveResponse\n                };\n            }\n            return {\n                imageData,\n                saveResponse: null\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            return {\n                imageData: null,\n                saveResponse: null\n            };\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(captureNumber, params) {\n        try {\n            // Format the filename with the current counter\n            const filename = `parameter_${String(captureNumber).padStart(3, '0')}.csv`;\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                ...Object.entries(params).map(([name, value])=>`${name},${value}`)\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(csvDataUrl, filename, 'parameters', this.captureFolder);\n                console.log(`Saved parameter CSV: ${filename}`);\n                return saveResponse;\n            }\n            return null;\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n            return null;\n        }\n    }\n    // Main capture and show process\n    async captureAndShowPreview(captureCounter, canvasRef, position) {\n        try {\n            console.log(`Starting capture process with counter: ${captureCounter}`);\n            // Step 1: Capture screen image\n            const { imageData: screenImage, saveResponse: screenResponse } = await this.captureScreenImage(canvasRef, captureCounter);\n            // Get the capture number from the response if available (for continuous numbering)\n            let usedCaptureNumber = captureCounter;\n            if (screenResponse && screenResponse.captureNumber) {\n                usedCaptureNumber = screenResponse.captureNumber;\n                console.log(`Server assigned capture number: ${usedCaptureNumber}`);\n            }\n            // Step 2: Capture webcam image (and immediately stop stream)\n            const webcamSuccess = await this.captureWebcamImage(usedCaptureNumber);\n            // Step 3: Save parameters\n            const params = {\n                dot_x: position ? position.x : 0,\n                dot_y: position ? position.y : 0,\n                canvas_width: canvasRef.current ? canvasRef.current.width : 0,\n                canvas_height: canvasRef.current ? canvasRef.current.height : 0,\n                window_width: window.innerWidth,\n                window_height: window.innerHeight,\n                timestamp: new Date().toISOString()\n            };\n            await this.saveParameterCSV(usedCaptureNumber, params);\n            // Step 4: Increment counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server is managing numbering, use the next number\n                if (screenResponse && screenResponse.captureNumber) {\n                    this.setCaptureCounter(screenResponse.captureNumber + 1);\n                } else {\n                    this.setCaptureCounter((prev)=>prev + 1);\n                }\n            }\n            // Step 5: Update status\n            if (this.setProcessStatus) {\n                this.setProcessStatus(`Captured with dot at: x=${position?.x}, y=${position?.y}`);\n            }\n            // Step 6: Show preview using the in-memory image data\n            this.showCapturePreview(screenImage, webcamSuccess ? 'webcam_image_data' : null, position);\n            // Step 7: Show TopBar again after preview is done\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 2200); // Wait longer than the preview duration\n            // Step 8: Clear status after a delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 1500);\n            // Clear error message after delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CaptureHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhcHR1cmVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxtREFBbUQ7QUFFbkQsTUFBTUE7SUFDRkMsWUFBWUMsWUFBWSxFQUFFQyxhQUFhLEVBQUVDLFlBQVksRUFBRUMsb0JBQW9CLENBQUU7UUFDM0UsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR0o7UUFDekIsSUFBSSxDQUFDSyxpQkFBaUIsR0FBR0o7UUFDekIsSUFBSSxDQUFDSyxnQkFBZ0IsR0FBR0o7UUFDeEIsSUFBSSxDQUFDSyxZQUFZLEdBQUdKO1FBQ3BCLElBQUksQ0FBQ0ssYUFBYSxHQUFHLHlCQUF5Qix3QkFBd0I7SUFDeEU7SUFFQSx5REFBeUQ7SUFDekRDLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRTtRQUN4RCxzQ0FBc0M7UUFDdEMsTUFBTUMsbUJBQW1CQyxTQUFTQyxhQUFhLENBQUM7UUFDaERGLGlCQUFpQkcsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7TUFjbEMsQ0FBQztRQUVELDhDQUE4QztRQUM5QyxNQUFNQyxxQkFBcUIsQ0FBQ0MsV0FBV0M7WUFDckMsSUFBSSxDQUFDRCxXQUFXLE9BQU87WUFFdkIsTUFBTUUsVUFBVVAsU0FBU0MsYUFBYSxDQUFDO1lBQ3ZDTSxRQUFRTCxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7O1FBSXpCLENBQUM7WUFFRCxNQUFNSyxNQUFNUixTQUFTQyxhQUFhLENBQUM7WUFDbkNPLElBQUlDLEdBQUcsR0FBR0o7WUFDVkcsSUFBSU4sS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7O1FBTXJCLENBQUM7WUFFRCxvQ0FBb0M7WUFDcENLLElBQUlFLE1BQU0sR0FBRyxJQUFNQyxRQUFRQyxHQUFHLENBQUMsR0FBR04sTUFBTSwwQkFBMEIsQ0FBQztZQUNuRUUsSUFBSUssT0FBTyxHQUFHLENBQUNDLElBQU1ILFFBQVFJLEtBQUssQ0FBQyxDQUFDLGNBQWMsRUFBRVQsTUFBTSxPQUFPLENBQUMsRUFBRVE7WUFFcEUsTUFBTUUsWUFBWWhCLFNBQVNDLGFBQWEsQ0FBQztZQUN6Q2UsVUFBVUMsV0FBVyxHQUFHWDtZQUN4QlUsVUFBVWQsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7UUFLM0IsQ0FBQztZQUVESSxRQUFRVyxXQUFXLENBQUNWO1lBQ3BCRCxRQUFRVyxXQUFXLENBQUNGO1lBQ3BCLE9BQU9UO1FBQ1Q7UUFFQSxpQkFBaUI7UUFDakIsTUFBTVksWUFBWW5CLFNBQVNDLGFBQWEsQ0FBQztRQUN6Q2tCLFVBQVVqQixLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7OztNQVEzQixDQUFDO1FBQ0RnQixVQUFVRixXQUFXLEdBQUcsQ0FBQyxRQUFRLEVBQUVyQixjQUFjLFFBQVEsS0FBSyxVQUFVLEVBQUVDLGNBQWMsUUFBUSxNQUFNO1FBQ3RHRSxpQkFBaUJtQixXQUFXLENBQUNDO1FBRTdCLDZCQUE2QjtRQUM3QixNQUFNQyxnQkFBZ0JoQixtQkFBbUJSLGFBQWE7UUFDdEQsSUFBSXdCLGVBQWU7WUFDakJyQixpQkFBaUJtQixXQUFXLENBQUNFO1FBQy9CO1FBRUEsNkJBQTZCO1FBQzdCLE1BQU1DLGdCQUFnQmpCLG1CQUFtQlAsYUFBYTtRQUN0RCxJQUFJd0IsZUFBZTtZQUNqQnRCLGlCQUFpQm1CLFdBQVcsQ0FBQ0c7UUFDL0I7UUFFQSxxQ0FBcUM7UUFDckMsSUFBSXZCLGFBQWE7WUFDZixNQUFNd0IsZUFBZXRCLFNBQVNDLGFBQWEsQ0FBQztZQUM1Q3FCLGFBQWFMLFdBQVcsR0FBRyxDQUFDLGdCQUFnQixFQUFFTSxLQUFLQyxLQUFLLENBQUMxQixZQUFZMkIsQ0FBQyxFQUFFLElBQUksRUFBRUYsS0FBS0MsS0FBSyxDQUFDMUIsWUFBWTRCLENBQUMsR0FBRztZQUN6R0osYUFBYXBCLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7O1FBUTlCLENBQUM7WUFDREosaUJBQWlCbUIsV0FBVyxDQUFDSTtRQUMvQjtRQUVBLHNCQUFzQjtRQUN0QixNQUFNSyxlQUFlM0IsU0FBU0MsYUFBYSxDQUFDO1FBQzVDMEIsYUFBYVYsV0FBVyxHQUFHO1FBQzNCVSxhQUFhekIsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7O01BUzlCLENBQUM7UUFDREosaUJBQWlCbUIsV0FBVyxDQUFDUztRQUU3QixrQ0FBa0M7UUFDbEMzQixTQUFTNEIsSUFBSSxDQUFDVixXQUFXLENBQUNuQjtRQUUxQix3QkFBd0I7UUFDeEIsSUFBSThCLFdBQVc7UUFDZixNQUFNQyxXQUFXQyxZQUFZO1lBQzNCRixZQUFZO1lBQ1osSUFBSUEsWUFBWSxHQUFHO2dCQUNqQkcsY0FBY0Y7Z0JBQ2QsV0FBVztnQkFDWC9CLGlCQUFpQkcsS0FBSyxDQUFDK0IsT0FBTyxHQUFHO2dCQUNqQyxvQkFBb0I7Z0JBQ3BCQyxXQUFXO29CQUNULElBQUluQyxpQkFBaUJvQyxVQUFVLEVBQUU7d0JBQy9CcEMsaUJBQWlCb0MsVUFBVSxDQUFDQyxXQUFXLENBQUNyQztvQkFDMUM7Z0JBQ0YsR0FBRztZQUNMLE9BQU87Z0JBQ0w0QixhQUFhVixXQUFXLEdBQUcsR0FBR1ksU0FBU1EsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ3REO1FBQ0YsR0FBRztRQUVILDZEQUE2RDtRQUM3REgsV0FBVztZQUNULElBQUluQyxpQkFBaUJvQyxVQUFVLEVBQUU7Z0JBQy9CcEMsaUJBQWlCb0MsVUFBVSxDQUFDQyxXQUFXLENBQUNyQztZQUMxQztRQUNGLEdBQUc7SUFDTDtJQUVBLHdEQUF3RDtJQUN4RCxNQUFNdUMsbUJBQW1CQyxhQUFhLEVBQUU7UUFDdEMsSUFBSUMsU0FBUztRQUNiLElBQUlDLFlBQVk7UUFFaEIsSUFBSTtZQUNGLCtDQUErQztZQUMvQyxNQUFNQyxXQUFXLENBQUMsT0FBTyxFQUFFQyxPQUFPSixlQUFlSyxRQUFRLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQztZQUV2RSx1REFBdUQ7WUFDdkRKLFNBQVMsTUFBTUssVUFBVUMsWUFBWSxDQUFDQyxZQUFZLENBQUM7Z0JBQ2pEQyxPQUFPO29CQUNMQyxPQUFPO3dCQUFFQyxPQUFPO29CQUFLO29CQUNyQkMsUUFBUTt3QkFBRUQsT0FBTztvQkFBSztvQkFDdEJFLFlBQVk7Z0JBQ2Q7Z0JBQ0FDLE9BQU87WUFDVDtZQUVBLG1DQUFtQztZQUNuQ1osWUFBWXpDLFNBQVNDLGFBQWEsQ0FBQztZQUNuQ3dDLFVBQVVhLFFBQVEsR0FBRztZQUNyQmIsVUFBVWMsV0FBVyxHQUFHO1lBQ3hCZCxVQUFVZSxLQUFLLEdBQUc7WUFDbEJmLFVBQVV2QyxLQUFLLENBQUN1RCxRQUFRLEdBQUc7WUFDM0JoQixVQUFVdkMsS0FBSyxDQUFDd0QsSUFBSSxHQUFHO1lBQ3ZCakIsVUFBVXZDLEtBQUssQ0FBQytCLE9BQU8sR0FBRztZQUMxQmpDLFNBQVM0QixJQUFJLENBQUNWLFdBQVcsQ0FBQ3VCO1lBRTFCLGtDQUFrQztZQUNsQ0EsVUFBVWtCLFNBQVMsR0FBR25CO1lBRXRCLCtCQUErQjtZQUMvQixNQUFNLElBQUlvQixRQUFRLENBQUNDO2dCQUNqQixNQUFNQyxZQUFZNUIsV0FBVztvQkFDM0J2QixRQUFRb0QsSUFBSSxDQUFDO29CQUNiRjtnQkFDRixHQUFHO2dCQUVIcEIsVUFBVXVCLFlBQVksR0FBRztvQkFDdkJDLGFBQWFIO29CQUNiRDtnQkFDRjtZQUNGO1lBRUEsc0NBQXNDO1lBQ3RDLE1BQU0sSUFBSUQsUUFBUUMsQ0FBQUEsVUFBVzNCLFdBQVcyQixTQUFTO1lBRWpELDhCQUE4QjtZQUM5QixNQUFNSyxhQUFhekIsVUFBVXlCLFVBQVUsSUFBSTtZQUMzQyxNQUFNQyxjQUFjMUIsVUFBVTBCLFdBQVcsSUFBSTtZQUM3Q3hELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFc0QsV0FBVyxDQUFDLEVBQUVDLGFBQWE7WUFFbkUsdUNBQXVDO1lBQ3ZDLE1BQU1DLGFBQWFwRSxTQUFTQyxhQUFhLENBQUM7WUFDMUNtRSxXQUFXbkIsS0FBSyxHQUFHaUI7WUFDbkJFLFdBQVdqQixNQUFNLEdBQUdnQjtZQUNwQixNQUFNRSxNQUFNRCxXQUFXRSxVQUFVLENBQUM7WUFDbENELElBQUlFLFNBQVMsQ0FBQzlCLFdBQVcsR0FBRyxHQUFHeUIsWUFBWUM7WUFFM0Msb0NBQW9DO1lBQ3BDLE1BQU05RCxZQUFZK0QsV0FBV0ksU0FBUyxDQUFDLGNBQWM7WUFFckQsaUJBQWlCO1lBQ2pCLE1BQU0sSUFBSSxDQUFDbEYsaUJBQWlCLENBQUNlLFdBQVdxQyxVQUFVLFVBQVUsSUFBSSxDQUFDaEQsYUFBYTtZQUU5RSxXQUFXO1lBQ1g4QyxPQUFPaUMsU0FBUyxHQUFHQyxPQUFPLENBQUNDLENBQUFBLFFBQVNBLE1BQU1DLElBQUk7WUFDOUNuQyxVQUFVb0MsTUFBTTtZQUVoQixPQUFPO1FBQ1QsRUFBRSxPQUFPOUQsT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxJQUFJeUIsUUFBUTtnQkFDVkEsT0FBT2lDLFNBQVMsR0FBR0MsT0FBTyxDQUFDQyxDQUFBQSxRQUFTQSxNQUFNQyxJQUFJO1lBQ2hEO1lBQ0EsSUFBSW5DLFdBQVc7Z0JBQ2JBLFVBQVVvQyxNQUFNO1lBQ2xCO1lBQ0EsT0FBTztRQUNUO0lBQ0Y7SUFFQSxtQ0FBbUM7SUFDbkMsTUFBTUMsbUJBQW1CQyxTQUFTLEVBQUV4QyxhQUFhLEVBQUU7UUFDakQsSUFBSTtZQUNGLCtDQUErQztZQUMvQyxNQUFNRyxXQUFXLENBQUMsT0FBTyxFQUFFQyxPQUFPSixlQUFlSyxRQUFRLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQztZQUV2RSxNQUFNb0MsU0FBU0QsVUFBVUUsT0FBTztZQUNoQyxJQUFJLENBQUNELFFBQVE7Z0JBQ1hyRSxRQUFRSSxLQUFLLENBQUM7Z0JBQ2QsT0FBTztvQkFBRVYsV0FBVztvQkFBTTZFLGNBQWM7Z0JBQUs7WUFDL0M7WUFFQSxpQkFBaUI7WUFDakIsTUFBTTdFLFlBQVkyRSxPQUFPUixTQUFTLENBQUM7WUFFbkMsaUJBQWlCO1lBQ2pCLElBQUksSUFBSSxDQUFDbEYsaUJBQWlCLEVBQUU7Z0JBQzFCLE1BQU00RixlQUFlLE1BQU0sSUFBSSxDQUFDNUYsaUJBQWlCLENBQUNlLFdBQVdxQyxVQUFVLFVBQVUsSUFBSSxDQUFDaEQsYUFBYTtnQkFDbkdpQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRThCLFNBQVMsV0FBVyxDQUFDLEVBQUV3QztnQkFDMUQsT0FBTztvQkFBRTdFO29CQUFXNkU7Z0JBQWE7WUFDbkM7WUFFQSxPQUFPO2dCQUFFN0U7Z0JBQVc2RSxjQUFjO1lBQUs7UUFDekMsRUFBRSxPQUFPbkUsT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMsaUNBQWlDQTtZQUMvQyxPQUFPO2dCQUFFVixXQUFXO2dCQUFNNkUsY0FBYztZQUFLO1FBQy9DO0lBQ0Y7SUFFQSxxQkFBcUI7SUFDckIsTUFBTUMsaUJBQWlCNUMsYUFBYSxFQUFFNkMsTUFBTSxFQUFFO1FBQzVDLElBQUk7WUFDRiwrQ0FBK0M7WUFDL0MsTUFBTTFDLFdBQVcsQ0FBQyxVQUFVLEVBQUVDLE9BQU9KLGVBQWVLLFFBQVEsQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDO1lBRTFFLHNEQUFzRDtZQUN0RCxNQUFNeUMsVUFBVTtnQkFDZDttQkFDR0MsT0FBT0MsT0FBTyxDQUFDSCxRQUFRSSxHQUFHLENBQUMsQ0FBQyxDQUFDQyxNQUFNQyxNQUFNLEdBQUssR0FBR0QsS0FBSyxDQUFDLEVBQUVDLE9BQU87YUFDcEUsQ0FBQ0MsSUFBSSxDQUFDO1lBRVAsMEJBQTBCO1lBQzFCLE1BQU1DLFVBQVUsSUFBSUMsS0FBSztnQkFBQ1I7YUFBUSxFQUFFO2dCQUFFUyxNQUFNO1lBQVc7WUFDdkQsTUFBTUMsWUFBWSxJQUFJQztZQUV0QixNQUFNQyxhQUFhLE1BQU0sSUFBSXJDLFFBQVEsQ0FBQ0M7Z0JBQ3BDa0MsVUFBVUcsU0FBUyxHQUFHLElBQU1yQyxRQUFRa0MsVUFBVUksTUFBTTtnQkFDcERKLFVBQVVLLGFBQWEsQ0FBQ1I7WUFDMUI7WUFFQSx5QkFBeUI7WUFDekIsSUFBSSxJQUFJLENBQUN0RyxpQkFBaUIsRUFBRTtnQkFDMUIsTUFBTTRGLGVBQWUsTUFBTSxJQUFJLENBQUM1RixpQkFBaUIsQ0FBQzJHLFlBQVl2RCxVQUFVLGNBQWMsSUFBSSxDQUFDaEQsYUFBYTtnQkFDeEdpQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUIsRUFBRThCLFVBQVU7Z0JBQzlDLE9BQU93QztZQUNUO1lBRUEsT0FBTztRQUNULEVBQUUsT0FBT21CLFVBQVU7WUFDakIxRixRQUFRSSxLQUFLLENBQUMsK0JBQStCc0Y7WUFDN0MsT0FBTztRQUNUO0lBQ0Y7SUFFQSxnQ0FBZ0M7SUFDaEMsTUFBTUMsc0JBQXNCQyxjQUFjLEVBQUV4QixTQUFTLEVBQUV0QixRQUFRLEVBQUU7UUFDL0QsSUFBSTtZQUNGOUMsUUFBUUMsR0FBRyxDQUFDLENBQUMsdUNBQXVDLEVBQUUyRixnQkFBZ0I7WUFFdEUsK0JBQStCO1lBQy9CLE1BQU0sRUFBRWxHLFdBQVdULFdBQVcsRUFBRXNGLGNBQWNzQixjQUFjLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQzFCLGtCQUFrQixDQUFDQyxXQUFXd0I7WUFFMUcsbUZBQW1GO1lBQ25GLElBQUlFLG9CQUFvQkY7WUFDeEIsSUFBSUMsa0JBQWtCQSxlQUFlakUsYUFBYSxFQUFFO2dCQUNsRGtFLG9CQUFvQkQsZUFBZWpFLGFBQWE7Z0JBQ2hENUIsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0NBQWdDLEVBQUU2RixtQkFBbUI7WUFDcEU7WUFFQSw2REFBNkQ7WUFDN0QsTUFBTUMsZ0JBQWdCLE1BQU0sSUFBSSxDQUFDcEUsa0JBQWtCLENBQUNtRTtZQUVwRCwwQkFBMEI7WUFDMUIsTUFBTXJCLFNBQVM7Z0JBQ2J1QixPQUFPbEQsV0FBV0EsU0FBU2hDLENBQUMsR0FBRztnQkFDL0JtRixPQUFPbkQsV0FBV0EsU0FBUy9CLENBQUMsR0FBRztnQkFDL0JtRixjQUFjOUIsVUFBVUUsT0FBTyxHQUFHRixVQUFVRSxPQUFPLENBQUNoQyxLQUFLLEdBQUc7Z0JBQzVENkQsZUFBZS9CLFVBQVVFLE9BQU8sR0FBR0YsVUFBVUUsT0FBTyxDQUFDOUIsTUFBTSxHQUFHO2dCQUM5RDRELGNBQWNDLE9BQU9DLFVBQVU7Z0JBQy9CQyxlQUFlRixPQUFPRyxXQUFXO2dCQUNqQ0MsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO1lBQ25DO1lBRUEsTUFBTSxJQUFJLENBQUNuQyxnQkFBZ0IsQ0FBQ3NCLG1CQUFtQnJCO1lBRS9DLDZDQUE2QztZQUM3QyxJQUFJLElBQUksQ0FBQzdGLGlCQUFpQixFQUFFO2dCQUMxQiwyREFBMkQ7Z0JBQzNELElBQUlpSCxrQkFBa0JBLGVBQWVqRSxhQUFhLEVBQUU7b0JBQ2xELElBQUksQ0FBQ2hELGlCQUFpQixDQUFDaUgsZUFBZWpFLGFBQWEsR0FBRztnQkFDeEQsT0FBTztvQkFDTCxJQUFJLENBQUNoRCxpQkFBaUIsQ0FBQ2dJLENBQUFBLE9BQVFBLE9BQU87Z0JBQ3hDO1lBQ0Y7WUFFQSx3QkFBd0I7WUFDeEIsSUFBSSxJQUFJLENBQUMvSCxnQkFBZ0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQyxDQUFDLHdCQUF3QixFQUFFaUUsVUFBVWhDLEVBQUUsSUFBSSxFQUFFZ0MsVUFBVS9CLEdBQUc7WUFDbEY7WUFFQSxzREFBc0Q7WUFDdEQsSUFBSSxDQUFDL0Isa0JBQWtCLENBQUNDLGFBQWE4RyxnQkFBZ0Isc0JBQXNCLE1BQU1qRDtZQUVqRixrREFBa0Q7WUFDbER2QixXQUFXO2dCQUNULElBQUksT0FBTyxJQUFJLENBQUN6QyxZQUFZLEtBQUssWUFBWTtvQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7Z0JBQ3BCLE9BQU8sSUFBSSxLQUFvRCxFQUFFLEVBRWhFO1lBQ0gsR0FBRyxPQUFPLHdDQUF3QztZQUVsRCxxQ0FBcUM7WUFDckN5QyxXQUFXO2dCQUNULElBQUksSUFBSSxDQUFDMUMsZ0JBQWdCLEVBQUU7b0JBQ3pCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUM7Z0JBQ3hCO1lBQ0YsR0FBRztRQUVMLEVBQUUsT0FBT3VCLE9BQU87WUFDZEosUUFBUUksS0FBSyxDQUFDLHFDQUFxQ0E7WUFFbkQscUJBQXFCO1lBQ3JCLElBQUksSUFBSSxDQUFDdkIsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUMsWUFBWXVCLE1BQU15RyxPQUFPO1lBQ2pEO1lBRUEsK0NBQStDO1lBQy9DdEYsV0FBVztnQkFDVCxJQUFJLE9BQU8sSUFBSSxDQUFDekMsWUFBWSxLQUFLLFlBQVk7b0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO2dCQUNwQixPQUFPLElBQUksS0FBb0QsRUFBRSxFQUVoRTtZQUNILEdBQUc7WUFFSCxrQ0FBa0M7WUFDbEN5QyxXQUFXO2dCQUNULElBQUksSUFBSSxDQUFDMUMsZ0JBQWdCLEVBQUU7b0JBQ3pCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUM7Z0JBQ3hCO1lBQ0YsR0FBRztRQUNMO0lBQ0Y7QUFDRjtBQUVBLGlFQUFlUixjQUFjQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9BY3Rpb24vQ2FwdHVyZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FwdHVyZUhhbmRsZXIuanMgLSBXaXRoIGZpeGVkIGNhcHR1cmUgbnVtYmVyaW5nXG5cbmNsYXNzIENhcHR1cmVIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzYXZlRnVuY3Rpb24sIGNvdW50ZXJTZXR0ZXIsIHN0YXR1c1NldHRlciwgdG9nZ2xlVG9wQmFyRnVuY3Rpb24pIHtcbiAgICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBzYXZlRnVuY3Rpb247XG4gICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyID0gY291bnRlclNldHRlcjtcbiAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyA9IHN0YXR1c1NldHRlcjtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gdG9nZ2xlVG9wQmFyRnVuY3Rpb247XG4gICAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJzsgLy8gVXNlIGZpeGVkIGZvbGRlciBuYW1lXG4gICAgfVxuICBcbiAgICAvLyBTaG93IHByZXZpZXcgb2YgdGhlIFNBVkVEIGltYWdlcyBmb3IgZXhhY3RseSAyIHNlY29uZHNcbiAgICBzaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlLCBkb3RQb3NpdGlvbikge1xuICAgICAgLy8gQ3JlYXRlIGEgY2VudGVyZWQgcHJldmlldyBjb250YWluZXJcbiAgICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDUwJTtcbiAgICAgICAgbGVmdDogNTAlO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZ2FwOiAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MgZWFzZTtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIC8vIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbWFnZSBwcmV2aWV3IGVsZW1lbnRcbiAgICAgIGNvbnN0IGNyZWF0ZUltYWdlUHJldmlldyA9IChpbWFnZURhdGEsIGxhYmVsKSA9PiB7XG4gICAgICAgIGlmICghaW1hZ2VEYXRhKSByZXR1cm4gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZURhdGE7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmVudCBsaXN0ZW5lcnMgZm9yIGltYWdlIGxvYWRpbmdcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IGNvbnNvbGUubG9nKGAke2xhYmVsfSBpbWFnZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgJHtsYWJlbH0gaW1hZ2U6YCwgZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0ZXh0TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGV4dExhYmVsLnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgIHRleHRMYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZCh0ZXh0TGFiZWwpO1xuICAgICAgICByZXR1cm4gcHJldmlldztcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEFkZCBkZWJ1ZyBpbmZvXG4gICAgICBjb25zdCBkZWJ1Z0luZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRlYnVnSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTMwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIGRlYnVnSW5mby50ZXh0Q29udGVudCA9IGBTY3JlZW46ICR7c2NyZWVuSW1hZ2UgPyAnWUVTJyA6ICdOTyd9LCBXZWJjYW06ICR7d2ViY2FtSW1hZ2UgPyAnWUVTJyA6ICdOTyd9YDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoZGVidWdJbmZvKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHNjcmVlbiBjYXB0dXJlIHByZXZpZXdcbiAgICAgIGNvbnN0IHNjcmVlblByZXZpZXcgPSBjcmVhdGVJbWFnZVByZXZpZXcoc2NyZWVuSW1hZ2UsICdTY3JlZW4gQ2FwdHVyZScpO1xuICAgICAgaWYgKHNjcmVlblByZXZpZXcpIHtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChzY3JlZW5QcmV2aWV3KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIHdlYmNhbSBjYXB0dXJlIHByZXZpZXdcbiAgICAgIGNvbnN0IHdlYmNhbVByZXZpZXcgPSBjcmVhdGVJbWFnZVByZXZpZXcod2ViY2FtSW1hZ2UsICdXZWJjYW0gQ2FwdHVyZScpO1xuICAgICAgaWYgKHdlYmNhbVByZXZpZXcpIHtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWJjYW1QcmV2aWV3KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIGRvdCBwb3NpdGlvbiBpbmZvIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKGRvdFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwb3NpdGlvbkluZm8udGV4dENvbnRlbnQgPSBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLnkpfWA7XG4gICAgICAgIHBvc2l0aW9uSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgdG9wOiAtNTBweDtcbiAgICAgICAgICBsZWZ0OiAwO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgYDtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3NpdGlvbkluZm8pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgdGltZXIgY291bnRkb3duXG4gICAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICAgIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgICBgO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBBZGQgdGhlIHByZXZpZXcgdG8gdGhlIGRvY3VtZW50XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgXG4gICAgICAvLyBTdGFydCBjb3VudGRvd24gdGltZXJcbiAgICAgIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGZhZGVcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwKTtcbiAgICAgIFxuICAgICAgLy8gU2FmZXR5IGNsZWFudXAgYWZ0ZXIgNSBzZWNvbmRzIGluIGNhc2UgYW55dGhpbmcgZ29lcyB3cm9uZ1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDUwMDApO1xuICAgIH1cbiAgXG4gICAgLy8gVGFrZSBhIHdlYmNhbSBwaWN0dXJlIGFuZCBpbW1lZGlhdGVseSBzdG9wIHRoZSBzdHJlYW1cbiAgICBhc3luYyBjYXB0dXJlV2ViY2FtSW1hZ2UoY2FwdHVyZU51bWJlcikge1xuICAgICAgbGV0IHN0cmVhbSA9IG51bGw7XG4gICAgICBsZXQgdGVtcFZpZGVvID0gbnVsbDtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRm9ybWF0IHRoZSBmaWxlbmFtZSB3aXRoIHRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBgd2ViY2FtXyR7U3RyaW5nKGNhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2A7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgc3RyZWFtIHdpdGggaGlnaCByZXNvbHV0aW9uIGNvbnN0cmFpbnRzXG4gICAgICAgIHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHtcbiAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgd2lkdGg6IHsgaWRlYWw6IDQwOTYgfSxcbiAgICAgICAgICAgIGhlaWdodDogeyBpZGVhbDogMjE2MCB9LFxuICAgICAgICAgICAgZmFjaW5nTW9kZTogXCJ1c2VyXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSB2aWRlbyBlbGVtZW50XG4gICAgICAgIHRlbXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIHRlbXBWaWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5tdXRlZCA9IHRydWU7XG4gICAgICAgIHRlbXBWaWRlby5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRlbXBWaWRlby5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xuICAgICAgICB0ZW1wVmlkZW8uc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29ubmVjdCBzdHJlYW0gdG8gdmlkZW8gZWxlbWVudFxuICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgdmlkZW8gdG8gaW5pdGlhbGl6ZVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVmlkZW8gbG9hZGluZyB0aW1lZCBvdXQsIGNvbnRpbnVpbmcgYW55d2F5XCIpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIHRlbXBWaWRlby5vbmxvYWRlZGRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBhIGNsZWFyIGZyYW1lXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBhY3R1YWwgdmlkZW8gZGltZW5zaW9uc1xuICAgICAgICBjb25zdCB2aWRlb1dpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICBjb25zdCB2aWRlb0hlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCA0ODA7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgYXQgcmVzb2x1dGlvbjogJHt2aWRlb1dpZHRofXgke3ZpZGVvSGVpZ2h0fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgZnJhbWUgYXQgZnVsbCByZXNvbHV0aW9uXG4gICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHZpZGVvV2lkdGg7XG4gICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdmlkZW9IZWlnaHQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHZpZGVvV2lkdGgsIHZpZGVvSGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgdG8gSlBFRyB3aXRoIGhpZ2ggcXVhbGl0eVxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycsIDAuOTUpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW1hZ2VcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlcihpbWFnZURhdGEsIGZpbGVuYW1lLCAnd2ViY2FtJywgdGhpcy5jYXB0dXJlRm9sZGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FwdHVyaW5nIHdlYmNhbSBpbWFnZTonLCBlcnJvcik7XG4gICAgICAgIGlmIChzdHJlYW0pIHtcbiAgICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZW1wVmlkZW8pIHtcbiAgICAgICAgICB0ZW1wVmlkZW8ucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gQ2FwdHVyZSBzY3JlZW4gaW1hZ2UgZnJvbSBjYW52YXNcbiAgICBhc3luYyBjYXB0dXJlU2NyZWVuSW1hZ2UoY2FudmFzUmVmLCBjYXB0dXJlTnVtYmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGb3JtYXQgdGhlIGZpbGVuYW1lIHdpdGggdGhlIGN1cnJlbnQgY291bnRlclxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGBzY3JlZW5fJHtTdHJpbmcoY2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcmVmZXJlbmNlIGlzIG51bGxcIik7XG4gICAgICAgICAgcmV0dXJuIHsgaW1hZ2VEYXRhOiBudWxsLCBzYXZlUmVzcG9uc2U6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGltYWdlIGRhdGFcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTYXZlIHRoZSBpbWFnZVxuICAgICAgICBpZiAodGhpcy5zYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgIGNvbnN0IHNhdmVSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgJ3NjcmVlbicsIHRoaXMuY2FwdHVyZUZvbGRlcik7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHNjcmVlbiBpbWFnZTogJHtmaWxlbmFtZX0sIHJlc3BvbnNlOmAsIHNhdmVSZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIHsgaW1hZ2VEYXRhLCBzYXZlUmVzcG9uc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHsgaW1hZ2VEYXRhLCBzYXZlUmVzcG9uc2U6IG51bGwgfTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYXB0dXJpbmcgc2NyZWVuIGltYWdlOlwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7IGltYWdlRGF0YTogbnVsbCwgc2F2ZVJlc3BvbnNlOiBudWxsIH07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIFNhdmUgcGFyYW1ldGVyIENTVlxuICAgIGFzeW5jIHNhdmVQYXJhbWV0ZXJDU1YoY2FwdHVyZU51bWJlciwgcGFyYW1zKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBGb3JtYXQgdGhlIGZpbGVuYW1lIHdpdGggdGhlIGN1cnJlbnQgY291bnRlclxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGBwYXJhbWV0ZXJfJHtTdHJpbmcoY2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uY3N2YDtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBDU1YgY29udGVudCB3aXRoIHR3byBjb2x1bW5zOiBuYW1lIGFuZCB2YWx1ZVxuICAgICAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgICAgIFwibmFtZSx2YWx1ZVwiLFxuICAgICAgICAgIC4uLk9iamVjdC5lbnRyaWVzKHBhcmFtcykubWFwKChbbmFtZSwgdmFsdWVdKSA9PiBgJHtuYW1lfSwke3ZhbHVlfWApXG4gICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IENTViB0byBkYXRhIFVSTFxuICAgICAgICBjb25zdCBjc3ZCbG9iID0gbmV3IEJsb2IoW2NzdkRhdGFdLCB7IHR5cGU6ICd0ZXh0L2NzdicgfSk7XG4gICAgICAgIGNvbnN0IGNzdlJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjc3ZEYXRhVXJsID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjc3ZSZWFkZXIub25sb2FkZW5kID0gKCkgPT4gcmVzb2x2ZShjc3ZSZWFkZXIucmVzdWx0KTtcbiAgICAgICAgICBjc3ZSZWFkZXIucmVhZEFzRGF0YVVSTChjc3ZCbG9iKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTYXZlIENTViB1c2luZyB0aGUgQVBJXG4gICAgICAgIGlmICh0aGlzLnNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgY29uc3Qgc2F2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlcihjc3ZEYXRhVXJsLCBmaWxlbmFtZSwgJ3BhcmFtZXRlcnMnLCB0aGlzLmNhcHR1cmVGb2xkZXIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCBwYXJhbWV0ZXIgQ1NWOiAke2ZpbGVuYW1lfWApO1xuICAgICAgICAgIHJldHVybiBzYXZlUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBjYXRjaCAoY3N2RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBwYXJhbWV0ZXIgQ1NWOlwiLCBjc3ZFcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgLy8gTWFpbiBjYXB0dXJlIGFuZCBzaG93IHByb2Nlc3NcbiAgICBhc3luYyBjYXB0dXJlQW5kU2hvd1ByZXZpZXcoY2FwdHVyZUNvdW50ZXIsIGNhbnZhc1JlZiwgcG9zaXRpb24pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlIHByb2Nlc3Mgd2l0aCBjb3VudGVyOiAke2NhcHR1cmVDb3VudGVyfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAxOiBDYXB0dXJlIHNjcmVlbiBpbWFnZVxuICAgICAgICBjb25zdCB7IGltYWdlRGF0YTogc2NyZWVuSW1hZ2UsIHNhdmVSZXNwb25zZTogc2NyZWVuUmVzcG9uc2UgfSA9IGF3YWl0IHRoaXMuY2FwdHVyZVNjcmVlbkltYWdlKGNhbnZhc1JlZiwgY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBjYXB0dXJlIG51bWJlciBmcm9tIHRoZSByZXNwb25zZSBpZiBhdmFpbGFibGUgKGZvciBjb250aW51b3VzIG51bWJlcmluZylcbiAgICAgICAgbGV0IHVzZWRDYXB0dXJlTnVtYmVyID0gY2FwdHVyZUNvdW50ZXI7XG4gICAgICAgIGlmIChzY3JlZW5SZXNwb25zZSAmJiBzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyKSB7XG4gICAgICAgICAgdXNlZENhcHR1cmVOdW1iZXIgPSBzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTZXJ2ZXIgYXNzaWduZWQgY2FwdHVyZSBudW1iZXI6ICR7dXNlZENhcHR1cmVOdW1iZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgMjogQ2FwdHVyZSB3ZWJjYW0gaW1hZ2UgKGFuZCBpbW1lZGlhdGVseSBzdG9wIHN0cmVhbSlcbiAgICAgICAgY29uc3Qgd2ViY2FtU3VjY2VzcyA9IGF3YWl0IHRoaXMuY2FwdHVyZVdlYmNhbUltYWdlKHVzZWRDYXB0dXJlTnVtYmVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgMzogU2F2ZSBwYXJhbWV0ZXJzXG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICBkb3RfeDogcG9zaXRpb24gPyBwb3NpdGlvbi54IDogMCxcbiAgICAgICAgICBkb3RfeTogcG9zaXRpb24gPyBwb3NpdGlvbi55IDogMCxcbiAgICAgICAgICBjYW52YXNfd2lkdGg6IGNhbnZhc1JlZi5jdXJyZW50ID8gY2FudmFzUmVmLmN1cnJlbnQud2lkdGggOiAwLFxuICAgICAgICAgIGNhbnZhc19oZWlnaHQ6IGNhbnZhc1JlZi5jdXJyZW50ID8gY2FudmFzUmVmLmN1cnJlbnQuaGVpZ2h0IDogMCxcbiAgICAgICAgICB3aW5kb3dfd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgIHdpbmRvd19oZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlUGFyYW1ldGVyQ1NWKHVzZWRDYXB0dXJlTnVtYmVyLCBwYXJhbXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA0OiBJbmNyZW1lbnQgY291bnRlciBmb3IgbmV4dCBjYXB0dXJlXG4gICAgICAgIGlmICh0aGlzLnNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBpcyBtYW5hZ2luZyBudW1iZXJpbmcsIHVzZSB0aGUgbmV4dCBudW1iZXJcbiAgICAgICAgICBpZiAoc2NyZWVuUmVzcG9uc2UgJiYgc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcihzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyICsgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIocHJldiA9PiBwcmV2ICsgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDU6IFVwZGF0ZSBzdGF0dXNcbiAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZWQgd2l0aCBkb3QgYXQ6IHg9JHtwb3NpdGlvbj8ueH0sIHk9JHtwb3NpdGlvbj8ueX1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA2OiBTaG93IHByZXZpZXcgdXNpbmcgdGhlIGluLW1lbW9yeSBpbWFnZSBkYXRhXG4gICAgICAgIHRoaXMuc2hvd0NhcHR1cmVQcmV2aWV3KHNjcmVlbkltYWdlLCB3ZWJjYW1TdWNjZXNzID8gJ3dlYmNhbV9pbWFnZV9kYXRhJyA6IG51bGwsIHBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgNzogU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgcHJldmlldyBpcyBkb25lXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDIyMDApOyAvLyBXYWl0IGxvbmdlciB0aGFuIHRoZSBwcmV2aWV3IGR1cmF0aW9uXG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDg6IENsZWFyIHN0YXR1cyBhZnRlciBhIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgY2FwdHVyZSBhbmQgcHJldmlldzonLCBlcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IGVycm9yIG1lc3NhZ2VcbiAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBlcnJvciBtZXNzYWdlIGFmdGVyIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLnNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIGV4cG9ydCBkZWZhdWx0IENhcHR1cmVIYW5kbGVyOyJdLCJuYW1lcyI6WyJDYXB0dXJlSGFuZGxlciIsImNvbnN0cnVjdG9yIiwic2F2ZUZ1bmN0aW9uIiwiY291bnRlclNldHRlciIsInN0YXR1c1NldHRlciIsInRvZ2dsZVRvcEJhckZ1bmN0aW9uIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsInNldFByb2Nlc3NTdGF0dXMiLCJ0b2dnbGVUb3BCYXIiLCJjYXB0dXJlRm9sZGVyIiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImRvdFBvc2l0aW9uIiwicHJldmlld0NvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInN0eWxlIiwiY3NzVGV4dCIsImNyZWF0ZUltYWdlUHJldmlldyIsImltYWdlRGF0YSIsImxhYmVsIiwicHJldmlldyIsImltZyIsInNyYyIsIm9ubG9hZCIsImNvbnNvbGUiLCJsb2ciLCJvbmVycm9yIiwiZSIsImVycm9yIiwidGV4dExhYmVsIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsImRlYnVnSW5mbyIsInNjcmVlblByZXZpZXciLCJ3ZWJjYW1QcmV2aWV3IiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwieCIsInkiLCJ0aW1lckVsZW1lbnQiLCJib2R5IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9wYWNpdHkiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9GaXhlZCIsImNhcHR1cmVXZWJjYW1JbWFnZSIsImNhcHR1cmVOdW1iZXIiLCJzdHJlYW0iLCJ0ZW1wVmlkZW8iLCJmaWxlbmFtZSIsIlN0cmluZyIsInBhZFN0YXJ0IiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZ2V0VXNlck1lZGlhIiwidmlkZW8iLCJ3aWR0aCIsImlkZWFsIiwiaGVpZ2h0IiwiZmFjaW5nTW9kZSIsImF1ZGlvIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwicG9zaXRpb24iLCJsZWZ0Iiwic3JjT2JqZWN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aW1lb3V0SWQiLCJ3YXJuIiwib25sb2FkZWRkYXRhIiwiY2xlYXJUaW1lb3V0IiwidmlkZW9XaWR0aCIsInZpZGVvSGVpZ2h0IiwidGVtcENhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJnZXRUcmFja3MiLCJmb3JFYWNoIiwidHJhY2siLCJzdG9wIiwicmVtb3ZlIiwiY2FwdHVyZVNjcmVlbkltYWdlIiwiY2FudmFzUmVmIiwiY2FudmFzIiwiY3VycmVudCIsInNhdmVSZXNwb25zZSIsInNhdmVQYXJhbWV0ZXJDU1YiLCJwYXJhbXMiLCJjc3ZEYXRhIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hcCIsIm5hbWUiLCJ2YWx1ZSIsImpvaW4iLCJjc3ZCbG9iIiwiQmxvYiIsInR5cGUiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJjc3ZFcnJvciIsImNhcHR1cmVBbmRTaG93UHJldmlldyIsImNhcHR1cmVDb3VudGVyIiwic2NyZWVuUmVzcG9uc2UiLCJ1c2VkQ2FwdHVyZU51bWJlciIsIndlYmNhbVN1Y2Nlc3MiLCJkb3RfeCIsImRvdF95IiwiY2FudmFzX3dpZHRoIiwiY2FudmFzX2hlaWdodCIsIndpbmRvd193aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJ3aW5kb3dfaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJ0aW1lc3RhbXAiLCJEYXRlIiwidG9JU09TdHJpbmciLCJwcmV2IiwibWVzc2FnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/CaptureHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/DotCaptureUtil.js":
/*!************************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/Action/DotCaptureUtil.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDotCountdown: () => (/* binding */ createDotCountdown),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   showImagePreview: () => (/* binding */ showImagePreview)\n/* harmony export */ });\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Show preview of captured images for exactly 2 seconds\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Improved function to show preview of captured images for exactly 2 seconds\nconst showImagePreview = (screenImage, webcamImage, dotPosition)=>{\n    // Create a preview container that centers in the screen\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 9999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n      opacity: 1;\n      transition: opacity 0.2s ease-in-out;\n    `;\n    // Add screen capture preview if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.style.cssText = `\n        max-width: 350px;\n        max-height: 250px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam capture preview if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.style.cssText = `\n        max-width: 350px;\n        max-height: 250px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n        positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -25px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add timer countdown\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n    previewContainer.appendChild(timerElement);\n    // Add the preview to the document\n    document.body.appendChild(previewContainer);\n    // Start countdown timer\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            timerElement.textContent = 'Closing...';\n            // Fade out the preview\n            previewContainer.style.opacity = '0';\n            // Remove after fade animation\n            setTimeout(()=>{\n                if (previewContainer && previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 200);\n        } else {\n            timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n        }\n    }, 100);\n    return previewContainer;\n};\n// Other utility functions remain the same...\n// Create and append a countdown element above a dot\nconst createDotCountdown = (position, canvasRect)=>{\n    // Create the countdown element directly above the dot\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'forced-countdown';\n    // Position it above the dot (calculate absolute position considering the canvas position)\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    countdownElement.style.cssText = `\n      position: fixed;\n      left: ${absoluteX}px;\n      top: ${absoluteY - 60}px;\n      transform: translateX(-50%);\n      color: red;\n      font-size: 36px;\n      font-weight: bold;\n      text-shadow: 0 0 10px white, 0 0 20px white;\n      z-index: 9999;\n      background-color: rgba(255, 255, 255, 0.8);\n      border: 2px solid red;\n      border-radius: 50%;\n      width: 50px;\n      height: 50px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    `;\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n// Draw a red dot on the canvas\nconst drawRedDot = (ctx, x, y, radius = 12)=>{\n    // Draw the dot with a glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect to the dot\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n// Initialize the canvas for drawing\nconst initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n// Generate a random position on the canvas\nconst getRandomPosition = (canvas, padding = 40)=>{\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0RvdENhcHR1cmVVdGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsb0JBQW9CO0FBQ3BCLHdEQUF3RDtBQUV4RCx3REFBd0Q7QUFDeEQsb0JBQW9CO0FBQ3BCLHdEQUF3RDtBQUV4RCw2RUFBNkU7QUFDdEUsTUFBTUEsbUJBQW1CLENBQUNDLGFBQWFDLGFBQWFDO0lBQ3ZELHdEQUF3RDtJQUN4RCxNQUFNQyxtQkFBbUJDLFNBQVNDLGFBQWEsQ0FBQztJQUNoREYsaUJBQWlCRyxTQUFTLEdBQUc7SUFDN0JILGlCQUFpQkksS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7SUFjbEMsQ0FBQztJQUVELDBDQUEwQztJQUMxQyxJQUFJUixhQUFhO1FBQ2YsTUFBTVMsZ0JBQWdCTCxTQUFTQyxhQUFhLENBQUM7UUFDN0NJLGNBQWNGLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7TUFJL0IsQ0FBQztRQUVELE1BQU1FLFlBQVlOLFNBQVNDLGFBQWEsQ0FBQztRQUN6Q0ssVUFBVUMsR0FBRyxHQUFHWDtRQUNoQlUsVUFBVUgsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7TUFLM0IsQ0FBQztRQUVELE1BQU1JLGNBQWNSLFNBQVNDLGFBQWEsQ0FBQztRQUMzQ08sWUFBWUMsV0FBVyxHQUFHO1FBQzFCRCxZQUFZTCxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7OztNQUs3QixDQUFDO1FBRURDLGNBQWNLLFdBQVcsQ0FBQ0o7UUFDMUJELGNBQWNLLFdBQVcsQ0FBQ0Y7UUFDMUJULGlCQUFpQlcsV0FBVyxDQUFDTDtJQUMvQjtJQUVBLDBDQUEwQztJQUMxQyxJQUFJUixhQUFhO1FBQ2YsTUFBTWMsZ0JBQWdCWCxTQUFTQyxhQUFhLENBQUM7UUFDN0NVLGNBQWNSLEtBQUssQ0FBQ0MsT0FBTyxH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QUFNQTtRQUN2RDFDLEdBQUdILEtBQUs4QyxLQUFLLENBQUM5QyxLQUFLK0MsTUFBTSxLQUFNUixDQUFBQSxTQUFTLElBQUlNLE9BQU0sS0FBTUE7SUFDMUQ7QUFDRixFQUFFIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9jb21wb25lbnRzLWd1aS9BY3Rpb24vRG90Q2FwdHVyZVV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRG90Q2FwdHVyZVV0aWwuanNcbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkb3QgY2FwdHVyZSBhbmQgcHJldmlldyBkaXNwbGF5XG5cbi8vIFNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXMgZm9yIGV4YWN0bHkgMiBzZWNvbmRzXG4vLyBEb3RDYXB0dXJlVXRpbC5qc1xuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRvdCBjYXB0dXJlIGFuZCBwcmV2aWV3IGRpc3BsYXlcblxuLy8gSW1wcm92ZWQgZnVuY3Rpb24gdG8gc2hvdyBwcmV2aWV3IG9mIGNhcHR1cmVkIGltYWdlcyBmb3IgZXhhY3RseSAyIHNlY29uZHNcbmV4cG9ydCBjb25zdCBzaG93SW1hZ2VQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgZG90UG9zaXRpb24pID0+IHtcbiAgICAvLyBDcmVhdGUgYSBwcmV2aWV3IGNvbnRhaW5lciB0aGF0IGNlbnRlcnMgaW4gdGhlIHNjcmVlblxuICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYXB0dXJlLXByZXZpZXctY29udGFpbmVyJztcbiAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGdhcDogMjBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICAgIG9wYWNpdHk6IDE7XG4gICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnMgZWFzZS1pbi1vdXQ7XG4gICAgYDtcbiAgICBcbiAgICAvLyBBZGQgc2NyZWVuIGNhcHR1cmUgcHJldmlldyBpZiBhdmFpbGFibGVcbiAgICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICAgIGNvbnN0IHNjcmVlblByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcmVlblByZXZpZXcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNjcmVlbkltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgc2NyZWVuSW1nLnNyYyA9IHNjcmVlbkltYWdlO1xuICAgICAgc2NyZWVuSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIG1heC13aWR0aDogMzUwcHg7XG4gICAgICAgIG1heC1oZWlnaHQ6IDI1MHB4O1xuICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgc2NyZWVuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcmVlbkxhYmVsLnRleHRDb250ZW50ID0gJ1NjcmVlbiBDYXB0dXJlJztcbiAgICAgIHNjcmVlbkxhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuSW1nKTtcbiAgICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuTGFiZWwpO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChzY3JlZW5QcmV2aWV3KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHdlYmNhbSBjYXB0dXJlIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3ZWJjYW1QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWJjYW1JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHdlYmNhbUltZy5zcmMgPSB3ZWJjYW1JbWFnZTtcbiAgICAgIHdlYmNhbUltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXgtd2lkdGg6IDM1MHB4O1xuICAgICAgICBtYXgtaGVpZ2h0OiAyNTBweDtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHdlYmNhbUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB3ZWJjYW1MYWJlbC50ZXh0Q29udGVudCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgICB3ZWJjYW1MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUltZyk7XG4gICAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQod2ViY2FtUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkb3QgcG9zaXRpb24gaW5mbyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZG90UG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9zaXRpb25JbmZvLnRleHRDb250ZW50ID0gYERvdCBwb3NpdGlvbjogeD0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi55KX1gO1xuICAgICAgcG9zaXRpb25JbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMjVweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvc2l0aW9uSW5mbyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB0aW1lciBjb3VudGRvd25cbiAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IC0yNXB4O1xuICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgIFxuICAgIC8vIEFkZCB0aGUgcHJldmlldyB0byB0aGUgZG9jdW1lbnRcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNvdW50ZG93biB0aW1lclxuICAgIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnQ2xvc2luZy4uLic7XG4gICAgICAgIFxuICAgICAgICAvLyBGYWRlIG91dCB0aGUgcHJldmlld1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZSBhbmltYXRpb25cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIgJiYgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICAgIFxuICAgIHJldHVybiBwcmV2aWV3Q29udGFpbmVyO1xuICB9O1xuICBcbiAgLy8gT3RoZXIgdXRpbGl0eSBmdW5jdGlvbnMgcmVtYWluIHRoZSBzYW1lLi4uXG4gICAgXG4gIC8vIENyZWF0ZSBhbmQgYXBwZW5kIGEgY291bnRkb3duIGVsZW1lbnQgYWJvdmUgYSBkb3RcbiAgZXhwb3J0IGNvbnN0IGNyZWF0ZURvdENvdW50ZG93biA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICAgIC8vIENyZWF0ZSB0aGUgY291bnRkb3duIGVsZW1lbnQgZGlyZWN0bHkgYWJvdmUgdGhlIGRvdFxuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdmb3JjZWQtY291bnRkb3duJztcbiAgICBcbiAgICAvLyBQb3NpdGlvbiBpdCBhYm92ZSB0aGUgZG90IChjYWxjdWxhdGUgYWJzb2x1dGUgcG9zaXRpb24gY29uc2lkZXJpbmcgdGhlIGNhbnZhcyBwb3NpdGlvbilcbiAgICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICAgIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcbiAgICBcbiAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICAgIHRvcDogJHthYnNvbHV0ZVkgLSA2MH1weDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgIGNvbG9yOiByZWQ7XG4gICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICBcbiAgICByZXR1cm4gY291bnRkb3duRWxlbWVudDtcbiAgfTtcbiAgXG4gIC8vIERyYXcgYSByZWQgZG90IG9uIHRoZSBjYW52YXNcbiAgZXhwb3J0IGNvbnN0IGRyYXdSZWREb3QgPSAoY3R4LCB4LCB5LCByYWRpdXMgPSAxMikgPT4ge1xuICAgIC8vIERyYXcgdGhlIGRvdCB3aXRoIGEgZ2xvdyBlZmZlY3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3QgdG8gdGhlIGRvdFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH07XG4gIFxuICAvLyBJbml0aWFsaXplIHRoZSBjYW52YXMgZm9yIGRyYXdpbmdcbiAgZXhwb3J0IGNvbnN0IGluaXRpYWxpemVDYW52YXMgPSAoY2FudmFzLCBwYXJlbnQpID0+IHtcbiAgICBpZiAoIWNhbnZhcyB8fCAhcGFyZW50KSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHBhcmVudFxuICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciBjYW52YXMgYW5kIHNldCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBcbiAgLy8gR2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb24gb24gdGhlIGNhbnZhc1xuICBleHBvcnQgY29uc3QgZ2V0UmFuZG9tUG9zaXRpb24gPSAoY2FudmFzLCBwYWRkaW5nID0gNDApID0+IHtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIHsgeDogMTAwLCB5OiAxMDAgfTsgLy8gRmFsbGJhY2sgcG9zaXRpb25cbiAgICBcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCB8fCA0MDA7ICAvLyBGYWxsYmFjayBpZiB3aWR0aCBpcyAwXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCB8fCAzMDA7IC8vIEZhbGxiYWNrIGlmIGhlaWdodCBpcyAwXG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh3aWR0aCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nLFxuICAgICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nXG4gICAgfTtcbiAgfTsiXSwibmFtZXMiOlsic2hvd0ltYWdlUHJldmlldyIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJkb3RQb3NpdGlvbiIsInByZXZpZXdDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJzY3JlZW5QcmV2aWV3Iiwic2NyZWVuSW1nIiwic3JjIiwic2NyZWVuTGFiZWwiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwid2ViY2FtUHJldmlldyIsIndlYmNhbUltZyIsIndlYmNhbUxhYmVsIiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwieCIsInkiLCJ0aW1lckVsZW1lbnQiLCJib2R5IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsIm9wYWNpdHkiLCJzZXRUaW1lb3V0IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidG9GaXhlZCIsImNyZWF0ZURvdENvdW50ZG93biIsInBvc2l0aW9uIiwiY2FudmFzUmVjdCIsImNvdW50ZG93bkVsZW1lbnQiLCJhYnNvbHV0ZVgiLCJsZWZ0IiwiYWJzb2x1dGVZIiwidG9wIiwiZHJhd1JlZERvdCIsImN0eCIsInJhZGl1cyIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImNhbnZhcyIsInBhcmVudCIsIndpZHRoIiwiY2xpZW50V2lkdGgiLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0IiwiZmlsbFJlY3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsInBhZGRpbmciLCJmbG9vciIsInJhbmRvbSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset-customized/components-gui/Action/DotCaptureUtil.js\n");

/***/ })

};
;