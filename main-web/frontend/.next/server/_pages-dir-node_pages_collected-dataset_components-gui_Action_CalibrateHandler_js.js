"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_pages_collected-dataset_components-gui_Action_CalibrateHandler_js";
exports.ids = ["_pages-dir-node_pages_collected-dataset_components-gui_Action_CalibrateHandler_js"];
exports.modules = {

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CalibrateHandler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibratePoints.js\");\n// CalibrateHandler.js - This should be placed in the components-gui folder\n// This is a complete implementation of the calibration functionality\n\nclass CalibrateHandler {\n    constructor(config){\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCount || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Internal state\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.calibrationPoints = [];\n        this.statusIndicator = null;\n        this.countdownElement = null;\n    }\n    // Create a status indicator in the top right corner\n    createStatusIndicator() {\n        // Remove any existing indicators first\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>{\n            if (indicator.parentNode) {\n                indicator.parentNode.removeChild(indicator);\n            }\n        });\n        // Create new status indicator\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      background-color: rgba(0, 102, 204, 0.9);\n      color: white;\n      font-size: 14px;\n      font-weight: bold;\n      padding: 8px 12px;\n      border-radius: 6px;\n      z-index: 9999;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n    `;\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    // Draw a specific calibration point\n    drawCalibrationPoint(point) {\n        const canvas = this.canvasRef.current;\n        if (!canvas) return null;\n        const ctx = canvas.getContext('2d');\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Draw the point with larger radius and glow effect\n        const radius = 8;\n        // Draw the calibration point\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = 'red';\n        ctx.fill();\n        // Add glow effect\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, radius + 4, 0, Math.PI * 2);\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n        return {\n            x: point.x,\n            y: point.y\n        };\n    }\n    // Create a countdown element above the current dot\n    createCountdownElement(position) {\n        // Remove any existing countdown elements\n        const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .center-countdown-backup');\n        existingCountdowns.forEach((countdown)=>{\n            if (countdown.parentNode) {\n                countdown.parentNode.removeChild(countdown);\n            }\n        });\n        // Get canvas position for absolute positioning\n        const canvas = this.canvasRef.current;\n        if (!canvas) return null;\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate absolute position\n        const absoluteX = canvasRect.left + position.x;\n        const absoluteY = canvasRect.top + position.y;\n        // Create new countdown element positioned above the dot\n        const countdown = document.createElement('div');\n        countdown.className = 'calibrate-countdown';\n        countdown.style.cssText = `\n      position: fixed;\n      left: ${absoluteX}px;\n      top: ${absoluteY - 60}px;\n      transform: translateX(-50%);\n      color: red;\n      font-size: 36px;\n      font-weight: bold;\n      text-shadow: 0 0 10px white, 0 0 20px white;\n      z-index: 9999;\n      background-color: rgba(255, 255, 255, 0.8);\n      border: 2px solid red;\n      border-radius: 50%;\n      width: 50px;\n      height: 50px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    `;\n        document.body.appendChild(countdown);\n        this.countdownElement = countdown;\n        return {\n            dot: countdown\n        };\n    }\n    // Capture screen image\n    async captureScreenImage() {\n        try {\n            const canvas = this.canvasRef.current;\n            if (!canvas) throw new Error(\"Canvas reference is null\");\n            // Format filename with counter\n            const counter = String(this.captureCounter).padStart(3, '0');\n            const filename = `screen_${counter}.jpg`;\n            // Capture image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save image via API\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type: 'screen',\n                    folder: this.captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n            const result = await response.json();\n            console.log(`Saved screen image: ${filename}`);\n            return {\n                data: imageData,\n                response: result\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            throw error;\n        }\n    }\n    // Capture webcam image silently\n    async captureWebcamImage() {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format filename with counter\n            const counter = String(this.captureCounter).padStart(3, '0');\n            const filename = `webcam_${counter}.jpg`;\n            // Look for an existing video element first\n            const videoElement = window.videoElement || document.querySelector('video');\n            if (videoElement && videoElement.readyState >= 2) {\n                // If we have a video element that's loaded, use it\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = videoElement.videoWidth || 640;\n                tempCanvas.height = videoElement.videoHeight || 480;\n                ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                const imageData = tempCanvas.toDataURL('image/png');\n                // Save the image\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type: 'webcam',\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    throw new Error(`Server responded with ${response.status}`);\n                }\n                const result = await response.json();\n                console.log(`Saved webcam image: ${filename}`);\n                return {\n                    data: imageData,\n                    response: result\n                };\n            }\n            // If no video element, create a temporary one\n            // Create a temporary stream for just this capture\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: true,\n                audio: false\n            });\n            // Create a hidden video element to receive the stream\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Set the stream to the video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Check if video dimensions are valid\n            if (tempVideo.videoWidth === 0 || tempVideo.videoHeight === 0) {\n                console.warn(\"Video dimensions are invalid, using default dimensions\");\n            }\n            // Capture the frame to a canvas\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = tempVideo.videoWidth || 640;\n            tempCanvas.height = tempVideo.videoHeight || 480;\n            const ctx = tempCanvas.getContext('2d');\n            ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n            // Get image data\n            const imageData = tempCanvas.toDataURL('image/png');\n            // Save the image via API\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type: 'webcam',\n                    folder: this.captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n            const result = await response.json();\n            console.log(`Saved webcam image: ${filename}`);\n            return {\n                data: imageData,\n                response: result\n            };\n        } catch (error) {\n            console.error(\"Error capturing webcam image:\", error);\n            return {\n                data: null,\n                response: null\n            };\n        } finally{\n            // IMPORTANT: Clean up resources even if there was an error\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(point, index) {\n        try {\n            // Format filename with counter\n            const counter = String(this.captureCounter).padStart(3, '0');\n            const filename = `parameter_${counter}.csv`;\n            const canvas = this.canvasRef.current;\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                `dot_x,${point.x}`,\n                `dot_y,${point.y}`,\n                `canvas_width,${canvas ? canvas.width : 0}`,\n                `canvas_height,${canvas ? canvas.height : 0}`,\n                `window_width,${window.innerWidth}`,\n                `window_height,${window.innerHeight}`,\n                `calibration_point_index,${index}`,\n                `calibration_point_label,${point.label || ''}`,\n                `timestamp,${new Date().toISOString()}`\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData: csvDataUrl,\n                    filename,\n                    type: 'parameters',\n                    folder: this.captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n            const result = await response.json();\n            console.log(`Saved parameter CSV: ${filename}`);\n            return result;\n        } catch (error) {\n            console.error(\"Error saving parameter CSV:\", error);\n            throw error;\n        }\n    }\n    // Show preview of captured images - made identical to WhiteScreenMain implementation\n    showCapturePreview(screenImage, webcamImage, point) {\n        if (!screenImage && !webcamImage) {\n            console.warn(\"No images available to preview\");\n            return;\n        }\n        // Remove any existing preview containers first (in case of overlapping)\n        try {\n            const existingPreviews = document.querySelectorAll('.capture-preview-container');\n            existingPreviews.forEach((preview)=>{\n                if (preview.parentNode) {\n                    console.log(\"Removing existing preview container\");\n                    preview.parentNode.removeChild(preview);\n                }\n            });\n        } catch (cleanupError) {\n            console.error(\"Error cleaning up existing previews:\", cleanupError);\n        }\n        // Create a new preview container with z-index higher than everything else\n        const previewContainer = document.createElement('div');\n        previewContainer.className = 'capture-preview-container';\n        previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 999999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n    `;\n        console.log(\"Preview container created\");\n        // Add debug info div\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = `\n      position: absolute;\n      top: -30px;\n      left: 0;\n      width: 100%;\n      color: white;\n      font-size: 12px;\n      text-align: center;\n    `;\n        debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n        previewContainer.appendChild(debugInfo);\n        // Function to add an image to the preview\n        const addImagePreview = (image, label)=>{\n            try {\n                console.log(`Adding ${label} preview, image data length: ${image ? image.length : 'N/A'}`);\n                const preview = document.createElement('div');\n                preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n                const img = document.createElement('img');\n                img.src = image;\n                img.alt = label;\n                img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n                // Event listeners for image loading\n                img.onload = ()=>console.log(`${label} image loaded successfully`);\n                img.onerror = (e)=>console.error(`Error loading ${label} image:`, e);\n                const labelElement = document.createElement('div');\n                labelElement.textContent = label;\n                labelElement.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n                preview.appendChild(img);\n                preview.appendChild(labelElement);\n                previewContainer.appendChild(preview);\n                console.log(`${label} preview element added to container`);\n                return true;\n            } catch (error) {\n                console.error(`Error adding ${label} preview:`, error);\n                return false;\n            }\n        };\n        // Add both images to preview if available\n        if (screenImage) {\n            addImagePreview(screenImage, 'Screen Capture');\n        }\n        if (webcamImage) {\n            addImagePreview(webcamImage, 'Webcam Capture');\n        }\n        // Add dot position info if available\n        if (point) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = point.label ? `${point.label}: x=${Math.round(point.x)}, y=${Math.round(point.y)}` : `Dot position: x=${Math.round(point.x)}, y=${Math.round(point.y)}`;\n            positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -50px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n            previewContainer.appendChild(positionInfo);\n            console.log(\"Dot position info added\");\n        }\n        // Add countdown timer\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n        previewContainer.appendChild(timerElement);\n        // Add to document body\n        try {\n            document.body.appendChild(previewContainer);\n            console.log(\"Preview container added to DOM\");\n        } catch (appendError) {\n            console.error(\"Error adding preview container to DOM:\", appendError);\n        }\n        // Countdown and remove the preview after 2 seconds\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.transition = 'opacity 0.3s ease';\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        console.log(\"Removing preview container from DOM\");\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                console.log(\"Safety cleanup of preview container\");\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Run the countdown animation for a point - simplified to only show countdown above dot\n    async runCountdown(point, index, total) {\n        // Create countdown element\n        const countdownElements = this.createCountdownElement(point);\n        if (!countdownElements) return false;\n        const { dot: countdownElement } = countdownElements;\n        // Run 3-2-1 countdown\n        for(let count = 3; count > 0; count--){\n            // Update countdown display\n            countdownElement.textContent = count;\n            // Update status indicator\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Calibrate Set Active: countdown ${count} (${index + 1}/${total})`;\n            }\n            // Update output text if available\n            if (this.setOutputText) {\n                this.setOutputText(`Calibration point ${index + 1}/${total} - countdown ${count}`);\n            }\n            // Wait for the next countdown step\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show capturing indicator briefly\n        countdownElement.textContent = \"✓\";\n        if (this.statusIndicator) {\n            this.statusIndicator.textContent = `Capturing point ${index + 1}/${total}`;\n        }\n        // Remove countdown element immediately after capture to only show the dot\n        // This ensures we see ONLY the red dot after capture, not the countdown indicators\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n        }, 300);\n        return true;\n    }\n    // Process a single calibration point\n    async processCalibrationPoint(point, index, total) {\n        try {\n            // Draw the calibration point\n            this.drawCalibrationPoint(point);\n            // Run countdown animation - same as RandomDot\n            await this.runCountdown(point, index, total);\n            // Capture screen image\n            const screenResult = await this.captureScreenImage();\n            // Capture webcam image\n            const webcamResult = await this.captureWebcamImage();\n            // Save parameter CSV\n            await this.saveParameterCSV(point, index);\n            // Increment capture counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server returned a new capture number, use it\n                if (screenResult.response && screenResult.response.captureNumber !== undefined) {\n                    this.captureCounter = screenResult.response.captureNumber + 1;\n                    this.setCaptureCounter(this.captureCounter);\n                } else {\n                    this.captureCounter++;\n                    this.setCaptureCounter(this.captureCounter);\n                }\n            }\n            // Show preview\n            this.showCapturePreview(screenResult.data, webcamResult ? webcamResult.data : null, point);\n            // Wait for preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2300));\n            return true;\n        } catch (error) {\n            console.error(`Error processing calibration point ${index + 1}:`, error);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Error: ${error.message}`;\n            }\n            if (this.setOutputText) {\n                this.setOutputText(`Error: ${error.message}`);\n            }\n            return false;\n        }\n    }\n    // Start the full calibration sequence\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        // Hide the TopBar IMMEDIATELY (first action)\n        if (typeof this.toggleTopBar === 'function') {\n            this.toggleTopBar(false);\n        }\n        // Small delay to ensure UI updates\n        await new Promise((resolve)=>setTimeout(resolve, 50));\n        // Create status indicator\n        const statusIndicator = this.createStatusIndicator();\n        statusIndicator.textContent = 'Calibrate Set Active: Initializing...';\n        try {\n            // Generate calibration points\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n            if (!this.calibrationPoints.length) {\n                throw new Error('Failed to generate calibration points');\n            }\n            // Update status\n            if (this.setOutputText) {\n                this.setOutputText(`Starting calibration with ${this.calibrationPoints.length} points`);\n            }\n            // Process each calibration point in sequence\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                statusIndicator.textContent = `Processing point ${i + 1}/${this.calibrationPoints.length}`;\n                // Process current point\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                // If processing failed, stop the sequence\n                if (!success) {\n                    throw new Error(`Failed to process point ${i + 1}`);\n                }\n            }\n            // Calibration complete\n            statusIndicator.textContent = 'Calibration completed';\n            if (this.setOutputText) {\n                this.setOutputText('Calibration completed successfully');\n            }\n            return true;\n        } catch (error) {\n            console.error('Calibration error:', error);\n            if (statusIndicator) {\n                statusIndicator.textContent = `Error: ${error.message}`;\n            }\n            if (this.setOutputText) {\n                this.setOutputText(`Calibration error: ${error.message}`);\n            }\n            return false;\n        } finally{\n            this.isProcessing = false;\n            // Show TopBar again\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(true);\n            }\n            // Remove status indicator after a delay\n            setTimeout(()=>{\n                if (statusIndicator && statusIndicator.parentNode) {\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }\n            }, 3000);\n            // Call onComplete callback if provided\n            if (typeof this.onComplete === 'function') {\n                this.onComplete();\n            }\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsMkVBQTJFO0FBQzNFLHFFQUFxRTtBQUNQO0FBRTlELE1BQU1DO0lBQ0pDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQixzQkFBc0I7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdELE9BQU9DLFNBQVM7UUFDakMsSUFBSSxDQUFDQyxZQUFZLEdBQUdGLE9BQU9FLFlBQVk7UUFDdkMsSUFBSSxDQUFDQyxhQUFhLEdBQUdILE9BQU9HLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxjQUFjLEdBQUdKLE9BQU9LLFlBQVksSUFBSTtRQUM3QyxJQUFJLENBQUNDLGlCQUFpQixHQUFHTixPQUFPTSxpQkFBaUI7UUFDakQsSUFBSSxDQUFDQyxhQUFhLEdBQUdQLE9BQU9PLGFBQWEsSUFBSTtRQUM3QyxJQUFJLENBQUNDLFVBQVUsR0FBR1IsT0FBT1EsVUFBVTtRQUVuQyxpQkFBaUI7UUFDakIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNDLGlCQUFpQixHQUFHLEVBQUU7UUFDM0IsSUFBSSxDQUFDQyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUMxQjtJQUVBLG9EQUFvRDtJQUNwREMsd0JBQXdCO1FBQ3RCLHVDQUF1QztRQUN2QyxNQUFNQyxxQkFBcUJDLFNBQVNDLGdCQUFnQixDQUFDO1FBQ3JERixtQkFBbUJHLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDekIsSUFBSUEsVUFBVUMsVUFBVSxFQUFFO2dCQUN4QkQsVUFBVUMsVUFBVSxDQUFDQyxXQUFXLENBQUNGO1lBQ25DO1FBQ0Y7UUFFQSw4QkFBOEI7UUFDOUIsTUFBTUEsWUFBWUgsU0FBU00sYUFBYSxDQUFDO1FBQ3pDSCxVQUFVSSxTQUFT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QUFJakcsbUJBQW1CQSxnQkFBZ0JRLFVBQVUsRUFBRTtvQkFDakRSLGdCQUFnQlEsVUFBVSxDQUFDQyxXQUFXLENBQUNUO2dCQUN6QztZQUNGLEdBQUc7WUFFSCx1Q0FBdUM7WUFDdkMsSUFBSSxPQUFPLElBQUksQ0FBQ0osVUFBVSxLQUFLLFlBQVk7Z0JBQ3pDLElBQUksQ0FBQ0EsVUFBVTtZQUNqQjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLGlFQUFlVixnQkFBZ0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWxpYnJhdGVIYW5kbGVyLmpzIC0gVGhpcyBzaG91bGQgYmUgcGxhY2VkIGluIHRoZSBjb21wb25lbnRzLWd1aSBmb2xkZXJcbi8vIFRoaXMgaXMgYSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2FsaWJyYXRpb24gZnVuY3Rpb25hbGl0eVxuaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4vQ2FsaWJyYXRlUG9pbnRzJztcblxuY2xhc3MgQ2FsaWJyYXRlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8vIFJlcXVpcmVkIHByb3BlcnRpZXNcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0T3V0cHV0VGV4dCA9IGNvbmZpZy5zZXRPdXRwdXRUZXh0O1xuICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBjb25maWcuY2FwdHVyZUNvdW50IHx8IDE7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSBjb25maWcuY2FwdHVyZUZvbGRlciB8fCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJztcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBjb25maWcub25Db21wbGV0ZTtcbiAgICBcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZVxuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50UG9pbnRJbmRleCA9IDA7XG4gICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cyA9IFtdO1xuICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgICB0aGlzLmNvdW50ZG93bkVsZW1lbnQgPSBudWxsO1xuICB9XG4gIFxuICAvLyBDcmVhdGUgYSBzdGF0dXMgaW5kaWNhdG9yIGluIHRoZSB0b3AgcmlnaHQgY29ybmVyXG4gIGNyZWF0ZVN0YXR1c0luZGljYXRvcigpIHtcbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGluZGljYXRvcnMgZmlyc3RcbiAgICBjb25zdCBleGlzdGluZ0luZGljYXRvcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InKTtcbiAgICBleGlzdGluZ0luZGljYXRvcnMuZm9yRWFjaChpbmRpY2F0b3IgPT4ge1xuICAgICAgaWYgKGluZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGluZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluZGljYXRvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIG5ldyBzdGF0dXMgaW5kaWNhdG9yXG4gICAgY29uc3QgaW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgaW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDEwcHg7XG4gICAgICByaWdodDogMTBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHBhZGRpbmc6IDhweCAxMnB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluZGljYXRvcik7XG4gICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IgPSBpbmRpY2F0b3I7XG4gICAgcmV0dXJuIGluZGljYXRvcjtcbiAgfVxuICBcbiAgLy8gRHJhdyBhIHNwZWNpZmljIGNhbGlicmF0aW9uIHBvaW50XG4gIGRyYXdDYWxpYnJhdGlvblBvaW50KHBvaW50KSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIERyYXcgdGhlIHBvaW50IHdpdGggbGFyZ2VyIHJhZGl1cyBhbmQgZ2xvdyBlZmZlY3RcbiAgICBjb25zdCByYWRpdXMgPSA4O1xuICAgIFxuICAgIC8vIERyYXcgdGhlIGNhbGlicmF0aW9uIHBvaW50XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gQWRkIGdsb3cgZWZmZWN0XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzICsgNCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIHJldHVybiB7IHg6IHBvaW50LngsIHk6IHBvaW50LnkgfTtcbiAgfVxuICBcbiAgLy8gQ3JlYXRlIGEgY291bnRkb3duIGVsZW1lbnQgYWJvdmUgdGhlIGN1cnJlbnQgZG90XG4gIGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9zaXRpb24pIHtcbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtY291bnRkb3duLCAuY2VudGVyLWNvdW50ZG93bi1iYWNrdXAnKTtcbiAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChjb3VudGRvd24gPT4ge1xuICAgICAgaWYgKGNvdW50ZG93bi5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvdW50ZG93bi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gR2V0IGNhbnZhcyBwb3NpdGlvbiBmb3IgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBhYnNvbHV0ZSBwb3NpdGlvblxuICAgIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLng7XG4gICAgY29uc3QgYWJzb2x1dGVZID0gY2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55O1xuICAgIFxuICAgIC8vIENyZWF0ZSBuZXcgY291bnRkb3duIGVsZW1lbnQgcG9zaXRpb25lZCBhYm92ZSB0aGUgZG90XG4gICAgY29uc3QgY291bnRkb3duID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY291bnRkb3duLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICBjb3VudGRvd24uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgICAgdG9wOiAke2Fic29sdXRlWSAtIDYwfXB4O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgY29sb3I6IHJlZDtcbiAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNTBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bik7XG4gICAgdGhpcy5jb3VudGRvd25FbGVtZW50ID0gY291bnRkb3duO1xuICAgIFxuICAgIHJldHVybiB7IGRvdDogY291bnRkb3duIH07XG4gIH1cbiAgXG4gIC8vIENhcHR1cmUgc2NyZWVuIGltYWdlXG4gIGFzeW5jIGNhcHR1cmVTY3JlZW5JbWFnZSgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmZXJlbmNlIGlzIG51bGxcIik7XG4gICAgICBcbiAgICAgIC8vIEZvcm1hdCBmaWxlbmFtZSB3aXRoIGNvdW50ZXJcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSBTdHJpbmcodGhpcy5jYXB0dXJlQ291bnRlcikucGFkU3RhcnQoMywgJzAnKTtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHNjcmVlbl8ke2NvdW50ZXJ9LmpwZ2A7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgaW1hZ2UgZGF0YVxuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgaW1hZ2UgdmlhIEFQSVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICB0eXBlOiAnc2NyZWVuJyxcbiAgICAgICAgICBmb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCBzY3JlZW4gaW1hZ2U6ICR7ZmlsZW5hbWV9YCk7XG4gICAgICBcbiAgICAgIHJldHVybiB7IGRhdGE6IGltYWdlRGF0YSwgcmVzcG9uc2U6IHJlc3VsdCB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIHNjcmVlbiBpbWFnZTpcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG4gIFxuICAvLyBDYXB0dXJlIHdlYmNhbSBpbWFnZSBzaWxlbnRseVxuICBhc3luYyBjYXB0dXJlV2ViY2FtSW1hZ2UoKSB7XG4gICAgbGV0IHN0cmVhbSA9IG51bGw7XG4gICAgbGV0IHRlbXBWaWRlbyA9IG51bGw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEZvcm1hdCBmaWxlbmFtZSB3aXRoIGNvdW50ZXJcbiAgICAgIGNvbnN0IGNvdW50ZXIgPSBTdHJpbmcodGhpcy5jYXB0dXJlQ291bnRlcikucGFkU3RhcnQoMywgJzAnKTtcbiAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHdlYmNhbV8ke2NvdW50ZXJ9LmpwZ2A7XG4gICAgICBcbiAgICAgIC8vIExvb2sgZm9yIGFuIGV4aXN0aW5nIHZpZGVvIGVsZW1lbnQgZmlyc3RcbiAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHdpbmRvdy52aWRlb0VsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICAgIFxuICAgICAgaWYgKHZpZGVvRWxlbWVudCAmJiB2aWRlb0VsZW1lbnQucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSB2aWRlbyBlbGVtZW50IHRoYXQncyBsb2FkZWQsIHVzZSBpdFxuICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB2aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgICBcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlb0VsZW1lbnQsIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW1hZ2VcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICB0eXBlOiAnd2ViY2FtJyxcbiAgICAgICAgICAgIGZvbGRlcjogdGhpcy5jYXB0dXJlRm9sZGVyXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHdlYmNhbSBpbWFnZTogJHtmaWxlbmFtZX1gKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGRhdGE6IGltYWdlRGF0YSwgcmVzcG9uc2U6IHJlc3VsdCB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJZiBubyB2aWRlbyBlbGVtZW50LCBjcmVhdGUgYSB0ZW1wb3Jhcnkgb25lXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3RyZWFtIGZvciBqdXN0IHRoaXMgY2FwdHVyZVxuICAgICAgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBcbiAgICAgICAgdmlkZW86IHRydWUsIFxuICAgICAgICBhdWRpbzogZmFsc2UgXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgaGlkZGVuIHZpZGVvIGVsZW1lbnQgdG8gcmVjZWl2ZSB0aGUgc3RyZWFtXG4gICAgICB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgIHRlbXBWaWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICB0ZW1wVmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgdGVtcFZpZGVvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHRlbXBWaWRlby5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnO1xuICAgICAgdGVtcFZpZGVvLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gICAgICBcbiAgICAgIC8vIFNldCB0aGUgc3RyZWFtIHRvIHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciB2aWRlbyB0byBpbml0aWFsaXplXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJWaWRlbyBsb2FkaW5nIHRpbWVkIG91dCwgY29udGludWluZyBhbnl3YXlcIik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgXG4gICAgICAgIHRlbXBWaWRlby5vbmxvYWRlZGRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBhIGNsZWFyIGZyYW1lXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHZpZGVvIGRpbWVuc2lvbnMgYXJlIHZhbGlkXG4gICAgICBpZiAodGVtcFZpZGVvLnZpZGVvV2lkdGggPT09IDAgfHwgdGVtcFZpZGVvLnZpZGVvSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlZpZGVvIGRpbWVuc2lvbnMgYXJlIGludmFsaWQsIHVzaW5nIGRlZmF1bHQgZGltZW5zaW9uc1wiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSB0aGUgZnJhbWUgdG8gYSBjYW52YXNcbiAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHRlbXBDYW52YXMud2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCA2NDA7XG4gICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCA0ODA7XG4gICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBpbWFnZSBkYXRhXG4gICAgICBjb25zdCBpbWFnZURhdGEgPSB0ZW1wQ2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdGhlIGltYWdlIHZpYSBBUElcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgdHlwZTogJ3dlYmNhbScsXG4gICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgd2ViY2FtIGltYWdlOiAke2ZpbGVuYW1lfWApO1xuICAgICAgXG4gICAgICByZXR1cm4geyBkYXRhOiBpbWFnZURhdGEsIHJlc3BvbnNlOiByZXN1bHQgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhcHR1cmluZyB3ZWJjYW0gaW1hZ2U6XCIsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIHJlc3BvbnNlOiBudWxsIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIElNUE9SVEFOVDogQ2xlYW4gdXAgcmVzb3VyY2VzIGV2ZW4gaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0ZW1wVmlkZW8pIHtcbiAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgIGlmICh0ZW1wVmlkZW8ucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRlbXBWaWRlby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNhdmUgcGFyYW1ldGVyIENTVlxuICBhc3luYyBzYXZlUGFyYW1ldGVyQ1NWKHBvaW50LCBpbmRleCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBGb3JtYXQgZmlsZW5hbWUgd2l0aCBjb3VudGVyXG4gICAgICBjb25zdCBjb3VudGVyID0gU3RyaW5nKHRoaXMuY2FwdHVyZUNvdW50ZXIpLnBhZFN0YXJ0KDMsICcwJyk7XG4gICAgICBjb25zdCBmaWxlbmFtZSA9IGBwYXJhbWV0ZXJfJHtjb3VudGVyfS5jc3ZgO1xuICAgICAgXG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgQ1NWIGNvbnRlbnQgd2l0aCB0d28gY29sdW1uczogbmFtZSBhbmQgdmFsdWVcbiAgICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICAgIFwibmFtZSx2YWx1ZVwiLFxuICAgICAgICBgZG90X3gsJHtwb2ludC54fWAsXG4gICAgICAgIGBkb3RfeSwke3BvaW50Lnl9YCxcbiAgICAgICAgYGNhbnZhc193aWR0aCwke2NhbnZhcyA/IGNhbnZhcy53aWR0aCA6IDB9YCxcbiAgICAgICAgYGNhbnZhc19oZWlnaHQsJHtjYW52YXMgPyBjYW52YXMuaGVpZ2h0IDogMH1gLFxuICAgICAgICBgd2luZG93X3dpZHRoLCR7d2luZG93LmlubmVyV2lkdGh9YCxcbiAgICAgICAgYHdpbmRvd19oZWlnaHQsJHt3aW5kb3cuaW5uZXJIZWlnaHR9YCxcbiAgICAgICAgYGNhbGlicmF0aW9uX3BvaW50X2luZGV4LCR7aW5kZXh9YCxcbiAgICAgICAgYGNhbGlicmF0aW9uX3BvaW50X2xhYmVsLCR7cG9pbnQubGFiZWwgfHwgJyd9YCxcbiAgICAgICAgYHRpbWVzdGFtcCwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IENTViB0byBkYXRhIFVSTFxuICAgICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgICAgY29uc3QgY3N2UmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIFxuICAgICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNzdlJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKGNzdlJlYWRlci5yZXN1bHQpO1xuICAgICAgICBjc3ZSZWFkZXIucmVhZEFzRGF0YVVSTChjc3ZCbG9iKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBTYXZlIENTViB1c2luZyB0aGUgQVBJXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgaW1hZ2VEYXRhOiBjc3ZEYXRhVXJsLFxuICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgIHR5cGU6ICdwYXJhbWV0ZXJzJyxcbiAgICAgICAgICBmb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCBwYXJhbWV0ZXIgQ1NWOiAke2ZpbGVuYW1lfWApO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHBhcmFtZXRlciBDU1Y6XCIsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gU2hvdyBwcmV2aWV3IG9mIGNhcHR1cmVkIGltYWdlcyAtIG1hZGUgaWRlbnRpY2FsIHRvIFdoaXRlU2NyZWVuTWFpbiBpbXBsZW1lbnRhdGlvblxuICBzaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlLCBwb2ludCkge1xuICAgIGlmICghc2NyZWVuSW1hZ2UgJiYgIXdlYmNhbUltYWdlKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJObyBpbWFnZXMgYXZhaWxhYmxlIHRvIHByZXZpZXdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBwcmV2aWV3IGNvbnRhaW5lcnMgZmlyc3QgKGluIGNhc2Ugb2Ygb3ZlcmxhcHBpbmcpXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJldmlld3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcicpO1xuICAgICAgZXhpc3RpbmdQcmV2aWV3cy5mb3JFYWNoKHByZXZpZXcgPT4ge1xuICAgICAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJSZW1vdmluZyBleGlzdGluZyBwcmV2aWV3IGNvbnRhaW5lclwiKTtcbiAgICAgICAgICBwcmV2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlldyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNsZWFuaW5nIHVwIGV4aXN0aW5nIHByZXZpZXdzOlwiLCBjbGVhbnVwRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgcHJldmlldyBjb250YWluZXIgd2l0aCB6LWluZGV4IGhpZ2hlciB0aGFuIGV2ZXJ5dGhpbmcgZWxzZVxuICAgIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYXB0dXJlLXByZXZpZXctY29udGFpbmVyJztcbiAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDUwJTtcbiAgICAgIGxlZnQ6IDUwJTtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGdhcDogMjBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICBwYWRkaW5nOiAyMHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgIGA7XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJQcmV2aWV3IGNvbnRhaW5lciBjcmVhdGVkXCIpO1xuICAgIFxuICAgIC8vIEFkZCBkZWJ1ZyBpbmZvIGRpdlxuICAgIGNvbnN0IGRlYnVnSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlYnVnSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAtMzBweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBgO1xuICAgIGRlYnVnSW5mby50ZXh0Q29udGVudCA9IGBTY3JlZW46ICR7c2NyZWVuSW1hZ2UgPyAnWUVTJyA6ICdOTyd9LCBXZWJjYW06ICR7d2ViY2FtSW1hZ2UgPyAnWUVTJyA6ICdOTyd9YDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKGRlYnVnSW5mbyk7XG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gYWRkIGFuIGltYWdlIHRvIHRoZSBwcmV2aWV3XG4gICAgY29uc3QgYWRkSW1hZ2VQcmV2aWV3ID0gKGltYWdlLCBsYWJlbCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyAke2xhYmVsfSBwcmV2aWV3LCBpbWFnZSBkYXRhIGxlbmd0aDogJHtpbWFnZSA/IGltYWdlLmxlbmd0aCA6ICdOL0EnfWApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlO1xuICAgICAgICBpbWcuYWx0ID0gbGFiZWw7XG4gICAgICAgIGltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICAvLyBFdmVudCBsaXN0ZW5lcnMgZm9yIGltYWdlIGxvYWRpbmdcbiAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IGNvbnNvbGUubG9nKGAke2xhYmVsfSBpbWFnZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IGNvbnNvbGUuZXJyb3IoYEVycm9yIGxvYWRpbmcgJHtsYWJlbH0gaW1hZ2U6YCwgZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsYWJlbEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbGFiZWxFbGVtZW50LnRleHRDb250ZW50ID0gbGFiZWw7XG4gICAgICAgIGxhYmVsRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZChsYWJlbEVsZW1lbnQpO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHByZXZpZXcpO1xuICAgICAgICBjb25zb2xlLmxvZyhgJHtsYWJlbH0gcHJldmlldyBlbGVtZW50IGFkZGVkIHRvIGNvbnRhaW5lcmApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGFkZGluZyAke2xhYmVsfSBwcmV2aWV3OmAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIGJvdGggaW1hZ2VzIHRvIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBhZGRJbWFnZVByZXZpZXcoc2NyZWVuSW1hZ2UsICdTY3JlZW4gQ2FwdHVyZScpO1xuICAgIH1cbiAgICBcbiAgICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICAgIGFkZEltYWdlUHJldmlldyh3ZWJjYW1JbWFnZSwgJ1dlYmNhbSBDYXB0dXJlJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkb3QgcG9zaXRpb24gaW5mbyBpZiBhdmFpbGFibGVcbiAgICBpZiAocG9pbnQpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9zaXRpb25JbmZvLnRleHRDb250ZW50ID0gcG9pbnQubGFiZWwgP1xuICAgICAgICBgJHtwb2ludC5sYWJlbH06IHg9JHtNYXRoLnJvdW5kKHBvaW50LngpfSwgeT0ke01hdGgucm91bmQocG9pbnQueSl9YCA6XG4gICAgICAgIGBEb3QgcG9zaXRpb246IHg9JHtNYXRoLnJvdW5kKHBvaW50LngpfSwgeT0ke01hdGgucm91bmQocG9pbnQueSl9YDtcbiAgICAgIHBvc2l0aW9uSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogI2ZmY2MwMDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTUwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3NpdGlvbkluZm8pO1xuICAgICAgY29uc29sZS5sb2coXCJEb3QgcG9zaXRpb24gaW5mbyBhZGRlZFwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGNvdW50ZG93biB0aW1lclxuICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgXG4gICAgLy8gQWRkIHRvIGRvY3VtZW50IGJvZHlcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUHJldmlldyBjb250YWluZXIgYWRkZWQgdG8gRE9NXCIpO1xuICAgIH0gY2F0Y2ggKGFwcGVuZEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHByZXZpZXcgY29udGFpbmVyIHRvIERPTTpcIiwgYXBwZW5kRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb3VudGRvd24gYW5kIHJlbW92ZSB0aGUgcHJldmlldyBhZnRlciAyIHNlY29uZHNcbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMC4zcyBlYXNlJztcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbW92aW5nIHByZXZpZXcgY29udGFpbmVyIGZyb20gRE9NXCIpO1xuICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICAvLyBTYWZldHkgY2xlYW51cCBhZnRlciA1IHNlY29uZHMgaW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2FmZXR5IGNsZWFudXAgb2YgcHJldmlldyBjb250YWluZXJcIik7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9LCA1MDAwKTtcbiAgfVxuICBcbiAgLy8gUnVuIHRoZSBjb3VudGRvd24gYW5pbWF0aW9uIGZvciBhIHBvaW50IC0gc2ltcGxpZmllZCB0byBvbmx5IHNob3cgY291bnRkb3duIGFib3ZlIGRvdFxuICBhc3luYyBydW5Db3VudGRvd24ocG9pbnQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIENyZWF0ZSBjb3VudGRvd24gZWxlbWVudFxuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnRzID0gdGhpcy5jcmVhdGVDb3VudGRvd25FbGVtZW50KHBvaW50KTtcbiAgICBpZiAoIWNvdW50ZG93bkVsZW1lbnRzKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgY29uc3QgeyBkb3Q6IGNvdW50ZG93bkVsZW1lbnQgfSA9IGNvdW50ZG93bkVsZW1lbnRzO1xuICAgIFxuICAgIC8vIFJ1biAzLTItMSBjb3VudGRvd25cbiAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgLy8gVXBkYXRlIGNvdW50ZG93biBkaXNwbGF5XG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRlIFNldCBBY3RpdmU6IGNvdW50ZG93biAke2NvdW50fSAoJHtpbmRleCArIDF9LyR7dG90YWx9KWA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBvdXRwdXQgdGV4dCBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh0aGlzLnNldE91dHB1dFRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0KGBDYWxpYnJhdGlvbiBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH0gLSBjb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdGhlIG5leHQgY291bnRkb3duIHN0ZXBcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICB9XG4gICAgXG4gICAgLy8gU2hvdyBjYXB0dXJpbmcgaW5kaWNhdG9yIGJyaWVmbHlcbiAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICBcbiAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhcHR1cmluZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgY2FwdHVyZSB0byBvbmx5IHNob3cgdGhlIGRvdFxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBzZWUgT05MWSB0aGUgcmVkIGRvdCBhZnRlciBjYXB0dXJlLCBub3QgdGhlIGNvdW50ZG93biBpbmRpY2F0b3JzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LCAzMDApO1xuICAgIFxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIFxuICAvLyBQcm9jZXNzIGEgc2luZ2xlIGNhbGlicmF0aW9uIHBvaW50XG4gIGFzeW5jIHByb2Nlc3NDYWxpYnJhdGlvblBvaW50KHBvaW50LCBpbmRleCwgdG90YWwpIHtcbiAgICB0cnkge1xuICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgIHRoaXMuZHJhd0NhbGlicmF0aW9uUG9pbnQocG9pbnQpO1xuICAgICAgXG4gICAgICAvLyBSdW4gY291bnRkb3duIGFuaW1hdGlvbiAtIHNhbWUgYXMgUmFuZG9tRG90XG4gICAgICBhd2FpdCB0aGlzLnJ1bkNvdW50ZG93bihwb2ludCwgaW5kZXgsIHRvdGFsKTtcbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSBzY3JlZW4gaW1hZ2VcbiAgICAgIGNvbnN0IHNjcmVlblJlc3VsdCA9IGF3YWl0IHRoaXMuY2FwdHVyZVNjcmVlbkltYWdlKCk7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgd2ViY2FtIGltYWdlXG4gICAgICBjb25zdCB3ZWJjYW1SZXN1bHQgPSBhd2FpdCB0aGlzLmNhcHR1cmVXZWJjYW1JbWFnZSgpO1xuICAgICAgXG4gICAgICAvLyBTYXZlIHBhcmFtZXRlciBDU1ZcbiAgICAgIGF3YWl0IHRoaXMuc2F2ZVBhcmFtZXRlckNTVihwb2ludCwgaW5kZXgpO1xuICAgICAgXG4gICAgICAvLyBJbmNyZW1lbnQgY2FwdHVyZSBjb3VudGVyIGZvciBuZXh0IGNhcHR1cmVcbiAgICAgIGlmICh0aGlzLnNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJuZWQgYSBuZXcgY2FwdHVyZSBudW1iZXIsIHVzZSBpdFxuICAgICAgICBpZiAoc2NyZWVuUmVzdWx0LnJlc3BvbnNlICYmIHNjcmVlblJlc3VsdC5yZXNwb25zZS5jYXB0dXJlTnVtYmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gc2NyZWVuUmVzdWx0LnJlc3BvbnNlLmNhcHR1cmVOdW1iZXIgKyAxO1xuICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIodGhpcy5jYXB0dXJlQ291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlcisrO1xuICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIodGhpcy5jYXB0dXJlQ291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBwcmV2aWV3XG4gICAgICB0aGlzLnNob3dDYXB0dXJlUHJldmlldyhcbiAgICAgICAgc2NyZWVuUmVzdWx0LmRhdGEsXG4gICAgICAgIHdlYmNhbVJlc3VsdCA/IHdlYmNhbVJlc3VsdC5kYXRhIDogbnVsbCxcbiAgICAgICAgcG9pbnRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHByZXZpZXcgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMzAwKSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aW5kZXggKyAxfTpgLCBlcnJvcik7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0aGlzLnNldE91dHB1dFRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0KGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIFxuICAvLyBTdGFydCB0aGUgZnVsbCBjYWxpYnJhdGlvbiBzZXF1ZW5jZVxuICBhc3luYyBzdGFydENhbGlicmF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgSU1NRURJQVRFTFkgKGZpcnN0IGFjdGlvbilcbiAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNtYWxsIGRlbGF5IHRvIGVuc3VyZSBVSSB1cGRhdGVzXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHN0YXR1cyBpbmRpY2F0b3JcbiAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSB0aGlzLmNyZWF0ZVN0YXR1c0luZGljYXRvcigpO1xuICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGUgU2V0IEFjdGl2ZTogSW5pdGlhbGl6aW5nLi4uJztcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHJlYWR5Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzJyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIGlmICh0aGlzLnNldE91dHB1dFRleHQpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0KGBTdGFydGluZyBjYWxpYnJhdGlvbiB3aXRoICR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2ApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnQgaW4gc2VxdWVuY2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgUHJvY2Vzc2luZyBwb2ludCAke2kgKyAxfS8ke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofWA7XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIGN1cnJlbnQgcG9pbnRcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMucHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQoXG4gICAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50c1tpXSxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBwcm9jZXNzaW5nIGZhaWxlZCwgc3RvcCB0aGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBwb2ludCAke2kgKyAxfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb24gY29tcGxldGVkJztcbiAgICAgIFxuICAgICAgaWYgKHRoaXMuc2V0T3V0cHV0VGV4dCkge1xuICAgICAgICB0aGlzLnNldE91dHB1dFRleHQoJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbGlicmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGhpcy5zZXRPdXRwdXRUZXh0KSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dChgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IgJiYgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDAwKTtcbiAgICAgIFxuICAgICAgLy8gQ2FsbCBvbkNvbXBsZXRlIGNhbGxiYWNrIGlmIHByb3ZpZGVkXG4gICAgICBpZiAodHlwZW9mIHRoaXMub25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FsaWJyYXRlSGFuZGxlcjsiXSwibmFtZXMiOlsiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImNhbnZhc1JlZiIsInRvZ2dsZVRvcEJhciIsInNldE91dHB1dFRleHQiLCJjYXB0dXJlQ291bnRlciIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsIm9uQ29tcGxldGUiLCJpc1Byb2Nlc3NpbmciLCJjdXJyZW50UG9pbnRJbmRleCIsImNhbGlicmF0aW9uUG9pbnRzIiwic3RhdHVzSW5kaWNhdG9yIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZVN0YXR1c0luZGljYXRvciIsImV4aXN0aW5nSW5kaWNhdG9ycyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpbmRpY2F0b3IiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwiZHJhd0NhbGlicmF0aW9uUG9pbnQiLCJwb2ludCIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInJhZGl1cyIsImJlZ2luUGF0aCIsImFyYyIsIngiLCJ5IiwiTWF0aCIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInBvc2l0aW9uIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiY291bnRkb3duIiwiY2FudmFzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImFic29sdXRlWCIsImxlZnQiLCJhYnNvbHV0ZVkiLCJ0b3AiLCJkb3QiLCJjYXB0dXJlU2NyZWVuSW1hZ2UiLCJFcnJvciIsImNvdW50ZXIiLCJTdHJpbmciLCJwYWRTdGFydCIsImZpbGVuYW1lIiwiaW1hZ2VEYXRhIiwidG9EYXRhVVJMIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwidHlwZSIsImZvbGRlciIsIm9rIiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsImNvbnNvbGUiLCJsb2ciLCJkYXRhIiwiZXJyb3IiLCJjYXB0dXJlV2ViY2FtSW1hZ2UiLCJzdHJlYW0iLCJ0ZW1wVmlkZW8iLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwicmVhZHlTdGF0ZSIsInRlbXBDYW52YXMiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsImF1ZGlvIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwib3BhY2l0eSIsInNyY09iamVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGltZW91dElkIiwic2V0VGltZW91dCIsIndhcm4iLCJvbmxvYWRlZGRhdGEiLCJjbGVhclRpbWVvdXQiLCJnZXRUcmFja3MiLCJ0cmFjayIsInN0b3AiLCJzYXZlUGFyYW1ldGVyQ1NWIiwiaW5kZXgiLCJjc3ZEYXRhIiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwibGFiZWwiLCJEYXRlIiwidG9JU09TdHJpbmciLCJqb2luIiwiY3N2QmxvYiIsIkJsb2IiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlYWRBc0RhdGFVUkwiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiZXhpc3RpbmdQcmV2aWV3cyIsInByZXZpZXciLCJjbGVhbnVwRXJyb3IiLCJwcmV2aWV3Q29udGFpbmVyIiwiZGVidWdJbmZvIiwidGV4dENvbnRlbnQiLCJhZGRJbWFnZVByZXZpZXciLCJpbWFnZSIsImxlbmd0aCIsImltZyIsInNyYyIsImFsdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJlIiwibGFiZWxFbGVtZW50IiwicG9zaXRpb25JbmZvIiwicm91bmQiLCJ0aW1lckVsZW1lbnQiLCJhcHBlbmRFcnJvciIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ0cmFuc2l0aW9uIiwidG9GaXhlZCIsInJ1bkNvdW50ZG93biIsInRvdGFsIiwiY291bnRkb3duRWxlbWVudHMiLCJjb3VudCIsInByb2Nlc3NDYWxpYnJhdGlvblBvaW50Iiwic2NyZWVuUmVzdWx0Iiwid2ViY2FtUmVzdWx0IiwiY2FwdHVyZU51bWJlciIsInVuZGVmaW5lZCIsIm1lc3NhZ2UiLCJzdGFydENhbGlicmF0aW9uIiwiaSIsInN1Y2Nlc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js\n");

/***/ })

};
;