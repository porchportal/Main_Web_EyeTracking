"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_pages_collected-dataset_components-gui_Action_CalibrateHandler_js";
exports.ids = ["_pages-dir-node_pages_collected-dataset_components-gui_Action_CalibrateHandler_js"];
exports.modules = {

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CalibrateHandler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/countSave.js\");\n// CalibrateHandler.js - Handles the calibration process\n\n\nclass CalibrateHandler {\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      background-color: rgba(0, 102, 204, 0.9);\n      color: white;\n      font-size: 14px;\n      font-weight: bold;\n      padding: 8px 12px;\n      border-radius: 6px;\n      z-index: 9999;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n    `;\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            const canvas = this.canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Processing point ${index + 1}/${total}`;\n            }\n            await (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.captureAndPreviewProcess)({\n                canvasRef: this.canvasRef,\n                position: point,\n                captureCounter: this.captureCounter,\n                saveImageToServer: async (imageData, filename, type, folder)=>{\n                    const response = await fetch('/api/save-capture', {\n                        method: 'POST',\n                        headers: {\n                            'Content-Type': 'application/json'\n                        },\n                        body: JSON.stringify({\n                            imageData,\n                            filename,\n                            type,\n                            folder: this.captureFolder\n                        })\n                    });\n                    if (!response.ok) {\n                        throw new Error(`Server error: ${response.status}`);\n                    }\n                    return await response.json();\n                },\n                setCaptureCounter: (newCounter)=>{\n                    this.captureCounter = newCounter;\n                    this.setCaptureCounter?.(newCounter);\n                },\n                setProcessStatus: (status)=>{\n                    this.setOutputText?.(status);\n                },\n                toggleTopBar: this.toggleTopBar,\n                onStatusUpdate: (status)=>{\n                    const msg = typeof status === 'string' ? status : `Point ${index + 1}/${total} - ${status.countdownValue || status.processStatus}`;\n                    this.setOutputText?.(msg);\n                },\n                captureFolder: this.captureFolder\n            });\n            return true;\n        } catch (err) {\n            console.error(`Error processing point ${index + 1}:`, err);\n            this.statusIndicator.textContent = `Error: ${err.message}`;\n            this.setOutputText?.(`Error: ${err.message}`);\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        this.toggleTopBar?.(false);\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            this.setOutputText?.(`Starting calibration with ${this.calibrationPoints.length} points`);\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (!success) break;\n            }\n            this.setOutputText?.('Calibration completed');\n            this.statusIndicator.textContent = 'Calibration completed';\n            this.toggleTopBar?.(true);\n            this.onComplete?.();\n        } catch (error) {\n            console.error('Calibration error:', error);\n            this.setOutputText?.(`Calibration error: ${error.message}`);\n            this.statusIndicator.textContent = `Error: ${error.message}`;\n            this.toggleTopBar?.(true);\n        } finally{\n            this.isProcessing = false;\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHdEQUF3RDtBQUNNO0FBSXpDO0FBRXJCLE1BQU1HO0lBQ0pDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNDLFNBQVMsR0FBR0QsT0FBT0MsU0FBUztRQUNqQyxJQUFJLENBQUNDLFlBQVksR0FBR0YsT0FBT0UsWUFBWTtRQUN2QyxJQUFJLENBQUNDLGFBQWEsR0FBR0gsT0FBT0csYUFBYTtRQUN6QyxJQUFJLENBQUNDLGNBQWMsR0FBR0osT0FBT0ksY0FBYyxJQUFJO1FBQy9DLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdMLE9BQU9LLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNDLGFBQWEsR0FBR04sT0FBT00sYUFBYSxJQUFJO1FBQzdDLElBQUksQ0FBQ0MsVUFBVSxHQUFHUCxPQUFPTyxVQUFVO1FBRW5DLG1FQUFtRTtRQUNuRSxJQUFJLENBQUNDLGlCQUFpQixHQUFHUixPQUFPUSxpQkFBaUIsSUFBSSxFQUFFO1FBRXZELFlBQVk7UUFDWixJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO0lBQ3pCO0lBRUFDLHdCQUF3QjtRQUN0QixNQUFNQyxxQkFBcUJDLFNBQVNDLGdCQUFnQixDQUFDO1FBQ3JERixtQkFBbUJHLE9BQU8sQ0FBQ0MsQ0FBQUEsWUFBYUEsVUFBVUMsTUFBTTtRQUV4RCxNQUFNRCxZQUFZSCxTQUFTSyxhQUFhLENBQUM7UUFDekNGLFVBQVVHLFNBQVMsR0FBRztRQUN0QkgsVUFBVUksS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7O0lBWTNCLENBQUM7UUFDRFIsU0FBU1MsSUFBSSxDQUFDQyxXQUFXLENBQUNQO1FBQzFCLElBQUksQ0FB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LE1BQU1DLE9BQU8sRUFBRTtZQUMxRCxJQUFJLENBQUNsRCxlQUFlLENBQUN5QixXQUFXLEdBQUcsQ0FBQyxPQUFPLEVBQUV3QixNQUFNQyxPQUFPLEVBQUU7WUFDNUQsSUFBSSxDQUFDM0QsWUFBWSxHQUFHO1FBQ3RCLFNBQVU7WUFDUixJQUFJLENBQUNPLFlBQVksR0FBRztRQUN0QjtJQUNGO0FBQ0Y7QUFFQSxpRUFBZVgsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlSGFuZGxlci5qcyAtIEhhbmRsZXMgdGhlIGNhbGlicmF0aW9uIHByb2Nlc3NcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQge1xuICBkcmF3UmVkRG90LFxuICBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Ncbn0gZnJvbSAnLi9jb3VudFNhdmUnO1xuXG5jbGFzcyBDYWxpYnJhdGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldE91dHB1dFRleHQgPSBjb25maWcuc2V0T3V0cHV0VGV4dDtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyIHx8IDE7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSBjb25maWcuY2FwdHVyZUZvbGRlciB8fCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJztcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBjb25maWcub25Db21wbGV0ZTtcblxuICAgIC8vIEFjY2VwdCBwYXNzZWQtaW4gY2FsaWJyYXRpb24gcG9pbnRzIChmcm9tIFNldENhbGlicmF0ZUFjdGlvbi5qcylcbiAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gY29uZmlnLmNhbGlicmF0aW9uUG9pbnRzIHx8IFtdO1xuXG4gICAgLy8gSW50ZXJuYWxzXG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRQb2ludEluZGV4ID0gMDtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gIH1cblxuICBjcmVhdGVTdGF0dXNJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJbmRpY2F0b3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJyk7XG4gICAgZXhpc3RpbmdJbmRpY2F0b3JzLmZvckVhY2goaW5kaWNhdG9yID0+IGluZGljYXRvci5yZW1vdmUoKSk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICBpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIHRvcDogMTBweDtcbiAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IGluZGljYXRvcjtcbiAgICByZXR1cm4gaW5kaWNhdG9yO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQocG9pbnQsIGluZGV4LCB0b3RhbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXBvaW50IHx8IHR5cGVvZiBwb2ludC54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9pbnQueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYWxpYnJhdGlvbiBwb2ludFwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgUHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgICBjYW52YXNSZWY6IHRoaXMuY2FudmFzUmVmLFxuICAgICAgICBwb3NpdGlvbjogcG9pbnQsXG4gICAgICAgIGNhcHR1cmVDb3VudGVyOiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICBzYXZlSW1hZ2VUb1NlcnZlcjogYXN5bmMgKGltYWdlRGF0YSwgZmlsZW5hbWUsIHR5cGUsIGZvbGRlcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlcnZlciBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IG5ld0NvdW50ZXI7XG4gICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcj8uKG5ld0NvdW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oc3RhdHVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyOiB0aGlzLnRvZ2dsZVRvcEJhcixcbiAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBjb25zdCBtc2cgPSB0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJyA/IHN0YXR1cyA6IGBQb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH0gLSAke3N0YXR1cy5jb3VudGRvd25WYWx1ZSB8fCBzdGF0dXMucHJvY2Vzc1N0YXR1c31gO1xuICAgICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKG1zZyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmVGb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX06YCwgZXJyKTtcbiAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RhcnRDYWxpYnJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgICB0aGlzLnRvZ2dsZVRvcEJhcj8uKGZhbHNlKTtcblxuICAgIGNvbnN0IGluZGljYXRvciA9IHRoaXMuY3JlYXRlU3RhdHVzSW5kaWNhdG9yKCk7XG4gICAgaW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0luaXRpYWxpemluZyBjYWxpYnJhdGlvbi4uLic7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCByZWFkeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IGdlbmVyYXRlIGlmIG5vbmUgd2VyZSBwYXNzZWQgaW5cbiAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBTdGFydGluZyBjYWxpYnJhdGlvbiB3aXRoICR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2ApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMucHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQodGhpcy5jYWxpYnJhdGlvblBvaW50c1tpXSwgaSwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoIXN1Y2Nlc3MpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LignQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnO1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXI/Lih0cnVlKTtcbiAgICAgIHRoaXMub25Db21wbGV0ZT8uKCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ2FsaWJyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcj8uKHRydWUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWxpYnJhdGVIYW5kbGVyOyJdLCJuYW1lcyI6WyJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZHJhd1JlZERvdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImNhbnZhc1JlZiIsInRvZ2dsZVRvcEJhciIsInNldE91dHB1dFRleHQiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsIm9uQ29tcGxldGUiLCJjYWxpYnJhdGlvblBvaW50cyIsImlzUHJvY2Vzc2luZyIsImN1cnJlbnRQb2ludEluZGV4Iiwic3RhdHVzSW5kaWNhdG9yIiwiY3JlYXRlU3RhdHVzSW5kaWNhdG9yIiwiZXhpc3RpbmdJbmRpY2F0b3JzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImluZGljYXRvciIsInJlbW92ZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludCIsInBvaW50IiwiaW5kZXgiLCJ0b3RhbCIsIngiLCJ5IiwiRXJyb3IiLCJjYW52YXMiLCJjdXJyZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsInRleHRDb250ZW50IiwicG9zaXRpb24iLCJzYXZlSW1hZ2VUb1NlcnZlciIsImltYWdlRGF0YSIsImZpbGVuYW1lIiwidHlwZSIsImZvbGRlciIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwic3RhdHVzIiwianNvbiIsIm5ld0NvdW50ZXIiLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJtc2ciLCJjb3VudGRvd25WYWx1ZSIsInByb2Nlc3NTdGF0dXMiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhcnRDYWxpYnJhdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibGVuZ3RoIiwiaSIsInN1Y2Nlc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/countSave.js":
/*!********************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/countSave.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n// countSave.js\n// Shared functionality for countdown and image capture processes\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @param {Function} onComplete - Callback to execute when countdown finishes\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = `\n      position: fixed;\n      left: ${absoluteX}px;\n      top: ${absoluteY - 60}px;\n      transform: translateX(-50%);\n      color: red;\n      font-size: 36px;\n      font-weight: bold;\n      text-shadow: 0 0 10px white, 0 0 20px white;\n      z-index: 9999;\n      background-color: rgba(255, 255, 255, 0.8);\n      border: 2px solid red;\n      border-radius: 50%;\n      width: 50px;\n      height: 50px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    `;\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate?.({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate?.({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate?.({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    if (position && typeof position.x === 'number' && typeof position.y === 'number') {\n                        drawRedDot(ctx, position.x, position.y);\n                    } else {\n                        console.warn(\"[runCountdown] Position is null after countdown\", position);\n                    }\n                    if (onComplete) {\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate?.({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n   * Captures images from both canvas and webcam\n   * @param {Object} options - Capture options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {string} options.captureFolder - Folder to save captures in\n   * @returns {Object} - Result with captured image data\n   */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    try {\n        const counter = String(captureCounter).padStart(3, '0');\n        const screenFilename = `screen_${counter}.jpg`;\n        const webcamFilename = `webcam_${counter}.jpg`;\n        const parameterFilename = `parameter_${counter}.csv`;\n        console.log(`Starting capture process with counter: ${counter}`);\n        console.log(`Dot position: x=${position.x}, y=${position.y}`);\n        let screenImageData = null;\n        let webcamImageData = null;\n        let usedCaptureNumber = captureCounter;\n        // === 1. Capture screen image from canvas ===\n        const canvas = canvasRef.current;\n        if (canvas) {\n            try {\n                const ctx = canvas.getContext('2d');\n                // ✅ Make sure the red dot is drawn RIGHT before screen capture\n                drawRedDot(ctx, position.x, position.y);\n                console.log(`Canvas dimensions: ${canvas.width}x${canvas.height}`);\n                screenImageData = canvas.toDataURL('image/png');\n                console.log(`Screen image captured, size: ${screenImageData.length} chars`);\n                if (saveImageToServer) {\n                    const screenResponse = await saveImageToServer(screenImageData, screenFilename, 'screen', captureFolder);\n                    if (screenResponse && screenResponse.captureNumber) {\n                        usedCaptureNumber = screenResponse.captureNumber;\n                        console.log(`Server assigned capture number: ${usedCaptureNumber}`);\n                    }\n                }\n            } catch (screenError) {\n                console.error(\"Error capturing or saving screen image:\", screenError);\n            }\n        } else {\n            console.error(\"Canvas reference is null, cannot capture screen\");\n        }\n        // === 2. Capture webcam image ===\n        try {\n            console.log(\"Attempting to capture webcam silently\");\n            const videoElement = window.videoElement || document.querySelector('video');\n            if (videoElement && videoElement.readyState >= 2) {\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = videoElement.videoWidth || 640;\n                tempCanvas.height = videoElement.videoHeight || 480;\n                ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, `webcam_${String(usedCaptureNumber).padStart(3, '0')}.jpg`, 'webcam', captureFolder);\n                }\n            } else {\n                const stream = await navigator.mediaDevices.getUserMedia({\n                    video: true,\n                    audio: false\n                });\n                const tempVideo = document.createElement('video');\n                tempVideo.autoplay = true;\n                tempVideo.playsInline = true;\n                tempVideo.muted = true;\n                tempVideo.style.position = 'absolute';\n                tempVideo.style.left = '-9999px';\n                tempVideo.style.opacity = '0';\n                document.body.appendChild(tempVideo);\n                tempVideo.srcObject = stream;\n                await new Promise((resolve)=>{\n                    const timeoutId = setTimeout(resolve, 1000);\n                    tempVideo.onloadeddata = ()=>{\n                        clearTimeout(timeoutId);\n                        resolve();\n                    };\n                });\n                await new Promise((resolve)=>setTimeout(resolve, 200));\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = tempVideo.videoWidth || 640;\n                tempCanvas.height = tempVideo.videoHeight || 480;\n                ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, `webcam_${String(usedCaptureNumber).padStart(3, '0')}.jpg`, 'webcam', captureFolder);\n                }\n                stream.getTracks().forEach((track)=>track.stop());\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        } catch (webcamError) {\n            console.error(\"Error capturing webcam silently:\", webcamError);\n        }\n        // === 3. Save parameter CSV ===\n        try {\n            console.log(\"Creating parameter CSV\");\n            const csvData = [\n                \"name,value\",\n                `dot_x,${position.x}`,\n                `dot_y,${position.y}`,\n                `canvas_width,${canvas ? canvas.width : 0}`,\n                `canvas_height,${canvas ? canvas.height : 0}`,\n                `window_width,${window.innerWidth}`,\n                `window_height,${window.innerHeight}`,\n                `timestamp,${new Date().toISOString()}`\n            ].join('\\n');\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            if (saveImageToServer) {\n                await saveImageToServer(csvDataUrl, `parameter_${String(usedCaptureNumber).padStart(3, '0')}.csv`, 'parameters', captureFolder);\n            }\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n        }\n        // === 4. Update counter ===\n        if (setCaptureCounter) {\n            setCaptureCounter(usedCaptureNumber + 1);\n        }\n        // === 5. Set process status ===\n        if (setProcessStatus) {\n            setProcessStatus(`Captured with dot at: x=${position.x}, y=${position.y}`);\n        }\n        // === 6. Return capture data ===\n        return {\n            screenImage: screenImageData,\n            webcamImage: webcamImageData,\n            position,\n            captureNumber: usedCaptureNumber\n        };\n    } catch (error) {\n        console.error(\"Error during capture:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(`Error capturing images: ${error.message}`);\n        }\n        throw error;\n    }\n};\n/**\n   * Display a preview of the captured images\n   * @param {string} screenImage - Data URL of the screen image\n   * @param {string} webcamImage - Data URL of the webcam image\n   * @param {Object} dotPosition - {x, y} position of the dot\n   */ const showCapturePreview = (screenImage, webcamImage, dotPosition)=>{\n    if (!screenImage && !webcamImage) {\n        console.warn(\"No images available to preview\");\n        return;\n    }\n    // Remove any existing preview containers first\n    try {\n        const existingPreviews = document.querySelectorAll('.capture-preview-container');\n        existingPreviews.forEach((preview)=>{\n            if (preview.parentNode) {\n                console.log(\"Removing existing preview container\");\n                preview.parentNode.removeChild(preview);\n            }\n        });\n    } catch (cleanupError) {\n        console.error(\"Error cleaning up existing previews:\", cleanupError);\n    }\n    // Create a new preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 999999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n    `;\n    // Function to add an image to the preview\n    const addImagePreview = (image, label)=>{\n        try {\n            const preview = document.createElement('div');\n            preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n            const img = document.createElement('img');\n            img.src = image;\n            img.alt = label;\n            img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n            const labelElement = document.createElement('div');\n            labelElement.textContent = label;\n            labelElement.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n            preview.appendChild(img);\n            preview.appendChild(labelElement);\n            previewContainer.appendChild(preview);\n            return true;\n        } catch (error) {\n            console.error(`Error adding ${label} preview:`, error);\n            return false;\n        }\n    };\n    // Add debug info div\n    const debugInfo = document.createElement('div');\n    debugInfo.style.cssText = `\n      position: absolute;\n      top: -30px;\n      left: 0;\n      width: 100%;\n      color: white;\n      font-size: 12px;\n      text-align: center;\n    `;\n    debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n    previewContainer.appendChild(debugInfo);\n    // Add both images to preview if available\n    if (screenImage) {\n        addImagePreview(screenImage, 'Screen Capture');\n    }\n    if (webcamImage) {\n        addImagePreview(webcamImage, 'Webcam Capture');\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n        positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -50px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add countdown timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n    previewContainer.appendChild(timerElement);\n    // Add to document body\n    document.body.appendChild(previewContainer);\n    // Countdown and remove the preview after 2 seconds\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            // Fade out\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            previewContainer.style.opacity = '0';\n            // Remove after fade\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n        }\n    }, 100);\n    // Safety cleanup after 5 seconds in case anything goes wrong\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n    return previewContainer;\n};\n/**\n   * Complete capture and preview process\n   * @param {Object} options - Process options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.onStatusUpdate - Function to update status\n   * @param {string} options.captureFolder - Folder to save captures in\n   */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.error('[captureImages] Invalid position:', position);\n        setProcessStatus?.('Error: Invalid dot position (captureImages)');\n        return;\n    }\n    let dotInterval;\n    try {\n        // Make sure we have a valid canvas reference\n        if (!canvasRef?.current) {\n            throw new Error(\"Canvas reference is invalid\");\n        }\n        // Draw the dot in its position first to ensure it's visible\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Initially draw the dot\n        drawRedDot(ctx, position.x, position.y);\n        // Create an interval to keep redrawing the dot to ensure it stays visible\n        dotInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y);\n        }, 200);\n        // First run the countdown\n        //   await runCountdown(\n        //     position,\n        //     canvasRef.current,\n        //     onStatusUpdate, \n        //     null // No callback here as we'll handle it directly\n        //   );\n        await runCountdown(position, canvas, onStatusUpdate, async ()=>{\n            try {\n                // ✅ Validate again here if needed\n                if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n                    throw new Error('Position is missing after countdown');\n                }\n                // Capture both canvas and webcam\n                const result = await captureImages({\n                    canvasRef,\n                    position,\n                    captureCounter,\n                    saveImageToServer,\n                    setCaptureCounter,\n                    setProcessStatus,\n                    toggleTopBar,\n                    captureFolder\n                });\n                return result;\n            } catch (err) {\n                console.error('[captureAndPreviewProcess] Error during capture:', err);\n                setProcessStatus?.(`Error: ${err.message}`);\n            }\n        });\n        // Make sure dot is visible after countdown\n        drawRedDot(ctx, position.x, position.y);\n        // Capture the images\n        const captureResult = await captureImages({\n            canvasRef,\n            position,\n            captureCounter,\n            saveImageToServer,\n            setCaptureCounter,\n            setProcessStatus,\n            toggleTopBar,\n            captureFolder\n        });\n        // Make sure dot is visible after capturing\n        drawRedDot(ctx, position.x, position.y);\n        // Show preview of captured images\n        showCapturePreview(captureResult.screenImage, captureResult.webcamImage, captureResult.position);\n        // Make sure dot is visible after preview\n        drawRedDot(ctx, position.x, position.y);\n        // Show TopBar again after a delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if (false) {}\n            // Make sure dot is still visible even after showing TopBar\n            drawRedDot(ctx, position.x, position.y);\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"Error in capture and preview process:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(`Error: ${error.message}`);\n        }\n        // Show TopBar again even if error occurred\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if (false) {}\n        }, 1500);\n        throw error;\n    } finally{\n        // Clear the dot redraw interval if it was created\n        if (dotInterval) {\n            clearInterval(dotInterval);\n        }\n    }\n};\n/**\n   * Generate a random dot position within the canvas\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {number} padding - Padding from the edges\n   * @returns {Object} - {x, y} position\n   */ const getRandomPosition = (canvas, padding = 40)=>{\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n   * Draw a red dot on the canvas\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @param {number} radius - Dot radius\n   * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n   * @returns {Object} - {x, y} position\n   */ const drawRedDot = (ctx, x, y, radius = 12, clearCanvas = true)=>{\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n   * Initialize canvas for drawing\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {HTMLElement} parent - Parent element for dimensions\n   * @returns {boolean} - Success status\n   */ const initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsaUVBQWlFO0FBRWpFOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLHlCQUF5QixDQUFDQyxVQUFVQztJQUM3QyxJQUFJLENBQUNELFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyw4Q0FBOENMO1FBQzNELE9BQU87SUFDVDtJQUVBLE1BQU1NLHFCQUFxQkMsU0FBU0MsZ0JBQWdCLENBQUM7SUFDckRGLG1CQUFtQkcsT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHQyxNQUFNO0lBRTFDLE1BQU1DLFlBQVlYLFdBQVdZLElBQUksR0FBR2IsU0FBU0UsQ0FBQztJQUM5QyxNQUFNWSxZQUFZYixXQUFXYyxHQUFHLEdBQUdmLFNBQVNHLENBQUM7SUFFN0MsTUFBTWEsbUJBQW1CVCxTQUFTVSxhQUFhLENBQUM7SUFDaERELGlCQUFpQkUsU0FBUyxHQUFHO0lBQzdCRixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7O1lBRTFCLEVBQUVSLFVBQVU7V0FDYixFQUFFRSxZQUFZLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQnhCLENBQUM7SUFFRFAsU0FBU2MsSUFBSSxDQUFDQyxXQUFXLENBQUNOO0lBQzFCLE9BQU9BO0FBQ1QsRUFBRTtBQUVGOzs7Ozs7Q0FNRCxHQUNNLE1BQU1PLGVBQWUsT0FBT3ZCLFVBQVV3QixRQUFRQyxnQkFBZ0JDO0lBQ2pFLElBQUksQ0FBQzFCLFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyxvQ0FBb0NMO1FBQ2pEeUIsaUJBQWlCO1lB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QztJQUFFO0FBQ2hCLEVBQUU7QUFFRjs7Ozs7R0FLQyxHQUNNLE1BQU04SixtQkFBbUIsQ0FBQ3pJLFFBQVEwSTtJQUN2QyxJQUFJLENBQUMxSSxVQUFVLENBQUMwSSxRQUFRLE9BQU87SUFFL0Isd0NBQXdDO0lBQ3hDMUksT0FBT3dDLEtBQUssR0FBR2tHLE9BQU9DLFdBQVc7SUFDakMzSSxPQUFPeUMsTUFBTSxHQUFHaUcsT0FBT0UsWUFBWTtJQUVuQyx3Q0FBd0M7SUFDeEMsTUFBTXJJLE1BQU1QLE9BQU9RLFVBQVUsQ0FBQztJQUM5QkQsSUFBSXdILFNBQVMsQ0FBQyxHQUFHLEdBQUcvSCxPQUFPd0MsS0FBSyxFQUFFeEMsT0FBT3lDLE1BQU07SUFDL0NsQyxJQUFJeUgsU0FBUyxHQUFHO0lBQ2hCekgsSUFBSTBILFFBQVEsQ0FBQyxHQUFHLEdBQUdqSSxPQUFPd0MsS0FBSyxFQUFFeEMsT0FBT3lDLE1BQU07SUFFOUMsT0FBTztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9BY3Rpb24vY291bnRTYXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvdW50U2F2ZS5qc1xuLy8gU2hhcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGNvdW50ZG93biBhbmQgaW1hZ2UgY2FwdHVyZSBwcm9jZXNzZXNcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBkaXNwbGF5cyBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIGEgZG90IHBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtET01SZWN0fSBjYW52YXNSZWN0IC0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgb2YgdGhlIGNhbnZhc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBjb3VudGRvd24gZmluaXNoZXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBUaGUgY3JlYXRlZCBjb3VudGRvd24gZWxlbWVudFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ291bnRkb3duRWxlbWVudCA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlQ291bnRkb3duRWxlbWVudF0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtY291bnRkb3duLCAuZm9yY2VkLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwJyk7XG4gICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuICBcbiAgICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICAgIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcbiAgXG4gICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgICAgdG9wOiAke2Fic29sdXRlWSAtIDYwfXB4O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgY29sb3I6IHJlZDtcbiAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNTBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICByZXR1cm4gY291bnRkb3duRWxlbWVudDtcbiAgfTtcbiAgXG4gIC8qKlxuICogUnVucyBhIGNvdW50ZG93biBwcm9jZXNzIHRoYXQgZGlzcGxheXMgMy0yLTEgYWJvdmUgYSBkb3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSBkb3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU3RhdHVzVXBkYXRlIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHN0YXR1cyBtZXNzYWdlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBjb3VudGRvd24gY29tcGxldGVzXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Db3VudGRvd24gPSBhc3luYyAocG9zaXRpb24sIGNhbnZhcywgb25TdGF0dXNVcGRhdGUsIG9uQ29tcGxldGUpID0+IHtcbiAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJJbnZhbGlkIGRvdCBwb3NpdGlvblwiLFxuICAgICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9zaXRpb24sIGNhbnZhc1JlY3QpO1xuICAgIFxuICAgIGlmICghY291bnRkb3duRWxlbWVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdbcnVuQ291bnRkb3duXSBDb3VudGRvd24gZWxlbWVudCBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIFxuICAgIGxldCBjb3VudCA9IDM7XG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICBcbiAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgIH0pO1xuICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ZG93bkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBjb3VudC0tO1xuICBcbiAgICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50ZG93bkludGVydmFsKTtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgXG4gICAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgICBjb3VudGRvd25WYWx1ZTogXCJDYXB0dXJpbmcuLi5cIixcbiAgICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ2FwdHVyaW5nIGltYWdlLi4uXCIsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiB0eXBlb2YgcG9zaXRpb24ueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHBvc2l0aW9uLnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbcnVuQ291bnRkb3duXSBQb3NpdGlvbiBpcyBudWxsIGFmdGVyIGNvdW50ZG93blwiLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICBcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCA4MDApO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQ2FwdHVyZXMgaW1hZ2VzIGZyb20gYm90aCBjYW52YXMgYW5kIHdlYmNhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENhcHR1cmUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlYWN0LlJlZk9iamVjdH0gb3B0aW9ucy5jYW52YXNSZWYgLSBSZWYgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwdHVyZUNvdW50ZXIgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNhdmVJbWFnZVRvU2VydmVyIC0gRnVuY3Rpb24gdG8gc2F2ZSBpbWFnZSB0byBzZXJ2ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRDYXB0dXJlQ291bnRlciAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRQcm9jZXNzU3RhdHVzIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHByb2Nlc3Mgc3RhdHVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYXB0dXJlRm9sZGVyIC0gRm9sZGVyIHRvIHNhdmUgY2FwdHVyZXMgaW5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBSZXN1bHQgd2l0aCBjYXB0dXJlZCBpbWFnZSBkYXRhXG4gICAqL1xuICBleHBvcnQgY29uc3QgY2FwdHVyZUltYWdlcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb3VudGVyID0gU3RyaW5nKGNhcHR1cmVDb3VudGVyKS5wYWRTdGFydCgzLCAnMCcpO1xuICAgICAgY29uc3Qgc2NyZWVuRmlsZW5hbWUgPSBgc2NyZWVuXyR7Y291bnRlcn0uanBnYDtcbiAgICAgIGNvbnN0IHdlYmNhbUZpbGVuYW1lID0gYHdlYmNhbV8ke2NvdW50ZXJ9LmpwZ2A7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJGaWxlbmFtZSA9IGBwYXJhbWV0ZXJfJHtjb3VudGVyfS5jc3ZgO1xuICBcbiAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlIHByb2Nlc3Mgd2l0aCBjb3VudGVyOiAke2NvdW50ZXJ9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgRG90IHBvc2l0aW9uOiB4PSR7cG9zaXRpb24ueH0sIHk9JHtwb3NpdGlvbi55fWApO1xuICBcbiAgICAgIGxldCBzY3JlZW5JbWFnZURhdGEgPSBudWxsO1xuICAgICAgbGV0IHdlYmNhbUltYWdlRGF0YSA9IG51bGw7XG4gICAgICBsZXQgdXNlZENhcHR1cmVOdW1iZXIgPSBjYXB0dXJlQ291bnRlcjtcbiAgXG4gICAgICAvLyA9PT0gMS4gQ2FwdHVyZSBzY3JlZW4gaW1hZ2UgZnJvbSBjYW52YXMgPT09XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgXG4gICAgICAgICAgLy8g4pyFIE1ha2Ugc3VyZSB0aGUgcmVkIGRvdCBpcyBkcmF3biBSSUdIVCBiZWZvcmUgc2NyZWVuIGNhcHR1cmVcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgZGltZW5zaW9uczogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgICAgICAgICBzY3JlZW5JbWFnZURhdGEgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2NyZWVuIGltYWdlIGNhcHR1cmVkLCBzaXplOiAke3NjcmVlbkltYWdlRGF0YS5sZW5ndGh9IGNoYXJzYCk7XG4gIFxuICAgICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuUmVzcG9uc2UgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcihcbiAgICAgICAgICAgICAgc2NyZWVuSW1hZ2VEYXRhLFxuICAgICAgICAgICAgICBzY3JlZW5GaWxlbmFtZSxcbiAgICAgICAgICAgICAgJ3NjcmVlbicsXG4gICAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgICk7XG4gIFxuICAgICAgICAgICAgaWYgKHNjcmVlblJlc3BvbnNlICYmIHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgdXNlZENhcHR1cmVOdW1iZXIgPSBzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU2VydmVyIGFzc2lnbmVkIGNhcHR1cmUgbnVtYmVyOiAke3VzZWRDYXB0dXJlTnVtYmVyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoc2NyZWVuRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIG9yIHNhdmluZyBzY3JlZW4gaW1hZ2U6XCIsIHNjcmVlbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbCwgY2Fubm90IGNhcHR1cmUgc2NyZWVuXCIpO1xuICAgICAgfVxuICBcbiAgICAgIC8vID09PSAyLiBDYXB0dXJlIHdlYmNhbSBpbWFnZSA9PT1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBjYXB0dXJlIHdlYmNhbSBzaWxlbnRseVwiKTtcbiAgXG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHdpbmRvdy52aWRlb0VsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgXG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnQgJiYgdmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHZpZGVvRWxlbWVudC52aWRlb0hlaWdodCB8fCA0ODA7XG4gIFxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgd2ViY2FtSW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICBcbiAgICAgICAgICBpZiAoc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEsXG4gICAgICAgICAgICAgIGB3ZWJjYW1fJHtTdHJpbmcodXNlZENhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2AsXG4gICAgICAgICAgICAgICd3ZWJjYW0nLFxuICAgICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBjb25zdCB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgIHRlbXBWaWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWaWRlby5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICBcbiAgICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKTtcbiAgICAgICAgICAgIHRlbXBWaWRlby5vbmxvYWRlZGRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gIFxuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHRlbXBWaWRlby52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCA0ODA7XG4gIFxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgd2ViY2FtSW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICBcbiAgICAgICAgICBpZiAoc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEsXG4gICAgICAgICAgICAgIGB3ZWJjYW1fJHtTdHJpbmcodXNlZENhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2AsXG4gICAgICAgICAgICAgICd3ZWJjYW0nLFxuICAgICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICBpZiAodGVtcFZpZGVvLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRlbXBWaWRlby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh3ZWJjYW1FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIHdlYmNhbSBzaWxlbnRseTpcIiwgd2ViY2FtRXJyb3IpO1xuICAgICAgfVxuICBcbiAgICAgIC8vID09PSAzLiBTYXZlIHBhcmFtZXRlciBDU1YgPT09XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHBhcmFtZXRlciBDU1ZcIik7XG4gIFxuICAgICAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgICAgIFwibmFtZSx2YWx1ZVwiLFxuICAgICAgICAgIGBkb3RfeCwke3Bvc2l0aW9uLnh9YCxcbiAgICAgICAgICBgZG90X3ksJHtwb3NpdGlvbi55fWAsXG4gICAgICAgICAgYGNhbnZhc193aWR0aCwke2NhbnZhcyA/IGNhbnZhcy53aWR0aCA6IDB9YCxcbiAgICAgICAgICBgY2FudmFzX2hlaWdodCwke2NhbnZhcyA/IGNhbnZhcy5oZWlnaHQgOiAwfWAsXG4gICAgICAgICAgYHdpbmRvd193aWR0aCwke3dpbmRvdy5pbm5lcldpZHRofWAsXG4gICAgICAgICAgYHdpbmRvd19oZWlnaHQsJHt3aW5kb3cuaW5uZXJIZWlnaHR9YCxcbiAgICAgICAgICBgdGltZXN0YW1wLCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWBcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgXG4gICAgICAgIGNvbnN0IGNzdkJsb2IgPSBuZXcgQmxvYihbY3N2RGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgICAgY29uc3QgY3N2UmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNzdlJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKGNzdlJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIGNzdlJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgICAgICB9KTtcbiAgXG4gICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgY3N2RGF0YVVybCxcbiAgICAgICAgICAgIGBwYXJhbWV0ZXJfJHtTdHJpbmcodXNlZENhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmNzdmAsXG4gICAgICAgICAgICAncGFyYW1ldGVycycsXG4gICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY3N2RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBwYXJhbWV0ZXIgQ1NWOlwiLCBjc3ZFcnJvcik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDQuIFVwZGF0ZSBjb3VudGVyID09PVxuICAgICAgaWYgKHNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyKHVzZWRDYXB0dXJlTnVtYmVyICsgMSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDUuIFNldCBwcm9jZXNzIHN0YXR1cyA9PT1cbiAgICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIHdpdGggZG90IGF0OiB4PSR7cG9zaXRpb24ueH0sIHk9JHtwb3NpdGlvbi55fWApO1xuICAgICAgfVxuICBcbiAgICAgIC8vID09PSA2LiBSZXR1cm4gY2FwdHVyZSBkYXRhID09PVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6IHNjcmVlbkltYWdlRGF0YSxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHdlYmNhbUltYWdlRGF0YSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVOdW1iZXI6IHVzZWRDYXB0dXJlTnVtYmVyXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGNhcHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYEVycm9yIGNhcHR1cmluZyBpbWFnZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBEaXNwbGF5IGEgcHJldmlldyBvZiB0aGUgY2FwdHVyZWQgaW1hZ2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY3JlZW5JbWFnZSAtIERhdGEgVVJMIG9mIHRoZSBzY3JlZW4gaW1hZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmNhbUltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHdlYmNhbSBpbWFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZG90UG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IHNob3dDYXB0dXJlUHJldmlldyA9IChzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKCFzY3JlZW5JbWFnZSAmJiAhd2ViY2FtSW1hZ2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGltYWdlcyBhdmFpbGFibGUgdG8gcHJldmlld1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlldyBjb250YWluZXJzIGZpcnN0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJldmlld3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcicpO1xuICAgICAgZXhpc3RpbmdQcmV2aWV3cy5mb3JFYWNoKHByZXZpZXcgPT4ge1xuICAgICAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJSZW1vdmluZyBleGlzdGluZyBwcmV2aWV3IGNvbnRhaW5lclwiKTtcbiAgICAgICAgICBwcmV2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlldyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNsZWFuaW5nIHVwIGV4aXN0aW5nIHByZXZpZXdzOlwiLCBjbGVhbnVwRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgcHJldmlldyBjb250YWluZXJcbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICBgO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGFkZCBhbiBpbWFnZSB0byB0aGUgcHJldmlld1xuICAgIGNvbnN0IGFkZEltYWdlUHJldmlldyA9IChpbWFnZSwgbGFiZWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZTtcbiAgICAgICAgaW1nLmFsdCA9IGxhYmVsO1xuICAgICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICBsYWJlbEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQobGFiZWxFbGVtZW50KTtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgJHtsYWJlbH0gcHJldmlldzpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBkZWJ1ZyBpbmZvIGRpdlxuICAgIGNvbnN0IGRlYnVnSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlYnVnSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAtMzBweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBgO1xuICAgIGRlYnVnSW5mby50ZXh0Q29udGVudCA9IGBTY3JlZW46ICR7c2NyZWVuSW1hZ2UgPyAnWUVTJyA6ICdOTyd9LCBXZWJjYW06ICR7d2ViY2FtSW1hZ2UgPyAnWUVTJyA6ICdOTyd9YDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKGRlYnVnSW5mbyk7XG4gICAgXG4gICAgLy8gQWRkIGJvdGggaW1hZ2VzIHRvIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBhZGRJbWFnZVByZXZpZXcoc2NyZWVuSW1hZ2UsICdTY3JlZW4gQ2FwdHVyZScpO1xuICAgIH1cbiAgICBcbiAgICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICAgIGFkZEltYWdlUHJldmlldyh3ZWJjYW1JbWFnZSwgJ1dlYmNhbSBDYXB0dXJlJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkb3QgcG9zaXRpb24gaW5mbyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZG90UG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9zaXRpb25JbmZvLnRleHRDb250ZW50ID0gYERvdCBwb3NpdGlvbjogeD0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi55KX1gO1xuICAgICAgcG9zaXRpb25JbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtNTBweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvc2l0aW9uSW5mbyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBjb3VudGRvd24gdGltZXJcbiAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IC0yNXB4O1xuICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgIFxuICAgIC8vIEFkZCB0byBkb2N1bWVudCBib2R5XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICBcbiAgICAvLyBDb3VudGRvd24gYW5kIHJlbW92ZSB0aGUgcHJldmlldyBhZnRlciAyIHNlY29uZHNcbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMC4zcyBlYXNlJztcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICAgIFxuICAgIC8vIFNhZmV0eSBjbGVhbnVwIGFmdGVyIDUgc2Vjb25kcyBpbiBjYXNlIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgfVxuICAgIH0sIDUwMDApO1xuICAgIFxuICAgIHJldHVybiBwcmV2aWV3Q29udGFpbmVyO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIENvbXBsZXRlIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2Vzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFByb2Nlc3Mgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlYWN0LlJlZk9iamVjdH0gb3B0aW9ucy5jYW52YXNSZWYgLSBSZWYgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwdHVyZUNvdW50ZXIgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNhdmVJbWFnZVRvU2VydmVyIC0gRnVuY3Rpb24gdG8gc2F2ZSBpbWFnZSB0byBzZXJ2ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRDYXB0dXJlQ291bnRlciAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRQcm9jZXNzU3RhdHVzIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHByb2Nlc3Mgc3RhdHVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU3RhdHVzVXBkYXRlIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHN0YXR1c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYXB0dXJlRm9sZGVyIC0gRm9sZGVyIHRvIHNhdmUgY2FwdHVyZXMgaW5cbiAgICovXG4gIGV4cG9ydCBjb25zdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1JlZixcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICBzYXZlSW1hZ2VUb1NlcnZlcixcbiAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYXB0dXJlSW1hZ2VzXSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKCdFcnJvcjogSW52YWxpZCBkb3QgcG9zaXRpb24gKGNhcHR1cmVJbWFnZXMpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBcbiAgICBcbiAgICBsZXQgZG90SW50ZXJ2YWw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSB2YWxpZCBjYW52YXMgcmVmZXJlbmNlXG4gICAgICAgIGlmICghY2FudmFzUmVmPy5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmZXJlbmNlIGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGRvdCBpbiBpdHMgcG9zaXRpb24gZmlyc3QgdG8gZW5zdXJlIGl0J3MgdmlzaWJsZVxuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsbHkgZHJhdyB0aGUgZG90XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnRlcnZhbCB0byBrZWVwIHJlZHJhd2luZyB0aGUgZG90IHRvIGVuc3VyZSBpdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgIGRvdEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgXG4gICAgICAvLyBGaXJzdCBydW4gdGhlIGNvdW50ZG93blxuICAgIC8vICAgYXdhaXQgcnVuQ291bnRkb3duKFxuICAgIC8vICAgICBwb3NpdGlvbixcbiAgICAvLyAgICAgY2FudmFzUmVmLmN1cnJlbnQsXG4gICAgLy8gICAgIG9uU3RhdHVzVXBkYXRlLCBcbiAgICAvLyAgICAgbnVsbCAvLyBObyBjYWxsYmFjayBoZXJlIGFzIHdlJ2xsIGhhbmRsZSBpdCBkaXJlY3RseVxuICAgIC8vICAgKTtcbiAgICAgICAgYXdhaXQgcnVuQ291bnRkb3duKHBvc2l0aW9uLCBjYW52YXMsIG9uU3RhdHVzVXBkYXRlLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8g4pyFIFZhbGlkYXRlIGFnYWluIGhlcmUgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIGlzIG1pc3NpbmcgYWZ0ZXIgY291bnRkb3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBib3RoIGNhbnZhcyBhbmQgd2ViY2FtXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzKHtcbiAgICAgICAgICAgICAgICBjYW52YXNSZWYsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgICAgICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICAgICAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2NhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc10gRXJyb3IgZHVyaW5nIGNhcHR1cmU6JywgZXJyKTtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgdmlzaWJsZSBhZnRlciBjb3VudGRvd25cbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgaW1hZ2VzXG4gICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzKHtcbiAgICAgICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzYXZlSW1hZ2VUb1NlcnZlcixcbiAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHZpc2libGUgYWZ0ZXIgY2FwdHVyaW5nXG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXNcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3KFxuICAgICAgICAgICAgY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSxcbiAgICAgICAgICAgIGNhcHR1cmVSZXN1bHQud2ViY2FtSW1hZ2UsXG4gICAgICAgICAgICBjYXB0dXJlUmVzdWx0LnBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHZpc2libGUgYWZ0ZXIgcHJldmlld1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlIGV2ZW4gYWZ0ZXIgc2hvd2luZyBUb3BCYXJcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgfSwgMjUwMCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY2FwdHVyZVJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gZXZlbiBpZiBlcnJvciBvY2N1cnJlZFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxNTAwKTtcbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHRoZSBkb3QgcmVkcmF3IGludGVydmFsIGlmIGl0IHdhcyBjcmVhdGVkXG4gICAgICBpZiAoZG90SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkb3RJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIGRvdCBwb3NpdGlvbiB3aXRoaW4gdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIFBhZGRpbmcgZnJvbSB0aGUgZWRnZXNcbiAgICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAgICovXG4gIGV4cG9ydCBjb25zdCBnZXRSYW5kb21Qb3NpdGlvbiA9IChjYW52YXMsIHBhZGRpbmcgPSA0MCkgPT4ge1xuICAgIGlmICghY2FudmFzKSByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICAgIFxuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoIHx8IDQwMDsgIC8vIEZhbGxiYWNrIGlmIHdpZHRoIGlzIDBcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IHx8IDMwMDsgLy8gRmFsbGJhY2sgaWYgaGVpZ2h0IGlzIDBcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdpZHRoIC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmcsXG4gICAgICB5OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGVpZ2h0IC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmdcbiAgICB9O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIERyYXcgYSByZWQgZG90IG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJDYW52YXMgLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgKGRlZmF1bHQ6IHRydWUpXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0ge3gsIHl9IHBvc2l0aW9uXG4gICAqL1xuICBleHBvcnQgY29uc3QgZHJhd1JlZERvdCA9IChjdHgsIHgsIHksIHJhZGl1cyA9IDEyLCBjbGVhckNhbnZhcyA9IHRydWUpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBjYW52YXMgaWYgcmVxdWVzdGVkIChkZWZhdWx0IGJlaGF2aW9yKVxuICAgIGlmIChjbGVhckNhbnZhcykge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBBZGQgYSBzZWNvbmQgbGFyZ2VyIGdsb3cgZm9yIGV2ZW4gYmV0dGVyIHZpc2liaWxpdHlcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjMpJztcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY2FudmFzIGZvciBkcmF3aW5nXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCAtIFBhcmVudCBlbGVtZW50IGZvciBkaW1lbnNpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFN1Y2Nlc3Mgc3RhdHVzXG4gICAqL1xuICBleHBvcnQgY29uc3QgaW5pdGlhbGl6ZUNhbnZhcyA9IChjYW52YXMsIHBhcmVudCkgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggcGFyZW50XG4gICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIGNhbnZhcyBhbmQgc2V0IHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07Il0sIm5hbWVzIjpbImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJ4IiwieSIsImNvbnNvbGUiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicmVtb3ZlIiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwicnVuQ291bnRkb3duIiwiY2FudmFzIiwib25TdGF0dXNVcGRhdGUiLCJvbkNvbXBsZXRlIiwicHJvY2Vzc1N0YXR1cyIsImNvdW50ZG93blZhbHVlIiwiaXNDYXB0dXJpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd1JlZERvdCIsImNvdW50IiwidGV4dENvbnRlbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50ZG93bkludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhcHR1cmVJbWFnZXMiLCJvcHRpb25zIiwiY2FudmFzUmVmIiwiY2FwdHVyZUNvdW50ZXIiLCJzYXZlSW1hZ2VUb1NlcnZlciIsInNldENhcHR1cmVDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVGb2xkZXIiLCJjb3VudGVyIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJzY3JlZW5GaWxlbmFtZSIsIndlYmNhbUZpbGVuYW1lIiwicGFyYW1ldGVyRmlsZW5hbWUiLCJsb2ciLCJzY3JlZW5JbWFnZURhdGEiLCJ3ZWJjYW1JbWFnZURhdGEiLCJ1c2VkQ2FwdHVyZU51bWJlciIsImN1cnJlbnQiLCJ3aWR0aCIsImhlaWdodCIsInRvRGF0YVVSTCIsImxlbmd0aCIsInNjcmVlblJlc3BvbnNlIiwiY2FwdHVyZU51bWJlciIsInNjcmVlbkVycm9yIiwiZXJyb3IiLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwicmVhZHlTdGF0ZSIsInRlbXBDYW52YXMiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJzdHJlYW0iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsImF1ZGlvIiwidGVtcFZpZGVvIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwib3BhY2l0eSIsInNyY09iamVjdCIsInRpbWVvdXRJZCIsIm9ubG9hZGVkZGF0YSIsImNsZWFyVGltZW91dCIsImdldFRyYWNrcyIsInRyYWNrIiwic3RvcCIsIndlYmNhbUVycm9yIiwiY3N2RGF0YSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJjc3ZCbG9iIiwiQmxvYiIsInR5cGUiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJjc3ZFcnJvciIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJtZXNzYWdlIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZG90UG9zaXRpb24iLCJleGlzdGluZ1ByZXZpZXdzIiwicHJldmlldyIsImNsZWFudXBFcnJvciIsInByZXZpZXdDb250YWluZXIiLCJhZGRJbWFnZVByZXZpZXciLCJpbWFnZSIsImxhYmVsIiwiaW1nIiwic3JjIiwiYWx0IiwibGFiZWxFbGVtZW50IiwiZGVidWdJbmZvIiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwidGltZXJFbGVtZW50IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInRyYW5zaXRpb24iLCJ0b0ZpeGVkIiwiY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIiwiZG90SW50ZXJ2YWwiLCJFcnJvciIsImVyciIsImNhcHR1cmVSZXN1bHQiLCJnZXRSYW5kb21Qb3NpdGlvbiIsInBhZGRpbmciLCJmbG9vciIsInJhbmRvbSIsInJhZGl1cyIsImNsZWFyQ2FudmFzIiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImluaXRpYWxpemVDYW52YXMiLCJwYXJlbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/countSave.js\n");

/***/ })

};
;