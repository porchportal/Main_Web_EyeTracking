"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_pages_collected-dataset_components-gui_Action_CalibrateHandler_js";
exports.ids = ["_pages-dir-node_pages_collected-dataset_components-gui_Action_CalibrateHandler_js"];
exports.modules = {

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CalibrateHandler.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibratePoints.js\");\n/* harmony import */ var _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CaptureHandler */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CaptureHandler.js\");\n/* harmony import */ var _DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotCaptureUtil */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js\");\n// CalibrateHandler.js - Using the existing CaptureHandler class\n\n\n\nclass CalibrateHandler {\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Create a CaptureHandler instance for handling the captures\n        this.captureHandler = new _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__[\"default\"](// Pass saveImageToServer function\n        async (imageData, filename, type, folder)=>{\n            try {\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type,\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    console.warn(`Server responded with ${response.status}`);\n                    return {};\n                }\n                return await response.json();\n            } catch (err) {\n                console.error(`Error saving ${type}:`, err);\n                return {};\n            }\n        }, // Pass setCaptureCounter function\n        (newCounter)=>{\n            if (typeof newCounter === 'function') {\n                this.captureCounter = newCounter(this.captureCounter);\n            } else {\n                this.captureCounter = newCounter;\n            }\n            if (this.setCaptureCounter) {\n                this.setCaptureCounter(this.captureCounter);\n            }\n        }, // Pass setProcessStatus function\n        (status)=>{\n            if (this.setOutputText) {\n                this.setOutputText(status);\n            }\n        }, // Pass toggleTopBar function\n        this.toggleTopBar);\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      background-color: rgba(0, 102, 204, 0.9);\n      color: white;\n      font-size: 14px;\n      font-weight: bold;\n      padding: 8px 12px;\n      border-radius: 6px;\n      z-index: 9999;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n    `;\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Processing point ${index + 1}/${total}`;\n            }\n            // Draw the dot\n            const canvas = this.canvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            const ctx = canvas.getContext('2d');\n            (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n            // Create countdown element\n            const canvasRect = canvas.getBoundingClientRect();\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'calibrate-countdown';\n            countdownElement.style.cssText = `\n        position: fixed;\n        left: ${canvasRect.left + point.x}px;\n        top: ${canvasRect.top + point.y - 60}px;\n        transform: translateX(-50%);\n        color: red;\n        font-size: 36px;\n        font-weight: bold;\n        text-shadow: 0 0 10px white, 0 0 20px white;\n        z-index: 9999;\n        background-color: rgba(255, 255, 255, 0.8);\n        border: 2px solid red;\n        border-radius: 50%;\n        width: 50px;\n        height: 50px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n      `;\n            document.body.appendChild(countdownElement);\n            // Run countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                this.setOutputText?.(`Point ${index + 1}/${total} - countdown ${count}`);\n                // Make sure dot remains visible during countdown\n                (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n                // Wait for next countdown step\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            // Show capturing indicator\n            countdownElement.textContent = \"âœ“\";\n            this.setOutputText?.(`Capturing point ${index + 1}/${total}`);\n            // Remove countdown element\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Use CaptureHandler to handle the capture process\n            const captureResult = await this.captureHandler.captureAndShowPreview(this.captureCounter, this.canvasRef, point);\n            // Add null check before using the result\n            if (!captureResult) {\n                console.warn(`No capture result for point ${index + 1}`);\n            // You might want to set a default or retry logic here\n            }\n            // Wait for the preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2500));\n            return true;\n        } catch (err) {\n            console.error(`Error processing point ${index + 1}:`, err);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Error: ${err.message}`;\n            }\n            this.setOutputText?.(`Error: ${err.message}`);\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        if (this.toggleTopBar) {\n            this.toggleTopBar(false);\n        }\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            this.setOutputText?.(`Starting calibration with ${this.calibrationPoints.length} points`);\n            let successCount = 0;\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (success) {\n                    successCount++;\n                }\n                // Small delay between points\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            this.setOutputText?.(`Calibration completed: ${successCount}/${this.calibrationPoints.length} points captured`);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Calibration complete: ${successCount}/${this.calibrationPoints.length} points`;\n            }\n            // Turn TopBar back on\n            if (this.toggleTopBar) {\n                this.toggleTopBar(true);\n            }\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        } catch (error) {\n            // console.error('Calibration error:', error);\n            // this.setOutputText?.(`Calibration error: ${error.message}`);\n            // if (this.statusIndicator) {\n            //   this.statusIndicator.textContent = `Error: ${error.message}`;\n            // }\n            // // Make sure we turn TopBar back on even on error\n            // if (this.toggleTopBar) {\n            //   this.toggleTopBar(true);\n            // }\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 1500);\n            // Return a default object to prevent null reference errors\n            return {\n                screenImage: '',\n                webcamImage: '',\n                success: false\n            };\n        } finally{\n            this.isProcessing = false;\n            // Remove the status indicator after a delay\n            setTimeout(()=>{\n                if (this.statusIndicator && this.statusIndicator.parentNode) {\n                    this.statusIndicator.parentNode.removeChild(this.statusIndicator);\n                }\n            }, 3000);\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYWxpYnJhdGVIYW5kbGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSxnRUFBZ0U7QUFDRjtBQUNoQjtBQUNBO0FBRTlDLE1BQU1HO0lBQ0pDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQixJQUFJLENBQUNDLFNBQVMsR0FBR0QsT0FBT0MsU0FBUztRQUNqQyxJQUFJLENBQUNDLFlBQVksR0FBR0YsT0FBT0UsWUFBWTtRQUN2QyxJQUFJLENBQUNDLGFBQWEsR0FBR0gsT0FBT0csYUFBYTtRQUN6QyxJQUFJLENBQUNDLGNBQWMsR0FBR0osT0FBT0ksY0FBYyxJQUFJO1FBQy9DLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdMLE9BQU9LLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNDLGFBQWEsR0FBR04sT0FBT00sYUFBYSxJQUFJO1FBQzdDLElBQUksQ0FBQ0MsVUFBVSxHQUFHUCxPQUFPTyxVQUFVO1FBRW5DLG1FQUFtRTtRQUNuRSxJQUFJLENBQUNDLGlCQUFpQixHQUFHUixPQUFPUSxpQkFBaUIsSUFBSSxFQUFFO1FBRXZELDZEQUE2RDtRQUM3RCxJQUFJLENBQUNDLGNBQWMsR0FBRyxJQUFJYix1REFBY0EsQ0FDdEMsa0NBQWtDO1FBQ2xDLE9BQU9jLFdBQVdDLFVBQVVDLE1BQU1DO1lBQ2hDLElBQUk7Z0JBQ0YsTUFBTUMsV0FBVyxNQUFNQyxNQUFNLHFCQUFxQjtvQkFDaERDLFFBQVE7b0JBQ1JDLFNBQVM7d0JBQ1AsZ0JBQWdCO29CQUNsQjtvQkFDQUMsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO3dCQUNuQlY7d0JBQ0FDO3dCQUNBQzt3QkFDQUMsUUFBUSxJQUFJLENBQUNQLGFBQWE7b0JBQzVCO2dCQUNGO2dCQUVBLElBQUksQ0FBQ1EsU0FBU08sRUFBRSxFQUFFO29CQUNoQkMsUUFBUUMsSUFBSSxDQUFDLENBQUMsc0JBQXNCLEVBQUVULFNBQVNV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RCxnQkFBZ0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQyxZQUFZbEQsTUFBTTBDLE9BQU87WUFDakQ7WUFFQSwrQ0FBK0M7WUFDL0NMLFdBQVc7Z0JBQ1QsSUFBSSxPQUFPLElBQUksQ0FBQzlELFlBQVksS0FBSyxZQUFZO29CQUMzQyxJQUFJLENBQUNBLFlBQVksQ0FBQztnQkFDcEIsT0FBTyxJQUFJLEtBQW9ELEVBQUUsRUFFaEU7WUFDSCxHQUFHO1lBRUgsMkRBQTJEO1lBQzNELE9BQU87Z0JBQ0w2RSxhQUFhO2dCQUNiQyxhQUFhO2dCQUNiSixTQUFTO1lBQ1g7UUFDRixTQUFVO1lBQ1IsSUFBSSxDQUFDL0MsWUFBWSxHQUFHO1lBRXBCLDRDQUE0QztZQUM1Q21DLFdBQVc7Z0JBQ1QsSUFBSSxJQUFJLENBQUNqQyxlQUFlLElBQUksSUFBSSxDQUFDQSxlQUFlLENBQUNrQyxVQUFVLEVBQUU7b0JBQzNELElBQUksQ0FBQ2xDLGVBQWUsQ0FBQ2tDLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDLElBQUksQ0FBQ25DLGVBQWU7Z0JBQ2xFO1lBQ0YsR0FBRztRQUNMO0lBQ0Y7QUFDRjtBQUVBLGlFQUFlakMsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlSGFuZGxlci5qcyAtIFVzaW5nIHRoZSBleGlzdGluZyBDYXB0dXJlSGFuZGxlciBjbGFzc1xuaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4vQ2FsaWJyYXRlUG9pbnRzJztcbmltcG9ydCBDYXB0dXJlSGFuZGxlciBmcm9tICcuL0NhcHR1cmVIYW5kbGVyJztcbmltcG9ydCB7IGRyYXdSZWREb3QgfSBmcm9tICcuL0RvdENhcHR1cmVVdGlsJztcblxuY2xhc3MgQ2FsaWJyYXRlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRPdXRwdXRUZXh0ID0gY29uZmlnLnNldE91dHB1dFRleHQ7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlciB8fCAxO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlRm9sZGVyID0gY29uZmlnLmNhcHR1cmVGb2xkZXIgfHwgJ2V5ZV90cmFja2luZ19jYXB0dXJlcyc7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gY29uZmlnLm9uQ29tcGxldGU7XG5cbiAgICAvLyBBY2NlcHQgcGFzc2VkLWluIGNhbGlicmF0aW9uIHBvaW50cyAoZnJvbSBTZXRDYWxpYnJhdGVBY3Rpb24uanMpXG4gICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cyA9IGNvbmZpZy5jYWxpYnJhdGlvblBvaW50cyB8fCBbXTtcblxuICAgIC8vIENyZWF0ZSBhIENhcHR1cmVIYW5kbGVyIGluc3RhbmNlIGZvciBoYW5kbGluZyB0aGUgY2FwdHVyZXNcbiAgICB0aGlzLmNhcHR1cmVIYW5kbGVyID0gbmV3IENhcHR1cmVIYW5kbGVyKFxuICAgICAgLy8gUGFzcyBzYXZlSW1hZ2VUb1NlcnZlciBmdW5jdGlvblxuICAgICAgYXN5bmMgKGltYWdlRGF0YSwgZmlsZW5hbWUsIHR5cGUsIGZvbGRlcikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgIGZvbGRlcjogdGhpcy5jYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBzYXZpbmcgJHt0eXBlfTpgLCBlcnIpO1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFBhc3Mgc2V0Q2FwdHVyZUNvdW50ZXIgZnVuY3Rpb25cbiAgICAgIChuZXdDb3VudGVyKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3Q291bnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBuZXdDb3VudGVyKHRoaXMuY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBuZXdDb3VudGVyO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5zZXRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIodGhpcy5jYXB0dXJlQ291bnRlcik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIHNldFByb2Nlc3NTdGF0dXMgZnVuY3Rpb25cbiAgICAgIChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc2V0T3V0cHV0VGV4dCkge1xuICAgICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dChzdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUGFzcyB0b2dnbGVUb3BCYXIgZnVuY3Rpb25cbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyXG4gICAgKTtcblxuICAgIC8vIEludGVybmFsc1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50UG9pbnRJbmRleCA9IDA7XG4gICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IgPSBudWxsO1xuICB9XG5cbiAgY3JlYXRlU3RhdHVzSW5kaWNhdG9yKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nSW5kaWNhdG9ycyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcicpO1xuICAgIGV4aXN0aW5nSW5kaWNhdG9ycy5mb3JFYWNoKGluZGljYXRvciA9PiBpbmRpY2F0b3IucmVtb3ZlKCkpO1xuXG4gICAgY29uc3QgaW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgaW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICB0b3A6IDEwcHg7XG4gICAgICByaWdodDogMTBweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHBhZGRpbmc6IDhweCAxMnB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNnB4O1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluZGljYXRvcik7XG4gICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IgPSBpbmRpY2F0b3I7XG4gICAgcmV0dXJuIGluZGljYXRvcjtcbiAgfVxuXG4gIGFzeW5jIHByb2Nlc3NDYWxpYnJhdGlvblBvaW50KHBvaW50LCBpbmRleCwgdG90YWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFwb2ludCB8fCB0eXBlb2YgcG9pbnQueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvaW50LnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FsaWJyYXRpb24gcG9pbnRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBQcm9jZXNzaW5nIHBvaW50ICR7aW5kZXggKyAxfS8ke3RvdGFsfWA7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNvdW50ZG93biBlbGVtZW50XG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLWNvdW50ZG93bic7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgbGVmdDogJHtjYW52YXNSZWN0LmxlZnQgKyBwb2ludC54fXB4O1xuICAgICAgICB0b3A6ICR7Y2FudmFzUmVjdC50b3AgKyBwb2ludC55IC0gNjB9cHg7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgXG4gICAgICAvLyBSdW4gY291bnRkb3duXG4gICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBQb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH0gLSBjb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgcmVtYWlucyB2aXNpYmxlIGR1cmluZyBjb3VudGRvd25cbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBmb3IgbmV4dCBjb3VudGRvd24gc3RlcFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgY2FwdHVyaW5nIGluZGljYXRvclxuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgQ2FwdHVyaW5nIHBvaW50ICR7aW5kZXggKyAxfS8ke3RvdGFsfWApO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgICAgXG4gICAgICAvLyBVc2UgQ2FwdHVyZUhhbmRsZXIgdG8gaGFuZGxlIHRoZSBjYXB0dXJlIHByb2Nlc3NcbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCB0aGlzLmNhcHR1cmVIYW5kbGVyLmNhcHR1cmVBbmRTaG93UHJldmlldyhcbiAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlcixcbiAgICAgICAgdGhpcy5jYW52YXNSZWYsXG4gICAgICAgIHBvaW50XG4gICAgICApO1xuICAgICAgXG4gICAgICAvLyBBZGQgbnVsbCBjaGVjayBiZWZvcmUgdXNpbmcgdGhlIHJlc3VsdFxuICAgICAgaWYgKCFjYXB0dXJlUmVzdWx0KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gY2FwdHVyZSByZXN1bHQgZm9yIHBvaW50ICR7aW5kZXggKyAxfWApO1xuICAgICAgICAvLyBZb3UgbWlnaHQgd2FudCB0byBzZXQgYSBkZWZhdWx0IG9yIHJldHJ5IGxvZ2ljIGhlcmVcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgdGhlIHByZXZpZXcgdG8gY29tcGxldGVcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyNTAwKSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX06YCwgZXJyKTtcbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHN0YXJ0Q2FsaWJyYXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNQcm9jZXNzaW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuXG5cblxuICAgIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGljYXRvciA9IHRoaXMuY3JlYXRlU3RhdHVzSW5kaWNhdG9yKCk7XG4gICAgaW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0luaXRpYWxpemluZyBjYWxpYnJhdGlvbi4uLic7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzIHx8IGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FudmFzIGlzIG5vdCByZWFkeScpO1xuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IGdlbmVyYXRlIGlmIG5vbmUgd2VyZSBwYXNzZWQgaW5cbiAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmICghdGhpcy5jYWxpYnJhdGlvblBvaW50cyB8fCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBTdGFydGluZyBjYWxpYnJhdGlvbiB3aXRoICR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2ApO1xuICAgICAgXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdGhpcy5wcm9jZXNzQ2FsaWJyYXRpb25Qb2ludChcbiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzW2ldLCBcbiAgICAgICAgICBpLCBcbiAgICAgICAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU21hbGwgZGVsYXkgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUdXJuIFRvcEJhciBiYWNrIG9uXG4gICAgICBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XG4gICAgICB9XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignQ2FsaWJyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgLy8gdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAvLyBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgIC8vICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgLy8gfVxuICAgICAgXG4gICAgICAvLyAvLyBNYWtlIHN1cmUgd2UgdHVybiBUb3BCYXIgYmFjayBvbiBldmVuIG9uIGVycm9yXG4gICAgICAvLyBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIC8vICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAvLyB9XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgY2FwdHVyZSBhbmQgcHJldmlldzonLCBlcnJvcik7XG4gIFxuICAgICAgLy8gU2hvdyBlcnJvciBtZXNzYWdlXG4gICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gZXZlbiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDE1MDApO1xuICAgICAgXG4gICAgICAvLyBSZXR1cm4gYSBkZWZhdWx0IG9iamVjdCB0byBwcmV2ZW50IG51bGwgcmVmZXJlbmNlIGVycm9yc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgdGhlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgYSBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvciAmJiB0aGlzLnN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnN0YXR1c0luZGljYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMDApO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYWxpYnJhdGVIYW5kbGVyOyJdLCJuYW1lcyI6WyJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiQ2FwdHVyZUhhbmRsZXIiLCJkcmF3UmVkRG90IiwiQ2FsaWJyYXRlSGFuZGxlciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiY2FudmFzUmVmIiwidG9nZ2xlVG9wQmFyIiwic2V0T3V0cHV0VGV4dCIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJjYXB0dXJlRm9sZGVyIiwib25Db21wbGV0ZSIsImNhbGlicmF0aW9uUG9pbnRzIiwiY2FwdHVyZUhhbmRsZXIiLCJpbWFnZURhdGEiLCJmaWxlbmFtZSIsInR5cGUiLCJmb2xkZXIiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJjb25zb2xlIiwid2FybiIsInN0YXR1cyIsImpzb24iLCJlcnIiLCJlcnJvciIsIm5ld0NvdW50ZXIiLCJpc1Byb2Nlc3NpbmciLCJjdXJyZW50UG9pbnRJbmRleCIsInN0YXR1c0luZGljYXRvciIsImNyZWF0ZVN0YXR1c0luZGljYXRvciIsImV4aXN0aW5nSW5kaWNhdG9ycyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJpbmRpY2F0b3IiLCJyZW1vdmUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYXBwZW5kQ2hpbGQiLCJwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludCIsInBvaW50IiwiaW5kZXgiLCJ0b3RhbCIsIngiLCJ5IiwiRXJyb3IiLCJ0ZXh0Q29udGVudCIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2FudmFzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvdW50ZG93bkVsZW1lbnQiLCJsZWZ0IiwidG9wIiwiY291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjYXB0dXJlUmVzdWx0IiwiY2FwdHVyZUFuZFNob3dQcmV2aWV3IiwibWVzc2FnZSIsInN0YXJ0Q2FsaWJyYXRpb24iLCJ3aWR0aCIsImhlaWdodCIsImxlbmd0aCIsInN1Y2Nlc3NDb3VudCIsImkiLCJzdWNjZXNzIiwic2V0UHJvY2Vzc1N0YXR1cyIsIndpbmRvdyIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CalibrateHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CaptureHandler.js":
/*!*************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/CaptureHandler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// CaptureHandler.js - With fixed capture numbering\nclass CaptureHandler {\n    constructor(saveFunction, counterSetter, statusSetter, toggleTopBarFunction){\n        this.saveImageToServer = saveFunction;\n        this.setCaptureCounter = counterSetter;\n        this.setProcessStatus = statusSetter;\n        this.toggleTopBar = toggleTopBarFunction;\n        this.captureFolder = 'eye_tracking_captures'; // Use fixed folder name\n    }\n    // Show preview of the SAVED images for exactly 2 seconds\n    showCapturePreview(screenImage, webcamImage, dotPosition) {\n        // Create a centered preview container\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = `\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: flex;\n        gap: 20px;\n        background-color: rgba(0, 0, 0, 0.85);\n        padding: 20px;\n        border-radius: 12px;\n        z-index: 999999;\n        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n        opacity: 1;\n        transition: opacity 0.3s ease;\n      `;\n        // Function to create an image preview element\n        const createImagePreview = (imageData, label)=>{\n            if (!imageData) return null;\n            const preview = document.createElement('div');\n            preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n            const img = document.createElement('img');\n            img.src = imageData;\n            img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n            // Event listeners for image loading\n            img.onload = ()=>console.log(`${label} image loaded successfully`);\n            img.onerror = (e)=>console.error(`Error loading ${label} image:`, e);\n            const textLabel = document.createElement('div');\n            textLabel.textContent = label;\n            textLabel.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n            preview.appendChild(img);\n            preview.appendChild(textLabel);\n            return preview;\n        };\n        // Add debug info\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = `\n        position: absolute;\n        top: -30px;\n        left: 0;\n        width: 100%;\n        color: white;\n        font-size: 12px;\n        text-align: center;\n      `;\n        debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n        previewContainer.appendChild(debugInfo);\n        // Add screen capture preview\n        const screenPreview = createImagePreview(screenImage, 'Screen Capture');\n        if (screenPreview) {\n            previewContainer.appendChild(screenPreview);\n        }\n        // Add webcam capture preview\n        const webcamPreview = createImagePreview(webcamImage, 'Webcam Capture');\n        if (webcamPreview) {\n            previewContainer.appendChild(webcamPreview);\n        }\n        // Add dot position info if available\n        if (dotPosition) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n            positionInfo.style.cssText = `\n          color: #ffcc00;\n          font-size: 14px;\n          position: absolute;\n          top: -50px;\n          left: 0;\n          width: 100%;\n          text-align: center;\n        `;\n            previewContainer.appendChild(positionInfo);\n        }\n        // Add timer countdown\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = `\n        position: absolute;\n        bottom: -25px;\n        right: 20px;\n        color: white;\n        font-size: 12px;\n        background-color: rgba(0, 0, 0, 0.7);\n        padding: 3px 8px;\n        border-radius: 4px;\n      `;\n        previewContainer.appendChild(timerElement);\n        // Add the preview to the document\n        document.body.appendChild(previewContainer);\n        // Start countdown timer\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Take a webcam picture and immediately stop the stream\n    async captureWebcamImage(captureNumber) {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format the filename with the current counter\n            const filename = `webcam_${String(captureNumber).padStart(3, '0')}.jpg`;\n            // Create a new stream with high resolution constraints\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 4096\n                    },\n                    height: {\n                        ideal: 2160\n                    },\n                    facingMode: \"user\"\n                },\n                audio: false\n            });\n            // Create a temporary video element\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Connect stream to video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get actual video dimensions\n            const videoWidth = tempVideo.videoWidth || 640;\n            const videoHeight = tempVideo.videoHeight || 480;\n            console.log(`Capturing at resolution: ${videoWidth}x${videoHeight}`);\n            // Capture the frame at full resolution\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = videoWidth;\n            tempCanvas.height = videoHeight;\n            const ctx = tempCanvas.getContext('2d');\n            ctx.drawImage(tempVideo, 0, 0, videoWidth, videoHeight);\n            // Convert to JPEG with high quality\n            const imageData = tempCanvas.toDataURL('image/jpeg', 0.95);\n            // Save the image\n            await this.saveImageToServer(imageData, filename, 'webcam', this.captureFolder);\n            // Clean up\n            stream.getTracks().forEach((track)=>track.stop());\n            tempVideo.remove();\n            return true;\n        } catch (error) {\n            console.error('Error capturing webcam image:', error);\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.remove();\n            }\n            return false;\n        }\n    }\n    // Capture screen image from canvas\n    async captureScreenImage(canvasRef, captureNumber) {\n        try {\n            // Format the filename with the current counter\n            const filename = `screen_${String(captureNumber).padStart(3, '0')}.jpg`;\n            const canvas = canvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas reference is null\");\n                return {\n                    imageData: null,\n                    saveResponse: null\n                };\n            }\n            // Get image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save the image\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(imageData, filename, 'screen', this.captureFolder);\n                console.log(`Saved screen image: ${filename}, response:`, saveResponse);\n                return {\n                    imageData,\n                    saveResponse\n                };\n            }\n            return {\n                imageData,\n                saveResponse: null\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            return {\n                imageData: null,\n                saveResponse: null\n            };\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(captureNumber, params) {\n        try {\n            // Format the filename with the current counter\n            const filename = `parameter_${String(captureNumber).padStart(3, '0')}.csv`;\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                ...Object.entries(params).map(([name, value])=>`${name},${value}`)\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(csvDataUrl, filename, 'parameters', this.captureFolder);\n                console.log(`Saved parameter CSV: ${filename}`);\n                return saveResponse;\n            }\n            return null;\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n            return null;\n        }\n    }\n    // Main capture and show process\n    async captureAndShowPreview(captureCounter, canvasRef, position) {\n        try {\n            console.log(`Starting capture process with counter: ${captureCounter}`);\n            // Step 1: Capture screen image\n            const { imageData: screenImage, saveResponse: screenResponse } = await this.captureScreenImage(canvasRef, captureCounter);\n            // Get the capture number from the response if available (for continuous numbering)\n            let usedCaptureNumber = captureCounter;\n            if (screenResponse && screenResponse.captureNumber) {\n                usedCaptureNumber = screenResponse.captureNumber;\n                console.log(`Server assigned capture number: ${usedCaptureNumber}`);\n            }\n            // Step 2: Capture webcam image (and immediately stop stream)\n            const webcamSuccess = await this.captureWebcamImage(usedCaptureNumber);\n            // Step 3: Save parameters\n            const params = {\n                dot_x: position ? position.x : 0,\n                dot_y: position ? position.y : 0,\n                canvas_width: canvasRef.current ? canvasRef.current.width : 0,\n                canvas_height: canvasRef.current ? canvasRef.current.height : 0,\n                window_width: window.innerWidth,\n                window_height: window.innerHeight,\n                timestamp: new Date().toISOString()\n            };\n            await this.saveParameterCSV(usedCaptureNumber, params);\n            // Step 4: Increment counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server is managing numbering, use the next number\n                if (screenResponse && screenResponse.captureNumber) {\n                    this.setCaptureCounter(screenResponse.captureNumber + 1);\n                } else {\n                    this.setCaptureCounter((prev)=>prev + 1);\n                }\n            }\n            // Step 5: Update status\n            if (this.setProcessStatus) {\n                this.setProcessStatus(`Captured with dot at: x=${position?.x}, y=${position?.y}`);\n            }\n            // Step 6: Show preview using the in-memory image data\n            this.showCapturePreview(screenImage, webcamSuccess ? 'webcam_image_data' : null, position);\n            // Step 7: Show TopBar again after preview is done\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 2200); // Wait longer than the preview duration\n            // Step 8: Clear status after a delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 1500);\n            // Clear error message after delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CaptureHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYXB0dXJlSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsbURBQW1EO0FBRW5ELE1BQU1BO0lBQ0ZDLFlBQVlDLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLG9CQUFvQixDQUFFO1FBQzNFLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdKO1FBQ3pCLElBQUksQ0FBQ0ssaUJBQWlCLEdBQUdKO1FBQ3pCLElBQUksQ0FBQ0ssZ0JBQWdCLEdBQUdKO1FBQ3hCLElBQUksQ0FBQ0ssWUFBWSxHQUFHSjtRQUNwQixJQUFJLENBQUNLLGFBQWEsR0FBRyx5QkFBeUIsd0JBQXdCO0lBQ3hFO0lBRUEseURBQXlEO0lBQ3pEQyxtQkFBbUJDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUU7UUFDeEQsc0NBQXNDO1FBQ3RDLE1BQU1DLG1CQUFtQkMsU0FBU0MsYUFBYSxDQUFDO1FBQ2hERixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7O01BY2xDLENBQUM7UUFFRCw4Q0FBOEM7UUFDOUMsTUFBTUMscUJBQXFCLENBQUNDLFdBQVdDO1lBQ3JDLElBQUksQ0FBQ0QsV0FBVyxPQUFPO1lBRXZCLE1BQU1FLFVBQVVQLFNBQVNDLGFBQWEsQ0FBQztZQUN2Q00sUUFBUUwsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7OztRQUl6QixDQUFDO1lBRUQsTUFBTUssTUFBTVIsU0FBU0MsYUFBYSxDQUFDO1lBQ25DTyxJQUFJQyxHQUFHLEdBQUdKO1lBQ1ZHLElBQUlOLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7OztRQU1yQixDQUFDO1lBRUQsb0NBQW9DO1lBQ3BDSyxJQUFJRSxNQUFNLEdBQUcsSUFBTUMsUUFBUUMsR0FBRyxDQUFDLEdBQUdOLE1BQU0sMEJBQTBCLENBQUM7WUFDbkVFLElBQUlL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Q2RKLFFBQVFJLEtBQUssQ0FBQyxxQ0FBcUNBO1lBRW5ELHFCQUFxQjtZQUNyQixJQUFJLElBQUksQ0FBQ3ZCLGdCQUFnQixFQUFFO2dCQUN6QixJQUFJLENBQUNBLGdCQUFnQixDQUFDLFlBQVl1QixNQUFNeUcsT0FBTztZQUNqRDtZQUVBLCtDQUErQztZQUMvQ3RGLFdBQVc7Z0JBQ1QsSUFBSSxPQUFPLElBQUksQ0FBQ3pDLFlBQVksS0FBSyxZQUFZO29CQUMzQyxJQUFJLENBQUNBLFlBQVksQ0FBQztnQkFDcEIsT0FBTyxJQUFJLEtBQW9ELEVBQUUsRUFFaEU7WUFDSCxHQUFHO1lBRUgsa0NBQWtDO1lBQ2xDeUMsV0FBVztnQkFDVCxJQUFJLElBQUksQ0FBQzFDLGdCQUFnQixFQUFFO29CQUN6QixJQUFJLENBQUNBLGdCQUFnQixDQUFDO2dCQUN4QjtZQUNGLEdBQUc7UUFDTDtJQUNGO0FBQ0Y7QUFFQSxpRUFBZVIsY0FBY0EsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9DYXB0dXJlSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYXB0dXJlSGFuZGxlci5qcyAtIFdpdGggZml4ZWQgY2FwdHVyZSBudW1iZXJpbmdcblxuY2xhc3MgQ2FwdHVyZUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKHNhdmVGdW5jdGlvbiwgY291bnRlclNldHRlciwgc3RhdHVzU2V0dGVyLCB0b2dnbGVUb3BCYXJGdW5jdGlvbikge1xuICAgICAgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlciA9IHNhdmVGdW5jdGlvbjtcbiAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb3VudGVyU2V0dGVyO1xuICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzID0gc3RhdHVzU2V0dGVyO1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIgPSB0b2dnbGVUb3BCYXJGdW5jdGlvbjtcbiAgICAgIHRoaXMuY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnOyAvLyBVc2UgZml4ZWQgZm9sZGVyIG5hbWVcbiAgICB9XG4gIFxuICAgIC8vIFNob3cgcHJldmlldyBvZiB0aGUgU0FWRUQgaW1hZ2VzIGZvciBleGFjdGx5IDIgc2Vjb25kc1xuICAgIHNob3dDYXB0dXJlUHJldmlldyhzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSB7XG4gICAgICAvLyBDcmVhdGUgYSBjZW50ZXJlZCBwcmV2aWV3IGNvbnRhaW5lclxuICAgICAgY29uc3QgcHJldmlld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogNTAlO1xuICAgICAgICBsZWZ0OiA1MCU7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBnYXA6IDIwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICAgICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcyBlYXNlO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgLy8gRnVuY3Rpb24gdG8gY3JlYXRlIGFuIGltYWdlIHByZXZpZXcgZWxlbWVudFxuICAgICAgY29uc3QgY3JlYXRlSW1hZ2VQcmV2aWV3ID0gKGltYWdlRGF0YSwgbGFiZWwpID0+IHtcbiAgICAgICAgaWYgKCFpbWFnZURhdGEpIHJldHVybiBudWxsO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgcHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBwcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlRGF0YTtcbiAgICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgICAgICBtYXgtaGVpZ2h0OiAyNDBweDtcbiAgICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW50IGxpc3RlbmVycyBmb3IgaW1hZ2UgbG9hZGluZ1xuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gY29uc29sZS5sb2coYCR7bGFiZWx9IGltYWdlIGxvYWRlZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgaW1nLm9uZXJyb3IgPSAoZSkgPT4gY29uc29sZS5lcnJvcihgRXJyb3IgbG9hZGluZyAke2xhYmVsfSBpbWFnZTpgLCBlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHRleHRMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0ZXh0TGFiZWwudGV4dENvbnRlbnQgPSBsYWJlbDtcbiAgICAgICAgdGV4dExhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgcHJldmlldy5hcHBlbmRDaGlsZChpbWcpO1xuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKHRleHRMYWJlbCk7XG4gICAgICAgIHJldHVybiBwcmV2aWV3O1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQWRkIGRlYnVnIGluZm9cbiAgICAgIGNvbnN0IGRlYnVnSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGVidWdJbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMzBweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgZGVidWdJbmZvLnRleHRDb250ZW50ID0gYFNjcmVlbjogJHtzY3JlZW5JbWFnZSA/ICdZRVMnIDogJ05PJ30sIFdlYmNhbTogJHt3ZWJjYW1JbWFnZSA/ICdZRVMnIDogJ05PJ31gO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChkZWJ1Z0luZm8pO1xuICAgICAgXG4gICAgICAvLyBBZGQgc2NyZWVuIGNhcHR1cmUgcHJldmlld1xuICAgICAgY29uc3Qgc2NyZWVuUHJldmlldyA9IGNyZWF0ZUltYWdlUHJldmlldyhzY3JlZW5JbWFnZSwgJ1NjcmVlbiBDYXB0dXJlJyk7XG4gICAgICBpZiAoc2NyZWVuUHJldmlldykge1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHNjcmVlblByZXZpZXcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgd2ViY2FtIGNhcHR1cmUgcHJldmlld1xuICAgICAgY29uc3Qgd2ViY2FtUHJldmlldyA9IGNyZWF0ZUltYWdlUHJldmlldyh3ZWJjYW1JbWFnZSwgJ1dlYmNhbSBDYXB0dXJlJyk7XG4gICAgICBpZiAod2ViY2FtUHJldmlldykge1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgZG90IHBvc2l0aW9uIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgICBpZiAoZG90UG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHBvc2l0aW9uSW5mby50ZXh0Q29udGVudCA9IGBEb3QgcG9zaXRpb246IHg9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLngpfSwgeT0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueSl9YDtcbiAgICAgICAgcG9zaXRpb25JbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICB0b3A6IC01MHB4O1xuICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvc2l0aW9uSW5mbyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCB0aW1lciBjb3VudGRvd25cbiAgICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJzIuMHMnO1xuICAgICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgYm90dG9tOiAtMjVweDtcbiAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIEFkZCB0aGUgcHJldmlldyB0byB0aGUgZG9jdW1lbnRcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICBcbiAgICAgIC8vIFN0YXJ0IGNvdW50ZG93biB0aW1lclxuICAgICAgbGV0IHRpbWVMZWZ0ID0gMi4wO1xuICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICAgICAgaWYgKHRpbWVMZWZ0IDw9IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAvLyBGYWRlIG91dFxuICAgICAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgICAgXG4gICAgICAvLyBTYWZldHkgY2xlYW51cCBhZnRlciA1IHNlY29uZHMgaW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSwgNTAwMCk7XG4gICAgfVxuICBcbiAgICAvLyBUYWtlIGEgd2ViY2FtIHBpY3R1cmUgYW5kIGltbWVkaWF0ZWx5IHN0b3AgdGhlIHN0cmVhbVxuICAgIGFzeW5jIGNhcHR1cmVXZWJjYW1JbWFnZShjYXB0dXJlTnVtYmVyKSB7XG4gICAgICBsZXQgc3RyZWFtID0gbnVsbDtcbiAgICAgIGxldCB0ZW1wVmlkZW8gPSBudWxsO1xuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICAvLyBGb3JtYXQgdGhlIGZpbGVuYW1lIHdpdGggdGhlIGN1cnJlbnQgY291bnRlclxuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IGB3ZWJjYW1fJHtTdHJpbmcoY2FwdHVyZU51bWJlcikucGFkU3RhcnQoMywgJzAnKX0uanBnYDtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBzdHJlYW0gd2l0aCBoaWdoIHJlc29sdXRpb24gY29uc3RyYWludHNcbiAgICAgICAgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICB3aWR0aDogeyBpZGVhbDogNDA5NiB9LFxuICAgICAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiAyMTYwIH0sXG4gICAgICAgICAgICBmYWNpbmdNb2RlOiBcInVzZXJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXVkaW86IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IHZpZGVvIGVsZW1lbnRcbiAgICAgICAgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdGVtcFZpZGVvLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgICAgIHRlbXBWaWRlby5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb25uZWN0IHN0cmVhbSB0byB2aWRlbyBlbGVtZW50XG4gICAgICAgIHRlbXBWaWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciB2aWRlbyB0byBpbml0aWFsaXplXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWaWRlbyBsb2FkaW5nIHRpbWVkIG91dCwgY29udGludWluZyBhbnl3YXlcIik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdGVtcFZpZGVvLm9ubG9hZGVkZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU21hbGwgZGVsYXkgdG8gZW5zdXJlIGEgY2xlYXIgZnJhbWVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2V0IGFjdHVhbCB2aWRlbyBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IHZpZGVvV2lkdGggPSB0ZW1wVmlkZW8udmlkZW9XaWR0aCB8fCA2NDA7XG4gICAgICAgIGNvbnN0IHZpZGVvSGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBhdCByZXNvbHV0aW9uOiAke3ZpZGVvV2lkdGh9eCR7dmlkZW9IZWlnaHR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBmcmFtZSBhdCBmdWxsIHJlc29sdXRpb25cbiAgICAgICAgY29uc3QgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdmlkZW9XaWR0aDtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSB2aWRlb0hlaWdodDtcbiAgICAgICAgY29uc3QgY3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKHRlbXBWaWRlbywgMCwgMCwgdmlkZW9XaWR0aCwgdmlkZW9IZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCB0byBKUEVHIHdpdGggaGlnaCBxdWFsaXR5XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9qcGVnJywgMC45NSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTYXZlIHRoZSBpbWFnZVxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGltYWdlRGF0YSwgZmlsZW5hbWUsICd3ZWJjYW0nLCB0aGlzLmNhcHR1cmVGb2xkZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYW4gdXBcbiAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYXB0dXJpbmcgd2ViY2FtIGltYWdlOicsIGVycm9yKTtcbiAgICAgICAgaWYgKHN0cmVhbSkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlbXBWaWRlbykge1xuICAgICAgICAgIHRlbXBWaWRlby5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyBDYXB0dXJlIHNjcmVlbiBpbWFnZSBmcm9tIGNhbnZhc1xuICAgIGFzeW5jIGNhcHR1cmVTY3JlZW5JbWFnZShjYW52YXNSZWYsIGNhcHR1cmVOdW1iZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHNjcmVlbl8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbFwiKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGE6IG51bGwsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgICAgICBjb25zdCBpbWFnZURhdGEgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdGhlIGltYWdlXG4gICAgICAgIGlmICh0aGlzLnNhdmVJbWFnZVRvU2VydmVyKSB7XG4gICAgICAgICAgY29uc3Qgc2F2ZVJlc3BvbnNlID0gYXdhaXQgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlcihpbWFnZURhdGEsIGZpbGVuYW1lLCAnc2NyZWVuJywgdGhpcy5jYXB0dXJlRm9sZGVyKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgc2NyZWVuIGltYWdlOiAke2ZpbGVuYW1lfSwgcmVzcG9uc2U6YCwgc2F2ZVJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4geyBpbWFnZURhdGEsIHNhdmVSZXNwb25zZSB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBpbWFnZURhdGEsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNhcHR1cmluZyBzY3JlZW4gaW1hZ2U6XCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHsgaW1hZ2VEYXRhOiBudWxsLCBzYXZlUmVzcG9uc2U6IG51bGwgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gU2F2ZSBwYXJhbWV0ZXIgQ1NWXG4gICAgYXN5bmMgc2F2ZVBhcmFtZXRlckNTVihjYXB0dXJlTnVtYmVyLCBwYXJhbXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHBhcmFtZXRlcl8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5jc3ZgO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIENTViBjb250ZW50IHdpdGggdHdvIGNvbHVtbnM6IG5hbWUgYW5kIHZhbHVlXG4gICAgICAgIGNvbnN0IGNzdkRhdGEgPSBbXG4gICAgICAgICAgXCJuYW1lLHZhbHVlXCIsXG4gICAgICAgICAgLi4uT2JqZWN0LmVudHJpZXMocGFyYW1zKS5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IGAke25hbWV9LCR7dmFsdWV9YClcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbnZlcnQgQ1NWIHRvIGRhdGEgVVJMXG4gICAgICAgIGNvbnN0IGNzdkJsb2IgPSBuZXcgQmxvYihbY3N2RGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgICAgY29uc3QgY3N2UmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNzdlJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKGNzdlJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIGNzdlJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgQ1NWIHVzaW5nIHRoZSBBUElcbiAgICAgICAgaWYgKHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICBjb25zdCBzYXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGNzdkRhdGFVcmwsIGZpbGVuYW1lLCAncGFyYW1ldGVycycsIHRoaXMuY2FwdHVyZUZvbGRlcik7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHBhcmFtZXRlciBDU1Y6ICR7ZmlsZW5hbWV9YCk7XG4gICAgICAgICAgcmV0dXJuIHNhdmVSZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGNhdGNoIChjc3ZFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2F2aW5nIHBhcmFtZXRlciBDU1Y6XCIsIGNzdkVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICAvLyBNYWluIGNhcHR1cmUgYW5kIHNob3cgcHJvY2Vzc1xuICAgIGFzeW5jIGNhcHR1cmVBbmRTaG93UHJldmlldyhjYXB0dXJlQ291bnRlciwgY2FudmFzUmVmLCBwb3NpdGlvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhcHR1cmUgcHJvY2VzcyB3aXRoIGNvdW50ZXI6ICR7Y2FwdHVyZUNvdW50ZXJ9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDE6IENhcHR1cmUgc2NyZWVuIGltYWdlXG4gICAgICAgIGNvbnN0IHsgaW1hZ2VEYXRhOiBzY3JlZW5JbWFnZSwgc2F2ZVJlc3BvbnNlOiBzY3JlZW5SZXNwb25zZSB9ID0gYXdhaXQgdGhpcy5jYXB0dXJlU2NyZWVuSW1hZ2UoY2FudmFzUmVmLCBjYXB0dXJlQ291bnRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIGNhcHR1cmUgbnVtYmVyIGZyb20gdGhlIHJlc3BvbnNlIGlmIGF2YWlsYWJsZSAoZm9yIGNvbnRpbnVvdXMgbnVtYmVyaW5nKVxuICAgICAgICBsZXQgdXNlZENhcHR1cmVOdW1iZXIgPSBjYXB0dXJlQ291bnRlcjtcbiAgICAgICAgaWYgKHNjcmVlblJlc3BvbnNlICYmIHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgICB1c2VkQ2FwdHVyZU51bWJlciA9IHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXI7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNlcnZlciBhc3NpZ25lZCBjYXB0dXJlIG51bWJlcjogJHt1c2VkQ2FwdHVyZU51bWJlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAyOiBDYXB0dXJlIHdlYmNhbSBpbWFnZSAoYW5kIGltbWVkaWF0ZWx5IHN0b3Agc3RyZWFtKVxuICAgICAgICBjb25zdCB3ZWJjYW1TdWNjZXNzID0gYXdhaXQgdGhpcy5jYXB0dXJlV2ViY2FtSW1hZ2UodXNlZENhcHR1cmVOdW1iZXIpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCAzOiBTYXZlIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgIGRvdF94OiBwb3NpdGlvbiA/IHBvc2l0aW9uLnggOiAwLFxuICAgICAgICAgIGRvdF95OiBwb3NpdGlvbiA/IHBvc2l0aW9uLnkgOiAwLFxuICAgICAgICAgIGNhbnZhc193aWR0aDogY2FudmFzUmVmLmN1cnJlbnQgPyBjYW52YXNSZWYuY3VycmVudC53aWR0aCA6IDAsXG4gICAgICAgICAgY2FudmFzX2hlaWdodDogY2FudmFzUmVmLmN1cnJlbnQgPyBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQgOiAwLFxuICAgICAgICAgIHdpbmRvd193aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgd2luZG93X2hlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhd2FpdCB0aGlzLnNhdmVQYXJhbWV0ZXJDU1YodXNlZENhcHR1cmVOdW1iZXIsIHBhcmFtcyk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDQ6IEluY3JlbWVudCBjb3VudGVyIGZvciBuZXh0IGNhcHR1cmVcbiAgICAgICAgaWYgKHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgc2VydmVyIGlzIG1hbmFnaW5nIG51bWJlcmluZywgdXNlIHRoZSBuZXh0IG51bWJlclxuICAgICAgICAgIGlmIChzY3JlZW5SZXNwb25zZSAmJiBzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIgKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgNTogVXBkYXRlIHN0YXR1c1xuICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlZCB3aXRoIGRvdCBhdDogeD0ke3Bvc2l0aW9uPy54fSwgeT0ke3Bvc2l0aW9uPy55fWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDY6IFNob3cgcHJldmlldyB1c2luZyB0aGUgaW4tbWVtb3J5IGltYWdlIGRhdGFcbiAgICAgICAgdGhpcy5zaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbVN1Y2Nlc3MgPyAnd2ViY2FtX2ltYWdlX2RhdGEnIDogbnVsbCwgcG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA3OiBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBwcmV2aWV3IGlzIGRvbmVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjIwMCk7IC8vIFdhaXQgbG9uZ2VyIHRoYW4gdGhlIHByZXZpZXcgZHVyYXRpb25cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgODogQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlIGFuZCBwcmV2aWV3OicsIGVycm9yKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGVycm9yIG1lc3NhZ2UgYWZ0ZXIgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgZXhwb3J0IGRlZmF1bHQgQ2FwdHVyZUhhbmRsZXI7Il0sIm5hbWVzIjpbIkNhcHR1cmVIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJzYXZlRnVuY3Rpb24iLCJjb3VudGVyU2V0dGVyIiwic3RhdHVzU2V0dGVyIiwidG9nZ2xlVG9wQmFyRnVuY3Rpb24iLCJzYXZlSW1hZ2VUb1NlcnZlciIsInNldENhcHR1cmVDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVGb2xkZXIiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiZG90UG9zaXRpb24iLCJwcmV2aWV3Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic3R5bGUiLCJjc3NUZXh0IiwiY3JlYXRlSW1hZ2VQcmV2aWV3IiwiaW1hZ2VEYXRhIiwibGFiZWwiLCJwcmV2aWV3IiwiaW1nIiwic3JjIiwib25sb2FkIiwiY29uc29sZSIsImxvZyIsIm9uZXJyb3IiLCJlIiwiZXJyb3IiLCJ0ZXh0TGFiZWwiLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwiZGVidWdJbmZvIiwic2NyZWVuUHJldmlldyIsIndlYmNhbVByZXZpZXciLCJwb3NpdGlvbkluZm8iLCJNYXRoIiwicm91bmQiLCJ4IiwieSIsInRpbWVyRWxlbWVudCIsImJvZHkiLCJ0aW1lTGVmdCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwib3BhY2l0eSIsInNldFRpbWVvdXQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ0b0ZpeGVkIiwiY2FwdHVyZVdlYmNhbUltYWdlIiwiY2FwdHVyZU51bWJlciIsInN0cmVhbSIsInRlbXBWaWRlbyIsImZpbGVuYW1lIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsIndpZHRoIiwiaWRlYWwiLCJoZWlnaHQiLCJmYWNpbmdNb2RlIiwiYXVkaW8iLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJwb3NpdGlvbiIsImxlZnQiLCJzcmNPYmplY3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpbWVvdXRJZCIsIndhcm4iLCJvbmxvYWRlZGRhdGEiLCJjbGVhclRpbWVvdXQiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJ0ZW1wQ2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsImdldFRyYWNrcyIsImZvckVhY2giLCJ0cmFjayIsInN0b3AiLCJyZW1vdmUiLCJjYXB0dXJlU2NyZWVuSW1hZ2UiLCJjYW52YXNSZWYiLCJjYW52YXMiLCJjdXJyZW50Iiwic2F2ZVJlc3BvbnNlIiwic2F2ZVBhcmFtZXRlckNTViIsInBhcmFtcyIsImNzdkRhdGEiLCJPYmplY3QiLCJlbnRyaWVzIiwibWFwIiwibmFtZSIsInZhbHVlIiwiam9pbiIsImNzdkJsb2IiLCJCbG9iIiwidHlwZSIsImNzdlJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVzdWx0IiwicmVhZEFzRGF0YVVSTCIsImNzdkVycm9yIiwiY2FwdHVyZUFuZFNob3dQcmV2aWV3IiwiY2FwdHVyZUNvdW50ZXIiLCJzY3JlZW5SZXNwb25zZSIsInVzZWRDYXB0dXJlTnVtYmVyIiwid2ViY2FtU3VjY2VzcyIsImRvdF94IiwiZG90X3kiLCJjYW52YXNfd2lkdGgiLCJjYW52YXNfaGVpZ2h0Iiwid2luZG93X3dpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsIndpbmRvd19oZWlnaHQiLCJpbm5lckhlaWdodCIsInRpbWVzdGFtcCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInByZXYiLCJtZXNzYWdlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/CaptureHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js":
/*!*************************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDotCountdown: () => (/* binding */ createDotCountdown),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   showImagePreview: () => (/* binding */ showImagePreview)\n/* harmony export */ });\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Show preview of captured images for exactly 2 seconds\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Improved function to show preview of captured images for exactly 2 seconds\nconst showImagePreview = (screenImage, webcamImage, dotPosition)=>{\n    // Create a preview container that centers in the screen\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 9999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n      opacity: 1;\n      transition: opacity 0.2s ease-in-out;\n    `;\n    // Add screen capture preview if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.style.cssText = `\n        max-width: 350px;\n        max-height: 250px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam capture preview if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.style.cssText = `\n        max-width: 350px;\n        max-height: 250px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n        positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -25px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add timer countdown\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n    previewContainer.appendChild(timerElement);\n    // Add the preview to the document\n    document.body.appendChild(previewContainer);\n    // Start countdown timer\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            timerElement.textContent = 'Closing...';\n            // Fade out the preview\n            previewContainer.style.opacity = '0';\n            // Remove after fade animation\n            setTimeout(()=>{\n                if (previewContainer && previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 200);\n        } else {\n            timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n        }\n    }, 100);\n    return previewContainer;\n};\n// Other utility functions remain the same...\n// Create and append a countdown element above a dot\nconst createDotCountdown = (position, canvasRect)=>{\n    // Create the countdown element directly above the dot\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'forced-countdown';\n    // Position it above the dot (calculate absolute position considering the canvas position)\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    countdownElement.style.cssText = `\n      position: fixed;\n      left: ${absoluteX}px;\n      top: ${absoluteY - 60}px;\n      transform: translateX(-50%);\n      color: red;\n      font-size: 36px;\n      font-weight: bold;\n      text-shadow: 0 0 10px white, 0 0 20px white;\n      z-index: 9999;\n      background-color: rgba(255, 255, 255, 0.8);\n      border: 2px solid red;\n      border-radius: 50%;\n      width: 50px;\n      height: 50px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    `;\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n// Draw a red dot on the canvas\nconst drawRedDot = (ctx, x, y, radius = 12)=>{\n    // Draw the dot with a glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect to the dot\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n// Initialize the canvas for drawing\nconst initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n// Generate a random position on the canvas\nconst getRandomPosition = (canvas, padding = 40)=>{\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9Eb3RDYXB0dXJlVXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLG9CQUFvQjtBQUNwQix3REFBd0Q7QUFFeEQsd0RBQXdEO0FBQ3hELG9CQUFvQjtBQUNwQix3REFBd0Q7QUFFeEQsNkVBQTZFO0FBQ3RFLE1BQU1BLG1CQUFtQixDQUFDQyxhQUFhQyxhQUFhQztJQUN2RCx3REFBd0Q7SUFDeEQsTUFBTUMsbUJBQW1CQyxTQUFTQyxhQUFhLENBQUM7SUFDaERGLGlCQUFpQkcsU0FBUyxHQUFHO0lBQzdCSCxpQkFBaUJJLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7O0lBY2xDLENBQUM7SUFFRCwwQ0FBMEM7SUFDMUMsSUFBSVIsYUFBYTtRQUNmLE1BQU1TLGdCQUFnQkwsU0FBU0MsYUFBYSxDQUFDO1FBQzdDSSxjQUFjRixLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7O01BSS9CLENBQUM7UUFFRCxNQUFNRSxZQUFZTixTQUFTQyxhQUFhLENBQUM7UUFDekNLLFVBQVVDLEdBQUcsR0FBR1g7UUFDaEJVLFVBQVVILEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7O01BSzNCLENBQUM7UUFFRCxNQUFNSSxjQUFjUixTQUFTQyxhQUFhLENBQUM7UUFDM0NPLFlBQVlDLFdBQVcsR0FBRztRQUMxQkQsWUFBWUwsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7TUFLN0IsQ0FBQztRQUVEQyxjQUFjSyxXQUFXLENBQUNKO1FBQzFCRCxjQUFjSyxXQUFXLENBQUNGO1FBQzFCVCxpQkFBaUJXLFdBQVcsQ0FBQ0w7SUFDL0I7SUFFQSwwQ0FBMEM7SUFDMUMsSUFBSVIsYUFBYTtRQUNmLE1BQU1jLGdCQUFnQlgsU0FBU0MsYUFBYSxDQUFDO1FBQzdDVSxjQUFjUixLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7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QyxHQUFHSCxLQUFLOEMsS0FBSyxDQUFDOUMsS0FBSytDLE1BQU0sS0FBTVIsQ0FBQUEsU0FBUyxJQUFJTSxPQUFNLEtBQU1BO0lBQzFEO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9Eb3RDYXB0dXJlVXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBEb3RDYXB0dXJlVXRpbC5qc1xuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRvdCBjYXB0dXJlIGFuZCBwcmV2aWV3IGRpc3BsYXlcblxuLy8gU2hvdyBwcmV2aWV3IG9mIGNhcHR1cmVkIGltYWdlcyBmb3IgZXhhY3RseSAyIHNlY29uZHNcbi8vIERvdENhcHR1cmVVdGlsLmpzXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZG90IGNhcHR1cmUgYW5kIHByZXZpZXcgZGlzcGxheVxuXG4vLyBJbXByb3ZlZCBmdW5jdGlvbiB0byBzaG93IHByZXZpZXcgb2YgY2FwdHVyZWQgaW1hZ2VzIGZvciBleGFjdGx5IDIgc2Vjb25kc1xuZXhwb3J0IGNvbnN0IHNob3dJbWFnZVByZXZpZXcgPSAoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlLCBkb3RQb3NpdGlvbikgPT4ge1xuICAgIC8vIENyZWF0ZSBhIHByZXZpZXcgY29udGFpbmVyIHRoYXQgY2VudGVycyBpbiB0aGUgc2NyZWVuXG4gICAgY29uc3QgcHJldmlld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHByZXZpZXdDb250YWluZXIuY2xhc3NOYW1lID0gJ2NhcHR1cmUtcHJldmlldy1jb250YWluZXInO1xuICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIHRvcDogNTAlO1xuICAgICAgbGVmdDogNTAlO1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZ2FwOiAyMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg1KTtcbiAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgICAgb3BhY2l0eTogMTtcbiAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycyBlYXNlLWluLW91dDtcbiAgICBgO1xuICAgIFxuICAgIC8vIEFkZCBzY3JlZW4gY2FwdHVyZSBwcmV2aWV3IGlmIGF2YWlsYWJsZVxuICAgIGlmIChzY3JlZW5JbWFnZSkge1xuICAgICAgY29uc3Qgc2NyZWVuUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2NyZWVuUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgc2NyZWVuSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICBzY3JlZW5JbWcuc3JjID0gc2NyZWVuSW1hZ2U7XG4gICAgICBzY3JlZW5JbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgbWF4LXdpZHRoOiAzNTBweDtcbiAgICAgICAgbWF4LWhlaWdodDogMjUwcHg7XG4gICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCBzY3JlZW5MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc2NyZWVuTGFiZWwudGV4dENvbnRlbnQgPSAnU2NyZWVuIENhcHR1cmUnO1xuICAgICAgc2NyZWVuTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgc2NyZWVuUHJldmlldy5hcHBlbmRDaGlsZChzY3JlZW5JbWcpO1xuICAgICAgc2NyZWVuUHJldmlldy5hcHBlbmRDaGlsZChzY3JlZW5MYWJlbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHNjcmVlblByZXZpZXcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgd2ViY2FtIGNhcHR1cmUgcHJldmlldyBpZiBhdmFpbGFibGVcbiAgICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICAgIGNvbnN0IHdlYmNhbVByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHdlYmNhbVByZXZpZXcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHdlYmNhbUltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgd2ViY2FtSW1nLnNyYyA9IHdlYmNhbUltYWdlO1xuICAgICAgd2ViY2FtSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIG1heC13aWR0aDogMzUwcHg7XG4gICAgICAgIG1heC1oZWlnaHQ6IDI1MHB4O1xuICAgICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgd2ViY2FtTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHdlYmNhbUxhYmVsLnRleHRDb250ZW50ID0gJ1dlYmNhbSBDYXB0dXJlJztcbiAgICAgIHdlYmNhbUxhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIHdlYmNhbVByZXZpZXcuYXBwZW5kQ2hpbGQod2ViY2FtSW1nKTtcbiAgICAgIHdlYmNhbVByZXZpZXcuYXBwZW5kQ2hpbGQod2ViY2FtTGFiZWwpO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWJjYW1QcmV2aWV3KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGRvdCBwb3NpdGlvbiBpbmZvIGlmIGF2YWlsYWJsZVxuICAgIGlmIChkb3RQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3NpdGlvbkluZm8udGV4dENvbnRlbnQgPSBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLnkpfWA7XG4gICAgICBwb3NpdGlvbkluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC0yNXB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9zaXRpb25JbmZvKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHRpbWVyIGNvdW50ZG93blxuICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgXG4gICAgLy8gQWRkIHRoZSBwcmV2aWV3IHRvIHRoZSBkb2N1bWVudFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgXG4gICAgLy8gU3RhcnQgY291bnRkb3duIHRpbWVyXG4gICAgbGV0IHRpbWVMZWZ0ID0gMi4wO1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGltZUxlZnQgLT0gMC4xO1xuICAgICAgaWYgKHRpbWVMZWZ0IDw9IDApIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICdDbG9zaW5nLi4uJztcbiAgICAgICAgXG4gICAgICAgIC8vIEZhZGUgb3V0IHRoZSBwcmV2aWV3XG4gICAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBhZnRlciBmYWRlIGFuaW1hdGlvblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lciAmJiBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gICAgXG4gICAgcmV0dXJuIHByZXZpZXdDb250YWluZXI7XG4gIH07XG4gIFxuICAvLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9ucyByZW1haW4gdGhlIHNhbWUuLi5cbiAgICBcbiAgLy8gQ3JlYXRlIGFuZCBhcHBlbmQgYSBjb3VudGRvd24gZWxlbWVudCBhYm92ZSBhIGRvdFxuICBleHBvcnQgY29uc3QgY3JlYXRlRG90Q291bnRkb3duID0gKHBvc2l0aW9uLCBjYW52YXNSZWN0KSA9PiB7XG4gICAgLy8gQ3JlYXRlIHRoZSBjb3VudGRvd24gZWxlbWVudCBkaXJlY3RseSBhYm92ZSB0aGUgZG90XG4gICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2ZvcmNlZC1jb3VudGRvd24nO1xuICAgIFxuICAgIC8vIFBvc2l0aW9uIGl0IGFib3ZlIHRoZSBkb3QgKGNhbGN1bGF0ZSBhYnNvbHV0ZSBwb3NpdGlvbiBjb25zaWRlcmluZyB0aGUgY2FudmFzIHBvc2l0aW9uKVxuICAgIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLng7XG4gICAgY29uc3QgYWJzb2x1dGVZID0gY2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55O1xuICAgIFxuICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgICAgdG9wOiAke2Fic29sdXRlWSAtIDYwfXB4O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgY29sb3I6IHJlZDtcbiAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNTBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgIFxuICAgIHJldHVybiBjb3VudGRvd25FbGVtZW50O1xuICB9O1xuICBcbiAgLy8gRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhc1xuICBleHBvcnQgY29uc3QgZHJhd1JlZERvdCA9IChjdHgsIHgsIHksIHJhZGl1cyA9IDEyKSA9PiB7XG4gICAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBnbG93IGVmZmVjdFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAncmVkJztcbiAgICBjdHguZmlsbCgpO1xuICAgIFxuICAgIC8vIEFkZCBnbG93IGVmZmVjdCB0byB0aGUgZG90XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfTtcbiAgXG4gIC8vIEluaXRpYWxpemUgdGhlIGNhbnZhcyBmb3IgZHJhd2luZ1xuICBleHBvcnQgY29uc3QgaW5pdGlhbGl6ZUNhbnZhcyA9IChjYW52YXMsIHBhcmVudCkgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggcGFyZW50XG4gICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIGNhbnZhcyBhbmQgc2V0IHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIFxuICAvLyBHZW5lcmF0ZSBhIHJhbmRvbSBwb3NpdGlvbiBvbiB0aGUgY2FudmFzXG4gIGV4cG9ydCBjb25zdCBnZXRSYW5kb21Qb3NpdGlvbiA9IChjYW52YXMsIHBhZGRpbmcgPSA0MCkgPT4ge1xuICAgIGlmICghY2FudmFzKSByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICAgIFxuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoIHx8IDQwMDsgIC8vIEZhbGxiYWNrIGlmIHdpZHRoIGlzIDBcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IHx8IDMwMDsgLy8gRmFsbGJhY2sgaWYgaGVpZ2h0IGlzIDBcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdpZHRoIC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmcsXG4gICAgICB5OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGVpZ2h0IC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmdcbiAgICB9O1xuICB9OyJdLCJuYW1lcyI6WyJzaG93SW1hZ2VQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImRvdFBvc2l0aW9uIiwicHJldmlld0NvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsInNjcmVlblByZXZpZXciLCJzY3JlZW5JbWciLCJzcmMiLCJzY3JlZW5MYWJlbCIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJ3ZWJjYW1QcmV2aWV3Iiwid2ViY2FtSW1nIiwid2ViY2FtTGFiZWwiLCJwb3NpdGlvbkluZm8iLCJNYXRoIiwicm91bmQiLCJ4IiwieSIsInRpbWVyRWxlbWVudCIsImJvZHkiLCJ0aW1lTGVmdCIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwib3BhY2l0eSIsInNldFRpbWVvdXQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ0b0ZpeGVkIiwiY3JlYXRlRG90Q291bnRkb3duIiwicG9zaXRpb24iLCJjYW52YXNSZWN0IiwiY291bnRkb3duRWxlbWVudCIsImFic29sdXRlWCIsImxlZnQiLCJhYnNvbHV0ZVkiLCJ0b3AiLCJkcmF3UmVkRG90IiwiY3R4IiwicmFkaXVzIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsU3R5bGUiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJpbml0aWFsaXplQ2FudmFzIiwiY2FudmFzIiwicGFyZW50Iiwid2lkdGgiLCJjbGllbnRXaWR0aCIsImhlaWdodCIsImNsaWVudEhlaWdodCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsUmVjdCIsImdldFJhbmRvbVBvc2l0aW9uIiwicGFkZGluZyIsImZsb29yIiwicmFuZG9tIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/DotCaptureUtil.js\n");

/***/ })

};
;