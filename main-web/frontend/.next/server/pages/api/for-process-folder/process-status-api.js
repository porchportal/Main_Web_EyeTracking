"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/for-process-folder/process-status-api";
exports.ids = ["pages/api/for-process-folder/process-status-api"];
exports.modules = {

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/for-process-folder/process-status-api.js */ \"(api-node)/./pages/api/for-process-folder/process-status-api.js\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/for-process-folder/process-status-api\",\n        pathname: \"/api/for-process-folder/process-status-api\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGZm9yLXByb2Nlc3MtZm9sZGVyJTJGcHJvY2Vzcy1zdGF0dXMtYXBpJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZmb3ItcHJvY2Vzcy1mb2xkZXIlMkZwcm9jZXNzLXN0YXR1cy1hcGkuanMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ0U7QUFDMUQ7QUFDaUY7QUFDakY7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGdGQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxnRkFBUTtBQUNwQztBQUNPLHdCQUF3Qix5R0FBbUI7QUFDbEQ7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsICdkZWZhdWx0Jyk7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCAnY29uZmlnJyk7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZm9yLXByb2Nlc3MtZm9sZGVyL3Byb2Nlc3Mtc3RhdHVzLWFwaVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6ICcnLFxuICAgICAgICBmaWxlbmFtZTogJydcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/for-process-folder/process-status-api.js":
/*!************************************************************!*\
  !*** ./pages/api/for-process-folder/process-status-api.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! form-data */ \"form-data\");\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_5__);\n// pages/api/process-status-api.js - API to handle process status checks and triggers\n\n\n\n\n\n\n// Convert exec to Promise-based\nconst execPromise = util__WEBPACK_IMPORTED_MODULE_3___default().promisify(child_process__WEBPACK_IMPORTED_MODULE_2__.exec);\n// Function to send a single image to the Python backend for processing\n// Modified function to preserve original parameter data and add new metrics\n// Fixed function to properly process webcam images through the Python backend\nasync function processImageWithPython(inputPath, outputPath, setNumber, captureDir, enhancePath) {\n    try {\n        console.log(`Starting to process image: ${inputPath}`);\n        // Check if input file exists\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(inputPath)) {\n            console.error(`Input file does not exist: ${inputPath}`);\n            return null;\n        }\n        // Get the backend URL\n        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';\n        const apiKey = process.env.API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV';\n        // Create form data\n        const formData = new (form_data__WEBPACK_IMPORTED_MODULE_5___default())();\n        // Open the file as a stream\n        const fileStream = fs__WEBPACK_IMPORTED_MODULE_0___default().createReadStream(inputPath);\n        // Log the file size\n        const stats = fs__WEBPACK_IMPORTED_MODULE_0___default().statSync(inputPath);\n        console.log(`File size: ${stats.size} bytes`);\n        // Add file to form data\n        formData.append('file', fileStream, {\n            filename: path__WEBPACK_IMPORTED_MODULE_1___default().basename(inputPath),\n            contentType: 'image/jpeg'\n        });\n        // Add processing parameters - these must match the FastAPI backend expectations\n        // formData.append('showHeadPose', 'false');\n        // formData.append('showBoundingBox', 'true');\n        // formData.append('showMask', 'false');\n        // formData.append('showParameters', 'true');\n        formData.append('showHeadPose', 'false');\n        formData.append('showBoundingBox', 'false');\n        formData.append('showMask', 'false');\n        formData.append('showParameters', 'false');\n        console.log(`Sending ${inputPath} to Python backend at ${backendUrl}/process-image`);\n        // Log request details for debugging\n        console.log('API Key being used:', apiKey);\n        console.log('Form data parameters:', 'showHeadPose=true', 'showBoundingBox=true', 'showMask=false', 'showParameters=true');\n        // Call the Python backend\n        const response = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(`${backendUrl}/process-image`, {\n            method: 'POST',\n            headers: {\n                'X-API-Key': apiKey\n            },\n            body: formData,\n            timeout: 30000 // 30 second timeout for processing large images\n        });\n        // Log the response status\n        console.log(`Backend response status: ${response.status}`);\n        if (!response.ok) {\n            let errorText = '';\n            try {\n                errorText = await response.text();\n            } catch (e) {\n                errorText = 'Could not read error details';\n            }\n            console.error(`Backend error: ${response.status} ${response.statusText}`);\n            console.error(`Response body: ${errorText}`);\n            throw new Error(`Backend returned ${response.status}: ${response.statusText}`);\n        }\n        // Parse the response as JSON\n        let result;\n        try {\n            const responseText = await response.text();\n            console.log(`Response text (first 200 chars): ${responseText.substring(0, 200)}...`);\n            result = JSON.parse(responseText);\n        } catch (error) {\n            console.error('Error parsing response JSON:', error);\n            throw new Error(`Failed to parse backend response: ${error.message}`);\n        }\n        // Log result status\n        console.log('Backend processing result:', result.success ? 'Success' : 'Failed');\n        if (result.success) {\n            // Check if a face was detected\n            if (result.face_detected === false) {\n                console.log('No face detected in the image - saving original image');\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                // Still update parameter file with this information\n                await updateParameterFile(setNumber, {\n                    face_detected: false\n                }, captureDir, enhancePath);\n                return null;\n            }\n            // Verify we have the processed image data\n            if (!result.image || !result.image.data) {\n                console.error('Backend response missing image data');\n                // Fall back to copying the original image\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                console.log(`Copied original image as fallback to: ${outputPath}`);\n                // Update parameter file with minimal info\n                await updateParameterFile(setNumber, {\n                    face_detected: false\n                }, captureDir, enhancePath);\n                return null;\n            }\n            // Save the processed image\n            try {\n                const imageBuffer = Buffer.from(result.image.data, 'base64');\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(outputPath, imageBuffer);\n                console.log(`Saved processed image to ${outputPath}, size: ${imageBuffer.length} bytes`);\n            } catch (error) {\n                console.error(`Error saving processed image: ${error.message}`);\n                // Fall back to copying the original image\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                console.log(`Copied original image as fallback to: ${outputPath}`);\n            }\n            // Check for metrics in the response\n            if (result.metrics) {\n                console.log('Metrics received from backend:', JSON.stringify(result.metrics));\n                // Update parameter file with the metrics\n                await updateParameterFile(setNumber, result.metrics, captureDir, enhancePath);\n                return result.metrics;\n            } else {\n                console.log('No metrics received from backend, using face_detected status only');\n                // Update parameter file with just the face detection status\n                await updateParameterFile(setNumber, {\n                    face_detected: true\n                }, captureDir, enhancePath);\n                return {\n                    face_detected: true\n                };\n            }\n        } else {\n            console.error(`Backend processing failed: ${result.error || 'Unknown error'}`);\n            // Fall back to copying the original image\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n            console.log(`Copied original image as fallback to: ${outputPath}`);\n            // Update parameter file with error information\n            await updateParameterFile(setNumber, null, captureDir, enhancePath);\n            return null;\n        }\n    } catch (error) {\n        console.error(`Error processing image with Python backend: ${error.message}`);\n        console.error(error.stack);\n        // Fall back to copying the original image\n        try {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n            console.log(`Copied original image as fallback after error: ${outputPath}`);\n        } catch (copyError) {\n            console.error(`Error copying original image: ${copyError.message}`);\n        }\n        // Update parameter file with error information\n        await updateParameterFile(setNumber, null, captureDir, enhancePath);\n        return null;\n    }\n}\n// New function to update parameter file with new metrics while preserving original data\n// Updated function to properly handle parameter file updates\nasync function updateParameterFile(setNumber, metrics, captureDir, enhancePath) {\n    console.log(`Updating parameter file for set ${setNumber} with new metrics`);\n    // Determine parameter file paths\n    const originalParamPaths = [\n        path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `parameters_${setNumber}.csv`),\n        path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `parameter_${setNumber}.csv`)\n    ];\n    // Output parameter file path\n    const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n    // Load original parameter data if available\n    let originalParams = new Map();\n    let originalParamFound = false;\n    let originalFirstLineIsHeader = false;\n    for (const originalPath of originalParamPaths){\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(originalPath)) {\n            console.log(`Found original parameter file: ${originalPath}`);\n            originalParamFound = true;\n            try {\n                const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(originalPath, 'utf8');\n                console.log(`Original parameter file content: ${content.substring(0, 100)}...`);\n                const lines = content.split('\\n');\n                // Check if the first line is a header\n                const firstLine = lines[0].trim();\n                originalFirstLineIsHeader = firstLine.toLowerCase().includes('parameter') || firstLine.toLowerCase().includes('name');\n                // Skip header line if it exists\n                const startLine = originalFirstLineIsHeader ? 1 : 0;\n                // Parse the original parameters\n                for(let i = startLine; i < lines.length; i++){\n                    const line = lines[i].trim();\n                    if (line) {\n                        const parts = line.split(',');\n                        if (parts.length >= 2) {\n                            const paramName = parts[0].trim();\n                            const paramValue = parts[1].trim();\n                            originalParams.set(paramName, paramValue);\n                            console.log(`Loaded parameter: ${paramName}=${paramValue}`);\n                        }\n                    }\n                }\n                console.log(`Loaded ${originalParams.size} parameters from original file`);\n                break; // Found and loaded one parameter file, no need to check the other\n            } catch (err) {\n                console.error(`Error reading original parameter file: ${err.message}`);\n            }\n        }\n    }\n    // Prepare CSV content with header\n    let csvContent = 'Parameter,Value\\n';\n    // Add original parameters first (except those we'll update with new values)\n    const excludeParams = [\n        'pitch',\n        'yaw',\n        'roll',\n        'face_width',\n        'face_height',\n        'left_eye_x',\n        'left_eye_y',\n        'right_eye_x',\n        'right_eye_y',\n        'face_box_min_x',\n        'face_box_min_y',\n        'face_box_max_x',\n        'face_box_max_y'\n    ];\n    // Log all original parameters for debugging\n    console.log(\"Original parameters:\");\n    originalParams.forEach((value, key)=>{\n        console.log(`  ${key}: ${value}`);\n    });\n    // Add existing parameters (except those we'll update)\n    originalParams.forEach((value, key)=>{\n        if (!excludeParams.includes(key.toLowerCase())) {\n            csvContent += `${key},${value}\\n`;\n        }\n    });\n    // Now add the new metrics\n    if (metrics && metrics.face_detected !== false) {\n        console.log(\"Adding new metrics from face detection\");\n        // Add head pose data\n        if (metrics.head_pose) {\n            console.log(`Adding head pose: pitch=${metrics.head_pose.pitch}, yaw=${metrics.head_pose.yaw}, roll=${metrics.head_pose.roll}`);\n            csvContent += `pitch,${metrics.head_pose.pitch}\\n`;\n            csvContent += `yaw,${metrics.head_pose.yaw}\\n`;\n            csvContent += `roll,${metrics.head_pose.roll}\\n`;\n        }\n        // Add eye centers if available\n        if (metrics.eye_centers) {\n            if (metrics.eye_centers.left) {\n                console.log(`Adding left eye: ${metrics.eye_centers.left.join(',')}`);\n                csvContent += `left_eye_x,${metrics.eye_centers.left[0]}\\n`;\n                csvContent += `left_eye_y,${metrics.eye_centers.left[1]}\\n`;\n            }\n            if (metrics.eye_centers.right) {\n                console.log(`Adding right eye: ${metrics.eye_centers.right.join(',')}`);\n                csvContent += `right_eye_x,${metrics.eye_centers.right[0]}\\n`;\n                csvContent += `right_eye_y,${metrics.eye_centers.right[1]}\\n`;\n            }\n        }\n        // Add face box information if available\n        if (metrics.face_box) {\n            if (metrics.face_box.min) {\n                console.log(`Adding face box min: ${metrics.face_box.min.join(',')}`);\n                csvContent += `face_box_min_x,${metrics.face_box.min[0]}\\n`;\n                csvContent += `face_box_min_y,${metrics.face_box.min[1]}\\n`;\n            }\n            if (metrics.face_box.max) {\n                console.log(`Adding face box max: ${metrics.face_box.max.join(',')}`);\n                csvContent += `face_box_max_x,${metrics.face_box.max[0]}\\n`;\n                csvContent += `face_box_max_y,${metrics.face_box.max[1]}\\n`;\n                // Calculate and add face width and height\n                if (metrics.face_box.min) {\n                    const faceWidth = Math.round(metrics.face_box.max[0] - metrics.face_box.min[0]);\n                    const faceHeight = Math.round(metrics.face_box.max[1] - metrics.face_box.min[1]);\n                    console.log(`Adding face dimensions: width=${faceWidth}, height=${faceHeight}`);\n                    csvContent += `face_width,${faceWidth}\\n`;\n                    csvContent += `face_height,${faceHeight}\\n`;\n                }\n            }\n        }\n    } else if (originalParamFound) {\n        // If no new metrics but we had original data for these fields, preserve them\n        console.log(\"No new metrics, preserving original face tracking data if available\");\n        const fieldsToPreserve = [\n            'pitch',\n            'yaw',\n            'roll',\n            'face_width',\n            'face_height',\n            'left_eye_x',\n            'left_eye_y',\n            'right_eye_x',\n            'right_eye_y',\n            'face_box_min_x',\n            'face_box_min_y',\n            'face_box_max_x',\n            'face_box_max_y'\n        ];\n        fieldsToPreserve.forEach((field)=>{\n            if (originalParams.has(field)) {\n                console.log(`Preserving original ${field}=${originalParams.get(field)}`);\n                csvContent += `${field},${originalParams.get(field)}\\n`;\n            }\n        });\n    } else {\n        // No metrics and no original data, add placeholder information\n        console.log(\"No metrics and no original data, adding placeholder\");\n        csvContent += 'info,No face detected or processing failed\\n';\n    }\n    // Log the final CSV content for debugging\n    console.log(`Final parameter file content:\\n${csvContent}`);\n    // Write the updated CSV file\n    fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(paramDestPath, csvContent);\n    console.log(`Wrote updated parameter file to: ${paramDestPath}`);\n    // Verify the file was written\n    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramDestPath)) {\n        console.log(`Parameter file successfully updated: ${paramDestPath}`);\n        return true;\n    } else {\n        console.error(`Failed to create parameter file: ${paramDestPath}`);\n        return false;\n    }\n}\n// Function to process files via the FastAPI backend\nasync function processFilesViaBackend(setNumbers) {\n    try {\n        // Get the backend URL from environment variable or use default\n        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';\n        const apiKey = process.env.API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV';\n        // Call the FastAPI backend to process the files\n        const response = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(`${backendUrl}/process-batch`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-API-Key': apiKey\n            },\n            body: JSON.stringify({\n                set_numbers: setNumbers,\n                show_head_pose: true,\n                show_bounding_box: true,\n                show_mask: false,\n                show_parameters: false\n            })\n        });\n        // Check if the request was successful\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error('Backend processing error:', errorText);\n            return {\n                success: false,\n                error: `Backend error: ${response.status} ${response.statusText}`\n            };\n        }\n        // Parse the response\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error('Error calling backend for processing:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Function to process files directly in Node.js\n// Function to process files directly in Node.js\nasync function processFilesDirectly(setNumbers, captureDir, enhancePath, progressFilePath) {\n    try {\n        console.log(\"=== STARTING DIRECT PROCESSING ===\");\n        console.log(`Processing sets: ${setNumbers.join(', ')}`);\n        console.log(`Capture directory: ${captureDir}`);\n        console.log(`Enhance directory: ${enhancePath}`);\n        // Get current progress or initialize\n        let progress = {\n            currentSet: 0,\n            totalSets: setNumbers.length,\n            processedSets: [],\n            startTime: new Date().toISOString(),\n            lastUpdateTime: new Date().toISOString()\n        };\n        // Process each set\n        for (const setNumber of setNumbers){\n            try {\n                console.log(`\\n--- Processing set ${setNumber} ---`);\n                progress.currentSet = setNumber;\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progress, null, 2));\n                console.log(`Updated progress file for set ${setNumber}`);\n                // Process webcam image\n                const webcamSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `webcam_${setNumber}.jpg`);\n                const webcamDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `webcam_enhance_${setNumber}.jpg`);\n                console.log(`Looking for webcam image at: ${webcamSrcPath}`);\n                if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(webcamSrcPath)) {\n                    console.log(`Found webcam image: ${webcamSrcPath}`);\n                    try {\n                        // Process the image through the Python backend\n                        console.log(`Sending webcam image for set ${setNumber} to process_image_handler`);\n                        // We're passing the capture directory and enhance path to help with parameter file handling\n                        const metrics = await processImageWithPython(webcamSrcPath, webcamDestPath, setNumber, captureDir, enhancePath);\n                        if (metrics) {\n                            console.log(`✅ Successfully processed webcam image and extracted metrics for set ${setNumber}`);\n                        } else {\n                            console.warn(`⚠️ Process completed but no metrics returned for set ${setNumber}`);\n                            // Ensure the image is copied even if no metrics were returned\n                            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(webcamDestPath)) {\n                                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(webcamSrcPath, webcamDestPath);\n                                console.log(`Copied original webcam image as fallback for set ${setNumber}`);\n                            }\n                        }\n                    } catch (err) {\n                        console.error(`❌ Error processing webcam image for set ${setNumber}: ${err.message}`);\n                        console.error(err.stack);\n                        // Fallback to copying the original file\n                        console.log(`Copying original webcam image as fallback for set ${setNumber}`);\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(webcamSrcPath, webcamDestPath);\n                    }\n                } else {\n                    console.warn(`⚠️ Webcam image not found for set ${setNumber}: ${webcamSrcPath}`);\n                }\n                // Process screen image if it exists\n                const screenSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `screen_${setNumber}.jpg`);\n                const screenDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `screen_enhance_${setNumber}.jpg`);\n                console.log(`Looking for screen image at: ${screenSrcPath}`);\n                if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(screenSrcPath)) {\n                    console.log(`Screen image found: ${screenSrcPath}`);\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(screenSrcPath, screenDestPath);\n                    console.log(`Copied screen image to: ${screenDestPath}`);\n                } else {\n                    console.warn(`⚠️ Screen image not found for set ${setNumber}`);\n                }\n                // Verify that we have a parameter file for this set in the enhance directory\n                const enhanceParamPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n                if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhanceParamPath)) {\n                    console.log(`Parameter file not created during processing for set ${setNumber}, checking for original...`);\n                    await updateParameterFile(setNumber, null, captureDir, enhancePath);\n                }\n                // Update progress\n                progress.processedSets.push(setNumber);\n                progress.lastUpdateTime = new Date().toISOString();\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progress, null, 2));\n                console.log(`Updated progress - set ${setNumber} completed`);\n                // Add a small delay to prevent overwhelming the system\n                console.log(`Waiting 500ms before processing next set...`);\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n            } catch (err) {\n                console.error(`❌ Error processing set ${setNumber}:`, err);\n            }\n        }\n        console.log(\"\\n=== PROCESSING COMPLETED ===\");\n        console.log(`Total sets processed: ${progress.processedSets.length}/${progress.totalSets}`);\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('❌ Error in direct processing:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Helper function to copy parameter files\nasync function copyParameterFile(captureDir, enhancePath, setNumber) {\n    // Try both parameter and parameters naming\n    const paramFileNames = [\n        `parameters_${setNumber}.csv`,\n        `parameter_${setNumber}.csv`\n    ];\n    let paramFound = false;\n    for (const paramFileName of paramFileNames){\n        const paramSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, paramFileName);\n        console.log(`Looking for parameter file at: ${paramSrcPath}`);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramSrcPath)) {\n            console.log(`Parameter file found: ${paramSrcPath}`);\n            paramFound = true;\n            // Determine destination name (change parameter to parameter_enhance)\n            const destFileName = 'parameter_enhance_' + setNumber + '.csv';\n            const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, destFileName);\n            console.log(`Copying parameter file to: ${paramDestPath}`);\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(paramSrcPath, paramDestPath);\n            // Verify parameter file copy\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramDestPath)) {\n                console.log(`✅ Parameter file copied successfully`);\n                // Read content to verify\n                try {\n                    const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(paramDestPath, 'utf8');\n                    const firstLine = content.split('\\n')[0];\n                    console.log(`Parameter file content starts with: ${firstLine}`);\n                } catch (readErr) {\n                    console.error(`Error reading parameter file: ${readErr.message}`);\n                }\n            } else {\n                console.error(`❌ Error: Parameter destination file doesn't exist after copy!`);\n            }\n            break; // Found and copied one parameter file, no need to check the other\n        }\n    }\n    if (!paramFound) {\n        console.log(`⚠️ No parameter files found for set ${setNumber}`);\n        // Create an empty parameter file if none exists\n        const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n        const emptyContent = 'Parameter,Value\\ninfo,No face detected or processing failed\\n';\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(paramDestPath, emptyContent);\n        console.log(`⚠️ Created empty parameter file: ${paramDestPath}`);\n    }\n}\n// Main handler for API requests\nasync function handler(req, res) {\n    // Handle GET request to check processing status\n    if (req.method === 'GET') {\n        try {\n            const capturesPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'eye_tracking_captures');\n            const enhancePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'enhance');\n            // Create captures directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures'))) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures'), {\n                    recursive: true\n                });\n            }\n            // Create capture directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesPath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(capturesPath, {\n                    recursive: true\n                });\n            }\n            // Create enhance directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(enhancePath, {\n                    recursive: true\n                });\n            }\n            // Check if there's a processing.lock file (indicating processing is in progress)\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing.lock');\n            const isProcessing = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath);\n            // Check for progress information file\n            const progressFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing_progress.json');\n            let progressInfo = {\n                currentSet: 0,\n                totalSets: 0,\n                processedSets: [],\n                startTime: null,\n                lastUpdateTime: null\n            };\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(progressFilePath)) {\n                try {\n                    const progressData = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(progressFilePath, 'utf8');\n                    progressInfo = JSON.parse(progressData);\n                } catch (err) {\n                    console.error(\"Error reading progress file:\", err);\n                }\n            }\n            // Count files in each directory\n            const captureFiles = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesPath) ? fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(capturesPath).filter((file)=>file.startsWith('webcam_') && file.endsWith('.jpg')).length : 0;\n            const enhanceFiles = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath) ? fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(enhancePath).filter((file)=>file.startsWith('webcam_enhance_') && file.endsWith('.jpg')).length : 0;\n            return res.status(200).json({\n                success: true,\n                isProcessing,\n                captureCount: captureFiles,\n                enhanceCount: enhanceFiles,\n                needsProcessing: captureFiles > enhanceFiles,\n                progress: progressInfo\n            });\n        } catch (error) {\n            console.error('Error checking process status:', error);\n            return res.status(500).json({\n                success: false,\n                error: error.message\n            });\n        }\n    } else if (req.method === 'POST') {\n        try {\n            // Get list of files to process from request body\n            const { setNumbers } = req.body;\n            if (!setNumbers || !Array.isArray(setNumbers) || setNumbers.length === 0) {\n                return res.status(400).json({\n                    success: false,\n                    error: 'No set numbers provided for processing'\n                });\n            }\n            // Make sure the directory exists before creating the lock file\n            const capturesDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures');\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesDir)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(capturesDir, {\n                    recursive: true\n                });\n            }\n            // Create enhance directory if it doesn't exist\n            const enhancePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'enhance');\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(enhancePath, {\n                    recursive: true\n                });\n            }\n            // Check if there's already a lock file\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(capturesDir, 'processing.lock');\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                return res.status(409).json({\n                    success: false,\n                    error: 'Processing is already in progress'\n                });\n            }\n            // Create lock file to indicate processing is in progress\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(lockFilePath, new Date().toISOString());\n                console.log(`Created lock file at ${lockFilePath}`);\n            } catch (err) {\n                console.error(`Error creating lock file: ${err.message}`);\n                return res.status(500).json({\n                    success: false,\n                    error: `Failed to create lock file: ${err.message}`\n                });\n            }\n            // Create initial progress file\n            const progressFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(capturesDir, 'processing_progress.json');\n            const progressInfo = {\n                currentSet: 0,\n                totalSets: setNumbers.length,\n                processedSets: [],\n                startTime: new Date().toISOString(),\n                lastUpdateTime: new Date().toISOString()\n            };\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progressInfo, null, 2));\n            } catch (err) {\n                console.error(`Error creating progress file: ${err.message}`);\n            }\n            // Define paths for processing\n            const captureDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'eye_tracking_captures');\n            // Determine which processing method to use\n            const useBackend = process.env.USE_PYTHON_BACKEND === 'true';\n            if (useBackend) {\n                console.log(`Starting backend processing of ${setNumbers.length} sets...`);\n                // Start processing with the Python backend\n                processFilesViaBackend(setNumbers).then((result)=>{\n                    console.log('Backend processing completed with result:', result);\n                    // Clean up the lock file when done\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                }).catch((err)=>{\n                    console.error('Backend processing failed:', err);\n                    // Clean up the lock file on error\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: 'Processing started',\n                    setsToProcess: setNumbers.length,\n                    processingMethod: 'python-backend'\n                });\n            } else {\n                console.log(`Starting direct processing of ${setNumbers.length} sets...`);\n                // Start processing in the background using direct Node.js processing\n                processFilesDirectly(setNumbers, captureDir, enhancePath, progressFilePath).then((result)=>{\n                    console.log('Processing completed with result:', result);\n                    // Clean up the lock file when done\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                }).catch((err)=>{\n                    console.error('Processing failed:', err);\n                    // Clean up the lock file on error\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: 'Processing started',\n                    setsToProcess: setNumbers.length,\n                    processingMethod: 'direct'\n                });\n            }\n        } catch (error) {\n            console.error('Error triggering processing:', error);\n            // If there's an error, make sure to delete the lock file\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing.lock');\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                try {\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                } catch (e) {\n                    console.error('Error removing lock file:', e);\n                }\n            }\n            return res.status(500).json({\n                success: false,\n                error: error.message\n            });\n        }\n    } else {\n        return res.status(405).json({\n            success: false,\n            error: 'Method not allowed'\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxRkFBcUY7QUFDakU7QUFDSTtBQUNhO0FBQ2I7QUFDTztBQUNFO0FBRWpDLGdDQUFnQztBQUNoQyxNQUFNTSxjQUFjSCxxREFBYyxDQUFDRCwrQ0FBSUE7QUFFdkMsdUVBQXVFO0FBQ3ZFLDRFQUE0RTtBQUM1RSw4RUFBOEU7QUFDOUUsZUFBZU0sdUJBQXVCQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFdBQVc7SUFDN0YsSUFBSTtRQUNGQyxRQUFRQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsRUFBRU4sV0FBVztRQUVyRCw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDVCxvREFBYSxDQUFDUyxZQUFZO1lBQzdCSyxRQUFRRyxLQUFLLENBQUMsQ0FBQywyQkFBMkIsRUFBRVIsV0FBVztZQUN2RCxPQUFPO1FBQ1Q7UUFFQSxzQkFBc0I7UUFDdEIsTUFBTVMsYUFBYUMsUUFBUUMsR0FBRyxDQUFDQyxXQUFXLElBQUk7UUFDOUMsTUFBTUMsU0FBU0gsUUFBUUMsR0FBRyxDQUFDRyxPQUFPLElBQUk7UUFFdEMsbUJBQW1CO1FBQ25CLE1BQU1DLFdBQVcsSUFBSW5CLGtEQUFRQTtRQUU3Qiw0QkFBNEI7UUFDNUIsTUFBTW9CLGFBQWF6QiwwREFBbUIsQ0FBQ1M7UUFFdkMsb0JBQW9CO1FBQ3BCLE1BQU1rQixRQUFRM0Isa0RBQVcsQ0FBQ1M7UUFDMUJLLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRVksTUFBTUUsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUU1Qyx3QkFBd0I7UUFDeEJMLFNBQVNNLE1BQU0sQ0FBQyxRQUFRTCxZQUFZO1lBQ2xDTSxVQUFVOUIsb0RBQWEsQ0FBQ1E7WUFDeEJ3QixhQUFhO1FBQ2Y7UUFFQSxnRkFBZ0Y7UUFDaEYsNENBQTRDO1FB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QUMsc0JBQXNCeUU7b0JBQ3BDLGtDQUFrQztvQkFDbEMsSUFBSTFGLG9EQUFhLENBQUM2SixlQUFlO3dCQUMvQjdKLG9EQUFhLENBQUM2SjtvQkFDaEI7Z0JBQ0Y7Z0JBRUYsT0FBT0wsSUFBSWpILE1BQU0sQ0FBQyxLQUFLa0YsSUFBSSxDQUFDO29CQUMxQnJFLFNBQVM7b0JBQ1RELFNBQVM7b0JBQ1RnSSxlQUFlaEUsV0FBV3JELE1BQU07b0JBQ2hDc0gsa0JBQWtCO2dCQUNwQjtZQUNGO1FBQ0YsRUFBRSxPQUFPbkssT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsZ0NBQWdDQTtZQUU5Qyx5REFBeUQ7WUFDekQsTUFBTTRJLGVBQWU1SixnREFBUyxDQUFDa0IsUUFBUXVJLEdBQUcsSUFBSSxVQUFVLFlBQVk7WUFDcEUsSUFBSTFKLG9EQUFhLENBQUM2SixlQUFlO2dCQUMvQixJQUFJO29CQUNGN0osb0RBQWEsQ0FBQzZKO2dCQUNoQixFQUFFLE9BQU9sSCxHQUFHO29CQUNWN0IsUUFBUUcsS0FBSyxDQUFDLDZCQUE2QjBCO2dCQUM3QztZQUNGO1lBRUEsT0FBTzZHLElBQUlqSCxNQUFNLENBQUMsS0FBS2tGLElBQUksQ0FBQztnQkFDMUJyRSxTQUFTO2dCQUNUbkMsT0FBT0EsTUFBTWtDLE9BQU87WUFDdEI7UUFDRjtJQUNGLE9BQ0s7UUFDSCxPQUFPcUcsSUFBSWpILE1BQU0sQ0FBQyxLQUFLa0YsSUFBSSxDQUFDO1lBQzFCckUsU0FBUztZQUNUbkMsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhZ2VzL2FwaS9wcm9jZXNzLXN0YXR1cy1hcGkuanMgLSBBUEkgdG8gaGFuZGxlIHByb2Nlc3Mgc3RhdHVzIGNoZWNrcyBhbmQgdHJpZ2dlcnNcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0IGZldGNoIGZyb20gJ25vZGUtZmV0Y2gnO1xuaW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5cbi8vIENvbnZlcnQgZXhlYyB0byBQcm9taXNlLWJhc2VkXG5jb25zdCBleGVjUHJvbWlzZSA9IHV0aWwucHJvbWlzaWZ5KGV4ZWMpO1xuXG4vLyBGdW5jdGlvbiB0byBzZW5kIGEgc2luZ2xlIGltYWdlIHRvIHRoZSBQeXRob24gYmFja2VuZCBmb3IgcHJvY2Vzc2luZ1xuLy8gTW9kaWZpZWQgZnVuY3Rpb24gdG8gcHJlc2VydmUgb3JpZ2luYWwgcGFyYW1ldGVyIGRhdGEgYW5kIGFkZCBuZXcgbWV0cmljc1xuLy8gRml4ZWQgZnVuY3Rpb24gdG8gcHJvcGVybHkgcHJvY2VzcyB3ZWJjYW0gaW1hZ2VzIHRocm91Z2ggdGhlIFB5dGhvbiBiYWNrZW5kXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uKGlucHV0UGF0aCwgb3V0cHV0UGF0aCwgc2V0TnVtYmVyLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyB0byBwcm9jZXNzIGltYWdlOiAke2lucHV0UGF0aH1gKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBpbnB1dCBmaWxlIGV4aXN0c1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhpbnB1dFBhdGgpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBJbnB1dCBmaWxlIGRvZXMgbm90IGV4aXN0OiAke2lucHV0UGF0aH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGJhY2tlbmQgVVJMXG4gICAgY29uc3QgYmFja2VuZFVybCA9IHByb2Nlc3MuZW52LkJBQ0tFTkRfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVic7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGZvcm0gZGF0YVxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgXG4gICAgLy8gT3BlbiB0aGUgZmlsZSBhcyBhIHN0cmVhbVxuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGlucHV0UGF0aCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSBmaWxlIHNpemVcbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGlucHV0UGF0aCk7XG4gICAgY29uc29sZS5sb2coYEZpbGUgc2l6ZTogJHtzdGF0cy5zaXplfSBieXRlc2ApO1xuICAgIFxuICAgIC8vIEFkZCBmaWxlIHRvIGZvcm0gZGF0YVxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGVTdHJlYW0sIHtcbiAgICAgIGZpbGVuYW1lOiBwYXRoLmJhc2VuYW1lKGlucHV0UGF0aCksXG4gICAgICBjb250ZW50VHlwZTogJ2ltYWdlL2pwZWcnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWRkIHByb2Nlc3NpbmcgcGFyYW1ldGVycyAtIHRoZXNlIG11c3QgbWF0Y2ggdGhlIEZhc3RBUEkgYmFja2VuZCBleHBlY3RhdGlvbnNcbiAgICAvLyBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dIZWFkUG9zZScsICdmYWxzZScpO1xuICAgIC8vIGZvcm1EYXRhLmFwcGVuZCgnc2hvd0JvdW5kaW5nQm94JywgJ3RydWUnKTtcbiAgICAvLyBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dNYXNrJywgJ2ZhbHNlJyk7XG4gICAgLy8gZm9ybURhdGEuYXBwZW5kKCdzaG93UGFyYW1ldGVycycsICd0cnVlJyk7XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dIZWFkUG9zZScsICdmYWxzZScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd0JvdW5kaW5nQm94JywgJ2ZhbHNlJyk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdzaG93TWFzaycsICdmYWxzZScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd1BhcmFtZXRlcnMnLCAnZmFsc2UnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgU2VuZGluZyAke2lucHV0UGF0aH0gdG8gUHl0aG9uIGJhY2tlbmQgYXQgJHtiYWNrZW5kVXJsfS9wcm9jZXNzLWltYWdlYCk7XG4gICAgXG4gICAgLy8gTG9nIHJlcXVlc3QgZGV0YWlscyBmb3IgZGVidWdnaW5nXG4gICAgY29uc29sZS5sb2coJ0FQSSBLZXkgYmVpbmcgdXNlZDonLCBhcGlLZXkpO1xuICAgIGNvbnNvbGUubG9nKCdGb3JtIGRhdGEgcGFyYW1ldGVyczonLCBcbiAgICAgICAgICAgICAgICdzaG93SGVhZFBvc2U9dHJ1ZScsIFxuICAgICAgICAgICAgICAgJ3Nob3dCb3VuZGluZ0JveD10cnVlJywgXG4gICAgICAgICAgICAgICAnc2hvd01hc2s9ZmFsc2UnLCBcbiAgICAgICAgICAgICAgICdzaG93UGFyYW1ldGVycz10cnVlJyk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgUHl0aG9uIGJhY2tlbmRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2JhY2tlbmRVcmx9L3Byb2Nlc3MtaW1hZ2VgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtQVBJLUtleSc6IGFwaUtleVxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgdGltZW91dDogMzAwMDAgLy8gMzAgc2Vjb25kIHRpbWVvdXQgZm9yIHByb2Nlc3NpbmcgbGFyZ2UgaW1hZ2VzXG4gICAgfSk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSByZXNwb25zZSBzdGF0dXNcbiAgICBjb25zb2xlLmxvZyhgQmFja2VuZCByZXNwb25zZSBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvclRleHQgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JUZXh0ID0gJ0NvdWxkIG5vdCByZWFkIGVycm9yIGRldGFpbHMnO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmVycm9yKGBCYWNrZW5kIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgY29uc29sZS5lcnJvcihgUmVzcG9uc2UgYm9keTogJHtlcnJvclRleHR9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmQgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSBhcyBKU09OXG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5sb2coYFJlc3BvbnNlIHRleHQgKGZpcnN0IDIwMCBjaGFycyk6ICR7cmVzcG9uc2VUZXh0LnN1YnN0cmluZygwLCAyMDApfS4uLmApO1xuICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHJlc3BvbnNlIEpTT046JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYmFja2VuZCByZXNwb25zZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBMb2cgcmVzdWx0IHN0YXR1c1xuICAgIGNvbnNvbGUubG9nKCdCYWNrZW5kIHByb2Nlc3NpbmcgcmVzdWx0OicsIHJlc3VsdC5zdWNjZXNzID8gJ1N1Y2Nlc3MnIDogJ0ZhaWxlZCcpO1xuICAgIFxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgLy8gQ2hlY2sgaWYgYSBmYWNlIHdhcyBkZXRlY3RlZFxuICAgICAgaWYgKHJlc3VsdC5mYWNlX2RldGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gZmFjZSBkZXRlY3RlZCBpbiB0aGUgaW1hZ2UgLSBzYXZpbmcgb3JpZ2luYWwgaW1hZ2UnKTtcbiAgICAgICAgZnMuY29weUZpbGVTeW5jKGlucHV0UGF0aCwgb3V0cHV0UGF0aCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGlsbCB1cGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCB0aGlzIGluZm9ybWF0aW9uXG4gICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCB7IGZhY2VfZGV0ZWN0ZWQ6IGZhbHNlIH0sIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgd2UgaGF2ZSB0aGUgcHJvY2Vzc2VkIGltYWdlIGRhdGFcbiAgICAgIGlmICghcmVzdWx0LmltYWdlIHx8ICFyZXN1bHQuaW1hZ2UuZGF0YSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdCYWNrZW5kIHJlc3BvbnNlIG1pc3NpbmcgaW1hZ2UgZGF0YScpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgIGZzLmNvcHlGaWxlU3luYyhpbnB1dFBhdGgsIG91dHB1dFBhdGgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIGltYWdlIGFzIGZhbGxiYWNrIHRvOiAke291dHB1dFBhdGh9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBtaW5pbWFsIGluZm9cbiAgICAgICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIHsgZmFjZV9kZXRlY3RlZDogZmFsc2UgfSwgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdGhlIHByb2Nlc3NlZCBpbWFnZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW1hZ2VCdWZmZXIgPSBCdWZmZXIuZnJvbShyZXN1bHQuaW1hZ2UuZGF0YSwgJ2Jhc2U2NCcpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGltYWdlQnVmZmVyKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHByb2Nlc3NlZCBpbWFnZSB0byAke291dHB1dFBhdGh9LCBzaXplOiAke2ltYWdlQnVmZmVyLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyBwcm9jZXNzZWQgaW1hZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgICBmcy5jb3B5RmlsZVN5bmMoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICAgICAgY29uc29sZS5sb2coYENvcGllZCBvcmlnaW5hbCBpbWFnZSBhcyBmYWxsYmFjayB0bzogJHtvdXRwdXRQYXRofWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbWV0cmljcyBpbiB0aGUgcmVzcG9uc2VcbiAgICAgIGlmIChyZXN1bHQubWV0cmljcykge1xuICAgICAgICBjb25zb2xlLmxvZygnTWV0cmljcyByZWNlaXZlZCBmcm9tIGJhY2tlbmQ6JywgSlNPTi5zdHJpbmdpZnkocmVzdWx0Lm1ldHJpY3MpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwYXJhbWV0ZXIgZmlsZSB3aXRoIHRoZSBtZXRyaWNzXG4gICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCByZXN1bHQubWV0cmljcywgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXRyaWNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIG1ldHJpY3MgcmVjZWl2ZWQgZnJvbSBiYWNrZW5kLCB1c2luZyBmYWNlX2RldGVjdGVkIHN0YXR1cyBvbmx5Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBqdXN0IHRoZSBmYWNlIGRldGVjdGlvbiBzdGF0dXNcbiAgICAgICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIHsgZmFjZV9kZXRlY3RlZDogdHJ1ZSB9LCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBmYWNlX2RldGVjdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEJhY2tlbmQgcHJvY2Vzc2luZyBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICBmcy5jb3B5RmlsZVN5bmMoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDb3BpZWQgb3JpZ2luYWwgaW1hZ2UgYXMgZmFsbGJhY2sgdG86ICR7b3V0cHV0UGF0aH1gKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHBhcmFtZXRlciBmaWxlIHdpdGggZXJyb3IgaW5mb3JtYXRpb25cbiAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBudWxsLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGltYWdlIHdpdGggUHl0aG9uIGJhY2tlbmQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcbiAgICBcbiAgICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICB0cnkge1xuICAgICAgZnMuY29weUZpbGVTeW5jKGlucHV0UGF0aCwgb3V0cHV0UGF0aCk7XG4gICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIGltYWdlIGFzIGZhbGxiYWNrIGFmdGVyIGVycm9yOiAke291dHB1dFBhdGh9YCk7XG4gICAgfSBjYXRjaCAoY29weUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjb3B5aW5nIG9yaWdpbmFsIGltYWdlOiAke2NvcHlFcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBlcnJvciBpbmZvcm1hdGlvblxuICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBudWxsLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gTmV3IGZ1bmN0aW9uIHRvIHVwZGF0ZSBwYXJhbWV0ZXIgZmlsZSB3aXRoIG5ldyBtZXRyaWNzIHdoaWxlIHByZXNlcnZpbmcgb3JpZ2luYWwgZGF0YVxuLy8gVXBkYXRlZCBmdW5jdGlvbiB0byBwcm9wZXJseSBoYW5kbGUgcGFyYW1ldGVyIGZpbGUgdXBkYXRlc1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIG1ldHJpY3MsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKSB7XG4gIGNvbnNvbGUubG9nKGBVcGRhdGluZyBwYXJhbWV0ZXIgZmlsZSBmb3Igc2V0ICR7c2V0TnVtYmVyfSB3aXRoIG5ldyBtZXRyaWNzYCk7XG4gIFxuICAvLyBEZXRlcm1pbmUgcGFyYW1ldGVyIGZpbGUgcGF0aHNcbiAgY29uc3Qgb3JpZ2luYWxQYXJhbVBhdGhzID0gW1xuICAgIHBhdGguam9pbihjYXB0dXJlRGlyLCBgcGFyYW1ldGVyc18ke3NldE51bWJlcn0uY3N2YCksXG4gICAgcGF0aC5qb2luKGNhcHR1cmVEaXIsIGBwYXJhbWV0ZXJfJHtzZXROdW1iZXJ9LmNzdmApXG4gIF07XG4gIFxuICAvLyBPdXRwdXQgcGFyYW1ldGVyIGZpbGUgcGF0aFxuICBjb25zdCBwYXJhbURlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgcGFyYW1ldGVyX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmNzdmApO1xuICBcbiAgLy8gTG9hZCBvcmlnaW5hbCBwYXJhbWV0ZXIgZGF0YSBpZiBhdmFpbGFibGVcbiAgbGV0IG9yaWdpbmFsUGFyYW1zID0gbmV3IE1hcCgpO1xuICBsZXQgb3JpZ2luYWxQYXJhbUZvdW5kID0gZmFsc2U7XG4gIGxldCBvcmlnaW5hbEZpcnN0TGluZUlzSGVhZGVyID0gZmFsc2U7XG4gIFxuICBmb3IgKGNvbnN0IG9yaWdpbmFsUGF0aCBvZiBvcmlnaW5hbFBhcmFtUGF0aHMpIHtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhvcmlnaW5hbFBhdGgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgb3JpZ2luYWwgcGFyYW1ldGVyIGZpbGU6ICR7b3JpZ2luYWxQYXRofWApO1xuICAgICAgb3JpZ2luYWxQYXJhbUZvdW5kID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhvcmlnaW5hbFBhdGgsICd1dGY4Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBPcmlnaW5hbCBwYXJhbWV0ZXIgZmlsZSBjb250ZW50OiAke2NvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCl9Li4uYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGxpbmUgaXMgYSBoZWFkZXJcbiAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gbGluZXNbMF0udHJpbSgpO1xuICAgICAgICBvcmlnaW5hbEZpcnN0TGluZUlzSGVhZGVyID0gZmlyc3RMaW5lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3BhcmFtZXRlcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbmFtZScpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBoZWFkZXIgbGluZSBpZiBpdCBleGlzdHNcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gb3JpZ2luYWxGaXJzdExpbmVJc0hlYWRlciA/IDEgOiAwO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgdGhlIG9yaWdpbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBwYXJhbVZhbHVlID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICBvcmlnaW5hbFBhcmFtcy5zZXQocGFyYW1OYW1lLCBwYXJhbVZhbHVlKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYExvYWRlZCBwYXJhbWV0ZXI6ICR7cGFyYW1OYW1lfT0ke3BhcmFtVmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7b3JpZ2luYWxQYXJhbXMuc2l6ZX0gcGFyYW1ldGVycyBmcm9tIG9yaWdpbmFsIGZpbGVgKTtcbiAgICAgICAgYnJlYWs7IC8vIEZvdW5kIGFuZCBsb2FkZWQgb25lIHBhcmFtZXRlciBmaWxlLCBubyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgb3JpZ2luYWwgcGFyYW1ldGVyIGZpbGU6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBQcmVwYXJlIENTViBjb250ZW50IHdpdGggaGVhZGVyXG4gIGxldCBjc3ZDb250ZW50ID0gJ1BhcmFtZXRlcixWYWx1ZVxcbic7XG4gIFxuICAvLyBBZGQgb3JpZ2luYWwgcGFyYW1ldGVycyBmaXJzdCAoZXhjZXB0IHRob3NlIHdlJ2xsIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMpXG4gIGNvbnN0IGV4Y2x1ZGVQYXJhbXMgPSBbJ3BpdGNoJywgJ3lhdycsICdyb2xsJywgJ2ZhY2Vfd2lkdGgnLCAnZmFjZV9oZWlnaHQnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAnbGVmdF9leWVfeCcsICdsZWZ0X2V5ZV95JywgJ3JpZ2h0X2V5ZV94JywgJ3JpZ2h0X2V5ZV95JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnZmFjZV9ib3hfbWluX3gnLCAnZmFjZV9ib3hfbWluX3knLCAnZmFjZV9ib3hfbWF4X3gnLCAnZmFjZV9ib3hfbWF4X3knXTtcbiAgXG4gIC8vIExvZyBhbGwgb3JpZ2luYWwgcGFyYW1ldGVycyBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUubG9nKFwiT3JpZ2luYWwgcGFyYW1ldGVyczpcIik7XG4gIG9yaWdpbmFsUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgICAke2tleX06ICR7dmFsdWV9YCk7XG4gIH0pO1xuICBcbiAgLy8gQWRkIGV4aXN0aW5nIHBhcmFtZXRlcnMgKGV4Y2VwdCB0aG9zZSB3ZSdsbCB1cGRhdGUpXG4gIG9yaWdpbmFsUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoIWV4Y2x1ZGVQYXJhbXMuaW5jbHVkZXMoa2V5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICBjc3ZDb250ZW50ICs9IGAke2tleX0sJHt2YWx1ZX1cXG5gO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBOb3cgYWRkIHRoZSBuZXcgbWV0cmljc1xuICBpZiAobWV0cmljcyAmJiBtZXRyaWNzLmZhY2VfZGV0ZWN0ZWQgIT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2coXCJBZGRpbmcgbmV3IG1ldHJpY3MgZnJvbSBmYWNlIGRldGVjdGlvblwiKTtcbiAgICBcbiAgICAvLyBBZGQgaGVhZCBwb3NlIGRhdGFcbiAgICBpZiAobWV0cmljcy5oZWFkX3Bvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgaGVhZCBwb3NlOiBwaXRjaD0ke21ldHJpY3MuaGVhZF9wb3NlLnBpdGNofSwgeWF3PSR7bWV0cmljcy5oZWFkX3Bvc2UueWF3fSwgcm9sbD0ke21ldHJpY3MuaGVhZF9wb3NlLnJvbGx9YCk7XG4gICAgICBjc3ZDb250ZW50ICs9IGBwaXRjaCwke21ldHJpY3MuaGVhZF9wb3NlLnBpdGNofVxcbmA7XG4gICAgICBjc3ZDb250ZW50ICs9IGB5YXcsJHttZXRyaWNzLmhlYWRfcG9zZS55YXd9XFxuYDtcbiAgICAgIGNzdkNvbnRlbnQgKz0gYHJvbGwsJHttZXRyaWNzLmhlYWRfcG9zZS5yb2xsfVxcbmA7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBleWUgY2VudGVycyBpZiBhdmFpbGFibGVcbiAgICBpZiAobWV0cmljcy5leWVfY2VudGVycykge1xuICAgICAgaWYgKG1ldHJpY3MuZXllX2NlbnRlcnMubGVmdCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGxlZnQgZXllOiAke21ldHJpY3MuZXllX2NlbnRlcnMubGVmdC5qb2luKCcsJyl9YCk7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGxlZnRfZXllX3gsJHttZXRyaWNzLmV5ZV9jZW50ZXJzLmxlZnRbMF19XFxuYDtcbiAgICAgICAgY3N2Q29udGVudCArPSBgbGVmdF9leWVfeSwke21ldHJpY3MuZXllX2NlbnRlcnMubGVmdFsxXX1cXG5gO1xuICAgICAgfVxuICAgICAgaWYgKG1ldHJpY3MuZXllX2NlbnRlcnMucmlnaHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyByaWdodCBleWU6ICR7bWV0cmljcy5leWVfY2VudGVycy5yaWdodC5qb2luKCcsJyl9YCk7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYHJpZ2h0X2V5ZV94LCR7bWV0cmljcy5leWVfY2VudGVycy5yaWdodFswXX1cXG5gO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGByaWdodF9leWVfeSwke21ldHJpY3MuZXllX2NlbnRlcnMucmlnaHRbMV19XFxuYDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGZhY2UgYm94IGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGlmIChtZXRyaWNzLmZhY2VfYm94KSB7XG4gICAgICBpZiAobWV0cmljcy5mYWNlX2JveC5taW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBmYWNlIGJveCBtaW46ICR7bWV0cmljcy5mYWNlX2JveC5taW4uam9pbignLCcpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGBmYWNlX2JveF9taW5feCwke21ldHJpY3MuZmFjZV9ib3gubWluWzBdfVxcbmA7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGZhY2VfYm94X21pbl95LCR7bWV0cmljcy5mYWNlX2JveC5taW5bMV19XFxuYDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRyaWNzLmZhY2VfYm94Lm1heCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGZhY2UgYm94IG1heDogJHttZXRyaWNzLmZhY2VfYm94Lm1heC5qb2luKCcsJyl9YCk7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGZhY2VfYm94X21heF94LCR7bWV0cmljcy5mYWNlX2JveC5tYXhbMF19XFxuYDtcbiAgICAgICAgY3N2Q29udGVudCArPSBgZmFjZV9ib3hfbWF4X3ksJHttZXRyaWNzLmZhY2VfYm94Lm1heFsxXX1cXG5gO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBhZGQgZmFjZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGlmIChtZXRyaWNzLmZhY2VfYm94Lm1pbikge1xuICAgICAgICAgIGNvbnN0IGZhY2VXaWR0aCA9IE1hdGgucm91bmQobWV0cmljcy5mYWNlX2JveC5tYXhbMF0gLSBtZXRyaWNzLmZhY2VfYm94Lm1pblswXSk7XG4gICAgICAgICAgY29uc3QgZmFjZUhlaWdodCA9IE1hdGgucm91bmQobWV0cmljcy5mYWNlX2JveC5tYXhbMV0gLSBtZXRyaWNzLmZhY2VfYm94Lm1pblsxXSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBmYWNlIGRpbWVuc2lvbnM6IHdpZHRoPSR7ZmFjZVdpZHRofSwgaGVpZ2h0PSR7ZmFjZUhlaWdodH1gKTtcbiAgICAgICAgICBjc3ZDb250ZW50ICs9IGBmYWNlX3dpZHRoLCR7ZmFjZVdpZHRofVxcbmA7XG4gICAgICAgICAgY3N2Q29udGVudCArPSBgZmFjZV9oZWlnaHQsJHtmYWNlSGVpZ2h0fVxcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZ2luYWxQYXJhbUZvdW5kKSB7XG4gICAgLy8gSWYgbm8gbmV3IG1ldHJpY3MgYnV0IHdlIGhhZCBvcmlnaW5hbCBkYXRhIGZvciB0aGVzZSBmaWVsZHMsIHByZXNlcnZlIHRoZW1cbiAgICBjb25zb2xlLmxvZyhcIk5vIG5ldyBtZXRyaWNzLCBwcmVzZXJ2aW5nIG9yaWdpbmFsIGZhY2UgdHJhY2tpbmcgZGF0YSBpZiBhdmFpbGFibGVcIik7XG4gICAgXG4gICAgY29uc3QgZmllbGRzVG9QcmVzZXJ2ZSA9IFsncGl0Y2gnLCAneWF3JywgJ3JvbGwnLCAnZmFjZV93aWR0aCcsICdmYWNlX2hlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0X2V5ZV94JywgJ2xlZnRfZXllX3knLCAncmlnaHRfZXllX3gnLCAncmlnaHRfZXllX3knLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFjZV9ib3hfbWluX3gnLCAnZmFjZV9ib3hfbWluX3knLCAnZmFjZV9ib3hfbWF4X3gnLCAnZmFjZV9ib3hfbWF4X3knXTtcbiAgICBcbiAgICBmaWVsZHNUb1ByZXNlcnZlLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsUGFyYW1zLmhhcyhmaWVsZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFByZXNlcnZpbmcgb3JpZ2luYWwgJHtmaWVsZH09JHtvcmlnaW5hbFBhcmFtcy5nZXQoZmllbGQpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGAke2ZpZWxkfSwke29yaWdpbmFsUGFyYW1zLmdldChmaWVsZCl9XFxuYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBtZXRyaWNzIGFuZCBubyBvcmlnaW5hbCBkYXRhLCBhZGQgcGxhY2Vob2xkZXIgaW5mb3JtYXRpb25cbiAgICBjb25zb2xlLmxvZyhcIk5vIG1ldHJpY3MgYW5kIG5vIG9yaWdpbmFsIGRhdGEsIGFkZGluZyBwbGFjZWhvbGRlclwiKTtcbiAgICBjc3ZDb250ZW50ICs9ICdpbmZvLE5vIGZhY2UgZGV0ZWN0ZWQgb3IgcHJvY2Vzc2luZyBmYWlsZWRcXG4nO1xuICB9XG4gIFxuICAvLyBMb2cgdGhlIGZpbmFsIENTViBjb250ZW50IGZvciBkZWJ1Z2dpbmdcbiAgY29uc29sZS5sb2coYEZpbmFsIHBhcmFtZXRlciBmaWxlIGNvbnRlbnQ6XFxuJHtjc3ZDb250ZW50fWApO1xuICBcbiAgLy8gV3JpdGUgdGhlIHVwZGF0ZWQgQ1NWIGZpbGVcbiAgZnMud3JpdGVGaWxlU3luYyhwYXJhbURlc3RQYXRoLCBjc3ZDb250ZW50KTtcbiAgY29uc29sZS5sb2coYFdyb3RlIHVwZGF0ZWQgcGFyYW1ldGVyIGZpbGUgdG86ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgXG4gIC8vIFZlcmlmeSB0aGUgZmlsZSB3YXMgd3JpdHRlblxuICBpZiAoZnMuZXhpc3RzU3luYyhwYXJhbURlc3RQYXRoKSkge1xuICAgIGNvbnNvbGUubG9nKGBQYXJhbWV0ZXIgZmlsZSBzdWNjZXNzZnVsbHkgdXBkYXRlZDogJHtwYXJhbURlc3RQYXRofWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcGFyYW1ldGVyIGZpbGU6ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gcHJvY2VzcyBmaWxlcyB2aWEgdGhlIEZhc3RBUEkgYmFja2VuZFxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzVmlhQmFja2VuZChzZXROdW1iZXJzKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBiYWNrZW5kIFVSTCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHVzZSBkZWZhdWx0XG4gICAgY29uc3QgYmFja2VuZFVybCA9IHByb2Nlc3MuZW52LkJBQ0tFTkRfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVic7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgRmFzdEFQSSBiYWNrZW5kIHRvIHByb2Nlc3MgdGhlIGZpbGVzXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYWNrZW5kVXJsfS9wcm9jZXNzLWJhdGNoYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdYLUFQSS1LZXknOiBhcGlLZXlcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICBzZXRfbnVtYmVyczogc2V0TnVtYmVycyxcbiAgICAgICAgc2hvd19oZWFkX3Bvc2U6IHRydWUsXG4gICAgICAgIHNob3dfYm91bmRpbmdfYm94OiB0cnVlLFxuICAgICAgICBzaG93X21hc2s6IGZhbHNlLFxuICAgICAgICBzaG93X3BhcmFtZXRlcnM6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5lcnJvcignQmFja2VuZCBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yVGV4dCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBCYWNrZW5kIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsbGluZyBiYWNrZW5kIGZvciBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBwcm9jZXNzIGZpbGVzIGRpcmVjdGx5IGluIE5vZGUuanNcbi8vIEZ1bmN0aW9uIHRvIHByb2Nlc3MgZmlsZXMgZGlyZWN0bHkgaW4gTm9kZS5qc1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzRGlyZWN0bHkoc2V0TnVtYmVycywgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgsIHByb2dyZXNzRmlsZVBhdGgpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIj09PSBTVEFSVElORyBESVJFQ1QgUFJPQ0VTU0lORyA9PT1cIik7XG4gICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc2V0czogJHtzZXROdW1iZXJzLmpvaW4oJywgJyl9YCk7XG4gICAgY29uc29sZS5sb2coYENhcHR1cmUgZGlyZWN0b3J5OiAke2NhcHR1cmVEaXJ9YCk7XG4gICAgY29uc29sZS5sb2coYEVuaGFuY2UgZGlyZWN0b3J5OiAke2VuaGFuY2VQYXRofWApO1xuICAgIFxuICAgIC8vIEdldCBjdXJyZW50IHByb2dyZXNzIG9yIGluaXRpYWxpemVcbiAgICBsZXQgcHJvZ3Jlc3MgPSB7XG4gICAgICBjdXJyZW50U2V0OiAwLFxuICAgICAgdG90YWxTZXRzOiBzZXROdW1iZXJzLmxlbmd0aCxcbiAgICAgIHByb2Nlc3NlZFNldHM6IFtdLFxuICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBsYXN0VXBkYXRlVGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIGVhY2ggc2V0XG4gICAgZm9yIChjb25zdCBzZXROdW1iZXIgb2Ygc2V0TnVtYmVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFxcbi0tLSBQcm9jZXNzaW5nIHNldCAke3NldE51bWJlcn0gLS0tYCk7XG4gICAgICAgIHByb2dyZXNzLmN1cnJlbnRTZXQgPSBzZXROdW1iZXI7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3MsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgcHJvZ3Jlc3MgZmlsZSBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyB3ZWJjYW0gaW1hZ2VcbiAgICAgICAgY29uc3Qgd2ViY2FtU3JjUGF0aCA9IHBhdGguam9pbihjYXB0dXJlRGlyLCBgd2ViY2FtXyR7c2V0TnVtYmVyfS5qcGdgKTtcbiAgICAgICAgY29uc3Qgd2ViY2FtRGVzdFBhdGggPSBwYXRoLmpvaW4oZW5oYW5jZVBhdGgsIGB3ZWJjYW1fZW5oYW5jZV8ke3NldE51bWJlcn0uanBnYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgTG9va2luZyBmb3Igd2ViY2FtIGltYWdlIGF0OiAke3dlYmNhbVNyY1BhdGh9YCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyh3ZWJjYW1TcmNQYXRoKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCB3ZWJjYW0gaW1hZ2U6ICR7d2ViY2FtU3JjUGF0aH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgaW1hZ2UgdGhyb3VnaCB0aGUgUHl0aG9uIGJhY2tlbmRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTZW5kaW5nIHdlYmNhbSBpbWFnZSBmb3Igc2V0ICR7c2V0TnVtYmVyfSB0byBwcm9jZXNzX2ltYWdlX2hhbmRsZXJgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UncmUgcGFzc2luZyB0aGUgY2FwdHVyZSBkaXJlY3RvcnkgYW5kIGVuaGFuY2UgcGF0aCB0byBoZWxwIHdpdGggcGFyYW1ldGVyIGZpbGUgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uKHdlYmNhbVNyY1BhdGgsIHdlYmNhbURlc3RQYXRoLCBzZXROdW1iZXIsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG1ldHJpY3MpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIHdlYmNhbSBpbWFnZSBhbmQgZXh0cmFjdGVkIG1ldHJpY3MgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFByb2Nlc3MgY29tcGxldGVkIGJ1dCBubyBtZXRyaWNzIHJldHVybmVkIGZvciBzZXQgJHtzZXROdW1iZXJ9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGltYWdlIGlzIGNvcGllZCBldmVuIGlmIG5vIG1ldHJpY3Mgd2VyZSByZXR1cm5lZFxuICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMod2ViY2FtRGVzdFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZnMuY29weUZpbGVTeW5jKHdlYmNhbVNyY1BhdGgsIHdlYmNhbURlc3RQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIHdlYmNhbSBpbWFnZSBhcyBmYWxsYmFjayBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcHJvY2Vzc2luZyB3ZWJjYW0gaW1hZ2UgZm9yIHNldCAke3NldE51bWJlcn06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGZpbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb3B5aW5nIG9yaWdpbmFsIHdlYmNhbSBpbWFnZSBhcyBmYWxsYmFjayBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICAgICAgZnMuY29weUZpbGVTeW5jKHdlYmNhbVNyY1BhdGgsIHdlYmNhbURlc3RQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gV2ViY2FtIGltYWdlIG5vdCBmb3VuZCBmb3Igc2V0ICR7c2V0TnVtYmVyfTogJHt3ZWJjYW1TcmNQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIHNjcmVlbiBpbWFnZSBpZiBpdCBleGlzdHNcbiAgICAgICAgY29uc3Qgc2NyZWVuU3JjUGF0aCA9IHBhdGguam9pbihjYXB0dXJlRGlyLCBgc2NyZWVuXyR7c2V0TnVtYmVyfS5qcGdgKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuRGVzdFBhdGggPSBwYXRoLmpvaW4oZW5oYW5jZVBhdGgsIGBzY3JlZW5fZW5oYW5jZV8ke3NldE51bWJlcn0uanBnYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgTG9va2luZyBmb3Igc2NyZWVuIGltYWdlIGF0OiAke3NjcmVlblNyY1BhdGh9YCk7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHNjcmVlblNyY1BhdGgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNjcmVlbiBpbWFnZSBmb3VuZDogJHtzY3JlZW5TcmNQYXRofWApO1xuICAgICAgICAgIGZzLmNvcHlGaWxlU3luYyhzY3JlZW5TcmNQYXRoLCBzY3JlZW5EZXN0UGF0aCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYENvcGllZCBzY3JlZW4gaW1hZ2UgdG86ICR7c2NyZWVuRGVzdFBhdGh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gU2NyZWVuIGltYWdlIG5vdCBmb3VuZCBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIGEgcGFyYW1ldGVyIGZpbGUgZm9yIHRoaXMgc2V0IGluIHRoZSBlbmhhbmNlIGRpcmVjdG9yeVxuICAgICAgICBjb25zdCBlbmhhbmNlUGFyYW1QYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgcGFyYW1ldGVyX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmNzdmApO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhcmFtUGF0aCkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW1ldGVyIGZpbGUgbm90IGNyZWF0ZWQgZHVyaW5nIHByb2Nlc3NpbmcgZm9yIHNldCAke3NldE51bWJlcn0sIGNoZWNraW5nIGZvciBvcmlnaW5hbC4uLmApO1xuICAgICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBudWxsLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICAgICAgICBwcm9ncmVzcy5wcm9jZXNzZWRTZXRzLnB1c2goc2V0TnVtYmVyKTtcbiAgICAgICAgcHJvZ3Jlc3MubGFzdFVwZGF0ZVRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3MsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgcHJvZ3Jlc3MgLSBzZXQgJHtzZXROdW1iZXJ9IGNvbXBsZXRlZGApO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHN5c3RlbVxuICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyA1MDBtcyBiZWZvcmUgcHJvY2Vzc2luZyBuZXh0IHNldC4uLmApO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHByb2Nlc3Npbmcgc2V0ICR7c2V0TnVtYmVyfTpgLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIlxcbj09PSBQUk9DRVNTSU5HIENPTVBMRVRFRCA9PT1cIik7XG4gICAgY29uc29sZS5sb2coYFRvdGFsIHNldHMgcHJvY2Vzc2VkOiAke3Byb2dyZXNzLnByb2Nlc3NlZFNldHMubGVuZ3RofS8ke3Byb2dyZXNzLnRvdGFsU2V0c31gKTtcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIGRpcmVjdCBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29weSBwYXJhbWV0ZXIgZmlsZXNcbmFzeW5jIGZ1bmN0aW9uIGNvcHlQYXJhbWV0ZXJGaWxlKGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoLCBzZXROdW1iZXIpIHtcbiAgLy8gVHJ5IGJvdGggcGFyYW1ldGVyIGFuZCBwYXJhbWV0ZXJzIG5hbWluZ1xuICBjb25zdCBwYXJhbUZpbGVOYW1lcyA9IFtcbiAgICBgcGFyYW1ldGVyc18ke3NldE51bWJlcn0uY3N2YCxcbiAgICBgcGFyYW1ldGVyXyR7c2V0TnVtYmVyfS5jc3ZgXG4gIF07XG4gIFxuICBsZXQgcGFyYW1Gb3VuZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHBhcmFtRmlsZU5hbWUgb2YgcGFyYW1GaWxlTmFtZXMpIHtcbiAgICBjb25zdCBwYXJhbVNyY1BhdGggPSBwYXRoLmpvaW4oY2FwdHVyZURpciwgcGFyYW1GaWxlTmFtZSk7XG4gICAgY29uc29sZS5sb2coYExvb2tpbmcgZm9yIHBhcmFtZXRlciBmaWxlIGF0OiAke3BhcmFtU3JjUGF0aH1gKTtcbiAgICBcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXJhbVNyY1BhdGgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUGFyYW1ldGVyIGZpbGUgZm91bmQ6ICR7cGFyYW1TcmNQYXRofWApO1xuICAgICAgcGFyYW1Gb3VuZCA9IHRydWU7XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBkZXN0aW5hdGlvbiBuYW1lIChjaGFuZ2UgcGFyYW1ldGVyIHRvIHBhcmFtZXRlcl9lbmhhbmNlKVxuICAgICAgY29uc3QgZGVzdEZpbGVOYW1lID0gJ3BhcmFtZXRlcl9lbmhhbmNlXycgKyBzZXROdW1iZXIgKyAnLmNzdic7XG4gICAgICBjb25zdCBwYXJhbURlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBkZXN0RmlsZU5hbWUpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQ29weWluZyBwYXJhbWV0ZXIgZmlsZSB0bzogJHtwYXJhbURlc3RQYXRofWApO1xuICAgICAgZnMuY29weUZpbGVTeW5jKHBhcmFtU3JjUGF0aCwgcGFyYW1EZXN0UGF0aCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwYXJhbWV0ZXIgZmlsZSBjb3B5XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXJhbURlc3RQYXRoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFBhcmFtZXRlciBmaWxlIGNvcGllZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlYWQgY29udGVudCB0byB2ZXJpZnlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRGVzdFBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gY29udGVudC5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgY29uc29sZS5sb2coYFBhcmFtZXRlciBmaWxlIGNvbnRlbnQgc3RhcnRzIHdpdGg6ICR7Zmlyc3RMaW5lfWApO1xuICAgICAgICB9IGNhdGNoIChyZWFkRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBwYXJhbWV0ZXIgZmlsZTogJHtyZWFkRXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvcjogUGFyYW1ldGVyIGRlc3RpbmF0aW9uIGZpbGUgZG9lc24ndCBleGlzdCBhZnRlciBjb3B5IWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBicmVhazsgLy8gRm91bmQgYW5kIGNvcGllZCBvbmUgcGFyYW1ldGVyIGZpbGUsIG5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyXG4gICAgfVxuICB9XG4gIFxuICBpZiAoIXBhcmFtRm91bmQpIHtcbiAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5vIHBhcmFtZXRlciBmaWxlcyBmb3VuZCBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBwYXJhbWV0ZXIgZmlsZSBpZiBub25lIGV4aXN0c1xuICAgIGNvbnN0IHBhcmFtRGVzdFBhdGggPSBwYXRoLmpvaW4oZW5oYW5jZVBhdGgsIGBwYXJhbWV0ZXJfZW5oYW5jZV8ke3NldE51bWJlcn0uY3N2YCk7XG4gICAgY29uc3QgZW1wdHlDb250ZW50ID0gJ1BhcmFtZXRlcixWYWx1ZVxcbmluZm8sTm8gZmFjZSBkZXRlY3RlZCBvciBwcm9jZXNzaW5nIGZhaWxlZFxcbic7XG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXJhbURlc3RQYXRoLCBlbXB0eUNvbnRlbnQpO1xuICAgIGNvbnNvbGUubG9nKGDimqDvuI8gQ3JlYXRlZCBlbXB0eSBwYXJhbWV0ZXIgZmlsZTogJHtwYXJhbURlc3RQYXRofWApO1xuICB9XG59XG5cbi8vIE1haW4gaGFuZGxlciBmb3IgQVBJIHJlcXVlc3RzXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzKSB7XG4gIC8vIEhhbmRsZSBHRVQgcmVxdWVzdCB0byBjaGVjayBwcm9jZXNzaW5nIHN0YXR1c1xuICBpZiAocmVxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FwdHVyZXNQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyk7XG4gICAgICBjb25zdCBlbmhhbmNlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ2VuaGFuY2UnKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNhcHR1cmVzIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnKSkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJyksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgY2FwdHVyZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGNhcHR1cmVzUGF0aCkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKGNhcHR1cmVzUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBlbmhhbmNlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhdGgpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhlbmhhbmNlUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBwcm9jZXNzaW5nLmxvY2sgZmlsZSAoaW5kaWNhdGluZyBwcm9jZXNzaW5nIGlzIGluIHByb2dyZXNzKVxuICAgICAgY29uc3QgbG9ja0ZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAncHJvY2Vzc2luZy5sb2NrJyk7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmcgPSBmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBwcm9ncmVzcyBpbmZvcm1hdGlvbiBmaWxlXG4gICAgICBjb25zdCBwcm9ncmVzc0ZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAncHJvY2Vzc2luZ19wcm9ncmVzcy5qc29uJyk7XG4gICAgICBsZXQgcHJvZ3Jlc3NJbmZvID0geyBcbiAgICAgICAgY3VycmVudFNldDogMCxcbiAgICAgICAgdG90YWxTZXRzOiAwLFxuICAgICAgICBwcm9jZXNzZWRTZXRzOiBbXSxcbiAgICAgICAgc3RhcnRUaW1lOiBudWxsLFxuICAgICAgICBsYXN0VXBkYXRlVGltZTogbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocHJvZ3Jlc3NGaWxlUGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzc0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICBwcm9ncmVzc0luZm8gPSBKU09OLnBhcnNlKHByb2dyZXNzRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIHByb2dyZXNzIGZpbGU6XCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ291bnQgZmlsZXMgaW4gZWFjaCBkaXJlY3RvcnlcbiAgICAgIGNvbnN0IGNhcHR1cmVGaWxlcyA9IGZzLmV4aXN0c1N5bmMoY2FwdHVyZXNQYXRoKSBcbiAgICAgICAgPyBmcy5yZWFkZGlyU3luYyhjYXB0dXJlc1BhdGgpLmZpbHRlcihmaWxlID0+IFxuICAgICAgICAgICAgZmlsZS5zdGFydHNXaXRoKCd3ZWJjYW1fJykgJiYgZmlsZS5lbmRzV2l0aCgnLmpwZycpKS5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgICAgICBcbiAgICAgIGNvbnN0IGVuaGFuY2VGaWxlcyA9IGZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhdGgpXG4gICAgICAgID8gZnMucmVhZGRpclN5bmMoZW5oYW5jZVBhdGgpLmZpbHRlcihmaWxlID0+IFxuICAgICAgICAgICAgZmlsZS5zdGFydHNXaXRoKCd3ZWJjYW1fZW5oYW5jZV8nKSAmJiBmaWxlLmVuZHNXaXRoKCcuanBnJykpLmxlbmd0aFxuICAgICAgICA6IDA7XG4gICAgICBcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGlzUHJvY2Vzc2luZyxcbiAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlRmlsZXMsXG4gICAgICAgIGVuaGFuY2VDb3VudDogZW5oYW5jZUZpbGVzLFxuICAgICAgICBuZWVkc1Byb2Nlc3Npbmc6IGNhcHR1cmVGaWxlcyA+IGVuaGFuY2VGaWxlcyxcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzSW5mb1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHByb2Nlc3Mgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIEhhbmRsZSBQT1NUIHJlcXVlc3QgdG8gdHJpZ2dlciBwcm9jZXNzaW5nXG4gIGVsc2UgaWYgKHJlcS5tZXRob2QgPT09ICdQT1NUJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgbGlzdCBvZiBmaWxlcyB0byBwcm9jZXNzIGZyb20gcmVxdWVzdCBib2R5XG4gICAgICBjb25zdCB7IHNldE51bWJlcnMgfSA9IHJlcS5ib2R5O1xuICAgICAgXG4gICAgICBpZiAoIXNldE51bWJlcnMgfHwgIUFycmF5LmlzQXJyYXkoc2V0TnVtYmVycykgfHwgc2V0TnVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ05vIHNldCBudW1iZXJzIHByb3ZpZGVkIGZvciBwcm9jZXNzaW5nJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkaXJlY3RvcnkgZXhpc3RzIGJlZm9yZSBjcmVhdGluZyB0aGUgbG9jayBmaWxlXG4gICAgICBjb25zdCBjYXB0dXJlc0RpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJyk7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoY2FwdHVyZXNEaXIpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhjYXB0dXJlc0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBlbmhhbmNlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBjb25zdCBlbmhhbmNlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ2VuaGFuY2UnKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhlbmhhbmNlUGF0aCkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKGVuaGFuY2VQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgbG9jayBmaWxlXG4gICAgICBjb25zdCBsb2NrRmlsZVBhdGggPSBwYXRoLmpvaW4oY2FwdHVyZXNEaXIsICdwcm9jZXNzaW5nLmxvY2snKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA5KS5qc29uKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ1Byb2Nlc3NpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBsb2NrIGZpbGUgdG8gaW5kaWNhdGUgcHJvY2Vzc2luZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhsb2NrRmlsZVBhdGgsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGxvY2sgZmlsZSBhdCAke2xvY2tGaWxlUGF0aH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBsb2NrIGZpbGU6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gY3JlYXRlIGxvY2sgZmlsZTogJHtlcnIubWVzc2FnZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgaW5pdGlhbCBwcm9ncmVzcyBmaWxlXG4gICAgICBjb25zdCBwcm9ncmVzc0ZpbGVQYXRoID0gcGF0aC5qb2luKGNhcHR1cmVzRGlyLCAncHJvY2Vzc2luZ19wcm9ncmVzcy5qc29uJyk7XG4gICAgICBjb25zdCBwcm9ncmVzc0luZm8gPSB7XG4gICAgICAgIGN1cnJlbnRTZXQ6IDAsXG4gICAgICAgIHRvdGFsU2V0czogc2V0TnVtYmVycy5sZW5ndGgsXG4gICAgICAgIHByb2Nlc3NlZFNldHM6IFtdLFxuICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdFVwZGF0ZVRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwcm9ncmVzc0ZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShwcm9ncmVzc0luZm8sIG51bGwsIDIpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBwcm9ncmVzcyBmaWxlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWZpbmUgcGF0aHMgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IGNhcHR1cmVEaXIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycsICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnKTtcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHByb2Nlc3NpbmcgbWV0aG9kIHRvIHVzZVxuICAgICAgY29uc3QgdXNlQmFja2VuZCA9IHByb2Nlc3MuZW52LlVTRV9QWVRIT05fQkFDS0VORCA9PT0gJ3RydWUnO1xuICAgICAgXG4gICAgICBpZiAodXNlQmFja2VuZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgYmFja2VuZCBwcm9jZXNzaW5nIG9mICR7c2V0TnVtYmVycy5sZW5ndGh9IHNldHMuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHByb2Nlc3Npbmcgd2l0aCB0aGUgUHl0aG9uIGJhY2tlbmRcbiAgICAgICAgcHJvY2Vzc0ZpbGVzVmlhQmFja2VuZChzZXROdW1iZXJzKVxuICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmFja2VuZCBwcm9jZXNzaW5nIGNvbXBsZXRlZCB3aXRoIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGxvY2sgZmlsZSB3aGVuIGRvbmVcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhsb2NrRmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdCYWNrZW5kIHByb2Nlc3NpbmcgZmFpbGVkOicsIGVycik7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbG9jayBmaWxlIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgIGZzLnVubGlua1N5bmMobG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiAnUHJvY2Vzc2luZyBzdGFydGVkJyxcbiAgICAgICAgICBzZXRzVG9Qcm9jZXNzOiBzZXROdW1iZXJzLmxlbmd0aCxcbiAgICAgICAgICBwcm9jZXNzaW5nTWV0aG9kOiAncHl0aG9uLWJhY2tlbmQnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGRpcmVjdCBwcm9jZXNzaW5nIG9mICR7c2V0TnVtYmVycy5sZW5ndGh9IHNldHMuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmcgaW4gdGhlIGJhY2tncm91bmQgdXNpbmcgZGlyZWN0IE5vZGUuanMgcHJvY2Vzc2luZ1xuICAgICAgICBwcm9jZXNzRmlsZXNEaXJlY3RseShzZXROdW1iZXJzLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCwgcHJvZ3Jlc3NGaWxlUGF0aClcbiAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgY29tcGxldGVkIHdpdGggcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbG9jayBmaWxlIHdoZW4gZG9uZVxuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobG9ja0ZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2Nlc3NpbmcgZmFpbGVkOicsIGVycik7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbG9jayBmaWxlIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgIGZzLnVubGlua1N5bmMobG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiAnUHJvY2Vzc2luZyBzdGFydGVkJyxcbiAgICAgICAgICBzZXRzVG9Qcm9jZXNzOiBzZXROdW1iZXJzLmxlbmd0aCxcbiAgICAgICAgICBwcm9jZXNzaW5nTWV0aG9kOiAnZGlyZWN0J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHJpZ2dlcmluZyBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciwgbWFrZSBzdXJlIHRvIGRlbGV0ZSB0aGUgbG9jayBmaWxlXG4gICAgICBjb25zdCBsb2NrRmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycsICdwcm9jZXNzaW5nLmxvY2snKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy51bmxpbmtTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBsb2NrIGZpbGU6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgXG4gICAgfSk7XG4gIH1cbn0iXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwiZXhlYyIsInV0aWwiLCJmZXRjaCIsIkZvcm1EYXRhIiwiZXhlY1Byb21pc2UiLCJwcm9taXNpZnkiLCJwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uIiwiaW5wdXRQYXRoIiwib3V0cHV0UGF0aCIsInNldE51bWJlciIsImNhcHR1cmVEaXIiLCJlbmhhbmNlUGF0aCIsImNvbnNvbGUiLCJsb2ciLCJleGlzdHNTeW5jIiwiZXJyb3IiLCJiYWNrZW5kVXJsIiwicHJvY2VzcyIsImVudiIsIkJBQ0tFTkRfVVJMIiwiYXBpS2V5IiwiQVBJX0tFWSIsImZvcm1EYXRhIiwiZmlsZVN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJzdGF0cyIsInN0YXRTeW5jIiwic2l6ZSIsImFwcGVuZCIsImZpbGVuYW1lIiwiYmFzZW5hbWUiLCJjb250ZW50VHlwZSIsInJlc3BvbnNlIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ0aW1lb3V0Iiwic3RhdHVzIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZSIsInN0YXR1c1RleHQiLCJFcnJvciIsInJlc3VsdCIsInJlc3BvbnNlVGV4dCIsInN1YnN0cmluZyIsIkpTT04iLCJwYXJzZSIsIm1lc3NhZ2UiLCJzdWNjZXNzIiwiZmFjZV9kZXRlY3RlZCIsImNvcHlGaWxlU3luYyIsInVwZGF0ZVBhcmFtZXRlckZpbGUiLCJpbWFnZSIsImRhdGEiLCJpbWFnZUJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJ3cml0ZUZpbGVTeW5jIiwibGVuZ3RoIiwibWV0cmljcyIsInN0cmluZ2lmeSIsInN0YWNrIiwiY29weUVycm9yIiwib3JpZ2luYWxQYXJhbVBhdGhzIiwiam9pbiIsInBhcmFtRGVzdFBhdGgiLCJvcmlnaW5hbFBhcmFtcyIsIk1hcCIsIm9yaWdpbmFsUGFyYW1Gb3VuZCIsIm9yaWdpbmFsRmlyc3RMaW5lSXNIZWFkZXIiLCJvcmlnaW5hbFBhdGgiLCJjb250ZW50IiwicmVhZEZpbGVTeW5jIiwibGluZXMiLCJzcGxpdCIsImZpcnN0TGluZSIsInRyaW0iLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwic3RhcnRMaW5lIiwiaSIsImxpbmUiLCJwYXJ0cyIsInBhcmFtTmFtZSIsInBhcmFtVmFsdWUiLCJzZXQiLCJlcnIiLCJjc3ZDb250ZW50IiwiZXhjbHVkZVBhcmFtcyIsImZvckVhY2giLCJ2YWx1ZSIsImtleSIsImhlYWRfcG9zZSIsInBpdGNoIiwieWF3Iiwicm9sbCIsImV5ZV9jZW50ZXJzIiwibGVmdCIsInJpZ2h0IiwiZmFjZV9ib3giLCJtaW4iLCJtYXgiLCJmYWNlV2lkdGgiLCJNYXRoIiwicm91bmQiLCJmYWNlSGVpZ2h0IiwiZmllbGRzVG9QcmVzZXJ2ZSIsImZpZWxkIiwiaGFzIiwiZ2V0IiwicHJvY2Vzc0ZpbGVzVmlhQmFja2VuZCIsInNldE51bWJlcnMiLCJzZXRfbnVtYmVycyIsInNob3dfaGVhZF9wb3NlIiwic2hvd19ib3VuZGluZ19ib3giLCJzaG93X21hc2siLCJzaG93X3BhcmFtZXRlcnMiLCJqc29uIiwicHJvY2Vzc0ZpbGVzRGlyZWN0bHkiLCJwcm9ncmVzc0ZpbGVQYXRoIiwicHJvZ3Jlc3MiLCJjdXJyZW50U2V0IiwidG90YWxTZXRzIiwicHJvY2Vzc2VkU2V0cyIsInN0YXJ0VGltZSIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImxhc3RVcGRhdGVUaW1lIiwid2ViY2FtU3JjUGF0aCIsIndlYmNhbURlc3RQYXRoIiwid2FybiIsInNjcmVlblNyY1BhdGgiLCJzY3JlZW5EZXN0UGF0aCIsImVuaGFuY2VQYXJhbVBhdGgiLCJwdXNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiY29weVBhcmFtZXRlckZpbGUiLCJwYXJhbUZpbGVOYW1lcyIsInBhcmFtRm91bmQiLCJwYXJhbUZpbGVOYW1lIiwicGFyYW1TcmNQYXRoIiwiZGVzdEZpbGVOYW1lIiwicmVhZEVyciIsImVtcHR5Q29udGVudCIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJjYXB0dXJlc1BhdGgiLCJjd2QiLCJta2RpclN5bmMiLCJyZWN1cnNpdmUiLCJsb2NrRmlsZVBhdGgiLCJpc1Byb2Nlc3NpbmciLCJwcm9ncmVzc0luZm8iLCJwcm9ncmVzc0RhdGEiLCJjYXB0dXJlRmlsZXMiLCJyZWFkZGlyU3luYyIsImZpbHRlciIsImZpbGUiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJlbmhhbmNlRmlsZXMiLCJjYXB0dXJlQ291bnQiLCJlbmhhbmNlQ291bnQiLCJuZWVkc1Byb2Nlc3NpbmciLCJBcnJheSIsImlzQXJyYXkiLCJjYXB0dXJlc0RpciIsInVzZUJhY2tlbmQiLCJVU0VfUFlUSE9OX0JBQ0tFTkQiLCJ0aGVuIiwidW5saW5rU3luYyIsImNhdGNoIiwic2V0c1RvUHJvY2VzcyIsInByb2Nlc3NpbmdNZXRob2QiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/for-process-folder/process-status-api.js\n");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "form-data":
/*!****************************!*\
  !*** external "form-data" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("form-data");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-fetch");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();