"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/for-process-folder/process-status-api";
exports.ids = ["pages/api/for-process-folder/process-status-api"];
exports.modules = {

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/for-process-folder/process-status-api.js */ \"(api-node)/./pages/api/for-process-folder/process-status-api.js\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/for-process-folder/process-status-api\",\n        pathname: \"/api/for-process-folder/process-status-api\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGZm9yLXByb2Nlc3MtZm9sZGVyJTJGcHJvY2Vzcy1zdGF0dXMtYXBpJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZmb3ItcHJvY2Vzcy1mb2xkZXIlMkZwcm9jZXNzLXN0YXR1cy1hcGkuanMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ0U7QUFDMUQ7QUFDaUY7QUFDakY7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGdGQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxnRkFBUTtBQUNwQztBQUNPLHdCQUF3Qix5R0FBbUI7QUFDbEQ7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsICdkZWZhdWx0Jyk7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCAnY29uZmlnJyk7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZm9yLXByb2Nlc3MtZm9sZGVyL3Byb2Nlc3Mtc3RhdHVzLWFwaVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6ICcnLFxuICAgICAgICBmaWxlbmFtZTogJydcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/for-process-folder/process-status-api.js":
/*!************************************************************!*\
  !*** ./pages/api/for-process-folder/process-status-api.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! form-data */ \"form-data\");\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_5__);\n// pages/api/process-status-api.js - API to handle process status checks and triggers\n\n\n\n\n\n\n// Convert exec to Promise-based\nconst execPromise = util__WEBPACK_IMPORTED_MODULE_3___default().promisify(child_process__WEBPACK_IMPORTED_MODULE_2__.exec);\n// Updated function to properly handle image processing with proper dimension retention\n// Function to send a single image to the Python backend for processing\n// Modified function to preserve original parameter data and add new metrics\n// Fixed function to properly process webcam images through the Python backend\nasync function processImageWithPython(inputPath, outputPath, setNumber, captureDir, enhancePath) {\n    try {\n        console.log(`Starting to process image: ${inputPath}`);\n        // Check if input file exists\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(inputPath)) {\n            console.error(`Input file does not exist: ${inputPath}`);\n            return null;\n        }\n        // Get the backend URL\n        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';\n        const apiKey = process.env.API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV';\n        // Create form data\n        const formData = new (form_data__WEBPACK_IMPORTED_MODULE_5___default())();\n        // Open the file as a stream\n        const fileStream = fs__WEBPACK_IMPORTED_MODULE_0___default().createReadStream(inputPath);\n        // Log the file size\n        const stats = fs__WEBPACK_IMPORTED_MODULE_0___default().statSync(inputPath);\n        console.log(`File size: ${stats.size} bytes`);\n        // Add file to form data\n        formData.append('file', fileStream, {\n            filename: path__WEBPACK_IMPORTED_MODULE_1___default().basename(inputPath),\n            contentType: 'image/jpeg'\n        });\n        // Add processing parameters - these must match the FastAPI backend expectations\n        // formData.append('showHeadPose', 'false');\n        // formData.append('showBoundingBox', 'true');\n        // formData.append('showMask', 'false');\n        // formData.append('showParameters', 'true');\n        formData.append('showHeadPose', 'false');\n        formData.append('showBoundingBox', 'false');\n        formData.append('showMask', 'false');\n        formData.append('showParameters', 'false');\n        console.log(`Sending ${inputPath} to Python backend at ${backendUrl}/process-image`);\n        // Log request details for debugging\n        console.log('API Key being used:', apiKey);\n        console.log('Form data parameters:', 'showHeadPose=true', 'showBoundingBox=true', 'showMask=false', 'showParameters=true');\n        // Call the Python backend\n        const response = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(`${backendUrl}/process-image`, {\n            method: 'POST',\n            headers: {\n                'X-API-Key': apiKey\n            },\n            body: formData,\n            timeout: 30000 // 30 second timeout for processing large images\n        });\n        // Log the response status\n        console.log(`Backend response status: ${response.status}`);\n        if (!response.ok) {\n            let errorText = '';\n            try {\n                errorText = await response.text();\n            } catch (e) {\n                errorText = 'Could not read error details';\n            }\n            console.error(`Backend error: ${response.status} ${response.statusText}`);\n            console.error(`Response body: ${errorText}`);\n            throw new Error(`Backend returned ${response.status}: ${response.statusText}`);\n        }\n        // Parse the response as JSON\n        let result;\n        try {\n            const responseText = await response.text();\n            console.log(`Response text (first 200 chars): ${responseText.substring(0, 200)}...`);\n            result = JSON.parse(responseText);\n        } catch (error) {\n            console.error('Error parsing response JSON:', error);\n            throw new Error(`Failed to parse backend response: ${error.message}`);\n        }\n        // Log result status\n        console.log('Backend processing result:', result.success ? 'Success' : 'Failed');\n        if (result.success) {\n            // Check if a face was detected\n            if (result.face_detected === false) {\n                console.log('No face detected in the image - saving original image');\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                // Still update parameter file with this information\n                await updateParameterFile(setNumber, {\n                    face_detected: false\n                }, captureDir, enhancePath);\n                return null;\n            }\n            // Verify we have the processed image data\n            if (!result.image || !result.image.data) {\n                console.error('Backend response missing image data');\n                // Fall back to copying the original image\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                console.log(`Copied original image as fallback to: ${outputPath}`);\n                // Update parameter file with minimal info\n                await updateParameterFile(setNumber, {\n                    face_detected: false\n                }, captureDir, enhancePath);\n                return null;\n            }\n            // Save the processed image\n            try {\n                const imageBuffer = Buffer.from(result.image.data, 'base64');\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(outputPath, imageBuffer);\n                console.log(`Saved processed image to ${outputPath}, size: ${imageBuffer.length} bytes`);\n            } catch (error) {\n                console.error(`Error saving processed image: ${error.message}`);\n                // Fall back to copying the original image\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                console.log(`Copied original image as fallback to: ${outputPath}`);\n            }\n            // Check for metrics in the response\n            if (result.metrics) {\n                console.log('Metrics received from backend:', JSON.stringify(result.metrics));\n                // Update parameter file with the metrics\n                await updateParameterFile(setNumber, result.metrics, captureDir, enhancePath);\n                return result.metrics;\n            } else {\n                console.log('No metrics received from backend, using face_detected status only');\n                // Update parameter file with just the face detection status\n                await updateParameterFile(setNumber, {\n                    face_detected: true\n                }, captureDir, enhancePath);\n                return {\n                    face_detected: true\n                };\n            }\n        } else {\n            console.error(`Backend processing failed: ${result.error || 'Unknown error'}`);\n            // Fall back to copying the original image\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n            console.log(`Copied original image as fallback to: ${outputPath}`);\n            // Update parameter file with error information\n            await updateParameterFile(setNumber, null, captureDir, enhancePath);\n            return null;\n        }\n    } catch (error) {\n        console.error(`Error processing image with Python backend: ${error.message}`);\n        console.error(error.stack);\n        // Fall back to copying the original image\n        try {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n            console.log(`Copied original image as fallback after error: ${outputPath}`);\n        } catch (copyError) {\n            console.error(`Error copying original image: ${copyError.message}`);\n        }\n        // Update parameter file with error information\n        await updateParameterFile(setNumber, null, captureDir, enhancePath);\n        return null;\n    }\n}\n// New function to update parameter file with new metrics while preserving original data\n// Updated function to properly handle parameter file updates\nasync function updateParameterFile(setNumber, metrics, captureDir, enhancePath) {\n    console.log(`Updating parameter file for set ${setNumber} with new metrics`);\n    // Determine parameter file paths\n    const originalParamPaths = [\n        path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `parameters_${setNumber}.csv`),\n        path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `parameter_${setNumber}.csv`)\n    ];\n    // Output parameter file path\n    const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n    // Load original parameter data if available\n    let originalParams = new Map();\n    let originalParamFound = false;\n    let originalFirstLineIsHeader = false;\n    for (const originalPath of originalParamPaths){\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(originalPath)) {\n            console.log(`Found original parameter file: ${originalPath}`);\n            originalParamFound = true;\n            try {\n                const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(originalPath, 'utf8');\n                console.log(`Original parameter file content: ${content.substring(0, 100)}...`);\n                const lines = content.split('\\n');\n                // Check if the first line is a header\n                const firstLine = lines[0].trim();\n                originalFirstLineIsHeader = firstLine.toLowerCase().includes('parameter') || firstLine.toLowerCase().includes('name');\n                // Skip header line if it exists\n                const startLine = originalFirstLineIsHeader ? 1 : 0;\n                // Parse the original parameters\n                for(let i = startLine; i < lines.length; i++){\n                    const line = lines[i].trim();\n                    if (line) {\n                        const parts = line.split(',');\n                        if (parts.length >= 2) {\n                            const paramName = parts[0].trim();\n                            const paramValue = parts[1].trim();\n                            originalParams.set(paramName, paramValue);\n                            console.log(`Loaded parameter: ${paramName}=${paramValue}`);\n                        }\n                    }\n                }\n                console.log(`Loaded ${originalParams.size} parameters from original file`);\n                break; // Found and loaded one parameter file, no need to check the other\n            } catch (err) {\n                console.error(`Error reading original parameter file: ${err.message}`);\n            }\n        }\n    }\n    // Prepare CSV content with header\n    let csvContent = 'Parameter,Value\\n';\n    // Add original parameters first (except those we'll update with new values)\n    const excludeParams = [\n        'pitch',\n        'yaw',\n        'roll',\n        'face_width',\n        'face_height',\n        'left_eye_x',\n        'left_eye_y',\n        'right_eye_x',\n        'right_eye_y',\n        'face_box_min_x',\n        'face_box_min_y',\n        'face_box_max_x',\n        'face_box_max_y'\n    ];\n    // Log all original parameters for debugging\n    console.log(\"Original parameters:\");\n    originalParams.forEach((value, key)=>{\n        console.log(`  ${key}: ${value}`);\n    });\n    // Add existing parameters (except those we'll update)\n    originalParams.forEach((value, key)=>{\n        if (!excludeParams.includes(key.toLowerCase())) {\n            csvContent += `${key},${value}\\n`;\n        }\n    });\n    // Now add the new metrics\n    if (metrics && metrics.face_detected !== false) {\n        console.log(\"Adding new metrics from face detection\");\n        // Add head pose data\n        if (metrics.head_pose) {\n            console.log(`Adding head pose: pitch=${metrics.head_pose.pitch}, yaw=${metrics.head_pose.yaw}, roll=${metrics.head_pose.roll}`);\n            csvContent += `pitch,${metrics.head_pose.pitch}\\n`;\n            csvContent += `yaw,${metrics.head_pose.yaw}\\n`;\n            csvContent += `roll,${metrics.head_pose.roll}\\n`;\n        }\n        // Add eye centers if available\n        if (metrics.eye_centers) {\n            if (metrics.eye_centers.left) {\n                console.log(`Adding left eye: ${metrics.eye_centers.left.join(',')}`);\n                csvContent += `left_eye_x,${metrics.eye_centers.left[0]}\\n`;\n                csvContent += `left_eye_y,${metrics.eye_centers.left[1]}\\n`;\n            }\n            if (metrics.eye_centers.right) {\n                console.log(`Adding right eye: ${metrics.eye_centers.right.join(',')}`);\n                csvContent += `right_eye_x,${metrics.eye_centers.right[0]}\\n`;\n                csvContent += `right_eye_y,${metrics.eye_centers.right[1]}\\n`;\n            }\n        }\n        // Add face box information if available\n        if (metrics.face_box) {\n            if (metrics.face_box.min) {\n                console.log(`Adding face box min: ${metrics.face_box.min.join(',')}`);\n                csvContent += `face_box_min_x,${metrics.face_box.min[0]}\\n`;\n                csvContent += `face_box_min_y,${metrics.face_box.min[1]}\\n`;\n            }\n            if (metrics.face_box.max) {\n                console.log(`Adding face box max: ${metrics.face_box.max.join(',')}`);\n                csvContent += `face_box_max_x,${metrics.face_box.max[0]}\\n`;\n                csvContent += `face_box_max_y,${metrics.face_box.max[1]}\\n`;\n                // Calculate and add face width and height\n                if (metrics.face_box.min) {\n                    const faceWidth = Math.round(metrics.face_box.max[0] - metrics.face_box.min[0]);\n                    const faceHeight = Math.round(metrics.face_box.max[1] - metrics.face_box.min[1]);\n                    console.log(`Adding face dimensions: width=${faceWidth}, height=${faceHeight}`);\n                    csvContent += `face_width,${faceWidth}\\n`;\n                    csvContent += `face_height,${faceHeight}\\n`;\n                }\n            }\n        }\n    } else if (originalParamFound) {\n        // If no new metrics but we had original data for these fields, preserve them\n        console.log(\"No new metrics, preserving original face tracking data if available\");\n        const fieldsToPreserve = [\n            'pitch',\n            'yaw',\n            'roll',\n            'face_width',\n            'face_height',\n            'left_eye_x',\n            'left_eye_y',\n            'right_eye_x',\n            'right_eye_y',\n            'face_box_min_x',\n            'face_box_min_y',\n            'face_box_max_x',\n            'face_box_max_y'\n        ];\n        fieldsToPreserve.forEach((field)=>{\n            if (originalParams.has(field)) {\n                console.log(`Preserving original ${field}=${originalParams.get(field)}`);\n                csvContent += `${field},${originalParams.get(field)}\\n`;\n            }\n        });\n    } else {\n        // No metrics and no original data, add placeholder information\n        console.log(\"No metrics and no original data, adding placeholder\");\n        csvContent += 'info,No face detected or processing failed\\n';\n    }\n    // Log the final CSV content for debugging\n    console.log(`Final parameter file content:\\n${csvContent}`);\n    // Write the updated CSV file\n    fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(paramDestPath, csvContent);\n    console.log(`Wrote updated parameter file to: ${paramDestPath}`);\n    // Verify the file was written\n    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramDestPath)) {\n        console.log(`Parameter file successfully updated: ${paramDestPath}`);\n        return true;\n    } else {\n        console.error(`Failed to create parameter file: ${paramDestPath}`);\n        return false;\n    }\n}\n// Function to process files via the FastAPI backend\nasync function processFilesViaBackend(setNumbers) {\n    try {\n        // Get the backend URL from environment variable or use default\n        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';\n        const apiKey = process.env.API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV';\n        // Call the FastAPI backend to process the files\n        const response = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(`${backendUrl}/process-batch`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-API-Key': apiKey\n            },\n            body: JSON.stringify({\n                set_numbers: setNumbers,\n                show_head_pose: true,\n                show_bounding_box: true,\n                show_mask: false,\n                show_parameters: false\n            })\n        });\n        // Check if the request was successful\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error('Backend processing error:', errorText);\n            return {\n                success: false,\n                error: `Backend error: ${response.status} ${response.statusText}`\n            };\n        }\n        // Parse the response\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error('Error calling backend for processing:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Function to process files directly in Node.js\n// Function to process files directly in Node.js\nasync function processFilesDirectly(setNumbers, captureDir, enhancePath, progressFilePath) {\n    try {\n        console.log(\"=== STARTING DIRECT PROCESSING ===\");\n        console.log(`Processing sets: ${setNumbers.join(', ')}`);\n        console.log(`Capture directory: ${captureDir}`);\n        console.log(`Enhance directory: ${enhancePath}`);\n        // Get current progress or initialize\n        let progress = {\n            currentSet: 0,\n            totalSets: setNumbers.length,\n            processedSets: [],\n            startTime: new Date().toISOString(),\n            lastUpdateTime: new Date().toISOString()\n        };\n        // Process each set\n        for (const setNumber of setNumbers){\n            try {\n                console.log(`\\n--- Processing set ${setNumber} ---`);\n                progress.currentSet = setNumber;\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progress, null, 2));\n                console.log(`Updated progress file for set ${setNumber}`);\n                // Process webcam image\n                const webcamSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `webcam_${setNumber}.jpg`);\n                const webcamDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `webcam_enhance_${setNumber}.jpg`);\n                console.log(`Looking for webcam image at: ${webcamSrcPath}`);\n                if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(webcamSrcPath)) {\n                    console.log(`Found webcam image: ${webcamSrcPath}`);\n                    try {\n                        // Process the image through the Python backend\n                        console.log(`Sending webcam image for set ${setNumber} to process_image_handler`);\n                        // We're passing the capture directory and enhance path to help with parameter file handling\n                        const metrics = await processImageWithPython(webcamSrcPath, webcamDestPath, setNumber, captureDir, enhancePath);\n                        if (metrics) {\n                            console.log(`✅ Successfully processed webcam image and extracted metrics for set ${setNumber}`);\n                        } else {\n                            console.warn(`⚠️ Process completed but no metrics returned for set ${setNumber}`);\n                            // Ensure the image is copied even if no metrics were returned\n                            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(webcamDestPath)) {\n                                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(webcamSrcPath, webcamDestPath);\n                                console.log(`Copied original webcam image as fallback for set ${setNumber}`);\n                            }\n                        }\n                    } catch (err) {\n                        console.error(`❌ Error processing webcam image for set ${setNumber}: ${err.message}`);\n                        console.error(err.stack);\n                        // Fallback to copying the original file\n                        console.log(`Copying original webcam image as fallback for set ${setNumber}`);\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(webcamSrcPath, webcamDestPath);\n                    }\n                } else {\n                    console.warn(`⚠️ Webcam image not found for set ${setNumber}: ${webcamSrcPath}`);\n                }\n                // Process screen image if it exists\n                const screenSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `screen_${setNumber}.jpg`);\n                const screenDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `screen_enhance_${setNumber}.jpg`);\n                console.log(`Looking for screen image at: ${screenSrcPath}`);\n                if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(screenSrcPath)) {\n                    console.log(`Screen image found: ${screenSrcPath}`);\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(screenSrcPath, screenDestPath);\n                    console.log(`Copied screen image to: ${screenDestPath}`);\n                } else {\n                    console.warn(`⚠️ Screen image not found for set ${setNumber}`);\n                }\n                // Verify that we have a parameter file for this set in the enhance directory\n                const enhanceParamPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n                if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhanceParamPath)) {\n                    console.log(`Parameter file not created during processing for set ${setNumber}, checking for original...`);\n                    await updateParameterFile(setNumber, null, captureDir, enhancePath);\n                }\n                // Update progress\n                progress.processedSets.push(setNumber);\n                progress.lastUpdateTime = new Date().toISOString();\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progress, null, 2));\n                console.log(`Updated progress - set ${setNumber} completed`);\n                // Add a small delay to prevent overwhelming the system\n                console.log(`Waiting 500ms before processing next set...`);\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n            } catch (err) {\n                console.error(`❌ Error processing set ${setNumber}:`, err);\n            }\n        }\n        console.log(\"\\n=== PROCESSING COMPLETED ===\");\n        console.log(`Total sets processed: ${progress.processedSets.length}/${progress.totalSets}`);\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('❌ Error in direct processing:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Helper function to copy parameter files\nasync function copyParameterFile(captureDir, enhancePath, setNumber) {\n    // Try both parameter and parameters naming\n    const paramFileNames = [\n        `parameters_${setNumber}.csv`,\n        `parameter_${setNumber}.csv`\n    ];\n    let paramFound = false;\n    for (const paramFileName of paramFileNames){\n        const paramSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, paramFileName);\n        console.log(`Looking for parameter file at: ${paramSrcPath}`);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramSrcPath)) {\n            console.log(`Parameter file found: ${paramSrcPath}`);\n            paramFound = true;\n            // Determine destination name (change parameter to parameter_enhance)\n            const destFileName = 'parameter_enhance_' + setNumber + '.csv';\n            const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, destFileName);\n            console.log(`Copying parameter file to: ${paramDestPath}`);\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(paramSrcPath, paramDestPath);\n            // Verify parameter file copy\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramDestPath)) {\n                console.log(`✅ Parameter file copied successfully`);\n                // Read content to verify\n                try {\n                    const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(paramDestPath, 'utf8');\n                    const firstLine = content.split('\\n')[0];\n                    console.log(`Parameter file content starts with: ${firstLine}`);\n                } catch (readErr) {\n                    console.error(`Error reading parameter file: ${readErr.message}`);\n                }\n            } else {\n                console.error(`❌ Error: Parameter destination file doesn't exist after copy!`);\n            }\n            break; // Found and copied one parameter file, no need to check the other\n        }\n    }\n    if (!paramFound) {\n        console.log(`⚠️ No parameter files found for set ${setNumber}`);\n        // Create an empty parameter file if none exists\n        const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n        const emptyContent = 'Parameter,Value\\ninfo,No face detected or processing failed\\n';\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(paramDestPath, emptyContent);\n        console.log(`⚠️ Created empty parameter file: ${paramDestPath}`);\n    }\n}\n// Main handler for API requests\nasync function handler(req, res) {\n    // Handle GET request to check processing status\n    if (req.method === 'GET') {\n        try {\n            const capturesPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'eye_tracking_captures');\n            const enhancePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'enhance');\n            // Create captures directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures'))) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures'), {\n                    recursive: true\n                });\n            }\n            // Create capture directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesPath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(capturesPath, {\n                    recursive: true\n                });\n            }\n            // Create enhance directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(enhancePath, {\n                    recursive: true\n                });\n            }\n            // Check if there's a processing.lock file (indicating processing is in progress)\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing.lock');\n            const isProcessing = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath);\n            // Check for progress information file\n            const progressFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing_progress.json');\n            let progressInfo = {\n                currentSet: 0,\n                totalSets: 0,\n                processedSets: [],\n                startTime: null,\n                lastUpdateTime: null\n            };\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(progressFilePath)) {\n                try {\n                    const progressData = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(progressFilePath, 'utf8');\n                    progressInfo = JSON.parse(progressData);\n                } catch (err) {\n                    console.error(\"Error reading progress file:\", err);\n                }\n            }\n            // Count files in each directory\n            const captureFiles = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesPath) ? fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(capturesPath).filter((file)=>file.startsWith('webcam_') && file.endsWith('.jpg')).length : 0;\n            const enhanceFiles = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath) ? fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(enhancePath).filter((file)=>file.startsWith('webcam_enhance_') && file.endsWith('.jpg')).length : 0;\n            return res.status(200).json({\n                success: true,\n                isProcessing,\n                captureCount: captureFiles,\n                enhanceCount: enhanceFiles,\n                needsProcessing: captureFiles > enhanceFiles,\n                progress: progressInfo\n            });\n        } catch (error) {\n            console.error('Error checking process status:', error);\n            return res.status(500).json({\n                success: false,\n                error: error.message\n            });\n        }\n    } else if (req.method === 'POST') {\n        try {\n            // Get list of files to process from request body\n            const { setNumbers } = req.body;\n            if (!setNumbers || !Array.isArray(setNumbers) || setNumbers.length === 0) {\n                return res.status(400).json({\n                    success: false,\n                    error: 'No set numbers provided for processing'\n                });\n            }\n            // Make sure the directory exists before creating the lock file\n            const capturesDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures');\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesDir)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(capturesDir, {\n                    recursive: true\n                });\n            }\n            // Create enhance directory if it doesn't exist\n            const enhancePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'enhance');\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(enhancePath, {\n                    recursive: true\n                });\n            }\n            // Check if there's already a lock file\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(capturesDir, 'processing.lock');\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                return res.status(409).json({\n                    success: false,\n                    error: 'Processing is already in progress'\n                });\n            }\n            // Create lock file to indicate processing is in progress\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(lockFilePath, new Date().toISOString());\n                console.log(`Created lock file at ${lockFilePath}`);\n            } catch (err) {\n                console.error(`Error creating lock file: ${err.message}`);\n                return res.status(500).json({\n                    success: false,\n                    error: `Failed to create lock file: ${err.message}`\n                });\n            }\n            // Create initial progress file\n            const progressFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(capturesDir, 'processing_progress.json');\n            const progressInfo = {\n                currentSet: 0,\n                totalSets: setNumbers.length,\n                processedSets: [],\n                startTime: new Date().toISOString(),\n                lastUpdateTime: new Date().toISOString()\n            };\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progressInfo, null, 2));\n            } catch (err) {\n                console.error(`Error creating progress file: ${err.message}`);\n            }\n            // Define paths for processing\n            const captureDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'eye_tracking_captures');\n            // Determine which processing method to use\n            const useBackend = process.env.USE_PYTHON_BACKEND === 'true';\n            if (useBackend) {\n                console.log(`Starting backend processing of ${setNumbers.length} sets...`);\n                // Start processing with the Python backend\n                processFilesViaBackend(setNumbers).then((result)=>{\n                    console.log('Backend processing completed with result:', result);\n                    // Clean up the lock file when done\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                }).catch((err)=>{\n                    console.error('Backend processing failed:', err);\n                    // Clean up the lock file on error\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: 'Processing started',\n                    setsToProcess: setNumbers.length,\n                    processingMethod: 'python-backend'\n                });\n            } else {\n                console.log(`Starting direct processing of ${setNumbers.length} sets...`);\n                // Start processing in the background using direct Node.js processing\n                processFilesDirectly(setNumbers, captureDir, enhancePath, progressFilePath).then((result)=>{\n                    console.log('Processing completed with result:', result);\n                    // Clean up the lock file when done\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                }).catch((err)=>{\n                    console.error('Processing failed:', err);\n                    // Clean up the lock file on error\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: 'Processing started',\n                    setsToProcess: setNumbers.length,\n                    processingMethod: 'direct'\n                });\n            }\n        } catch (error) {\n            console.error('Error triggering processing:', error);\n            // If there's an error, make sure to delete the lock file\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing.lock');\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                try {\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                } catch (e) {\n                    console.error('Error removing lock file:', e);\n                }\n            }\n            return res.status(500).json({\n                success: false,\n                error: error.message\n            });\n        }\n    } else {\n        return res.status(405).json({\n            success: false,\n            error: 'Method not allowed'\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxRkFBcUY7QUFDakU7QUFDSTtBQUNhO0FBQ2I7QUFDTztBQUNFO0FBRWpDLGdDQUFnQztBQUNoQyxNQUFNTSxjQUFjSCxxREFBYyxDQUFDRCwrQ0FBSUE7QUFFdkMsdUZBQXVGO0FBQ3ZGLHVFQUF1RTtBQUN2RSw0RUFBNEU7QUFDNUUsOEVBQThFO0FBQzlFLGVBQWVNLHVCQUF1QkMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQzdGLElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDLENBQUMsMkJBQTJCLEVBQUVOLFdBQVc7UUFFckQsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ1Qsb0RBQWEsQ0FBQ1MsWUFBWTtZQUM3QkssUUFBUUcsS0FBSyxDQUFDLENBQUMsMkJBQTJCLEVBQUVSLFdBQVc7WUFDdkQsT0FBTztRQUNUO1FBRUEsc0JBQXNCO1FBQ3RCLE1BQU1TLGFBQWFDLFFBQVFDLEdBQUcsQ0FBQ0MsV0FBVyxJQUFJO1FBQzlDLE1BQU1DLFNBQVNILFFBQVFDLEdBQUcsQ0FBQ0csT0FBTyxJQUFJO1FBRXRDLG1CQUFtQjtRQUNuQixNQUFNQyxXQUFXLElBQUluQixrREFBUUE7UUFFN0IsNEJBQTRCO1FBQzVCLE1BQU1vQixhQUFhekIsMERBQW1CLENBQUNTO1FBRXZDLG9CQUFvQjtRQUNwQixNQUFNa0IsUUFBUTNCLGtEQUFXLENBQUNTO1FBQzFCSyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUVZLE1BQU1FLElBQUksQ0FBQyxNQUFNLENBQUM7UUFFNUMsd0JBQXdCO1FBQ3hCTCxTQUFTTSxNQUFNLENBQUMsUUFBUUwsWUFBWTtZQUNsQ00sVUFBVTlCLG9EQUFhLENBQUNRO1lBQ3hCd0IsYUFBYTtRQUNmO1FBRUEsZ0ZBQWdGO1FBQ2hGLDRDQUE0QztRQUM1Qyw4Q0FBOEM7UUFDOUMsd0NBQXdDO1FBQ3hDLDZDQUE2QztRQUU3Q1QsU0FBU00sTUFBTSxDQUFDLGdCQUFnQjtRQUNoQ04sU0FBU00sTUFBTSxDQUFDLG1CQUFtQjtRQUNuQ04sU0FBU00sTUFBTSxDQUFDLFlBQVk7UUFDNUJOLFNBQVNNLE1BQU0sQ0FBQyxrQkFBa0I7UUFFbENoQixRQUFRQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUVOLFVBQVUsc0JBQXNCLEVBQUVTLFdBQVcsY0FBYyxDQUFDO1FBRW5GLG9DQUFvQztRQUNwQ0osUUFBUUMsR0FBRyxDQUFDLHVCQUF1Qk87UUFDbkNSLFFBQVFDLEdBQUcsQ0FBQyx5QkFDRCxxQkFDQSx3QkFDQSxrQkFDQTtRQUVYLDBCQUEwQjtRQUMxQixNQUFNbUIsV0FBVyxNQUFNOUIsaURBQUtBLENBQUMsR0FBR2MsV0FBVyxjQUFjLENBQUMsRUFBRTtZQUMxRGlCLFFBQVE7WUFDUkMsU0FBUztnQkFDUCxhQUFhZDtZQUNmO1lBQ0FlLE1BQU1iO1lBQ05jLFNBQVMsTUFBTSxnREFBZ0Q7UUFDakU7UUFFQSwwQkFBMEI7UUFDMUJ4QixRQUFRQyxHQUFHLENBQUMsQ0FBQyx5QkFBeUIsRUFBRW1CLFNBQVNLLE1BQU0sRUFBRTtRQUV6RCxJQUFJLENBQUNMLFNBQVNNLEVBQUUsRUFBRTtZQUNoQixJQUFJQyxZQUFZO1lBQ2hCLElBQUk7Z0JBQ0ZBLFlBQVksTUFBTVAsU0FBU1EsSUFBSTtZQUNqQyxFQUFFLE9BQU9DLEdBQUc7Z0JBQ1ZGLFlBQVk7WUFDZDtZQUVBM0IsUUFBUUcsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFaUIsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU1UsVUFBVSxFQUFFO1lBQ3hFOUIsUUFBUUcsS0FBSyxDQUFDLENBQUMsZUFBZSxFQUFFd0IsV0FBVztZQUMzQyxNQUFNLElBQUlJLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRVgsU0FBU0ssTUFBTSxDQUFDLEVBQUUsRUFBRUwsU0FBU1UsVUFBVSxFQUFFO1FBQy9FO1FBRUEsNkJBQTZCO1FBQzdCLElBQUlFO1FBQ0osSUFBSTtZQUNGLE1BQU1DLGVBQWUsTUFBTWIsU0FBU1EsSUFBSTtZQUN4QzVCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlDQUFpQyxFQUFFZ0MsYUFBYUMsU0FBUyxDQUFDLEdBQUcsS0FBSyxHQUFHLENBQUM7WUFDbkZGLFNBQVNHLEtBQUtDLEtBQUssQ0FBQ0g7UUFDdEIsRUFBRSxPQUFPOUIsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsZ0NBQWdDQTtZQUM5QyxNQUFNLElBQUk0QixNQUFNLENBQUMsa0NBQWtDLEVBQUU1QixNQUFNa0MsT0FBTyxFQUFFO1FBQ3RFO1FBRUEsb0JBQW9CO1FBQ3BCckMsUUFBUUMsR0FBRyxDQUFDLDhCQUE4QitCLE9BQU9NLE9BQU8sR0FBRyxZQUFZO1FBRXZFLElBQUlOLE9BQU9NLE9BQU8sRUFBRTtZQUNsQiwrQkFBK0I7WUFDL0IsSUFBSU4sT0FBT08sYUFBYSxLQUFLLE9BQU87Z0JBQ2xDdkMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaZixzREFBZSxDQUFDUyxXQUFXQztnQkFFM0Isb0RBQW9EO2dCQUNwRCxNQUFNNkMsb0JBQW9CNUMsV0FBVztvQkFBRTBDLGVBQWU7Z0JBQU0sR0FBR3pDLFlBQVlDO2dCQUUzRSxPQUFPO1lBQ1Q7WUFFQSwwQ0FBMEM7WUFDMUMsSUFBSSxDQUFDaUMsT0FBT1UsS0FBSyxJQUFJLENBQUNWLE9BQU9VLEtBQUssQ0FBQ0MsSUFBSSxFQUFFO2dCQUN2QzNDLFFBQVFHLEtBQUssQ0FBQztnQkFFZCwwQ0FBMEM7Z0JBQzFDakIsc0RBQWUsQ0FBQ1MsV0FBV0M7Z0JBQzNCSSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxzQ0FBc0MsRUFBRUwsWUFBWTtnQkFFakUsMENBQTBDO2dCQUMxQyxNQUFNNkMsb0JBQW9CNUMsV0FBVztvQkFBRTBDLGVBQWU7Z0JBQU0sR0FBR3pDLFlBQVlDO2dCQUUzRSxPQUFPO1lBQ1Q7WUFFQSwyQkFBMkI7WUFDM0IsSUFBSTtnQkFDRixNQUFNNkMsY0FBY0MsT0FBT0MsSUFBSSxDQUFDZCxPQUFPVSxLQUFLLENBQUNDLElBQUksRUFBRTtnQkFDbkR6RCx1REFBZ0IsQ0FBQ1UsWUFBWWdEO2dCQUM3QjVDLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHlCQUF5QixFQUFFTCxXQUFXLFFBQVEsRUFBRWdELFlBQVlJLE1BQU0sQ0FBQyxNQUFNLENBQUM7WUFDekYsRUFBRSxPQUFPN0MsT0FBTztnQkFDZEgsUUFBUUcsS0FBSyxDQUFDLENBQUMsOEJBQThCLEVBQUVBLE1BQU1rQyxPQUFPLEVBQUU7Z0JBRTlELDBDQUEwQztnQkFDMUNuRCxzREFBZSxDQUFDUyxXQUFXQztnQkFDM0JJLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHNDQUFzQyxFQUFFTCxZQUFZO1lBQ25FO1lBRUEsb0NBQW9DO1lBQ3BDLElBQUlvQyxPQUFPaUIsT0FBTyxFQUFFO2dCQUNsQmpELFFBQVFDLEdBQUcsQ0FBQyxrQ0FBa0NrQyxLQUFLZSxTQUFTLENBQUNsQixPQUFPaUIsT0FBTztnQkFFM0UseUNBQXlDO2dCQUN6QyxNQUFNUixvQkFBb0I1QyxXQUFXbUMsT0FBT2lCLE9BQU8sRUFBRW5ELFlBQVlDO2dCQUVqRSxPQUFPaUMsT0FBT2lCLE9BQU87WUFDdkIsT0FBTztnQkFDTGpELFFBQVFDLEdBQUcsQ0FBQztnQkFFWiw0REFBNEQ7Z0JBQzVELE1BQU13QyxvQkFBb0I1QyxXQUFXO29CQUFFMEMsZUFBZTtnQkFBSyxHQUFHekMsWUFBWUM7Z0JBRTFFLE9BQU87b0JBQUV3QyxlQUFlO2dCQUFLO1lBQy9CO1FBQ0YsT0FBTztZQUNMdkMsUUFBUUcsS0FBSyxDQUFDLENBQUMsMkJBQTJCLEVBQUU2QixPQUFPN0IsS0FBSyxJQUFJLGlCQUFpQjtZQUU3RSwwQ0FBMEM7WUFDMUNqQixzREFBZSxDQUFDUyxXQUFXQztZQUMzQkksUUFBUUMsR0FBRyxDQUFDLENBQUMsc0NBQXNDLEVBQUVMLFlBQVk7WUFFakUsK0NBQStDO1lBQy9DLE1BQU02QyxvQkFBb0I1QyxXQUFXLE1BQU1DLFlBQVlDO1lBRXZELE9BQU87UUFDVDtJQUNGLEVBQUUsT0FBT0ksT0FBTztRQUNkSCxRQUFRRyxLQUFLLENBQUMsQ0FBQyw0Q0FBNEMsRUFBRUEsTUFBTWtDLE9BQU8sRUFBRTtRQUM1RXJDLFFBQVFHLEtBQUssQ0FBQ0EsTUFBTWdELEtBQUs7UUFFekIsMENBQTBDO1FBQzFDLElBQUk7WUFDRmpFLHNEQUFlLENBQUNTLFdBQVdDO1lBQzNCSSxRQUFRQyxHQUFHLENBQUMsQ0FBQywrQ0FBK0MsRUFBRUwsWUFBWTtRQUM1RSxFQUFFLE9BQU93RCxXQUFXO1lBQ2xCcEQsUUFBUUcsS0FBSyxDQUFDLENBQUMsOEJBQThCLEVBQUVpRCxVQUFVZixPQUFPLEVBQUU7UUFDcEU7UUFFQSwrQ0FBK0M7UUFDL0MsTUFBTUksb0JBQW9CNUMsV0FBVyxNQUFNQyxZQUFZQztRQUV2RCxPQUFPO0lBQ1Q7QUFDRjtBQUNBLHdGQUF3RjtBQUN4Riw2REFBNkQ7QUFDN0QsZUFBZTBDLG9CQUFvQjVDLFNBQVMsRUFBRW9ELE9BQU8sRUFBRW5ELFVBQVUsRUFBRUMsV0FBVztJQUM1RUMsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0NBQWdDLEVBQUVKLFVBQVUsaUJBQWlCLENBQUM7SUFFM0UsaUNBQWlDO0lBQ2pDLE1BQU13RCxxQkFBcUI7UUFDekJsRSxnREFBUyxDQUFDVyxZQUFZLENBQUMsV0FBVyxFQUFFRCxVQUFVLElBQUksQ0FBQztRQUNuRFYsZ0RBQVMsQ0FBQ1csWUFBWSxDQUFDLFVBQVUsRUFBRUQsVUFBVSxJQUFJLENBQUM7S0FDbkQ7SUFFRCw2QkFBNkI7SUFDN0IsTUFBTTBELGdCQUFnQnBFLGdEQUFTLENBQUNZLGFBQWEsQ0FBQyxrQkFBa0IsRUFBRUYsVUFBVSxJQUFJLENBQUM7SUFFakYsNENBQTRDO0lBQzVDLElBQUkyRCxpQkFBaUIsSUFBSUM7SUFDekIsSUFBSUMscUJBQXFCO0lBQ3pCLElBQUlDLDRCQUE0QjtJQUVoQyxLQUFLLE1BQU1DLGdCQUFnQlAsbUJBQW9CO1FBQzdDLElBQUluRSxvREFBYSxDQUFDMEUsZUFBZTtZQUMvQjVELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLCtCQUErQixFQUFFMkQsY0FBYztZQUM1REYscUJBQXFCO1lBRXJCLElBQUk7Z0JBQ0YsTUFBTUcsVUFBVTNFLHNEQUFlLENBQUMwRSxjQUFjO2dCQUM5QzVELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlDQUFpQyxFQUFFNEQsUUFBUTNCLFNBQVMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDO2dCQUU5RSxNQUFNNkIsUUFBUUYsUUFBUUcsS0FBSyxDQUFDO2dCQUU1QixzQ0FBc0M7Z0JBQ3RDLE1BQU1DLFlBQVlGLEtBQUssQ0FBQyxFQUFFLENBQUNHLElBQUk7Z0JBQy9CUCw0QkFBNEJNLFVBQVVFLFdBQVcsR0FBR0MsUUFBUSxDQUFDLGdCQUNsQ0gsVUFBVUUsV0FBVyxHQUFHQyxRQUFRLENBQUM7Z0JBRTVELGdDQUFnQztnQkFDaEMsTUFBTUMsWUFBWVYsNEJBQTRCLElBQUk7Z0JBRWxELGdDQUFnQztnQkFDaEMsSUFBSyxJQUFJVyxJQUFJRCxXQUFXQyxJQUFJUCxNQUFNZixNQUFNLEVBQUVzQixJQUFLO29CQUM3QyxNQUFNQyxPQUFPUixLQUFLLENBQUNPLEVBQUUsQ0FBQ0osSUFBSTtvQkFDMUIsSUFBSUssTUFBTTt3QkFDUixNQUFNQyxRQUFRRCxLQUFLUCxLQUFLLENBQUM7d0JBQ3pCLElBQUlRLE1BQU14QixNQUFNLElBQUksR0FBRzs0QkFDckIsTUFBTXlCLFlBQVlELEtBQUssQ0FBQyxFQUFFLENBQUNOLElBQUk7NEJBQy9CLE1BQU1RLGFBQWFGLEtBQUssQ0FBQyxFQUFFLENBQUNOLElBQUk7NEJBQ2hDVixlQUFlbUIsR0FBRyxDQUFDRixXQUFXQzs0QkFDOUIxRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrQkFBa0IsRUFBRXdFLFVBQVUsQ0FBQyxFQUFFQyxZQUFZO3dCQUM1RDtvQkFDRjtnQkFDRjtnQkFFQTFFLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLE9BQU8sRUFBRXVELGVBQWV6QyxJQUFJLENBQUMsOEJBQThCLENBQUM7Z0JBQ3pFLE9BQU8sa0VBQWtFO1lBQzNFLEVBQUUsT0FBTzZELEtBQUs7Z0JBQ1o1RSxRQUFRRyxLQUFLLENBQUMsQ0FBQyx1Q0FBdUMsRUFBRXlFLElBQUl2QyxPQUFPLEVBQUU7WUFDdkU7UUFDRjtJQUNGO0lBRUEsa0NBQWtDO0lBQ2xDLElBQUl3QyxhQUFhO0lBRWpCLDRFQUE0RTtJQUM1RSxNQUFNQyxnQkFBZ0I7UUFBQztRQUFTO1FBQU87UUFBUTtRQUFjO1FBQ3RDO1FBQWM7UUFBYztRQUFlO1FBQzNDO1FBQWtCO1FBQWtCO1FBQWtCO0tBQWlCO0lBRTlGLDRDQUE0QztJQUM1QzlFLFFBQVFDLEdBQUcsQ0FBQztJQUNadUQsZUFBZXVCLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUM3QmpGLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsRUFBRWdGLElBQUksRUFBRSxFQUFFRCxPQUFPO0lBQ2xDO0lBRUEsc0RBQXNEO0lBQ3REeEIsZUFBZXVCLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUM3QixJQUFJLENBQUNILGNBQWNWLFFBQVEsQ0FBQ2EsSUFBSWQsV0FBVyxLQUFLO1lBQzlDVSxjQUFjLEdBQUdJLElBQUksQ0FBQyxFQUFFRCxNQUFNLEVBQUUsQ0FBQztRQUNuQztJQUNGO0lBRUEsMEJBQTBCO0lBQzFCLElBQUkvQixXQUFXQSxRQUFRVixhQUFhLEtBQUssT0FBTztRQUM5Q3ZDLFFBQVFDLEdBQUcsQ0FBQztRQUVaLHFCQUFxQjtRQUNyQixJQUFJZ0QsUUFBUWlDLFNBQVMsRUFBRTtZQUNyQmxGLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHdCQUF3QixFQUFFZ0QsUUFBUWlDLFNBQVMsQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sRUFBRWxDLFFBQVFpQyxTQUFTLENBQUNFLEdBQUcsQ0FBQyxPQUFPLEVBQUVuQyxRQUFRaUMsU0FBUyxDQUFDRyxJQUFJLEVBQUU7WUFDOUhSLGNBQWMsQ0FBQyxNQUFNLEVBQUU1QixRQUFRaUMsU0FBUyxDQUFDQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2xETixjQUFjLENBQUMsSUFBSSxFQUFFNUIsUUFBUWlDLFNBQVMsQ0FBQ0UsR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUM5Q1AsY0FBYyxDQUFDLEtBQUssRUFBRTVCLFFBQVFpQyxTQUFTLENBQUNHLElBQUksQ0FBQyxFQUFFLENBQUM7UUFDbEQ7UUFFQSwrQkFBK0I7UUFDL0IsSUFBSXBDLFFBQVFxQyxXQUFXLEVBQUU7WUFDdkIsSUFBSXJDLFFBQVFxQyxXQUFXLENBQUNDLElBQUksRUFBRTtnQkFDNUJ2RixRQUFRQyxHQUFHLENBQUMsQ0FBQyxpQkFBaUIsRUFBRWdELFFBQVFxQyxXQUFXLENBQUNDLElBQUksQ0FBQ2pDLElBQUksQ0FBQyxNQUFNO2dCQUNwRXVCLGNBQWMsQ0FBQyxXQUFXLEVBQUU1QixRQUFRcUMsV0FBVyxDQUFDQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDM0RWLGNBQWMsQ0FBQyxXQUFXLEVBQUU1QixRQUFRcUMsV0FBVyxDQUFDQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztZQUM3RDtZQUNBLElBQUl0QyxRQUFRcUMsV0FBVyxDQUFDRSxLQUFLLEVBQUU7Z0JBQzdCeEYsUUFBUUMsR0FBRyxDQUFDLENBQUMsa0JBQWtCLEVBQUVnRCxRQUFRcUMsV0FBVyxDQUFDRSxLQUFLLENBQUNsQyxJQUFJLENBQUMsTUFBTTtnQkFDdEV1QixjQUFjLENBQUMsWUFBWSxFQUFFNUIsUUFBUXFDLFdBQVcsQ0FBQ0UsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7Z0JBQzdEWCxjQUFjLENBQUMsWUFBWSxFQUFFNUIsUUFBUXFDLFdBQVcsQ0FBQ0UsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7WUFDL0Q7UUFDRjtRQUVBLHdDQUF3QztRQUN4QyxJQUFJdkMsUUFBUXdDLFFBQVEsRUFBRTtZQUNwQixJQUFJeEMsUUFBUXdDLFFBQVEsQ0FBQ0MsR0FBRyxFQUFFO2dCQUN4QjFGLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixFQUFFZ0QsUUFBUXdDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDcEMsSUFBSSxDQUFDLE1BQU07Z0JBQ3BFdUIsY0FBYyxDQUFDLGVBQWUsRUFBRTVCLFFBQVF3QyxRQUFRLENBQUNDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO2dCQUMzRGIsY0FBYyxDQUFDLGVBQWUsRUFBRTVCLFFBQVF3QyxRQUFRLENBQUNDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQzdEO1lBQ0EsSUFBSXpDLFFBQVF3QyxRQUFRLENBQUNFLEdBQUcsRUFBRTtnQkFDeEIzRixRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUIsRUFBRWdELFFBQVF3QyxRQUFRLENBQUNFLEdBQUcsQ0FBQ3JDLElBQUksQ0FBQyxNQUFNO2dCQUNwRXVCLGNBQWMsQ0FBQyxlQUFlLEVBQUU1QixRQUFRd0MsUUFBUSxDQUFDRSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFDM0RkLGNBQWMsQ0FBQyxlQUFlLEVBQUU1QixRQUFRd0MsUUFBUSxDQUFDRSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztnQkFFM0QsMENBQTBDO2dCQUMxQyxJQUFJMUMsUUFBUXdDLFFBQVEsQ0FBQ0MsR0FBRyxFQUFFO29CQUN4QixNQUFNRSxZQUFZQyxLQUFLQyxLQUFLLENBQUM3QyxRQUFRd0MsUUFBUSxDQUFDRSxHQUFHLENBQUMsRUFBRSxHQUFHMUMsUUFBUXdDLFFBQVEsQ0FBQ0MsR0FBRyxDQUFDLEVBQUU7b0JBQzlFLE1BQU1LLGFBQWFGLEtBQUtDLEtBQUssQ0FBQzdDLFFBQVF3QyxRQUFRLENBQUNFLEdBQUcsQ0FBQyxFQUFFLEdBQUcxQyxRQUFRd0MsUUFBUSxDQUFDQyxHQUFHLENBQUMsRUFBRTtvQkFDL0UxRixRQUFRQyxHQUFHLENBQUMsQ0FBQyw4QkFBOEIsRUFBRTJGLFVBQVUsU0FBUyxFQUFFRyxZQUFZO29CQUM5RWxCLGNBQWMsQ0FBQyxXQUFXLEVBQUVlLFVBQVUsRUFBRSxDQUFDO29CQUN6Q2YsY0FBYyxDQUFDLFlBQVksRUFBRWtCLFdBQVcsRUFBRSxDQUFDO2dCQUM3QztZQUNGO1FBQ0Y7SUFDRixPQUFPLElBQUlyQyxvQkFBb0I7UUFDN0IsNkVBQTZFO1FBQzdFMUQsUUFBUUMsR0FBRyxDQUFDO1FBRVosTUFBTStGLG1CQUFtQjtZQUFDO1lBQVM7WUFBTztZQUFRO1lBQWM7WUFDdkM7WUFBYztZQUFjO1lBQWU7WUFDM0M7WUFBa0I7WUFBa0I7WUFBa0I7U0FBaUI7UUFFaEdBLGlCQUFpQmpCLE9BQU8sQ0FBQ2tCLENBQUFBO1lBQ3ZCLElBQUl6QyxlQUFlMEMsR0FBRyxDQUFDRCxRQUFRO2dCQUM3QmpHLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFZ0csTUFBTSxDQUFDLEVBQUV6QyxlQUFlMkMsR0FBRyxDQUFDRixRQUFRO2dCQUN2RXBCLGNBQWMsR0FBR29CLE1BQU0sQ0FBQyxFQUFFekMsZUFBZTJDLEdBQUcsQ0FBQ0YsT0FBTyxFQUFFLENBQUM7WUFDekQ7UUFDRjtJQUNGLE9BQU87UUFDTCwrREFBK0Q7UUFDL0RqRyxRQUFRQyxHQUFHLENBQUM7UUFDWjRFLGNBQWM7SUFDaEI7SUFFQSwwQ0FBMEM7SUFDMUM3RSxRQUFRQyxHQUFHLENBQUMsQ0FBQywrQkFBK0IsRUFBRTRFLFlBQVk7SUFFMUQsNkJBQTZCO0lBQzdCM0YsdURBQWdCLENBQUNxRSxlQUFlc0I7SUFDaEM3RSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRXNELGVBQWU7SUFFL0QsOEJBQThCO0lBQzlCLElBQUlyRSxvREFBYSxDQUFDcUUsZ0JBQWdCO1FBQ2hDdkQsUUFBUUMsR0FBRyxDQUFDLENBQUMscUNBQXFDLEVBQUVzRCxlQUFlO1FBQ25FLE9BQU87SUFDVCxPQUFPO1FBQ0x2RCxRQUFRRyxLQUFLLENBQUMsQ0FBQyxpQ0FBaUMsRUFBRW9ELGVBQWU7UUFDakUsT0FBTztJQUNUO0FBQ0Y7QUFFQSxvREFBb0Q7QUFDcEQsZUFBZTZDLHVCQUF1QkMsVUFBVTtJQUM5QyxJQUFJO1FBQ0YsK0RBQStEO1FBQy9ELE1BQU1qRyxhQUFhQyxRQUFRQyxHQUFHLENBQUNDLFdBQVcsSUFBSTtRQUM5QyxNQUFNQyxTQUFTSCxRQUFRQyxHQUFHLENBQUNHLE9BQU8sSUFBSTtRQUV0QyxnREFBZ0Q7UUFDaEQsTUFBTVcsV0FBVyxNQUFNOUIsaURBQUtBLENBQUMsR0FBR2MsV0FBVyxjQUFjLENBQUMsRUFBRTtZQUMxRGlCLFFBQVE7WUFDUkMsU0FBUztnQkFDUCxnQkFBZ0I7Z0JBQ2hCLGFBQWFkO1lBQ2Y7WUFDQWUsTUFBTVksS0FBS2UsU0FBUyxDQUFDO2dCQUNuQm9ELGFBQWFEO2dCQUNiRSxnQkFBZ0I7Z0JBQ2hCQyxtQkFBbUI7Z0JBQ25CQyxXQUFXO2dCQUNYQyxpQkFBaUI7WUFDbkI7UUFDRjtRQUVBLHNDQUFzQztRQUN0QyxJQUFJLENBQUN0RixTQUFTTSxFQUFFLEVBQUU7WUFDaEIsTUFBTUMsWUFBWSxNQUFNUCxTQUFTUSxJQUFJO1lBQ3JDNUIsUUFBUUcsS0FBSyxDQUFDLDZCQUE2QndCO1lBQzNDLE9BQU87Z0JBQUVXLFNBQVM7Z0JBQU9uQyxPQUFPLENBQUMsZUFBZSxFQUFFaUIsU0FBU0ssTUFBTSxDQUFDLENBQUMsRUFBRUwsU0FBU1UsVUFBVSxFQUFFO1lBQUM7UUFDN0Y7UUFFQSxxQkFBcUI7UUFDckIsTUFBTUUsU0FBUyxNQUFNWixTQUFTdUYsSUFBSTtRQUNsQyxPQUFPM0U7SUFDVCxFQUFFLE9BQU83QixPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyx5Q0FBeUNBO1FBQ3ZELE9BQU87WUFBRW1DLFNBQVM7WUFBT25DLE9BQU9BLE1BQU1rQyxPQUFPO1FBQUM7SUFDaEQ7QUFDRjtBQUVBLGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZUFBZXVFLHFCQUFxQlAsVUFBVSxFQUFFdkcsVUFBVSxFQUFFQyxXQUFXLEVBQUU4RyxnQkFBZ0I7SUFDdkYsSUFBSTtRQUNGN0csUUFBUUMsR0FBRyxDQUFDO1FBQ1pELFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlCQUFpQixFQUFFb0csV0FBVy9DLElBQUksQ0FBQyxPQUFPO1FBQ3ZEdEQsUUFBUUMsR0FBRyxDQUFDLENBQUMsbUJBQW1CLEVBQUVILFlBQVk7UUFDOUNFLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG1CQUFtQixFQUFFRixhQUFhO1FBRS9DLHFDQUFxQztRQUNyQyxJQUFJK0csV0FBVztZQUNiQyxZQUFZO1lBQ1pDLFdBQVdYLFdBQVdyRCxNQUFNO1lBQzVCaUUsZUFBZSxFQUFFO1lBQ2pCQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7WUFDakNDLGdCQUFnQixJQUFJRixPQUFPQyxXQUFXO1FBQ3hDO1FBRUEsbUJBQW1CO1FBQ25CLEtBQUssTUFBTXZILGFBQWF3RyxXQUFZO1lBQ2xDLElBQUk7Z0JBQ0ZyRyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxxQkFBcUIsRUFBRUosVUFBVSxJQUFJLENBQUM7Z0JBQ25EaUgsU0FBU0MsVUFBVSxHQUFHbEg7Z0JBQ3RCWCx1REFBZ0IsQ0FBQzJILGtCQUFrQjFFLEtBQUtlLFNBQVMsQ0FBQzRELFVBQVUsTUFBTTtnQkFDbEU5RyxRQUFRQyxHQUFHLENBQUMsQ0FBQyw4QkFBOEIsRUFBRUosV0FBVztnQkFFeEQsdUJBQXVCO2dCQUN2QixNQUFNeUgsZ0JBQWdCbkksZ0RBQVMsQ0FBQ1csWUFBWSxDQUFDLE9BQU8sRUFBRUQsVUFBVSxJQUFJLENBQUM7Z0JBQ3JFLE1BQU0wSCxpQkFBaUJwSSxnREFBUyxDQUFDWSxhQUFhLENBQUMsZUFBZSxFQUFFRixVQUFVLElBQUksQ0FBQztnQkFFL0VHLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDZCQUE2QixFQUFFcUgsZUFBZTtnQkFFM0QsSUFBSXBJLG9EQUFhLENBQUNvSSxnQkFBZ0I7b0JBQ2hDdEgsUUFBUUMsR0FBRyxDQUFDLENBQUMsb0JBQW9CLEVBQUVxSCxlQUFlO29CQUVsRCxJQUFJO3dCQUNGLCtDQUErQzt3QkFDL0N0SCxRQUFRQyxHQUFHLENBQUMsQ0FBQyw2QkFBNkIsRUFBRUosVUFBVSx5QkFBeUIsQ0FBQzt3QkFFaEYsNEZBQTRGO3dCQUM1RixNQUFNb0QsVUFBVSxNQUFNdkQsdUJBQXVCNEgsZUFBZUMsZ0JBQWdCMUgsV0FBV0MsWUFBWUM7d0JBRW5HLElBQUlrRCxTQUFTOzRCQUNYakQsUUFBUUMsR0FBRyxDQUFDLENBQUMsb0VBQW9FLEVBQUVKLFdBQVc7d0JBQ2hHLE9BQU87NEJBQ0xHLFFBQVF3SCxJQUFJLENBQUMsQ0FBQyxxREFBcUQsRUFBRTNILFdBQVc7NEJBRWhGLDhEQUE4RDs0QkFDOUQsSUFBSSxDQUFDWCxvREFBYSxDQUFDcUksaUJBQWlCO2dDQUNsQ3JJLHNEQUFlLENBQUNvSSxlQUFlQztnQ0FDL0J2SCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxpREFBaUQsRUFBRUosV0FBVzs0QkFDN0U7d0JBQ0Y7b0JBQ0YsRUFBRSxPQUFPK0UsS0FBSzt3QkFDWjVFLFFBQVFHLEtBQUssQ0FBQyxDQUFDLHdDQUF3QyxFQUFFTixVQUFVLEVBQUUsRUFBRStFLElBQUl2QyxPQUFPLEVBQUU7d0JBQ3BGckMsUUFBUUcsS0FBSyxDQUFDeUUsSUFBSXpCLEtBQUs7d0JBRXZCLHdDQUF3Qzt3QkFDeENuRCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxrREFBa0QsRUFBRUosV0FBVzt3QkFDNUVYLHNEQUFlLENBQUNvSSxlQUFlQztvQkFDakM7Z0JBQ0YsT0FBTztvQkFDTHZILFFBQVF3SCxJQUFJLENBQUMsQ0FBQyxrQ0FBa0MsRUFBRTNILFVBQVUsRUFBRSxFQUFFeUgsZUFBZTtnQkFDakY7Z0JBRUEsb0NBQW9DO2dCQUNwQyxNQUFNRyxnQkFBZ0J0SSxnREFBUyxDQUFDVyxZQUFZLENBQUMsT0FBTyxFQUFFRCxVQUFVLElBQUksQ0FBQztnQkFDckUsTUFBTTZILGlCQUFpQnZJLGdEQUFTLENBQUNZLGFBQWEsQ0FBQyxlQUFlLEVBQUVGLFVBQVUsSUFBSSxDQUFDO2dCQUUvRUcsUUFBUUMsR0FBRyxDQUFDLENBQUMsNkJBQTZCLEVBQUV3SCxlQUFlO2dCQUMzRCxJQUFJdkksb0RBQWEsQ0FBQ3VJLGdCQUFnQjtvQkFDaEN6SCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQkFBb0IsRUFBRXdILGVBQWU7b0JBQ2xEdkksc0RBQWUsQ0FBQ3VJLGVBQWVDO29CQUMvQjFILFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHdCQUF3QixFQUFFeUgsZ0JBQWdCO2dCQUN6RCxPQUFPO29CQUNMMUgsUUFBUXdILElBQUksQ0FBQyxDQUFDLGtDQUFrQyxFQUFFM0gsV0FBVztnQkFDL0Q7Z0JBRUEsNkVBQTZFO2dCQUM3RSxNQUFNOEgsbUJBQW1CeEksZ0RBQVMsQ0FBQ1ksYUFBYSxDQUFDLGtCQUFrQixFQUFFRixVQUFVLElBQUksQ0FBQztnQkFDcEYsSUFBSSxDQUFDWCxvREFBYSxDQUFDeUksbUJBQW1CO29CQUNwQzNILFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFEQUFxRCxFQUFFSixVQUFVLDBCQUEwQixDQUFDO29CQUN6RyxNQUFNNEMsb0JBQW9CNUMsV0FBVyxNQUFNQyxZQUFZQztnQkFDekQ7Z0JBRUEsa0JBQWtCO2dCQUNsQitHLFNBQVNHLGFBQWEsQ0FBQ1csSUFBSSxDQUFDL0g7Z0JBQzVCaUgsU0FBU08sY0FBYyxHQUFHLElBQUlGLE9BQU9DLFdBQVc7Z0JBQ2hEbEksdURBQWdCLENBQUMySCxrQkFBa0IxRSxLQUFLZSxTQUFTLENBQUM0RCxVQUFVLE1BQU07Z0JBQ2xFOUcsUUFBUUMsR0FBRyxDQUFDLENBQUMsdUJBQXVCLEVBQUVKLFVBQVUsVUFBVSxDQUFDO2dCQUUzRCx1REFBdUQ7Z0JBQ3ZERyxRQUFRQyxHQUFHLENBQUMsQ0FBQywyQ0FBMkMsQ0FBQztnQkFDekQsTUFBTSxJQUFJNEgsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztZQUNuRCxFQUFFLE9BQU9sRCxLQUFLO2dCQUNaNUUsUUFBUUcsS0FBSyxDQUFDLENBQUMsdUJBQXVCLEVBQUVOLFVBQVUsQ0FBQyxDQUFDLEVBQUUrRTtZQUN4RDtRQUNGO1FBRUE1RSxRQUFRQyxHQUFHLENBQUM7UUFDWkQsUUFBUUMsR0FBRyxDQUFDLENBQUMsc0JBQXNCLEVBQUU2RyxTQUFTRyxhQUFhLENBQUNqRSxNQUFNLENBQUMsQ0FBQyxFQUFFOEQsU0FBU0UsU0FBUyxFQUFFO1FBRTFGLE9BQU87WUFBRTFFLFNBQVM7UUFBSztJQUN6QixFQUFFLE9BQU9uQyxPQUFPO1FBQ2RILFFBQVFHLEtBQUssQ0FBQyxpQ0FBaUNBO1FBQy9DLE9BQU87WUFBRW1DLFNBQVM7WUFBT25DLE9BQU9BLE1BQU1rQyxPQUFPO1FBQUM7SUFDaEQ7QUFDRjtBQUVBLDBDQUEwQztBQUMxQyxlQUFlMkYsa0JBQWtCbEksVUFBVSxFQUFFQyxXQUFXLEVBQUVGLFNBQVM7SUFDakUsMkNBQTJDO0lBQzNDLE1BQU1vSSxpQkFBaUI7UUFDckIsQ0FBQyxXQUFXLEVBQUVwSSxVQUFVLElBQUksQ0FBQztRQUM3QixDQUFDLFVBQVUsRUFBRUEsVUFBVSxJQUFJLENBQUM7S0FDN0I7SUFFRCxJQUFJcUksYUFBYTtJQUNqQixLQUFLLE1BQU1DLGlCQUFpQkYsZUFBZ0I7UUFDMUMsTUFBTUcsZUFBZWpKLGdEQUFTLENBQUNXLFlBQVlxSTtRQUMzQ25JLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLCtCQUErQixFQUFFbUksY0FBYztRQUU1RCxJQUFJbEosb0RBQWEsQ0FBQ2tKLGVBQWU7WUFDL0JwSSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxzQkFBc0IsRUFBRW1JLGNBQWM7WUFDbkRGLGFBQWE7WUFFYixxRUFBcUU7WUFDckUsTUFBTUcsZUFBZSx1QkFBdUJ4SSxZQUFZO1lBQ3hELE1BQU0wRCxnQkFBZ0JwRSxnREFBUyxDQUFDWSxhQUFhc0k7WUFFN0NySSxRQUFRQyxHQUFHLENBQUMsQ0FBQywyQkFBMkIsRUFBRXNELGVBQWU7WUFDekRyRSxzREFBZSxDQUFDa0osY0FBYzdFO1lBRTlCLDZCQUE2QjtZQUM3QixJQUFJckUsb0RBQWEsQ0FBQ3FFLGdCQUFnQjtnQkFDaEN2RCxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQ0FBb0MsQ0FBQztnQkFFbEQseUJBQXlCO2dCQUN6QixJQUFJO29CQUNGLE1BQU00RCxVQUFVM0Usc0RBQWUsQ0FBQ3FFLGVBQWU7b0JBQy9DLE1BQU1VLFlBQVlKLFFBQVFHLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtvQkFDeENoRSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQ0FBb0MsRUFBRWdFLFdBQVc7Z0JBQ2hFLEVBQUUsT0FBT3FFLFNBQVM7b0JBQ2hCdEksUUFBUUcsS0FBSyxDQUFDLENBQUMsOEJBQThCLEVBQUVtSSxRQUFRakcsT0FBTyxFQUFFO2dCQUNsRTtZQUNGLE9BQU87Z0JBQ0xyQyxRQUFRRyxLQUFLLENBQUMsQ0FBQyw2REFBNkQsQ0FBQztZQUMvRTtZQUVBLE9BQU8sa0VBQWtFO1FBQzNFO0lBQ0Y7SUFFQSxJQUFJLENBQUMrSCxZQUFZO1FBQ2ZsSSxRQUFRQyxHQUFHLENBQUMsQ0FBQyxvQ0FBb0MsRUFBRUosV0FBVztRQUU5RCxnREFBZ0Q7UUFDaEQsTUFBTTBELGdCQUFnQnBFLGdEQUFTLENBQUNZLGFBQWEsQ0FBQyxrQkFBa0IsRUFBRUYsVUFBVSxJQUFJLENBQUM7UUFDakYsTUFBTTBJLGVBQWU7UUFDckJySix1REFBZ0IsQ0FBQ3FFLGVBQWVnRjtRQUNoQ3ZJLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLGlDQUFpQyxFQUFFc0QsZUFBZTtJQUNqRTtBQUNGO0FBRUEsZ0NBQWdDO0FBQ2pCLGVBQWVpRixRQUFRQyxHQUFHLEVBQUVDLEdBQUc7SUFDNUMsZ0RBQWdEO0lBQ2hELElBQUlELElBQUlwSCxNQUFNLEtBQUssT0FBTztRQUN4QixJQUFJO1lBQ0YsTUFBTXNILGVBQWV4SixnREFBUyxDQUFDa0IsUUFBUXVJLEdBQUcsSUFBSSxVQUFVLFlBQVk7WUFDcEUsTUFBTTdJLGNBQWNaLGdEQUFTLENBQUNrQixRQUFRdUksR0FBRyxJQUFJLFVBQVUsWUFBWTtZQUVuRSxnREFBZ0Q7WUFDaEQsSUFBSSxDQUFDMUosb0RBQWEsQ0FBQ0MsZ0RBQVMsQ0FBQ2tCLFFBQVF1SSxHQUFHLElBQUksVUFBVSxjQUFjO2dCQUNsRTFKLG1EQUFZLENBQUNDLGdEQUFTLENBQUNrQixRQUFRdUksR0FBRyxJQUFJLFVBQVUsYUFBYTtvQkFBRUUsV0FBVztnQkFBSztZQUNqRjtZQUVBLCtDQUErQztZQUMvQyxJQUFJLENBQUM1SixvREFBYSxDQUFDeUosZUFBZTtnQkFDaEN6SixtREFBWSxDQUFDeUosY0FBYztvQkFBRUcsV0FBVztnQkFBSztZQUMvQztZQUVBLCtDQUErQztZQUMvQyxJQUFJLENBQUM1SixvREFBYSxDQUFDYSxjQUFjO2dCQUMvQmIsbURBQVksQ0FBQ2EsYUFBYTtvQkFBRStJLFdBQVc7Z0JBQUs7WUFDOUM7WUFFQSxpRkFBaUY7WUFDakYsTUFBTUMsZUFBZTVKLGdEQUFTLENBQUNrQixRQUFRdUksR0FBRyxJQUFJLFVBQVUsWUFBWTtZQUNwRSxNQUFNSSxlQUFlOUosb0RBQWEsQ0FBQzZKO1lBRW5DLHNDQUFzQztZQUN0QyxNQUFNbEMsbUJBQW1CMUgsZ0RBQVMsQ0FBQ2tCLFFBQVF1SSxHQUFHLElBQUksVUFBVSxZQUFZO1lBQ3hFLElBQUlLLGVBQWU7Z0JBQ2pCbEMsWUFBWTtnQkFDWkMsV0FBVztnQkFDWEMsZUFBZSxFQUFFO2dCQUNqQkMsV0FBVztnQkFDWEcsZ0JBQWdCO1lBQ2xCO1lBRUEsSUFBSW5JLG9EQUFhLENBQUMySCxtQkFBbUI7Z0JBQ25DLElBQUk7b0JBQ0YsTUFBTXFDLGVBQWVoSyxzREFBZSxDQUFDMkgsa0JBQWtCO29CQUN2RG9DLGVBQWU5RyxLQUFLQyxLQUFLLENBQUM4RztnQkFDNUIsRUFBRSxPQUFPdEUsS0FBSztvQkFDWjVFLFFBQVFHLEtBQUssQ0FBQyxnQ0FBZ0N5RTtnQkFDaEQ7WUFDRjtZQUVBLGdDQUFnQztZQUNoQyxNQUFNdUUsZUFBZWpLLG9EQUFhLENBQUN5SixnQkFDL0J6SixxREFBYyxDQUFDeUosY0FBY1UsTUFBTSxDQUFDQyxDQUFBQSxPQUNsQ0EsS0FBS0MsVUFBVSxDQUFDLGNBQWNELEtBQUtFLFFBQVEsQ0FBQyxTQUFTeEcsTUFBTSxHQUM3RDtZQUVKLE1BQU15RyxlQUFldkssb0RBQWEsQ0FBQ2EsZUFDL0JiLHFEQUFjLENBQUNhLGFBQWFzSixNQUFNLENBQUNDLENBQUFBLE9BQ2pDQSxLQUFLQyxVQUFVLENBQUMsc0JBQXNCRCxLQUFLRSxRQUFRLENBQUMsU0FBU3hHLE1BQU0sR0FDckU7WUFFSixPQUFPMEYsSUFBSWpILE1BQU0sQ0FBQyxLQUFLa0YsSUFBSSxDQUFDO2dCQUMxQnJFLFNBQVM7Z0JBQ1QwRztnQkFDQVUsY0FBY1A7Z0JBQ2RRLGNBQWNGO2dCQUNkRyxpQkFBaUJULGVBQWVNO2dCQUNoQzNDLFVBQVVtQztZQUNaO1FBQ0YsRUFBRSxPQUFPOUksT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsa0NBQWtDQTtZQUNoRCxPQUFPdUksSUFBSWpILE1BQU0sQ0FBQyxLQUFLa0YsSUFBSSxDQUFDO2dCQUMxQnJFLFNBQVM7Z0JBQ1RuQyxPQUFPQSxNQUFNa0MsT0FBTztZQUN0QjtRQUNGO0lBQ0YsT0FFSyxJQUFJb0csSUFBSXBILE1BQU0sS0FBSyxRQUFRO1FBQzlCLElBQUk7WUFDRixpREFBaUQ7WUFDakQsTUFBTSxFQUFFZ0YsVUFBVSxFQUFFLEdBQUdvQyxJQUFJbEgsSUFBSTtZQUUvQixJQUFJLENBQUM4RSxjQUFjLENBQUN3RCxNQUFNQyxPQUFPLENBQUN6RCxlQUFlQSxXQUFXckQsTUFBTSxLQUFLLEdBQUc7Z0JBQ3hFLE9BQU8wRixJQUFJakgsTUFBTSxDQUFDLEtBQUtrRixJQUFJLENBQUM7b0JBQzFCckUsU0FBUztvQkFDVG5DLE9BQU87Z0JBQ1Q7WUFDRjtZQUVBLCtEQUErRDtZQUMvRCxNQUFNNEosY0FBYzVLLGdEQUFTLENBQUNrQixRQUFRdUksR0FBRyxJQUFJLFVBQVU7WUFDdkQsSUFBSSxDQUFDMUosb0RBQWEsQ0FBQzZLLGNBQWM7Z0JBQy9CN0ssbURBQVksQ0FBQzZLLGFBQWE7b0JBQUVqQixXQUFXO2dCQUFLO1lBQzlDO1lBRUEsK0NBQStDO1lBQy9DLE1BQU0vSSxjQUFjWixnREFBUyxDQUFDa0IsUUFBUXVJLEdBQUcsSUFBSSxVQUFVLFlBQVk7WUFDbkUsSUFBSSxDQUFDMUosb0RBQWEsQ0FBQ2EsY0FBYztnQkFDL0JiLG1EQUFZLENBQUNhLGFBQWE7b0JBQUUrSSxXQUFXO2dCQUFLO1lBQzlDO1lBRUEsdUNBQXVDO1lBQ3ZDLE1BQU1DLGVBQWU1SixnREFBUyxDQUFDNEssYUFBYTtZQUM1QyxJQUFJN0ssb0RBQWEsQ0FBQzZKLGVBQWU7Z0JBQy9CLE9BQU9MLElBQUlqSCxNQUFNLENBQUMsS0FBS2tGLElBQUksQ0FBQztvQkFDMUJyRSxTQUFTO29CQUNUbkMsT0FBTztnQkFDVDtZQUNGO1lBRUEseURBQXlEO1lBQ3pELElBQUk7Z0JBQ0ZqQix1REFBZ0IsQ0FBQzZKLGNBQWMsSUFBSTVCLE9BQU9DLFdBQVc7Z0JBQ3JEcEgsUUFBUUMsR0FBRyxDQUFDLENBQUMscUJBQXFCLEVBQUU4SSxjQUFjO1lBQ3BELEVBQUUsT0FBT25FLEtBQUs7Z0JBQ1o1RSxRQUFRRyxLQUFLLENBQUMsQ0FBQywwQkFBMEIsRUFBRXlFLElBQUl2QyxPQUFPLEVBQUU7Z0JBQ3hELE9BQU9xRyxJQUFJakgsTUFBTSxDQUFDLEtBQUtrRixJQUFJLENBQUM7b0JBQzFCckUsU0FBUztvQkFDVG5DLE9BQU8sQ0FBQyw0QkFBNEIsRUFBRXlFLElBQUl2QyxPQUFPLEVBQUU7Z0JBQ3JEO1lBQ0Y7WUFFQSwrQkFBK0I7WUFDL0IsTUFBTXdFLG1CQUFtQjFILGdEQUFTLENBQUM0SyxhQUFhO1lBQ2hELE1BQU1kLGVBQWU7Z0JBQ25CbEMsWUFBWTtnQkFDWkMsV0FBV1gsV0FBV3JELE1BQU07Z0JBQzVCaUUsZUFBZSxFQUFFO2dCQUNqQkMsV0FBVyxJQUFJQyxPQUFPQyxXQUFXO2dCQUNqQ0MsZ0JBQWdCLElBQUlGLE9BQU9DLFdBQVc7WUFDeEM7WUFFQSxJQUFJO2dCQUNGbEksdURBQWdCLENBQUMySCxrQkFBa0IxRSxLQUFLZSxTQUFTLENBQUMrRixjQUFjLE1BQU07WUFDeEUsRUFBRSxPQUFPckUsS0FBSztnQkFDWjVFLFFBQVFHLEtBQUssQ0FBQyxDQUFDLDhCQUE4QixFQUFFeUUsSUFBSXZDLE9BQU8sRUFBRTtZQUM5RDtZQUVBLDhCQUE4QjtZQUM5QixNQUFNdkMsYUFBYVgsZ0RBQVMsQ0FBQ2tCLFFBQVF1SSxHQUFHLElBQUksVUFBVSxZQUFZO1lBRWxFLDJDQUEyQztZQUMzQyxNQUFNb0IsYUFBYTNKLFFBQVFDLEdBQUcsQ0FBQzJKLGtCQUFrQixLQUFLO1lBRXRELElBQUlELFlBQVk7Z0JBQ2RoSyxRQUFRQyxHQUFHLENBQUMsQ0FBQywrQkFBK0IsRUFBRW9HLFdBQVdyRCxNQUFNLENBQUMsUUFBUSxDQUFDO2dCQUV6RSwyQ0FBMkM7Z0JBQzNDb0QsdUJBQXVCQyxZQUNwQjZELElBQUksQ0FBQ2xJLENBQUFBO29CQUNKaEMsUUFBUUMsR0FBRyxDQUFDLDZDQUE2QytCO29CQUN6RCxtQ0FBbUM7b0JBQ25DLElBQUk5QyxvREFBYSxDQUFDNkosZUFBZTt3QkFDL0I3SixvREFBYSxDQUFDNko7b0JBQ2hCO2dCQUNGLEdBQ0NxQixLQUFLLENBQUN4RixDQUFBQTtvQkFDTDVFLFFBQVFHLEtBQUssQ0FBQyw4QkFBOEJ5RTtvQkFDNUMsa0NBQWtDO29CQUNsQyxJQUFJMUYsb0RBQWEsQ0FBQzZKLGVBQWU7d0JBQy9CN0osb0RBQWEsQ0FBQzZKO29CQUNoQjtnQkFDRjtnQkFFRixPQUFPTCxJQUFJakgsTUFBTSxDQUFDLEtBQUtrRixJQUFJLENBQUM7b0JBQzFCckUsU0FBUztvQkFDVEQsU0FBUztvQkFDVGdJLGVBQWVoRSxXQUFXckQsTUFBTTtvQkFDaENzSCxrQkFBa0I7Z0JBQ3BCO1lBQ0YsT0FBTztnQkFDTHRLLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDhCQUE4QixFQUFFb0csV0FBV3JELE1BQU0sQ0FBQyxRQUFRLENBQUM7Z0JBRXhFLHFFQUFxRTtnQkFDckU0RCxxQkFBcUJQLFlBQVl2RyxZQUFZQyxhQUFhOEcsa0JBQ3ZEcUQsSUFBSSxDQUFDbEksQ0FBQUE7b0JBQ0poQyxRQUFRQyxHQUFHLENBQUMscUNBQXFDK0I7b0JBQ2pELG1DQUFtQztvQkFDbkMsSUFBSTlDLG9EQUFhLENBQUM2SixlQUFlO3dCQUMvQjdKLG9EQUFhLENBQUM2SjtvQkFDaEI7Z0JBQ0YsR0FDQ3FCLEtBQUssQ0FBQ3hGLENBQUFBO29CQUNMNUUsUUFBUUcsS0FBSyxDQUFDLHNCQUFzQnlFO29CQUNwQyxrQ0FBa0M7b0JBQ2xDLElBQUkxRixvREFBYSxDQUFDNkosZUFBZTt3QkFDL0I3SixvREFBYSxDQUFDNko7b0JBQ2hCO2dCQUNGO2dCQUVGLE9BQU9MLElBQUlqSCxNQUFNLENBQUMsS0FBS2tGLElBQUksQ0FBQztvQkFDMUJyRSxTQUFTO29CQUNURCxTQUFTO29CQUNUZ0ksZUFBZWhFLFdBQVdyRCxNQUFNO29CQUNoQ3NILGtCQUFrQjtnQkFDcEI7WUFDRjtRQUNGLEVBQUUsT0FBT25LLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLGdDQUFnQ0E7WUFFOUMseURBQXlEO1lBQ3pELE1BQU00SSxlQUFlNUosZ0RBQVMsQ0FBQ2tCLFFBQVF1SSxHQUFHLElBQUksVUFBVSxZQUFZO1lBQ3BFLElBQUkxSixvREFBYSxDQUFDNkosZUFBZTtnQkFDL0IsSUFBSTtvQkFDRjdKLG9EQUFhLENBQUM2SjtnQkFDaEIsRUFBRSxPQUFPbEgsR0FBRztvQkFDVjdCLFFBQVFHLEtBQUssQ0FBQyw2QkFBNkIwQjtnQkFDN0M7WUFDRjtZQUVBLE9BQU82RyxJQUFJakgsTUFBTSxDQUFDLEtBQUtrRixJQUFJLENBQUM7Z0JBQzFCckUsU0FBUztnQkFDVG5DLE9BQU9BLE1BQU1rQyxPQUFPO1lBQ3RCO1FBQ0Y7SUFDRixPQUNLO1FBQ0gsT0FBT3FHLElBQUlqSCxNQUFNLENBQUMsS0FBS2tGLElBQUksQ0FBQztZQUMxQnJFLFNBQVM7WUFDVG5DLE9BQU87UUFDVDtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9hcGkvZm9yLXByb2Nlc3MtZm9sZGVyL3Byb2Nlc3Mtc3RhdHVzLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWdlcy9hcGkvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzIC0gQVBJIHRvIGhhbmRsZSBwcm9jZXNzIHN0YXR1cyBjaGVja3MgYW5kIHRyaWdnZXJzXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJztcbmltcG9ydCBmZXRjaCBmcm9tICdub2RlLWZldGNoJztcbmltcG9ydCBGb3JtRGF0YSBmcm9tICdmb3JtLWRhdGEnO1xuXG4vLyBDb252ZXJ0IGV4ZWMgdG8gUHJvbWlzZS1iYXNlZFxuY29uc3QgZXhlY1Byb21pc2UgPSB1dGlsLnByb21pc2lmeShleGVjKTtcblxuLy8gVXBkYXRlZCBmdW5jdGlvbiB0byBwcm9wZXJseSBoYW5kbGUgaW1hZ2UgcHJvY2Vzc2luZyB3aXRoIHByb3BlciBkaW1lbnNpb24gcmV0ZW50aW9uXG4vLyBGdW5jdGlvbiB0byBzZW5kIGEgc2luZ2xlIGltYWdlIHRvIHRoZSBQeXRob24gYmFja2VuZCBmb3IgcHJvY2Vzc2luZ1xuLy8gTW9kaWZpZWQgZnVuY3Rpb24gdG8gcHJlc2VydmUgb3JpZ2luYWwgcGFyYW1ldGVyIGRhdGEgYW5kIGFkZCBuZXcgbWV0cmljc1xuLy8gRml4ZWQgZnVuY3Rpb24gdG8gcHJvcGVybHkgcHJvY2VzcyB3ZWJjYW0gaW1hZ2VzIHRocm91Z2ggdGhlIFB5dGhvbiBiYWNrZW5kXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uKGlucHV0UGF0aCwgb3V0cHV0UGF0aCwgc2V0TnVtYmVyLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyB0byBwcm9jZXNzIGltYWdlOiAke2lucHV0UGF0aH1gKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBpbnB1dCBmaWxlIGV4aXN0c1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhpbnB1dFBhdGgpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBJbnB1dCBmaWxlIGRvZXMgbm90IGV4aXN0OiAke2lucHV0UGF0aH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGJhY2tlbmQgVVJMXG4gICAgY29uc3QgYmFja2VuZFVybCA9IHByb2Nlc3MuZW52LkJBQ0tFTkRfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVic7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGZvcm0gZGF0YVxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgXG4gICAgLy8gT3BlbiB0aGUgZmlsZSBhcyBhIHN0cmVhbVxuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGlucHV0UGF0aCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSBmaWxlIHNpemVcbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGlucHV0UGF0aCk7XG4gICAgY29uc29sZS5sb2coYEZpbGUgc2l6ZTogJHtzdGF0cy5zaXplfSBieXRlc2ApO1xuICAgIFxuICAgIC8vIEFkZCBmaWxlIHRvIGZvcm0gZGF0YVxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGVTdHJlYW0sIHtcbiAgICAgIGZpbGVuYW1lOiBwYXRoLmJhc2VuYW1lKGlucHV0UGF0aCksXG4gICAgICBjb250ZW50VHlwZTogJ2ltYWdlL2pwZWcnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWRkIHByb2Nlc3NpbmcgcGFyYW1ldGVycyAtIHRoZXNlIG11c3QgbWF0Y2ggdGhlIEZhc3RBUEkgYmFja2VuZCBleHBlY3RhdGlvbnNcbiAgICAvLyBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dIZWFkUG9zZScsICdmYWxzZScpO1xuICAgIC8vIGZvcm1EYXRhLmFwcGVuZCgnc2hvd0JvdW5kaW5nQm94JywgJ3RydWUnKTtcbiAgICAvLyBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dNYXNrJywgJ2ZhbHNlJyk7XG4gICAgLy8gZm9ybURhdGEuYXBwZW5kKCdzaG93UGFyYW1ldGVycycsICd0cnVlJyk7XG5cbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dIZWFkUG9zZScsICdmYWxzZScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd0JvdW5kaW5nQm94JywgJ2ZhbHNlJyk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdzaG93TWFzaycsICdmYWxzZScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd1BhcmFtZXRlcnMnLCAnZmFsc2UnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgU2VuZGluZyAke2lucHV0UGF0aH0gdG8gUHl0aG9uIGJhY2tlbmQgYXQgJHtiYWNrZW5kVXJsfS9wcm9jZXNzLWltYWdlYCk7XG4gICAgXG4gICAgLy8gTG9nIHJlcXVlc3QgZGV0YWlscyBmb3IgZGVidWdnaW5nXG4gICAgY29uc29sZS5sb2coJ0FQSSBLZXkgYmVpbmcgdXNlZDonLCBhcGlLZXkpO1xuICAgIGNvbnNvbGUubG9nKCdGb3JtIGRhdGEgcGFyYW1ldGVyczonLCBcbiAgICAgICAgICAgICAgICdzaG93SGVhZFBvc2U9dHJ1ZScsIFxuICAgICAgICAgICAgICAgJ3Nob3dCb3VuZGluZ0JveD10cnVlJywgXG4gICAgICAgICAgICAgICAnc2hvd01hc2s9ZmFsc2UnLCBcbiAgICAgICAgICAgICAgICdzaG93UGFyYW1ldGVycz10cnVlJyk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgUHl0aG9uIGJhY2tlbmRcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke2JhY2tlbmRVcmx9L3Byb2Nlc3MtaW1hZ2VgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ1gtQVBJLUtleSc6IGFwaUtleVxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgdGltZW91dDogMzAwMDAgLy8gMzAgc2Vjb25kIHRpbWVvdXQgZm9yIHByb2Nlc3NpbmcgbGFyZ2UgaW1hZ2VzXG4gICAgfSk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSByZXNwb25zZSBzdGF0dXNcbiAgICBjb25zb2xlLmxvZyhgQmFja2VuZCByZXNwb25zZSBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvclRleHQgPSAnJztcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JUZXh0ID0gJ0NvdWxkIG5vdCByZWFkIGVycm9yIGRldGFpbHMnO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmVycm9yKGBCYWNrZW5kIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgY29uc29sZS5lcnJvcihgUmVzcG9uc2UgYm9keTogJHtlcnJvclRleHR9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhY2tlbmQgcmV0dXJuZWQgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSBhcyBKU09OXG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5sb2coYFJlc3BvbnNlIHRleHQgKGZpcnN0IDIwMCBjaGFycyk6ICR7cmVzcG9uc2VUZXh0LnN1YnN0cmluZygwLCAyMDApfS4uLmApO1xuICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIHJlc3BvbnNlIEpTT046JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgYmFja2VuZCByZXNwb25zZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBMb2cgcmVzdWx0IHN0YXR1c1xuICAgIGNvbnNvbGUubG9nKCdCYWNrZW5kIHByb2Nlc3NpbmcgcmVzdWx0OicsIHJlc3VsdC5zdWNjZXNzID8gJ1N1Y2Nlc3MnIDogJ0ZhaWxlZCcpO1xuICAgIFxuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgLy8gQ2hlY2sgaWYgYSBmYWNlIHdhcyBkZXRlY3RlZFxuICAgICAgaWYgKHJlc3VsdC5mYWNlX2RldGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gZmFjZSBkZXRlY3RlZCBpbiB0aGUgaW1hZ2UgLSBzYXZpbmcgb3JpZ2luYWwgaW1hZ2UnKTtcbiAgICAgICAgZnMuY29weUZpbGVTeW5jKGlucHV0UGF0aCwgb3V0cHV0UGF0aCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGlsbCB1cGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCB0aGlzIGluZm9ybWF0aW9uXG4gICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCB7IGZhY2VfZGV0ZWN0ZWQ6IGZhbHNlIH0sIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBWZXJpZnkgd2UgaGF2ZSB0aGUgcHJvY2Vzc2VkIGltYWdlIGRhdGFcbiAgICAgIGlmICghcmVzdWx0LmltYWdlIHx8ICFyZXN1bHQuaW1hZ2UuZGF0YSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdCYWNrZW5kIHJlc3BvbnNlIG1pc3NpbmcgaW1hZ2UgZGF0YScpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgIGZzLmNvcHlGaWxlU3luYyhpbnB1dFBhdGgsIG91dHB1dFBhdGgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIGltYWdlIGFzIGZhbGxiYWNrIHRvOiAke291dHB1dFBhdGh9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBtaW5pbWFsIGluZm9cbiAgICAgICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIHsgZmFjZV9kZXRlY3RlZDogZmFsc2UgfSwgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNhdmUgdGhlIHByb2Nlc3NlZCBpbWFnZVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW1hZ2VCdWZmZXIgPSBCdWZmZXIuZnJvbShyZXN1bHQuaW1hZ2UuZGF0YSwgJ2Jhc2U2NCcpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGltYWdlQnVmZmVyKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHByb2Nlc3NlZCBpbWFnZSB0byAke291dHB1dFBhdGh9LCBzaXplOiAke2ltYWdlQnVmZmVyLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyBwcm9jZXNzZWQgaW1hZ2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgICBmcy5jb3B5RmlsZVN5bmMoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICAgICAgY29uc29sZS5sb2coYENvcGllZCBvcmlnaW5hbCBpbWFnZSBhcyBmYWxsYmFjayB0bzogJHtvdXRwdXRQYXRofWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgbWV0cmljcyBpbiB0aGUgcmVzcG9uc2VcbiAgICAgIGlmIChyZXN1bHQubWV0cmljcykge1xuICAgICAgICBjb25zb2xlLmxvZygnTWV0cmljcyByZWNlaXZlZCBmcm9tIGJhY2tlbmQ6JywgSlNPTi5zdHJpbmdpZnkocmVzdWx0Lm1ldHJpY3MpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwYXJhbWV0ZXIgZmlsZSB3aXRoIHRoZSBtZXRyaWNzXG4gICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCByZXN1bHQubWV0cmljcywgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5tZXRyaWNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIG1ldHJpY3MgcmVjZWl2ZWQgZnJvbSBiYWNrZW5kLCB1c2luZyBmYWNlX2RldGVjdGVkIHN0YXR1cyBvbmx5Jyk7XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBqdXN0IHRoZSBmYWNlIGRldGVjdGlvbiBzdGF0dXNcbiAgICAgICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIHsgZmFjZV9kZXRlY3RlZDogdHJ1ZSB9LCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4geyBmYWNlX2RldGVjdGVkOiB0cnVlIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEJhY2tlbmQgcHJvY2Vzc2luZyBmYWlsZWQ6ICR7cmVzdWx0LmVycm9yIHx8ICdVbmtub3duIGVycm9yJ31gKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICBmcy5jb3B5RmlsZVN5bmMoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDb3BpZWQgb3JpZ2luYWwgaW1hZ2UgYXMgZmFsbGJhY2sgdG86ICR7b3V0cHV0UGF0aH1gKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHBhcmFtZXRlciBmaWxlIHdpdGggZXJyb3IgaW5mb3JtYXRpb25cbiAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBudWxsLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICBcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGltYWdlIHdpdGggUHl0aG9uIGJhY2tlbmQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yLnN0YWNrKTtcbiAgICBcbiAgICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICB0cnkge1xuICAgICAgZnMuY29weUZpbGVTeW5jKGlucHV0UGF0aCwgb3V0cHV0UGF0aCk7XG4gICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIGltYWdlIGFzIGZhbGxiYWNrIGFmdGVyIGVycm9yOiAke291dHB1dFBhdGh9YCk7XG4gICAgfSBjYXRjaCAoY29weUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjb3B5aW5nIG9yaWdpbmFsIGltYWdlOiAke2NvcHlFcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBlcnJvciBpbmZvcm1hdGlvblxuICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBudWxsLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbi8vIE5ldyBmdW5jdGlvbiB0byB1cGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBuZXcgbWV0cmljcyB3aGlsZSBwcmVzZXJ2aW5nIG9yaWdpbmFsIGRhdGFcbi8vIFVwZGF0ZWQgZnVuY3Rpb24gdG8gcHJvcGVybHkgaGFuZGxlIHBhcmFtZXRlciBmaWxlIHVwZGF0ZXNcbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBtZXRyaWNzLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCkge1xuICBjb25zb2xlLmxvZyhgVXBkYXRpbmcgcGFyYW1ldGVyIGZpbGUgZm9yIHNldCAke3NldE51bWJlcn0gd2l0aCBuZXcgbWV0cmljc2ApO1xuICBcbiAgLy8gRGV0ZXJtaW5lIHBhcmFtZXRlciBmaWxlIHBhdGhzXG4gIGNvbnN0IG9yaWdpbmFsUGFyYW1QYXRocyA9IFtcbiAgICBwYXRoLmpvaW4oY2FwdHVyZURpciwgYHBhcmFtZXRlcnNfJHtzZXROdW1iZXJ9LmNzdmApLFxuICAgIHBhdGguam9pbihjYXB0dXJlRGlyLCBgcGFyYW1ldGVyXyR7c2V0TnVtYmVyfS5jc3ZgKVxuICBdO1xuICBcbiAgLy8gT3V0cHV0IHBhcmFtZXRlciBmaWxlIHBhdGhcbiAgY29uc3QgcGFyYW1EZXN0UGF0aCA9IHBhdGguam9pbihlbmhhbmNlUGF0aCwgYHBhcmFtZXRlcl9lbmhhbmNlXyR7c2V0TnVtYmVyfS5jc3ZgKTtcbiAgXG4gIC8vIExvYWQgb3JpZ2luYWwgcGFyYW1ldGVyIGRhdGEgaWYgYXZhaWxhYmxlXG4gIGxldCBvcmlnaW5hbFBhcmFtcyA9IG5ldyBNYXAoKTtcbiAgbGV0IG9yaWdpbmFsUGFyYW1Gb3VuZCA9IGZhbHNlO1xuICBsZXQgb3JpZ2luYWxGaXJzdExpbmVJc0hlYWRlciA9IGZhbHNlO1xuICBcbiAgZm9yIChjb25zdCBvcmlnaW5hbFBhdGggb2Ygb3JpZ2luYWxQYXJhbVBhdGhzKSB7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMob3JpZ2luYWxQYXRoKSkge1xuICAgICAgY29uc29sZS5sb2coYEZvdW5kIG9yaWdpbmFsIHBhcmFtZXRlciBmaWxlOiAke29yaWdpbmFsUGF0aH1gKTtcbiAgICAgIG9yaWdpbmFsUGFyYW1Gb3VuZCA9IHRydWU7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMob3JpZ2luYWxQYXRoLCAndXRmOCcpO1xuICAgICAgICBjb25zb2xlLmxvZyhgT3JpZ2luYWwgcGFyYW1ldGVyIGZpbGUgY29udGVudDogJHtjb250ZW50LnN1YnN0cmluZygwLCAxMDApfS4uLmApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBsaW5lIGlzIGEgaGVhZGVyXG4gICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGxpbmVzWzBdLnRyaW0oKTtcbiAgICAgICAgb3JpZ2luYWxGaXJzdExpbmVJc0hlYWRlciA9IGZpcnN0TGluZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdwYXJhbWV0ZXInKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RMaW5lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ25hbWUnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNraXAgaGVhZGVyIGxpbmUgaWYgaXQgZXhpc3RzXG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IG9yaWdpbmFsRmlyc3RMaW5lSXNIZWFkZXIgPyAxIDogMDtcbiAgICAgICAgXG4gICAgICAgIC8vIFBhcnNlIHRoZSBvcmlnaW5hbCBwYXJhbWV0ZXJzXG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmU7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXS50cmltKCk7XG4gICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcmFtTmFtZSA9IHBhcnRzWzBdLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgcGFyYW1WYWx1ZSA9IHBhcnRzWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgb3JpZ2luYWxQYXJhbXMuc2V0KHBhcmFtTmFtZSwgcGFyYW1WYWx1ZSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgcGFyYW1ldGVyOiAke3BhcmFtTmFtZX09JHtwYXJhbVZhbHVlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYExvYWRlZCAke29yaWdpbmFsUGFyYW1zLnNpemV9IHBhcmFtZXRlcnMgZnJvbSBvcmlnaW5hbCBmaWxlYCk7XG4gICAgICAgIGJyZWFrOyAvLyBGb3VuZCBhbmQgbG9hZGVkIG9uZSBwYXJhbWV0ZXIgZmlsZSwgbm8gbmVlZCB0byBjaGVjayB0aGUgb3RoZXJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciByZWFkaW5nIG9yaWdpbmFsIHBhcmFtZXRlciBmaWxlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgLy8gUHJlcGFyZSBDU1YgY29udGVudCB3aXRoIGhlYWRlclxuICBsZXQgY3N2Q29udGVudCA9ICdQYXJhbWV0ZXIsVmFsdWVcXG4nO1xuICBcbiAgLy8gQWRkIG9yaWdpbmFsIHBhcmFtZXRlcnMgZmlyc3QgKGV4Y2VwdCB0aG9zZSB3ZSdsbCB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzKVxuICBjb25zdCBleGNsdWRlUGFyYW1zID0gWydwaXRjaCcsICd5YXcnLCAncm9sbCcsICdmYWNlX3dpZHRoJywgJ2ZhY2VfaGVpZ2h0JywgXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2xlZnRfZXllX3gnLCAnbGVmdF9leWVfeScsICdyaWdodF9leWVfeCcsICdyaWdodF9leWVfeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ2ZhY2VfYm94X21pbl94JywgJ2ZhY2VfYm94X21pbl95JywgJ2ZhY2VfYm94X21heF94JywgJ2ZhY2VfYm94X21heF95J107XG4gIFxuICAvLyBMb2cgYWxsIG9yaWdpbmFsIHBhcmFtZXRlcnMgZm9yIGRlYnVnZ2luZ1xuICBjb25zb2xlLmxvZyhcIk9yaWdpbmFsIHBhcmFtZXRlcnM6XCIpO1xuICBvcmlnaW5hbFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgY29uc29sZS5sb2coYCAgJHtrZXl9OiAke3ZhbHVlfWApO1xuICB9KTtcbiAgXG4gIC8vIEFkZCBleGlzdGluZyBwYXJhbWV0ZXJzIChleGNlcHQgdGhvc2Ugd2UnbGwgdXBkYXRlKVxuICBvcmlnaW5hbFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKCFleGNsdWRlUGFyYW1zLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgY3N2Q29udGVudCArPSBgJHtrZXl9LCR7dmFsdWV9XFxuYDtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gTm93IGFkZCB0aGUgbmV3IG1ldHJpY3NcbiAgaWYgKG1ldHJpY3MgJiYgbWV0cmljcy5mYWNlX2RldGVjdGVkICE9PSBmYWxzZSkge1xuICAgIGNvbnNvbGUubG9nKFwiQWRkaW5nIG5ldyBtZXRyaWNzIGZyb20gZmFjZSBkZXRlY3Rpb25cIik7XG4gICAgXG4gICAgLy8gQWRkIGhlYWQgcG9zZSBkYXRhXG4gICAgaWYgKG1ldHJpY3MuaGVhZF9wb3NlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGhlYWQgcG9zZTogcGl0Y2g9JHttZXRyaWNzLmhlYWRfcG9zZS5waXRjaH0sIHlhdz0ke21ldHJpY3MuaGVhZF9wb3NlLnlhd30sIHJvbGw9JHttZXRyaWNzLmhlYWRfcG9zZS5yb2xsfWApO1xuICAgICAgY3N2Q29udGVudCArPSBgcGl0Y2gsJHttZXRyaWNzLmhlYWRfcG9zZS5waXRjaH1cXG5gO1xuICAgICAgY3N2Q29udGVudCArPSBgeWF3LCR7bWV0cmljcy5oZWFkX3Bvc2UueWF3fVxcbmA7XG4gICAgICBjc3ZDb250ZW50ICs9IGByb2xsLCR7bWV0cmljcy5oZWFkX3Bvc2Uucm9sbH1cXG5gO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgZXllIGNlbnRlcnMgaWYgYXZhaWxhYmxlXG4gICAgaWYgKG1ldHJpY3MuZXllX2NlbnRlcnMpIHtcbiAgICAgIGlmIChtZXRyaWNzLmV5ZV9jZW50ZXJzLmxlZnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBsZWZ0IGV5ZTogJHttZXRyaWNzLmV5ZV9jZW50ZXJzLmxlZnQuam9pbignLCcpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGBsZWZ0X2V5ZV94LCR7bWV0cmljcy5leWVfY2VudGVycy5sZWZ0WzBdfVxcbmA7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGxlZnRfZXllX3ksJHttZXRyaWNzLmV5ZV9jZW50ZXJzLmxlZnRbMV19XFxuYDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRyaWNzLmV5ZV9jZW50ZXJzLnJpZ2h0KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgcmlnaHQgZXllOiAke21ldHJpY3MuZXllX2NlbnRlcnMucmlnaHQuam9pbignLCcpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGByaWdodF9leWVfeCwke21ldHJpY3MuZXllX2NlbnRlcnMucmlnaHRbMF19XFxuYDtcbiAgICAgICAgY3N2Q29udGVudCArPSBgcmlnaHRfZXllX3ksJHttZXRyaWNzLmV5ZV9jZW50ZXJzLnJpZ2h0WzFdfVxcbmA7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBmYWNlIGJveCBpbmZvcm1hdGlvbiBpZiBhdmFpbGFibGVcbiAgICBpZiAobWV0cmljcy5mYWNlX2JveCkge1xuICAgICAgaWYgKG1ldHJpY3MuZmFjZV9ib3gubWluKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgZmFjZSBib3ggbWluOiAke21ldHJpY3MuZmFjZV9ib3gubWluLmpvaW4oJywnKX1gKTtcbiAgICAgICAgY3N2Q29udGVudCArPSBgZmFjZV9ib3hfbWluX3gsJHttZXRyaWNzLmZhY2VfYm94Lm1pblswXX1cXG5gO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGBmYWNlX2JveF9taW5feSwke21ldHJpY3MuZmFjZV9ib3gubWluWzFdfVxcbmA7XG4gICAgICB9XG4gICAgICBpZiAobWV0cmljcy5mYWNlX2JveC5tYXgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBmYWNlIGJveCBtYXg6ICR7bWV0cmljcy5mYWNlX2JveC5tYXguam9pbignLCcpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGBmYWNlX2JveF9tYXhfeCwke21ldHJpY3MuZmFjZV9ib3gubWF4WzBdfVxcbmA7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGZhY2VfYm94X21heF95LCR7bWV0cmljcy5mYWNlX2JveC5tYXhbMV19XFxuYDtcbiAgICAgICAgXG4gICAgICAgIC8vIENhbGN1bGF0ZSBhbmQgYWRkIGZhY2Ugd2lkdGggYW5kIGhlaWdodFxuICAgICAgICBpZiAobWV0cmljcy5mYWNlX2JveC5taW4pIHtcbiAgICAgICAgICBjb25zdCBmYWNlV2lkdGggPSBNYXRoLnJvdW5kKG1ldHJpY3MuZmFjZV9ib3gubWF4WzBdIC0gbWV0cmljcy5mYWNlX2JveC5taW5bMF0pO1xuICAgICAgICAgIGNvbnN0IGZhY2VIZWlnaHQgPSBNYXRoLnJvdW5kKG1ldHJpY3MuZmFjZV9ib3gubWF4WzFdIC0gbWV0cmljcy5mYWNlX2JveC5taW5bMV0pO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgZmFjZSBkaW1lbnNpb25zOiB3aWR0aD0ke2ZhY2VXaWR0aH0sIGhlaWdodD0ke2ZhY2VIZWlnaHR9YCk7XG4gICAgICAgICAgY3N2Q29udGVudCArPSBgZmFjZV93aWR0aCwke2ZhY2VXaWR0aH1cXG5gO1xuICAgICAgICAgIGNzdkNvbnRlbnQgKz0gYGZhY2VfaGVpZ2h0LCR7ZmFjZUhlaWdodH1cXG5gO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKG9yaWdpbmFsUGFyYW1Gb3VuZCkge1xuICAgIC8vIElmIG5vIG5ldyBtZXRyaWNzIGJ1dCB3ZSBoYWQgb3JpZ2luYWwgZGF0YSBmb3IgdGhlc2UgZmllbGRzLCBwcmVzZXJ2ZSB0aGVtXG4gICAgY29uc29sZS5sb2coXCJObyBuZXcgbWV0cmljcywgcHJlc2VydmluZyBvcmlnaW5hbCBmYWNlIHRyYWNraW5nIGRhdGEgaWYgYXZhaWxhYmxlXCIpO1xuICAgIFxuICAgIGNvbnN0IGZpZWxkc1RvUHJlc2VydmUgPSBbJ3BpdGNoJywgJ3lhdycsICdyb2xsJywgJ2ZhY2Vfd2lkdGgnLCAnZmFjZV9oZWlnaHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGVmdF9leWVfeCcsICdsZWZ0X2V5ZV95JywgJ3JpZ2h0X2V5ZV94JywgJ3JpZ2h0X2V5ZV95JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZhY2VfYm94X21pbl94JywgJ2ZhY2VfYm94X21pbl95JywgJ2ZhY2VfYm94X21heF94JywgJ2ZhY2VfYm94X21heF95J107XG4gICAgXG4gICAgZmllbGRzVG9QcmVzZXJ2ZS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgIGlmIChvcmlnaW5hbFBhcmFtcy5oYXMoZmllbGQpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQcmVzZXJ2aW5nIG9yaWdpbmFsICR7ZmllbGR9PSR7b3JpZ2luYWxQYXJhbXMuZ2V0KGZpZWxkKX1gKTtcbiAgICAgICAgY3N2Q29udGVudCArPSBgJHtmaWVsZH0sJHtvcmlnaW5hbFBhcmFtcy5nZXQoZmllbGQpfVxcbmA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gbWV0cmljcyBhbmQgbm8gb3JpZ2luYWwgZGF0YSwgYWRkIHBsYWNlaG9sZGVyIGluZm9ybWF0aW9uXG4gICAgY29uc29sZS5sb2coXCJObyBtZXRyaWNzIGFuZCBubyBvcmlnaW5hbCBkYXRhLCBhZGRpbmcgcGxhY2Vob2xkZXJcIik7XG4gICAgY3N2Q29udGVudCArPSAnaW5mbyxObyBmYWNlIGRldGVjdGVkIG9yIHByb2Nlc3NpbmcgZmFpbGVkXFxuJztcbiAgfVxuICBcbiAgLy8gTG9nIHRoZSBmaW5hbCBDU1YgY29udGVudCBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUubG9nKGBGaW5hbCBwYXJhbWV0ZXIgZmlsZSBjb250ZW50OlxcbiR7Y3N2Q29udGVudH1gKTtcbiAgXG4gIC8vIFdyaXRlIHRoZSB1cGRhdGVkIENTViBmaWxlXG4gIGZzLndyaXRlRmlsZVN5bmMocGFyYW1EZXN0UGF0aCwgY3N2Q29udGVudCk7XG4gIGNvbnNvbGUubG9nKGBXcm90ZSB1cGRhdGVkIHBhcmFtZXRlciBmaWxlIHRvOiAke3BhcmFtRGVzdFBhdGh9YCk7XG4gIFxuICAvLyBWZXJpZnkgdGhlIGZpbGUgd2FzIHdyaXR0ZW5cbiAgaWYgKGZzLmV4aXN0c1N5bmMocGFyYW1EZXN0UGF0aCkpIHtcbiAgICBjb25zb2xlLmxvZyhgUGFyYW1ldGVyIGZpbGUgc3VjY2Vzc2Z1bGx5IHVwZGF0ZWQ6ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHBhcmFtZXRlciBmaWxlOiAke3BhcmFtRGVzdFBhdGh9YCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIHByb2Nlc3MgZmlsZXMgdmlhIHRoZSBGYXN0QVBJIGJhY2tlbmRcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NGaWxlc1ZpYUJhY2tlbmQoc2V0TnVtYmVycykge1xuICB0cnkge1xuICAgIC8vIEdldCB0aGUgYmFja2VuZCBVUkwgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZSBvciB1c2UgZGVmYXVsdFxuICAgIGNvbnN0IGJhY2tlbmRVcmwgPSBwcm9jZXNzLmVudi5CQUNLRU5EX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJztcbiAgICBjb25zdCBhcGlLZXkgPSBwcm9jZXNzLmVudi5BUElfS0VZIHx8ICdBMUIyQzNENC1FNUY2LTc4OTAtR0hJSi1LTE1OT1BRUlNUVVYnO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIEZhc3RBUEkgYmFja2VuZCB0byBwcm9jZXNzIHRoZSBmaWxlc1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7YmFja2VuZFVybH0vcHJvY2Vzcy1iYXRjaGAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAnWC1BUEktS2V5JzogYXBpS2V5XG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBcbiAgICAgICAgc2V0X251bWJlcnM6IHNldE51bWJlcnMsXG4gICAgICAgIHNob3dfaGVhZF9wb3NlOiB0cnVlLFxuICAgICAgICBzaG93X2JvdW5kaW5nX2JveDogdHJ1ZSxcbiAgICAgICAgc2hvd19tYXNrOiBmYWxzZSxcbiAgICAgICAgc2hvd19wYXJhbWV0ZXJzOiBmYWxzZVxuICAgICAgfSlcbiAgICB9KTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGUgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0JhY2tlbmQgcHJvY2Vzc2luZyBlcnJvcjonLCBlcnJvclRleHQpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBgQmFja2VuZCBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgYmFja2VuZCBmb3IgcHJvY2Vzc2luZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gcHJvY2VzcyBmaWxlcyBkaXJlY3RseSBpbiBOb2RlLmpzXG4vLyBGdW5jdGlvbiB0byBwcm9jZXNzIGZpbGVzIGRpcmVjdGx5IGluIE5vZGUuanNcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NGaWxlc0RpcmVjdGx5KHNldE51bWJlcnMsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoLCBwcm9ncmVzc0ZpbGVQYXRoKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coXCI9PT0gU1RBUlRJTkcgRElSRUNUIFBST0NFU1NJTkcgPT09XCIpO1xuICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIHNldHM6ICR7c2V0TnVtYmVycy5qb2luKCcsICcpfWApO1xuICAgIGNvbnNvbGUubG9nKGBDYXB0dXJlIGRpcmVjdG9yeTogJHtjYXB0dXJlRGlyfWApO1xuICAgIGNvbnNvbGUubG9nKGBFbmhhbmNlIGRpcmVjdG9yeTogJHtlbmhhbmNlUGF0aH1gKTtcbiAgICBcbiAgICAvLyBHZXQgY3VycmVudCBwcm9ncmVzcyBvciBpbml0aWFsaXplXG4gICAgbGV0IHByb2dyZXNzID0ge1xuICAgICAgY3VycmVudFNldDogMCxcbiAgICAgIHRvdGFsU2V0czogc2V0TnVtYmVycy5sZW5ndGgsXG4gICAgICBwcm9jZXNzZWRTZXRzOiBbXSxcbiAgICAgIHN0YXJ0VGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgbGFzdFVwZGF0ZVRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG4gICAgXG4gICAgLy8gUHJvY2VzcyBlYWNoIHNldFxuICAgIGZvciAoY29uc3Qgc2V0TnVtYmVyIG9mIHNldE51bWJlcnMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBcXG4tLS0gUHJvY2Vzc2luZyBzZXQgJHtzZXROdW1iZXJ9IC0tLWApO1xuICAgICAgICBwcm9ncmVzcy5jdXJyZW50U2V0ID0gc2V0TnVtYmVyO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHByb2dyZXNzRmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHByb2dyZXNzLCBudWxsLCAyKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIHByb2dyZXNzIGZpbGUgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFByb2Nlc3Mgd2ViY2FtIGltYWdlXG4gICAgICAgIGNvbnN0IHdlYmNhbVNyY1BhdGggPSBwYXRoLmpvaW4oY2FwdHVyZURpciwgYHdlYmNhbV8ke3NldE51bWJlcn0uanBnYCk7XG4gICAgICAgIGNvbnN0IHdlYmNhbURlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgd2ViY2FtX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmpwZ2ApO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYExvb2tpbmcgZm9yIHdlYmNhbSBpbWFnZSBhdDogJHt3ZWJjYW1TcmNQYXRofWApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMod2ViY2FtU3JjUGF0aCkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgd2ViY2FtIGltYWdlOiAke3dlYmNhbVNyY1BhdGh9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGltYWdlIHRocm91Z2ggdGhlIFB5dGhvbiBiYWNrZW5kXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2VuZGluZyB3ZWJjYW0gaW1hZ2UgZm9yIHNldCAke3NldE51bWJlcn0gdG8gcHJvY2Vzc19pbWFnZV9oYW5kbGVyYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdlJ3JlIHBhc3NpbmcgdGhlIGNhcHR1cmUgZGlyZWN0b3J5IGFuZCBlbmhhbmNlIHBhdGggdG8gaGVscCB3aXRoIHBhcmFtZXRlciBmaWxlIGhhbmRsaW5nXG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gYXdhaXQgcHJvY2Vzc0ltYWdlV2l0aFB5dGhvbih3ZWJjYW1TcmNQYXRoLCB3ZWJjYW1EZXN0UGF0aCwgc2V0TnVtYmVyLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChtZXRyaWNzKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCB3ZWJjYW0gaW1hZ2UgYW5kIGV4dHJhY3RlZCBtZXRyaWNzIGZvciBzZXQgJHtzZXROdW1iZXJ9YCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYOKaoO+4jyBQcm9jZXNzIGNvbXBsZXRlZCBidXQgbm8gbWV0cmljcyByZXR1cm5lZCBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBpbWFnZSBpcyBjb3BpZWQgZXZlbiBpZiBubyBtZXRyaWNzIHdlcmUgcmV0dXJuZWRcbiAgICAgICAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHdlYmNhbURlc3RQYXRoKSkge1xuICAgICAgICAgICAgICAgIGZzLmNvcHlGaWxlU3luYyh3ZWJjYW1TcmNQYXRoLCB3ZWJjYW1EZXN0UGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENvcGllZCBvcmlnaW5hbCB3ZWJjYW0gaW1hZ2UgYXMgZmFsbGJhY2sgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHByb2Nlc3Npbmcgd2ViY2FtIGltYWdlIGZvciBzZXQgJHtzZXROdW1iZXJ9OiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb3B5aW5nIHRoZSBvcmlnaW5hbCBmaWxlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29weWluZyBvcmlnaW5hbCB3ZWJjYW0gaW1hZ2UgYXMgZmFsbGJhY2sgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICAgICAgICAgIGZzLmNvcHlGaWxlU3luYyh3ZWJjYW1TcmNQYXRoLCB3ZWJjYW1EZXN0UGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFdlYmNhbSBpbWFnZSBub3QgZm91bmQgZm9yIHNldCAke3NldE51bWJlcn06ICR7d2ViY2FtU3JjUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyBzY3JlZW4gaW1hZ2UgaWYgaXQgZXhpc3RzXG4gICAgICAgIGNvbnN0IHNjcmVlblNyY1BhdGggPSBwYXRoLmpvaW4oY2FwdHVyZURpciwgYHNjcmVlbl8ke3NldE51bWJlcn0uanBnYCk7XG4gICAgICAgIGNvbnN0IHNjcmVlbkRlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgc2NyZWVuX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmpwZ2ApO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYExvb2tpbmcgZm9yIHNjcmVlbiBpbWFnZSBhdDogJHtzY3JlZW5TcmNQYXRofWApO1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhzY3JlZW5TcmNQYXRoKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTY3JlZW4gaW1hZ2UgZm91bmQ6ICR7c2NyZWVuU3JjUGF0aH1gKTtcbiAgICAgICAgICBmcy5jb3B5RmlsZVN5bmMoc2NyZWVuU3JjUGF0aCwgc2NyZWVuRGVzdFBhdGgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBDb3BpZWQgc2NyZWVuIGltYWdlIHRvOiAke3NjcmVlbkRlc3RQYXRofWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFNjcmVlbiBpbWFnZSBub3QgZm91bmQgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSBhIHBhcmFtZXRlciBmaWxlIGZvciB0aGlzIHNldCBpbiB0aGUgZW5oYW5jZSBkaXJlY3RvcnlcbiAgICAgICAgY29uc3QgZW5oYW5jZVBhcmFtUGF0aCA9IHBhdGguam9pbihlbmhhbmNlUGF0aCwgYHBhcmFtZXRlcl9lbmhhbmNlXyR7c2V0TnVtYmVyfS5jc3ZgKTtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGVuaGFuY2VQYXJhbVBhdGgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFBhcmFtZXRlciBmaWxlIG5vdCBjcmVhdGVkIGR1cmluZyBwcm9jZXNzaW5nIGZvciBzZXQgJHtzZXROdW1iZXJ9LCBjaGVja2luZyBmb3Igb3JpZ2luYWwuLi5gKTtcbiAgICAgICAgICBhd2FpdCB1cGRhdGVQYXJhbWV0ZXJGaWxlKHNldE51bWJlciwgbnVsbCwgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3NcbiAgICAgICAgcHJvZ3Jlc3MucHJvY2Vzc2VkU2V0cy5wdXNoKHNldE51bWJlcik7XG4gICAgICAgIHByb2dyZXNzLmxhc3RVcGRhdGVUaW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKHByb2dyZXNzRmlsZVBhdGgsIEpTT04uc3RyaW5naWZ5KHByb2dyZXNzLCBudWxsLCAyKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIHByb2dyZXNzIC0gc2V0ICR7c2V0TnVtYmVyfSBjb21wbGV0ZWRgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIHByZXZlbnQgb3ZlcndoZWxtaW5nIHRoZSBzeXN0ZW1cbiAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgNTAwbXMgYmVmb3JlIHByb2Nlc3NpbmcgbmV4dCBzZXQuLi5gKTtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvciBwcm9jZXNzaW5nIHNldCAke3NldE51bWJlcn06YCwgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJcXG49PT0gUFJPQ0VTU0lORyBDT01QTEVURUQgPT09XCIpO1xuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBzZXRzIHByb2Nlc3NlZDogJHtwcm9ncmVzcy5wcm9jZXNzZWRTZXRzLmxlbmd0aH0vJHtwcm9ncmVzcy50b3RhbFNldHN9YCk7XG4gICAgXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBkaXJlY3QgcHJvY2Vzc2luZzonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlcnJvci5tZXNzYWdlIH07XG4gIH1cbn1cblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcHkgcGFyYW1ldGVyIGZpbGVzXG5hc3luYyBmdW5jdGlvbiBjb3B5UGFyYW1ldGVyRmlsZShjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCwgc2V0TnVtYmVyKSB7XG4gIC8vIFRyeSBib3RoIHBhcmFtZXRlciBhbmQgcGFyYW1ldGVycyBuYW1pbmdcbiAgY29uc3QgcGFyYW1GaWxlTmFtZXMgPSBbXG4gICAgYHBhcmFtZXRlcnNfJHtzZXROdW1iZXJ9LmNzdmAsXG4gICAgYHBhcmFtZXRlcl8ke3NldE51bWJlcn0uY3N2YFxuICBdO1xuICBcbiAgbGV0IHBhcmFtRm91bmQgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBwYXJhbUZpbGVOYW1lIG9mIHBhcmFtRmlsZU5hbWVzKSB7XG4gICAgY29uc3QgcGFyYW1TcmNQYXRoID0gcGF0aC5qb2luKGNhcHR1cmVEaXIsIHBhcmFtRmlsZU5hbWUpO1xuICAgIGNvbnNvbGUubG9nKGBMb29raW5nIGZvciBwYXJhbWV0ZXIgZmlsZSBhdDogJHtwYXJhbVNyY1BhdGh9YCk7XG4gICAgXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMocGFyYW1TcmNQYXRoKSkge1xuICAgICAgY29uc29sZS5sb2coYFBhcmFtZXRlciBmaWxlIGZvdW5kOiAke3BhcmFtU3JjUGF0aH1gKTtcbiAgICAgIHBhcmFtRm91bmQgPSB0cnVlO1xuICAgICAgXG4gICAgICAvLyBEZXRlcm1pbmUgZGVzdGluYXRpb24gbmFtZSAoY2hhbmdlIHBhcmFtZXRlciB0byBwYXJhbWV0ZXJfZW5oYW5jZSlcbiAgICAgIGNvbnN0IGRlc3RGaWxlTmFtZSA9ICdwYXJhbWV0ZXJfZW5oYW5jZV8nICsgc2V0TnVtYmVyICsgJy5jc3YnO1xuICAgICAgY29uc3QgcGFyYW1EZXN0UGF0aCA9IHBhdGguam9pbihlbmhhbmNlUGF0aCwgZGVzdEZpbGVOYW1lKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYENvcHlpbmcgcGFyYW1ldGVyIGZpbGUgdG86ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgICAgIGZzLmNvcHlGaWxlU3luYyhwYXJhbVNyY1BhdGgsIHBhcmFtRGVzdFBhdGgpO1xuICAgICAgXG4gICAgICAvLyBWZXJpZnkgcGFyYW1ldGVyIGZpbGUgY29weVxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocGFyYW1EZXN0UGF0aCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYOKchSBQYXJhbWV0ZXIgZmlsZSBjb3BpZWQgc3VjY2Vzc2Z1bGx5YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWFkIGNvbnRlbnQgdG8gdmVyaWZ5XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhwYXJhbURlc3RQYXRoLCAndXRmOCcpO1xuICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpWzBdO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBQYXJhbWV0ZXIgZmlsZSBjb250ZW50IHN0YXJ0cyB3aXRoOiAke2ZpcnN0TGluZX1gKTtcbiAgICAgICAgfSBjYXRjaCAocmVhZEVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgcGFyYW1ldGVyIGZpbGU6ICR7cmVhZEVyci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3I6IFBhcmFtZXRlciBkZXN0aW5hdGlvbiBmaWxlIGRvZXNuJ3QgZXhpc3QgYWZ0ZXIgY29weSFgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYnJlYWs7IC8vIEZvdW5kIGFuZCBjb3BpZWQgb25lIHBhcmFtZXRlciBmaWxlLCBubyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlclxuICAgIH1cbiAgfVxuICBcbiAgaWYgKCFwYXJhbUZvdW5kKSB7XG4gICAgY29uc29sZS5sb2coYOKaoO+4jyBObyBwYXJhbWV0ZXIgZmlsZXMgZm91bmQgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYW4gZW1wdHkgcGFyYW1ldGVyIGZpbGUgaWYgbm9uZSBleGlzdHNcbiAgICBjb25zdCBwYXJhbURlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgcGFyYW1ldGVyX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmNzdmApO1xuICAgIGNvbnN0IGVtcHR5Q29udGVudCA9ICdQYXJhbWV0ZXIsVmFsdWVcXG5pbmZvLE5vIGZhY2UgZGV0ZWN0ZWQgb3IgcHJvY2Vzc2luZyBmYWlsZWRcXG4nO1xuICAgIGZzLndyaXRlRmlsZVN5bmMocGFyYW1EZXN0UGF0aCwgZW1wdHlDb250ZW50KTtcbiAgICBjb25zb2xlLmxvZyhg4pqg77iPIENyZWF0ZWQgZW1wdHkgcGFyYW1ldGVyIGZpbGU6ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgfVxufVxuXG4vLyBNYWluIGhhbmRsZXIgZm9yIEFQSSByZXF1ZXN0c1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXEsIHJlcykge1xuICAvLyBIYW5kbGUgR0VUIHJlcXVlc3QgdG8gY2hlY2sgcHJvY2Vzc2luZyBzdGF0dXNcbiAgaWYgKHJlcS5tZXRob2QgPT09ICdHRVQnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhcHR1cmVzUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ2V5ZV90cmFja2luZ19jYXB0dXJlcycpO1xuICAgICAgY29uc3QgZW5oYW5jZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycsICdlbmhhbmNlJyk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBjYXB0dXJlcyBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJykpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNhcHR1cmUgZGlyZWN0b3J5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhjYXB0dXJlc1BhdGgpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhjYXB0dXJlc1BhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgZW5oYW5jZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGVuaGFuY2VQYXRoKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoZW5oYW5jZVBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgcHJvY2Vzc2luZy5sb2NrIGZpbGUgKGluZGljYXRpbmcgcHJvY2Vzc2luZyBpcyBpbiBwcm9ncmVzcylcbiAgICAgIGNvbnN0IGxvY2tGaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ3Byb2Nlc3NpbmcubG9jaycpO1xuICAgICAgY29uc3QgaXNQcm9jZXNzaW5nID0gZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBmb3IgcHJvZ3Jlc3MgaW5mb3JtYXRpb24gZmlsZVxuICAgICAgY29uc3QgcHJvZ3Jlc3NGaWxlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ3Byb2Nlc3NpbmdfcHJvZ3Jlc3MuanNvbicpO1xuICAgICAgbGV0IHByb2dyZXNzSW5mbyA9IHsgXG4gICAgICAgIGN1cnJlbnRTZXQ6IDAsXG4gICAgICAgIHRvdGFsU2V0czogMCxcbiAgICAgICAgcHJvY2Vzc2VkU2V0czogW10sXG4gICAgICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICAgICAgbGFzdFVwZGF0ZVRpbWU6IG51bGxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKHByb2dyZXNzRmlsZVBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcHJvZ3Jlc3NEYXRhID0gZnMucmVhZEZpbGVTeW5jKHByb2dyZXNzRmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgcHJvZ3Jlc3NJbmZvID0gSlNPTi5wYXJzZShwcm9ncmVzc0RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcmVhZGluZyBwcm9ncmVzcyBmaWxlOlwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENvdW50IGZpbGVzIGluIGVhY2ggZGlyZWN0b3J5XG4gICAgICBjb25zdCBjYXB0dXJlRmlsZXMgPSBmcy5leGlzdHNTeW5jKGNhcHR1cmVzUGF0aCkgXG4gICAgICAgID8gZnMucmVhZGRpclN5bmMoY2FwdHVyZXNQYXRoKS5maWx0ZXIoZmlsZSA9PiBcbiAgICAgICAgICAgIGZpbGUuc3RhcnRzV2l0aCgnd2ViY2FtXycpICYmIGZpbGUuZW5kc1dpdGgoJy5qcGcnKSkubGVuZ3RoXG4gICAgICAgIDogMDtcbiAgICAgICAgXG4gICAgICBjb25zdCBlbmhhbmNlRmlsZXMgPSBmcy5leGlzdHNTeW5jKGVuaGFuY2VQYXRoKVxuICAgICAgICA/IGZzLnJlYWRkaXJTeW5jKGVuaGFuY2VQYXRoKS5maWx0ZXIoZmlsZSA9PiBcbiAgICAgICAgICAgIGZpbGUuc3RhcnRzV2l0aCgnd2ViY2FtX2VuaGFuY2VfJykgJiYgZmlsZS5lbmRzV2l0aCgnLmpwZycpKS5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBpc1Byb2Nlc3NpbmcsXG4gICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUZpbGVzLFxuICAgICAgICBlbmhhbmNlQ291bnQ6IGVuaGFuY2VGaWxlcyxcbiAgICAgICAgbmVlZHNQcm9jZXNzaW5nOiBjYXB0dXJlRmlsZXMgPiBlbmhhbmNlRmlsZXMsXG4gICAgICAgIHByb2dyZXNzOiBwcm9ncmVzc0luZm9cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBwcm9jZXNzIHN0YXR1czonLCBlcnJvcik7XG4gICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvLyBIYW5kbGUgUE9TVCByZXF1ZXN0IHRvIHRyaWdnZXIgcHJvY2Vzc2luZ1xuICBlbHNlIGlmIChyZXEubWV0aG9kID09PSAnUE9TVCcpIHtcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGxpc3Qgb2YgZmlsZXMgdG8gcHJvY2VzcyBmcm9tIHJlcXVlc3QgYm9keVxuICAgICAgY29uc3QgeyBzZXROdW1iZXJzIH0gPSByZXEuYm9keTtcbiAgICAgIFxuICAgICAgaWYgKCFzZXROdW1iZXJzIHx8ICFBcnJheS5pc0FycmF5KHNldE51bWJlcnMpIHx8IHNldE51bWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdObyBzZXQgbnVtYmVycyBwcm92aWRlZCBmb3IgcHJvY2Vzc2luZydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZGlyZWN0b3J5IGV4aXN0cyBiZWZvcmUgY3JlYXRpbmcgdGhlIGxvY2sgZmlsZVxuICAgICAgY29uc3QgY2FwdHVyZXNEaXIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycpO1xuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGNhcHR1cmVzRGlyKSkge1xuICAgICAgICBmcy5ta2RpclN5bmMoY2FwdHVyZXNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgZW5oYW5jZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgY29uc3QgZW5oYW5jZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycsICdlbmhhbmNlJyk7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhdGgpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhlbmhhbmNlUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYWxyZWFkeSBhIGxvY2sgZmlsZVxuICAgICAgY29uc3QgbG9ja0ZpbGVQYXRoID0gcGF0aC5qb2luKGNhcHR1cmVzRGlyLCAncHJvY2Vzc2luZy5sb2NrJyk7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwOSkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdQcm9jZXNzaW5nIGlzIGFscmVhZHkgaW4gcHJvZ3Jlc3MnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgbG9jayBmaWxlIHRvIGluZGljYXRlIHByb2Nlc3NpbmcgaXMgaW4gcHJvZ3Jlc3NcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMobG9ja0ZpbGVQYXRoLCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ3JlYXRlZCBsb2NrIGZpbGUgYXQgJHtsb2NrRmlsZVBhdGh9YCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgbG9jayBmaWxlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cyg1MDApLmpzb24oe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIGNyZWF0ZSBsb2NrIGZpbGU6ICR7ZXJyLm1lc3NhZ2V9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgcHJvZ3Jlc3MgZmlsZVxuICAgICAgY29uc3QgcHJvZ3Jlc3NGaWxlUGF0aCA9IHBhdGguam9pbihjYXB0dXJlc0RpciwgJ3Byb2Nlc3NpbmdfcHJvZ3Jlc3MuanNvbicpO1xuICAgICAgY29uc3QgcHJvZ3Jlc3NJbmZvID0ge1xuICAgICAgICBjdXJyZW50U2V0OiAwLFxuICAgICAgICB0b3RhbFNldHM6IHNldE51bWJlcnMubGVuZ3RoLFxuICAgICAgICBwcm9jZXNzZWRTZXRzOiBbXSxcbiAgICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGxhc3RVcGRhdGVUaW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3NJbmZvLCBudWxsLCAyKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY3JlYXRpbmcgcHJvZ3Jlc3MgZmlsZTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRGVmaW5lIHBhdGhzIGZvciBwcm9jZXNzaW5nXG4gICAgICBjb25zdCBjYXB0dXJlRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyk7XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBwcm9jZXNzaW5nIG1ldGhvZCB0byB1c2VcbiAgICAgIGNvbnN0IHVzZUJhY2tlbmQgPSBwcm9jZXNzLmVudi5VU0VfUFlUSE9OX0JBQ0tFTkQgPT09ICd0cnVlJztcbiAgICAgIFxuICAgICAgaWYgKHVzZUJhY2tlbmQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGJhY2tlbmQgcHJvY2Vzc2luZyBvZiAke3NldE51bWJlcnMubGVuZ3RofSBzZXRzLi4uYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCBwcm9jZXNzaW5nIHdpdGggdGhlIFB5dGhvbiBiYWNrZW5kXG4gICAgICAgIHByb2Nlc3NGaWxlc1ZpYUJhY2tlbmQoc2V0TnVtYmVycylcbiAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0JhY2tlbmQgcHJvY2Vzc2luZyBjb21wbGV0ZWQgd2l0aCByZXN1bHQ6JywgcmVzdWx0KTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBsb2NrIGZpbGUgd2hlbiBkb25lXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgIGZzLnVubGlua1N5bmMobG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQmFja2VuZCBwcm9jZXNzaW5nIGZhaWxlZDonLCBlcnIpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGxvY2sgZmlsZSBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobG9ja0ZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZTogJ1Byb2Nlc3Npbmcgc3RhcnRlZCcsXG4gICAgICAgICAgc2V0c1RvUHJvY2Vzczogc2V0TnVtYmVycy5sZW5ndGgsXG4gICAgICAgICAgcHJvY2Vzc2luZ01ldGhvZDogJ3B5dGhvbi1iYWNrZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBkaXJlY3QgcHJvY2Vzc2luZyBvZiAke3NldE51bWJlcnMubGVuZ3RofSBzZXRzLi4uYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGFydCBwcm9jZXNzaW5nIGluIHRoZSBiYWNrZ3JvdW5kIHVzaW5nIGRpcmVjdCBOb2RlLmpzIHByb2Nlc3NpbmdcbiAgICAgICAgcHJvY2Vzc0ZpbGVzRGlyZWN0bHkoc2V0TnVtYmVycywgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgsIHByb2dyZXNzRmlsZVBhdGgpXG4gICAgICAgICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGNvbXBsZXRlZCB3aXRoIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGxvY2sgZmlsZSB3aGVuIGRvbmVcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhsb2NrRmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9jZXNzaW5nIGZhaWxlZDonLCBlcnIpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGxvY2sgZmlsZSBvbiBlcnJvclxuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobG9ja0ZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzLnN0YXR1cygyMDApLmpzb24oe1xuICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZTogJ1Byb2Nlc3Npbmcgc3RhcnRlZCcsXG4gICAgICAgICAgc2V0c1RvUHJvY2Vzczogc2V0TnVtYmVycy5sZW5ndGgsXG4gICAgICAgICAgcHJvY2Vzc2luZ01ldGhvZDogJ2RpcmVjdCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRyaWdnZXJpbmcgcHJvY2Vzc2luZzonLCBlcnJvcik7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZXJlJ3MgYW4gZXJyb3IsIG1ha2Ugc3VyZSB0byBkZWxldGUgdGhlIGxvY2sgZmlsZVxuICAgICAgY29uc3QgbG9ja0ZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAncHJvY2Vzc2luZy5sb2NrJyk7XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMudW5saW5rU3luYyhsb2NrRmlsZVBhdGgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVtb3ZpbmcgbG9jayBmaWxlOicsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IFxuICAgICAgc3VjY2VzczogZmFsc2UsIFxuICAgICAgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIFxuICAgIH0pO1xuICB9XG59Il0sIm5hbWVzIjpbImZzIiwicGF0aCIsImV4ZWMiLCJ1dGlsIiwiZmV0Y2giLCJGb3JtRGF0YSIsImV4ZWNQcm9taXNlIiwicHJvbWlzaWZ5IiwicHJvY2Vzc0ltYWdlV2l0aFB5dGhvbiIsImlucHV0UGF0aCIsIm91dHB1dFBhdGgiLCJzZXROdW1iZXIiLCJjYXB0dXJlRGlyIiwiZW5oYW5jZVBhdGgiLCJjb25zb2xlIiwibG9nIiwiZXhpc3RzU3luYyIsImVycm9yIiwiYmFja2VuZFVybCIsInByb2Nlc3MiLCJlbnYiLCJCQUNLRU5EX1VSTCIsImFwaUtleSIsIkFQSV9LRVkiLCJmb3JtRGF0YSIsImZpbGVTdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwic3RhdHMiLCJzdGF0U3luYyIsInNpemUiLCJhcHBlbmQiLCJmaWxlbmFtZSIsImJhc2VuYW1lIiwiY29udGVudFR5cGUiLCJyZXNwb25zZSIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwidGltZW91dCIsInN0YXR1cyIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsImUiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJyZXN1bHQiLCJyZXNwb25zZVRleHQiLCJzdWJzdHJpbmciLCJKU09OIiwicGFyc2UiLCJtZXNzYWdlIiwic3VjY2VzcyIsImZhY2VfZGV0ZWN0ZWQiLCJjb3B5RmlsZVN5bmMiLCJ1cGRhdGVQYXJhbWV0ZXJGaWxlIiwiaW1hZ2UiLCJkYXRhIiwiaW1hZ2VCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwid3JpdGVGaWxlU3luYyIsImxlbmd0aCIsIm1ldHJpY3MiLCJzdHJpbmdpZnkiLCJzdGFjayIsImNvcHlFcnJvciIsIm9yaWdpbmFsUGFyYW1QYXRocyIsImpvaW4iLCJwYXJhbURlc3RQYXRoIiwib3JpZ2luYWxQYXJhbXMiLCJNYXAiLCJvcmlnaW5hbFBhcmFtRm91bmQiLCJvcmlnaW5hbEZpcnN0TGluZUlzSGVhZGVyIiwib3JpZ2luYWxQYXRoIiwiY29udGVudCIsInJlYWRGaWxlU3luYyIsImxpbmVzIiwic3BsaXQiLCJmaXJzdExpbmUiLCJ0cmltIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsInN0YXJ0TGluZSIsImkiLCJsaW5lIiwicGFydHMiLCJwYXJhbU5hbWUiLCJwYXJhbVZhbHVlIiwic2V0IiwiZXJyIiwiY3N2Q29udGVudCIsImV4Y2x1ZGVQYXJhbXMiLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJoZWFkX3Bvc2UiLCJwaXRjaCIsInlhdyIsInJvbGwiLCJleWVfY2VudGVycyIsImxlZnQiLCJyaWdodCIsImZhY2VfYm94IiwibWluIiwibWF4IiwiZmFjZVdpZHRoIiwiTWF0aCIsInJvdW5kIiwiZmFjZUhlaWdodCIsImZpZWxkc1RvUHJlc2VydmUiLCJmaWVsZCIsImhhcyIsImdldCIsInByb2Nlc3NGaWxlc1ZpYUJhY2tlbmQiLCJzZXROdW1iZXJzIiwic2V0X251bWJlcnMiLCJzaG93X2hlYWRfcG9zZSIsInNob3dfYm91bmRpbmdfYm94Iiwic2hvd19tYXNrIiwic2hvd19wYXJhbWV0ZXJzIiwianNvbiIsInByb2Nlc3NGaWxlc0RpcmVjdGx5IiwicHJvZ3Jlc3NGaWxlUGF0aCIsInByb2dyZXNzIiwiY3VycmVudFNldCIsInRvdGFsU2V0cyIsInByb2Nlc3NlZFNldHMiLCJzdGFydFRpbWUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJsYXN0VXBkYXRlVGltZSIsIndlYmNhbVNyY1BhdGgiLCJ3ZWJjYW1EZXN0UGF0aCIsIndhcm4iLCJzY3JlZW5TcmNQYXRoIiwic2NyZWVuRGVzdFBhdGgiLCJlbmhhbmNlUGFyYW1QYXRoIiwicHVzaCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImNvcHlQYXJhbWV0ZXJGaWxlIiwicGFyYW1GaWxlTmFtZXMiLCJwYXJhbUZvdW5kIiwicGFyYW1GaWxlTmFtZSIsInBhcmFtU3JjUGF0aCIsImRlc3RGaWxlTmFtZSIsInJlYWRFcnIiLCJlbXB0eUNvbnRlbnQiLCJoYW5kbGVyIiwicmVxIiwicmVzIiwiY2FwdHVyZXNQYXRoIiwiY3dkIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwibG9ja0ZpbGVQYXRoIiwiaXNQcm9jZXNzaW5nIiwicHJvZ3Jlc3NJbmZvIiwicHJvZ3Jlc3NEYXRhIiwiY2FwdHVyZUZpbGVzIiwicmVhZGRpclN5bmMiLCJmaWx0ZXIiLCJmaWxlIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwiZW5oYW5jZUZpbGVzIiwiY2FwdHVyZUNvdW50IiwiZW5oYW5jZUNvdW50IiwibmVlZHNQcm9jZXNzaW5nIiwiQXJyYXkiLCJpc0FycmF5IiwiY2FwdHVyZXNEaXIiLCJ1c2VCYWNrZW5kIiwiVVNFX1BZVEhPTl9CQUNLRU5EIiwidGhlbiIsInVubGlua1N5bmMiLCJjYXRjaCIsInNldHNUb1Byb2Nlc3MiLCJwcm9jZXNzaW5nTWV0aG9kIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/for-process-folder/process-status-api.js\n");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "form-data":
/*!****************************!*\
  !*** external "form-data" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("form-data");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-fetch");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();