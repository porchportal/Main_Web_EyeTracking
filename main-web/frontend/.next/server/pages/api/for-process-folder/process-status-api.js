"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/for-process-folder/process-status-api";
exports.ids = ["pages/api/for-process-folder/process-status-api"];
exports.modules = {

/***/ "(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/route-modules/pages-api/module.compiled */ \"(api-node)/./node_modules/next/dist/server/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/route-kind */ \"(api-node)/./node_modules/next/dist/server/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api-node)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages/api/for-process-folder/process-status-api.js */ \"(api-node)/./pages/api/for-process-folder/process-status-api.js\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__, 'default'));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__, 'config');\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/for-process-folder/process-status-api\",\n        pathname: \"/api/for-process-folder/process-status-api\",\n        // The following aren't used in production.\n        bundlePath: '',\n        filename: ''\n    },\n    userland: _pages_api_for_process_folder_process_status_api_js__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtcm91dGUtbG9hZGVyL2luZGV4LmpzP2tpbmQ9UEFHRVNfQVBJJnBhZ2U9JTJGYXBpJTJGZm9yLXByb2Nlc3MtZm9sZGVyJTJGcHJvY2Vzcy1zdGF0dXMtYXBpJnByZWZlcnJlZFJlZ2lvbj0mYWJzb2x1dGVQYWdlUGF0aD0uJTJGcGFnZXMlMkZhcGklMkZmb3ItcHJvY2Vzcy1mb2xkZXIlMkZwcm9jZXNzLXN0YXR1cy1hcGkuanMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQStGO0FBQ3ZDO0FBQ0U7QUFDMUQ7QUFDaUY7QUFDakY7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLGdGQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxnRkFBUTtBQUNwQztBQUNPLHdCQUF3Qix5R0FBbUI7QUFDbEQ7QUFDQSxjQUFjLGtFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsICdkZWZhdWx0Jyk7XG4vLyBSZS1leHBvcnQgY29uZmlnLlxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IGhvaXN0KHVzZXJsYW5kLCAnY29uZmlnJyk7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZm9yLXByb2Nlc3MtZm9sZGVyL3Byb2Nlc3Mtc3RhdHVzLWFwaVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6ICcnLFxuICAgICAgICBmaWxlbmFtZTogJydcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api-node)/./pages/api/for-process-folder/process-status-api.js":
/*!************************************************************!*\
  !*** ./pages/api/for-process-folder/process-status-api.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(node_fetch__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! form-data */ \"form-data\");\n/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(form_data__WEBPACK_IMPORTED_MODULE_5__);\n// pages/api/process-status-api.js - API to handle process status checks and triggers\n\n\n\n\n\n\n// Convert exec to Promise-based\nconst execPromise = util__WEBPACK_IMPORTED_MODULE_3___default().promisify(child_process__WEBPACK_IMPORTED_MODULE_2__.exec);\n// Updated function to properly handle image processing with proper dimension retention\nasync function processImageWithPython(inputPath, outputPath, setNumber, captureDir, enhancePath) {\n    try {\n        console.log(`Starting to process image: ${inputPath}`);\n        // Check if input file exists\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(inputPath)) {\n            console.error(`Input file does not exist: ${inputPath}`);\n            return null;\n        }\n        // Get the backend URL\n        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';\n        const apiKey = process.env.API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV';\n        // Create form data\n        const formData = new (form_data__WEBPACK_IMPORTED_MODULE_5___default())();\n        // Open the file as a stream\n        const fileStream = fs__WEBPACK_IMPORTED_MODULE_0___default().createReadStream(inputPath);\n        // Log the file size\n        const stats = fs__WEBPACK_IMPORTED_MODULE_0___default().statSync(inputPath);\n        console.log(`File size: ${stats.size} bytes`);\n        // Add file to form data\n        formData.append('file', fileStream, {\n            filename: path__WEBPACK_IMPORTED_MODULE_1___default().basename(inputPath),\n            contentType: 'image/jpeg'\n        });\n        // Add processing parameters - these must match the FastAPI backend expectations\n        formData.append('showHeadPose', 'false');\n        formData.append('showBoundingBox', 'false');\n        formData.append('showMask', 'false');\n        formData.append('showParameters', 'false');\n        console.log(`Sending ${inputPath} to Python backend at ${backendUrl}/process-image`);\n        // Log request details for debugging\n        console.log('API Key being used:', apiKey);\n        console.log('Form data parameters:', 'showHeadPose=false', 'showBoundingBox=true', 'showMask=false', 'showParameters=true');\n        // Call the Python backend\n        const response = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(`${backendUrl}/process-image`, {\n            method: 'POST',\n            headers: {\n                'X-API-Key': apiKey\n            },\n            body: formData,\n            timeout: 30000 // 30 second timeout for processing large images\n        });\n        // Log the response status\n        console.log(`Backend response status: ${response.status}`);\n        if (!response.ok) {\n            let errorText = '';\n            try {\n                errorText = await response.text();\n            } catch (e) {\n                errorText = 'Could not read error details';\n            }\n            console.error(`Backend error: ${response.status} ${response.statusText}`);\n            console.error(`Response body: ${errorText}`);\n            throw new Error(`Backend returned ${response.status}: ${response.statusText}`);\n        }\n        // Parse the response as JSON\n        let result;\n        try {\n            const responseText = await response.text();\n            console.log(`Response text (first 200 chars): ${responseText.substring(0, 200)}...`);\n            result = JSON.parse(responseText);\n        } catch (error) {\n            console.error('Error parsing response JSON:', error);\n            throw new Error(`Failed to parse backend response: ${error.message}`);\n        }\n        // Log result status\n        console.log('Backend processing result:', result.success ? 'Success' : 'Failed');\n        if (result.success) {\n            // Check if a face was detected\n            if (result.face_detected === false) {\n                console.log('No face detected in the image - saving original image');\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                // Still update parameter file with this information\n                await updateParameterFile(setNumber, {\n                    face_detected: false\n                }, captureDir, enhancePath);\n                return null;\n            }\n            // Verify we have the processed image data\n            if (!result.image || !result.image.data) {\n                console.error('Backend response missing image data');\n                // Fall back to copying the original image\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                console.log(`Copied original image as fallback to: ${outputPath}`);\n                // Update parameter file with minimal info\n                await updateParameterFile(setNumber, {\n                    face_detected: false\n                }, captureDir, enhancePath);\n                return null;\n            }\n            // Check if the dimensions in the response match the original image\n            if (result.image.width && result.image.height) {\n                console.log(`Processed image dimensions from API: ${result.image.width}x${result.image.height}`);\n            }\n            // Save the processed image - allowing dimension changes\n            try {\n                const imageBuffer = Buffer.from(result.image.data, 'base64');\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(outputPath, imageBuffer);\n                console.log(`Saved processed image to ${outputPath}, size: ${imageBuffer.length} bytes`);\n                // Log image saved info, we're not verifying dimensions match because we're allowing changes\n                console.log('Image saved successfully, dimensions may have changed from the original');\n            } catch (error) {\n                console.error(`Error saving processed image: ${error.message}`);\n                // Fall back to copying the original image\n                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n                console.log(`Copied original image as fallback to: ${outputPath}`);\n            }\n            // Check for metrics in the response\n            if (result.metrics) {\n                console.log('Metrics received from backend:', JSON.stringify(result.metrics));\n                // Update parameter file with the metrics\n                await updateParameterFile(setNumber, result.metrics, captureDir, enhancePath);\n                return result.metrics;\n            } else {\n                console.log('No metrics received from backend, using face_detected status only');\n                // Update parameter file with just the face detection status\n                await updateParameterFile(setNumber, {\n                    face_detected: true\n                }, captureDir, enhancePath);\n                return {\n                    face_detected: true\n                };\n            }\n        } else {\n            console.error(`Backend processing failed: ${result.error || 'Unknown error'}`);\n            // Fall back to copying the original image\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n            console.log(`Copied original image as fallback to: ${outputPath}`);\n            // Update parameter file with error information\n            await updateParameterFile(setNumber, null, captureDir, enhancePath);\n            return null;\n        }\n    } catch (error) {\n        console.error(`Error processing image with Python backend: ${error.message}`);\n        console.error(error.stack);\n        // Fall back to copying the original image\n        try {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(inputPath, outputPath);\n            console.log(`Copied original image as fallback after error: ${outputPath}`);\n        } catch (copyError) {\n            console.error(`Error copying original image: ${copyError.message}`);\n        }\n        // Update parameter file with error information\n        await updateParameterFile(setNumber, null, captureDir, enhancePath);\n        return null;\n    }\n}\n// New function to update parameter file with new metrics while preserving original data\n// Updated function to properly handle parameter file updates\nasync function updateParameterFile(setNumber, metrics, captureDir, enhancePath) {\n    console.log(`Updating parameter file for set ${setNumber} with new metrics`);\n    // Determine parameter file paths\n    const originalParamPaths = [\n        path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `parameters_${setNumber}.csv`),\n        path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `parameter_${setNumber}.csv`)\n    ];\n    // Output parameter file path\n    const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n    // Load original parameter data if available\n    let originalParams = new Map();\n    let originalParamFound = false;\n    let originalFirstLineIsHeader = false;\n    for (const originalPath of originalParamPaths){\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(originalPath)) {\n            console.log(`Found original parameter file: ${originalPath}`);\n            originalParamFound = true;\n            try {\n                const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(originalPath, 'utf8');\n                console.log(`Original parameter file content: ${content.substring(0, 100)}...`);\n                const lines = content.split('\\n');\n                // Check if the first line is a header\n                const firstLine = lines[0].trim();\n                originalFirstLineIsHeader = firstLine.toLowerCase().includes('parameter') || firstLine.toLowerCase().includes('name');\n                // Skip header line if it exists\n                const startLine = originalFirstLineIsHeader ? 1 : 0;\n                // Parse the original parameters\n                for(let i = startLine; i < lines.length; i++){\n                    const line = lines[i].trim();\n                    if (line) {\n                        const parts = line.split(',');\n                        if (parts.length >= 2) {\n                            const paramName = parts[0].trim();\n                            const paramValue = parts[1].trim();\n                            originalParams.set(paramName, paramValue);\n                            console.log(`Loaded parameter: ${paramName}=${paramValue}`);\n                        }\n                    }\n                }\n                console.log(`Loaded ${originalParams.size} parameters from original file`);\n                break; // Found and loaded one parameter file, no need to check the other\n            } catch (err) {\n                console.error(`Error reading original parameter file: ${err.message}`);\n            }\n        }\n    }\n    // Prepare CSV content with header\n    let csvContent = 'Parameter,Value\\n';\n    // Add original parameters first (except those we'll update with new values)\n    const excludeParams = [\n        'pitch',\n        'yaw',\n        'roll',\n        'face_width',\n        'face_height',\n        'left_eye_x',\n        'left_eye_y',\n        'right_eye_x',\n        'right_eye_y',\n        'face_box_min_x',\n        'face_box_min_y',\n        'face_box_max_x',\n        'face_box_max_y'\n    ];\n    // Log all original parameters for debugging\n    console.log(\"Original parameters:\");\n    originalParams.forEach((value, key)=>{\n        console.log(`  ${key}: ${value}`);\n    });\n    // Add existing parameters (except those we'll update)\n    originalParams.forEach((value, key)=>{\n        if (!excludeParams.includes(key.toLowerCase())) {\n            csvContent += `${key},${value}\\n`;\n        }\n    });\n    // Now add the new metrics\n    if (metrics && metrics.face_detected !== false) {\n        console.log(\"Adding new metrics from face detection\");\n        // Add head pose data\n        if (metrics.head_pose) {\n            console.log(`Adding head pose: pitch=${metrics.head_pose.pitch}, yaw=${metrics.head_pose.yaw}, roll=${metrics.head_pose.roll}`);\n            csvContent += `pitch,${metrics.head_pose.pitch}\\n`;\n            csvContent += `yaw,${metrics.head_pose.yaw}\\n`;\n            csvContent += `roll,${metrics.head_pose.roll}\\n`;\n        }\n        // Add eye centers if available\n        if (metrics.eye_centers) {\n            if (metrics.eye_centers.left) {\n                console.log(`Adding left eye: ${metrics.eye_centers.left.join(',')}`);\n                csvContent += `left_eye_x,${metrics.eye_centers.left[0]}\\n`;\n                csvContent += `left_eye_y,${metrics.eye_centers.left[1]}\\n`;\n            }\n            if (metrics.eye_centers.right) {\n                console.log(`Adding right eye: ${metrics.eye_centers.right.join(',')}`);\n                csvContent += `right_eye_x,${metrics.eye_centers.right[0]}\\n`;\n                csvContent += `right_eye_y,${metrics.eye_centers.right[1]}\\n`;\n            }\n        }\n        // Add face box information if available\n        if (metrics.face_box) {\n            if (metrics.face_box.min) {\n                console.log(`Adding face box min: ${metrics.face_box.min.join(',')}`);\n                csvContent += `face_box_min_x,${metrics.face_box.min[0]}\\n`;\n                csvContent += `face_box_min_y,${metrics.face_box.min[1]}\\n`;\n            }\n            if (metrics.face_box.max) {\n                console.log(`Adding face box max: ${metrics.face_box.max.join(',')}`);\n                csvContent += `face_box_max_x,${metrics.face_box.max[0]}\\n`;\n                csvContent += `face_box_max_y,${metrics.face_box.max[1]}\\n`;\n                // Calculate and add face width and height\n                if (metrics.face_box.min) {\n                    const faceWidth = Math.round(metrics.face_box.max[0] - metrics.face_box.min[0]);\n                    const faceHeight = Math.round(metrics.face_box.max[1] - metrics.face_box.min[1]);\n                    console.log(`Adding face dimensions: width=${faceWidth}, height=${faceHeight}`);\n                    csvContent += `face_width,${faceWidth}\\n`;\n                    csvContent += `face_height,${faceHeight}\\n`;\n                }\n            }\n        }\n    } else if (originalParamFound) {\n        // If no new metrics but we had original data for these fields, preserve them\n        console.log(\"No new metrics, preserving original face tracking data if available\");\n        const fieldsToPreserve = [\n            'pitch',\n            'yaw',\n            'roll',\n            'face_width',\n            'face_height',\n            'left_eye_x',\n            'left_eye_y',\n            'right_eye_x',\n            'right_eye_y',\n            'face_box_min_x',\n            'face_box_min_y',\n            'face_box_max_x',\n            'face_box_max_y'\n        ];\n        fieldsToPreserve.forEach((field)=>{\n            if (originalParams.has(field)) {\n                console.log(`Preserving original ${field}=${originalParams.get(field)}`);\n                csvContent += `${field},${originalParams.get(field)}\\n`;\n            }\n        });\n    } else {\n        // No metrics and no original data, add placeholder information\n        console.log(\"No metrics and no original data, adding placeholder\");\n        csvContent += 'info,No face detected or processing failed\\n';\n    }\n    // Log the final CSV content for debugging\n    console.log(`Final parameter file content:\\n${csvContent}`);\n    // Write the updated CSV file\n    fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(paramDestPath, csvContent);\n    console.log(`Wrote updated parameter file to: ${paramDestPath}`);\n    // Verify the file was written\n    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramDestPath)) {\n        console.log(`Parameter file successfully updated: ${paramDestPath}`);\n        return true;\n    } else {\n        console.error(`Failed to create parameter file: ${paramDestPath}`);\n        return false;\n    }\n}\n// Function to process files via the FastAPI backend\nasync function processFilesViaBackend(setNumbers) {\n    try {\n        // Get the backend URL from environment variable or use default\n        const backendUrl = process.env.BACKEND_URL || 'http://localhost:8000';\n        const apiKey = process.env.API_KEY || 'A1B2C3D4-E5F6-7890-GHIJ-KLMNOPQRSTUV';\n        // Call the FastAPI backend to process the files\n        const response = await node_fetch__WEBPACK_IMPORTED_MODULE_4___default()(`${backendUrl}/process-batch`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-API-Key': apiKey\n            },\n            body: JSON.stringify({\n                set_numbers: setNumbers,\n                show_head_pose: true,\n                show_bounding_box: true,\n                show_mask: false,\n                show_parameters: false\n            })\n        });\n        // Check if the request was successful\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error('Backend processing error:', errorText);\n            return {\n                success: false,\n                error: `Backend error: ${response.status} ${response.statusText}`\n            };\n        }\n        // Parse the response\n        const result = await response.json();\n        return result;\n    } catch (error) {\n        console.error('Error calling backend for processing:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Function to process files directly in Node.js\n// Function to process files directly in Node.js\nasync function processFilesDirectly(setNumbers, captureDir, enhancePath, progressFilePath) {\n    try {\n        console.log(\"=== STARTING DIRECT PROCESSING ===\");\n        console.log(`Processing sets: ${setNumbers.join(', ')}`);\n        console.log(`Capture directory: ${captureDir}`);\n        console.log(`Enhance directory: ${enhancePath}`);\n        // Get current progress or initialize\n        let progress = {\n            currentSet: 0,\n            totalSets: setNumbers.length,\n            processedSets: [],\n            startTime: new Date().toISOString(),\n            lastUpdateTime: new Date().toISOString()\n        };\n        // Process each set\n        for (const setNumber of setNumbers){\n            try {\n                console.log(`\\n--- Processing set ${setNumber} ---`);\n                progress.currentSet = setNumber;\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progress, null, 2));\n                console.log(`Updated progress file for set ${setNumber}`);\n                // Process webcam image\n                const webcamSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `webcam_${setNumber}.jpg`);\n                const webcamDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `webcam_enhance_${setNumber}.jpg`);\n                console.log(`Looking for webcam image at: ${webcamSrcPath}`);\n                if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(webcamSrcPath)) {\n                    console.log(`Found webcam image: ${webcamSrcPath}`);\n                    try {\n                        // Process the image through the Python backend\n                        console.log(`Sending webcam image for set ${setNumber} to process_image_handler`);\n                        // We're passing the capture directory and enhance path to help with parameter file handling\n                        const metrics = await processImageWithPython(webcamSrcPath, webcamDestPath, setNumber, captureDir, enhancePath);\n                        if (metrics) {\n                            console.log(`✅ Successfully processed webcam image and extracted metrics for set ${setNumber}`);\n                        } else {\n                            console.warn(`⚠️ Process completed but no metrics returned for set ${setNumber}`);\n                            // Ensure the image is copied even if no metrics were returned\n                            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(webcamDestPath)) {\n                                fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(webcamSrcPath, webcamDestPath);\n                                console.log(`Copied original webcam image as fallback for set ${setNumber}`);\n                            }\n                        }\n                    } catch (err) {\n                        console.error(`❌ Error processing webcam image for set ${setNumber}: ${err.message}`);\n                        console.error(err.stack);\n                        // Fallback to copying the original file\n                        console.log(`Copying original webcam image as fallback for set ${setNumber}`);\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(webcamSrcPath, webcamDestPath);\n                    }\n                } else {\n                    console.warn(`⚠️ Webcam image not found for set ${setNumber}: ${webcamSrcPath}`);\n                }\n                // Process screen image if it exists\n                const screenSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, `screen_${setNumber}.jpg`);\n                const screenDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `screen_enhance_${setNumber}.jpg`);\n                console.log(`Looking for screen image at: ${screenSrcPath}`);\n                if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(screenSrcPath)) {\n                    console.log(`Screen image found: ${screenSrcPath}`);\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(screenSrcPath, screenDestPath);\n                    console.log(`Copied screen image to: ${screenDestPath}`);\n                } else {\n                    console.warn(`⚠️ Screen image not found for set ${setNumber}`);\n                }\n                // Verify that we have a parameter file for this set in the enhance directory\n                const enhanceParamPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n                if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhanceParamPath)) {\n                    console.log(`Parameter file not created during processing for set ${setNumber}, checking for original...`);\n                    await updateParameterFile(setNumber, null, captureDir, enhancePath);\n                }\n                // Update progress\n                progress.processedSets.push(setNumber);\n                progress.lastUpdateTime = new Date().toISOString();\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progress, null, 2));\n                console.log(`Updated progress - set ${setNumber} completed`);\n                // Add a small delay to prevent overwhelming the system\n                console.log(`Waiting 500ms before processing next set...`);\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n            } catch (err) {\n                console.error(`❌ Error processing set ${setNumber}:`, err);\n            }\n        }\n        console.log(\"\\n=== PROCESSING COMPLETED ===\");\n        console.log(`Total sets processed: ${progress.processedSets.length}/${progress.totalSets}`);\n        return {\n            success: true\n        };\n    } catch (error) {\n        console.error('❌ Error in direct processing:', error);\n        return {\n            success: false,\n            error: error.message\n        };\n    }\n}\n// Helper function to copy parameter files\nasync function copyParameterFile(captureDir, enhancePath, setNumber) {\n    // Try both parameter and parameters naming\n    const paramFileNames = [\n        `parameters_${setNumber}.csv`,\n        `parameter_${setNumber}.csv`\n    ];\n    let paramFound = false;\n    for (const paramFileName of paramFileNames){\n        const paramSrcPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(captureDir, paramFileName);\n        console.log(`Looking for parameter file at: ${paramSrcPath}`);\n        if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramSrcPath)) {\n            console.log(`Parameter file found: ${paramSrcPath}`);\n            paramFound = true;\n            // Determine destination name (change parameter to parameter_enhance)\n            const destFileName = 'parameter_enhance_' + setNumber + '.csv';\n            const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, destFileName);\n            console.log(`Copying parameter file to: ${paramDestPath}`);\n            fs__WEBPACK_IMPORTED_MODULE_0___default().copyFileSync(paramSrcPath, paramDestPath);\n            // Verify parameter file copy\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(paramDestPath)) {\n                console.log(`✅ Parameter file copied successfully`);\n                // Read content to verify\n                try {\n                    const content = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(paramDestPath, 'utf8');\n                    const firstLine = content.split('\\n')[0];\n                    console.log(`Parameter file content starts with: ${firstLine}`);\n                } catch (readErr) {\n                    console.error(`Error reading parameter file: ${readErr.message}`);\n                }\n            } else {\n                console.error(`❌ Error: Parameter destination file doesn't exist after copy!`);\n            }\n            break; // Found and copied one parameter file, no need to check the other\n        }\n    }\n    if (!paramFound) {\n        console.log(`⚠️ No parameter files found for set ${setNumber}`);\n        // Create an empty parameter file if none exists\n        const paramDestPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(enhancePath, `parameter_enhance_${setNumber}.csv`);\n        const emptyContent = 'Parameter,Value\\ninfo,No face detected or processing failed\\n';\n        fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(paramDestPath, emptyContent);\n        console.log(`⚠️ Created empty parameter file: ${paramDestPath}`);\n    }\n}\n// Main handler for API requests\nasync function handler(req, res) {\n    // Handle GET request to check processing status\n    if (req.method === 'GET') {\n        try {\n            const capturesPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'eye_tracking_captures');\n            const enhancePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'enhance');\n            // Create captures directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures'))) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures'), {\n                    recursive: true\n                });\n            }\n            // Create capture directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesPath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(capturesPath, {\n                    recursive: true\n                });\n            }\n            // Create enhance directory if it doesn't exist\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(enhancePath, {\n                    recursive: true\n                });\n            }\n            // Check if there's a processing.lock file (indicating processing is in progress)\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing.lock');\n            const isProcessing = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath);\n            // Check for progress information file\n            const progressFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing_progress.json');\n            let progressInfo = {\n                currentSet: 0,\n                totalSets: 0,\n                processedSets: [],\n                startTime: null,\n                lastUpdateTime: null\n            };\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(progressFilePath)) {\n                try {\n                    const progressData = fs__WEBPACK_IMPORTED_MODULE_0___default().readFileSync(progressFilePath, 'utf8');\n                    progressInfo = JSON.parse(progressData);\n                } catch (err) {\n                    console.error(\"Error reading progress file:\", err);\n                }\n            }\n            // Count files in each directory\n            const captureFiles = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesPath) ? fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(capturesPath).filter((file)=>file.startsWith('webcam_') && file.endsWith('.jpg')).length : 0;\n            const enhanceFiles = fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath) ? fs__WEBPACK_IMPORTED_MODULE_0___default().readdirSync(enhancePath).filter((file)=>file.startsWith('webcam_enhance_') && file.endsWith('.jpg')).length : 0;\n            return res.status(200).json({\n                success: true,\n                isProcessing,\n                captureCount: captureFiles,\n                enhanceCount: enhanceFiles,\n                needsProcessing: captureFiles > enhanceFiles,\n                progress: progressInfo\n            });\n        } catch (error) {\n            console.error('Error checking process status:', error);\n            return res.status(500).json({\n                success: false,\n                error: error.message\n            });\n        }\n    } else if (req.method === 'POST') {\n        try {\n            // Get list of files to process from request body\n            const { setNumbers } = req.body;\n            if (!setNumbers || !Array.isArray(setNumbers) || setNumbers.length === 0) {\n                return res.status(400).json({\n                    success: false,\n                    error: 'No set numbers provided for processing'\n                });\n            }\n            // Make sure the directory exists before creating the lock file\n            const capturesDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures');\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(capturesDir)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(capturesDir, {\n                    recursive: true\n                });\n            }\n            // Create enhance directory if it doesn't exist\n            const enhancePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'enhance');\n            if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(enhancePath)) {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(enhancePath, {\n                    recursive: true\n                });\n            }\n            // Check if there's already a lock file\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(capturesDir, 'processing.lock');\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                return res.status(409).json({\n                    success: false,\n                    error: 'Processing is already in progress'\n                });\n            }\n            // Create lock file to indicate processing is in progress\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(lockFilePath, new Date().toISOString());\n                console.log(`Created lock file at ${lockFilePath}`);\n            } catch (err) {\n                console.error(`Error creating lock file: ${err.message}`);\n                return res.status(500).json({\n                    success: false,\n                    error: `Failed to create lock file: ${err.message}`\n                });\n            }\n            // Create initial progress file\n            const progressFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(capturesDir, 'processing_progress.json');\n            const progressInfo = {\n                currentSet: 0,\n                totalSets: setNumbers.length,\n                processedSets: [],\n                startTime: new Date().toISOString(),\n                lastUpdateTime: new Date().toISOString()\n            };\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(progressFilePath, JSON.stringify(progressInfo, null, 2));\n            } catch (err) {\n                console.error(`Error creating progress file: ${err.message}`);\n            }\n            // Define paths for processing\n            const captureDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'eye_tracking_captures');\n            // Determine which processing method to use\n            const useBackend = process.env.USE_PYTHON_BACKEND === 'true';\n            if (useBackend) {\n                console.log(`Starting backend processing of ${setNumbers.length} sets...`);\n                // Start processing with the Python backend\n                processFilesViaBackend(setNumbers).then((result)=>{\n                    console.log('Backend processing completed with result:', result);\n                    // Clean up the lock file when done\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                }).catch((err)=>{\n                    console.error('Backend processing failed:', err);\n                    // Clean up the lock file on error\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: 'Processing started',\n                    setsToProcess: setNumbers.length,\n                    processingMethod: 'python-backend'\n                });\n            } else {\n                console.log(`Starting direct processing of ${setNumbers.length} sets...`);\n                // Start processing in the background using direct Node.js processing\n                processFilesDirectly(setNumbers, captureDir, enhancePath, progressFilePath).then((result)=>{\n                    console.log('Processing completed with result:', result);\n                    // Clean up the lock file when done\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                }).catch((err)=>{\n                    console.error('Processing failed:', err);\n                    // Clean up the lock file on error\n                    if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                        fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                    }\n                });\n                return res.status(200).json({\n                    success: true,\n                    message: 'Processing started',\n                    setsToProcess: setNumbers.length,\n                    processingMethod: 'direct'\n                });\n            }\n        } catch (error) {\n            console.error('Error triggering processing:', error);\n            // If there's an error, make sure to delete the lock file\n            const lockFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), 'public', 'captures', 'processing.lock');\n            if (fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(lockFilePath)) {\n                try {\n                    fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(lockFilePath);\n                } catch (e) {\n                    console.error('Error removing lock file:', e);\n                }\n            }\n            return res.status(500).json({\n                success: false,\n                error: error.message\n            });\n        }\n    } else {\n        return res.status(405).json({\n            success: false,\n            error: 'Method not allowed'\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaS1ub2RlKS8uL3BhZ2VzL2FwaS9mb3ItcHJvY2Vzcy1mb2xkZXIvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxRkFBcUY7QUFDakU7QUFDSTtBQUNhO0FBQ2I7QUFDTztBQUNFO0FBRWpDLGdDQUFnQztBQUNoQyxNQUFNTSxjQUFjSCxxREFBYyxDQUFDRCwrQ0FBSUE7QUFFdkMsdUZBQXVGO0FBQ3ZGLGVBQWVNLHVCQUF1QkMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQzdGLElBQUk7UUFDRkMsUUFBUUMsR0FBRyxDQUFDLENBQUMsMkJBQTJCLEVBQUVOLFdBQVc7UUFFckQsNkJBQTZCO1FBQzdCLElBQUksQ0FBQ1Qsb0RBQWEsQ0FBQ1MsWUFBWTtZQUM3QkssUUFBUUcsS0FBSyxDQUFDLENBQUMsMkJBQTJCLEVBQUVSLFdBQVc7WUFDdkQsT0FBTztRQUNUO1FBRUEsc0JBQXNCO1FBQ3RCLE1BQU1TLGFBQWFDLFFBQVFDLEdBQUcsQ0FBQ0MsV0FBVyxJQUFJO1FBQzlDLE1BQU1DLFNBQVNILFFBQVFDLEdBQUcsQ0FBQ0csT0FBTyxJQUFJO1FBRXRDLG1CQUFtQjtRQUNuQixNQUFNQyxXQUFXLElBQUluQixrREFBUUE7UUFFN0IsNEJBQTRCO1FBQzVCLE1BQU1vQixhQUFhekIsMERBQW1CLENBQUNTO1FBRXZDLG9CQUFvQjtRQUNwQixNQUFNa0IsUUFBUTNCLGtEQUFXLENBQUNTO1FBQzFCSyxRQUFRQyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUVZLE1BQU1FLElBQUksQ0FBQyxNQUFNLENBQUM7UUFFNUMsd0JBQXdCO1FBQ3hCTCxTQUFTTSxNQUFNLENBQUMsUUFBUUwsWUFBWTtZQUNsQ00sVUFBVTlCLG9EQUFhLENBQUNRO1lBQ3hCd0IsYUFBYTtRQUNmO1FBRUEsZ0ZBQWdGO1FBQ2hGVCxTQUFTTSxNQUFNLENBQUMsZ0JBQWdCO1FBQ2hDTixTQUFT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cmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9hcGkvZm9yLXByb2Nlc3MtZm9sZGVyL3Byb2Nlc3Mtc3RhdHVzLWFwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBwYWdlcy9hcGkvcHJvY2Vzcy1zdGF0dXMtYXBpLmpzIC0gQVBJIHRvIGhhbmRsZSBwcm9jZXNzIHN0YXR1cyBjaGVja3MgYW5kIHRyaWdnZXJzXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBleGVjIH0gZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgdXRpbCBmcm9tICd1dGlsJztcbmltcG9ydCBmZXRjaCBmcm9tICdub2RlLWZldGNoJztcbmltcG9ydCBGb3JtRGF0YSBmcm9tICdmb3JtLWRhdGEnO1xuXG4vLyBDb252ZXJ0IGV4ZWMgdG8gUHJvbWlzZS1iYXNlZFxuY29uc3QgZXhlY1Byb21pc2UgPSB1dGlsLnByb21pc2lmeShleGVjKTtcblxuLy8gVXBkYXRlZCBmdW5jdGlvbiB0byBwcm9wZXJseSBoYW5kbGUgaW1hZ2UgcHJvY2Vzc2luZyB3aXRoIHByb3BlciBkaW1lbnNpb24gcmV0ZW50aW9uXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uKGlucHV0UGF0aCwgb3V0cHV0UGF0aCwgc2V0TnVtYmVyLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCkge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyB0byBwcm9jZXNzIGltYWdlOiAke2lucHV0UGF0aH1gKTtcbiAgICBcbiAgICAvLyBDaGVjayBpZiBpbnB1dCBmaWxlIGV4aXN0c1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhpbnB1dFBhdGgpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBJbnB1dCBmaWxlIGRvZXMgbm90IGV4aXN0OiAke2lucHV0UGF0aH1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGJhY2tlbmQgVVJMXG4gICAgY29uc3QgYmFja2VuZFVybCA9IHByb2Nlc3MuZW52LkJBQ0tFTkRfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVic7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGZvcm0gZGF0YVxuICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgXG4gICAgLy8gT3BlbiB0aGUgZmlsZSBhcyBhIHN0cmVhbVxuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGlucHV0UGF0aCk7XG4gICAgXG4gICAgLy8gTG9nIHRoZSBmaWxlIHNpemVcbiAgICBjb25zdCBzdGF0cyA9IGZzLnN0YXRTeW5jKGlucHV0UGF0aCk7XG4gICAgY29uc29sZS5sb2coYEZpbGUgc2l6ZTogJHtzdGF0cy5zaXplfSBieXRlc2ApO1xuICAgIFxuICAgIC8vIEFkZCBmaWxlIHRvIGZvcm0gZGF0YVxuICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGVTdHJlYW0sIHtcbiAgICAgIGZpbGVuYW1lOiBwYXRoLmJhc2VuYW1lKGlucHV0UGF0aCksXG4gICAgICBjb250ZW50VHlwZTogJ2ltYWdlL2pwZWcnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gQWRkIHByb2Nlc3NpbmcgcGFyYW1ldGVycyAtIHRoZXNlIG11c3QgbWF0Y2ggdGhlIEZhc3RBUEkgYmFja2VuZCBleHBlY3RhdGlvbnNcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3Nob3dIZWFkUG9zZScsICdmYWxzZScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd0JvdW5kaW5nQm94JywgJ2ZhbHNlJyk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCdzaG93TWFzaycsICdmYWxzZScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc2hvd1BhcmFtZXRlcnMnLCAnZmFsc2UnKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgU2VuZGluZyAke2lucHV0UGF0aH0gdG8gUHl0aG9uIGJhY2tlbmQgYXQgJHtiYWNrZW5kVXJsfS9wcm9jZXNzLWltYWdlYCk7XG4gICAgXG4gICAgLy8gTG9nIHJlcXVlc3QgZGV0YWlscyBmb3IgZGVidWdnaW5nXG4gICAgY29uc29sZS5sb2coJ0FQSSBLZXkgYmVpbmcgdXNlZDonLCBhcGlLZXkpO1xuICAgIGNvbnNvbGUubG9nKCdGb3JtIGRhdGEgcGFyYW1ldGVyczonLCBcbiAgICAgICAgICAgICAgICdzaG93SGVhZFBvc2U9ZmFsc2UnLCBcbiAgICAgICAgICAgICAgICdzaG93Qm91bmRpbmdCb3g9dHJ1ZScsIFxuICAgICAgICAgICAgICAgJ3Nob3dNYXNrPWZhbHNlJywgXG4gICAgICAgICAgICAgICAnc2hvd1BhcmFtZXRlcnM9dHJ1ZScpO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIFB5dGhvbiBiYWNrZW5kXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYWNrZW5kVXJsfS9wcm9jZXNzLWltYWdlYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdYLUFQSS1LZXknOiBhcGlLZXlcbiAgICAgIH0sXG4gICAgICBib2R5OiBmb3JtRGF0YSxcbiAgICAgIHRpbWVvdXQ6IDMwMDAwIC8vIDMwIHNlY29uZCB0aW1lb3V0IGZvciBwcm9jZXNzaW5nIGxhcmdlIGltYWdlc1xuICAgIH0pO1xuICAgIFxuICAgIC8vIExvZyB0aGUgcmVzcG9uc2Ugc3RhdHVzXG4gICAgY29uc29sZS5sb2coYEJhY2tlbmQgcmVzcG9uc2Ugc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JUZXh0ID0gJyc7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yVGV4dCA9ICdDb3VsZCBub3QgcmVhZCBlcnJvciBkZXRhaWxzJztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc29sZS5lcnJvcihgQmFja2VuZCBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFJlc3BvbnNlIGJvZHk6ICR7ZXJyb3JUZXh0fWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWNrZW5kIHJldHVybmVkICR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBQYXJzZSB0aGUgcmVzcG9uc2UgYXMgSlNPTlxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBSZXNwb25zZSB0ZXh0IChmaXJzdCAyMDAgY2hhcnMpOiAke3Jlc3BvbnNlVGV4dC5zdWJzdHJpbmcoMCwgMjAwKX0uLi5gKTtcbiAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyByZXNwb25zZSBKU09OOicsIGVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIGJhY2tlbmQgcmVzcG9uc2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTG9nIHJlc3VsdCBzdGF0dXNcbiAgICBjb25zb2xlLmxvZygnQmFja2VuZCBwcm9jZXNzaW5nIHJlc3VsdDonLCByZXN1bHQuc3VjY2VzcyA/ICdTdWNjZXNzJyA6ICdGYWlsZWQnKTtcbiAgICBcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIC8vIENoZWNrIGlmIGEgZmFjZSB3YXMgZGV0ZWN0ZWRcbiAgICAgIGlmIChyZXN1bHQuZmFjZV9kZXRlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05vIGZhY2UgZGV0ZWN0ZWQgaW4gdGhlIGltYWdlIC0gc2F2aW5nIG9yaWdpbmFsIGltYWdlJyk7XG4gICAgICAgIGZzLmNvcHlGaWxlU3luYyhpbnB1dFBhdGgsIG91dHB1dFBhdGgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RpbGwgdXBkYXRlIHBhcmFtZXRlciBmaWxlIHdpdGggdGhpcyBpbmZvcm1hdGlvblxuICAgICAgICBhd2FpdCB1cGRhdGVQYXJhbWV0ZXJGaWxlKHNldE51bWJlciwgeyBmYWNlX2RldGVjdGVkOiBmYWxzZSB9LCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmVyaWZ5IHdlIGhhdmUgdGhlIHByb2Nlc3NlZCBpbWFnZSBkYXRhXG4gICAgICBpZiAoIXJlc3VsdC5pbWFnZSB8fCAhcmVzdWx0LmltYWdlLmRhdGEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQmFja2VuZCByZXNwb25zZSBtaXNzaW5nIGltYWdlIGRhdGEnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgICAgICBmcy5jb3B5RmlsZVN5bmMoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICAgICAgY29uc29sZS5sb2coYENvcGllZCBvcmlnaW5hbCBpbWFnZSBhcyBmYWxsYmFjayB0bzogJHtvdXRwdXRQYXRofWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBhcmFtZXRlciBmaWxlIHdpdGggbWluaW1hbCBpbmZvXG4gICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCB7IGZhY2VfZGV0ZWN0ZWQ6IGZhbHNlIH0sIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZGltZW5zaW9ucyBpbiB0aGUgcmVzcG9uc2UgbWF0Y2ggdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICBpZiAocmVzdWx0LmltYWdlLndpZHRoICYmIHJlc3VsdC5pbWFnZS5oZWlnaHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3NlZCBpbWFnZSBkaW1lbnNpb25zIGZyb20gQVBJOiAke3Jlc3VsdC5pbWFnZS53aWR0aH14JHtyZXN1bHQuaW1hZ2UuaGVpZ2h0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTYXZlIHRoZSBwcm9jZXNzZWQgaW1hZ2UgLSBhbGxvd2luZyBkaW1lbnNpb24gY2hhbmdlc1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaW1hZ2VCdWZmZXIgPSBCdWZmZXIuZnJvbShyZXN1bHQuaW1hZ2UuZGF0YSwgJ2Jhc2U2NCcpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKG91dHB1dFBhdGgsIGltYWdlQnVmZmVyKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNhdmVkIHByb2Nlc3NlZCBpbWFnZSB0byAke291dHB1dFBhdGh9LCBzaXplOiAke2ltYWdlQnVmZmVyLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIExvZyBpbWFnZSBzYXZlZCBpbmZvLCB3ZSdyZSBub3QgdmVyaWZ5aW5nIGRpbWVuc2lvbnMgbWF0Y2ggYmVjYXVzZSB3ZSdyZSBhbGxvd2luZyBjaGFuZ2VzXG4gICAgICAgIGNvbnNvbGUubG9nKCdJbWFnZSBzYXZlZCBzdWNjZXNzZnVsbHksIGRpbWVuc2lvbnMgbWF5IGhhdmUgY2hhbmdlZCBmcm9tIHRoZSBvcmlnaW5hbCcpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nIHByb2Nlc3NlZCBpbWFnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICAgIGZzLmNvcHlGaWxlU3luYyhpbnB1dFBhdGgsIG91dHB1dFBhdGgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIGltYWdlIGFzIGZhbGxiYWNrIHRvOiAke291dHB1dFBhdGh9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBtZXRyaWNzIGluIHRoZSByZXNwb25zZVxuICAgICAgaWYgKHJlc3VsdC5tZXRyaWNzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdNZXRyaWNzIHJlY2VpdmVkIGZyb20gYmFja2VuZDonLCBKU09OLnN0cmluZ2lmeShyZXN1bHQubWV0cmljcykpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHBhcmFtZXRlciBmaWxlIHdpdGggdGhlIG1ldHJpY3NcbiAgICAgICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIHJlc3VsdC5tZXRyaWNzLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0Lm1ldHJpY3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnTm8gbWV0cmljcyByZWNlaXZlZCBmcm9tIGJhY2tlbmQsIHVzaW5nIGZhY2VfZGV0ZWN0ZWQgc3RhdHVzIG9ubHknKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwYXJhbWV0ZXIgZmlsZSB3aXRoIGp1c3QgdGhlIGZhY2UgZGV0ZWN0aW9uIHN0YXR1c1xuICAgICAgICBhd2FpdCB1cGRhdGVQYXJhbWV0ZXJGaWxlKHNldE51bWJlciwgeyBmYWNlX2RldGVjdGVkOiB0cnVlIH0sIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGZhY2VfZGV0ZWN0ZWQ6IHRydWUgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgQmFja2VuZCBwcm9jZXNzaW5nIGZhaWxlZDogJHtyZXN1bHQuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InfWApO1xuICAgICAgXG4gICAgICAvLyBGYWxsIGJhY2sgdG8gY29weWluZyB0aGUgb3JpZ2luYWwgaW1hZ2VcbiAgICAgIGZzLmNvcHlGaWxlU3luYyhpbnB1dFBhdGgsIG91dHB1dFBhdGgpO1xuICAgICAgY29uc29sZS5sb2coYENvcGllZCBvcmlnaW5hbCBpbWFnZSBhcyBmYWxsYmFjayB0bzogJHtvdXRwdXRQYXRofWApO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcGFyYW1ldGVyIGZpbGUgd2l0aCBlcnJvciBpbmZvcm1hdGlvblxuICAgICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIG51bGwsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgaW1hZ2Ugd2l0aCBQeXRob24gYmFja2VuZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3Iuc3RhY2spO1xuICAgIFxuICAgIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIHRoZSBvcmlnaW5hbCBpbWFnZVxuICAgIHRyeSB7XG4gICAgICBmcy5jb3B5RmlsZVN5bmMoaW5wdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDb3BpZWQgb3JpZ2luYWwgaW1hZ2UgYXMgZmFsbGJhY2sgYWZ0ZXIgZXJyb3I6ICR7b3V0cHV0UGF0aH1gKTtcbiAgICB9IGNhdGNoIChjb3B5RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGNvcHlpbmcgb3JpZ2luYWwgaW1hZ2U6ICR7Y29weUVycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBwYXJhbWV0ZXIgZmlsZSB3aXRoIGVycm9yIGluZm9ybWF0aW9uXG4gICAgYXdhaXQgdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIG51bGwsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLy8gTmV3IGZ1bmN0aW9uIHRvIHVwZGF0ZSBwYXJhbWV0ZXIgZmlsZSB3aXRoIG5ldyBtZXRyaWNzIHdoaWxlIHByZXNlcnZpbmcgb3JpZ2luYWwgZGF0YVxuLy8gVXBkYXRlZCBmdW5jdGlvbiB0byBwcm9wZXJseSBoYW5kbGUgcGFyYW1ldGVyIGZpbGUgdXBkYXRlc1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlUGFyYW1ldGVyRmlsZShzZXROdW1iZXIsIG1ldHJpY3MsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKSB7XG4gIGNvbnNvbGUubG9nKGBVcGRhdGluZyBwYXJhbWV0ZXIgZmlsZSBmb3Igc2V0ICR7c2V0TnVtYmVyfSB3aXRoIG5ldyBtZXRyaWNzYCk7XG4gIFxuICAvLyBEZXRlcm1pbmUgcGFyYW1ldGVyIGZpbGUgcGF0aHNcbiAgY29uc3Qgb3JpZ2luYWxQYXJhbVBhdGhzID0gW1xuICAgIHBhdGguam9pbihjYXB0dXJlRGlyLCBgcGFyYW1ldGVyc18ke3NldE51bWJlcn0uY3N2YCksXG4gICAgcGF0aC5qb2luKGNhcHR1cmVEaXIsIGBwYXJhbWV0ZXJfJHtzZXROdW1iZXJ9LmNzdmApXG4gIF07XG4gIFxuICAvLyBPdXRwdXQgcGFyYW1ldGVyIGZpbGUgcGF0aFxuICBjb25zdCBwYXJhbURlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgcGFyYW1ldGVyX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmNzdmApO1xuICBcbiAgLy8gTG9hZCBvcmlnaW5hbCBwYXJhbWV0ZXIgZGF0YSBpZiBhdmFpbGFibGVcbiAgbGV0IG9yaWdpbmFsUGFyYW1zID0gbmV3IE1hcCgpO1xuICBsZXQgb3JpZ2luYWxQYXJhbUZvdW5kID0gZmFsc2U7XG4gIGxldCBvcmlnaW5hbEZpcnN0TGluZUlzSGVhZGVyID0gZmFsc2U7XG4gIFxuICBmb3IgKGNvbnN0IG9yaWdpbmFsUGF0aCBvZiBvcmlnaW5hbFBhcmFtUGF0aHMpIHtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhvcmlnaW5hbFBhdGgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgb3JpZ2luYWwgcGFyYW1ldGVyIGZpbGU6ICR7b3JpZ2luYWxQYXRofWApO1xuICAgICAgb3JpZ2luYWxQYXJhbUZvdW5kID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhvcmlnaW5hbFBhdGgsICd1dGY4Jyk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBPcmlnaW5hbCBwYXJhbWV0ZXIgZmlsZSBjb250ZW50OiAke2NvbnRlbnQuc3Vic3RyaW5nKDAsIDEwMCl9Li4uYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGZpcnN0IGxpbmUgaXMgYSBoZWFkZXJcbiAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gbGluZXNbMF0udHJpbSgpO1xuICAgICAgICBvcmlnaW5hbEZpcnN0TGluZUlzSGVhZGVyID0gZmlyc3RMaW5lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3BhcmFtZXRlcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnbmFtZScpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2tpcCBoZWFkZXIgbGluZSBpZiBpdCBleGlzdHNcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gb3JpZ2luYWxGaXJzdExpbmVJc0hlYWRlciA/IDEgOiAwO1xuICAgICAgICBcbiAgICAgICAgLy8gUGFyc2UgdGhlIG9yaWdpbmFsIHBhcmFtZXRlcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZTsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gcGFydHNbMF0udHJpbSgpO1xuICAgICAgICAgICAgICBjb25zdCBwYXJhbVZhbHVlID0gcGFydHNbMV0udHJpbSgpO1xuICAgICAgICAgICAgICBvcmlnaW5hbFBhcmFtcy5zZXQocGFyYW1OYW1lLCBwYXJhbVZhbHVlKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYExvYWRlZCBwYXJhbWV0ZXI6ICR7cGFyYW1OYW1lfT0ke3BhcmFtVmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgTG9hZGVkICR7b3JpZ2luYWxQYXJhbXMuc2l6ZX0gcGFyYW1ldGVycyBmcm9tIG9yaWdpbmFsIGZpbGVgKTtcbiAgICAgICAgYnJlYWs7IC8vIEZvdW5kIGFuZCBsb2FkZWQgb25lIHBhcmFtZXRlciBmaWxlLCBubyBuZWVkIHRvIGNoZWNrIHRoZSBvdGhlclxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgb3JpZ2luYWwgcGFyYW1ldGVyIGZpbGU6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICAvLyBQcmVwYXJlIENTViBjb250ZW50IHdpdGggaGVhZGVyXG4gIGxldCBjc3ZDb250ZW50ID0gJ1BhcmFtZXRlcixWYWx1ZVxcbic7XG4gIFxuICAvLyBBZGQgb3JpZ2luYWwgcGFyYW1ldGVycyBmaXJzdCAoZXhjZXB0IHRob3NlIHdlJ2xsIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMpXG4gIGNvbnN0IGV4Y2x1ZGVQYXJhbXMgPSBbJ3BpdGNoJywgJ3lhdycsICdyb2xsJywgJ2ZhY2Vfd2lkdGgnLCAnZmFjZV9oZWlnaHQnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAnbGVmdF9leWVfeCcsICdsZWZ0X2V5ZV95JywgJ3JpZ2h0X2V5ZV94JywgJ3JpZ2h0X2V5ZV95JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAnZmFjZV9ib3hfbWluX3gnLCAnZmFjZV9ib3hfbWluX3knLCAnZmFjZV9ib3hfbWF4X3gnLCAnZmFjZV9ib3hfbWF4X3knXTtcbiAgXG4gIC8vIExvZyBhbGwgb3JpZ2luYWwgcGFyYW1ldGVycyBmb3IgZGVidWdnaW5nXG4gIGNvbnNvbGUubG9nKFwiT3JpZ2luYWwgcGFyYW1ldGVyczpcIik7XG4gIG9yaWdpbmFsUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgICAke2tleX06ICR7dmFsdWV9YCk7XG4gIH0pO1xuICBcbiAgLy8gQWRkIGV4aXN0aW5nIHBhcmFtZXRlcnMgKGV4Y2VwdCB0aG9zZSB3ZSdsbCB1cGRhdGUpXG4gIG9yaWdpbmFsUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoIWV4Y2x1ZGVQYXJhbXMuaW5jbHVkZXMoa2V5LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICBjc3ZDb250ZW50ICs9IGAke2tleX0sJHt2YWx1ZX1cXG5gO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBOb3cgYWRkIHRoZSBuZXcgbWV0cmljc1xuICBpZiAobWV0cmljcyAmJiBtZXRyaWNzLmZhY2VfZGV0ZWN0ZWQgIT09IGZhbHNlKSB7XG4gICAgY29uc29sZS5sb2coXCJBZGRpbmcgbmV3IG1ldHJpY3MgZnJvbSBmYWNlIGRldGVjdGlvblwiKTtcbiAgICBcbiAgICAvLyBBZGQgaGVhZCBwb3NlIGRhdGFcbiAgICBpZiAobWV0cmljcy5oZWFkX3Bvc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgaGVhZCBwb3NlOiBwaXRjaD0ke21ldHJpY3MuaGVhZF9wb3NlLnBpdGNofSwgeWF3PSR7bWV0cmljcy5oZWFkX3Bvc2UueWF3fSwgcm9sbD0ke21ldHJpY3MuaGVhZF9wb3NlLnJvbGx9YCk7XG4gICAgICBjc3ZDb250ZW50ICs9IGBwaXRjaCwke21ldHJpY3MuaGVhZF9wb3NlLnBpdGNofVxcbmA7XG4gICAgICBjc3ZDb250ZW50ICs9IGB5YXcsJHttZXRyaWNzLmhlYWRfcG9zZS55YXd9XFxuYDtcbiAgICAgIGNzdkNvbnRlbnQgKz0gYHJvbGwsJHttZXRyaWNzLmhlYWRfcG9zZS5yb2xsfVxcbmA7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBleWUgY2VudGVycyBpZiBhdmFpbGFibGVcbiAgICBpZiAobWV0cmljcy5leWVfY2VudGVycykge1xuICAgICAgaWYgKG1ldHJpY3MuZXllX2NlbnRlcnMubGVmdCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGxlZnQgZXllOiAke21ldHJpY3MuZXllX2NlbnRlcnMubGVmdC5qb2luKCcsJyl9YCk7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGxlZnRfZXllX3gsJHttZXRyaWNzLmV5ZV9jZW50ZXJzLmxlZnRbMF19XFxuYDtcbiAgICAgICAgY3N2Q29udGVudCArPSBgbGVmdF9leWVfeSwke21ldHJpY3MuZXllX2NlbnRlcnMubGVmdFsxXX1cXG5gO1xuICAgICAgfVxuICAgICAgaWYgKG1ldHJpY3MuZXllX2NlbnRlcnMucmlnaHQpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyByaWdodCBleWU6ICR7bWV0cmljcy5leWVfY2VudGVycy5yaWdodC5qb2luKCcsJyl9YCk7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYHJpZ2h0X2V5ZV94LCR7bWV0cmljcy5leWVfY2VudGVycy5yaWdodFswXX1cXG5gO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGByaWdodF9leWVfeSwke21ldHJpY3MuZXllX2NlbnRlcnMucmlnaHRbMV19XFxuYDtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGZhY2UgYm94IGluZm9ybWF0aW9uIGlmIGF2YWlsYWJsZVxuICAgIGlmIChtZXRyaWNzLmZhY2VfYm94KSB7XG4gICAgICBpZiAobWV0cmljcy5mYWNlX2JveC5taW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBmYWNlIGJveCBtaW46ICR7bWV0cmljcy5mYWNlX2JveC5taW4uam9pbignLCcpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGBmYWNlX2JveF9taW5feCwke21ldHJpY3MuZmFjZV9ib3gubWluWzBdfVxcbmA7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGZhY2VfYm94X21pbl95LCR7bWV0cmljcy5mYWNlX2JveC5taW5bMV19XFxuYDtcbiAgICAgIH1cbiAgICAgIGlmIChtZXRyaWNzLmZhY2VfYm94Lm1heCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgQWRkaW5nIGZhY2UgYm94IG1heDogJHttZXRyaWNzLmZhY2VfYm94Lm1heC5qb2luKCcsJyl9YCk7XG4gICAgICAgIGNzdkNvbnRlbnQgKz0gYGZhY2VfYm94X21heF94LCR7bWV0cmljcy5mYWNlX2JveC5tYXhbMF19XFxuYDtcbiAgICAgICAgY3N2Q29udGVudCArPSBgZmFjZV9ib3hfbWF4X3ksJHttZXRyaWNzLmZhY2VfYm94Lm1heFsxXX1cXG5gO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGFuZCBhZGQgZmFjZSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICAgIGlmIChtZXRyaWNzLmZhY2VfYm94Lm1pbikge1xuICAgICAgICAgIGNvbnN0IGZhY2VXaWR0aCA9IE1hdGgucm91bmQobWV0cmljcy5mYWNlX2JveC5tYXhbMF0gLSBtZXRyaWNzLmZhY2VfYm94Lm1pblswXSk7XG4gICAgICAgICAgY29uc3QgZmFjZUhlaWdodCA9IE1hdGgucm91bmQobWV0cmljcy5mYWNlX2JveC5tYXhbMV0gLSBtZXRyaWNzLmZhY2VfYm94Lm1pblsxXSk7XG4gICAgICAgICAgY29uc29sZS5sb2coYEFkZGluZyBmYWNlIGRpbWVuc2lvbnM6IHdpZHRoPSR7ZmFjZVdpZHRofSwgaGVpZ2h0PSR7ZmFjZUhlaWdodH1gKTtcbiAgICAgICAgICBjc3ZDb250ZW50ICs9IGBmYWNlX3dpZHRoLCR7ZmFjZVdpZHRofVxcbmA7XG4gICAgICAgICAgY3N2Q29udGVudCArPSBgZmFjZV9oZWlnaHQsJHtmYWNlSGVpZ2h0fVxcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob3JpZ2luYWxQYXJhbUZvdW5kKSB7XG4gICAgLy8gSWYgbm8gbmV3IG1ldHJpY3MgYnV0IHdlIGhhZCBvcmlnaW5hbCBkYXRhIGZvciB0aGVzZSBmaWVsZHMsIHByZXNlcnZlIHRoZW1cbiAgICBjb25zb2xlLmxvZyhcIk5vIG5ldyBtZXRyaWNzLCBwcmVzZXJ2aW5nIG9yaWdpbmFsIGZhY2UgdHJhY2tpbmcgZGF0YSBpZiBhdmFpbGFibGVcIik7XG4gICAgXG4gICAgY29uc3QgZmllbGRzVG9QcmVzZXJ2ZSA9IFsncGl0Y2gnLCAneWF3JywgJ3JvbGwnLCAnZmFjZV93aWR0aCcsICdmYWNlX2hlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICdsZWZ0X2V5ZV94JywgJ2xlZnRfZXllX3knLCAncmlnaHRfZXllX3gnLCAncmlnaHRfZXllX3knLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmFjZV9ib3hfbWluX3gnLCAnZmFjZV9ib3hfbWluX3knLCAnZmFjZV9ib3hfbWF4X3gnLCAnZmFjZV9ib3hfbWF4X3knXTtcbiAgICBcbiAgICBmaWVsZHNUb1ByZXNlcnZlLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgaWYgKG9yaWdpbmFsUGFyYW1zLmhhcyhmaWVsZCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFByZXNlcnZpbmcgb3JpZ2luYWwgJHtmaWVsZH09JHtvcmlnaW5hbFBhcmFtcy5nZXQoZmllbGQpfWApO1xuICAgICAgICBjc3ZDb250ZW50ICs9IGAke2ZpZWxkfSwke29yaWdpbmFsUGFyYW1zLmdldChmaWVsZCl9XFxuYDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBtZXRyaWNzIGFuZCBubyBvcmlnaW5hbCBkYXRhLCBhZGQgcGxhY2Vob2xkZXIgaW5mb3JtYXRpb25cbiAgICBjb25zb2xlLmxvZyhcIk5vIG1ldHJpY3MgYW5kIG5vIG9yaWdpbmFsIGRhdGEsIGFkZGluZyBwbGFjZWhvbGRlclwiKTtcbiAgICBjc3ZDb250ZW50ICs9ICdpbmZvLE5vIGZhY2UgZGV0ZWN0ZWQgb3IgcHJvY2Vzc2luZyBmYWlsZWRcXG4nO1xuICB9XG4gIFxuICAvLyBMb2cgdGhlIGZpbmFsIENTViBjb250ZW50IGZvciBkZWJ1Z2dpbmdcbiAgY29uc29sZS5sb2coYEZpbmFsIHBhcmFtZXRlciBmaWxlIGNvbnRlbnQ6XFxuJHtjc3ZDb250ZW50fWApO1xuICBcbiAgLy8gV3JpdGUgdGhlIHVwZGF0ZWQgQ1NWIGZpbGVcbiAgZnMud3JpdGVGaWxlU3luYyhwYXJhbURlc3RQYXRoLCBjc3ZDb250ZW50KTtcbiAgY29uc29sZS5sb2coYFdyb3RlIHVwZGF0ZWQgcGFyYW1ldGVyIGZpbGUgdG86ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgXG4gIC8vIFZlcmlmeSB0aGUgZmlsZSB3YXMgd3JpdHRlblxuICBpZiAoZnMuZXhpc3RzU3luYyhwYXJhbURlc3RQYXRoKSkge1xuICAgIGNvbnNvbGUubG9nKGBQYXJhbWV0ZXIgZmlsZSBzdWNjZXNzZnVsbHkgdXBkYXRlZDogJHtwYXJhbURlc3RQYXRofWApO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgcGFyYW1ldGVyIGZpbGU6ICR7cGFyYW1EZXN0UGF0aH1gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gRnVuY3Rpb24gdG8gcHJvY2VzcyBmaWxlcyB2aWEgdGhlIEZhc3RBUEkgYmFja2VuZFxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzVmlhQmFja2VuZChzZXROdW1iZXJzKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IHRoZSBiYWNrZW5kIFVSTCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlIG9yIHVzZSBkZWZhdWx0XG4gICAgY29uc3QgYmFja2VuZFVybCA9IHByb2Nlc3MuZW52LkJBQ0tFTkRfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnO1xuICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52LkFQSV9LRVkgfHwgJ0ExQjJDM0Q0LUU1RjYtNzg5MC1HSElKLUtMTU5PUFFSU1RVVic7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgRmFzdEFQSSBiYWNrZW5kIHRvIHByb2Nlc3MgdGhlIGZpbGVzXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYWNrZW5kVXJsfS9wcm9jZXNzLWJhdGNoYCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdYLUFQSS1LZXknOiBhcGlLZXlcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IFxuICAgICAgICBzZXRfbnVtYmVyczogc2V0TnVtYmVycyxcbiAgICAgICAgc2hvd19oZWFkX3Bvc2U6IHRydWUsXG4gICAgICAgIHNob3dfYm91bmRpbmdfYm94OiB0cnVlLFxuICAgICAgICBzaG93X21hc2s6IGZhbHNlLFxuICAgICAgICBzaG93X3BhcmFtZXRlcnM6IGZhbHNlXG4gICAgICB9KVxuICAgIH0pO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgY29uc29sZS5lcnJvcignQmFja2VuZCBwcm9jZXNzaW5nIGVycm9yOicsIGVycm9yVGV4dCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGBCYWNrZW5kIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsbGluZyBiYWNrZW5kIGZvciBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBwcm9jZXNzIGZpbGVzIGRpcmVjdGx5IGluIE5vZGUuanNcbi8vIEZ1bmN0aW9uIHRvIHByb2Nlc3MgZmlsZXMgZGlyZWN0bHkgaW4gTm9kZS5qc1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0ZpbGVzRGlyZWN0bHkoc2V0TnVtYmVycywgY2FwdHVyZURpciwgZW5oYW5jZVBhdGgsIHByb2dyZXNzRmlsZVBhdGgpIHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhcIj09PSBTVEFSVElORyBESVJFQ1QgUFJPQ0VTU0lORyA9PT1cIik7XG4gICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc2V0czogJHtzZXROdW1iZXJzLmpvaW4oJywgJyl9YCk7XG4gICAgY29uc29sZS5sb2coYENhcHR1cmUgZGlyZWN0b3J5OiAke2NhcHR1cmVEaXJ9YCk7XG4gICAgY29uc29sZS5sb2coYEVuaGFuY2UgZGlyZWN0b3J5OiAke2VuaGFuY2VQYXRofWApO1xuICAgIFxuICAgIC8vIEdldCBjdXJyZW50IHByb2dyZXNzIG9yIGluaXRpYWxpemVcbiAgICBsZXQgcHJvZ3Jlc3MgPSB7XG4gICAgICBjdXJyZW50U2V0OiAwLFxuICAgICAgdG90YWxTZXRzOiBzZXROdW1iZXJzLmxlbmd0aCxcbiAgICAgIHByb2Nlc3NlZFNldHM6IFtdLFxuICAgICAgc3RhcnRUaW1lOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICBsYXN0VXBkYXRlVGltZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcbiAgICBcbiAgICAvLyBQcm9jZXNzIGVhY2ggc2V0XG4gICAgZm9yIChjb25zdCBzZXROdW1iZXIgb2Ygc2V0TnVtYmVycykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFxcbi0tLSBQcm9jZXNzaW5nIHNldCAke3NldE51bWJlcn0gLS0tYCk7XG4gICAgICAgIHByb2dyZXNzLmN1cnJlbnRTZXQgPSBzZXROdW1iZXI7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3MsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgcHJvZ3Jlc3MgZmlsZSBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvY2VzcyB3ZWJjYW0gaW1hZ2VcbiAgICAgICAgY29uc3Qgd2ViY2FtU3JjUGF0aCA9IHBhdGguam9pbihjYXB0dXJlRGlyLCBgd2ViY2FtXyR7c2V0TnVtYmVyfS5qcGdgKTtcbiAgICAgICAgY29uc3Qgd2ViY2FtRGVzdFBhdGggPSBwYXRoLmpvaW4oZW5oYW5jZVBhdGgsIGB3ZWJjYW1fZW5oYW5jZV8ke3NldE51bWJlcn0uanBnYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgTG9va2luZyBmb3Igd2ViY2FtIGltYWdlIGF0OiAke3dlYmNhbVNyY1BhdGh9YCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyh3ZWJjYW1TcmNQYXRoKSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCB3ZWJjYW0gaW1hZ2U6ICR7d2ViY2FtU3JjUGF0aH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgaW1hZ2UgdGhyb3VnaCB0aGUgUHl0aG9uIGJhY2tlbmRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTZW5kaW5nIHdlYmNhbSBpbWFnZSBmb3Igc2V0ICR7c2V0TnVtYmVyfSB0byBwcm9jZXNzX2ltYWdlX2hhbmRsZXJgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gV2UncmUgcGFzc2luZyB0aGUgY2FwdHVyZSBkaXJlY3RvcnkgYW5kIGVuaGFuY2UgcGF0aCB0byBoZWxwIHdpdGggcGFyYW1ldGVyIGZpbGUgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpY3MgPSBhd2FpdCBwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uKHdlYmNhbVNyY1BhdGgsIHdlYmNhbURlc3RQYXRoLCBzZXROdW1iZXIsIGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG1ldHJpY3MpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBTdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIHdlYmNhbSBpbWFnZSBhbmQgZXh0cmFjdGVkIG1ldHJpY3MgZm9yIHNldCAke3NldE51bWJlcn1gKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2Fybihg4pqg77iPIFByb2Nlc3MgY29tcGxldGVkIGJ1dCBubyBtZXRyaWNzIHJldHVybmVkIGZvciBzZXQgJHtzZXROdW1iZXJ9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGltYWdlIGlzIGNvcGllZCBldmVuIGlmIG5vIG1ldHJpY3Mgd2VyZSByZXR1cm5lZFxuICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMod2ViY2FtRGVzdFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgZnMuY29weUZpbGVTeW5jKHdlYmNhbVNyY1BhdGgsIHdlYmNhbURlc3RQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ29waWVkIG9yaWdpbmFsIHdlYmNhbSBpbWFnZSBhcyBmYWxsYmFjayBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRXJyb3IgcHJvY2Vzc2luZyB3ZWJjYW0gaW1hZ2UgZm9yIHNldCAke3NldE51bWJlcn06ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvcHlpbmcgdGhlIG9yaWdpbmFsIGZpbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDb3B5aW5nIG9yaWdpbmFsIHdlYmNhbSBpbWFnZSBhcyBmYWxsYmFjayBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICAgICAgZnMuY29weUZpbGVTeW5jKHdlYmNhbVNyY1BhdGgsIHdlYmNhbURlc3RQYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gV2ViY2FtIGltYWdlIG5vdCBmb3VuZCBmb3Igc2V0ICR7c2V0TnVtYmVyfTogJHt3ZWJjYW1TcmNQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBQcm9jZXNzIHNjcmVlbiBpbWFnZSBpZiBpdCBleGlzdHNcbiAgICAgICAgY29uc3Qgc2NyZWVuU3JjUGF0aCA9IHBhdGguam9pbihjYXB0dXJlRGlyLCBgc2NyZWVuXyR7c2V0TnVtYmVyfS5qcGdgKTtcbiAgICAgICAgY29uc3Qgc2NyZWVuRGVzdFBhdGggPSBwYXRoLmpvaW4oZW5oYW5jZVBhdGgsIGBzY3JlZW5fZW5oYW5jZV8ke3NldE51bWJlcn0uanBnYCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgTG9va2luZyBmb3Igc2NyZWVuIGltYWdlIGF0OiAke3NjcmVlblNyY1BhdGh9YCk7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHNjcmVlblNyY1BhdGgpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYFNjcmVlbiBpbWFnZSBmb3VuZDogJHtzY3JlZW5TcmNQYXRofWApO1xuICAgICAgICAgIGZzLmNvcHlGaWxlU3luYyhzY3JlZW5TcmNQYXRoLCBzY3JlZW5EZXN0UGF0aCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYENvcGllZCBzY3JlZW4gaW1hZ2UgdG86ICR7c2NyZWVuRGVzdFBhdGh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gU2NyZWVuIGltYWdlIG5vdCBmb3VuZCBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIGEgcGFyYW1ldGVyIGZpbGUgZm9yIHRoaXMgc2V0IGluIHRoZSBlbmhhbmNlIGRpcmVjdG9yeVxuICAgICAgICBjb25zdCBlbmhhbmNlUGFyYW1QYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBgcGFyYW1ldGVyX2VuaGFuY2VfJHtzZXROdW1iZXJ9LmNzdmApO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhcmFtUGF0aCkpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUGFyYW1ldGVyIGZpbGUgbm90IGNyZWF0ZWQgZHVyaW5nIHByb2Nlc3NpbmcgZm9yIHNldCAke3NldE51bWJlcn0sIGNoZWNraW5nIGZvciBvcmlnaW5hbC4uLmApO1xuICAgICAgICAgIGF3YWl0IHVwZGF0ZVBhcmFtZXRlckZpbGUoc2V0TnVtYmVyLCBudWxsLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzc1xuICAgICAgICBwcm9ncmVzcy5wcm9jZXNzZWRTZXRzLnB1c2goc2V0TnVtYmVyKTtcbiAgICAgICAgcHJvZ3Jlc3MubGFzdFVwZGF0ZVRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgSlNPTi5zdHJpbmdpZnkocHJvZ3Jlc3MsIG51bGwsIDIpKTtcbiAgICAgICAgY29uc29sZS5sb2coYFVwZGF0ZWQgcHJvZ3Jlc3MgLSBzZXQgJHtzZXROdW1iZXJ9IGNvbXBsZXRlZGApO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGEgc21hbGwgZGVsYXkgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHN5c3RlbVxuICAgICAgICBjb25zb2xlLmxvZyhgV2FpdGluZyA1MDBtcyBiZWZvcmUgcHJvY2Vzc2luZyBuZXh0IHNldC4uLmApO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEVycm9yIHByb2Nlc3Npbmcgc2V0ICR7c2V0TnVtYmVyfTpgLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhcIlxcbj09PSBQUk9DRVNTSU5HIENPTVBMRVRFRCA9PT1cIik7XG4gICAgY29uc29sZS5sb2coYFRvdGFsIHNldHMgcHJvY2Vzc2VkOiAke3Byb2dyZXNzLnByb2Nlc3NlZFNldHMubGVuZ3RofS8ke3Byb2dyZXNzLnRvdGFsU2V0c31gKTtcbiAgICBcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIGRpcmVjdCBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29weSBwYXJhbWV0ZXIgZmlsZXNcbmFzeW5jIGZ1bmN0aW9uIGNvcHlQYXJhbWV0ZXJGaWxlKGNhcHR1cmVEaXIsIGVuaGFuY2VQYXRoLCBzZXROdW1iZXIpIHtcbiAgLy8gVHJ5IGJvdGggcGFyYW1ldGVyIGFuZCBwYXJhbWV0ZXJzIG5hbWluZ1xuICBjb25zdCBwYXJhbUZpbGVOYW1lcyA9IFtcbiAgICBgcGFyYW1ldGVyc18ke3NldE51bWJlcn0uY3N2YCxcbiAgICBgcGFyYW1ldGVyXyR7c2V0TnVtYmVyfS5jc3ZgXG4gIF07XG4gIFxuICBsZXQgcGFyYW1Gb3VuZCA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IHBhcmFtRmlsZU5hbWUgb2YgcGFyYW1GaWxlTmFtZXMpIHtcbiAgICBjb25zdCBwYXJhbVNyY1BhdGggPSBwYXRoLmpvaW4oY2FwdHVyZURpciwgcGFyYW1GaWxlTmFtZSk7XG4gICAgY29uc29sZS5sb2coYExvb2tpbmcgZm9yIHBhcmFtZXRlciBmaWxlIGF0OiAke3BhcmFtU3JjUGF0aH1gKTtcbiAgICBcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXJhbVNyY1BhdGgpKSB7XG4gICAgICBjb25zb2xlLmxvZyhgUGFyYW1ldGVyIGZpbGUgZm91bmQ6ICR7cGFyYW1TcmNQYXRofWApO1xuICAgICAgcGFyYW1Gb3VuZCA9IHRydWU7XG4gICAgICBcbiAgICAgIC8vIERldGVybWluZSBkZXN0aW5hdGlvbiBuYW1lIChjaGFuZ2UgcGFyYW1ldGVyIHRvIHBhcmFtZXRlcl9lbmhhbmNlKVxuICAgICAgY29uc3QgZGVzdEZpbGVOYW1lID0gJ3BhcmFtZXRlcl9lbmhhbmNlXycgKyBzZXROdW1iZXIgKyAnLmNzdic7XG4gICAgICBjb25zdCBwYXJhbURlc3RQYXRoID0gcGF0aC5qb2luKGVuaGFuY2VQYXRoLCBkZXN0RmlsZU5hbWUpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQ29weWluZyBwYXJhbWV0ZXIgZmlsZSB0bzogJHtwYXJhbURlc3RQYXRofWApO1xuICAgICAgZnMuY29weUZpbGVTeW5jKHBhcmFtU3JjUGF0aCwgcGFyYW1EZXN0UGF0aCk7XG4gICAgICBcbiAgICAgIC8vIFZlcmlmeSBwYXJhbWV0ZXIgZmlsZSBjb3B5XG4gICAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXJhbURlc3RQYXRoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIFBhcmFtZXRlciBmaWxlIGNvcGllZCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlYWQgY29udGVudCB0byB2ZXJpZnlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKHBhcmFtRGVzdFBhdGgsICd1dGY4Jyk7XG4gICAgICAgICAgY29uc3QgZmlyc3RMaW5lID0gY29udGVudC5zcGxpdCgnXFxuJylbMF07XG4gICAgICAgICAgY29uc29sZS5sb2coYFBhcmFtZXRlciBmaWxlIGNvbnRlbnQgc3RhcnRzIHdpdGg6ICR7Zmlyc3RMaW5lfWApO1xuICAgICAgICB9IGNhdGNoIChyZWFkRXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBwYXJhbWV0ZXIgZmlsZTogJHtyZWFkRXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBFcnJvcjogUGFyYW1ldGVyIGRlc3RpbmF0aW9uIGZpbGUgZG9lc24ndCBleGlzdCBhZnRlciBjb3B5IWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBicmVhazsgLy8gRm91bmQgYW5kIGNvcGllZCBvbmUgcGFyYW1ldGVyIGZpbGUsIG5vIG5lZWQgdG8gY2hlY2sgdGhlIG90aGVyXG4gICAgfVxuICB9XG4gIFxuICBpZiAoIXBhcmFtRm91bmQpIHtcbiAgICBjb25zb2xlLmxvZyhg4pqg77iPIE5vIHBhcmFtZXRlciBmaWxlcyBmb3VuZCBmb3Igc2V0ICR7c2V0TnVtYmVyfWApO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhbiBlbXB0eSBwYXJhbWV0ZXIgZmlsZSBpZiBub25lIGV4aXN0c1xuICAgIGNvbnN0IHBhcmFtRGVzdFBhdGggPSBwYXRoLmpvaW4oZW5oYW5jZVBhdGgsIGBwYXJhbWV0ZXJfZW5oYW5jZV8ke3NldE51bWJlcn0uY3N2YCk7XG4gICAgY29uc3QgZW1wdHlDb250ZW50ID0gJ1BhcmFtZXRlcixWYWx1ZVxcbmluZm8sTm8gZmFjZSBkZXRlY3RlZCBvciBwcm9jZXNzaW5nIGZhaWxlZFxcbic7XG4gICAgZnMud3JpdGVGaWxlU3luYyhwYXJhbURlc3RQYXRoLCBlbXB0eUNvbnRlbnQpO1xuICAgIGNvbnNvbGUubG9nKGDimqDvuI8gQ3JlYXRlZCBlbXB0eSBwYXJhbWV0ZXIgZmlsZTogJHtwYXJhbURlc3RQYXRofWApO1xuICB9XG59XG5cbi8vIE1haW4gaGFuZGxlciBmb3IgQVBJIHJlcXVlc3RzXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcSwgcmVzKSB7XG4gIC8vIEhhbmRsZSBHRVQgcmVxdWVzdCB0byBjaGVjayBwcm9jZXNzaW5nIHN0YXR1c1xuICBpZiAocmVxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FwdHVyZXNQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyk7XG4gICAgICBjb25zdCBlbmhhbmNlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ2VuaGFuY2UnKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGNhcHR1cmVzIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMocGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnKSkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJyksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgY2FwdHVyZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKGNhcHR1cmVzUGF0aCkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKGNhcHR1cmVzUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBlbmhhbmNlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhdGgpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhlbmhhbmNlUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3MgYSBwcm9jZXNzaW5nLmxvY2sgZmlsZSAoaW5kaWNhdGluZyBwcm9jZXNzaW5nIGlzIGluIHByb2dyZXNzKVxuICAgICAgY29uc3QgbG9ja0ZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAncHJvY2Vzc2luZy5sb2NrJyk7XG4gICAgICBjb25zdCBpc1Byb2Nlc3NpbmcgPSBmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGZvciBwcm9ncmVzcyBpbmZvcm1hdGlvbiBmaWxlXG4gICAgICBjb25zdCBwcm9ncmVzc0ZpbGVQYXRoID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdwdWJsaWMnLCAnY2FwdHVyZXMnLCAncHJvY2Vzc2luZ19wcm9ncmVzcy5qc29uJyk7XG4gICAgICBsZXQgcHJvZ3Jlc3NJbmZvID0geyBcbiAgICAgICAgY3VycmVudFNldDogMCxcbiAgICAgICAgdG90YWxTZXRzOiAwLFxuICAgICAgICBwcm9jZXNzZWRTZXRzOiBbXSxcbiAgICAgICAgc3RhcnRUaW1lOiBudWxsLFxuICAgICAgICBsYXN0VXBkYXRlVGltZTogbnVsbFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocHJvZ3Jlc3NGaWxlUGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwcm9ncmVzc0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMocHJvZ3Jlc3NGaWxlUGF0aCwgJ3V0ZjgnKTtcbiAgICAgICAgICBwcm9ncmVzc0luZm8gPSBKU09OLnBhcnNlKHByb2dyZXNzRGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZWFkaW5nIHByb2dyZXNzIGZpbGU6XCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ291bnQgZmlsZXMgaW4gZWFjaCBkaXJlY3RvcnlcbiAgICAgIGNvbnN0IGNhcHR1cmVGaWxlcyA9IGZzLmV4aXN0c1N5bmMoY2FwdHVyZXNQYXRoKSBcbiAgICAgICAgPyBmcy5yZWFkZGlyU3luYyhjYXB0dXJlc1BhdGgpLmZpbHRlcihmaWxlID0+IFxuICAgICAgICAgICAgZmlsZS5zdGFydHNXaXRoKCd3ZWJjYW1fJykgJiYgZmlsZS5lbmRzV2l0aCgnLmpwZycpKS5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgICAgICBcbiAgICAgIGNvbnN0IGVuaGFuY2VGaWxlcyA9IGZzLmV4aXN0c1N5bmMoZW5oYW5jZVBhdGgpXG4gICAgICAgID8gZnMucmVhZGRpclN5bmMoZW5oYW5jZVBhdGgpLmZpbHRlcihmaWxlID0+IFxuICAgICAgICAgICAgZmlsZS5zdGFydHNXaXRoKCd3ZWJjYW1fZW5oYW5jZV8nKSAmJiBmaWxlLmVuZHNXaXRoKCcuanBnJykpLmxlbmd0aFxuICAgICAgICA6IDA7XG4gICAgICBcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGlzUHJvY2Vzc2luZyxcbiAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlRmlsZXMsXG4gICAgICAgIGVuaGFuY2VDb3VudDogZW5oYW5jZUZpbGVzLFxuICAgICAgICBuZWVkc1Byb2Nlc3Npbmc6IGNhcHR1cmVGaWxlcyA+IGVuaGFuY2VGaWxlcyxcbiAgICAgICAgcHJvZ3Jlc3M6IHByb2dyZXNzSW5mb1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHByb2Nlc3Mgc3RhdHVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8vIEhhbmRsZSBQT1NUIHJlcXVlc3QgdG8gdHJpZ2dlciBwcm9jZXNzaW5nXG4gIGVsc2UgaWYgKHJlcS5tZXRob2QgPT09ICdQT1NUJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgbGlzdCBvZiBmaWxlcyB0byBwcm9jZXNzIGZyb20gcmVxdWVzdCBib2R5XG4gICAgICBjb25zdCB7IHNldE51bWJlcnMgfSA9IHJlcS5ib2R5O1xuICAgICAgXG4gICAgICBpZiAoIXNldE51bWJlcnMgfHwgIUFycmF5LmlzQXJyYXkoc2V0TnVtYmVycykgfHwgc2V0TnVtYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ05vIHNldCBudW1iZXJzIHByb3ZpZGVkIGZvciBwcm9jZXNzaW5nJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkaXJlY3RvcnkgZXhpc3RzIGJlZm9yZSBjcmVhdGluZyB0aGUgbG9jayBmaWxlXG4gICAgICBjb25zdCBjYXB0dXJlc0RpciA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJyk7XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoY2FwdHVyZXNEaXIpKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhjYXB0dXJlc0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBlbmhhbmNlIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICBjb25zdCBlbmhhbmNlUGF0aCA9IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAncHVibGljJywgJ2NhcHR1cmVzJywgJ2VuaGFuY2UnKTtcbiAgICAgIGlmICghZnMuZXhpc3RzU3luYyhlbmhhbmNlUGF0aCkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKGVuaGFuY2VQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhbHJlYWR5IGEgbG9jayBmaWxlXG4gICAgICBjb25zdCBsb2NrRmlsZVBhdGggPSBwYXRoLmpvaW4oY2FwdHVyZXNEaXIsICdwcm9jZXNzaW5nLmxvY2snKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA5KS5qc29uKHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogJ1Byb2Nlc3NpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzcydcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBsb2NrIGZpbGUgdG8gaW5kaWNhdGUgcHJvY2Vzc2luZyBpcyBpbiBwcm9ncmVzc1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhsb2NrRmlsZVBhdGgsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGVkIGxvY2sgZmlsZSBhdCAke2xvY2tGaWxlUGF0aH1gKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBsb2NrIGZpbGU6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDUwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IGBGYWlsZWQgdG8gY3JlYXRlIGxvY2sgZmlsZTogJHtlcnIubWVzc2FnZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgaW5pdGlhbCBwcm9ncmVzcyBmaWxlXG4gICAgICBjb25zdCBwcm9ncmVzc0ZpbGVQYXRoID0gcGF0aC5qb2luKGNhcHR1cmVzRGlyLCAncHJvY2Vzc2luZ19wcm9ncmVzcy5qc29uJyk7XG4gICAgICBjb25zdCBwcm9ncmVzc0luZm8gPSB7XG4gICAgICAgIGN1cnJlbnRTZXQ6IDAsXG4gICAgICAgIHRvdGFsU2V0czogc2V0TnVtYmVycy5sZW5ndGgsXG4gICAgICAgIHByb2Nlc3NlZFNldHM6IFtdLFxuICAgICAgICBzdGFydFRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgbGFzdFVwZGF0ZVRpbWU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhwcm9ncmVzc0ZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShwcm9ncmVzc0luZm8sIG51bGwsIDIpKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjcmVhdGluZyBwcm9ncmVzcyBmaWxlOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEZWZpbmUgcGF0aHMgZm9yIHByb2Nlc3NpbmdcbiAgICAgIGNvbnN0IGNhcHR1cmVEaXIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycsICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnKTtcbiAgICAgIFxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHByb2Nlc3NpbmcgbWV0aG9kIHRvIHVzZVxuICAgICAgY29uc3QgdXNlQmFja2VuZCA9IHByb2Nlc3MuZW52LlVTRV9QWVRIT05fQkFDS0VORCA9PT0gJ3RydWUnO1xuICAgICAgXG4gICAgICBpZiAodXNlQmFja2VuZCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgYmFja2VuZCBwcm9jZXNzaW5nIG9mICR7c2V0TnVtYmVycy5sZW5ndGh9IHNldHMuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHByb2Nlc3Npbmcgd2l0aCB0aGUgUHl0aG9uIGJhY2tlbmRcbiAgICAgICAgcHJvY2Vzc0ZpbGVzVmlhQmFja2VuZChzZXROdW1iZXJzKVxuICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQmFja2VuZCBwcm9jZXNzaW5nIGNvbXBsZXRlZCB3aXRoIHJlc3VsdDonLCByZXN1bHQpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIGxvY2sgZmlsZSB3aGVuIGRvbmVcbiAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhsb2NrRmlsZVBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdCYWNrZW5kIHByb2Nlc3NpbmcgZmFpbGVkOicsIGVycik7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbG9jayBmaWxlIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgIGZzLnVubGlua1N5bmMobG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiAnUHJvY2Vzc2luZyBzdGFydGVkJyxcbiAgICAgICAgICBzZXRzVG9Qcm9jZXNzOiBzZXROdW1iZXJzLmxlbmd0aCxcbiAgICAgICAgICBwcm9jZXNzaW5nTWV0aG9kOiAncHl0aG9uLWJhY2tlbmQnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGRpcmVjdCBwcm9jZXNzaW5nIG9mICR7c2V0TnVtYmVycy5sZW5ndGh9IHNldHMuLi5gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmcgaW4gdGhlIGJhY2tncm91bmQgdXNpbmcgZGlyZWN0IE5vZGUuanMgcHJvY2Vzc2luZ1xuICAgICAgICBwcm9jZXNzRmlsZXNEaXJlY3RseShzZXROdW1iZXJzLCBjYXB0dXJlRGlyLCBlbmhhbmNlUGF0aCwgcHJvZ3Jlc3NGaWxlUGF0aClcbiAgICAgICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgY29tcGxldGVkIHdpdGggcmVzdWx0OicsIHJlc3VsdCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbG9jayBmaWxlIHdoZW4gZG9uZVxuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMobG9ja0ZpbGVQYXRoKSkge1xuICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Byb2Nlc3NpbmcgZmFpbGVkOicsIGVycik7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgbG9jayBmaWxlIG9uIGVycm9yXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhsb2NrRmlsZVBhdGgpKSB7XG4gICAgICAgICAgICAgIGZzLnVubGlua1N5bmMobG9ja0ZpbGVQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXMuc3RhdHVzKDIwMCkuanNvbih7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiAnUHJvY2Vzc2luZyBzdGFydGVkJyxcbiAgICAgICAgICBzZXRzVG9Qcm9jZXNzOiBzZXROdW1iZXJzLmxlbmd0aCxcbiAgICAgICAgICBwcm9jZXNzaW5nTWV0aG9kOiAnZGlyZWN0J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdHJpZ2dlcmluZyBwcm9jZXNzaW5nOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciwgbWFrZSBzdXJlIHRvIGRlbGV0ZSB0aGUgbG9jayBmaWxlXG4gICAgICBjb25zdCBsb2NrRmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3B1YmxpYycsICdjYXB0dXJlcycsICdwcm9jZXNzaW5nLmxvY2snKTtcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKGxvY2tGaWxlUGF0aCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy51bmxpbmtTeW5jKGxvY2tGaWxlUGF0aCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBsb2NrIGZpbGU6JywgZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNTAwKS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgXG4gICAgICBzdWNjZXNzOiBmYWxzZSwgXG4gICAgICBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgXG4gICAgfSk7XG4gIH1cbn0iXSwibmFtZXMiOlsiZnMiLCJwYXRoIiwiZXhlYyIsInV0aWwiLCJmZXRjaCIsIkZvcm1EYXRhIiwiZXhlY1Byb21pc2UiLCJwcm9taXNpZnkiLCJwcm9jZXNzSW1hZ2VXaXRoUHl0aG9uIiwiaW5wdXRQYXRoIiwib3V0cHV0UGF0aCIsInNldE51bWJlciIsImNhcHR1cmVEaXIiLCJlbmhhbmNlUGF0aCIsImNvbnNvbGUiLCJsb2ciLCJleGlzdHNTeW5jIiwiZXJyb3IiLCJiYWNrZW5kVXJsIiwicHJvY2VzcyIsImVudiIsIkJBQ0tFTkRfVVJMIiwiYXBpS2V5IiwiQVBJX0tFWSIsImZvcm1EYXRhIiwiZmlsZVN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJzdGF0cyIsInN0YXRTeW5jIiwic2l6ZSIsImFwcGVuZCIsImZpbGVuYW1lIiwiYmFzZW5hbWUiLCJjb250ZW50VHlwZSIsInJlc3BvbnNlIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJ0aW1lb3V0Iiwic3RhdHVzIiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiZSIsInN0YXR1c1RleHQiLCJFcnJvciIsInJlc3VsdCIsInJlc3BvbnNlVGV4dCIsInN1YnN0cmluZyIsIkpTT04iLCJwYXJzZSIsIm1lc3NhZ2UiLCJzdWNjZXNzIiwiZmFjZV9kZXRlY3RlZCIsImNvcHlGaWxlU3luYyIsInVwZGF0ZVBhcmFtZXRlckZpbGUiLCJpbWFnZSIsImRhdGEiLCJ3aWR0aCIsImhlaWdodCIsImltYWdlQnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsIndyaXRlRmlsZVN5bmMiLCJsZW5ndGgiLCJtZXRyaWNzIiwic3RyaW5naWZ5Iiwic3RhY2siLCJjb3B5RXJyb3IiLCJvcmlnaW5hbFBhcmFtUGF0aHMiLCJqb2luIiwicGFyYW1EZXN0UGF0aCIsIm9yaWdpbmFsUGFyYW1zIiwiTWFwIiwib3JpZ2luYWxQYXJhbUZvdW5kIiwib3JpZ2luYWxGaXJzdExpbmVJc0hlYWRlciIsIm9yaWdpbmFsUGF0aCIsImNvbnRlbnQiLCJyZWFkRmlsZVN5bmMiLCJsaW5lcyIsInNwbGl0IiwiZmlyc3RMaW5lIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiaW5jbHVkZXMiLCJzdGFydExpbmUiLCJpIiwibGluZSIsInBhcnRzIiwicGFyYW1OYW1lIiwicGFyYW1WYWx1ZSIsInNldCIsImVyciIsImNzdkNvbnRlbnQiLCJleGNsdWRlUGFyYW1zIiwiZm9yRWFjaCIsInZhbHVlIiwia2V5IiwiaGVhZF9wb3NlIiwicGl0Y2giLCJ5YXciLCJyb2xsIiwiZXllX2NlbnRlcnMiLCJsZWZ0IiwicmlnaHQiLCJmYWNlX2JveCIsIm1pbiIsIm1heCIsImZhY2VXaWR0aCIsIk1hdGgiLCJyb3VuZCIsImZhY2VIZWlnaHQiLCJmaWVsZHNUb1ByZXNlcnZlIiwiZmllbGQiLCJoYXMiLCJnZXQiLCJwcm9jZXNzRmlsZXNWaWFCYWNrZW5kIiwic2V0TnVtYmVycyIsInNldF9udW1iZXJzIiwic2hvd19oZWFkX3Bvc2UiLCJzaG93X2JvdW5kaW5nX2JveCIsInNob3dfbWFzayIsInNob3dfcGFyYW1ldGVycyIsImpzb24iLCJwcm9jZXNzRmlsZXNEaXJlY3RseSIsInByb2dyZXNzRmlsZVBhdGgiLCJwcm9ncmVzcyIsImN1cnJlbnRTZXQiLCJ0b3RhbFNldHMiLCJwcm9jZXNzZWRTZXRzIiwic3RhcnRUaW1lIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibGFzdFVwZGF0ZVRpbWUiLCJ3ZWJjYW1TcmNQYXRoIiwid2ViY2FtRGVzdFBhdGgiLCJ3YXJuIiwic2NyZWVuU3JjUGF0aCIsInNjcmVlbkRlc3RQYXRoIiwiZW5oYW5jZVBhcmFtUGF0aCIsInB1c2giLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb3B5UGFyYW1ldGVyRmlsZSIsInBhcmFtRmlsZU5hbWVzIiwicGFyYW1Gb3VuZCIsInBhcmFtRmlsZU5hbWUiLCJwYXJhbVNyY1BhdGgiLCJkZXN0RmlsZU5hbWUiLCJyZWFkRXJyIiwiZW1wdHlDb250ZW50IiwiaGFuZGxlciIsInJlcSIsInJlcyIsImNhcHR1cmVzUGF0aCIsImN3ZCIsIm1rZGlyU3luYyIsInJlY3Vyc2l2ZSIsImxvY2tGaWxlUGF0aCIsImlzUHJvY2Vzc2luZyIsInByb2dyZXNzSW5mbyIsInByb2dyZXNzRGF0YSIsImNhcHR1cmVGaWxlcyIsInJlYWRkaXJTeW5jIiwiZmlsdGVyIiwiZmlsZSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImVuaGFuY2VGaWxlcyIsImNhcHR1cmVDb3VudCIsImVuaGFuY2VDb3VudCIsIm5lZWRzUHJvY2Vzc2luZyIsIkFycmF5IiwiaXNBcnJheSIsImNhcHR1cmVzRGlyIiwidXNlQmFja2VuZCIsIlVTRV9QWVRIT05fQkFDS0VORCIsInRoZW4iLCJ1bmxpbmtTeW5jIiwiY2F0Y2giLCJzZXRzVG9Qcm9jZXNzIiwicHJvY2Vzc2luZ01ldGhvZCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api-node)/./pages/api/for-process-folder/process-status-api.js\n");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "form-data":
/*!****************************!*\
  !*** external "form-data" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("form-data");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "node-fetch":
/*!*****************************!*\
  !*** external "node-fetch" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-fetch");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api-node)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Ffor-process-folder%2Fprocess-status-api&preferredRegion=&absolutePagePath=.%2Fpages%2Fapi%2Ffor-process-folder%2Fprocess-status-api.js&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();