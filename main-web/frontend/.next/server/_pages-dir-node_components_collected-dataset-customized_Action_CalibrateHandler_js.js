"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_CalibrateHandler_js";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_CalibrateHandler_js"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/CalibrateHandler.js":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CalibrateHandler.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CaptureHandler */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/CaptureHandler.js\");\n/* harmony import */ var _DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotCaptureUtil */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/DotCaptureUtil.js\");\n// CalibrateHandler.js - Using the existing CaptureHandler class\n\n\n\nclass CalibrateHandler {\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Create a CaptureHandler instance for handling the captures\n        this.captureHandler = new _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__[\"default\"](// Pass saveImageToServer function\n        async (imageData, filename, type, folder)=>{\n            try {\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type,\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    console.warn(`Server responded with ${response.status}`);\n                    return {};\n                }\n                return await response.json();\n            } catch (err) {\n                console.error(`Error saving ${type}:`, err);\n                return {};\n            }\n        }, // Pass setCaptureCounter function\n        (newCounter)=>{\n            if (typeof newCounter === 'function') {\n                this.captureCounter = newCounter(this.captureCounter);\n            } else {\n                this.captureCounter = newCounter;\n            }\n            if (this.setCaptureCounter) {\n                this.setCaptureCounter(this.captureCounter);\n            }\n        }, // Pass setProcessStatus function\n        (status)=>{\n            if (this.setOutputText) {\n                this.setOutputText(status);\n            }\n        }, // Pass toggleTopBar function\n        this.toggleTopBar);\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = `\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      background-color: rgba(0, 102, 204, 0.9);\n      color: white;\n      font-size: 14px;\n      font-weight: bold;\n      padding: 8px 12px;\n      border-radius: 6px;\n      z-index: 9999;\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n    `;\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Processing point ${index + 1}/${total}`;\n            }\n            // Draw the dot\n            const canvas = this.canvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            const ctx = canvas.getContext('2d');\n            (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n            // Create countdown element\n            const canvasRect = canvas.getBoundingClientRect();\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'calibrate-countdown';\n            countdownElement.style.cssText = `\n        position: fixed;\n        left: ${canvasRect.left + point.x}px;\n        top: ${canvasRect.top + point.y - 60}px;\n        transform: translateX(-50%);\n        color: red;\n        font-size: 36px;\n        font-weight: bold;\n        text-shadow: 0 0 10px white, 0 0 20px white;\n        z-index: 9999;\n        background-color: rgba(255, 255, 255, 0.8);\n        border: 2px solid red;\n        border-radius: 50%;\n        width: 50px;\n        height: 50px;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n      `;\n            document.body.appendChild(countdownElement);\n            // Run countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                this.setOutputText?.(`Point ${index + 1}/${total} - countdown ${count}`);\n                // Make sure dot remains visible during countdown\n                (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n                // Wait for next countdown step\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            // Show capturing indicator\n            countdownElement.textContent = \"âœ“\";\n            this.setOutputText?.(`Capturing point ${index + 1}/${total}`);\n            // Remove countdown element\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Use CaptureHandler to handle the capture process\n            const captureResult = await this.captureHandler.captureAndShowPreview(this.captureCounter, this.canvasRef, point);\n            // Add null check before using the result\n            if (!captureResult) {\n                console.warn(`No capture result for point ${index + 1}`);\n            // You might want to set a default or retry logic here\n            }\n            // Wait for the preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2500));\n            return true;\n        } catch (err) {\n            console.error(`Error processing point ${index + 1}:`, err);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Error: ${err.message}`;\n            }\n            this.setOutputText?.(`Error: ${err.message}`);\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        if (this.toggleTopBar) {\n            this.toggleTopBar(false);\n        }\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            this.setOutputText?.(`Starting calibration with ${this.calibrationPoints.length} points`);\n            let successCount = 0;\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (success) {\n                    successCount++;\n                }\n                // Small delay between points\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            this.setOutputText?.(`Calibration completed: ${successCount}/${this.calibrationPoints.length} points captured`);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = `Calibration complete: ${successCount}/${this.calibrationPoints.length} points`;\n            }\n            // Turn TopBar back on\n            if (this.toggleTopBar) {\n                this.toggleTopBar(true);\n            }\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        } catch (error) {\n            // console.error('Calibration error:', error);\n            // this.setOutputText?.(`Calibration error: ${error.message}`);\n            // if (this.statusIndicator) {\n            //   this.statusIndicator.textContent = `Error: ${error.message}`;\n            // }\n            // // Make sure we turn TopBar back on even on error\n            // if (this.toggleTopBar) {\n            //   this.toggleTopBar(true);\n            // }\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 1500);\n            // Return a default object to prevent null reference errors\n            return {\n                screenImage: '',\n                webcamImage: '',\n                success: false\n            };\n        } finally{\n            this.isProcessing = false;\n            // Remove the status indicator after a delay\n            setTimeout(()=>{\n                if (this.statusIndicator && this.statusIndicator.parentNode) {\n                    this.statusIndicator.parentNode.removeChild(this.statusIndicator);\n                }\n            }, 3000);\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsZ0VBQWdFO0FBQ0Y7QUFDaEI7QUFDQTtBQUU5QyxNQUFNRztJQUNKQyxZQUFZQyxNQUFNLENBQUU7UUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdELE9BQU9DLFNBQVM7UUFDakMsSUFBSSxDQUFDQyxZQUFZLEdBQUdGLE9BQU9FLFlBQVk7UUFDdkMsSUFBSSxDQUFDQyxhQUFhLEdBQUdILE9BQU9HLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxjQUFjLEdBQUdKLE9BQU9JLGNBQWMsSUFBSTtRQUMvQyxJQUFJLENBQUNDLGlCQUFpQixHQUFHTCxPQUFPSyxpQkFBaUI7UUFDakQsSUFBSSxDQUFDQyxhQUFhLEdBQUdOLE9BQU9NLGFBQWEsSUFBSTtRQUM3QyxJQUFJLENBQUNDLFVBQVUsR0FBR1AsT0FBT08sVUFBVTtRQUVuQyxtRUFBbUU7UUFDbkUsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR1IsT0FBT1EsaUJBQWlCLElBQUksRUFBRTtRQUV2RCw2REFBNkQ7UUFDN0QsSUFBSSxDQUFDQyxjQUFjLEdBQUcsSUFBSWIsdURBQWNBLENBQ3RDLGtDQUFrQztRQUNsQyxPQUFPYyxXQUFXQyxVQUFVQyxNQUFNQztZQUNoQyxJQUFJO2dCQUNGLE1BQU1DLFdBQVcsTUFBTUMsTUFBTSxxQkFBcUI7b0JBQ2hEQyxRQUFRO29CQUNSQyxTQUFTO3dCQUNQLGdCQUFnQjtvQkFDbEI7b0JBQ0FDLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQzt3QkFDbkJWO3dCQUNBQzt3QkFDQUM7d0JBQ0FDLFFBQVEsSUFBSSxDQUFDUCxhQUFhO29CQUM1QjtnQkFDRjtnQkFFQSxJQUFJLENBQUNRLFNBQVNPLEVBQUUsRUFBRTtvQkFDaEJDLFFBQVFDLElBQUksQ0FBQyxDQUFDLHNCQUFzQixFQUFFVCxTQUFT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a0QsZ0JBQWdCLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUMsWUFBWWxELE1BQU0wQyxPQUFPO1lBQ2pEO1lBRUEsK0NBQStDO1lBQy9DTCxXQUFXO2dCQUNULElBQUksT0FBTyxJQUFJLENBQUM5RCxZQUFZLEtBQUssWUFBWTtvQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7Z0JBQ3BCLE9BQU8sSUFBSSxLQUFvRCxFQUFFLEVBRWhFO1lBQ0gsR0FBRztZQUVILDJEQUEyRDtZQUMzRCxPQUFPO2dCQUNMNkUsYUFBYTtnQkFDYkMsYUFBYTtnQkFDYkosU0FBUztZQUNYO1FBQ0YsU0FBVTtZQUNSLElBQUksQ0FBQy9DLFlBQVksR0FBRztZQUVwQiw0Q0FBNEM7WUFDNUNtQyxXQUFXO2dCQUNULElBQUksSUFBSSxDQUFDakMsZUFBZSxJQUFJLElBQUksQ0FBQ0EsZUFBZSxDQUFDa0MsVUFBVSxFQUFFO29CQUMzRCxJQUFJLENBQUNsQyxlQUFlLENBQUNrQyxVQUFVLENBQUNDLFdBQVcsQ0FBQyxJQUFJLENBQUNuQyxlQUFlO2dCQUNsRTtZQUNGLEdBQUc7UUFDTDtJQUNGO0FBQ0Y7QUFFQSxpRUFBZWpDLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3BvcmNocG9ydGFsMi9EZXNrdG9wL/CflKVldmVyeXRoaW5nL01haW5fV2ViX0V5ZVRyYWNraW5nL21haW4td2ViL2Zyb250ZW5kL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWxpYnJhdGVIYW5kbGVyLmpzIC0gVXNpbmcgdGhlIGV4aXN0aW5nIENhcHR1cmVIYW5kbGVyIGNsYXNzXG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IENhcHR1cmVIYW5kbGVyIGZyb20gJy4vQ2FwdHVyZUhhbmRsZXInO1xuaW1wb3J0IHsgZHJhd1JlZERvdCB9IGZyb20gJy4vRG90Q2FwdHVyZVV0aWwnO1xuXG5jbGFzcyBDYWxpYnJhdGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldE91dHB1dFRleHQgPSBjb25maWcuc2V0T3V0cHV0VGV4dDtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyIHx8IDE7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVGb2xkZXIgPSBjb25maWcuY2FwdHVyZUZvbGRlciB8fCAnZXllX3RyYWNraW5nX2NhcHR1cmVzJztcbiAgICB0aGlzLm9uQ29tcGxldGUgPSBjb25maWcub25Db21wbGV0ZTtcblxuICAgIC8vIEFjY2VwdCBwYXNzZWQtaW4gY2FsaWJyYXRpb24gcG9pbnRzIChmcm9tIFNldENhbGlicmF0ZUFjdGlvbi5qcylcbiAgICB0aGlzLmNhbGlicmF0aW9uUG9pbnRzID0gY29uZmlnLmNhbGlicmF0aW9uUG9pbnRzIHx8IFtdO1xuXG4gICAgLy8gQ3JlYXRlIGEgQ2FwdHVyZUhhbmRsZXIgaW5zdGFuY2UgZm9yIGhhbmRsaW5nIHRoZSBjYXB0dXJlc1xuICAgIHRoaXMuY2FwdHVyZUhhbmRsZXIgPSBuZXcgQ2FwdHVyZUhhbmRsZXIoXG4gICAgICAvLyBQYXNzIHNhdmVJbWFnZVRvU2VydmVyIGZ1bmN0aW9uXG4gICAgICBhc3luYyAoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgdHlwZSwgZm9sZGVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCgnL2FwaS9zYXZlLWNhcHR1cmUnLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgZm9sZGVyOiB0aGlzLmNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyAke3R5cGV9OmAsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUGFzcyBzZXRDYXB0dXJlQ291bnRlciBmdW5jdGlvblxuICAgICAgKG5ld0NvdW50ZXIpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdDb3VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IG5ld0NvdW50ZXIodGhpcy5jYXB0dXJlQ291bnRlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IG5ld0NvdW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0aGlzLnNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcih0aGlzLmNhcHR1cmVDb3VudGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFBhc3Mgc2V0UHJvY2Vzc1N0YXR1cyBmdW5jdGlvblxuICAgICAgKHN0YXR1cykgPT4ge1xuICAgICAgICBpZiAodGhpcy5zZXRPdXRwdXRUZXh0KSB7XG4gICAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0KHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIHRvZ2dsZVRvcEJhciBmdW5jdGlvblxuICAgICAgdGhpcy50b2dnbGVUb3BCYXJcbiAgICApO1xuXG4gICAgLy8gSW50ZXJuYWxzXG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRQb2ludEluZGV4ID0gMDtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gIH1cblxuICBjcmVhdGVTdGF0dXNJbmRpY2F0b3IoKSB7XG4gICAgY29uc3QgZXhpc3RpbmdJbmRpY2F0b3JzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJyk7XG4gICAgZXhpc3RpbmdJbmRpY2F0b3JzLmZvckVhY2goaW5kaWNhdG9yID0+IGluZGljYXRvci5yZW1vdmUoKSk7XG5cbiAgICBjb25zdCBpbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBpbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICBpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIHRvcDogMTBweDtcbiAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICB0aGlzLnN0YXR1c0luZGljYXRvciA9IGluZGljYXRvcjtcbiAgICByZXR1cm4gaW5kaWNhdG9yO1xuICB9XG5cbiAgYXN5bmMgcHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQocG9pbnQsIGluZGV4LCB0b3RhbCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXBvaW50IHx8IHR5cGVvZiBwb2ludC54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9pbnQueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYWxpYnJhdGlvbiBwb2ludFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYFByb2Nlc3NpbmcgcG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9YDtcbiAgICAgIH1cblxuICAgICAgLy8gRHJhdyB0aGUgZG90XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBsZWZ0OiAke2NhbnZhc1JlY3QubGVmdCArIHBvaW50Lnh9cHg7XG4gICAgICAgIHRvcDogJHtjYW52YXNSZWN0LnRvcCArIHBvaW50LnkgLSA2MH1weDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIFJ1biBjb3VudGRvd25cbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYFBvaW50ICR7aW5kZXggKyAxfS8ke3RvdGFsfSAtIGNvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCByZW1haW5zIHZpc2libGUgZHVyaW5nIGNvdW50ZG93blxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGZvciBuZXh0IGNvdW50ZG93biBzdGVwXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBjYXB0dXJpbmcgaW5kaWNhdG9yXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBDYXB0dXJpbmcgcG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9YCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBDYXB0dXJlSGFuZGxlciB0byBoYW5kbGUgdGhlIGNhcHR1cmUgcHJvY2Vzc1xuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IHRoaXMuY2FwdHVyZUhhbmRsZXIuY2FwdHVyZUFuZFNob3dQcmV2aWV3KFxuICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICB0aGlzLmNhbnZhc1JlZixcbiAgICAgICAgcG9pbnRcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBudWxsIGNoZWNrIGJlZm9yZSB1c2luZyB0aGUgcmVzdWx0XG4gICAgICBpZiAoIWNhcHR1cmVSZXN1bHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBjYXB0dXJlIHJlc3VsdCBmb3IgcG9pbnQgJHtpbmRleCArIDF9YCk7XG4gICAgICAgIC8vIFlvdSBtaWdodCB3YW50IHRvIHNldCBhIGRlZmF1bHQgb3IgcmV0cnkgbG9naWMgaGVyZVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciB0aGUgcHJldmlldyB0byBjb21wbGV0ZVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDI1MDApKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHBvaW50ICR7aW5kZXggKyAxfTpgLCBlcnIpO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICB9XG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgc3RhcnRDYWxpYnJhdGlvbigpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cblxuXG4gICAgaWYgKHRoaXMudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5kaWNhdG9yID0gdGhpcy5jcmVhdGVTdGF0dXNJbmRpY2F0b3IoKTtcbiAgICBpbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnSW5pdGlhbGl6aW5nIGNhbGlicmF0aW9uLi4uJztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMgfHwgY2FudmFzLndpZHRoID09PSAwIHx8IGNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW52YXMgaXMgbm90IHJlYWR5Jyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgZ2VuZXJhdGUgaWYgbm9uZSB3ZXJlIHBhc3NlZCBpblxuICAgICAgaWYgKCF0aGlzLmNhbGlicmF0aW9uUG9pbnRzIHx8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNhbGlicmF0aW9uUG9pbnRzIHx8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYFN0YXJ0aW5nIGNhbGlicmF0aW9uIHdpdGggJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH0gcG9pbnRzYCk7XG4gICAgICBcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnByb2Nlc3NDYWxpYnJhdGlvblBvaW50KFxuICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHNbaV0sIFxuICAgICAgICAgIGksIFxuICAgICAgICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTbWFsbCBkZWxheSBiZXR3ZWVuIHBvaW50c1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFR1cm4gVG9wQmFyIGJhY2sgb25cbiAgICAgIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdDYWxpYnJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICAvLyB0aGlzLnNldE91dHB1dFRleHQ/LihgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIC8vIGlmICh0aGlzLnN0YXR1c0luZGljYXRvcikge1xuICAgICAgLy8gICB0aGlzLnN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWA7XG4gICAgICAvLyB9XG4gICAgICBcbiAgICAgIC8vIC8vIE1ha2Ugc3VyZSB3ZSB0dXJuIFRvcEJhciBiYWNrIG9uIGV2ZW4gb24gZXJyb3JcbiAgICAgIC8vIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgLy8gICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIC8vIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlIGFuZCBwcmV2aWV3OicsIGVycm9yKTtcbiAgXG4gICAgICAvLyBTaG93IGVycm9yIG1lc3NhZ2VcbiAgICAgIGlmICh0aGlzLnNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBldmVuIGlmIHRoZXJlIHdhcyBhbiBlcnJvclxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTUwMCk7XG4gICAgICBcbiAgICAgIC8vIFJldHVybiBhIGRlZmF1bHQgb2JqZWN0IHRvIHByZXZlbnQgbnVsbCByZWZlcmVuY2UgZXJyb3JzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2VcbiAgICAgIH07XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSB0aGUgc3RhdHVzIGluZGljYXRvciBhZnRlciBhIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yICYmIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhbGlicmF0ZUhhbmRsZXI7Il0sIm5hbWVzIjpbImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJDYXB0dXJlSGFuZGxlciIsImRyYXdSZWREb3QiLCJDYWxpYnJhdGVIYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJjYW52YXNSZWYiLCJ0b2dnbGVUb3BCYXIiLCJzZXRPdXRwdXRUZXh0IiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsImNhcHR1cmVGb2xkZXIiLCJvbkNvbXBsZXRlIiwiY2FsaWJyYXRpb25Qb2ludHMiLCJjYXB0dXJlSGFuZGxlciIsImltYWdlRGF0YSIsImZpbGVuYW1lIiwidHlwZSIsImZvbGRlciIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImNvbnNvbGUiLCJ3YXJuIiwic3RhdHVzIiwianNvbiIsImVyciIsImVycm9yIiwibmV3Q291bnRlciIsImlzUHJvY2Vzc2luZyIsImN1cnJlbnRQb2ludEluZGV4Iiwic3RhdHVzSW5kaWNhdG9yIiwiY3JlYXRlU3RhdHVzSW5kaWNhdG9yIiwiZXhpc3RpbmdJbmRpY2F0b3JzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImluZGljYXRvciIsInJlbW92ZSIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJhcHBlbmRDaGlsZCIsInByb2Nlc3NDYWxpYnJhdGlvblBvaW50IiwicG9pbnQiLCJpbmRleCIsInRvdGFsIiwieCIsInkiLCJFcnJvciIsInRleHRDb250ZW50IiwiY2FudmFzIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJjYW52YXNSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY291bnRkb3duRWxlbWVudCIsImxlZnQiLCJ0b3AiLCJjb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhcHR1cmVSZXN1bHQiLCJjYXB0dXJlQW5kU2hvd1ByZXZpZXciLCJtZXNzYWdlIiwic3RhcnRDYWxpYnJhdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibGVuZ3RoIiwic3VjY2Vzc0NvdW50IiwiaSIsInN1Y2Nlc3MiLCJzZXRQcm9jZXNzU3RhdHVzIiwid2luZG93Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/CalibrateHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/CaptureHandler.js":
/*!**************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CaptureHandler.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// CaptureHandler.js - With fixed capture numbering\nclass CaptureHandler {\n    constructor(saveFunction, counterSetter, statusSetter, toggleTopBarFunction){\n        this.saveImageToServer = saveFunction;\n        this.setCaptureCounter = counterSetter;\n        this.setProcessStatus = statusSetter;\n        this.toggleTopBar = toggleTopBarFunction;\n        this.captureFolder = 'eye_tracking_captures'; // Use fixed folder name\n    }\n    // Show preview of the SAVED images for exactly 2 seconds\n    showCapturePreview(screenImage, webcamImage, dotPosition) {\n        // Create a centered preview container\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = `\n        position: fixed;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        display: flex;\n        gap: 20px;\n        background-color: rgba(0, 0, 0, 0.85);\n        padding: 20px;\n        border-radius: 12px;\n        z-index: 999999;\n        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n        opacity: 1;\n        transition: opacity 0.3s ease;\n      `;\n        // Function to create an image preview element\n        const createImagePreview = (imageData, label)=>{\n            if (!imageData) return null;\n            const preview = document.createElement('div');\n            preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n            const img = document.createElement('img');\n            img.src = imageData;\n            img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n            // Event listeners for image loading\n            img.onload = ()=>console.log(`${label} image loaded successfully`);\n            img.onerror = (e)=>console.error(`Error loading ${label} image:`, e);\n            const textLabel = document.createElement('div');\n            textLabel.textContent = label;\n            textLabel.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n            preview.appendChild(img);\n            preview.appendChild(textLabel);\n            return preview;\n        };\n        // Add debug info\n        const debugInfo = document.createElement('div');\n        debugInfo.style.cssText = `\n        position: absolute;\n        top: -30px;\n        left: 0;\n        width: 100%;\n        color: white;\n        font-size: 12px;\n        text-align: center;\n      `;\n        debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n        previewContainer.appendChild(debugInfo);\n        // Add screen capture preview\n        const screenPreview = createImagePreview(screenImage, 'Screen Capture');\n        if (screenPreview) {\n            previewContainer.appendChild(screenPreview);\n        }\n        // Add webcam capture preview\n        const webcamPreview = createImagePreview(webcamImage, 'Webcam Capture');\n        if (webcamPreview) {\n            previewContainer.appendChild(webcamPreview);\n        }\n        // Add dot position info if available\n        if (dotPosition) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n            positionInfo.style.cssText = `\n          color: #ffcc00;\n          font-size: 14px;\n          position: absolute;\n          top: -50px;\n          left: 0;\n          width: 100%;\n          text-align: center;\n        `;\n            previewContainer.appendChild(positionInfo);\n        }\n        // Add timer countdown\n        const timerElement = document.createElement('div');\n        timerElement.textContent = '2.0s';\n        timerElement.style.cssText = `\n        position: absolute;\n        bottom: -25px;\n        right: 20px;\n        color: white;\n        font-size: 12px;\n        background-color: rgba(0, 0, 0, 0.7);\n        padding: 3px 8px;\n        border-radius: 4px;\n      `;\n        previewContainer.appendChild(timerElement);\n        // Add the preview to the document\n        document.body.appendChild(previewContainer);\n        // Start countdown timer\n        let timeLeft = 2.0;\n        const interval = setInterval(()=>{\n            timeLeft -= 0.1;\n            if (timeLeft <= 0) {\n                clearInterval(interval);\n                // Fade out\n                previewContainer.style.opacity = '0';\n                // Remove after fade\n                setTimeout(()=>{\n                    if (previewContainer.parentNode) {\n                        previewContainer.parentNode.removeChild(previewContainer);\n                    }\n                }, 300);\n            } else {\n                timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n            }\n        }, 100);\n        // Safety cleanup after 5 seconds in case anything goes wrong\n        setTimeout(()=>{\n            if (previewContainer.parentNode) {\n                previewContainer.parentNode.removeChild(previewContainer);\n            }\n        }, 5000);\n    }\n    // Take a webcam picture and immediately stop the stream\n    async captureWebcamImage(captureNumber) {\n        let stream = null;\n        let tempVideo = null;\n        try {\n            // Format the filename with the current counter\n            const filename = `webcam_${String(captureNumber).padStart(3, '0')}.jpg`;\n            // Create a new stream with high resolution constraints\n            stream = await navigator.mediaDevices.getUserMedia({\n                video: {\n                    width: {\n                        ideal: 4096\n                    },\n                    height: {\n                        ideal: 2160\n                    },\n                    facingMode: \"user\"\n                },\n                audio: false\n            });\n            // Create a temporary video element\n            tempVideo = document.createElement('video');\n            tempVideo.autoplay = true;\n            tempVideo.playsInline = true;\n            tempVideo.muted = true;\n            tempVideo.style.position = 'absolute';\n            tempVideo.style.left = '-9999px';\n            tempVideo.style.opacity = '0';\n            document.body.appendChild(tempVideo);\n            // Connect stream to video element\n            tempVideo.srcObject = stream;\n            // Wait for video to initialize\n            await new Promise((resolve)=>{\n                const timeoutId = setTimeout(()=>{\n                    console.warn(\"Video loading timed out, continuing anyway\");\n                    resolve();\n                }, 1000);\n                tempVideo.onloadeddata = ()=>{\n                    clearTimeout(timeoutId);\n                    resolve();\n                };\n            });\n            // Small delay to ensure a clear frame\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Get actual video dimensions\n            const videoWidth = tempVideo.videoWidth || 640;\n            const videoHeight = tempVideo.videoHeight || 480;\n            console.log(`Capturing at resolution: ${videoWidth}x${videoHeight}`);\n            // Capture the frame at full resolution\n            const tempCanvas = document.createElement('canvas');\n            tempCanvas.width = videoWidth;\n            tempCanvas.height = videoHeight;\n            const ctx = tempCanvas.getContext('2d');\n            ctx.drawImage(tempVideo, 0, 0, videoWidth, videoHeight);\n            // Convert to JPEG with high quality\n            const imageData = tempCanvas.toDataURL('image/jpeg', 0.95);\n            // Save the image\n            await this.saveImageToServer(imageData, filename, 'webcam', this.captureFolder);\n            // Clean up\n            stream.getTracks().forEach((track)=>track.stop());\n            tempVideo.remove();\n            return true;\n        } catch (error) {\n            console.error('Error capturing webcam image:', error);\n            if (stream) {\n                stream.getTracks().forEach((track)=>track.stop());\n            }\n            if (tempVideo) {\n                tempVideo.remove();\n            }\n            return false;\n        }\n    }\n    // Capture screen image from canvas\n    async captureScreenImage(canvasRef, captureNumber) {\n        try {\n            // Format the filename with the current counter\n            const filename = `screen_${String(captureNumber).padStart(3, '0')}.jpg`;\n            const canvas = canvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas reference is null\");\n                return {\n                    imageData: null,\n                    saveResponse: null\n                };\n            }\n            // Get image data\n            const imageData = canvas.toDataURL('image/png');\n            // Save the image\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(imageData, filename, 'screen', this.captureFolder);\n                console.log(`Saved screen image: ${filename}, response:`, saveResponse);\n                return {\n                    imageData,\n                    saveResponse\n                };\n            }\n            return {\n                imageData,\n                saveResponse: null\n            };\n        } catch (error) {\n            console.error(\"Error capturing screen image:\", error);\n            return {\n                imageData: null,\n                saveResponse: null\n            };\n        }\n    }\n    // Save parameter CSV\n    async saveParameterCSV(captureNumber, params) {\n        try {\n            // Format the filename with the current counter\n            const filename = `parameter_${String(captureNumber).padStart(3, '0')}.csv`;\n            // Create CSV content with two columns: name and value\n            const csvData = [\n                \"name,value\",\n                ...Object.entries(params).map(([name, value])=>`${name},${value}`)\n            ].join('\\n');\n            // Convert CSV to data URL\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            // Save CSV using the API\n            if (this.saveImageToServer) {\n                const saveResponse = await this.saveImageToServer(csvDataUrl, filename, 'parameters', this.captureFolder);\n                console.log(`Saved parameter CSV: ${filename}`);\n                return saveResponse;\n            }\n            return null;\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n            return null;\n        }\n    }\n    // Main capture and show process\n    async captureAndShowPreview(captureCounter, canvasRef, position) {\n        try {\n            console.log(`Starting capture process with counter: ${captureCounter}`);\n            // Step 1: Capture screen image\n            const { imageData: screenImage, saveResponse: screenResponse } = await this.captureScreenImage(canvasRef, captureCounter);\n            // Get the capture number from the response if available (for continuous numbering)\n            let usedCaptureNumber = captureCounter;\n            if (screenResponse && screenResponse.captureNumber) {\n                usedCaptureNumber = screenResponse.captureNumber;\n                console.log(`Server assigned capture number: ${usedCaptureNumber}`);\n            }\n            // Step 2: Capture webcam image (and immediately stop stream)\n            const webcamSuccess = await this.captureWebcamImage(usedCaptureNumber);\n            // Step 3: Save parameters\n            const params = {\n                dot_x: position ? position.x : 0,\n                dot_y: position ? position.y : 0,\n                canvas_width: canvasRef.current ? canvasRef.current.width : 0,\n                canvas_height: canvasRef.current ? canvasRef.current.height : 0,\n                window_width: window.innerWidth,\n                window_height: window.innerHeight,\n                timestamp: new Date().toISOString()\n            };\n            await this.saveParameterCSV(usedCaptureNumber, params);\n            // Step 4: Increment counter for next capture\n            if (this.setCaptureCounter) {\n                // If the server is managing numbering, use the next number\n                if (screenResponse && screenResponse.captureNumber) {\n                    this.setCaptureCounter(screenResponse.captureNumber + 1);\n                } else {\n                    this.setCaptureCounter((prev)=>prev + 1);\n                }\n            }\n            // Step 5: Update status\n            if (this.setProcessStatus) {\n                this.setProcessStatus(`Captured with dot at: x=${position?.x}, y=${position?.y}`);\n            }\n            // Step 6: Show preview using the in-memory image data\n            this.showCapturePreview(screenImage, webcamSuccess ? 'webcam_image_data' : null, position);\n            // Step 7: Show TopBar again after preview is done\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 2200); // Wait longer than the preview duration\n            // Step 8: Clear status after a delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if (false) {}\n            }, 1500);\n            // Clear error message after delay\n            setTimeout(()=>{\n                if (this.setProcessStatus) {\n                    this.setProcessStatus('');\n                }\n            }, 3000);\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CaptureHandler);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FwdHVyZUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLG1EQUFtRDtBQUVuRCxNQUFNQTtJQUNGQyxZQUFZQyxZQUFZLEVBQUVDLGFBQWEsRUFBRUMsWUFBWSxFQUFFQyxvQkFBb0IsQ0FBRTtRQUMzRSxJQUFJLENBQUNDLGlCQUFpQixHQUFHSjtRQUN6QixJQUFJLENBQUNLLGlCQUFpQixHQUFHSjtRQUN6QixJQUFJLENBQUNLLGdCQUFnQixHQUFHSjtRQUN4QixJQUFJLENBQUNLLFlBQVksR0FBR0o7UUFDcEIsSUFBSSxDQUFDSyxhQUFhLEdBQUcseUJBQXlCLHdCQUF3QjtJQUN4RTtJQUVBLHlEQUF5RDtJQUN6REMsbUJBQW1CQyxXQUFXLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFO1FBQ3hELHNDQUFzQztRQUN0QyxNQUFNQyxtQkFBbUJDLFNBQVNDLGFBQWEsQ0FBQztRQUNoREYsaUJBQWlCRyxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7OztNQWNsQyxDQUFDO1FBRUQsOENBQThDO1FBQzlDLE1BQU1DLHFCQUFxQixDQUFDQyxXQUFXQztZQUNyQyxJQUFJLENBQUNELFdBQVcsT0FBTztZQUV2QixNQUFNRSxVQUFVUCxTQUFTQyxhQUFhLENBQUM7WUFDdkNNLFFBQVFMLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7UUFJekIsQ0FBQztZQUVELE1BQU1LLE1BQU1SLFNBQVNDLGFBQWEsQ0FBQztZQUNuQ08sSUFBSUMsR0FBRyxHQUFHSjtZQUNWRyxJQUFJTixLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7UUFNckIsQ0FBQztZQUVELG9DQUFvQztZQUNwQ0ssSUFBSUUsTUFBTSxHQUFHLElBQU1DLFFBQVFDLEdBQUcsQ0FBQyxHQUFHTixNQUFNLDBCQUEwQixDQUFDO1lBQ25FRSxJQUFJSyxPQUFPLEdBQUcsQ0FBQ0MsSUFBTUgsUUFBUUksS0FBSyxDQUFDLENBQUMsY0FBYyxFQUFFVCxNQUFNLE9BQU8sQ0FBQyxFQUFFUTtZQUVwRSxNQUFNRSxZQUFZaEIsU0FBU0MsYUFBYSxDQUFDO1lBQ3pDZSxVQUFVQyxXQUFXLEdBQUdYO1lBQ3hCVSxVQUFVZCxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7OztRQUszQixDQUFDO1lBRURJLFFBQVFXLFdBQVcsQ0FBQ1Y7WUFDcEJELFFBQVFXLFdBQVcsQ0FBQ0Y7WUFDcEIsT0FBT1Q7UUFDVDtRQUVBLGlCQUFpQjtRQUNqQixNQUFNWSxZQUFZbkIsU0FBU0MsYUFBYSxDQUFDO1FBQ3pDa0IsVUFBVWpCLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7O01BUTNCLENBQUM7UUFDRGdCLFVBQVVGLFdBQVcsR0FBRyxDQUFDLFFBQVEsRUFBRXJCLGNBQWMsUUFBUSxLQUFLLFVBQVUsRUFBRUMsY0FBYyxRQUFRLE1BQU07UUFDdEdFLGlCQUFpQm1CLFdBQVcsQ0FBQ0M7UUFFN0IsNkJBQTZCO1FBQzdCLE1BQU1DLGdCQUFnQmhCLG1CQUFtQlIsYUFBYTtRQUN0RCxJQUFJd0IsZUFBZTtZQUNqQnJCLGlCQUFpQm1CLFdBQVcsQ0FBQ0U7UUFDL0I7UUFFQSw2QkFBNkI7UUFDN0IsTUFBTUMsZ0JBQWdCakIsbUJBQW1CUCxhQUFhO1FBQ3RELElBQUl3QixlQUFlO1lBQ2pCdEIsaUJBQWlCbUIsV0FBVyxDQUFDRztRQUMvQjtRQUVBLHFDQUFxQztRQUNyQyxJQUFJdkIsYUFBYTtZQUNmLE1BQU13QixlQUFldEIsU0FBU0MsYUFBYSxDQUFDO1lBQzVDcUIsYUFBYUwsV0FBVyxHQUFHLENBQUMsZ0JBQWdCLEVBQUVNLEtBQUtDLEtBQUssQ0FBQzFCLFlBQVkyQixDQUFDLEVBQUUsSUFBSSxFQUFFRixLQUFLQyxLQUFLLENBQUMxQixZQUFZNEIsQ0FBQyxHQUFHO1lBQ3pHSixhQUFhcEIsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7UUFROUIsQ0FBQztZQUNESixpQkFBaUJtQixXQUFXLENBQUNJO1FBQy9CO1FBRUEsc0JBQXNCO1FBQ3RCLE1BQU1LLGVBQWUzQixTQUFTQyxhQUFhLENBQUM7UUFDNUMwQixhQUFhVixXQUFXLEdBQUc7UUFDM0JVLGFBQWF6QixLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7TUFTOUIsQ0FBQztRQUNESixpQkFBaUJtQixXQUFXLENBQUNTO1FBRTdCLGtDQUFrQztRQUNsQzNCLFNBQVM0QixJQUFJLENBQUNWLFdBQVcsQ0FBQ25CO1FBRTFCLHdCQUF3QjtRQUN4QixJQUFJOEIsV0FBVztRQUNmLE1BQU1DLFdBQVdDLFlBQVk7WUFDM0JGLFlBQVk7WUFDWixJQUFJQSxZQUFZLEdBQUc7Z0JBQ2pCRyxjQUFjRjtnQkFDZCxXQUFXO2dCQUNYL0IsaUJBQWlCRyxLQUFLLENBQUMrQixPQUFPLEdBQUc7Z0JBQ2pDLG9CQUFvQjtnQkFDcEJDLFdBQVc7b0JBQ1QsSUFBSW5DLGlCQUFpQm9DLFVBQVUsRUFBRTt3QkFDL0JwQyxpQkFBaUJvQyxVQUFVLENBQUNDLFdBQVcsQ0FBQ3JDO29CQUMxQztnQkFDRixHQUFHO1lBQ0wsT0FBTztnQkFDTDRCLGFBQWFWLFdBQVcsR0FBRyxHQUFHWSxTQUFTUSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdEQ7UUFDRixHQUFHO1FBRUgsNkRBQTZEO1FBQzdESCxXQUFXO1lBQ1QsSUFBSW5DLGlCQUFpQm9DLFVBQVUsRUFBRTtnQkFDL0JwQyxpQkFBaUJvQyxVQUFVLENBQUNDLFdBQVcsQ0FBQ3JDO1lBQzFDO1FBQ0YsR0FBRztJQUNMO0lBRUEsd0RBQXdEO0lBQ3hELE1BQU11QyxtQkFBbUJDLGFBQWEsRUFBRTtRQUN0QyxJQUFJQyxTQUFTO1FBQ2IsSUFBSUMsWUFBWTtRQUVoQixJQUFJO1lBQ0YsK0NBQStDO1lBQy9DLE1BQU1DLFdBQVcsQ0FBQyxPQUFPLEVBQUVDLE9BQU9KLGVBQWVLLFFBQVEsQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDO1lBRXZFLHVEQUF1RDtZQUN2REosU0FBUyxNQUFNSyxVQUFVQyxZQUFZLENBQUNDLFlBQVksQ0FBQztnQkFDakRDLE9BQU87b0JBQ0xDLE9BQU87d0JBQUVDLE9BQU87b0JBQUs7b0JBQ3JCQyxRQUFRO3dCQUFFRCxPQUFPO29CQUFLO29CQUN0QkUsWUFBWTtnQkFDZDtnQkFDQUMsT0FBTztZQUNUO1lBRUEsbUNBQW1DO1lBQ25DWixZQUFZekMsU0FBU0MsYUFBYSxDQUFDO1lBQ25Dd0MsVUFBVWEsUUFBUSxHQUFHO1lBQ3JCYixVQUFVYyxXQUFXLEdBQUc7WUFDeEJkLFVBQVVlLEtBQUssR0FBRztZQUNsQmYsVUFBVXZDLEtBQUssQ0FBQ3VELFFBQVEsR0FBRztZQUMzQmhCLFVBQVV2QyxLQUFLLENBQUN3RCxJQUFJLEdBQUc7WUFDdkJqQixVQUFVdkMsS0FBSyxDQUFDK0IsT0FBTyxHQUFHO1lBQzFCakMsU0FBUzRCLElBQUksQ0FBQ1YsV0FBVyxDQUFDdUI7WUFFMUIsa0NBQWtDO1lBQ2xDQSxVQUFVa0IsU0FBUyxHQUFHbkI7WUFFdEIsK0JBQStCO1lBQy9CLE1BQU0sSUFBSW9CLFFBQVEsQ0FBQ0M7Z0JBQ2pCLE1BQU1DLFlBQVk1QixXQUFXO29CQUMzQnZCLFFBQVFvRCxJQUFJLENBQUM7b0JBQ2JGO2dCQUNGLEdBQUc7Z0JBRUhwQixVQUFVdUIsWUFBWSxHQUFHO29CQUN2QkMsYUFBYUg7b0JBQ2JEO2dCQUNGO1lBQ0Y7WUFFQSxzQ0FBc0M7WUFDdEMsTUFBTSxJQUFJRCxRQUFRQyxDQUFBQSxVQUFXM0IsV0FBVzJCLFNBQVM7WUFFakQsOEJBQThCO1lBQzlCLE1BQU1LLGFBQWF6QixVQUFVeUIsVUFBVSxJQUFJO1lBQzNDLE1BQU1DLGNBQWMxQixVQUFVMEIsV0FBVyxJQUFJO1lBQzdDeEQsUUFBUUMsR0FBRyxDQUFDLENBQUMseUJBQXlCLEVBQUVzRCxXQUFXLENBQUMsRUFBRUMsYUFBYTtZQUVuRSx1Q0FBdUM7WUFDdkMsTUFBTUMsYUFBYXBFLFNBQVNDLGFBQWEsQ0FBQztZQUMxQ21FLFdBQVduQixLQUFLLEdBQUdpQjtZQUNuQkUsV0FBV2pCLE1BQU0sR0FBR2dCO1lBQ3BCLE1BQU1FLE1BQU1ELFdBQVdFLFVBQVUsQ0FBQztZQUNsQ0QsSUFBSUUsU0FBUyxDQUFDOUIsV0FBVyxHQUFHLEdBQUd5QixZQUFZQztZQUUzQyxvQ0FBb0M7WUFDcEMsTUFBTTlELFlBQVkrRCxXQUFXSSxTQUFTLENBQUMsY0FBYztZQUVyRCxpQkFBaUI7WUFDakIsTUFBTSxJQUFJLENBQUNsRixpQkFBaUIsQ0FBQ2UsV0FBV3FDLFVBQVUsVUFBVSxJQUFJLENBQUNoRCxhQUFhO1lBRTlFLFdBQVc7WUFDWDhDLE9BQU9pQyxTQUFTLEdBQUdDLE9BQU8sQ0FBQ0MsQ0FBQUEsUUFBU0EsTUFBTUMsSUFBSTtZQUM5Q25DLFVBQVVvQyxNQUFNO1lBRWhCLE9BQU87UUFDVCxFQUFFLE9BQU85RCxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLElBQUl5QixRQUFRO2dCQUNWQSxPQUFPaUMsU0FBUyxHQUFHQyxPQUFPLENBQUNDLENBQUFBLFFBQVNBLE1BQU1DLElBQUk7WUFDaEQ7WUFDQSxJQUFJbkMsV0FBVztnQkFDYkEsVUFBVW9DLE1BQU07WUFDbEI7WUFDQSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxNQUFNQyxtQkFBbUJDLFNBQVMsRUFBRXhDLGFBQWEsRUFBRTtRQUNqRCxJQUFJO1lBQ0YsK0NBQStDO1lBQy9DLE1BQU1HLFdBQVcsQ0FBQyxPQUFPLEVBQUVDLE9BQU9KLGVBQWVLLFFBQVEsQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDO1lBRXZFLE1BQU1vQyxTQUFTRCxVQUFVRSxPQUFPO1lBQ2hDLElBQUksQ0FBQ0QsUUFBUTtnQkFDWHJFLFFBQVFJLEtBQUssQ0FBQztnQkFDZCxPQUFPO29CQUFFVixXQUFXO29CQUFNNkUsY0FBYztnQkFBSztZQUMvQztZQUVBLGlCQUFpQjtZQUNqQixNQUFNN0UsWUFBWTJFLE9BQU9SLFNBQVMsQ0FBQztZQUVuQyxpQkFBaUI7WUFDakIsSUFBSSxJQUFJLENBQUNsRixpQkFBaUIsRUFBRTtnQkFDMUIsTUFBTTRGLGVBQWUsTUFBTSxJQUFJLENBQUM1RixpQkFBaUIsQ0FBQ2UsV0FBV3FDLFVBQVUsVUFBVSxJQUFJLENBQUNoRCxhQUFhO2dCQUNuR2lCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLG9CQUFvQixFQUFFOEIsU0FBUyxXQUFXLENBQUMsRUFBRXdDO2dCQUMxRCxPQUFPO29CQUFFN0U7b0JBQVc2RTtnQkFBYTtZQUNuQztZQUVBLE9BQU87Z0JBQUU3RTtnQkFBVzZFLGNBQWM7WUFBSztRQUN6QyxFQUFFLE9BQU9uRSxPQUFPO1lBQ2RKLFFBQVFJLEtBQUssQ0FBQyxpQ0FBaUNBO1lBQy9DLE9BQU87Z0JBQUVWLFdBQVc7Z0JBQU02RSxjQUFjO1lBQUs7UUFDL0M7SUFDRjtJQUVBLHFCQUFxQjtJQUNyQixNQUFNQyxpQkFBaUI1QyxhQUFhLEVBQUU2QyxNQUFNLEVBQUU7UUFDNUMsSUFBSTtZQUNGLCtDQUErQztZQUMvQyxNQUFNMUMsV0FBVyxDQUFDLFVBQVUsRUFBRUMsT0FBT0osZUFBZUssUUFBUSxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUM7WUFFMUUsc0RBQXNEO1lBQ3RELE1BQU15QyxVQUFVO2dCQUNkO21CQUNHQyxPQUFPQyxPQUFPLENBQUNILFFBQVFJLEdBQUcsQ0FBQyxDQUFDLENBQUNDLE1BQU1DLE1BQU0sR0FBSyxHQUFHRCxLQUFLLENBQUMsRUFBRUMsT0FBTzthQUNwRSxDQUFDQyxJQUFJLENBQUM7WUFFUCwwQkFBMEI7WUFDMUIsTUFBTUMsVUFBVSxJQUFJQyxLQUFLO2dCQUFDUjthQUFRLEVBQUU7Z0JBQUVTLE1BQU07WUFBVztZQUN2RCxNQUFNQyxZQUFZLElBQUlDO1lBRXRCLE1BQU1DLGFBQWEsTUFBTSxJQUFJckMsUUFBUSxDQUFDQztnQkFDcENrQyxVQUFVRyxTQUFTLEdBQUcsSUFBTXJDLFFBQVFrQyxVQUFVSSxNQUFNO2dCQUNwREosVUFBVUssYUFBYSxDQUFDUjtZQUMxQjtZQUVBLHlCQUF5QjtZQUN6QixJQUFJLElBQUksQ0FBQ3RHLGlCQUFpQixFQUFFO2dCQUMxQixNQUFNNEYsZUFBZSxNQUFNLElBQUksQ0FBQzVGLGlCQUFpQixDQUFDMkcsWUFBWXZELFVBQVUsY0FBYyxJQUFJLENBQUNoRCxhQUFhO2dCQUN4R2lCLFFBQVFDLEdBQUcsQ0FBQyxDQUFDLHFCQUFxQixFQUFFOEIsVUFBVTtnQkFDOUMsT0FBT3dDO1lBQ1Q7WUFFQSxPQUFPO1FBQ1QsRUFBRSxPQUFPbUIsVUFBVTtZQUNqQjFGLFFBQVFJLEtBQUssQ0FBQywrQkFBK0JzRjtZQUM3QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLGdDQUFnQztJQUNoQyxNQUFNQyxzQkFBc0JDLGNBQWMsRUFBRXhCLFNBQVMsRUFBRXRCLFFBQVEsRUFBRTtRQUMvRCxJQUFJO1lBQ0Y5QyxRQUFRQyxHQUFHLENBQUMsQ0FBQyx1Q0FBdUMsRUFBRTJGLGdCQUFnQjtZQUV0RSwrQkFBK0I7WUFDL0IsTUFBTSxFQUFFbEcsV0FBV1QsV0FBVyxFQUFFc0YsY0FBY3NCLGNBQWMsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDMUIsa0JBQWtCLENBQUNDLFdBQVd3QjtZQUUxRyxtRkFBbUY7WUFDbkYsSUFBSUUsb0JBQW9CRjtZQUN4QixJQUFJQyxrQkFBa0JBLGVBQWVqRSxhQUFhLEVBQUU7Z0JBQ2xEa0Usb0JBQW9CRCxlQUFlakUsYUFBYTtnQkFDaEQ1QixRQUFRQyxHQUFHLENBQUMsQ0FBQyxnQ0FBZ0MsRUFBRTZGLG1CQUFtQjtZQUNwRTtZQUVBLDZEQUE2RDtZQUM3RCxNQUFNQyxnQkFBZ0IsTUFBTSxJQUFJLENBQUNwRSxrQkFBa0IsQ0FBQ21FO1lBRXBELDBCQUEwQjtZQUMxQixNQUFNckIsU0FBUztnQkFDYnVCLE9BQU9sRCxXQUFXQSxTQUFTaEMsQ0FBQyxHQUFHO2dCQUMvQm1GLE9BQU9uRCxXQUFXQSxTQUFTL0IsQ0FBQyxHQUFHO2dCQUMvQm1GLGNBQWM5QixVQUFVRSxPQUFPLEdBQUdGLFVBQVVFLE9BQU8sQ0FBQ2hDLEtBQUssR0FBRztnQkFDNUQ2RCxlQUFlL0IsVUFBVUUsT0FBTyxHQUFHRixVQUFVRSxPQUFPLENBQUM5QixNQUFNLEdBQUc7Z0JBQzlENEQsY0FBY0MsT0FBT0MsVUFBVTtnQkFDL0JDLGVBQWVGLE9BQU9HLFdBQVc7Z0JBQ2pDQyxXQUFXLElBQUlDLE9BQU9DLFdBQVc7WUFDbkM7WUFFQSxNQUFNLElBQUksQ0FBQ25DLGdCQUFnQixDQUFDc0IsbUJBQW1CckI7WUFFL0MsNkNBQTZDO1lBQzdDLElBQUksSUFBSSxDQUFDN0YsaUJBQWlCLEVBQUU7Z0JBQzFCLDJEQUEyRDtnQkFDM0QsSUFBSWlILGtCQUFrQkEsZUFBZWpFLGFBQWEsRUFBRTtvQkFDbEQsSUFBSSxDQUFDaEQsaUJBQWlCLENBQUNpSCxlQUFlakUsYUFBYSxHQUFHO2dCQUN4RCxPQUFPO29CQUNMLElBQUksQ0FBQ2hELGlCQUFpQixDQUFDZ0ksQ0FBQUEsT0FBUUEsT0FBTztnQkFDeEM7WUFDRjtZQUVBLHdCQUF3QjtZQUN4QixJQUFJLElBQUksQ0FBQy9ILGdCQUFnQixFQUFFO2dCQUN6QixJQUFJLENBQUNBLGdCQUFnQixDQUFDLENBQUMsd0JBQXdCLEVBQUVpRSxVQUFVaEMsRUFBRSxJQUFJLEVBQUVnQyxVQUFVL0IsR0FBRztZQUNsRjtZQUVBLHNEQUFzRDtZQUN0RCxJQUFJLENBQUMvQixrQkFBa0IsQ0FBQ0MsYUFBYThHLGdCQUFnQixzQkFBc0IsTUFBTWpEO1lBRWpGLGtEQUFrRDtZQUNsRHZCLFdBQVc7Z0JBQ1QsSUFBSSxPQUFPLElBQUksQ0FBQ3pDLFlBQVksS0FBSyxZQUFZO29CQUMzQyxJQUFJLENBQUNBLFlBQVksQ0FBQztnQkFDcEIsT0FBTyxJQUFJLEtBQW9ELEVBQUUsRUFFaEU7WUFDSCxHQUFHLE9BQU8sd0NBQXdDO1lBRWxELHFDQUFxQztZQUNyQ3lDLFdBQVc7Z0JBQ1QsSUFBSSxJQUFJLENBQUMxQyxnQkFBZ0IsRUFBRTtvQkFDekIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQztnQkFDeEI7WUFDRixHQUFHO1FBRUwsRUFBRSxPQUFPdUIsT0FBTztZQUNkSixRQUFRSSxLQUFLLENBQUMscUNBQXFDQTtZQUVuRCxxQkFBcUI7WUFDckIsSUFBSSxJQUFJLENBQUN2QixnQkFBZ0IsRUFBRTtnQkFDekIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQyxZQUFZdUIsTUFBTXlHLE9BQU87WUFDakQ7WUFFQSwrQ0FBK0M7WUFDL0N0RixXQUFXO2dCQUNULElBQUksT0FBTyxJQUFJLENBQUN6QyxZQUFZLEtBQUssWUFBWTtvQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7Z0JBQ3BCLE9BQU8sSUFBSSxLQUFvRCxFQUFFLEVBRWhFO1lBQ0gsR0FBRztZQUVILGtDQUFrQztZQUNsQ3lDLFdBQVc7Z0JBQ1QsSUFBSSxJQUFJLENBQUMxQyxnQkFBZ0IsRUFBRTtvQkFDekIsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQztnQkFDeEI7WUFDRixHQUFHO1FBQ0w7SUFDRjtBQUNGO0FBRUEsaUVBQWVSLGNBQWNBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhcHR1cmVIYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENhcHR1cmVIYW5kbGVyLmpzIC0gV2l0aCBmaXhlZCBjYXB0dXJlIG51bWJlcmluZ1xuXG5jbGFzcyBDYXB0dXJlSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc2F2ZUZ1bmN0aW9uLCBjb3VudGVyU2V0dGVyLCBzdGF0dXNTZXR0ZXIsIHRvZ2dsZVRvcEJhckZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLnNhdmVJbWFnZVRvU2VydmVyID0gc2F2ZUZ1bmN0aW9uO1xuICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvdW50ZXJTZXR0ZXI7XG4gICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBzdGF0dXNTZXR0ZXI7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IHRvZ2dsZVRvcEJhckZ1bmN0aW9uO1xuICAgICAgdGhpcy5jYXB0dXJlRm9sZGVyID0gJ2V5ZV90cmFja2luZ19jYXB0dXJlcyc7IC8vIFVzZSBmaXhlZCBmb2xkZXIgbmFtZVxuICAgIH1cbiAgXG4gICAgLy8gU2hvdyBwcmV2aWV3IG9mIHRoZSBTQVZFRCBpbWFnZXMgZm9yIGV4YWN0bHkgMiBzZWNvbmRzXG4gICAgc2hvd0NhcHR1cmVQcmV2aWV3KHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgZG90UG9zaXRpb24pIHtcbiAgICAgIC8vIENyZWF0ZSBhIGNlbnRlcmVkIHByZXZpZXcgY29udGFpbmVyXG4gICAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiA1MCU7XG4gICAgICAgIGxlZnQ6IDUwJTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGdhcDogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg1KTtcbiAgICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICAgICAgei1pbmRleDogOTk5OTk5O1xuICAgICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzIGVhc2U7XG4gICAgICBgO1xuICAgICAgXG4gICAgICAvLyBGdW5jdGlvbiB0byBjcmVhdGUgYW4gaW1hZ2UgcHJldmlldyBlbGVtZW50XG4gICAgICBjb25zdCBjcmVhdGVJbWFnZVByZXZpZXcgPSAoaW1hZ2VEYXRhLCBsYWJlbCkgPT4ge1xuICAgICAgICBpZiAoIWltYWdlRGF0YSkgcmV0dXJuIG51bGw7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHByZXZpZXcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYDtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcuc3JjID0gaW1hZ2VEYXRhO1xuICAgICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXJzIGZvciBpbWFnZSBsb2FkaW5nXG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBjb25zb2xlLmxvZyhgJHtsYWJlbH0gaW1hZ2UgbG9hZGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nICR7bGFiZWx9IGltYWdlOmAsIGUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgdGV4dExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRleHRMYWJlbC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICB0ZXh0TGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQodGV4dExhYmVsKTtcbiAgICAgICAgcmV0dXJuIHByZXZpZXc7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBBZGQgZGVidWcgaW5mb1xuICAgICAgY29uc3QgZGVidWdJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkZWJ1Z0luZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC0zMHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBkZWJ1Z0luZm8udGV4dENvbnRlbnQgPSBgU2NyZWVuOiAke3NjcmVlbkltYWdlID8gJ1lFUycgOiAnTk8nfSwgV2ViY2FtOiAke3dlYmNhbUltYWdlID8gJ1lFUycgOiAnTk8nfWA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKGRlYnVnSW5mbyk7XG4gICAgICBcbiAgICAgIC8vIEFkZCBzY3JlZW4gY2FwdHVyZSBwcmV2aWV3XG4gICAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gY3JlYXRlSW1hZ2VQcmV2aWV3KHNjcmVlbkltYWdlLCAnU2NyZWVuIENhcHR1cmUnKTtcbiAgICAgIGlmIChzY3JlZW5QcmV2aWV3KSB7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc2NyZWVuUHJldmlldyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCB3ZWJjYW0gY2FwdHVyZSBwcmV2aWV3XG4gICAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gY3JlYXRlSW1hZ2VQcmV2aWV3KHdlYmNhbUltYWdlLCAnV2ViY2FtIENhcHR1cmUnKTtcbiAgICAgIGlmICh3ZWJjYW1QcmV2aWV3KSB7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQod2ViY2FtUHJldmlldyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBkb3QgcG9zaXRpb24gaW5mbyBpZiBhdmFpbGFibGVcbiAgICAgIGlmIChkb3RQb3NpdGlvbikge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcG9zaXRpb25JbmZvLnRleHRDb250ZW50ID0gYERvdCBwb3NpdGlvbjogeD0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi55KX1gO1xuICAgICAgICBwb3NpdGlvbkluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBjb2xvcjogI2ZmY2MwMDtcbiAgICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHRvcDogLTUwcHg7XG4gICAgICAgICAgbGVmdDogMDtcbiAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIGA7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9zaXRpb25JbmZvKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIHRpbWVyIGNvdW50ZG93blxuICAgICAgY29uc3QgdGltZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gICAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3R0b206IC0yNXB4O1xuICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgICAgcGFkZGluZzogM3B4IDhweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgYDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQodGltZXJFbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRoZSBwcmV2aWV3IHRvIHRoZSBkb2N1bWVudFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgIFxuICAgICAgLy8gU3RhcnQgY291bnRkb3duIHRpbWVyXG4gICAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgdGltZUxlZnQgLT0gMC4xO1xuICAgICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICAgIC8vIEZhZGUgb3V0XG4gICAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgIC8vIFJlbW92ZSBhZnRlciBmYWRlXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgICBcbiAgICAgIC8vIFNhZmV0eSBjbGVhbnVwIGFmdGVyIDUgc2Vjb25kcyBpbiBjYXNlIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9LCA1MDAwKTtcbiAgICB9XG4gIFxuICAgIC8vIFRha2UgYSB3ZWJjYW0gcGljdHVyZSBhbmQgaW1tZWRpYXRlbHkgc3RvcCB0aGUgc3RyZWFtXG4gICAgYXN5bmMgY2FwdHVyZVdlYmNhbUltYWdlKGNhcHR1cmVOdW1iZXIpIHtcbiAgICAgIGxldCBzdHJlYW0gPSBudWxsO1xuICAgICAgbGV0IHRlbXBWaWRlbyA9IG51bGw7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZmlsZW5hbWUgd2l0aCB0aGUgY3VycmVudCBjb3VudGVyXG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gYHdlYmNhbV8ke1N0cmluZyhjYXB0dXJlTnVtYmVyKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHN0cmVhbSB3aXRoIGhpZ2ggcmVzb2x1dGlvbiBjb25zdHJhaW50c1xuICAgICAgICBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgIHdpZHRoOiB7IGlkZWFsOiA0MDk2IH0sXG4gICAgICAgICAgICBoZWlnaHQ6IHsgaWRlYWw6IDIxNjAgfSxcbiAgICAgICAgICAgIGZhY2luZ01vZGU6IFwidXNlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdWRpbzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgdmlkZW8gZWxlbWVudFxuICAgICAgICB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB0ZW1wVmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICB0ZW1wVmlkZW8ucGxheXNJbmxpbmUgPSB0cnVlO1xuICAgICAgICB0ZW1wVmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICB0ZW1wVmlkZW8uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0ZW1wVmlkZW8uc3R5bGUubGVmdCA9ICctOTk5OXB4JztcbiAgICAgICAgdGVtcFZpZGVvLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVtcFZpZGVvKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbm5lY3Qgc3RyZWFtIHRvIHZpZGVvIGVsZW1lbnRcbiAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIHZpZGVvIHRvIGluaXRpYWxpemVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlZpZGVvIGxvYWRpbmcgdGltZWQgb3V0LCBjb250aW51aW5nIGFueXdheVwiKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICB0ZW1wVmlkZW8ub25sb2FkZWRkYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgYSBjbGVhciBmcmFtZVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgYWN0dWFsIHZpZGVvIGRpbWVuc2lvbnNcbiAgICAgICAgY29uc3QgdmlkZW9XaWR0aCA9IHRlbXBWaWRlby52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgICAgY29uc3QgdmlkZW9IZWlnaHQgPSB0ZW1wVmlkZW8udmlkZW9IZWlnaHQgfHwgNDgwO1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2FwdHVyaW5nIGF0IHJlc29sdXRpb246ICR7dmlkZW9XaWR0aH14JHt2aWRlb0hlaWdodH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhcHR1cmUgdGhlIGZyYW1lIGF0IGZ1bGwgcmVzb2x1dGlvblxuICAgICAgICBjb25zdCB0ZW1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRlbXBDYW52YXMud2lkdGggPSB2aWRlb1dpZHRoO1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHZpZGVvSGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwLCB2aWRlb1dpZHRoLCB2aWRlb0hlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IHRvIEpQRUcgd2l0aCBoaWdoIHF1YWxpdHlcbiAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnLCAwLjk1KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNhdmUgdGhlIGltYWdlXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgJ3dlYmNhbScsIHRoaXMuY2FwdHVyZUZvbGRlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgICB0ZW1wVmlkZW8ucmVtb3ZlKCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhcHR1cmluZyB3ZWJjYW0gaW1hZ2U6JywgZXJyb3IpO1xuICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVtcFZpZGVvKSB7XG4gICAgICAgICAgdGVtcFZpZGVvLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIC8vIENhcHR1cmUgc2NyZWVuIGltYWdlIGZyb20gY2FudmFzXG4gICAgYXN5bmMgY2FwdHVyZVNjcmVlbkltYWdlKGNhbnZhc1JlZiwgY2FwdHVyZU51bWJlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRm9ybWF0IHRoZSBmaWxlbmFtZSB3aXRoIHRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBgc2NyZWVuXyR7U3RyaW5nKGNhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2A7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsXCIpO1xuICAgICAgICAgIHJldHVybiB7IGltYWdlRGF0YTogbnVsbCwgc2F2ZVJlc3BvbnNlOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCBpbWFnZSBkYXRhXG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW1hZ2VcbiAgICAgICAgaWYgKHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICBjb25zdCBzYXZlUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnNhdmVJbWFnZVRvU2VydmVyKGltYWdlRGF0YSwgZmlsZW5hbWUsICdzY3JlZW4nLCB0aGlzLmNhcHR1cmVGb2xkZXIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCBzY3JlZW4gaW1hZ2U6ICR7ZmlsZW5hbWV9LCByZXNwb25zZTpgLCBzYXZlUmVzcG9uc2UpO1xuICAgICAgICAgIHJldHVybiB7IGltYWdlRGF0YSwgc2F2ZVJlc3BvbnNlIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGltYWdlRGF0YSwgc2F2ZVJlc3BvbnNlOiBudWxsIH07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIHNjcmVlbiBpbWFnZTpcIiwgZXJyb3IpO1xuICAgICAgICByZXR1cm4geyBpbWFnZURhdGE6IG51bGwsIHNhdmVSZXNwb25zZTogbnVsbCB9O1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBTYXZlIHBhcmFtZXRlciBDU1ZcbiAgICBhc3luYyBzYXZlUGFyYW1ldGVyQ1NWKGNhcHR1cmVOdW1iZXIsIHBhcmFtcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRm9ybWF0IHRoZSBmaWxlbmFtZSB3aXRoIHRoZSBjdXJyZW50IGNvdW50ZXJcbiAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBgcGFyYW1ldGVyXyR7U3RyaW5nKGNhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmNzdmA7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgQ1NWIGNvbnRlbnQgd2l0aCB0d28gY29sdW1uczogbmFtZSBhbmQgdmFsdWVcbiAgICAgICAgY29uc3QgY3N2RGF0YSA9IFtcbiAgICAgICAgICBcIm5hbWUsdmFsdWVcIixcbiAgICAgICAgICAuLi5PYmplY3QuZW50cmllcyhwYXJhbXMpLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4gYCR7bmFtZX0sJHt2YWx1ZX1gKVxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBDU1YgdG8gZGF0YSBVUkxcbiAgICAgICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgICAgICBjb25zdCBjc3ZSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY3N2UmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUoY3N2UmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgY3N2UmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2F2ZSBDU1YgdXNpbmcgdGhlIEFQSVxuICAgICAgICBpZiAodGhpcy5zYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgIGNvbnN0IHNhdmVSZXNwb25zZSA9IGF3YWl0IHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIoY3N2RGF0YVVybCwgZmlsZW5hbWUsICdwYXJhbWV0ZXJzJywgdGhpcy5jYXB0dXJlRm9sZGVyKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgcGFyYW1ldGVyIENTVjogJHtmaWxlbmFtZX1gKTtcbiAgICAgICAgICByZXR1cm4gc2F2ZVJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGNzdkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzYXZpbmcgcGFyYW1ldGVyIENTVjpcIiwgY3N2RXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIFxuICAgIC8vIE1haW4gY2FwdHVyZSBhbmQgc2hvdyBwcm9jZXNzXG4gICAgYXN5bmMgY2FwdHVyZUFuZFNob3dQcmV2aWV3KGNhcHR1cmVDb3VudGVyLCBjYW52YXNSZWYsIHBvc2l0aW9uKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FwdHVyZSBwcm9jZXNzIHdpdGggY291bnRlcjogJHtjYXB0dXJlQ291bnRlcn1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgMTogQ2FwdHVyZSBzY3JlZW4gaW1hZ2VcbiAgICAgICAgY29uc3QgeyBpbWFnZURhdGE6IHNjcmVlbkltYWdlLCBzYXZlUmVzcG9uc2U6IHNjcmVlblJlc3BvbnNlIH0gPSBhd2FpdCB0aGlzLmNhcHR1cmVTY3JlZW5JbWFnZShjYW52YXNSZWYsIGNhcHR1cmVDb3VudGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgY2FwdHVyZSBudW1iZXIgZnJvbSB0aGUgcmVzcG9uc2UgaWYgYXZhaWxhYmxlIChmb3IgY29udGludW91cyBudW1iZXJpbmcpXG4gICAgICAgIGxldCB1c2VkQ2FwdHVyZU51bWJlciA9IGNhcHR1cmVDb3VudGVyO1xuICAgICAgICBpZiAoc2NyZWVuUmVzcG9uc2UgJiYgc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlcikge1xuICAgICAgICAgIHVzZWRDYXB0dXJlTnVtYmVyID0gc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlcjtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2VydmVyIGFzc2lnbmVkIGNhcHR1cmUgbnVtYmVyOiAke3VzZWRDYXB0dXJlTnVtYmVyfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDI6IENhcHR1cmUgd2ViY2FtIGltYWdlIChhbmQgaW1tZWRpYXRlbHkgc3RvcCBzdHJlYW0pXG4gICAgICAgIGNvbnN0IHdlYmNhbVN1Y2Nlc3MgPSBhd2FpdCB0aGlzLmNhcHR1cmVXZWJjYW1JbWFnZSh1c2VkQ2FwdHVyZU51bWJlcik7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDM6IFNhdmUgcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgZG90X3g6IHBvc2l0aW9uID8gcG9zaXRpb24ueCA6IDAsXG4gICAgICAgICAgZG90X3k6IHBvc2l0aW9uID8gcG9zaXRpb24ueSA6IDAsXG4gICAgICAgICAgY2FudmFzX3dpZHRoOiBjYW52YXNSZWYuY3VycmVudCA/IGNhbnZhc1JlZi5jdXJyZW50LndpZHRoIDogMCxcbiAgICAgICAgICBjYW52YXNfaGVpZ2h0OiBjYW52YXNSZWYuY3VycmVudCA/IGNhbnZhc1JlZi5jdXJyZW50LmhlaWdodCA6IDAsXG4gICAgICAgICAgd2luZG93X3dpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICB3aW5kb3dfaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZVBhcmFtZXRlckNTVih1c2VkQ2FwdHVyZU51bWJlciwgcGFyYW1zKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgNDogSW5jcmVtZW50IGNvdW50ZXIgZm9yIG5leHQgY2FwdHVyZVxuICAgICAgICBpZiAodGhpcy5zZXRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgaXMgbWFuYWdpbmcgbnVtYmVyaW5nLCB1c2UgdGhlIG5leHQgbnVtYmVyXG4gICAgICAgICAgaWYgKHNjcmVlblJlc3BvbnNlICYmIHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIoc2NyZWVuUmVzcG9uc2UuY2FwdHVyZU51bWJlciArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA1OiBVcGRhdGUgc3RhdHVzXG4gICAgICAgIGlmICh0aGlzLnNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIHdpdGggZG90IGF0OiB4PSR7cG9zaXRpb24/Lnh9LCB5PSR7cG9zaXRpb24/Lnl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFN0ZXAgNjogU2hvdyBwcmV2aWV3IHVzaW5nIHRoZSBpbi1tZW1vcnkgaW1hZ2UgZGF0YVxuICAgICAgICB0aGlzLnNob3dDYXB0dXJlUHJldmlldyhzY3JlZW5JbWFnZSwgd2ViY2FtU3VjY2VzcyA/ICd3ZWJjYW1faW1hZ2VfZGF0YScgOiBudWxsLCBwb3NpdGlvbik7XG4gICAgICAgIFxuICAgICAgICAvLyBTdGVwIDc6IFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIHByZXZpZXcgaXMgZG9uZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAyMjAwKTsgLy8gV2FpdCBsb25nZXIgdGhhbiB0aGUgcHJldmlldyBkdXJhdGlvblxuICAgICAgICBcbiAgICAgICAgLy8gU3RlcCA4OiBDbGVhciBzdGF0dXMgYWZ0ZXIgYSBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGNhcHR1cmUgYW5kIHByZXZpZXc6JywgZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBlcnJvciBtZXNzYWdlXG4gICAgICAgIGlmICh0aGlzLnNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGV2ZW4gaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDE1MDApO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgZXJyb3IgbWVzc2FnZSBhZnRlciBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5zZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBleHBvcnQgZGVmYXVsdCBDYXB0dXJlSGFuZGxlcjsiXSwibmFtZXMiOlsiQ2FwdHVyZUhhbmRsZXIiLCJjb25zdHJ1Y3RvciIsInNhdmVGdW5jdGlvbiIsImNvdW50ZXJTZXR0ZXIiLCJzdGF0dXNTZXR0ZXIiLCJ0b2dnbGVUb3BCYXJGdW5jdGlvbiIsInNhdmVJbWFnZVRvU2VydmVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzZXRQcm9jZXNzU3RhdHVzIiwidG9nZ2xlVG9wQmFyIiwiY2FwdHVyZUZvbGRlciIsInNob3dDYXB0dXJlUHJldmlldyIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJkb3RQb3NpdGlvbiIsInByZXZpZXdDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsImNzc1RleHQiLCJjcmVhdGVJbWFnZVByZXZpZXciLCJpbWFnZURhdGEiLCJsYWJlbCIsInByZXZpZXciLCJpbWciLCJzcmMiLCJvbmxvYWQiLCJjb25zb2xlIiwibG9nIiwib25lcnJvciIsImUiLCJlcnJvciIsInRleHRMYWJlbCIsInRleHRDb250ZW50IiwiYXBwZW5kQ2hpbGQiLCJkZWJ1Z0luZm8iLCJzY3JlZW5QcmV2aWV3Iiwid2ViY2FtUHJldmlldyIsInBvc2l0aW9uSW5mbyIsIk1hdGgiLCJyb3VuZCIsIngiLCJ5IiwidGltZXJFbGVtZW50IiwiYm9keSIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5Iiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRvRml4ZWQiLCJjYXB0dXJlV2ViY2FtSW1hZ2UiLCJjYXB0dXJlTnVtYmVyIiwic3RyZWFtIiwidGVtcFZpZGVvIiwiZmlsZW5hbWUiLCJTdHJpbmciLCJwYWRTdGFydCIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwid2lkdGgiLCJpZGVhbCIsImhlaWdodCIsImZhY2luZ01vZGUiLCJhdWRpbyIsImF1dG9wbGF5IiwicGxheXNJbmxpbmUiLCJtdXRlZCIsInBvc2l0aW9uIiwibGVmdCIsInNyY09iamVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGltZW91dElkIiwid2FybiIsIm9ubG9hZGVkZGF0YSIsImNsZWFyVGltZW91dCIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsInRlbXBDYW52YXMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwiZ2V0VHJhY2tzIiwiZm9yRWFjaCIsInRyYWNrIiwic3RvcCIsInJlbW92ZSIsImNhcHR1cmVTY3JlZW5JbWFnZSIsImNhbnZhc1JlZiIsImNhbnZhcyIsImN1cnJlbnQiLCJzYXZlUmVzcG9uc2UiLCJzYXZlUGFyYW1ldGVyQ1NWIiwicGFyYW1zIiwiY3N2RGF0YSIsIk9iamVjdCIsImVudHJpZXMiLCJtYXAiLCJuYW1lIiwidmFsdWUiLCJqb2luIiwiY3N2QmxvYiIsIkJsb2IiLCJ0eXBlIiwiY3N2UmVhZGVyIiwiRmlsZVJlYWRlciIsImNzdkRhdGFVcmwiLCJvbmxvYWRlbmQiLCJyZXN1bHQiLCJyZWFkQXNEYXRhVVJMIiwiY3N2RXJyb3IiLCJjYXB0dXJlQW5kU2hvd1ByZXZpZXciLCJjYXB0dXJlQ291bnRlciIsInNjcmVlblJlc3BvbnNlIiwidXNlZENhcHR1cmVOdW1iZXIiLCJ3ZWJjYW1TdWNjZXNzIiwiZG90X3giLCJkb3RfeSIsImNhbnZhc193aWR0aCIsImNhbnZhc19oZWlnaHQiLCJ3aW5kb3dfd2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwid2luZG93X2hlaWdodCIsImlubmVySGVpZ2h0IiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwicHJldiIsIm1lc3NhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/CaptureHandler.js\n");

/***/ }),

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/DotCaptureUtil.js":
/*!**************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/DotCaptureUtil.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDotCountdown: () => (/* binding */ createDotCountdown),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   showImagePreview: () => (/* binding */ showImagePreview)\n/* harmony export */ });\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Show preview of captured images for exactly 2 seconds\n// DotCaptureUtil.js\n// Utility functions for dot capture and preview display\n// Improved function to show preview of captured images for exactly 2 seconds\nconst showImagePreview = (screenImage, webcamImage, dotPosition)=>{\n    // Create a preview container that centers in the screen\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 9999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n      opacity: 1;\n      transition: opacity 0.2s ease-in-out;\n    `;\n    // Add screen capture preview if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.style.cssText = `\n        max-width: 350px;\n        max-height: 250px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam capture preview if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.style.cssText = `\n        max-width: 350px;\n        max-height: 250px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n        positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -25px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add timer countdown\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n    previewContainer.appendChild(timerElement);\n    // Add the preview to the document\n    document.body.appendChild(previewContainer);\n    // Start countdown timer\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            timerElement.textContent = 'Closing...';\n            // Fade out the preview\n            previewContainer.style.opacity = '0';\n            // Remove after fade animation\n            setTimeout(()=>{\n                if (previewContainer && previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 200);\n        } else {\n            timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n        }\n    }, 100);\n    return previewContainer;\n};\n// Other utility functions remain the same...\n// Create and append a countdown element above a dot\nconst createDotCountdown = (position, canvasRect)=>{\n    // Create the countdown element directly above the dot\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'forced-countdown';\n    // Position it above the dot (calculate absolute position considering the canvas position)\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    countdownElement.style.cssText = `\n      position: fixed;\n      left: ${absoluteX}px;\n      top: ${absoluteY - 60}px;\n      transform: translateX(-50%);\n      color: red;\n      font-size: 36px;\n      font-weight: bold;\n      text-shadow: 0 0 10px white, 0 0 20px white;\n      z-index: 9999;\n      background-color: rgba(255, 255, 255, 0.8);\n      border: 2px solid red;\n      border-radius: 50%;\n      width: 50px;\n      height: 50px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    `;\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n// Draw a red dot on the canvas\nconst drawRedDot = (ctx, x, y, radius = 12)=>{\n    // Draw the dot with a glow effect\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect to the dot\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n// Initialize the canvas for drawing\nconst initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n// Generate a random position on the canvas\nconst getRandomPosition = (canvas, padding = 40)=>{\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vRG90Q2FwdHVyZVV0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxvQkFBb0I7QUFDcEIsd0RBQXdEO0FBRXhELHdEQUF3RDtBQUN4RCxvQkFBb0I7QUFDcEIsd0RBQXdEO0FBRXhELDZFQUE2RTtBQUN0RSxNQUFNQSxtQkFBbUIsQ0FBQ0MsYUFBYUMsYUFBYUM7SUFDdkQsd0RBQXdEO0lBQ3hELE1BQU1DLG1CQUFtQkMsU0FBU0MsYUFBYSxDQUFDO0lBQ2hERixpQkFBaUJHLFNBQVMsR0FBRztJQUM3QkgsaUJBQWlCSSxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7OztJQWNsQyxDQUFDO0lBRUQsMENBQTBDO0lBQzFDLElBQUlSLGFBQWE7UUFDZixNQUFNUyxnQkFBZ0JMLFNBQVNDLGFBQWEsQ0FBQztRQUM3Q0ksY0FBY0YsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7OztNQUkvQixDQUFDO1FBRUQsTUFBTUUsWUFBWU4sU0FBU0MsYUFBYSxDQUFDO1FBQ3pDSyxVQUFVQyxHQUFHLEdBQUdYO1FBQ2hCVSxVQUFVSCxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7OztNQUszQixDQUFDO1FBRUQsTUFBTUksY0FBY1IsU0FBU0MsYUFBYSxDQUFDO1FBQzNDTyxZQUFZQyxXQUFXLEdBQUc7UUFDMUJELFlBQVlMLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7O01BSzdCLENBQUM7UUFFREMsY0FBY0ssV0FBVyxDQUFDSjtRQUMxQkQsY0FBY0ssV0FBVyxDQUFDRjtRQUMxQlQsaUJBQWlCVyxXQUFXLENBQUNMO0lBQy9CO0lBRUEsMENBQTBDO0lBQzFDLElBQUlSLGFBQWE7UUFDZixNQUFNYyxnQkFBZ0JYLFNBQVNDLGFBQWEsQ0FBQztRQUM3Q1UsY0FBY1IsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7OztNQUkvQixDQUFDO1FBRUQsTUFBTVEsWUFBWVosU0FBU0MsYUFBYSxDQUFDO1FBQ3pDVyxVQUFVTCxHQUFHLEdBQUdWO1FBQ2hCZSxVQUFVVCxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7OztNQUszQixDQUFDO1FBRUQsTUFBTVMsY0FBY2IsU0FBU0MsYUFBYSxDQUFDO1FBQzNDWSxZQUFZSixXQUFXLEdBQUc7UUFDMUJJLFlBQVlWLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7O01BSzdCLENBQUM7UUFFRE8sY0FBY0QsV0FBVyxDQUFDRTtRQUMxQkQsY0FBY0QsV0FBVyxDQUFDRztRQUMxQmQsaUJBQWlCVyxXQUFXLENBQUNDO0lBQy9CO0lBRUEscUNBQXFDO0lBQ3JDLElBQUliLGFBQWE7UUFDZixNQUFNZ0IsZUFBZWQsU0FBU0MsYUFBYSxDQUFDO1FBQzVDYSxhQUFhTCxXQUFXLEdBQUcsQ0FBQyxnQkFBZ0IsRUFBRU0sS0FBS0MsS0FBSyxDQUFDbEIsWUFBWW1CLENBQUMsRUFBRSxJQUFJLEVBQUVGLEtBQUtDLEtBQUssQ0FBQ2xCLFlBQVlvQixDQUFDLEdBQUc7UUFDekdKLGFBQWFYLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7Ozs7Ozs7O01BUTlCLENBQUM7UUFDREwsaUJBQWlCVyxXQUFXLENBQUNJO0lBQy9CO0lBRUEsc0JBQXNCO0lBQ3RCLE1BQU1LLGVBQWVuQixTQUFTQyxhQUFhLENBQUM7SUFDNUNrQixhQUFhVixXQUFXLEdBQUc7SUFDM0JVLGFBQWFoQixLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7SUFTOUIsQ0FBQztJQUNETCxpQkFBaUJXLFdBQVcsQ0FBQ1M7SUFFN0Isa0NBQWtDO0lBQ2xDbkIsU0FBU29CLElBQUksQ0FBQ1YsV0FBVyxDQUFDWDtJQUUxQix3QkFBd0I7SUFDeEIsSUFBSXNCLFdBQVc7SUFDZixNQUFNQyxXQUFXQyxZQUFZO1FBQzNCRixZQUFZO1FBQ1osSUFBSUEsWUFBWSxHQUFHO1lBQ2pCRyxjQUFjRjtZQUNkSCxhQUFhVixXQUFXLEdBQUc7WUFFM0IsdUJBQXVCO1lBQ3ZCVixpQkFBaUJJLEtBQUssQ0FBQ3NCLE9BQU8sR0FBRztZQUVqQyw4QkFBOEI7WUFDOUJDLFdBQVc7Z0JBQ1QsSUFBSTNCLG9CQUFvQkEsaUJBQWlCNEIsVUFBVSxFQUFFO29CQUNuRDVCLGlCQUFpQjRCLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDN0I7Z0JBQzFDO1lBQ0YsR0FBRztRQUNMLE9BQU87WUFDTG9CLGFBQWFWLFdBQVcsR0FBRyxHQUFHWSxTQUFTUSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDdEQ7SUFDRixHQUFHO0lBRUgsT0FBTzlCO0FBQ1QsRUFBRTtBQUVGLDZDQUE2QztBQUU3QyxvREFBb0Q7QUFDN0MsTUFBTStCLHFCQUFxQixDQUFDQyxVQUFVQztJQUMzQyxzREFBc0Q7SUFDdEQsTUFBTUMsbUJBQW1CakMsU0FBU0MsYUFBYSxDQUFDO0lBQ2hEZ0MsaUJBQWlCL0IsU0FBUyxHQUFHO0lBRTdCLDBGQUEwRjtJQUMxRixNQUFNZ0MsWUFBWUYsV0FBV0csSUFBSSxHQUFHSixTQUFTZCxDQUFDO0lBQzlDLE1BQU1tQixZQUFZSixXQUFXSyxHQUFHLEdBQUdOLFNBQVNiLENBQUM7SUFFN0NlLGlCQUFpQjlCLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7O1lBRTFCLEVBQUU4QixVQUFVO1dBQ2IsRUFBRUUsWUFBWSxHQUFHOzs7Ozs7Ozs7Ozs7Ozs7O0lBZ0J4QixDQUFDO0lBQ0RwQyxTQUFTb0IsSUFBSSxDQUFDVixXQUFXLENBQUN1QjtJQUUxQixPQUFPQTtBQUNULEVBQUU7QUFFRiwrQkFBK0I7QUFDeEIsTUFBTUssYUFBYSxDQUFDQyxLQUFLdEIsR0FBR0MsR0FBR3NCLFNBQVMsRUFBRTtJQUMvQyxrQ0FBa0M7SUFDbENELElBQUlFLFNBQVM7SUFDYkYsSUFBSUcsR0FBRyxDQUFDekIsR0FBR0MsR0FBR3NCLFFBQVEsR0FBR3pCLEtBQUs0QixFQUFFLEdBQUc7SUFDbkNKLElBQUlLLFNBQVMsR0FBRztJQUNoQkwsSUFBSU0sSUFBSTtJQUVSLDZCQUE2QjtJQUM3Qk4sSUFBSUUsU0FBUztJQUNiRixJQUFJRyxHQUFHLENBQUN6QixHQUFHQyxHQUFHc0IsU0FBUyxHQUFHLEdBQUd6QixLQUFLNEIsRUFBRSxHQUFHO0lBQ3ZDSixJQUFJTyxXQUFXLEdBQUc7SUFDbEJQLElBQUlRLFNBQVMsR0FBRztJQUNoQlIsSUFBSVMsTUFBTTtJQUVWLE9BQU87UUFBRS9CO1FBQUdDO0lBQUU7QUFDaEIsRUFBRTtBQUVGLG9DQUFvQztBQUM3QixNQUFNK0IsbUJBQW1CLENBQUNDLFFBQVFDO0lBQ3ZDLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxRQUFRLE9BQU87SUFFL0Isd0NBQXdDO0lBQ3hDRCxPQUFPRSxLQUFLLEdBQUdELE9BQU9FLFdBQVc7SUFDakNILE9BQU9JLE1BQU0sR0FBR0gsT0FBT0ksWUFBWTtJQUVuQyx3Q0FBd0M7SUFDeEMsTUFBTWhCLE1BQU1XLE9BQU9NLFVBQVUsQ0FBQztJQUM5QmpCLElBQUlrQixTQUFTLENBQUMsR0FBRyxHQUFHUCxPQUFPRSxLQUFLLEVBQUVGLE9BQU9JLE1BQU07SUFDL0NmLElBQUlLLFNBQVMsR0FBRztJQUNoQkwsSUFBSW1CLFFBQVEsQ0FBQyxHQUFHLEdBQUdSLE9BQU9FLEtBQUssRUFBRUYsT0FBT0ksTUFBTTtJQUU5QyxPQUFPO0FBQ1QsRUFBRTtBQUVGLDJDQUEyQztBQUNwQyxNQUFNSyxvQkFBb0IsQ0FBQ1QsUUFBUVUsVUFBVSxFQUFFO0lBQ3BELElBQUksQ0FBQ1YsUUFBUSxPQUFPO1FBQUVqQyxHQUFHO1FBQUtDLEdBQUc7SUFBSSxHQUFHLG9CQUFvQjtJQUU1RCxNQUFNa0MsUUFBUUYsT0FBT0UsS0FBSyxJQUFJLEtBQU0seUJBQXlCO0lBQzdELE1BQU1FLFNBQVNKLE9BQU9JLE1BQU0sSUFBSSxLQUFLLDBCQUEwQjtJQUUvRCxPQUFPO1FBQ0xyQyxHQUFHRixLQUFLOEMsS0FBSyxDQUFDOUMsS0FBSytDLE1BQU0sS0FBTVYsQ0FBQUEsUUFBUSxJQUFJUSxPQUFNLEtBQU1BO1FBQ3ZEMUMsR0FBR0gsS0FBSzhDLEtBQUssQ0FBQzlDLEtBQUsrQyxNQUFNLEtBQU1SLENBQUFBLFNBQVMsSUFBSU0sT0FBTSxLQUFNQTtJQUMxRDtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0RvdENhcHR1cmVVdGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIERvdENhcHR1cmVVdGlsLmpzXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZG90IGNhcHR1cmUgYW5kIHByZXZpZXcgZGlzcGxheVxuXG4vLyBTaG93IHByZXZpZXcgb2YgY2FwdHVyZWQgaW1hZ2VzIGZvciBleGFjdGx5IDIgc2Vjb25kc1xuLy8gRG90Q2FwdHVyZVV0aWwuanNcbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBkb3QgY2FwdHVyZSBhbmQgcHJldmlldyBkaXNwbGF5XG5cbi8vIEltcHJvdmVkIGZ1bmN0aW9uIHRvIHNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXMgZm9yIGV4YWN0bHkgMiBzZWNvbmRzXG5leHBvcnQgY29uc3Qgc2hvd0ltYWdlUHJldmlldyA9IChzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSA9PiB7XG4gICAgLy8gQ3JlYXRlIGEgcHJldmlldyBjb250YWluZXIgdGhhdCBjZW50ZXJzIGluIHRoZSBzY3JlZW5cbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICBvcGFjaXR5OiAxO1xuICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzIGVhc2UtaW4tb3V0O1xuICAgIGA7XG4gICAgXG4gICAgLy8gQWRkIHNjcmVlbiBjYXB0dXJlIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCBzY3JlZW5JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHNjcmVlbkltZy5zcmMgPSBzY3JlZW5JbWFnZTtcbiAgICAgIHNjcmVlbkltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXgtd2lkdGg6IDM1MHB4O1xuICAgICAgICBtYXgtaGVpZ2h0OiAyNTBweDtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNjcmVlbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgICBzY3JlZW5MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkltZyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc2NyZWVuUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB3ZWJjYW0gY2FwdHVyZSBwcmV2aWV3IGlmIGF2YWlsYWJsZVxuICAgIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc3Qgd2ViY2FtUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd2ViY2FtUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgd2ViY2FtSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB3ZWJjYW1JbWcuc3JjID0gd2ViY2FtSW1hZ2U7XG4gICAgICB3ZWJjYW1JbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgbWF4LXdpZHRoOiAzNTBweDtcbiAgICAgICAgbWF4LWhlaWdodDogMjUwcHg7XG4gICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWJjYW1MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd2ViY2FtTGFiZWwudGV4dENvbnRlbnQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgICAgd2ViY2FtTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1JbWcpO1xuICAgICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1MYWJlbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgZG90IHBvc2l0aW9uIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgaWYgKGRvdFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvc2l0aW9uSW5mby50ZXh0Q29udGVudCA9IGBEb3QgcG9zaXRpb246IHg9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLngpfSwgeT0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueSl9YDtcbiAgICAgIHBvc2l0aW9uSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogI2ZmY2MwMDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTI1cHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3NpdGlvbkluZm8pO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgdGltZXIgY291bnRkb3duXG4gICAgY29uc3QgdGltZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJzIuMHMnO1xuICAgIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgYm90dG9tOiAtMjVweDtcbiAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxMnB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgICAgcGFkZGluZzogM3B4IDhweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICBgO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQodGltZXJFbGVtZW50KTtcbiAgICBcbiAgICAvLyBBZGQgdGhlIHByZXZpZXcgdG8gdGhlIGRvY3VtZW50XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICBcbiAgICAvLyBTdGFydCBjb3VudGRvd24gdGltZXJcbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJ0Nsb3NpbmcuLi4nO1xuICAgICAgICBcbiAgICAgICAgLy8gRmFkZSBvdXQgdGhlIHByZXZpZXdcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGZhZGUgYW5pbWF0aW9uXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyICYmIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICByZXR1cm4gcHJldmlld0NvbnRhaW5lcjtcbiAgfTtcbiAgXG4gIC8vIE90aGVyIHV0aWxpdHkgZnVuY3Rpb25zIHJlbWFpbiB0aGUgc2FtZS4uLlxuICAgIFxuICAvLyBDcmVhdGUgYW5kIGFwcGVuZCBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIGEgZG90XG4gIGV4cG9ydCBjb25zdCBjcmVhdGVEb3RDb3VudGRvd24gPSAocG9zaXRpb24sIGNhbnZhc1JlY3QpID0+IHtcbiAgICAvLyBDcmVhdGUgdGhlIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IGFib3ZlIHRoZSBkb3RcbiAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZm9yY2VkLWNvdW50ZG93bic7XG4gICAgXG4gICAgLy8gUG9zaXRpb24gaXQgYWJvdmUgdGhlIGRvdCAoY2FsY3VsYXRlIGFic29sdXRlIHBvc2l0aW9uIGNvbnNpZGVyaW5nIHRoZSBjYW52YXMgcG9zaXRpb24pXG4gICAgY29uc3QgYWJzb2x1dGVYID0gY2FudmFzUmVjdC5sZWZ0ICsgcG9zaXRpb24ueDtcbiAgICBjb25zdCBhYnNvbHV0ZVkgPSBjYW52YXNSZWN0LnRvcCArIHBvc2l0aW9uLnk7XG4gICAgXG4gICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogJHthYnNvbHV0ZVh9cHg7XG4gICAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgXG4gICAgcmV0dXJuIGNvdW50ZG93bkVsZW1lbnQ7XG4gIH07XG4gIFxuICAvLyBEcmF3IGEgcmVkIGRvdCBvbiB0aGUgY2FudmFzXG4gIGV4cG9ydCBjb25zdCBkcmF3UmVkRG90ID0gKGN0eCwgeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGdsb3cgZWZmZWN0XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gQWRkIGdsb3cgZWZmZWN0IHRvIHRoZSBkb3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJztcbiAgICBjdHgubGluZVdpZHRoID0gMztcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9O1xuICBcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgY2FudmFzIGZvciBkcmF3aW5nXG4gIGV4cG9ydCBjb25zdCBpbml0aWFsaXplQ2FudmFzID0gKGNhbnZhcywgcGFyZW50KSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCBwYXJlbnRcbiAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzIGFuZCBzZXQgd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIHBvc2l0aW9uIG9uIHRoZSBjYW52YXNcbiAgZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiB7IHg6IDEwMCwgeTogMTAwIH07IC8vIEZhbGxiYWNrIHBvc2l0aW9uXG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgfHwgMzAwOyAvLyBGYWxsYmFjayBpZiBoZWlnaHQgaXMgMFxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyICogcGFkZGluZykpICsgcGFkZGluZ1xuICAgIH07XG4gIH07Il0sIm5hbWVzIjpbInNob3dJbWFnZVByZXZpZXciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiZG90UG9zaXRpb24iLCJwcmV2aWV3Q29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0Iiwic2NyZWVuUHJldmlldyIsInNjcmVlbkltZyIsInNyYyIsInNjcmVlbkxhYmVsIiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsIndlYmNhbVByZXZpZXciLCJ3ZWJjYW1JbWciLCJ3ZWJjYW1MYWJlbCIsInBvc2l0aW9uSW5mbyIsIk1hdGgiLCJyb3VuZCIsIngiLCJ5IiwidGltZXJFbGVtZW50IiwiYm9keSIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5Iiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRvRml4ZWQiLCJjcmVhdGVEb3RDb3VudGRvd24iLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJjb3VudGRvd25FbGVtZW50IiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImRyYXdSZWREb3QiLCJjdHgiLCJyYWRpdXMiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGxTdHlsZSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImluaXRpYWxpemVDYW52YXMiLCJjYW52YXMiLCJwYXJlbnQiLCJ3aWR0aCIsImNsaWVudFdpZHRoIiwiaGVpZ2h0IiwiY2xpZW50SGVpZ2h0IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImZpbGxSZWN0IiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/DotCaptureUtil.js\n");

/***/ })

};
;