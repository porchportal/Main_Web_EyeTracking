"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_pages_collected-dataset_components-gui_WhiteScreenMain_js";
exports.ids = ["_pages-dir-node_pages_collected-dataset_components-gui_WhiteScreenMain_js"];
exports.modules = {

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/Action/countSave.js":
/*!********************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/Action/countSave.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   initializeCanvas: () => (/* binding */ initializeCanvas),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n// countSave.js\n// Shared functionality for countdown and image capture processes\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @param {Function} onComplete - Callback to execute when countdown finishes\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = `\n      position: fixed;\n      left: ${absoluteX}px;\n      top: ${absoluteY - 60}px;\n      transform: translateX(-50%);\n      color: red;\n      font-size: 36px;\n      font-weight: bold;\n      text-shadow: 0 0 10px white, 0 0 20px white;\n      z-index: 9999;\n      background-color: rgba(255, 255, 255, 0.8);\n      border: 2px solid red;\n      border-radius: 50%;\n      width: 50px;\n      height: 50px;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n    `;\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate?.({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate?.({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate?.({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    if (position && typeof position.x === 'number' && typeof position.y === 'number') {\n                        drawRedDot(ctx, position.x, position.y);\n                    } else {\n                        console.warn(\"[runCountdown] Position is null after countdown\", position);\n                    }\n                    if (onComplete) {\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate?.({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n   * Captures images from both canvas and webcam\n   * @param {Object} options - Capture options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {string} options.captureFolder - Folder to save captures in\n   * @returns {Object} - Result with captured image data\n   */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    try {\n        const counter = String(captureCounter).padStart(3, '0');\n        const screenFilename = `screen_${counter}.jpg`;\n        const webcamFilename = `webcam_${counter}.jpg`;\n        const parameterFilename = `parameter_${counter}.csv`;\n        console.log(`Starting capture process with counter: ${counter}`);\n        console.log(`Dot position: x=${position.x}, y=${position.y}`);\n        let screenImageData = null;\n        let webcamImageData = null;\n        let usedCaptureNumber = captureCounter;\n        // === 1. Capture screen image from canvas ===\n        const canvas = canvasRef.current;\n        if (canvas) {\n            try {\n                const ctx = canvas.getContext('2d');\n                // ✅ Make sure the red dot is drawn RIGHT before screen capture\n                drawRedDot(ctx, position.x, position.y);\n                console.log(`Canvas dimensions: ${canvas.width}x${canvas.height}`);\n                screenImageData = canvas.toDataURL('image/png');\n                console.log(`Screen image captured, size: ${screenImageData.length} chars`);\n                if (saveImageToServer) {\n                    const screenResponse = await saveImageToServer(screenImageData, screenFilename, 'screen', captureFolder);\n                    if (screenResponse && screenResponse.captureNumber) {\n                        usedCaptureNumber = screenResponse.captureNumber;\n                        console.log(`Server assigned capture number: ${usedCaptureNumber}`);\n                    }\n                }\n            } catch (screenError) {\n                console.error(\"Error capturing or saving screen image:\", screenError);\n            }\n        } else {\n            console.error(\"Canvas reference is null, cannot capture screen\");\n        }\n        // === 2. Capture webcam image ===\n        try {\n            console.log(\"Attempting to capture webcam silently\");\n            const videoElement = window.videoElement || document.querySelector('video');\n            if (videoElement && videoElement.readyState >= 2) {\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = videoElement.videoWidth || 640;\n                tempCanvas.height = videoElement.videoHeight || 480;\n                ctx.drawImage(videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, `webcam_${String(usedCaptureNumber).padStart(3, '0')}.jpg`, 'webcam', captureFolder);\n                }\n            } else {\n                const stream = await navigator.mediaDevices.getUserMedia({\n                    video: true,\n                    audio: false\n                });\n                const tempVideo = document.createElement('video');\n                tempVideo.autoplay = true;\n                tempVideo.playsInline = true;\n                tempVideo.muted = true;\n                tempVideo.style.position = 'absolute';\n                tempVideo.style.left = '-9999px';\n                tempVideo.style.opacity = '0';\n                document.body.appendChild(tempVideo);\n                tempVideo.srcObject = stream;\n                await new Promise((resolve)=>{\n                    const timeoutId = setTimeout(resolve, 1000);\n                    tempVideo.onloadeddata = ()=>{\n                        clearTimeout(timeoutId);\n                        resolve();\n                    };\n                });\n                await new Promise((resolve)=>setTimeout(resolve, 200));\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = tempVideo.videoWidth || 640;\n                tempCanvas.height = tempVideo.videoHeight || 480;\n                ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImageData = tempCanvas.toDataURL('image/png');\n                if (saveImageToServer) {\n                    await saveImageToServer(webcamImageData, `webcam_${String(usedCaptureNumber).padStart(3, '0')}.jpg`, 'webcam', captureFolder);\n                }\n                stream.getTracks().forEach((track)=>track.stop());\n                tempVideo.srcObject = null;\n                if (tempVideo.parentNode) {\n                    tempVideo.parentNode.removeChild(tempVideo);\n                }\n            }\n        } catch (webcamError) {\n            console.error(\"Error capturing webcam silently:\", webcamError);\n        }\n        // === 3. Save parameter CSV ===\n        try {\n            console.log(\"Creating parameter CSV\");\n            const csvData = [\n                \"name,value\",\n                `dot_x,${position.x}`,\n                `dot_y,${position.y}`,\n                `canvas_width,${canvas ? canvas.width : 0}`,\n                `canvas_height,${canvas ? canvas.height : 0}`,\n                `window_width,${window.innerWidth}`,\n                `window_height,${window.innerHeight}`,\n                `timestamp,${new Date().toISOString()}`\n            ].join('\\n');\n            const csvBlob = new Blob([\n                csvData\n            ], {\n                type: 'text/csv'\n            });\n            const csvReader = new FileReader();\n            const csvDataUrl = await new Promise((resolve)=>{\n                csvReader.onloadend = ()=>resolve(csvReader.result);\n                csvReader.readAsDataURL(csvBlob);\n            });\n            if (saveImageToServer) {\n                await saveImageToServer(csvDataUrl, `parameter_${String(usedCaptureNumber).padStart(3, '0')}.csv`, 'parameters', captureFolder);\n            }\n        } catch (csvError) {\n            console.error(\"Error saving parameter CSV:\", csvError);\n        }\n        // === 4. Update counter ===\n        if (setCaptureCounter) {\n            setCaptureCounter(usedCaptureNumber + 1);\n        }\n        // === 5. Set process status ===\n        if (setProcessStatus) {\n            setProcessStatus(`Captured with dot at: x=${position.x}, y=${position.y}`);\n        }\n        // === 6. Return capture data ===\n        return {\n            screenImage: screenImageData,\n            webcamImage: webcamImageData,\n            position,\n            captureNumber: usedCaptureNumber\n        };\n    } catch (error) {\n        console.error(\"Error during capture:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(`Error capturing images: ${error.message}`);\n        }\n        throw error;\n    }\n};\n/**\n   * Display a preview of the captured images\n   * @param {string} screenImage - Data URL of the screen image\n   * @param {string} webcamImage - Data URL of the webcam image\n   * @param {Object} dotPosition - {x, y} position of the dot\n   */ const showCapturePreview = (screenImage, webcamImage, dotPosition)=>{\n    if (!screenImage && !webcamImage) {\n        console.warn(\"No images available to preview\");\n        return;\n    }\n    // Remove any existing preview containers first\n    try {\n        const existingPreviews = document.querySelectorAll('.capture-preview-container');\n        existingPreviews.forEach((preview)=>{\n            if (preview.parentNode) {\n                console.log(\"Removing existing preview container\");\n                preview.parentNode.removeChild(preview);\n            }\n        });\n    } catch (cleanupError) {\n        console.error(\"Error cleaning up existing previews:\", cleanupError);\n    }\n    // Create a new preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 999999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n    `;\n    // Function to add an image to the preview\n    const addImagePreview = (image, label)=>{\n        try {\n            const preview = document.createElement('div');\n            preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n            const img = document.createElement('img');\n            img.src = image;\n            img.alt = label;\n            img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n            const labelElement = document.createElement('div');\n            labelElement.textContent = label;\n            labelElement.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n            preview.appendChild(img);\n            preview.appendChild(labelElement);\n            previewContainer.appendChild(preview);\n            return true;\n        } catch (error) {\n            console.error(`Error adding ${label} preview:`, error);\n            return false;\n        }\n    };\n    // Add debug info div\n    const debugInfo = document.createElement('div');\n    debugInfo.style.cssText = `\n      position: absolute;\n      top: -30px;\n      left: 0;\n      width: 100%;\n      color: white;\n      font-size: 12px;\n      text-align: center;\n    `;\n    debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n    previewContainer.appendChild(debugInfo);\n    // Add both images to preview if available\n    if (screenImage) {\n        addImagePreview(screenImage, 'Screen Capture');\n    }\n    if (webcamImage) {\n        addImagePreview(webcamImage, 'Webcam Capture');\n    }\n    // Add dot position info if available\n    if (dotPosition) {\n        const positionInfo = document.createElement('div');\n        positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n        positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -50px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n        previewContainer.appendChild(positionInfo);\n    }\n    // Add countdown timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n    previewContainer.appendChild(timerElement);\n    // Add to document body\n    document.body.appendChild(previewContainer);\n    // Countdown and remove the preview after 2 seconds\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            // Fade out\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            previewContainer.style.opacity = '0';\n            // Remove after fade\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n        }\n    }, 100);\n    // Safety cleanup after 5 seconds in case anything goes wrong\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n    return previewContainer;\n};\n/**\n   * Complete capture and preview process\n   * @param {Object} options - Process options\n   * @param {React.RefObject} options.canvasRef - Ref to the canvas element\n   * @param {Object} options.position - {x, y} position of the dot\n   * @param {number} options.captureCounter - Current capture counter\n   * @param {Function} options.saveImageToServer - Function to save image to server\n   * @param {Function} options.setCaptureCounter - Function to update capture counter\n   * @param {Function} options.setProcessStatus - Function to update process status\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.onStatusUpdate - Function to update status\n   * @param {string} options.captureFolder - Folder to save captures in\n   */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, saveImageToServer, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.error('[captureImages] Invalid position:', position);\n        setProcessStatus?.('Error: Invalid dot position (captureImages)');\n        return;\n    }\n    let dotInterval;\n    try {\n        // Make sure we have a valid canvas reference\n        if (!canvasRef?.current) {\n            throw new Error(\"Canvas reference is invalid\");\n        }\n        // Draw the dot in its position first to ensure it's visible\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext('2d');\n        // Initially draw the dot\n        drawRedDot(ctx, position.x, position.y);\n        // Create an interval to keep redrawing the dot to ensure it stays visible\n        dotInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y);\n        }, 200);\n        // First run the countdown\n        //   await runCountdown(\n        //     position,\n        //     canvasRef.current,\n        //     onStatusUpdate, \n        //     null // No callback here as we'll handle it directly\n        //   );\n        await runCountdown(position, canvas, onStatusUpdate, async ()=>{\n            try {\n                // ✅ Validate again here if needed\n                if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n                    throw new Error('Position is missing after countdown');\n                }\n                // Capture both canvas and webcam\n                const result = await captureImages({\n                    canvasRef,\n                    position,\n                    captureCounter,\n                    saveImageToServer,\n                    setCaptureCounter,\n                    setProcessStatus,\n                    toggleTopBar,\n                    captureFolder\n                });\n                return result;\n            } catch (err) {\n                console.error('[captureAndPreviewProcess] Error during capture:', err);\n                setProcessStatus?.(`Error: ${err.message}`);\n            }\n        });\n        // Make sure dot is visible after countdown\n        drawRedDot(ctx, position.x, position.y);\n        // Capture the images\n        const captureResult = await captureImages({\n            canvasRef,\n            position,\n            captureCounter,\n            saveImageToServer,\n            setCaptureCounter,\n            setProcessStatus,\n            toggleTopBar,\n            captureFolder\n        });\n        // Make sure dot is visible after capturing\n        drawRedDot(ctx, position.x, position.y);\n        // Show preview of captured images\n        showCapturePreview(captureResult.screenImage, captureResult.webcamImage, captureResult.position);\n        // Make sure dot is visible after preview\n        drawRedDot(ctx, position.x, position.y);\n        // Show TopBar again after a delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if (false) {}\n            // Make sure dot is still visible even after showing TopBar\n            drawRedDot(ctx, position.x, position.y);\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"Error in capture and preview process:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(`Error: ${error.message}`);\n        }\n        // Show TopBar again even if error occurred\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if (false) {}\n        }, 1500);\n        throw error;\n    } finally{\n        // Clear the dot redraw interval if it was created\n        if (dotInterval) {\n            clearInterval(dotInterval);\n        }\n    }\n};\n/**\n   * Generate a random dot position within the canvas\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {number} padding - Padding from the edges\n   * @returns {Object} - {x, y} position\n   */ const getRandomPosition = (canvas, padding = 40)=>{\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n   * Draw a red dot on the canvas\n   * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n   * @param {number} x - X coordinate\n   * @param {number} y - Y coordinate\n   * @param {number} radius - Dot radius\n   * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n   * @returns {Object} - {x, y} position\n   */ const drawRedDot = (ctx, x, y, radius = 12, clearCanvas = true)=>{\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n   * Initialize canvas for drawing\n   * @param {HTMLCanvasElement} canvas - Canvas element\n   * @param {HTMLElement} parent - Parent element for dimensions\n   * @returns {boolean} - Success status\n   */ const initializeCanvas = (canvas, parent)=>{\n    if (!canvas || !parent) return false;\n    // Set canvas dimensions to match parent\n    canvas.width = parent.clientWidth;\n    canvas.height = parent.clientHeight;\n    // Clear canvas and set white background\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    return true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL0FjdGlvbi9jb3VudFNhdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ2YsaUVBQWlFO0FBRWpFOzs7Ozs7Q0FNQyxHQUNNLE1BQU1BLHlCQUF5QixDQUFDQyxVQUFVQztJQUM3QyxJQUFJLENBQUNELFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyw4Q0FBOENMO1FBQzNELE9BQU87SUFDVDtJQUVBLE1BQU1NLHFCQUFxQkMsU0FBU0MsZ0JBQWdCLENBQUM7SUFDckRGLG1CQUFtQkcsT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHQyxNQUFNO0lBRTFDLE1BQU1DLFlBQVlYLFdBQVdZLElBQUksR0FBR2IsU0FBU0UsQ0FBQztJQUM5QyxNQUFNWSxZQUFZYixXQUFXYyxHQUFHLEdBQUdmLFNBQVNHLENBQUM7SUFFN0MsTUFBTWEsbUJBQW1CVCxTQUFTVSxhQUFhLENBQUM7SUFDaERELGlCQUFpQkUsU0FBUyxHQUFHO0lBQzdCRixpQkFBaUJHLEtBQUssQ0FBQ0MsT0FBTyxHQUFHLENBQUM7O1lBRTFCLEVBQUVSLFVBQVU7V0FDYixFQUFFRSxZQUFZLEdBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQnhCLENBQUM7SUFFRFAsU0FBU2MsSUFBSSxDQUFDQyxXQUFXLENBQUNOO0lBQzFCLE9BQU9BO0FBQ1QsRUFBRTtBQUVGOzs7Ozs7Q0FNRCxHQUNNLE1BQU1PLGVBQWUsT0FBT3ZCLFVBQVV3QixRQUFRQyxnQkFBZ0JDO0lBQ2pFLElBQUksQ0FBQzFCLFlBQVksT0FBT0EsU0FBU0UsQ0FBQyxLQUFLLFlBQVksT0FBT0YsU0FBU0csQ0FBQyxLQUFLLFVBQVU7UUFDakZDLFFBQVFDLElBQUksQ0FBQyxvQ0FBb0NMO1FBQ2pEeUIsaUJBQWlCO1lB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QztJQUFFO0FBQ2hCLEVBQUU7QUFFRjs7Ozs7R0FLQyxHQUNNLE1BQU04SixtQkFBbUIsQ0FBQ3pJLFFBQVEwSTtJQUN2QyxJQUFJLENBQUMxSSxVQUFVLENBQUMwSSxRQUFRLE9BQU87SUFFL0Isd0NBQXdDO0lBQ3hDMUksT0FBT3dDLEtBQUssR0FBR2tHLE9BQU9DLFdBQVc7SUFDakMzSSxPQUFPeUMsTUFBTSxHQUFHaUcsT0FBT0UsWUFBWTtJQUVuQyx3Q0FBd0M7SUFDeEMsTUFBTXJJLE1BQU1QLE9BQU9RLFVBQVUsQ0FBQztJQUM5QkQsSUFBSXdILFNBQVMsQ0FBQyxHQUFHLEdBQUcvSCxPQUFPd0MsS0FBSyxFQUFFeEMsT0FBT3lDLE1BQU07SUFDL0NsQyxJQUFJeUgsU0FBUyxHQUFHO0lBQ2hCekgsSUFBSTBILFFBQVEsQ0FBQyxHQUFHLEdBQUdqSSxPQUFPd0MsS0FBSyxFQUFFeEMsT0FBT3lDLE1BQU07SUFFOUMsT0FBTztBQUNULEVBQUUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9wb3JjaHBvcnRhbDIvRGVza3RvcC/wn5SlZXZlcnl0aGluZy9NYWluX1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9BY3Rpb24vY291bnRTYXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvdW50U2F2ZS5qc1xuLy8gU2hhcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGNvdW50ZG93biBhbmQgaW1hZ2UgY2FwdHVyZSBwcm9jZXNzZXNcblxuLyoqXG4gKiBDcmVhdGVzIGFuZCBkaXNwbGF5cyBhIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIGEgZG90IHBvc2l0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtET01SZWN0fSBjYW52YXNSZWN0IC0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgb2YgdGhlIGNhbnZhc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBjb3VudGRvd24gZmluaXNoZXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBUaGUgY3JlYXRlZCBjb3VudGRvd24gZWxlbWVudFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ291bnRkb3duRWxlbWVudCA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKCdbY3JlYXRlQ291bnRkb3duRWxlbWVudF0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtY291bnRkb3duLCAuZm9yY2VkLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwJyk7XG4gICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4gZWwucmVtb3ZlKCkpO1xuICBcbiAgICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICAgIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueTtcbiAgXG4gICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgICAgdG9wOiAke2Fic29sdXRlWSAtIDYwfXB4O1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgY29sb3I6IHJlZDtcbiAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogNTBweDtcbiAgICAgIGhlaWdodDogNTBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgYDtcbiAgXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICByZXR1cm4gY291bnRkb3duRWxlbWVudDtcbiAgfTtcbiAgXG4gIC8qKlxuICogUnVucyBhIGNvdW50ZG93biBwcm9jZXNzIHRoYXQgZGlzcGxheXMgMy0yLTEgYWJvdmUgYSBkb3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSBkb3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU3RhdHVzVXBkYXRlIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHN0YXR1cyBtZXNzYWdlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBjb3VudGRvd24gY29tcGxldGVzXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Db3VudGRvd24gPSBhc3luYyAocG9zaXRpb24sIGNhbnZhcywgb25TdGF0dXNVcGRhdGUsIG9uQ29tcGxldGUpID0+IHtcbiAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJJbnZhbGlkIGRvdCBwb3NpdGlvblwiLFxuICAgICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9zaXRpb24sIGNhbnZhc1JlY3QpO1xuICAgIFxuICAgIGlmICghY291bnRkb3duRWxlbWVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdbcnVuQ291bnRkb3duXSBDb3VudGRvd24gZWxlbWVudCBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIFxuICAgIGxldCBjb3VudCA9IDM7XG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICBcbiAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgIH0pO1xuICBcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNvbnN0IGNvdW50ZG93bkludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBjb3VudC0tO1xuICBcbiAgICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50ZG93bkludGVydmFsKTtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgXG4gICAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgICBjb3VudGRvd25WYWx1ZTogXCJDYXB0dXJpbmcuLi5cIixcbiAgICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ2FwdHVyaW5nIGltYWdlLi4uXCIsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICBcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAmJiB0eXBlb2YgcG9zaXRpb24ueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHBvc2l0aW9uLnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbcnVuQ291bnRkb3duXSBQb3NpdGlvbiBpcyBudWxsIGFmdGVyIGNvdW50ZG93blwiLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICBcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCA4MDApO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogQ2FwdHVyZXMgaW1hZ2VzIGZyb20gYm90aCBjYW52YXMgYW5kIHdlYmNhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENhcHR1cmUgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlYWN0LlJlZk9iamVjdH0gb3B0aW9ucy5jYW52YXNSZWYgLSBSZWYgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwdHVyZUNvdW50ZXIgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNhdmVJbWFnZVRvU2VydmVyIC0gRnVuY3Rpb24gdG8gc2F2ZSBpbWFnZSB0byBzZXJ2ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRDYXB0dXJlQ291bnRlciAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRQcm9jZXNzU3RhdHVzIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHByb2Nlc3Mgc3RhdHVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYXB0dXJlRm9sZGVyIC0gRm9sZGVyIHRvIHNhdmUgY2FwdHVyZXMgaW5cbiAgICogQHJldHVybnMge09iamVjdH0gLSBSZXN1bHQgd2l0aCBjYXB0dXJlZCBpbWFnZSBkYXRhXG4gICAqL1xuICBleHBvcnQgY29uc3QgY2FwdHVyZUltYWdlcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb3VudGVyID0gU3RyaW5nKGNhcHR1cmVDb3VudGVyKS5wYWRTdGFydCgzLCAnMCcpO1xuICAgICAgY29uc3Qgc2NyZWVuRmlsZW5hbWUgPSBgc2NyZWVuXyR7Y291bnRlcn0uanBnYDtcbiAgICAgIGNvbnN0IHdlYmNhbUZpbGVuYW1lID0gYHdlYmNhbV8ke2NvdW50ZXJ9LmpwZ2A7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJGaWxlbmFtZSA9IGBwYXJhbWV0ZXJfJHtjb3VudGVyfS5jc3ZgO1xuICBcbiAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlIHByb2Nlc3Mgd2l0aCBjb3VudGVyOiAke2NvdW50ZXJ9YCk7XG4gICAgICBjb25zb2xlLmxvZyhgRG90IHBvc2l0aW9uOiB4PSR7cG9zaXRpb24ueH0sIHk9JHtwb3NpdGlvbi55fWApO1xuICBcbiAgICAgIGxldCBzY3JlZW5JbWFnZURhdGEgPSBudWxsO1xuICAgICAgbGV0IHdlYmNhbUltYWdlRGF0YSA9IG51bGw7XG4gICAgICBsZXQgdXNlZENhcHR1cmVOdW1iZXIgPSBjYXB0dXJlQ291bnRlcjtcbiAgXG4gICAgICAvLyA9PT0gMS4gQ2FwdHVyZSBzY3JlZW4gaW1hZ2UgZnJvbSBjYW52YXMgPT09XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgXG4gICAgICAgICAgLy8g4pyFIE1ha2Ugc3VyZSB0aGUgcmVkIGRvdCBpcyBkcmF3biBSSUdIVCBiZWZvcmUgc2NyZWVuIGNhcHR1cmVcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgZGltZW5zaW9uczogJHtjYW52YXMud2lkdGh9eCR7Y2FudmFzLmhlaWdodH1gKTtcbiAgICAgICAgICBzY3JlZW5JbWFnZURhdGEgPSBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2NyZWVuIGltYWdlIGNhcHR1cmVkLCBzaXplOiAke3NjcmVlbkltYWdlRGF0YS5sZW5ndGh9IGNoYXJzYCk7XG4gIFxuICAgICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuUmVzcG9uc2UgPSBhd2FpdCBzYXZlSW1hZ2VUb1NlcnZlcihcbiAgICAgICAgICAgICAgc2NyZWVuSW1hZ2VEYXRhLFxuICAgICAgICAgICAgICBzY3JlZW5GaWxlbmFtZSxcbiAgICAgICAgICAgICAgJ3NjcmVlbicsXG4gICAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgICAgICk7XG4gIFxuICAgICAgICAgICAgaWYgKHNjcmVlblJlc3BvbnNlICYmIHNjcmVlblJlc3BvbnNlLmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgdXNlZENhcHR1cmVOdW1iZXIgPSBzY3JlZW5SZXNwb25zZS5jYXB0dXJlTnVtYmVyO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU2VydmVyIGFzc2lnbmVkIGNhcHR1cmUgbnVtYmVyOiAke3VzZWRDYXB0dXJlTnVtYmVyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoc2NyZWVuRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIG9yIHNhdmluZyBzY3JlZW4gaW1hZ2U6XCIsIHNjcmVlbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbCwgY2Fubm90IGNhcHR1cmUgc2NyZWVuXCIpO1xuICAgICAgfVxuICBcbiAgICAgIC8vID09PSAyLiBDYXB0dXJlIHdlYmNhbSBpbWFnZSA9PT1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBjYXB0dXJlIHdlYmNhbSBzaWxlbnRseVwiKTtcbiAgXG4gICAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHdpbmRvdy52aWRlb0VsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgXG4gICAgICAgIGlmICh2aWRlb0VsZW1lbnQgJiYgdmlkZW9FbGVtZW50LnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHZpZGVvRWxlbWVudC52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHZpZGVvRWxlbWVudC52aWRlb0hlaWdodCB8fCA0ODA7XG4gIFxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodmlkZW9FbGVtZW50LCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgd2ViY2FtSW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICBcbiAgICAgICAgICBpZiAoc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEsXG4gICAgICAgICAgICAgIGB3ZWJjYW1fJHtTdHJpbmcodXNlZENhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2AsXG4gICAgICAgICAgICAgICd3ZWJjYW0nLFxuICAgICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGlvOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBjb25zdCB0ZW1wVmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgIHRlbXBWaWRlby5hdXRvcGxheSA9IHRydWU7XG4gICAgICAgICAgdGVtcFZpZGVvLnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8ubXV0ZWQgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWaWRlby5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICBcbiAgICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuICBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKTtcbiAgICAgICAgICAgIHRlbXBWaWRlby5vbmxvYWRlZGRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gIFxuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHRlbXBWaWRlby52aWRlb1dpZHRoIHx8IDY0MDtcbiAgICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHRlbXBWaWRlby52aWRlb0hlaWdodCB8fCA0ODA7XG4gIFxuICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGVtcFZpZGVvLCAwLCAwLCB0ZW1wQ2FudmFzLndpZHRoLCB0ZW1wQ2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgd2ViY2FtSW1hZ2VEYXRhID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICBcbiAgICAgICAgICBpZiAoc2F2ZUltYWdlVG9TZXJ2ZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgICB3ZWJjYW1JbWFnZURhdGEsXG4gICAgICAgICAgICAgIGB3ZWJjYW1fJHtTdHJpbmcodXNlZENhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmpwZ2AsXG4gICAgICAgICAgICAgICd3ZWJjYW0nLFxuICAgICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgICAgICB0ZW1wVmlkZW8uc3JjT2JqZWN0ID0gbnVsbDtcbiAgICAgICAgICBpZiAodGVtcFZpZGVvLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRlbXBWaWRlby5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXBWaWRlbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoICh3ZWJjYW1FcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FwdHVyaW5nIHdlYmNhbSBzaWxlbnRseTpcIiwgd2ViY2FtRXJyb3IpO1xuICAgICAgfVxuICBcbiAgICAgIC8vID09PSAzLiBTYXZlIHBhcmFtZXRlciBDU1YgPT09XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNyZWF0aW5nIHBhcmFtZXRlciBDU1ZcIik7XG4gIFxuICAgICAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgICAgIFwibmFtZSx2YWx1ZVwiLFxuICAgICAgICAgIGBkb3RfeCwke3Bvc2l0aW9uLnh9YCxcbiAgICAgICAgICBgZG90X3ksJHtwb3NpdGlvbi55fWAsXG4gICAgICAgICAgYGNhbnZhc193aWR0aCwke2NhbnZhcyA/IGNhbnZhcy53aWR0aCA6IDB9YCxcbiAgICAgICAgICBgY2FudmFzX2hlaWdodCwke2NhbnZhcyA/IGNhbnZhcy5oZWlnaHQgOiAwfWAsXG4gICAgICAgICAgYHdpbmRvd193aWR0aCwke3dpbmRvdy5pbm5lcldpZHRofWAsXG4gICAgICAgICAgYHdpbmRvd19oZWlnaHQsJHt3aW5kb3cuaW5uZXJIZWlnaHR9YCxcbiAgICAgICAgICBgdGltZXN0YW1wLCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfWBcbiAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgXG4gICAgICAgIGNvbnN0IGNzdkJsb2IgPSBuZXcgQmxvYihbY3N2RGF0YV0sIHsgdHlwZTogJ3RleHQvY3N2JyB9KTtcbiAgICAgICAgY29uc3QgY3N2UmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgXG4gICAgICAgIGNvbnN0IGNzdkRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGNzdlJlYWRlci5vbmxvYWRlbmQgPSAoKSA9PiByZXNvbHZlKGNzdlJlYWRlci5yZXN1bHQpO1xuICAgICAgICAgIGNzdlJlYWRlci5yZWFkQXNEYXRhVVJMKGNzdkJsb2IpO1xuICAgICAgICB9KTtcbiAgXG4gICAgICAgIGlmIChzYXZlSW1hZ2VUb1NlcnZlcikge1xuICAgICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKFxuICAgICAgICAgICAgY3N2RGF0YVVybCxcbiAgICAgICAgICAgIGBwYXJhbWV0ZXJfJHtTdHJpbmcodXNlZENhcHR1cmVOdW1iZXIpLnBhZFN0YXJ0KDMsICcwJyl9LmNzdmAsXG4gICAgICAgICAgICAncGFyYW1ldGVycycsXG4gICAgICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoY3N2RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBwYXJhbWV0ZXIgQ1NWOlwiLCBjc3ZFcnJvcik7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDQuIFVwZGF0ZSBjb3VudGVyID09PVxuICAgICAgaWYgKHNldENhcHR1cmVDb3VudGVyKSB7XG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyKHVzZWRDYXB0dXJlTnVtYmVyICsgMSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gPT09IDUuIFNldCBwcm9jZXNzIHN0YXR1cyA9PT1cbiAgICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIHdpdGggZG90IGF0OiB4PSR7cG9zaXRpb24ueH0sIHk9JHtwb3NpdGlvbi55fWApO1xuICAgICAgfVxuICBcbiAgICAgIC8vID09PSA2LiBSZXR1cm4gY2FwdHVyZSBkYXRhID09PVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6IHNjcmVlbkltYWdlRGF0YSxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHdlYmNhbUltYWdlRGF0YSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVOdW1iZXI6IHVzZWRDYXB0dXJlTnVtYmVyXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGNhcHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYEVycm9yIGNhcHR1cmluZyBpbWFnZXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8qKlxuICAgKiBEaXNwbGF5IGEgcHJldmlldyBvZiB0aGUgY2FwdHVyZWQgaW1hZ2VzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY3JlZW5JbWFnZSAtIERhdGEgVVJMIG9mIHRoZSBzY3JlZW4gaW1hZ2VcbiAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmNhbUltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHdlYmNhbSBpbWFnZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZG90UG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICAgKi9cbiAgZXhwb3J0IGNvbnN0IHNob3dDYXB0dXJlUHJldmlldyA9IChzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKCFzY3JlZW5JbWFnZSAmJiAhd2ViY2FtSW1hZ2UpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIGltYWdlcyBhdmFpbGFibGUgdG8gcHJldmlld1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIFxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlldyBjb250YWluZXJzIGZpcnN0XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUHJldmlld3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcicpO1xuICAgICAgZXhpc3RpbmdQcmV2aWV3cy5mb3JFYWNoKHByZXZpZXcgPT4ge1xuICAgICAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJSZW1vdmluZyBleGlzdGluZyBwcmV2aWV3IGNvbnRhaW5lclwiKTtcbiAgICAgICAgICBwcmV2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlldyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGNsZWFuaW5nIHVwIGV4aXN0aW5nIHByZXZpZXdzOlwiLCBjbGVhbnVwRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDcmVhdGUgYSBuZXcgcHJldmlldyBjb250YWluZXJcbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICBgO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGFkZCBhbiBpbWFnZSB0byB0aGUgcHJldmlld1xuICAgIGNvbnN0IGFkZEltYWdlUHJldmlldyA9IChpbWFnZSwgbGFiZWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZTtcbiAgICAgICAgaW1nLmFsdCA9IGxhYmVsO1xuICAgICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICBsYWJlbEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQobGFiZWxFbGVtZW50KTtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgJHtsYWJlbH0gcHJldmlldzpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBkZWJ1ZyBpbmZvIGRpdlxuICAgIGNvbnN0IGRlYnVnSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRlYnVnSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAtMzBweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBgO1xuICAgIGRlYnVnSW5mby50ZXh0Q29udGVudCA9IGBTY3JlZW46ICR7c2NyZWVuSW1hZ2UgPyAnWUVTJyA6ICdOTyd9LCBXZWJjYW06ICR7d2ViY2FtSW1hZ2UgPyAnWUVTJyA6ICdOTyd9YDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKGRlYnVnSW5mbyk7XG4gICAgXG4gICAgLy8gQWRkIGJvdGggaW1hZ2VzIHRvIHByZXZpZXcgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBhZGRJbWFnZVByZXZpZXcoc2NyZWVuSW1hZ2UsICdTY3JlZW4gQ2FwdHVyZScpO1xuICAgIH1cbiAgICBcbiAgICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICAgIGFkZEltYWdlUHJldmlldyh3ZWJjYW1JbWFnZSwgJ1dlYmNhbSBDYXB0dXJlJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBkb3QgcG9zaXRpb24gaW5mbyBpZiBhdmFpbGFibGVcbiAgICBpZiAoZG90UG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uSW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcG9zaXRpb25JbmZvLnRleHRDb250ZW50ID0gYERvdCBwb3NpdGlvbjogeD0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi55KX1gO1xuICAgICAgcG9zaXRpb25JbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtNTBweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgIGA7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvc2l0aW9uSW5mbyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCBjb3VudGRvd24gdGltZXJcbiAgICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gICAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBib3R0b206IC0yNXB4O1xuICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgIGA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICAgIFxuICAgIC8vIEFkZCB0byBkb2N1bWVudCBib2R5XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICBcbiAgICAvLyBDb3VudGRvd24gYW5kIHJlbW92ZSB0aGUgcHJldmlldyBhZnRlciAyIHNlY29uZHNcbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMC4zcyBlYXNlJztcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICAgIH1cbiAgICB9LCAxMDApO1xuICAgIFxuICAgIC8vIFNhZmV0eSBjbGVhbnVwIGFmdGVyIDUgc2Vjb25kcyBpbiBjYXNlIGFueXRoaW5nIGdvZXMgd3JvbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgfVxuICAgIH0sIDUwMDApO1xuICAgIFxuICAgIHJldHVybiBwcmV2aWV3Q29udGFpbmVyO1xuICB9O1xuICBcbiAgLyoqXG4gICAqIENvbXBsZXRlIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2Vzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFByb2Nlc3Mgb3B0aW9uc1xuICAgKiBAcGFyYW0ge1JlYWN0LlJlZk9iamVjdH0gb3B0aW9ucy5jYW52YXNSZWYgLSBSZWYgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLnBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuY2FwdHVyZUNvdW50ZXIgLSBDdXJyZW50IGNhcHR1cmUgY291bnRlclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLnNhdmVJbWFnZVRvU2VydmVyIC0gRnVuY3Rpb24gdG8gc2F2ZSBpbWFnZSB0byBzZXJ2ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRDYXB0dXJlQ291bnRlciAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy5zZXRQcm9jZXNzU3RhdHVzIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHByb2Nlc3Mgc3RhdHVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudG9nZ2xlVG9wQmFyIC0gRnVuY3Rpb24gdG8gdG9nZ2xlIHRvcCBiYXIgdmlzaWJpbGl0eVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25zLm9uU3RhdHVzVXBkYXRlIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHN0YXR1c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5jYXB0dXJlRm9sZGVyIC0gRm9sZGVyIHRvIHNhdmUgY2FwdHVyZXMgaW5cbiAgICovXG4gIGV4cG9ydCBjb25zdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1JlZixcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICBzYXZlSW1hZ2VUb1NlcnZlcixcbiAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYXB0dXJlSW1hZ2VzXSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKCdFcnJvcjogSW52YWxpZCBkb3QgcG9zaXRpb24gKGNhcHR1cmVJbWFnZXMpJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBcbiAgICBcbiAgICBsZXQgZG90SW50ZXJ2YWw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSB2YWxpZCBjYW52YXMgcmVmZXJlbmNlXG4gICAgICAgIGlmICghY2FudmFzUmVmPy5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgcmVmZXJlbmNlIGlzIGludmFsaWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGRvdCBpbiBpdHMgcG9zaXRpb24gZmlyc3QgdG8gZW5zdXJlIGl0J3MgdmlzaWJsZVxuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsbHkgZHJhdyB0aGUgZG90XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpbnRlcnZhbCB0byBrZWVwIHJlZHJhd2luZyB0aGUgZG90IHRvIGVuc3VyZSBpdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgIGRvdEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgXG4gICAgICAvLyBGaXJzdCBydW4gdGhlIGNvdW50ZG93blxuICAgIC8vICAgYXdhaXQgcnVuQ291bnRkb3duKFxuICAgIC8vICAgICBwb3NpdGlvbixcbiAgICAvLyAgICAgY2FudmFzUmVmLmN1cnJlbnQsXG4gICAgLy8gICAgIG9uU3RhdHVzVXBkYXRlLCBcbiAgICAvLyAgICAgbnVsbCAvLyBObyBjYWxsYmFjayBoZXJlIGFzIHdlJ2xsIGhhbmRsZSBpdCBkaXJlY3RseVxuICAgIC8vICAgKTtcbiAgICAgICAgYXdhaXQgcnVuQ291bnRkb3duKHBvc2l0aW9uLCBjYW52YXMsIG9uU3RhdHVzVXBkYXRlLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8g4pyFIFZhbGlkYXRlIGFnYWluIGhlcmUgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Bvc2l0aW9uIGlzIG1pc3NpbmcgYWZ0ZXIgY291bnRkb3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBib3RoIGNhbnZhcyBhbmQgd2ViY2FtXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzKHtcbiAgICAgICAgICAgICAgICBjYW52YXNSZWYsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgICAgICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICAgICAgICAgICAgY2FwdHVyZUZvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW2NhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc10gRXJyb3IgZHVyaW5nIGNhcHR1cmU6JywgZXJyKTtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgdmlzaWJsZSBhZnRlciBjb3VudGRvd25cbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FwdHVyZSB0aGUgaW1hZ2VzXG4gICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzKHtcbiAgICAgICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzYXZlSW1hZ2VUb1NlcnZlcixcbiAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHZpc2libGUgYWZ0ZXIgY2FwdHVyaW5nXG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgcHJldmlldyBvZiBjYXB0dXJlZCBpbWFnZXNcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3KFxuICAgICAgICAgICAgY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSxcbiAgICAgICAgICAgIGNhcHR1cmVSZXN1bHQud2ViY2FtSW1hZ2UsXG4gICAgICAgICAgICBjYXB0dXJlUmVzdWx0LnBvc2l0aW9uXG4gICAgICAgICk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHZpc2libGUgYWZ0ZXIgcHJldmlld1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlIGV2ZW4gYWZ0ZXIgc2hvd2luZyBUb3BCYXJcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgfSwgMjUwMCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gY2FwdHVyZVJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gZXZlbiBpZiBlcnJvciBvY2N1cnJlZFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxNTAwKTtcbiAgICAgIFxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHRoZSBkb3QgcmVkcmF3IGludGVydmFsIGlmIGl0IHdhcyBjcmVhdGVkXG4gICAgICBpZiAoZG90SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChkb3RJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBcbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgcmFuZG9tIGRvdCBwb3NpdGlvbiB3aXRoaW4gdGhlIGNhbnZhc1xuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIFBhZGRpbmcgZnJvbSB0aGUgZWRnZXNcbiAgICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAgICovXG4gIGV4cG9ydCBjb25zdCBnZXRSYW5kb21Qb3NpdGlvbiA9IChjYW52YXMsIHBhZGRpbmcgPSA0MCkgPT4ge1xuICAgIGlmICghY2FudmFzKSByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICAgIFxuICAgIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoIHx8IDQwMDsgIC8vIEZhbGxiYWNrIGlmIHdpZHRoIGlzIDBcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IHx8IDMwMDsgLy8gRmFsbGJhY2sgaWYgaGVpZ2h0IGlzIDBcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdpZHRoIC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmcsXG4gICAgICB5OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaGVpZ2h0IC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmdcbiAgICB9O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIERyYXcgYSByZWQgZG90IG9uIHRoZSBjYW52YXNcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJDYW52YXMgLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgKGRlZmF1bHQ6IHRydWUpXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0ge3gsIHl9IHBvc2l0aW9uXG4gICAqL1xuICBleHBvcnQgY29uc3QgZHJhd1JlZERvdCA9IChjdHgsIHgsIHksIHJhZGl1cyA9IDEyLCBjbGVhckNhbnZhcyA9IHRydWUpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICAgIFxuICAgIC8vIENsZWFyIHRoZSBjYW52YXMgaWYgcmVxdWVzdGVkIChkZWZhdWx0IGJlaGF2aW9yKVxuICAgIGlmIChjbGVhckNhbnZhcykge1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgXG4gICAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBBZGQgYSBzZWNvbmQgbGFyZ2VyIGdsb3cgZm9yIGV2ZW4gYmV0dGVyIHZpc2liaWxpdHlcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjMpJztcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgXG4gICAgcmV0dXJuIHsgeCwgeSB9O1xuICB9O1xuICBcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgY2FudmFzIGZvciBkcmF3aW5nXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudCAtIFBhcmVudCBlbGVtZW50IGZvciBkaW1lbnNpb25zXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFN1Y2Nlc3Mgc3RhdHVzXG4gICAqL1xuICBleHBvcnQgY29uc3QgaW5pdGlhbGl6ZUNhbnZhcyA9IChjYW52YXMsIHBhcmVudCkgPT4ge1xuICAgIGlmICghY2FudmFzIHx8ICFwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggcGFyZW50XG4gICAgY2FudmFzLndpZHRoID0gcGFyZW50LmNsaWVudFdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIGNhbnZhcyBhbmQgc2V0IHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH07Il0sIm5hbWVzIjpbImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJ4IiwieSIsImNvbnNvbGUiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicmVtb3ZlIiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwicnVuQ291bnRkb3duIiwiY2FudmFzIiwib25TdGF0dXNVcGRhdGUiLCJvbkNvbXBsZXRlIiwicHJvY2Vzc1N0YXR1cyIsImNvdW50ZG93blZhbHVlIiwiaXNDYXB0dXJpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd1JlZERvdCIsImNvdW50IiwidGV4dENvbnRlbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50ZG93bkludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwic2V0VGltZW91dCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNhcHR1cmVJbWFnZXMiLCJvcHRpb25zIiwiY2FudmFzUmVmIiwiY2FwdHVyZUNvdW50ZXIiLCJzYXZlSW1hZ2VUb1NlcnZlciIsInNldENhcHR1cmVDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVGb2xkZXIiLCJjb3VudGVyIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJzY3JlZW5GaWxlbmFtZSIsIndlYmNhbUZpbGVuYW1lIiwicGFyYW1ldGVyRmlsZW5hbWUiLCJsb2ciLCJzY3JlZW5JbWFnZURhdGEiLCJ3ZWJjYW1JbWFnZURhdGEiLCJ1c2VkQ2FwdHVyZU51bWJlciIsImN1cnJlbnQiLCJ3aWR0aCIsImhlaWdodCIsInRvRGF0YVVSTCIsImxlbmd0aCIsInNjcmVlblJlc3BvbnNlIiwiY2FwdHVyZU51bWJlciIsInNjcmVlbkVycm9yIiwiZXJyb3IiLCJ2aWRlb0VsZW1lbnQiLCJ3aW5kb3ciLCJxdWVyeVNlbGVjdG9yIiwicmVhZHlTdGF0ZSIsInRlbXBDYW52YXMiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJzdHJlYW0iLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJnZXRVc2VyTWVkaWEiLCJ2aWRlbyIsImF1ZGlvIiwidGVtcFZpZGVvIiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsIm11dGVkIiwib3BhY2l0eSIsInNyY09iamVjdCIsInRpbWVvdXRJZCIsIm9ubG9hZGVkZGF0YSIsImNsZWFyVGltZW91dCIsImdldFRyYWNrcyIsInRyYWNrIiwic3RvcCIsIndlYmNhbUVycm9yIiwiY3N2RGF0YSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJjc3ZCbG9iIiwiQmxvYiIsInR5cGUiLCJjc3ZSZWFkZXIiLCJGaWxlUmVhZGVyIiwiY3N2RGF0YVVybCIsIm9ubG9hZGVuZCIsInJlc3VsdCIsInJlYWRBc0RhdGFVUkwiLCJjc3ZFcnJvciIsInNjcmVlbkltYWdlIiwid2ViY2FtSW1hZ2UiLCJtZXNzYWdlIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZG90UG9zaXRpb24iLCJleGlzdGluZ1ByZXZpZXdzIiwicHJldmlldyIsImNsZWFudXBFcnJvciIsInByZXZpZXdDb250YWluZXIiLCJhZGRJbWFnZVByZXZpZXciLCJpbWFnZSIsImxhYmVsIiwiaW1nIiwic3JjIiwiYWx0IiwibGFiZWxFbGVtZW50IiwiZGVidWdJbmZvIiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwidGltZXJFbGVtZW50IiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInRyYW5zaXRpb24iLCJ0b0ZpeGVkIiwiY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIiwiZG90SW50ZXJ2YWwiLCJFcnJvciIsImVyciIsImNhcHR1cmVSZXN1bHQiLCJnZXRSYW5kb21Qb3NpdGlvbiIsInBhZGRpbmciLCJmbG9vciIsInJhbmRvbSIsInJhZGl1cyIsImNsZWFyQ2FudmFzIiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImluaXRpYWxpemVDYW52YXMiLCJwYXJlbnQiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/Action/countSave.js\n");

/***/ }),

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/WhiteScreenMain.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/WhiteScreenMain.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-node)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Action_countSave__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Action/countSave */ \"(pages-dir-node)/./pages/collected-dataset/components-gui/Action/countSave.js\");\n// components-gui/WhiteScreenMain.js\n\n\n\n// Import the shared functionality\n\n// Create a client-only version of the component\nconst WhiteScreenMain = ({ onStatusUpdate, triggerCameraAccess, onButtonClick, canvasRef = null, toggleTopBar })=>{\n    // Use provided canvasRef or create a new one\n    const internalCanvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const activeCanvasRef = canvasRef || internalCanvasRef;\n    // Current dot state\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Track capture session\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [captureFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('eye_tracking_captures'); // Fixed folder name\n    // Configuration state\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Debug state to make visibility easier to track\n    const [canvasVisible, setCanvasVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [forceShowCountdown, setForceShowCountdown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Set up canvas when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            // Skip if this runs during SSR\n            if (true) return;\n            const canvas = activeCanvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas ref is null in setup effect\");\n                return;\n            }\n            console.log(\"Canvas setup effect running\", {\n                hasCanvas: !!canvas,\n                canvasHeight: canvas.height,\n                canvasWidth: canvas.width\n            });\n            // Function to update canvas dimensions\n            const updateDimensions = {\n                \"WhiteScreenMain.useEffect.updateDimensions\": ()=>{\n                    const parent = canvas.parentElement;\n                    if (!parent) {\n                        console.error(\"Canvas parent is null\");\n                        return;\n                    }\n                    // Get the parent container dimensions\n                    const parentWidth = parent.clientWidth;\n                    const parentHeight = parent.clientHeight;\n                    console.log(\"Resizing canvas to:\", {\n                        parentWidth,\n                        parentHeight\n                    });\n                    canvas.width = parentWidth;\n                    canvas.height = parentHeight;\n                    // Clear the canvas and set background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Redraw current dot if exists\n                    if (currentDot) {\n                        console.log(\"Redrawing dot after resize:\", currentDot);\n                        drawDot(currentDot.x, currentDot.y, 'red', 8);\n                    }\n                    setCanvasVisible(true);\n                }\n            }[\"WhiteScreenMain.useEffect.updateDimensions\"];\n            // Initial sizing\n            updateDimensions();\n            // Listen for window resize\n            window.addEventListener('resize', updateDimensions);\n            // Clean up\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    window.removeEventListener('resize', updateDimensions);\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        activeCanvasRef,\n        currentDot\n    ]);\n    // Draw a dot on the canvas\n    const drawDot = (x, y, color = 'red', radius = 12)=>{\n        console.log(\"Drawing dot at:\", {\n            x,\n            y,\n            color,\n            radius\n        });\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in drawDot\");\n            return null;\n        }\n        const ctx = canvas.getContext('2d');\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Draw dot with glow effect\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        // Add glow effect\n        ctx.beginPath();\n        ctx.arc(x, y, radius + 5, 0, Math.PI * 2); // Increased glow\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; // More visible glow\n        ctx.lineWidth = 3; // Thicker line\n        ctx.stroke();\n        // Store current dot position - using callback form to ensure it updates\n        setCurrentDot((prev)=>{\n            console.log(\"Updating currentDot state from:\", prev, \"to:\", {\n                x,\n                y\n            });\n            return {\n                x,\n                y\n            };\n        });\n        return {\n            x,\n            y\n        };\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        console.log(\"Clearing canvas\");\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in clearCanvas\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n        setCountdownValue(null);\n        setForceShowCountdown(false);\n        setProcessStatus('Canvas cleared');\n        // Clear the message after a delay\n        setTimeout(()=>{\n            setProcessStatus('');\n        }, 1500);\n    };\n    // Save an image to the server\n    const saveImageToServer = async (imageData, filename, type)=>{\n        try {\n            console.log(`Attempting to save ${type} image: ${filename}`);\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type,\n                    folder: captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n            const result = await response.json();\n            console.log(`Saved ${type} image:`, result);\n            // If the server returns a new capture number, update our counter\n            if (result.captureNumber) {\n                setCaptureCounter(result.captureNumber + 1);\n            }\n            return result;\n        } catch (error) {\n            console.error(`Error saving ${type} image:`, error);\n            throw error;\n        }\n    };\n    // Updated captureImage function using countSave module\n    const captureImage = async ()=>{\n        console.log(\"Capturing images...\");\n        setIsCapturing(true);\n        try {\n            // Use the shared capture function\n            const captureResult = await (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.captureImages)({\n                canvasRef: activeCanvasRef,\n                position: currentDot,\n                captureCounter,\n                saveImageToServer,\n                setCaptureCounter,\n                setProcessStatus,\n                toggleTopBar,\n                captureFolder: 'eye_tracking_captures'\n            });\n            // Show preview using the shared function\n            (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.showCapturePreview)(captureResult.screenImage, captureResult.webcamImage, currentDot);\n            // Update status\n            setIsCapturing(false);\n            setProcessStatus(`Captured with dot at: x=${currentDot?.x}, y=${currentDot?.y}`);\n            // Update parent component\n            if (onStatusUpdate) {\n                onStatusUpdate(`Images and parameters saved for capture #${captureCounter}`);\n            }\n            // Show TopBar again after capture with a delay to let preview finish\n            setTimeout(()=>{\n                console.log(\"Showing TopBar after capture\");\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if (false) {}\n            }, 2500);\n        } catch (error) {\n            console.error('Error during capture:', error);\n            setIsCapturing(false);\n            setProcessStatus('Error capturing images: ' + error.message);\n        }\n        // Clear status after a delay\n        setTimeout(()=>{\n            setProcessStatus('');\n        }, 3000);\n    };\n    // Random Dot action\n    const handleRandomDot = ()=>{\n        // Hide the TopBar before showing dot\n        if (typeof toggleTopBar === 'function') {\n            toggleTopBar(false);\n        } else if (false) {}\n        setIsCapturing(true);\n        setProcessStatus('Generating random dot...');\n        // Give the component time to update\n        setTimeout(async ()=>{\n            const canvas = activeCanvasRef.current;\n            if (canvas) {\n                // Make sure canvas dimensions are properly set\n                const parent = canvas.parentElement;\n                (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.initializeCanvas)(canvas, parent);\n                // Generate random position\n                const position = (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.getRandomPosition)(canvas);\n                // Draw the dot\n                const ctx = canvas.getContext('2d');\n                (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.drawRedDot)(ctx, position.x, position.y);\n                // Store current dot position directly\n                setCurrentDot(position);\n                try {\n                    // Use the shared capture and preview process\n                    await (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.captureAndPreviewProcess)({\n                        canvasRef: activeCanvasRef,\n                        position,\n                        captureCounter,\n                        saveImageToServer,\n                        setCaptureCounter,\n                        setProcessStatus,\n                        toggleTopBar,\n                        onStatusUpdate: (status)=>{\n                            if (onStatusUpdate) {\n                                onStatusUpdate(status);\n                            }\n                        },\n                        captureFolder: 'eye_tracking_captures'\n                    });\n                    // Set capturing state to false after a delay\n                    setTimeout(()=>{\n                        setIsCapturing(false);\n                    }, 2200);\n                } catch (error) {\n                    console.error(\"Error in capture and preview process:\", error);\n                    setIsCapturing(false);\n                    setProcessStatus('Error capturing images: ' + error.message);\n                    // Clear error message after a delay\n                    setTimeout(()=>{\n                        setProcessStatus('');\n                    }, 3000);\n                }\n            }\n        }, 200);\n    };\n    // Multiple random dots sequence - also updated to use countSave functions\n    const handleSetRandom = ()=>{\n        if (isCapturing) return;\n        // Parse input values (use defaults if invalid)\n        const times = parseInt(randomTimes) || 1;\n        const delay = parseInt(delaySeconds) || 3;\n        if (times <= 0 || delay <= 0) {\n            setProcessStatus('Please use positive values for times and delay');\n            return;\n        }\n        setIsCapturing(true);\n        setRemainingCaptures(times);\n        setProcessStatus(`Starting ${times} random captures...`);\n        // Start sequence\n        scheduleRandomCaptures(times, times, delay);\n    };\n    // Schedule sequence of random captures - updated with countSave\n    const scheduleRandomCaptures = (remaining, total, delay)=>{\n        if (remaining <= 0) {\n            setIsCapturing(false);\n            setRemainingCaptures(0);\n            setProcessStatus('Random capture sequence completed');\n            // Clear status after a delay\n            setTimeout(()=>{\n                setProcessStatus('');\n            }, 2000);\n            return;\n        }\n        setRemainingCaptures(remaining);\n        setProcessStatus(`Capture ${total - remaining + 1} of ${total}`);\n        // Generate random position and draw\n        const canvas = activeCanvasRef.current;\n        const ctx = canvas.getContext('2d');\n        const position = (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.getRandomPosition)(canvas);\n        (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.drawRedDot)(ctx, position.x, position.y);\n        setCurrentDot(position);\n        // Use shared capture and preview process\n        (0,_Action_countSave__WEBPACK_IMPORTED_MODULE_3__.captureAndPreviewProcess)({\n            canvasRef: activeCanvasRef,\n            position,\n            captureCounter,\n            saveImageToServer,\n            setCaptureCounter,\n            setProcessStatus,\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (onStatusUpdate) {\n                    onStatusUpdate(status);\n                }\n            },\n            captureFolder: 'eye_tracking_captures'\n        }).then(()=>{\n            // Schedule next capture\n            setTimeout(()=>{\n                scheduleRandomCaptures(remaining - 1, total, delay);\n            }, delay * 1000);\n        }).catch((error)=>{\n            console.error('Error during random capture:', error);\n            setIsCapturing(false);\n            setProcessStatus('Error: ' + error.message);\n            // Clear error message after a delay\n            setTimeout(()=>{\n                setProcessStatus('');\n            }, 3000);\n        });\n    };\n    // Generate calibration points based on canvas dimensions\n    const generateCalibrationPoints = (width, height)=>{\n        if (!width || !height || width <= 0 || height <= 0) {\n            console.error(\"generateCalibrationPoints: Invalid canvas dimensions\", {\n                width,\n                height\n            });\n            return [];\n        }\n        const conditionalRound = (dimension, percentage)=>Math.round(dimension * percentage);\n        // Outer frame (12% from edges)\n        const xLeftOuter = conditionalRound(width, 0.12);\n        const xRightOuter = width - xLeftOuter;\n        const yTopOuter = conditionalRound(height, 0.12);\n        const yBottomOuter = height - yTopOuter;\n        // Inner frame (26% from edges)\n        const xLeftInner = conditionalRound(width, 0.26);\n        const xRightInner = width - xLeftInner;\n        const yTopInner = conditionalRound(height, 0.26);\n        const yBottomInner = height - yTopInner;\n        const xCenter = Math.floor(width / 2);\n        const yCenter = Math.floor(height / 2);\n        return [\n            // Outer frame (8 points)\n            {\n                x: xLeftOuter,\n                y: yTopOuter,\n                label: \"Outer Top-Left\"\n            },\n            {\n                x: xCenter,\n                y: yTopOuter,\n                label: \"Outer Top-Center\"\n            },\n            {\n                x: xRightOuter,\n                y: yTopOuter,\n                label: \"Outer Top-Right\"\n            },\n            {\n                x: xLeftOuter,\n                y: yCenter,\n                label: \"Outer Middle-Left\"\n            },\n            {\n                x: xRightOuter,\n                y: yCenter,\n                label: \"Outer Middle-Right\"\n            },\n            {\n                x: xLeftOuter,\n                y: yBottomOuter,\n                label: \"Outer Bottom-Left\"\n            },\n            {\n                x: xCenter,\n                y: yBottomOuter,\n                label: \"Outer Bottom-Center\"\n            },\n            {\n                x: xRightOuter,\n                y: yBottomOuter,\n                label: \"Outer Bottom-Right\"\n            },\n            // Inner frame (8 points)\n            {\n                x: xLeftInner,\n                y: yTopInner,\n                label: \"Inner Top-Left\"\n            },\n            {\n                x: xCenter,\n                y: yTopInner,\n                label: \"Inner Top-Center\"\n            },\n            {\n                x: xRightInner,\n                y: yTopInner,\n                label: \"Inner Top-Right\"\n            },\n            {\n                x: xLeftInner,\n                y: yCenter,\n                label: \"Inner Middle-Left\"\n            },\n            {\n                x: xRightInner,\n                y: yCenter,\n                label: \"Inner Middle-Right\"\n            },\n            {\n                x: xLeftInner,\n                y: yBottomInner,\n                label: \"Inner Bottom-Left\"\n            },\n            {\n                x: xCenter,\n                y: yBottomInner,\n                label: \"Inner Bottom-Center\"\n            },\n            {\n                x: xRightInner,\n                y: yBottomInner,\n                label: \"Inner Bottom-Right\"\n            }\n        ];\n    };\n    // Handle Set Calibrate action\n    const handleSetCalibrate = async ()=>{\n        try {\n            // STEP 1: HIDE THE TOP BAR IMMEDIATELY (before anything else happens)\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if (false) {}\n            // Add a small delay to ensure UI updates\n            await new Promise((resolve)=>setTimeout(resolve, 50));\n            // STEP 2: Initial setup\n            setIsCapturing(true);\n            setProcessStatus('Starting calibration sequence...');\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: 'Starting calibration sequence',\n                    isCapturing: true\n                });\n            }\n            // Create a status indicator\n            const statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        background-color: rgba(0, 102, 204, 0.9);\n        color: white;\n        font-size: 14px;\n        font-weight: bold;\n        padding: 8px 12px;\n        border-radius: 6px;\n        z-index: 9999;\n        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n      `;\n            statusIndicator.textContent = 'Calibrate Set Active: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // STEP 3: Setup canvas and generate points\n            const canvas = activeCanvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas reference is null\");\n            }\n            // Ensure canvas dimensions are set\n            const parent = canvas.parentElement;\n            if (parent) {\n                canvas.width = parent.clientWidth;\n                canvas.height = parent.clientHeight;\n            }\n            console.log(\"Canvas dimensions for calibration:\", {\n                width: canvas.width,\n                height: canvas.height\n            });\n            // Generate calibration points using the imported function\n            const points = generateCalibrationPoints(canvas.width, canvas.height);\n            setCalibrationPoints(points);\n            console.log(`Generated ${points.length} calibration points`);\n            if (!points || points.length === 0) {\n                throw new Error('Failed to generate calibration points');\n            }\n            setRemainingCaptures(points.length);\n            // STEP 4: Process each calibration point in sequence\n            for(let i = 0; i < points.length; i++){\n                // Update state\n                setCurrentCalibrationIndex(i);\n                setRemainingCaptures(points.length - i);\n                // Update status\n                const statusText = `Calibration ${i + 1}/${points.length}`;\n                setProcessStatus(statusText);\n                statusIndicator.textContent = `Calibrate Set Active: Processing point ${i + 1}/${points.length}`;\n                if (onStatusUpdate) {\n                    onStatusUpdate(statusText);\n                }\n                // STEP 5: Draw the red dot FIRST, before any countdown\n                const point = points[i];\n                drawDot(point.x, point.y);\n                // Wait a moment to ensure dot is visible\n                await new Promise((resolve)=>setTimeout(resolve, 50));\n                // STEP 6: Get canvas position for absolute positioning\n                const canvasRect = canvas.getBoundingClientRect();\n                // Create countdown element above the dot\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'calibrate-countdown';\n                // Position it above the dot\n                const absoluteX = canvasRect.left + point.x;\n                const absoluteY = canvasRect.top + point.y;\n                countdownElement.style.cssText = `\n          position: fixed;\n          left: ${absoluteX}px;\n          top: ${absoluteY - 60}px;\n          transform: translateX(-50%);\n          color: red;\n          font-size: 36px;\n          font-weight: bold;\n          text-shadow: 0 0 10px white, 0 0 20px white;\n          z-index: 9999;\n          background-color: rgba(255, 255, 255, 0.8);\n          border: 2px solid red;\n          border-radius: 50%;\n          width: 50px;\n          height: 50px;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n        `;\n                document.body.appendChild(countdownElement);\n                // STEP 7: Run 3-2-1 countdown (the dot stays visible during this time)\n                for(let count = 3; count > 0; count--){\n                    countdownElement.textContent = count;\n                    statusIndicator.textContent = `Calibrate Set Active: countdown ${count} (${i + 1}/${points.length})`;\n                    // Wait for next countdown step\n                    await new Promise((resolve)=>setTimeout(resolve, 800));\n                }\n                // STEP 8: Show capturing indicator\n                countdownElement.textContent = \"✓\";\n                statusIndicator.textContent = `Capturing point ${i + 1}/${points.length}`;\n                // STEP 9: Remove countdown element but KEEP the dot visible\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                }, 300);\n                // STEP 10: Capture images (the dot is still visible)\n                await captureImage();\n                // STEP 11: Wait for preview to complete before moving to next point\n                // During this time, the dot remains visible\n                await new Promise((resolve)=>setTimeout(resolve, 2300));\n            }\n            // STEP 12: Calibration complete\n            statusIndicator.textContent = 'Calibration completed';\n            setProcessStatus('Calibration completed');\n            if (onStatusUpdate) {\n                onStatusUpdate('Calibration completed successfully');\n            }\n            setRemainingCaptures(0);\n            // Remove status indicator after a delay\n            setTimeout(()=>{\n                if (statusIndicator.parentNode) {\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Calibration error:', error);\n            setProcessStatus(`Error: ${error.message}`);\n            if (onStatusUpdate) {\n                onStatusUpdate(`Calibration error: ${error.message}`);\n            }\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if (false) {}\n        }\n    };\n    // Map button clicks to appropriate handlers\n    const handleScreenAction = (actionType)=>{\n        console.log(`Screen action received: ${actionType}`);\n        switch(actionType){\n            case 'randomDot':\n                handleRandomDot();\n                break;\n            case 'setRandom':\n                handleSetRandom();\n                break;\n            case 'calibrate':\n                handleSetCalibrate();\n                break;\n            case 'clearAll':\n                clearCanvas();\n                break;\n            default:\n                // Forward to parent if not handled here\n                if (onButtonClick) {\n                    onButtonClick(actionType);\n                }\n        }\n    };\n    // Register action handlers with parent component\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            // Skip during SSR\n            if (true) return;\n            console.log(\"Registering action handlers with parent\");\n            if (onButtonClick) {\n                // Create action handlers\n                const actionHandlers = {\n                    randomDot: handleRandomDot,\n                    setRandom: handleSetRandom,\n                    calibrate: handleSetCalibrate,\n                    clearAll: clearCanvas\n                };\n                // Store in parent component context\n                onButtonClick('registerActions', actionHandlers);\n                // Also make them globally available for direct access\n                window.whiteScreenActions = actionHandlers;\n            }\n            // Cleanup on unmount\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    if (false) {}\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        onButtonClick\n    ]);\n    // Update parent with status changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            if (onStatusUpdate && processStatus) {\n                onStatusUpdate(processStatus);\n            }\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        processStatus,\n        onStatusUpdate\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"white-screen-container\",\n        style: {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            zIndex: 50,\n            backgroundColor: 'rgba(255, 255, 255, 0.5)' // Slight transparency to see if it's rendered\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"white-screen-canvas-container\",\n            style: {\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                backgroundColor: 'white',\n                overflow: 'hidden',\n                border: '1px solid #ccc',\n                zIndex: 51\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                    ref: canvasRef ? canvasRef : internalCanvasRef,\n                    className: \"white-screen-canvas\",\n                    style: {\n                        width: '100%',\n                        height: '100%',\n                        display: 'block'\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 732,\n                    columnNumber: 9\n                }, undefined),\n                (countdownValue !== null || forceShowCountdown) && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dot-countdown\",\n                    style: {\n                        position: 'absolute',\n                        left: `${currentDot.x - 30}px`,\n                        top: `${currentDot.y - 70}px`,\n                        color: 'red',\n                        fontSize: '48px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 10px white, 0 0 20px white',\n                        zIndex: 999,\n                        backgroundColor: 'rgba(255, 255, 255, 0.8)',\n                        padding: '10px 20px',\n                        borderRadius: '50%',\n                        boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)',\n                        width: '60px',\n                        height: '60px',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        border: '2px solid red' // Border to make it stand out\n                    },\n                    children: countdownValue || 3\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 744,\n                    columnNumber: 11\n                }, undefined),\n                (countdownValue !== null || forceShowCountdown) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"center-countdown-backup\",\n                    style: {\n                        position: 'fixed',\n                        top: '50%',\n                        left: '50%',\n                        transform: 'translate(-50%, -50%)',\n                        color: 'white',\n                        fontSize: '120px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 20px black',\n                        zIndex: 1000,\n                        backgroundColor: 'rgba(255, 0, 0, 0.7)',\n                        width: '200px',\n                        height: '200px',\n                        borderRadius: '50%',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        boxShadow: '0 0 30px rgba(0, 0, 0, 0.5)'\n                    },\n                    children: countdownValue || 3\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 773,\n                    columnNumber: 11\n                }, undefined),\n                currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dot-indicator\",\n                    style: {\n                        position: 'absolute',\n                        top: '10px',\n                        right: '10px',\n                        backgroundColor: 'rgba(0, 255, 0, 0.7)',\n                        color: 'black',\n                        padding: '5px 10px',\n                        borderRadius: '4px',\n                        fontSize: '12px',\n                        zIndex: 52\n                    },\n                    children: [\n                        \"Dot at x:\",\n                        currentDot.x,\n                        \", y:\",\n                        currentDot.y\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 801,\n                    columnNumber: 11\n                }, undefined),\n                (processStatus || remainingCaptures > 0) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"status-overlay\",\n                    style: {\n                        position: 'absolute',\n                        bottom: '10px',\n                        left: '10px',\n                        backgroundColor: 'rgba(0, 0, 0, 0.8)',\n                        color: 'white',\n                        padding: '10px 15px',\n                        borderRadius: '4px',\n                        fontSize: '16px',\n                        fontWeight: 'bold',\n                        boxShadow: '0 4px 8px rgba(0,0,0,0.3)',\n                        zIndex: 53\n                    },\n                    children: [\n                        processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: processStatus\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                            lineNumber: 837,\n                            columnNumber: 31\n                        }, undefined),\n                        remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                color: '#ffcc00'\n                            },\n                            children: [\n                                \"Remaining: \",\n                                remainingCaptures\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                            lineNumber: 839,\n                            columnNumber: 15\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 821,\n                    columnNumber: 11\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"canvas-indicator\",\n                    style: {\n                        position: 'absolute',\n                        top: '10px',\n                        left: '10px',\n                        backgroundColor: canvasVisible ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)',\n                        color: 'black',\n                        padding: '5px 10px',\n                        borderRadius: '4px',\n                        fontSize: '12px',\n                        zIndex: 52\n                    },\n                    children: [\n                        \"Canvas: \",\n                        canvasVisible ? 'Visible' : 'Hidden'\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 847,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n            lineNumber: 717,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n        lineNumber: 707,\n        columnNumber: 5\n    }, undefined);\n};\n// Export a dynamic version with SSR disabled to avoid useLayoutEffect warnings\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>Promise.resolve(WhiteScreenMain), {\n    ssr: false\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL1doaXRlU2NyZWVuTWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLG9DQUFvQzs7QUFDdUI7QUFDeEI7QUFFbkMsa0NBQWtDO0FBUU47QUFFNUIsZ0RBQWdEO0FBQ2hELE1BQU1XLGtCQUFrQixDQUFDLEVBQ3ZCQyxjQUFjLEVBQ2RDLG1CQUFtQixFQUNuQkMsYUFBYSxFQUNiQyxZQUFZLElBQUksRUFDaEJDLFlBQVksRUFDYjtJQUNDLDZDQUE2QztJQUM3QyxNQUFNQyxvQkFBb0JkLDZDQUFNQSxDQUFDO0lBQ2pDLE1BQU1lLGtCQUFrQkgsYUFBYUU7SUFFckMsb0JBQW9CO0lBQ3BCLE1BQU0sQ0FBQ0UsWUFBWUMsY0FBYyxHQUFHbkIsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDb0IsYUFBYUMsZUFBZSxHQUFHckIsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDc0IsZ0JBQWdCQyxrQkFBa0IsR0FBR3ZCLCtDQUFRQSxDQUFDO0lBQ3JELE1BQU0sQ0FBQ3dCLG1CQUFtQkMscUJBQXFCLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUMzRCxNQUFNLENBQUMwQixlQUFlQyxpQkFBaUIsR0FBRzNCLCtDQUFRQSxDQUFDO0lBRW5ELHdCQUF3QjtJQUN4QixNQUFNLENBQUM0QixnQkFBZ0JDLGtCQUFrQixHQUFHN0IsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDOEIsY0FBYyxHQUFHOUIsK0NBQVFBLENBQUMsMEJBQTBCLG9CQUFvQjtJQUUvRSxzQkFBc0I7SUFDdEIsTUFBTSxDQUFDK0IsYUFBYUMsZUFBZSxHQUFHaEMsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDaUMsY0FBY0MsZ0JBQWdCLEdBQUdsQywrQ0FBUUEsQ0FBQztJQUNqRCxNQUFNLENBQUNtQyxtQkFBbUJDLHFCQUFxQixHQUFHcEMsK0NBQVFBLENBQUMsRUFBRTtJQUM3RCxN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X1dlYl9FeWVUcmFja2luZy9tYWluLXdlYi9mcm9udGVuZC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC9jb21wb25lbnRzLWd1aS9XaGl0ZVNjcmVlbk1haW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29tcG9uZW50cy1ndWkvV2hpdGVTY3JlZW5NYWluLmpzXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcblxuLy8gSW1wb3J0IHRoZSBzaGFyZWQgZnVuY3Rpb25hbGl0eVxuaW1wb3J0IHsgXG4gIGdldFJhbmRvbVBvc2l0aW9uLCBcbiAgZHJhd1JlZERvdCwgXG4gIGNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyxcbiAgaW5pdGlhbGl6ZUNhbnZhcyxcbiAgY2FwdHVyZUltYWdlcyxcbiAgc2hvd0NhcHR1cmVQcmV2aWV3XG59IGZyb20gJy4vQWN0aW9uL2NvdW50U2F2ZSc7XG5cbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuY29uc3QgV2hpdGVTY3JlZW5NYWluID0gKHsgXG4gIG9uU3RhdHVzVXBkYXRlLCBcbiAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgb25CdXR0b25DbGljayxcbiAgY2FudmFzUmVmID0gbnVsbCxcbiAgdG9nZ2xlVG9wQmFyXG59KSA9PiB7XG4gIC8vIFVzZSBwcm92aWRlZCBjYW52YXNSZWYgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICBjb25zdCBpbnRlcm5hbENhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgYWN0aXZlQ2FudmFzUmVmID0gY2FudmFzUmVmIHx8IGludGVybmFsQ2FudmFzUmVmO1xuICBcbiAgLy8gQ3VycmVudCBkb3Qgc3RhdGVcbiAgY29uc3QgW2N1cnJlbnREb3QsIHNldEN1cnJlbnREb3RdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY291bnRkb3duVmFsdWUsIHNldENvdW50ZG93blZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcmVtYWluaW5nQ2FwdHVyZXMsIHNldFJlbWFpbmluZ0NhcHR1cmVzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIFxuICAvLyBUcmFjayBjYXB0dXJlIHNlc3Npb25cbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2NhcHR1cmVGb2xkZXJdID0gdXNlU3RhdGUoJ2V5ZV90cmFja2luZ19jYXB0dXJlcycpOyAvLyBGaXhlZCBmb2xkZXIgbmFtZVxuICBcbiAgLy8gQ29uZmlndXJhdGlvbiBzdGF0ZVxuICBjb25zdCBbcmFuZG9tVGltZXMsIHNldFJhbmRvbVRpbWVzXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbZGVsYXlTZWNvbmRzLCBzZXREZWxheVNlY29uZHNdID0gdXNlU3RhdGUoMyk7XG4gIGNvbnN0IFtjYWxpYnJhdGlvblBvaW50cywgc2V0Q2FsaWJyYXRpb25Qb2ludHNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbY3VycmVudENhbGlicmF0aW9uSW5kZXgsIHNldEN1cnJlbnRDYWxpYnJhdGlvbkluZGV4XSA9IHVzZVN0YXRlKDApO1xuICBcbiAgLy8gRGVidWcgc3RhdGUgdG8gbWFrZSB2aXNpYmlsaXR5IGVhc2llciB0byB0cmFja1xuICBjb25zdCBbY2FudmFzVmlzaWJsZSwgc2V0Q2FudmFzVmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtmb3JjZVNob3dDb3VudGRvd24sIHNldEZvcmNlU2hvd0NvdW50ZG93bl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBTZXQgdXAgY2FudmFzIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNraXAgaWYgdGhpcyBydW5zIGR1cmluZyBTU1JcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBhY3RpdmVDYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWYgaXMgbnVsbCBpbiBzZXR1cCBlZmZlY3RcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIHNldHVwIGVmZmVjdCBydW5uaW5nXCIsIHsgXG4gICAgICBoYXNDYW52YXM6ICEhY2FudmFzLCBcbiAgICAgIGNhbnZhc0hlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgIGNhbnZhc1dpZHRoOiBjYW52YXMud2lkdGhcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgY2FudmFzIGRpbWVuc2lvbnNcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHBhcmVudCBpcyBudWxsXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgcGFyZW50IGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVzaXppbmcgY2FudmFzIHRvOlwiLCB7IHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQgfSk7XG4gICAgICBcbiAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudFdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBhbmQgc2V0IGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gUmVkcmF3IGN1cnJlbnQgZG90IGlmIGV4aXN0c1xuICAgICAgaWYgKGN1cnJlbnREb3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZWRyYXdpbmcgZG90IGFmdGVyIHJlc2l6ZTpcIiwgY3VycmVudERvdCk7XG4gICAgICAgIGRyYXdEb3QoY3VycmVudERvdC54LCBjdXJyZW50RG90LnksICdyZWQnLCA4KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0Q2FudmFzVmlzaWJsZSh0cnVlKTtcbiAgICB9O1xuICAgIFxuICAgIC8vIEluaXRpYWwgc2l6aW5nXG4gICAgdXBkYXRlRGltZW5zaW9ucygpO1xuICAgIFxuICAgIC8vIExpc3RlbiBmb3Igd2luZG93IHJlc2l6ZVxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICBcbiAgICAvLyBDbGVhbiB1cFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUNhbnZhc1JlZiwgY3VycmVudERvdF0pO1xuICBcbiAgLy8gRHJhdyBhIGRvdCBvbiB0aGUgY2FudmFzXG4gIGNvbnN0IGRyYXdEb3QgPSAoeCwgeSwgY29sb3IgPSAncmVkJywgcmFkaXVzID0gMTIpID0+IHsgLy8gSW5jcmVhc2VkIHJhZGl1c1xuICAgIGNvbnNvbGUubG9nKFwiRHJhd2luZyBkb3QgYXQ6XCIsIHsgeCwgeSwgY29sb3IsIHJhZGl1cyB9KTtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBhY3RpdmVDYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWYgaXMgbnVsbCBpbiBkcmF3RG90XCIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vIENsZWFyIGNhbnZhc1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBEcmF3IGRvdCB3aXRoIGdsb3cgZWZmZWN0XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIGN0eC5maWxsKCk7XG4gICAgXG4gICAgLy8gQWRkIGdsb3cgZWZmZWN0XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgNSwgMCwgTWF0aC5QSSAqIDIpOyAvLyBJbmNyZWFzZWQgZ2xvd1xuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7IC8vIE1vcmUgdmlzaWJsZSBnbG93XG4gICAgY3R4LmxpbmVXaWR0aCA9IDM7IC8vIFRoaWNrZXIgbGluZVxuICAgIGN0eC5zdHJva2UoKTtcbiAgICBcbiAgICAvLyBTdG9yZSBjdXJyZW50IGRvdCBwb3NpdGlvbiAtIHVzaW5nIGNhbGxiYWNrIGZvcm0gdG8gZW5zdXJlIGl0IHVwZGF0ZXNcbiAgICBzZXRDdXJyZW50RG90KHByZXYgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCJVcGRhdGluZyBjdXJyZW50RG90IHN0YXRlIGZyb206XCIsIHByZXYsIFwidG86XCIsIHsgeCwgeSB9KTtcbiAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4geyB4LCB5IH07XG4gIH07XG4gIFxuICAvLyBDbGVhciB0aGUgY2FudmFzXG4gIGNvbnN0IGNsZWFyQ2FudmFzID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiQ2xlYXJpbmcgY2FudmFzXCIpO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZiBpcyBudWxsIGluIGNsZWFyQ2FudmFzXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgc2V0Q3VycmVudERvdChudWxsKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRGb3JjZVNob3dDb3VudGRvd24oZmFsc2UpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJ0NhbnZhcyBjbGVhcmVkJyk7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIG1lc3NhZ2UgYWZ0ZXIgYSBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnJyk7XG4gICAgfSwgMTUwMCk7XG4gIH07XG4gIFxuICAvLyBTYXZlIGFuIGltYWdlIHRvIHRoZSBzZXJ2ZXJcbiAgY29uc3Qgc2F2ZUltYWdlVG9TZXJ2ZXIgPSBhc3luYyAoaW1hZ2VEYXRhLCBmaWxlbmFtZSwgdHlwZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgQXR0ZW1wdGluZyB0byBzYXZlICR7dHlwZX0gaW1hZ2U6ICR7ZmlsZW5hbWV9YCk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvc2F2ZS1jYXB0dXJlJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGltYWdlRGF0YSxcbiAgICAgICAgICBmaWxlbmFtZSxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGZvbGRlcjogY2FwdHVyZUZvbGRlclxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUubG9nKGBTYXZlZCAke3R5cGV9IGltYWdlOmAsIHJlc3VsdCk7XG4gICAgICBcbiAgICAgIC8vIElmIHRoZSBzZXJ2ZXIgcmV0dXJucyBhIG5ldyBjYXB0dXJlIG51bWJlciwgdXBkYXRlIG91ciBjb3VudGVyXG4gICAgICBpZiAocmVzdWx0LmNhcHR1cmVOdW1iZXIpIHtcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIocmVzdWx0LmNhcHR1cmVOdW1iZXIgKyAxKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nICR7dHlwZX0gaW1hZ2U6YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gVXBkYXRlZCBjYXB0dXJlSW1hZ2UgZnVuY3Rpb24gdXNpbmcgY291bnRTYXZlIG1vZHVsZVxuICBjb25zdCBjYXB0dXJlSW1hZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJDYXB0dXJpbmcgaW1hZ2VzLi4uXCIpO1xuICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBVc2UgdGhlIHNoYXJlZCBjYXB0dXJlIGZ1bmN0aW9uXG4gICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlcyh7XG4gICAgICAgIGNhbnZhc1JlZjogYWN0aXZlQ2FudmFzUmVmLFxuICAgICAgICBwb3NpdGlvbjogY3VycmVudERvdCxcbiAgICAgICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgcHJldmlldyB1c2luZyB0aGUgc2hhcmVkIGZ1bmN0aW9uXG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXcoXG4gICAgICAgIGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UsXG4gICAgICAgIGNhcHR1cmVSZXN1bHQud2ViY2FtSW1hZ2UsXG4gICAgICAgIGN1cnJlbnREb3RcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIHdpdGggZG90IGF0OiB4PSR7Y3VycmVudERvdD8ueH0sIHk9JHtjdXJyZW50RG90Py55fWApO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgcGFyZW50IGNvbXBvbmVudFxuICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgIG9uU3RhdHVzVXBkYXRlKGBJbWFnZXMgYW5kIHBhcmFtZXRlcnMgc2F2ZWQgZm9yIGNhcHR1cmUgIyR7Y2FwdHVyZUNvdW50ZXJ9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGNhcHR1cmUgd2l0aCBhIGRlbGF5IHRvIGxldCBwcmV2aWV3IGZpbmlzaFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2hvd2luZyBUb3BCYXIgYWZ0ZXIgY2FwdHVyZVwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDI1MDApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgY2FwdHVyZTonLCBlcnJvcik7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdFcnJvciBjYXB0dXJpbmcgaW1hZ2VzOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFyIHN0YXR1cyBhZnRlciBhIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICB9LCAzMDAwKTtcbiAgfTtcbiAgXG4gIC8vIFJhbmRvbSBEb3QgYWN0aW9uXG4gIGNvbnN0IGhhbmRsZVJhbmRvbURvdCA9ICgpID0+IHtcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHNob3dpbmcgZG90XG4gICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB0b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKCdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nKTtcbiAgICBcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGltZSB0byB1cGRhdGVcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGRpbWVuc2lvbnMgYXJlIHByb3Blcmx5IHNldFxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgaW5pdGlhbGl6ZUNhbnZhcyhjYW52YXMsIHBhcmVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb25cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgZG90XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBjdXJyZW50IGRvdCBwb3NpdGlvbiBkaXJlY3RseVxuICAgICAgICBzZXRDdXJyZW50RG90KHBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBzaGFyZWQgY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzXG4gICAgICAgICAgYXdhaXQgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzKHtcbiAgICAgICAgICAgIGNhbnZhc1JlZjogYWN0aXZlQ2FudmFzUmVmLFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgb25TdGF0dXNVcGRhdGUoc3RhdHVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZSB0byBmYWxzZSBhZnRlciBhIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfSwgMjIwMCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCdFcnJvciBjYXB0dXJpbmcgaW1hZ2VzOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgZXJyb3IgbWVzc2FnZSBhZnRlciBhIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH07XG4gIFxuICAvLyBNdWx0aXBsZSByYW5kb20gZG90cyBzZXF1ZW5jZSAtIGFsc28gdXBkYXRlZCB0byB1c2UgY291bnRTYXZlIGZ1bmN0aW9uc1xuICBjb25zdCBoYW5kbGVTZXRSYW5kb20gPSAoKSA9PiB7XG4gICAgaWYgKGlzQ2FwdHVyaW5nKSByZXR1cm47XG4gICAgXG4gICAgLy8gUGFyc2UgaW5wdXQgdmFsdWVzICh1c2UgZGVmYXVsdHMgaWYgaW52YWxpZClcbiAgICBjb25zdCB0aW1lcyA9IHBhcnNlSW50KHJhbmRvbVRpbWVzKSB8fCAxO1xuICAgIGNvbnN0IGRlbGF5ID0gcGFyc2VJbnQoZGVsYXlTZWNvbmRzKSB8fCAzO1xuICAgIFxuICAgIGlmICh0aW1lcyA8PSAwIHx8IGRlbGF5IDw9IDApIHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ1BsZWFzZSB1c2UgcG9zaXRpdmUgdmFsdWVzIGZvciB0aW1lcyBhbmQgZGVsYXknKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYFN0YXJ0aW5nICR7dGltZXN9IHJhbmRvbSBjYXB0dXJlcy4uLmApO1xuICAgIFxuICAgIC8vIFN0YXJ0IHNlcXVlbmNlXG4gICAgc2NoZWR1bGVSYW5kb21DYXB0dXJlcyh0aW1lcywgdGltZXMsIGRlbGF5KTtcbiAgfTtcbiAgXG4gIC8vIFNjaGVkdWxlIHNlcXVlbmNlIG9mIHJhbmRvbSBjYXB0dXJlcyAtIHVwZGF0ZWQgd2l0aCBjb3VudFNhdmVcbiAgY29uc3Qgc2NoZWR1bGVSYW5kb21DYXB0dXJlcyA9IChyZW1haW5pbmcsIHRvdGFsLCBkZWxheSkgPT4ge1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHJlbWFpbmluZyk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke3RvdGFsIC0gcmVtYWluaW5nICsgMX0gb2YgJHt0b3RhbH1gKTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb24gYW5kIGRyYXdcbiAgICBjb25zdCBjYW52YXMgPSBhY3RpdmVDYW52YXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhbmRvbVBvc2l0aW9uKGNhbnZhcyk7XG4gICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIHNldEN1cnJlbnREb3QocG9zaXRpb24pO1xuICAgIFxuICAgIC8vIFVzZSBzaGFyZWQgY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzXG4gICAgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzKHtcbiAgICAgIGNhbnZhc1JlZjogYWN0aXZlQ2FudmFzUmVmLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgICAgb25TdGF0dXNVcGRhdGUoc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAvLyBTY2hlZHVsZSBuZXh0IGNhcHR1cmVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzY2hlZHVsZVJhbmRvbUNhcHR1cmVzKHJlbWFpbmluZyAtIDEsIHRvdGFsLCBkZWxheSk7XG4gICAgICB9LCBkZWxheSAqIDEwMDApO1xuICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyByYW5kb20gY2FwdHVyZTonLCBlcnJvcik7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBlcnJvciBtZXNzYWdlIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgIH0sIDMwMDApO1xuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIGNhbnZhcyBkaW1lbnNpb25zXG4gIGNvbnN0IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIGlmICghd2lkdGggfHwgIWhlaWdodCB8fCB3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50czogSW52YWxpZCBjYW52YXMgZGltZW5zaW9uc1wiLCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICBcbiAgICBjb25zdCBjb25kaXRpb25hbFJvdW5kID0gKGRpbWVuc2lvbiwgcGVyY2VudGFnZSkgPT4gTWF0aC5yb3VuZChkaW1lbnNpb24gKiBwZXJjZW50YWdlKTtcbiAgXG4gICAgLy8gT3V0ZXIgZnJhbWUgKDEyJSBmcm9tIGVkZ2VzKVxuICAgIGNvbnN0IHhMZWZ0T3V0ZXIgPSBjb25kaXRpb25hbFJvdW5kKHdpZHRoLCAwLjEyKTtcbiAgICBjb25zdCB4UmlnaHRPdXRlciA9IHdpZHRoIC0geExlZnRPdXRlcjtcbiAgICBjb25zdCB5VG9wT3V0ZXIgPSBjb25kaXRpb25hbFJvdW5kKGhlaWdodCwgMC4xMik7XG4gICAgY29uc3QgeUJvdHRvbU91dGVyID0gaGVpZ2h0IC0geVRvcE91dGVyO1xuICBcbiAgICAvLyBJbm5lciBmcmFtZSAoMjYlIGZyb20gZWRnZXMpXG4gICAgY29uc3QgeExlZnRJbm5lciA9IGNvbmRpdGlvbmFsUm91bmQod2lkdGgsIDAuMjYpO1xuICAgIGNvbnN0IHhSaWdodElubmVyID0gd2lkdGggLSB4TGVmdElubmVyO1xuICAgIGNvbnN0IHlUb3BJbm5lciA9IGNvbmRpdGlvbmFsUm91bmQoaGVpZ2h0LCAwLjI2KTtcbiAgICBjb25zdCB5Qm90dG9tSW5uZXIgPSBoZWlnaHQgLSB5VG9wSW5uZXI7XG4gIFxuICAgIGNvbnN0IHhDZW50ZXIgPSBNYXRoLmZsb29yKHdpZHRoIC8gMik7XG4gICAgY29uc3QgeUNlbnRlciA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMik7XG4gIFxuICAgIHJldHVybiBbXG4gICAgICAvLyBPdXRlciBmcmFtZSAoOCBwb2ludHMpXG4gICAgICB7IHg6IHhMZWZ0T3V0ZXIsIHk6IHlUb3BPdXRlciwgbGFiZWw6IFwiT3V0ZXIgVG9wLUxlZnRcIiB9LFxuICAgICAgeyB4OiB4Q2VudGVyLCB5OiB5VG9wT3V0ZXIsIGxhYmVsOiBcIk91dGVyIFRvcC1DZW50ZXJcIiB9LFxuICAgICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeVRvcE91dGVyLCBsYWJlbDogXCJPdXRlciBUb3AtUmlnaHRcIiB9LFxuICAgICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJPdXRlciBNaWRkbGUtTGVmdFwiIH0sXG4gICAgICB7IHg6IHhSaWdodE91dGVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJPdXRlciBNaWRkbGUtUmlnaHRcIiB9LFxuICAgICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5Qm90dG9tT3V0ZXIsIGxhYmVsOiBcIk91dGVyIEJvdHRvbS1MZWZ0XCIgfSxcbiAgICAgIHsgeDogeENlbnRlciwgeTogeUJvdHRvbU91dGVyLCBsYWJlbDogXCJPdXRlciBCb3R0b20tQ2VudGVyXCIgfSxcbiAgICAgIHsgeDogeFJpZ2h0T3V0ZXIsIHk6IHlCb3R0b21PdXRlciwgbGFiZWw6IFwiT3V0ZXIgQm90dG9tLVJpZ2h0XCIgfSxcbiAgXG4gICAgICAvLyBJbm5lciBmcmFtZSAoOCBwb2ludHMpXG4gICAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlUb3BJbm5lciwgbGFiZWw6IFwiSW5uZXIgVG9wLUxlZnRcIiB9LFxuICAgICAgeyB4OiB4Q2VudGVyLCB5OiB5VG9wSW5uZXIsIGxhYmVsOiBcIklubmVyIFRvcC1DZW50ZXJcIiB9LFxuICAgICAgeyB4OiB4UmlnaHRJbm5lciwgeTogeVRvcElubmVyLCBsYWJlbDogXCJJbm5lciBUb3AtUmlnaHRcIiB9LFxuICAgICAgeyB4OiB4TGVmdElubmVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJJbm5lciBNaWRkbGUtTGVmdFwiIH0sXG4gICAgICB7IHg6IHhSaWdodElubmVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJJbm5lciBNaWRkbGUtUmlnaHRcIiB9LFxuICAgICAgeyB4OiB4TGVmdElubmVyLCB5OiB5Qm90dG9tSW5uZXIsIGxhYmVsOiBcIklubmVyIEJvdHRvbS1MZWZ0XCIgfSxcbiAgICAgIHsgeDogeENlbnRlciwgeTogeUJvdHRvbUlubmVyLCBsYWJlbDogXCJJbm5lciBCb3R0b20tQ2VudGVyXCIgfSxcbiAgICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlCb3R0b21Jbm5lciwgbGFiZWw6IFwiSW5uZXIgQm90dG9tLVJpZ2h0XCIgfVxuICAgIF07XG4gIH07XG4gIFxuICAvLyBIYW5kbGUgU2V0IENhbGlicmF0ZSBhY3Rpb25cbiAgY29uc3QgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBTVEVQIDE6IEhJREUgVEhFIFRPUCBCQVIgSU1NRURJQVRFTFkgKGJlZm9yZSBhbnl0aGluZyBlbHNlIGhhcHBlbnMpXG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBZGQgYSBzbWFsbCBkZWxheSB0byBlbnN1cmUgVUkgdXBkYXRlc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSk7XG4gICAgICBcbiAgICAgIC8vIFNURVAgMjogSW5pdGlhbCBzZXR1cFxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicpO1xuICAgICAgXG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6ICdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZScsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDEwcHg7XG4gICAgICAgIHJpZ2h0OiAxMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHBhZGRpbmc6IDhweCAxMnB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA2cHg7XG4gICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0ZSBTZXQgQWN0aXZlOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgXG4gICAgICAvLyBTVEVQIDM6IFNldHVwIGNhbnZhcyBhbmQgZ2VuZXJhdGUgcG9pbnRzXG4gICAgICBjb25zdCBjYW52YXMgPSBhY3RpdmVDYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIGNhbnZhcyBkaW1lbnNpb25zIGFyZSBzZXRcbiAgICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBjYW52YXMud2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhcIkNhbnZhcyBkaW1lbnNpb25zIGZvciBjYWxpYnJhdGlvbjpcIiwgeyB3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQgfSk7XG4gICAgICBcbiAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cyB1c2luZyB0aGUgaW1wb3J0ZWQgZnVuY3Rpb25cbiAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHNldENhbGlicmF0aW9uUG9pbnRzKHBvaW50cyk7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBHZW5lcmF0ZWQgJHtwb2ludHMubGVuZ3RofSBjYWxpYnJhdGlvbiBwb2ludHNgKTtcbiAgICAgIFxuICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMnKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMocG9pbnRzLmxlbmd0aCk7XG4gICAgICBcbiAgICAgIC8vIFNURVAgNDogUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50IGluIHNlcXVlbmNlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdGVcbiAgICAgICAgc2V0Q3VycmVudENhbGlicmF0aW9uSW5kZXgoaSk7XG4gICAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHBvaW50cy5sZW5ndGggLSBpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgICAgY29uc3Qgc3RhdHVzVGV4dCA9IGBDYWxpYnJhdGlvbiAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXNUZXh0KTtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0ZSBTZXQgQWN0aXZlOiBQcm9jZXNzaW5nIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBcbiAgICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgICAgb25TdGF0dXNVcGRhdGUoc3RhdHVzVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgNTogRHJhdyB0aGUgcmVkIGRvdCBGSVJTVCwgYmVmb3JlIGFueSBjb3VudGRvd25cbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIGRyYXdEb3QocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGEgbW9tZW50IHRvIGVuc3VyZSBkb3QgaXMgdmlzaWJsZVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgNjogR2V0IGNhbnZhcyBwb3NpdGlvbiBmb3IgYWJzb2x1dGUgcG9zaXRpb25pbmdcbiAgICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBjb3VudGRvd24gZWxlbWVudCBhYm92ZSB0aGUgZG90XG4gICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLWNvdW50ZG93bic7XG4gICAgICAgIFxuICAgICAgICAvLyBQb3NpdGlvbiBpdCBhYm92ZSB0aGUgZG90XG4gICAgICAgIGNvbnN0IGFic29sdXRlWCA9IGNhbnZhc1JlY3QubGVmdCArIHBvaW50Lng7XG4gICAgICAgIGNvbnN0IGFic29sdXRlWSA9IGNhbnZhc1JlY3QudG9wICsgcG9pbnQueTtcbiAgICAgICAgXG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgbGVmdDogJHthYnNvbHV0ZVh9cHg7XG4gICAgICAgICAgdG9wOiAke2Fic29sdXRlWSAtIDYwfXB4O1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgIGA7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDc6IFJ1biAzLTItMSBjb3VudGRvd24gKHRoZSBkb3Qgc3RheXMgdmlzaWJsZSBkdXJpbmcgdGhpcyB0aW1lKVxuICAgICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRlIFNldCBBY3RpdmU6IGNvdW50ZG93biAke2NvdW50fSAoJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofSlgO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdhaXQgZm9yIG5leHQgY291bnRkb3duIHN0ZXBcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgODogU2hvdyBjYXB0dXJpbmcgaW5kaWNhdG9yXG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FwdHVyaW5nIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA5OiBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYnV0IEtFRVAgdGhlIGRvdCB2aXNpYmxlXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDEwOiBDYXB0dXJlIGltYWdlcyAodGhlIGRvdCBpcyBzdGlsbCB2aXNpYmxlKVxuICAgICAgICBhd2FpdCBjYXB0dXJlSW1hZ2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgMTE6IFdhaXQgZm9yIHByZXZpZXcgdG8gY29tcGxldGUgYmVmb3JlIG1vdmluZyB0byBuZXh0IHBvaW50XG4gICAgICAgIC8vIER1cmluZyB0aGlzIHRpbWUsIHRoZSBkb3QgcmVtYWlucyB2aXNpYmxlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMzAwKSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNURVAgMTI6IENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb24gY29tcGxldGVkJztcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCcpO1xuICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgIG9uU3RhdHVzVXBkYXRlKCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgc3RhdHVzIGluZGljYXRvciBhZnRlciBhIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQ2FsaWJyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgICBvblN0YXR1c1VwZGF0ZShgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBcbiAgLy8gTWFwIGJ1dHRvbiBjbGlja3MgdG8gYXBwcm9wcmlhdGUgaGFuZGxlcnNcbiAgY29uc3QgaGFuZGxlU2NyZWVuQWN0aW9uID0gKGFjdGlvblR5cGUpID0+IHtcbiAgICBjb25zb2xlLmxvZyhgU2NyZWVuIGFjdGlvbiByZWNlaXZlZDogJHthY3Rpb25UeXBlfWApO1xuICAgIFxuICAgIHN3aXRjaChhY3Rpb25UeXBlKSB7XG4gICAgICBjYXNlICdyYW5kb21Eb3QnOlxuICAgICAgICBoYW5kbGVSYW5kb21Eb3QoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzZXRSYW5kb20nOlxuICAgICAgICBoYW5kbGVTZXRSYW5kb20oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjYWxpYnJhdGUnOlxuICAgICAgICBoYW5kbGVTZXRDYWxpYnJhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjbGVhckFsbCc6XG4gICAgICAgIGNsZWFyQ2FudmFzKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRm9yd2FyZCB0byBwYXJlbnQgaWYgbm90IGhhbmRsZWQgaGVyZVxuICAgICAgICBpZiAob25CdXR0b25DbGljaykge1xuICAgICAgICAgIG9uQnV0dG9uQ2xpY2soYWN0aW9uVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvLyBSZWdpc3RlciBhY3Rpb24gaGFuZGxlcnMgd2l0aCBwYXJlbnQgY29tcG9uZW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU2tpcCBkdXJpbmcgU1NSXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgY29uc29sZS5sb2coXCJSZWdpc3RlcmluZyBhY3Rpb24gaGFuZGxlcnMgd2l0aCBwYXJlbnRcIik7XG4gICAgXG4gICAgaWYgKG9uQnV0dG9uQ2xpY2spIHtcbiAgICAgIC8vIENyZWF0ZSBhY3Rpb24gaGFuZGxlcnNcbiAgICAgIGNvbnN0IGFjdGlvbkhhbmRsZXJzID0ge1xuICAgICAgICByYW5kb21Eb3Q6IGhhbmRsZVJhbmRvbURvdCxcbiAgICAgICAgc2V0UmFuZG9tOiBoYW5kbGVTZXRSYW5kb20sXG4gICAgICAgIGNhbGlicmF0ZTogaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAgICAgICBjbGVhckFsbDogY2xlYXJDYW52YXNcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFN0b3JlIGluIHBhcmVudCBjb21wb25lbnQgY29udGV4dFxuICAgICAgb25CdXR0b25DbGljaygncmVnaXN0ZXJBY3Rpb25zJywgYWN0aW9uSGFuZGxlcnMpO1xuICAgICAgXG4gICAgICAvLyBBbHNvIG1ha2UgdGhlbSBnbG9iYWxseSBhdmFpbGFibGUgZm9yIGRpcmVjdCBhY2Nlc3NcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkFjdGlvbnMgPSBhY3Rpb25IYW5kbGVycztcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW51cCBvbiB1bm1vdW50XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cud2hpdGVTY3JlZW5BY3Rpb25zKSB7XG4gICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkFjdGlvbnMgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvbkJ1dHRvbkNsaWNrXSk7XG4gIFxuICAvLyBVcGRhdGUgcGFyZW50IHdpdGggc3RhdHVzIGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAob25TdGF0dXNVcGRhdGUgJiYgcHJvY2Vzc1N0YXR1cykge1xuICAgICAgb25TdGF0dXNVcGRhdGUocHJvY2Vzc1N0YXR1cyk7XG4gICAgfVxuICB9LCBbcHJvY2Vzc1N0YXR1cywgb25TdGF0dXNVcGRhdGVdKTtcbiAgXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3aGl0ZS1zY3JlZW4tY29udGFpbmVyXCIgc3R5bGU9e3sgXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICB6SW5kZXg6IDUwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJyAvLyBTbGlnaHQgdHJhbnNwYXJlbmN5IHRvIHNlZSBpZiBpdCdzIHJlbmRlcmVkXG4gICAgfX0+XG4gICAgICB7LyogV2hpdGUgc2NyZWVuIGNhbnZhcyAtIE1ha2UgaXQgY292ZXIgdGhlIGVudGlyZSBjb250YWluZXIgKi99XG4gICAgICA8ZGl2IFxuICAgICAgICBjbGFzc05hbWU9XCJ3aGl0ZS1zY3JlZW4tY2FudmFzLWNvbnRhaW5lclwiXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJywgLy8gTW9yZSB2aXNpYmxlIGJvcmRlclxuICAgICAgICAgIHpJbmRleDogNTFcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgey8qIENhbnZhcyAtIEFsd2F5cyByZW5kZXIgaXQgKi99XG4gICAgICAgIDxjYW52YXNcbiAgICAgICAgICByZWY9e2NhbnZhc1JlZiA/IGNhbnZhc1JlZiA6IGludGVybmFsQ2FudmFzUmVmfVxuICAgICAgICAgIGNsYXNzTmFtZT1cIndoaXRlLXNjcmVlbi1jYW52YXNcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAgXG4gICAgICAgIHsvKiBPdmVybGF5IGZvciBjb3VudGRvd24gbmVhciBkb3QgLSB3aXRoIGltcHJvdmVkIHZpc2liaWxpdHkgYW5kIGEgZmFsbGJhY2sgKi99XG4gICAgICAgIHsoY291bnRkb3duVmFsdWUgIT09IG51bGwgfHwgZm9yY2VTaG93Q291bnRkb3duKSAmJiBjdXJyZW50RG90ICYmIChcbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZG90LWNvdW50ZG93blwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgbGVmdDogYCR7Y3VycmVudERvdC54IC0gMzB9cHhgLFxuICAgICAgICAgICAgICB0b3A6IGAke2N1cnJlbnREb3QueSAtIDcwfXB4YCxcbiAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzQ4cHgnLCAvLyBNdWNoIGxhcmdlclxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgIHRleHRTaGFkb3c6ICcwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGUnLCAvLyBTdHJvbmdlciBzaGFkb3dcbiAgICAgICAgICAgICAgekluZGV4OiA5OTksXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC44KScsIC8vIEJhY2tncm91bmQgdG8gbWFrZSBpdCBtb3JlIHZpc2libGVcbiAgICAgICAgICAgICAgcGFkZGluZzogJzEwcHggMjBweCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAgICAgICAgIHdpZHRoOiAnNjBweCcsXG4gICAgICAgICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGJvcmRlcjogJzJweCBzb2xpZCByZWQnIC8vIEJvcmRlciB0byBtYWtlIGl0IHN0YW5kIG91dFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y291bnRkb3duVmFsdWUgfHwgM31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBCYWNrdXAgY2VudGVyZWQgY291bnRkb3duIGZvciBiZXR0ZXIgdmlzaWJpbGl0eSAqL31cbiAgICAgICAgeyhjb3VudGRvd25WYWx1ZSAhPT0gbnVsbCB8fCBmb3JjZVNob3dDb3VudGRvd24pICYmIChcbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2VudGVyLWNvdW50ZG93bi1iYWNrdXBcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxuICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgZm9udFNpemU6ICcxMjBweCcsIC8vIFZlcnkgbGFyZ2VcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICB0ZXh0U2hhZG93OiAnMCAwIDIwcHggYmxhY2snLFxuICAgICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAwLCAwLCAwLjcpJywgLy8gUmVkIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgd2lkdGg6ICcyMDBweCcsXG4gICAgICAgICAgICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDAgMzBweCByZ2JhKDAsIDAsIDAsIDAuNSknXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZSB8fCAzfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICBcbiAgICAgICAgey8qIEluZGljYXRvciB0aGF0IHRoZSBkb3QgaXMgcHJlc2VudCAtIGhlbHBzIHdpdGggZGVidWdnaW5nICovfVxuICAgICAgICB7Y3VycmVudERvdCAmJiAoXG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdC1pbmRpY2F0b3JcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgIHRvcDogJzEwcHgnLFxuICAgICAgICAgICAgICByaWdodDogJzEwcHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDI1NSwgMCwgMC43KScsXG4gICAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnNXB4IDEwcHgnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICB6SW5kZXg6IDUyXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIERvdCBhdCB4OntjdXJyZW50RG90Lnh9LCB5OntjdXJyZW50RG90Lnl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIFxuICAgICAgICB7LyogU3RhdHVzIG92ZXJsYXkgKi99XG4gICAgICAgIHsocHJvY2Vzc1N0YXR1cyB8fCByZW1haW5pbmdDYXB0dXJlcyA+IDApICYmIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJzdGF0dXMtb3ZlcmxheVwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgYm90dG9tOiAnMTBweCcsXG4gICAgICAgICAgICAgIGxlZnQ6ICcxMHB4JyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjgpJywgLy8gRGFya2VyIGZvciB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLCAvLyBXaGl0ZSB0ZXh0XG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcxMHB4IDE1cHgnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLCAvLyBMYXJnZXJcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLDAsMCwwLjMpJyxcbiAgICAgICAgICAgICAgekluZGV4OiA1M1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7cHJvY2Vzc1N0YXR1cyAmJiA8ZGl2Pntwcm9jZXNzU3RhdHVzfTwvZGl2Pn1cbiAgICAgICAgICAgIHtyZW1haW5pbmdDYXB0dXJlcyA+IDAgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiAnI2ZmY2MwMCcgfX0+XG4gICAgICAgICAgICAgICAgUmVtYWluaW5nOiB7cmVtYWluaW5nQ2FwdHVyZXN9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBDYW52YXMgdmlzaWJpbGl0eSBpbmRpY2F0b3IgLSBkZWJ1Z2dpbmcgb25seSAqL31cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbnZhcy1pbmRpY2F0b3JcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogJzEwcHgnLFxuICAgICAgICAgICAgbGVmdDogJzEwcHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjYW52YXNWaXNpYmxlID8gJ3JnYmEoMCwgMjU1LCAwLCAwLjcpJyA6ICdyZ2JhKDI1NSwgMCwgMCwgMC43KScsXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCcsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgIHpJbmRleDogNTJcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgQ2FudmFzOiB7Y2FudmFzVmlzaWJsZSA/ICdWaXNpYmxlJyA6ICdIaWRkZW4nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gRXhwb3J0IGEgZHluYW1pYyB2ZXJzaW9uIHdpdGggU1NSIGRpc2FibGVkIHRvIGF2b2lkIHVzZUxheW91dEVmZmVjdCB3YXJuaW5nc1xuZXhwb3J0IGRlZmF1bHQgZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoV2hpdGVTY3JlZW5NYWluKSwgeyBzc3I6IGZhbHNlIH0pOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiZHluYW1pYyIsImdldFJhbmRvbVBvc2l0aW9uIiwiZHJhd1JlZERvdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsImluaXRpYWxpemVDYW52YXMiLCJjYXB0dXJlSW1hZ2VzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiV2hpdGVTY3JlZW5NYWluIiwib25TdGF0dXNVcGRhdGUiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwib25CdXR0b25DbGljayIsImNhbnZhc1JlZiIsInRvZ2dsZVRvcEJhciIsImludGVybmFsQ2FudmFzUmVmIiwiYWN0aXZlQ2FudmFzUmVmIiwiY3VycmVudERvdCIsInNldEN1cnJlbnREb3QiLCJpc0NhcHR1cmluZyIsInNldElzQ2FwdHVyaW5nIiwiY291bnRkb3duVmFsdWUiLCJzZXRDb3VudGRvd25WYWx1ZSIsInJlbWFpbmluZ0NhcHR1cmVzIiwic2V0UmVtYWluaW5nQ2FwdHVyZXMiLCJwcm9jZXNzU3RhdHVzIiwic2V0UHJvY2Vzc1N0YXR1cyIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJjYXB0dXJlRm9sZGVyIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJjdXJyZW50Q2FsaWJyYXRpb25JbmRleCIsInNldEN1cnJlbnRDYWxpYnJhdGlvbkluZGV4IiwiY2FudmFzVmlzaWJsZSIsInNldENhbnZhc1Zpc2libGUiLCJmb3JjZVNob3dDb3VudGRvd24iLCJzZXRGb3JjZVNob3dDb3VudGRvd24iLCJjYW52YXMiLCJjdXJyZW50IiwiY29uc29sZSIsImVycm9yIiwibG9nIiwiaGFzQ2FudmFzIiwiY2FudmFzSGVpZ2h0IiwiaGVpZ2h0IiwiY2FudmFzV2lkdGgiLCJ3aWR0aCIsInVwZGF0ZURpbWVuc2lvbnMiLCJwYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwicGFyZW50V2lkdGgiLCJjbGllbnRXaWR0aCIsInBhcmVudEhlaWdodCIsImNsaWVudEhlaWdodCIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImRyYXdEb3QiLCJ4IiwieSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY29sb3IiLCJyYWRpdXMiLCJjbGVhclJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJNYXRoIiwiUEkiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJwcmV2IiwiY2xlYXJDYW52YXMiLCJzZXRUaW1lb3V0Iiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJpbWFnZURhdGEiLCJmaWxlbmFtZSIsInR5cGUiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9sZGVyIiwib2siLCJFcnJvciIsInN0YXR1cyIsInJlc3VsdCIsImpzb24iLCJjYXB0dXJlTnVtYmVyIiwiY2FwdHVyZUltYWdlIiwiY2FwdHVyZVJlc3VsdCIsInBvc2l0aW9uIiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsIm1lc3NhZ2UiLCJoYW5kbGVSYW5kb21Eb3QiLCJoYW5kbGVTZXRSYW5kb20iLCJ0aW1lcyIsInBhcnNlSW50IiwiZGVsYXkiLCJzY2hlZHVsZVJhbmRvbUNhcHR1cmVzIiwicmVtYWluaW5nIiwidG90YWwiLCJ0aGVuIiwiY2F0Y2giLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiY29uZGl0aW9uYWxSb3VuZCIsImRpbWVuc2lvbiIsInBlcmNlbnRhZ2UiLCJyb3VuZCIsInhMZWZ0T3V0ZXIiLCJ4UmlnaHRPdXRlciIsInlUb3BPdXRlciIsInlCb3R0b21PdXRlciIsInhMZWZ0SW5uZXIiLCJ4UmlnaHRJbm5lciIsInlUb3BJbm5lciIsInlCb3R0b21Jbm5lciIsInhDZW50ZXIiLCJmbG9vciIsInlDZW50ZXIiLCJsYWJlbCIsImhhbmRsZVNldENhbGlicmF0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic3RhdHVzSW5kaWNhdG9yIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwidGV4dENvbnRlbnQiLCJhcHBlbmRDaGlsZCIsInBvaW50cyIsImxlbmd0aCIsImkiLCJzdGF0dXNUZXh0IiwicG9pbnQiLCJjYW52YXNSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY291bnRkb3duRWxlbWVudCIsImFic29sdXRlWCIsImxlZnQiLCJhYnNvbHV0ZVkiLCJ0b3AiLCJjb3VudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImhhbmRsZVNjcmVlbkFjdGlvbiIsImFjdGlvblR5cGUiLCJhY3Rpb25IYW5kbGVycyIsInJhbmRvbURvdCIsInNldFJhbmRvbSIsImNhbGlicmF0ZSIsImNsZWFyQWxsIiwid2hpdGVTY3JlZW5BY3Rpb25zIiwiZGl2IiwiekluZGV4IiwiYmFja2dyb3VuZENvbG9yIiwib3ZlcmZsb3ciLCJib3JkZXIiLCJyZWYiLCJkaXNwbGF5IiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwidGV4dFNoYWRvdyIsInBhZGRpbmciLCJib3JkZXJSYWRpdXMiLCJib3hTaGFkb3ciLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJ0cmFuc2Zvcm0iLCJyaWdodCIsImJvdHRvbSIsInNzciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/WhiteScreenMain.js\n");

/***/ })

};
;