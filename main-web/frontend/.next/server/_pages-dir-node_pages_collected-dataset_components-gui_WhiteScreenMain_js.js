"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_pages_collected-dataset_components-gui_WhiteScreenMain_js";
exports.ids = ["_pages-dir-node_pages_collected-dataset_components-gui_WhiteScreenMain_js"];
exports.modules = {

/***/ "(pages-dir-node)/./pages/collected-dataset/components-gui/WhiteScreenMain.js":
/*!*******************************************************************!*\
  !*** ./pages/collected-dataset/components-gui/WhiteScreenMain.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-node)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n// components-gui/WhiteScreenMain.js\n\n\n\n// Create a client-only version of the component\nconst WhiteScreenMain = ({ onStatusUpdate, triggerCameraAccess, onButtonClick, canvasRef = null, toggleTopBar })=>{\n    // Use provided canvasRef or create a new one\n    const internalCanvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const activeCanvasRef = canvasRef || internalCanvasRef;\n    // Current dot state\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Track capture session\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [captureFolder] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('eye_tracking_captures'); // Fixed folder name\n    // Configuration state\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [currentCalibrationIndex, setCurrentCalibrationIndex] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    // Debug state to make visibility easier to track\n    const [canvasVisible, setCanvasVisible] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [forceShowCountdown, setForceShowCountdown] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Set up canvas when component mounts\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            // Skip if this runs during SSR\n            if (true) return;\n            const canvas = activeCanvasRef.current;\n            if (!canvas) {\n                console.error(\"Canvas ref is null in setup effect\");\n                return;\n            }\n            console.log(\"Canvas setup effect running\", {\n                hasCanvas: !!canvas,\n                canvasHeight: canvas.height,\n                canvasWidth: canvas.width\n            });\n            // Function to update canvas dimensions\n            const updateDimensions = {\n                \"WhiteScreenMain.useEffect.updateDimensions\": ()=>{\n                    const parent = canvas.parentElement;\n                    if (!parent) {\n                        console.error(\"Canvas parent is null\");\n                        return;\n                    }\n                    // Get the parent container dimensions\n                    const parentWidth = parent.clientWidth;\n                    const parentHeight = parent.clientHeight;\n                    console.log(\"Resizing canvas to:\", {\n                        parentWidth,\n                        parentHeight\n                    });\n                    canvas.width = parentWidth;\n                    canvas.height = parentHeight;\n                    // Clear the canvas and set background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Redraw current dot if exists\n                    if (currentDot) {\n                        console.log(\"Redrawing dot after resize:\", currentDot);\n                        drawDot(currentDot.x, currentDot.y, 'red', 8);\n                    }\n                    setCanvasVisible(true);\n                }\n            }[\"WhiteScreenMain.useEffect.updateDimensions\"];\n            // Add this helper function to show a preview of the captured images\n            const showCapturePreview = {\n                \"WhiteScreenMain.useEffect.showCapturePreview\": (screenImage, webcamImage, dotPosition)=>{\n                    if (!screenImage && !webcamImage) {\n                        console.warn(\"No images available to preview\");\n                        return;\n                    }\n                    // Remove any existing preview containers first (in case of overlapping)\n                    try {\n                        const existingPreviews = document.querySelectorAll('.capture-preview-container');\n                        existingPreviews.forEach({\n                            \"WhiteScreenMain.useEffect.showCapturePreview\": (preview)=>{\n                                if (preview.parentNode) {\n                                    console.log(\"Removing existing preview container\");\n                                    preview.parentNode.removeChild(preview);\n                                }\n                            }\n                        }[\"WhiteScreenMain.useEffect.showCapturePreview\"]);\n                    } catch (cleanupError) {\n                        console.error(\"Error cleaning up existing previews:\", cleanupError);\n                    }\n                    // Create a new preview container with z-index higher than everything else\n                    const previewContainer = document.createElement('div');\n                    previewContainer.className = 'capture-preview-container';\n                    previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 999999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n    `;\n                    console.log(\"Preview container created\");\n                    // Add debug info div\n                    const debugInfo = document.createElement('div');\n                    debugInfo.style.cssText = `\n      position: absolute;\n      top: -30px;\n      left: 0;\n      width: 100%;\n      color: white;\n      font-size: 12px;\n      text-align: center;\n    `;\n                    debugInfo.textContent = `Screen: ${screenImage ? 'YES' : 'NO'}, Webcam: ${webcamImage ? 'YES' : 'NO'}`;\n                    previewContainer.appendChild(debugInfo);\n                    // Function to add an image to the preview\n                    const addImagePreview = {\n                        \"WhiteScreenMain.useEffect.showCapturePreview.addImagePreview\": (image, label)=>{\n                            try {\n                                console.log(`Adding ${label} preview, image data length: ${image ? image.length : 'N/A'}`);\n                                const preview = document.createElement('div');\n                                preview.style.cssText = `\n          display: flex;\n          flex-direction: column;\n          align-items: center;\n        `;\n                                const img = document.createElement('img');\n                                img.src = image;\n                                img.alt = label;\n                                img.style.cssText = `\n          max-width: 320px;\n          max-height: 240px;\n          border: 3px solid white;\n          border-radius: 8px;\n          background-color: #333;\n        `;\n                                // Event listeners for image loading\n                                img.onload = ({\n                                    \"WhiteScreenMain.useEffect.showCapturePreview.addImagePreview\": ()=>console.log(`${label} image loaded successfully`)\n                                })[\"WhiteScreenMain.useEffect.showCapturePreview.addImagePreview\"];\n                                img.onerror = ({\n                                    \"WhiteScreenMain.useEffect.showCapturePreview.addImagePreview\": (e)=>console.error(`Error loading ${label} image:`, e)\n                                })[\"WhiteScreenMain.useEffect.showCapturePreview.addImagePreview\"];\n                                const labelElement = document.createElement('div');\n                                labelElement.textContent = label;\n                                labelElement.style.cssText = `\n          color: white;\n          font-size: 14px;\n          margin-top: 10px;\n          font-weight: bold;\n        `;\n                                preview.appendChild(img);\n                                preview.appendChild(labelElement);\n                                previewContainer.appendChild(preview);\n                                console.log(`${label} preview element added to container`);\n                                return true;\n                            } catch (error) {\n                                console.error(`Error adding ${label} preview:`, error);\n                                return false;\n                            }\n                        }\n                    }[\"WhiteScreenMain.useEffect.showCapturePreview.addImagePreview\"];\n                    // Add both images to preview if available\n                    if (screenImage) {\n                        addImagePreview(screenImage, 'Screen Capture');\n                    }\n                    if (webcamImage) {\n                        addImagePreview(webcamImage, 'Webcam Capture');\n                    }\n                    // Add dot position info if available\n                    if (dotPosition) {\n                        const positionInfo = document.createElement('div');\n                        positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n                        positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -50px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n                        previewContainer.appendChild(positionInfo);\n                        console.log(\"Dot position info added\");\n                    }\n                    // Add countdown timer\n                    const timerElement = document.createElement('div');\n                    timerElement.textContent = '2.0s';\n                    timerElement.style.cssText = `\n      position: absolute;\n      bottom: -25px;\n      right: 20px;\n      color: white;\n      font-size: 12px;\n      background-color: rgba(0, 0, 0, 0.7);\n      padding: 3px 8px;\n      border-radius: 4px;\n    `;\n                    previewContainer.appendChild(timerElement);\n                    // Add to document body\n                    try {\n                        document.body.appendChild(previewContainer);\n                        console.log(\"Preview container added to DOM\");\n                    } catch (appendError) {\n                        console.error(\"Error adding preview container to DOM:\", appendError);\n                    }\n                    // Countdown and remove the preview after 2 seconds\n                    let timeLeft = 2.0;\n                    const interval = setInterval({\n                        \"WhiteScreenMain.useEffect.showCapturePreview.interval\": ()=>{\n                            timeLeft -= 0.1;\n                            if (timeLeft <= 0) {\n                                clearInterval(interval);\n                                // Fade out\n                                previewContainer.style.transition = 'opacity 0.3s ease';\n                                previewContainer.style.opacity = '0';\n                                // Remove after fade\n                                setTimeout({\n                                    \"WhiteScreenMain.useEffect.showCapturePreview.interval\": ()=>{\n                                        if (previewContainer.parentNode) {\n                                            console.log(\"Removing preview container from DOM\");\n                                            previewContainer.parentNode.removeChild(previewContainer);\n                                        }\n                                    }\n                                }[\"WhiteScreenMain.useEffect.showCapturePreview.interval\"], 300);\n                            } else {\n                                timerElement.textContent = `${timeLeft.toFixed(1)}s`;\n                            }\n                        }\n                    }[\"WhiteScreenMain.useEffect.showCapturePreview.interval\"], 100);\n                    // Safety cleanup after 5 seconds in case anything goes wrong\n                    setTimeout({\n                        \"WhiteScreenMain.useEffect.showCapturePreview\": ()=>{\n                            if (previewContainer.parentNode) {\n                                console.log(\"Safety cleanup of preview container\");\n                                previewContainer.parentNode.removeChild(previewContainer);\n                            }\n                        }\n                    }[\"WhiteScreenMain.useEffect.showCapturePreview\"], 5000);\n                }\n            }[\"WhiteScreenMain.useEffect.showCapturePreview\"];\n            // Initial sizing\n            updateDimensions();\n            // Listen for window resize\n            window.addEventListener('resize', updateDimensions);\n            // Clean up\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    window.removeEventListener('resize', updateDimensions);\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        activeCanvasRef,\n        currentDot\n    ]);\n    // Generate a random position on the canvas\n    const getRandomPosition = ()=>{\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in getRandomPosition\");\n            return {\n                x: 100,\n                y: 100\n            }; // Fallback position\n        }\n        const width = canvas.width || 400; // Fallback if width is 0\n        const height = canvas.height || 300; // Fallback if height is 0\n        console.log(\"Canvas dimensions for random position:\", {\n            width,\n            height\n        });\n        // Ensure we're not too close to the edges\n        const padding = 40; // Increased padding\n        return {\n            x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n            y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n        };\n    };\n    // Draw a dot on the canvas\n    const drawDot = (x, y, color = 'red', radius = 12)=>{\n        console.log(\"Drawing dot at:\", {\n            x,\n            y,\n            color,\n            radius\n        });\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in drawDot\");\n            return null;\n        }\n        const ctx = canvas.getContext('2d');\n        // Clear canvas\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Draw dot with glow effect\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        // Add glow effect\n        ctx.beginPath();\n        ctx.arc(x, y, radius + 5, 0, Math.PI * 2); // Increased glow\n        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; // More visible glow\n        ctx.lineWidth = 3; // Thicker line\n        ctx.stroke();\n        // Store current dot position - using callback form to ensure it updates\n        setCurrentDot((prev)=>{\n            console.log(\"Updating currentDot state from:\", prev, \"to:\", {\n                x,\n                y\n            });\n            return {\n                x,\n                y\n            };\n        });\n        return {\n            x,\n            y\n        };\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        console.log(\"Clearing canvas\");\n        const canvas = activeCanvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas ref is null in clearCanvas\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n        setCountdownValue(null);\n        setForceShowCountdown(false);\n        setProcessStatus('Canvas cleared');\n        // Clear the message after a delay\n        setTimeout(()=>{\n            setProcessStatus('');\n        }, 1500);\n    };\n    // Start countdown timer\n    const startCountdown = (count, onComplete)=>{\n        console.log(\"Starting countdown from:\", count);\n        // Set countdown value in state\n        setCountdownValue(count);\n        setForceShowCountdown(true);\n        setIsCapturing(true);\n        // Update status for parent component\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                countdownValue: count,\n                processStatus: `Countdown: ${count}`,\n                isCapturing: true\n            });\n        }\n        const timer = setTimeout(()=>{\n            if (count > 1) {\n                startCountdown(count - 1, onComplete);\n            } else {\n                // Final countdown step\n                console.log(\"Countdown finished, clearing countdown display\");\n                setCountdownValue(null);\n                setForceShowCountdown(false);\n                // Update status for parent component\n                if (onStatusUpdate) {\n                    onStatusUpdate({\n                        countdownValue: null,\n                        processStatus: 'Capturing...',\n                        isCapturing: true\n                    });\n                }\n                // Execute completion callback immediately\n                if (onComplete) {\n                    console.log(\"Executing completion callback\");\n                    onComplete();\n                }\n            }\n        }, 800);\n        return ()=>clearTimeout(timer);\n    };\n    // Save an image to the server\n    const saveImageToServer = async (imageData, filename, type)=>{\n        try {\n            console.log(`Attempting to save ${type} image: ${filename}`);\n            const response = await fetch('/api/save-capture', {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    imageData,\n                    filename,\n                    type,\n                    folder: captureFolder\n                })\n            });\n            if (!response.ok) {\n                throw new Error(`Server responded with ${response.status}`);\n            }\n            const result = await response.json();\n            console.log(`Saved ${type} image:`, result);\n            // If the server returns a new capture number, update our counter\n            if (result.captureNumber) {\n                setCaptureCounter(result.captureNumber + 1);\n            }\n            return result;\n        } catch (error) {\n            console.error(`Error saving ${type} image:`, error);\n            throw error;\n        }\n    };\n    // Modified captureImage function in WhiteScreenMain.js\n    // Modified captureImage function for WhiteScreenMain.js\n    // Fixed captureImage function for WhiteScreenMain.js\n    const captureImage = async ()=>{\n        console.log(\"Capturing images...\");\n        setIsCapturing(true);\n        try {\n            // Generate filenames with counter\n            const screenFilename = `screen_${String(captureCounter).padStart(3, '0')}.jpg`;\n            const webcamFilename = `webcam_${String(captureCounter).padStart(3, '0')}.jpg`;\n            const parameterFilename = `parameter_${String(captureCounter).padStart(3, '0')}.csv`;\n            // Capture screen image (canvas with dot)\n            const canvas = activeCanvasRef.current;\n            let screenImage = null;\n            if (canvas) {\n                console.log(\"Capturing screen from canvas\");\n                screenImage = canvas.toDataURL('image/png');\n                await saveImageToServer(screenImage, screenFilename, 'screen');\n                console.log(`Saved screen image: ${screenFilename}`);\n            } else {\n                console.error(\"Cannot capture screen - canvas ref is null\");\n            }\n            // Capture webcam image if available\n            let webcamImage = null;\n            if (window.videoElement) {\n                console.log(\"Capturing from webcam\");\n                const tempCanvas = document.createElement('canvas');\n                const ctx = tempCanvas.getContext('2d');\n                tempCanvas.width = window.videoElement.videoWidth;\n                tempCanvas.height = window.videoElement.videoHeight;\n                ctx.drawImage(window.videoElement, 0, 0, tempCanvas.width, tempCanvas.height);\n                webcamImage = tempCanvas.toDataURL('image/png');\n                await saveImageToServer(webcamImage, webcamFilename, 'webcam');\n                console.log(`Saved webcam image: ${webcamFilename}`);\n            } else {\n                // Try to silently capture from webcam\n                try {\n                    // Create a temporary stream for just this capture\n                    const stream = await navigator.mediaDevices.getUserMedia({\n                        video: true,\n                        audio: false\n                    });\n                    // Create a hidden video element to receive the stream\n                    const tempVideo = document.createElement('video');\n                    tempVideo.autoplay = true;\n                    tempVideo.playsInline = true;\n                    tempVideo.muted = true;\n                    tempVideo.style.position = 'absolute';\n                    tempVideo.style.left = '-9999px'; // Position off-screen\n                    tempVideo.style.opacity = '0';\n                    document.body.appendChild(tempVideo);\n                    // Set the stream to the video element\n                    tempVideo.srcObject = stream;\n                    // Wait for video to initialize\n                    await new Promise((resolve)=>{\n                        const timeoutId = setTimeout(()=>{\n                            console.warn(\"Video loading timed out, continuing anyway\");\n                            resolve();\n                        }, 1000);\n                        tempVideo.onloadeddata = ()=>{\n                            clearTimeout(timeoutId);\n                            resolve();\n                        };\n                    });\n                    // Small delay to ensure a clear frame\n                    await new Promise((resolve)=>setTimeout(resolve, 200));\n                    // Capture the frame to a canvas\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = tempVideo.videoWidth || 640;\n                    tempCanvas.height = tempVideo.videoHeight || 480;\n                    const ctx = tempCanvas.getContext('2d');\n                    ctx.drawImage(tempVideo, 0, 0, tempCanvas.width, tempCanvas.height);\n                    // Get image data\n                    webcamImage = tempCanvas.toDataURL('image/png');\n                    console.log(`Captured webcam silently: ${webcamFilename}`);\n                    await saveImageToServer(webcamImage, webcamFilename, 'webcam');\n                    // IMPORTANT: Clean up - stop stream and remove video element\n                    stream.getTracks().forEach((track)=>track.stop());\n                    tempVideo.srcObject = null;\n                    if (tempVideo.parentNode) {\n                        tempVideo.parentNode.removeChild(tempVideo);\n                    }\n                } catch (webcamError) {\n                    console.log(\"Webcam element not available and silent capture failed:\", webcamError);\n                }\n            }\n            // Save parameters to CSV\n            try {\n                // Create CSV content with two columns: name and value\n                const csvData = [\n                    \"name,value\",\n                    `dot_x,${currentDot ? currentDot.x : 0}`,\n                    `dot_y,${currentDot ? currentDot.y : 0}`,\n                    `canvas_width,${canvas ? canvas.width : 0}`,\n                    `canvas_height,${canvas ? canvas.height : 0}`,\n                    `window_width,${window.innerWidth}`,\n                    `window_height,${window.innerHeight}`,\n                    `timestamp,${new Date().toISOString()}`\n                ].join('\\n');\n                // Convert CSV to data URL\n                const csvBlob = new Blob([\n                    csvData\n                ], {\n                    type: 'text/csv'\n                });\n                const csvReader = new FileReader();\n                const csvDataUrl = await new Promise((resolve)=>{\n                    csvReader.onloadend = ()=>resolve(csvReader.result);\n                    csvReader.readAsDataURL(csvBlob);\n                });\n                // Save CSV using the same API\n                await saveImageToServer(csvDataUrl, parameterFilename, 'parameters');\n                console.log(`Saved parameters CSV: ${parameterFilename}`);\n            } catch (csvError) {\n                console.error(\"Error saving parameter CSV:\", csvError);\n            }\n            // THIS IS THE MISSING PIECE - Show preview after capturing\n            console.log(\"Showing image preview with:\", {\n                hasScreenImage: !!screenImage,\n                hasWebcamImage: !!webcamImage\n            });\n            showCapturePreview(screenImage, webcamImage, currentDot);\n            // Increment the counter for next capture\n            setCaptureCounter((prev)=>prev + 1);\n            // Update status\n            setIsCapturing(false);\n            setProcessStatus(`Captured with dot at: x=${currentDot?.x}, y=${currentDot?.y}`);\n            // Update parent component\n            if (onStatusUpdate) {\n                onStatusUpdate(`Images and parameters saved for capture #${captureCounter}`);\n            }\n            // Show TopBar again after capture with a delay to let preview finish\n            setTimeout(()=>{\n                console.log(\"Showing TopBar after capture\");\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if (false) {}\n            }, 2500); // Increased to wait for preview to finish\n        } catch (error) {\n            console.error('Error during capture:', error);\n            setIsCapturing(false);\n            setProcessStatus('Error capturing images: ' + error.message);\n        }\n        // Clear status after a delay\n        setTimeout(()=>{\n            setProcessStatus('');\n        }, 3000);\n    };\n    // Add this new function to show a preview of captured images\n    const showCapturePreview = (screenImage, webcamImage, dotPosition)=>{\n        if (!screenImage && !webcamImage) return;\n        // Create a container for the preview\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = `\n      position: fixed;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%);\n      display: flex;\n      gap: 20px;\n      background-color: rgba(0, 0, 0, 0.85);\n      padding: 20px;\n      border-radius: 12px;\n      z-index: 9999;\n      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\n    `;\n        // Add screen image preview\n        if (screenImage) {\n            const screenPreview = document.createElement('div');\n            screenPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n            const screenImg = document.createElement('img');\n            screenImg.src = screenImage;\n            screenImg.style.cssText = `\n        max-width: 300px;\n        max-height: 200px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n            const screenLabel = document.createElement('div');\n            screenLabel.textContent = 'Screen Capture';\n            screenLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n            screenPreview.appendChild(screenImg);\n            screenPreview.appendChild(screenLabel);\n            previewContainer.appendChild(screenPreview);\n        }\n        // Add webcam image preview\n        if (webcamImage) {\n            const webcamPreview = document.createElement('div');\n            webcamPreview.style.cssText = `\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n      `;\n            const webcamImg = document.createElement('img');\n            webcamImg.src = webcamImage;\n            webcamImg.style.cssText = `\n        max-width: 300px;\n        max-height: 200px;\n        border: 3px solid white;\n        border-radius: 8px;\n      `;\n            const webcamLabel = document.createElement('div');\n            webcamLabel.textContent = 'Webcam Capture';\n            webcamLabel.style.cssText = `\n        color: white;\n        font-size: 14px;\n        margin-top: 10px;\n        font-weight: bold;\n      `;\n            webcamPreview.appendChild(webcamImg);\n            webcamPreview.appendChild(webcamLabel);\n            previewContainer.appendChild(webcamPreview);\n        }\n        // Add position indicator if available\n        if (dotPosition) {\n            const positionInfo = document.createElement('div');\n            positionInfo.textContent = `Dot position: x=${Math.round(dotPosition.x)}, y=${Math.round(dotPosition.y)}`;\n            positionInfo.style.cssText = `\n        color: #ffcc00;\n        font-size: 14px;\n        position: absolute;\n        top: -30px;\n        left: 0;\n        width: 100%;\n        text-align: center;\n      `;\n            previewContainer.appendChild(positionInfo);\n        }\n        // Add the preview to the document\n        document.body.appendChild(previewContainer);\n        // Remove preview after 2 seconds\n        setTimeout(()=>{\n            document.body.removeChild(previewContainer);\n        }, 2000);\n    };\n    // Random Dot action\n    const handleRandomDot = ()=>{\n        // Hide the TopBar before showing dot\n        if (typeof toggleTopBar === 'function') {\n            toggleTopBar(false);\n        } else if (false) {}\n        setIsCapturing(true);\n        setProcessStatus('Generating random dot...');\n        // Give the component time to update\n        setTimeout(()=>{\n            const canvas = activeCanvasRef.current;\n            if (canvas) {\n                // Make sure canvas dimensions are properly set\n                const parent = canvas.parentElement;\n                if (parent) {\n                    canvas.width = parent.clientWidth;\n                    canvas.height = parent.clientHeight;\n                }\n                // Clear any previous content\n                const ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                // Generate random position\n                const position = getRandomPosition();\n                // Draw the dot with a larger radius for visibility\n                ctx.beginPath();\n                ctx.arc(position.x, position.y, 12, 0, Math.PI * 2);\n                ctx.fillStyle = 'red';\n                ctx.fill();\n                // Add glow effect to the dot\n                ctx.beginPath();\n                ctx.arc(position.x, position.y, 15, 0, Math.PI * 2);\n                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n                ctx.lineWidth = 3;\n                ctx.stroke();\n                // Store current dot position directly\n                setCurrentDot(position);\n                // Get the canvas position relative to the viewport\n                const canvasRect = canvas.getBoundingClientRect();\n                // IMPORTANT: Create the countdown element directly above the dot\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'forced-countdown';\n                // Position it above the dot (calculate absolute position considering the canvas position)\n                const absoluteX = canvasRect.left + position.x;\n                const absoluteY = canvasRect.top + position.y;\n                countdownElement.style.cssText = `\n          position: fixed;\n          left: ${absoluteX}px;\n          top: ${absoluteY - 60}px;\n          transform: translateX(-50%);\n          color: red;\n          font-size: 36px;\n          font-weight: bold;\n          text-shadow: 0 0 10px white, 0 0 20px white;\n          z-index: 9999;\n          background-color: rgba(255, 255, 255, 0.8);\n          border: 2px solid red;\n          border-radius: 50%;\n          width: 50px;\n          height: 50px;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n        `;\n                document.body.appendChild(countdownElement);\n                // Manual countdown implementation\n                let count = 3;\n                countdownElement.textContent = count;\n                const countdownInterval = setInterval(()=>{\n                    count--;\n                    if (count <= 0) {\n                        clearInterval(countdownInterval);\n                        countdownElement.remove();\n                        captureImage(); // Proceed with capture\n                    } else {\n                        countdownElement.textContent = count;\n                    }\n                }, 800);\n            }\n        }, 200);\n    };\n    // Multiple random dots sequence\n    const handleSetRandom = ()=>{\n        if (isCapturing) return;\n        // Parse input values (use defaults if invalid)\n        const times = parseInt(randomTimes) || 1;\n        const delay = parseInt(delaySeconds) || 3;\n        if (times <= 0 || delay <= 0) {\n            setProcessStatus('Please use positive values for times and delay');\n            return;\n        }\n        setIsCapturing(true);\n        setRemainingCaptures(times);\n        setProcessStatus(`Starting ${times} random captures...`);\n        // Start sequence\n        scheduleRandomCaptures(times, times, delay);\n    };\n    // Schedule sequence of random captures\n    const scheduleRandomCaptures = (remaining, total, delay)=>{\n        if (remaining <= 0) {\n            setIsCapturing(false);\n            setRemainingCaptures(0);\n            setProcessStatus('Random capture sequence completed');\n            // Clear status after a delay\n            setTimeout(()=>{\n                setProcessStatus('');\n            }, 2000);\n            return;\n        }\n        setRemainingCaptures(remaining);\n        setProcessStatus(`Capture ${total - remaining + 1} of ${total}`);\n        // Generate random position and draw\n        const position = getRandomPosition();\n        drawDot(position.x, position.y);\n        // Start countdown and capture\n        startCountdown(3, ()=>{\n            captureImage();\n            // Schedule next capture\n            setTimeout(()=>{\n                scheduleRandomCaptures(remaining - 1, total, delay);\n            }, delay * 1000);\n        });\n    };\n    // Generate calibration points\n    const generateCalibrationPoints = ()=>{\n        const canvas = activeCanvasRef.current;\n        if (!canvas) return [];\n        const width = canvas.width;\n        const height = canvas.height;\n        // Helper function for rounding\n        const conditionalRound = (dimension, percentage)=>{\n            return Math.round(dimension * percentage);\n        };\n        // Define percentage values for outer and inner frames\n        const firstFramePercentage = 0.12; // Outer frame at 12% from edges\n        const secondFramePercentage = 0.26; // Inner frame at 26% from edges\n        // Calculate points for outer frame (first frame)\n        const xLeftFirst = conditionalRound(width, firstFramePercentage);\n        const xRightFirst = width - conditionalRound(width, firstFramePercentage);\n        const yTopFirst = conditionalRound(height, firstFramePercentage);\n        const yBottomFirst = height - conditionalRound(height, firstFramePercentage);\n        // Calculate points for inner frame (second frame)\n        const xLeftSecond = conditionalRound(width, secondFramePercentage);\n        const xRightSecond = width - conditionalRound(width, secondFramePercentage);\n        const yTopSecond = conditionalRound(height, secondFramePercentage);\n        const yBottomSecond = height - conditionalRound(height, secondFramePercentage);\n        // Return array of points in specific order\n        return [\n            // First frame - outer points\n            {\n                x: xLeftFirst,\n                y: yTopFirst\n            },\n            {\n                x: Math.floor(width / 2),\n                y: yTopFirst\n            },\n            {\n                x: xRightFirst,\n                y: yTopFirst\n            },\n            {\n                x: xLeftFirst,\n                y: Math.floor(height / 2)\n            },\n            {\n                x: xRightFirst,\n                y: Math.floor(height / 2)\n            },\n            {\n                x: xLeftFirst,\n                y: yBottomFirst\n            },\n            {\n                x: Math.floor(width / 2),\n                y: yBottomFirst\n            },\n            {\n                x: xRightFirst,\n                y: yBottomFirst\n            },\n            // Second frame - inner points\n            {\n                x: xLeftSecond,\n                y: yTopSecond\n            },\n            {\n                x: Math.floor(width / 2),\n                y: yTopSecond\n            },\n            {\n                x: xRightSecond,\n                y: yTopSecond\n            },\n            {\n                x: xLeftSecond,\n                y: Math.floor(height / 2)\n            },\n            {\n                x: xRightSecond,\n                y: Math.floor(height / 2)\n            },\n            {\n                x: xLeftSecond,\n                y: yBottomSecond\n            },\n            {\n                x: Math.floor(width / 2),\n                y: yBottomSecond\n            },\n            {\n                x: xRightSecond,\n                y: yBottomSecond\n            }\n        ];\n    };\n    // In WhiteScreenMain.js - Update the useEffect for button click registration\n    // Make sure the calibrate action is properly registered\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            // Skip during SSR\n            if (true) return;\n            console.log(\"Registering action handlers with parent\");\n            if (onButtonClick) {\n                // Create action handlers with proper method references\n                const actionHandlers = {\n                    randomDot: handleRandomDot,\n                    setRandom: handleSetRandom,\n                    calibrate: handleSetCalibrate,\n                    clearAll: clearCanvas\n                };\n                // Store in parent component context\n                onButtonClick('registerActions', actionHandlers);\n                // Also make them globally available for direct access\n                window.whiteScreenActions = actionHandlers;\n            }\n            // Cleanup on unmount\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    if (false) {}\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        onButtonClick\n    ]);\n    // Add this import at the top of WhiteScreenMain.js\n    // Replace the handleSetCalibrate function with this improved version\n    const handleSetCalibrate = async ()=>{\n        try {\n            // STEP 1: HIDE THE TOP BAR IMMEDIATELY (before anything else happens)\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if (false) {}\n            // Add a small delay to ensure UI updates\n            await new Promise((resolve)=>setTimeout(resolve, 50));\n            // STEP 2: Initial setup\n            setIsCapturing(true);\n            setProcessStatus('Starting calibration sequence...');\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: 'Starting calibration sequence',\n                    isCapturing: true\n                });\n            }\n            // Create a status indicator\n            const statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = `\n        position: fixed;\n        top: 10px;\n        right: 10px;\n        background-color: rgba(0, 102, 204, 0.9);\n        color: white;\n        font-size: 14px;\n        font-weight: bold;\n        padding: 8px 12px;\n        border-radius: 6px;\n        z-index: 9999;\n        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\n      `;\n            statusIndicator.textContent = 'Calibrate Set Active: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // STEP 3: Setup canvas and generate points\n            const canvas = activeCanvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas reference is null\");\n            }\n            // Ensure canvas dimensions are set\n            const parent = canvas.parentElement;\n            if (parent) {\n                canvas.width = parent.clientWidth;\n                canvas.height = parent.clientHeight;\n            }\n            console.log(\"Canvas dimensions for calibration:\", {\n                width: canvas.width,\n                height: canvas.height\n            });\n            // Generate calibration points using the imported function\n            const points = generateCalibrationPoints(canvas.width, canvas.height);\n            setCalibrationPoints(points);\n            console.log(`Generated ${points.length} calibration points`);\n            if (!points || points.length === 0) {\n                throw new Error('Failed to generate calibration points');\n            }\n            setRemainingCaptures(points.length);\n            // STEP 4: Process each calibration point in sequence\n            for(let i = 0; i < points.length; i++){\n                // Update state\n                setCurrentCalibrationIndex(i);\n                setRemainingCaptures(points.length - i);\n                // Update status\n                const statusText = `Calibration ${i + 1}/${points.length}`;\n                setProcessStatus(statusText);\n                statusIndicator.textContent = `Calibrate Set Active: Processing point ${i + 1}/${points.length}`;\n                if (onStatusUpdate) {\n                    onStatusUpdate(statusText);\n                }\n                // STEP 5: Draw the red dot FIRST, before any countdown\n                const point = points[i];\n                drawDot(point.x, point.y);\n                // Wait a moment to ensure dot is visible\n                await new Promise((resolve)=>setTimeout(resolve, 50));\n                // STEP 6: Get canvas position for absolute positioning\n                const canvasRect = canvas.getBoundingClientRect();\n                // Create countdown element above the dot\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'calibrate-countdown';\n                // Position it above the dot\n                const absoluteX = canvasRect.left + point.x;\n                const absoluteY = canvasRect.top + point.y;\n                countdownElement.style.cssText = `\n          position: fixed;\n          left: ${absoluteX}px;\n          top: ${absoluteY - 60}px;\n          transform: translateX(-50%);\n          color: red;\n          font-size: 36px;\n          font-weight: bold;\n          text-shadow: 0 0 10px white, 0 0 20px white;\n          z-index: 9999;\n          background-color: rgba(255, 255, 255, 0.8);\n          border: 2px solid red;\n          border-radius: 50%;\n          width: 50px;\n          height: 50px;\n          display: flex;\n          justify-content: center;\n          align-items: center;\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n        `;\n                document.body.appendChild(countdownElement);\n                // STEP 7: Run 3-2-1 countdown (the dot stays visible during this time)\n                for(let count = 3; count > 0; count--){\n                    countdownElement.textContent = count;\n                    statusIndicator.textContent = `Calibrate Set Active: countdown ${count} (${i + 1}/${points.length})`;\n                    // Wait for next countdown step\n                    await new Promise((resolve)=>setTimeout(resolve, 800));\n                }\n                // STEP 8: Show capturing indicator\n                countdownElement.textContent = \"âœ“\";\n                statusIndicator.textContent = `Capturing point ${i + 1}/${points.length}`;\n                // STEP 9: Remove countdown element but KEEP the dot visible\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                }, 300);\n                // STEP 10: Capture images (the dot is still visible)\n                await captureImage();\n                // STEP 11: Wait for preview to complete before moving to next point\n                // During this time, the dot remains visible\n                await new Promise((resolve)=>setTimeout(resolve, 2300));\n            }\n            // STEP 12: Calibration complete\n            statusIndicator.textContent = 'Calibration completed';\n            setProcessStatus('Calibration completed');\n            if (onStatusUpdate) {\n                onStatusUpdate('Calibration completed successfully');\n            }\n            setRemainingCaptures(0);\n            // Remove status indicator after a delay\n            setTimeout(()=>{\n                if (statusIndicator.parentNode) {\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }\n            }, 3000);\n        } catch (error) {\n            console.error('Calibration error:', error);\n            setProcessStatus(`Error: ${error.message}`);\n            if (onStatusUpdate) {\n                onStatusUpdate(`Calibration error: ${error.message}`);\n            }\n        } finally{\n            setIsCapturing(false);\n            // Show TopBar again\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if (false) {}\n        }\n    };\n    // Fix for startCountdown function to hide TopBar immediately\n    // const startCountdown = (count, onComplete) => {\n    //   console.log(\"Starting countdown from:\", count);\n    //   // Hide TopBar immediately when countdown starts\n    //   if (typeof toggleTopBar === 'function') {\n    //     toggleTopBar(false);\n    //   } else if (typeof window !== 'undefined' && window.toggleTopBar) {\n    //     window.toggleTopBar(false);\n    //   }\n    //   // Set countdown value in state\n    //   setCountdownValue(count);\n    //   setForceShowCountdown(true);\n    //   setIsCapturing(true);\n    //   // Update status for parent component\n    //   if (onStatusUpdate) {\n    //     onStatusUpdate({\n    //       countdownValue: count,\n    //       processStatus: `Countdown: ${count}`,\n    //       isCapturing: true\n    //     });\n    //   }\n    //   const timer = setTimeout(() => {\n    //     if (count > 1) {\n    //       startCountdown(count - 1, onComplete);\n    //     } else {\n    //       // Final countdown step\n    //       console.log(\"Countdown finished, clearing countdown display\");\n    //       setCountdownValue(null);\n    //       setForceShowCountdown(false);\n    //       // Update status for parent component\n    //       if (onStatusUpdate) {\n    //         onStatusUpdate({\n    //           countdownValue: null,\n    //           processStatus: 'Capturing...',\n    //           isCapturing: true\n    //         });\n    //       }\n    //       // Execute completion callback immediately\n    //       if (onComplete) {\n    //         console.log(\"Executing completion callback\");\n    //         onComplete();\n    //       }\n    //     }\n    //   }, 800);\n    //   return () => clearTimeout(timer);\n    // };\n    // Move to next calibration point\n    const moveToNextCalibrationPoint = ()=>{\n        const nextIndex = currentCalibrationIndex + 1;\n        // Check if we're done\n        if (nextIndex >= calibrationPoints.length) {\n            setIsCapturing(false);\n            setRemainingCaptures(0);\n            setProcessStatus('Calibration completed');\n            // Clear status after a delay\n            setTimeout(()=>{\n                setProcessStatus('');\n            }, 2000);\n            return;\n        }\n        // Update state and progress\n        setCurrentCalibrationIndex(nextIndex);\n        setRemainingCaptures(calibrationPoints.length - nextIndex);\n        setProcessStatus(`Calibration ${nextIndex + 1}/${calibrationPoints.length}`);\n        // Draw next point\n        const nextPoint = calibrationPoints[nextIndex];\n        drawDot(nextPoint.x, nextPoint.y);\n        // Start countdown for this point\n        startCountdown(3, ()=>{\n            captureImage();\n            setTimeout(()=>moveToNextCalibrationPoint(), 1000);\n        });\n    };\n    // Map button clicks to appropriate handlers\n    const handleScreenAction = (actionType)=>{\n        console.log(`Screen action received: ${actionType}`);\n        switch(actionType){\n            case 'randomDot':\n                handleRandomDot();\n                break;\n            case 'setRandom':\n                handleSetRandom();\n                break;\n            case 'calibrate':\n                handleSetCalibrate();\n                break;\n            case 'clearAll':\n                clearCanvas();\n                break;\n            default:\n                // Forward to parent if not handled here\n                if (onButtonClick) {\n                    onButtonClick(actionType);\n                }\n        }\n    };\n    // // Pass actions up to parent component\n    // useEffect(() => {\n    //   // Skip during SSR\n    //   if (typeof window === 'undefined') return;\n    //   console.log(\"Registering action handlers with parent\");\n    //   if (onButtonClick) {\n    //     // Create action handlers\n    //     const actionHandlers = {\n    //       randomDot: handleRandomDot,\n    //       setRandom: handleSetRandom,\n    //       calibrate: handleSetCalibrate,\n    //       clearAll: clearCanvas\n    //     };\n    //     // Store in parent component context\n    //     onButtonClick('registerActions', actionHandlers);\n    //   }\n    // }, [onButtonClick]);\n    // Update parent with status changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            if (onStatusUpdate && processStatus) {\n                onStatusUpdate(processStatus);\n            }\n        }\n    }[\"WhiteScreenMain.useEffect\"], [\n        processStatus,\n        onStatusUpdate\n    ]);\n    // Log when component mounts to verify it's being rendered\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"WhiteScreenMain.useEffect\": ()=>{\n            console.log(\"WhiteScreenMain component mounted\");\n            console.log(\"Props:\", {\n                hasStatusUpdate: !!onStatusUpdate,\n                hasCameraAccess: !!triggerCameraAccess,\n                hasButtonClick: !!onButtonClick,\n                hasCanvasRef: !!canvasRef,\n                hasToggleTopBar: !!toggleTopBar\n            });\n            return ({\n                \"WhiteScreenMain.useEffect\": ()=>{\n                    console.log(\"WhiteScreenMain component unmounting\");\n                }\n            })[\"WhiteScreenMain.useEffect\"];\n        }\n    }[\"WhiteScreenMain.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"white-screen-container\",\n        style: {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            zIndex: 50,\n            backgroundColor: 'rgba(255, 255, 255, 0.5)' // Slight transparency to see if it's rendered\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"white-screen-canvas-container\",\n            style: {\n                position: 'absolute',\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%',\n                backgroundColor: 'white',\n                overflow: 'hidden',\n                border: '1px solid #ccc',\n                zIndex: 51\n            },\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                    ref: canvasRef ? canvasRef : internalCanvasRef,\n                    className: \"white-screen-canvas\",\n                    style: {\n                        width: '100%',\n                        height: '100%',\n                        display: 'block'\n                    }\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 1337,\n                    columnNumber: 9\n                }, undefined),\n                (countdownValue !== null || forceShowCountdown) && currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dot-countdown\",\n                    style: {\n                        position: 'absolute',\n                        left: `${currentDot.x - 30}px`,\n                        top: `${currentDot.y - 70}px`,\n                        color: 'red',\n                        fontSize: '48px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 10px white, 0 0 20px white',\n                        zIndex: 999,\n                        backgroundColor: 'rgba(255, 255, 255, 0.8)',\n                        padding: '10px 20px',\n                        borderRadius: '50%',\n                        boxShadow: '0 0 10px rgba(0, 0, 0, 0.3)',\n                        width: '60px',\n                        height: '60px',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        border: '2px solid red' // Border to make it stand out\n                    },\n                    children: countdownValue || 3\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 1349,\n                    columnNumber: 11\n                }, undefined),\n                (countdownValue !== null || forceShowCountdown) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"center-countdown-backup\",\n                    style: {\n                        position: 'fixed',\n                        top: '50%',\n                        left: '50%',\n                        transform: 'translate(-50%, -50%)',\n                        color: 'white',\n                        fontSize: '120px',\n                        fontWeight: 'bold',\n                        textShadow: '0 0 20px black',\n                        zIndex: 1000,\n                        backgroundColor: 'rgba(255, 0, 0, 0.7)',\n                        width: '200px',\n                        height: '200px',\n                        borderRadius: '50%',\n                        display: 'flex',\n                        justifyContent: 'center',\n                        alignItems: 'center',\n                        boxShadow: '0 0 30px rgba(0, 0, 0, 0.5)'\n                    },\n                    children: countdownValue || 3\n                }, void 0, false, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 1378,\n                    columnNumber: 11\n                }, undefined),\n                currentDot && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"dot-indicator\",\n                    style: {\n                        position: 'absolute',\n                        top: '10px',\n                        right: '10px',\n                        backgroundColor: 'rgba(0, 255, 0, 0.7)',\n                        color: 'black',\n                        padding: '5px 10px',\n                        borderRadius: '4px',\n                        fontSize: '12px',\n                        zIndex: 52\n                    },\n                    children: [\n                        \"Dot at x:\",\n                        currentDot.x,\n                        \", y:\",\n                        currentDot.y\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 1406,\n                    columnNumber: 11\n                }, undefined),\n                (processStatus || remainingCaptures > 0) && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"status-overlay\",\n                    style: {\n                        position: 'absolute',\n                        bottom: '10px',\n                        left: '10px',\n                        backgroundColor: 'rgba(0, 0, 0, 0.8)',\n                        color: 'white',\n                        padding: '10px 15px',\n                        borderRadius: '4px',\n                        fontSize: '16px',\n                        fontWeight: 'bold',\n                        boxShadow: '0 4px 8px rgba(0,0,0,0.3)',\n                        zIndex: 53\n                    },\n                    children: [\n                        processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: processStatus\n                        }, void 0, false, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                            lineNumber: 1442,\n                            columnNumber: 31\n                        }, undefined),\n                        remainingCaptures > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                color: '#ffcc00'\n                            },\n                            children: [\n                                \"Remaining: \",\n                                remainingCaptures\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                            lineNumber: 1444,\n                            columnNumber: 15\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 1426,\n                    columnNumber: 11\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"canvas-indicator\",\n                    style: {\n                        position: 'absolute',\n                        top: '10px',\n                        left: '10px',\n                        backgroundColor: canvasVisible ? 'rgba(0, 255, 0, 0.7)' : 'rgba(255, 0, 0, 0.7)',\n                        color: 'black',\n                        padding: '5px 10px',\n                        borderRadius: '4px',\n                        fontSize: '12px',\n                        zIndex: 52\n                    },\n                    children: [\n                        \"Canvas: \",\n                        canvasVisible ? 'Visible' : 'Hidden'\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n                    lineNumber: 1452,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n            lineNumber: 1322,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/porchportal2/Desktop/\\uD83D\\uDD25everything/Main_Web_EyeTracking/main-web/frontend/pages/collected-dataset/components-gui/WhiteScreenMain.js\",\n        lineNumber: 1312,\n        columnNumber: 5\n    }, undefined);\n};\n// Export a dynamic version with SSR disabled to avoid useLayoutEffect warnings\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(()=>Promise.resolve(WhiteScreenMain), {\n    ssr: false\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0L2NvbXBvbmVudHMtZ3VpL1doaXRlU2NyZWVuTWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsb0NBQW9DOztBQUN1QjtBQUN4QjtBQUVuQyxnREFBZ0Q7QUFDaEQsTUFBTUssa0JBQWtCLENBQUMsRUFDdkJDLGNBQWMsRUFDZEMsbUJBQW1CLEVBQ25CQyxhQUFhLEVBQ2JDLFlBQVksSUFBSSxFQUNoQkMsWUFBWSxFQUNiO0lBQ0MsNkNBQTZDO0lBQzdDLE1BQU1DLG9CQUFvQlIsNkNBQU1BLENBQUM7SUFDakMsTUFBTVMsa0JBQWtCSCxhQUFhRTtJQUVyQyxvQkFBb0I7SUFDcEIsTUFBTSxDQUFDRSxZQUFZQyxjQUFjLEdBQUdiLCtDQUFRQSxDQUFDO0lBQzdDLE1BQU0sQ0FBQ2MsYUFBYUMsZUFBZSxHQUFHZiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNnQixnQkFBZ0JDLGtCQUFrQixHQUFHakIsK0NBQVFBLENBQUM7SUFDckQsTUFBTSxDQUFDa0IsbUJBQW1CQyxxQkFBcUIsR0FBR25CLCtDQUFRQSxDQUFDO0lBQzNELE1BQU0sQ0FBQ29CLGVBQWVDLGlCQUFpQixHQUFHckIsK0NBQVFBLENBQUM7SUFFbkQsd0JBQXdCO0lBQ3hCLE1BQU0sQ0FBQ3NCLGdCQUFnQkMsa0JBQWtCLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUNyRCxNQUFNLENBQUN3QixjQUFjLEdBQUd4QiwrQ0FBUUEsQ0FBQywwQkFBMEIsb0JBQW9CO0lBRS9FLHNCQUFzQjtJQUN0QixNQUFNLENBQUN5QixhQUFhQyxlQUFlLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUMyQixjQUFjQyxnQkFBZ0IsR0FBRzVCLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQzZCLG1CQUFtQkMscUJBQXFCLEdBQUc5QiwrQ0FBUUEsQ0FBQyxFQUFFO0lBQzdELE1BQU0sQ0FBQytCLHlCQUF5QkMsMkJB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d0JBQ0w2RCxPQUFPO3dCQUNQYixpQkFBaUI7d0JBQ2pCaEosT0FBTzt3QkFDUEgsU0FBUzt3QkFDVDJKLGNBQWM7d0JBQ2RILFVBQVU7d0JBQ1ZOLFFBQVE7b0JBQ1Y7O3dCQUNEO3dCQUNXclAsV0FBVytDLENBQUM7d0JBQUM7d0JBQUsvQyxXQUFXZ0QsQ0FBQzs7Ozs7OztnQkFLMUN4QyxDQUFBQSxpQkFBaUJGLG9CQUFvQixvQkFDckMsOERBQUM4TztvQkFDQ3BMLFdBQVU7b0JBQ1ZDLE9BQU87d0JBQ0w2RixVQUFVO3dCQUNWc0csUUFBUTt3QkFDUnJHLE1BQU07d0JBQ051RixpQkFBaUI7d0JBQ2pCaEosT0FBTzt3QkFDUEgsU0FBUzt3QkFDVDJKLGNBQWM7d0JBQ2RILFVBQVU7d0JBQ1ZDLFlBQVk7d0JBQ1pHLFdBQVc7d0JBQ1hWLFFBQVE7b0JBQ1Y7O3dCQUVDN08sK0JBQWlCLDhEQUFDNE87c0NBQUs1Tzs7Ozs7O3dCQUN2QkYsb0JBQW9CLG1CQUNuQiw4REFBQzhPOzRCQUFJbkwsT0FBTztnQ0FBRXFDLE9BQU87NEJBQVU7O2dDQUFHO2dDQUNwQmhHOzs7Ozs7Ozs7Ozs7OzhCQU9wQiw4REFBQzhPO29CQUNDcEwsV0FBVTtvQkFDVkMsT0FBTzt3QkFDTDZGLFVBQVU7d0JBQ1Z3QyxLQUFLO3dCQUNMdkMsTUFBTTt3QkFDTnVGLGlCQUFpQmpPLGdCQUFnQix5QkFBeUI7d0JBQzFEaUYsT0FBTzt3QkFDUEgsU0FBUzt3QkFDVDJKLGNBQWM7d0JBQ2RILFVBQVU7d0JBQ1ZOLFFBQVE7b0JBQ1Y7O3dCQUNEO3dCQUNVaE8sZ0JBQWdCLFlBQVk7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCL0M7QUFFQSwrRUFBK0U7QUFDL0UsaUVBQWU5QixtREFBT0EsQ0FBQyxJQUFNMEssUUFBUUMsT0FBTyxDQUFDMUssa0JBQWtCO0lBQUU2USxLQUFLO0FBQU0sRUFBRSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvcG9yY2hwb3J0YWwyL0Rlc2t0b3Av8J+UpWV2ZXJ5dGhpbmcvTWFpbl9XZWJfRXllVHJhY2tpbmcvbWFpbi13ZWIvZnJvbnRlbmQvcGFnZXMvY29sbGVjdGVkLWRhdGFzZXQvY29tcG9uZW50cy1ndWkvV2hpdGVTY3JlZW5NYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbXBvbmVudHMtZ3VpL1doaXRlU2NyZWVuTWFpbi5qc1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkeW5hbWljIGZyb20gJ25leHQvZHluYW1pYyc7XG5cbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgdGhlIGNvbXBvbmVudFxuY29uc3QgV2hpdGVTY3JlZW5NYWluID0gKHsgXG4gIG9uU3RhdHVzVXBkYXRlLCBcbiAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgb25CdXR0b25DbGljayxcbiAgY2FudmFzUmVmID0gbnVsbCxcbiAgdG9nZ2xlVG9wQmFyXG59KSA9PiB7XG4gIC8vIFVzZSBwcm92aWRlZCBjYW52YXNSZWYgb3IgY3JlYXRlIGEgbmV3IG9uZVxuICBjb25zdCBpbnRlcm5hbENhbnZhc1JlZiA9IHVzZVJlZihudWxsKTtcbiAgY29uc3QgYWN0aXZlQ2FudmFzUmVmID0gY2FudmFzUmVmIHx8IGludGVybmFsQ2FudmFzUmVmO1xuICBcbiAgLy8gQ3VycmVudCBkb3Qgc3RhdGVcbiAgY29uc3QgW2N1cnJlbnREb3QsIHNldEN1cnJlbnREb3RdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtpc0NhcHR1cmluZywgc2V0SXNDYXB0dXJpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY291bnRkb3duVmFsdWUsIHNldENvdW50ZG93blZhbHVlXSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcmVtYWluaW5nQ2FwdHVyZXMsIHNldFJlbWFpbmluZ0NhcHR1cmVzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIFxuICAvLyBUcmFjayBjYXB0dXJlIHNlc3Npb25cbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2NhcHR1cmVGb2xkZXJdID0gdXNlU3RhdGUoJ2V5ZV90cmFja2luZ19jYXB0dXJlcycpOyAvLyBGaXhlZCBmb2xkZXIgbmFtZVxuICBcbiAgLy8gQ29uZmlndXJhdGlvbiBzdGF0ZVxuICBjb25zdCBbcmFuZG9tVGltZXMsIHNldFJhbmRvbVRpbWVzXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbZGVsYXlTZWNvbmRzLCBzZXREZWxheVNlY29uZHNdID0gdXNlU3RhdGUoMyk7XG4gIGNvbnN0IFtjYWxpYnJhdGlvblBvaW50cywgc2V0Q2FsaWJyYXRpb25Qb2ludHNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbY3VycmVudENhbGlicmF0aW9uSW5kZXgsIHNldEN1cnJlbnRDYWxpYnJhdGlvbkluZGV4XSA9IHVzZVN0YXRlKDApO1xuICBcbiAgLy8gRGVidWcgc3RhdGUgdG8gbWFrZSB2aXNpYmlsaXR5IGVhc2llciB0byB0cmFja1xuICBjb25zdCBbY2FudmFzVmlzaWJsZSwgc2V0Q2FudmFzVmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtmb3JjZVNob3dDb3VudGRvd24sIHNldEZvcmNlU2hvd0NvdW50ZG93bl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBTZXQgdXAgY2FudmFzIHdoZW4gY29tcG9uZW50IG1vdW50c1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNraXAgaWYgdGhpcyBydW5zIGR1cmluZyBTU1JcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjYW52YXMgPSBhY3RpdmVDYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWYgaXMgbnVsbCBpbiBzZXR1cCBlZmZlY3RcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIHNldHVwIGVmZmVjdCBydW5uaW5nXCIsIHsgXG4gICAgICBoYXNDYW52YXM6ICEhY2FudmFzLCBcbiAgICAgIGNhbnZhc0hlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgIGNhbnZhc1dpZHRoOiBjYW52YXMud2lkdGhcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGdW5jdGlvbiB0byB1cGRhdGUgY2FudmFzIGRpbWVuc2lvbnNcbiAgICBjb25zdCB1cGRhdGVEaW1lbnNpb25zID0gKCkgPT4ge1xuICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHBhcmVudCBpcyBudWxsXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgcGFyZW50IGNvbnRhaW5lciBkaW1lbnNpb25zXG4gICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IHBhcmVudEhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVzaXppbmcgY2FudmFzIHRvOlwiLCB7IHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQgfSk7XG4gICAgICBcbiAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudFdpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudEhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBhbmQgc2V0IGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gUmVkcmF3IGN1cnJlbnQgZG90IGlmIGV4aXN0c1xuICAgICAgaWYgKGN1cnJlbnREb3QpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZWRyYXdpbmcgZG90IGFmdGVyIHJlc2l6ZTpcIiwgY3VycmVudERvdCk7XG4gICAgICAgIGRyYXdEb3QoY3VycmVudERvdC54LCBjdXJyZW50RG90LnksICdyZWQnLCA4KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0Q2FudmFzVmlzaWJsZSh0cnVlKTtcbiAgICB9O1xuICBcbiAgLy8gQWRkIHRoaXMgaGVscGVyIGZ1bmN0aW9uIHRvIHNob3cgYSBwcmV2aWV3IG9mIHRoZSBjYXB0dXJlZCBpbWFnZXNcbiAgY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgZG90UG9zaXRpb24pID0+IHtcbiAgICBpZiAoIXNjcmVlbkltYWdlICYmICF3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gaW1hZ2VzIGF2YWlsYWJsZSB0byBwcmV2aWV3XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlldyBjb250YWluZXJzIGZpcnN0IChpbiBjYXNlIG9mIG92ZXJsYXBwaW5nKVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBleGlzdGluZ1ByZXZpZXdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcHR1cmUtcHJldmlldy1jb250YWluZXInKTtcbiAgICAgIGV4aXN0aW5nUHJldmlld3MuZm9yRWFjaChwcmV2aWV3ID0+IHtcbiAgICAgICAgaWYgKHByZXZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVtb3ZpbmcgZXhpc3RpbmcgcHJldmlldyBjb250YWluZXJcIik7XG4gICAgICAgICAgcHJldmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChjbGVhbnVwRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjbGVhbmluZyB1cCBleGlzdGluZyBwcmV2aWV3czpcIiwgY2xlYW51cEVycm9yKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgbmV3IHByZXZpZXcgY29udGFpbmVyIHdpdGggei1pbmRleCBoaWdoZXIgdGhhbiBldmVyeXRoaW5nIGVsc2VcbiAgICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICBsZWZ0OiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBnYXA6IDIwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgICAgcGFkZGluZzogMjBweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICBgO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiUHJldmlldyBjb250YWluZXIgY3JlYXRlZFwiKTtcbiAgICBcbiAgICAvLyBBZGQgZGVidWcgaW5mbyBkaXZcbiAgICBjb25zdCBkZWJ1Z0luZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkZWJ1Z0luZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogLTMwcHg7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgYDtcbiAgICBkZWJ1Z0luZm8udGV4dENvbnRlbnQgPSBgU2NyZWVuOiAke3NjcmVlbkltYWdlID8gJ1lFUycgOiAnTk8nfSwgV2ViY2FtOiAke3dlYmNhbUltYWdlID8gJ1lFUycgOiAnTk8nfWA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChkZWJ1Z0luZm8pO1xuICAgIFxuICAgIC8vIEZ1bmN0aW9uIHRvIGFkZCBhbiBpbWFnZSB0byB0aGUgcHJldmlld1xuICAgIGNvbnN0IGFkZEltYWdlUHJldmlldyA9IChpbWFnZSwgbGFiZWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBZGRpbmcgJHtsYWJlbH0gcHJldmlldywgaW1hZ2UgZGF0YSBsZW5ndGg6ICR7aW1hZ2UgPyBpbWFnZS5sZW5ndGggOiAnTi9BJ31gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZTtcbiAgICAgICAgaW1nLmFsdCA9IGxhYmVsO1xuICAgICAgICBpbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgICAgICBgO1xuICAgICAgICBcbiAgICAgICAgLy8gRXZlbnQgbGlzdGVuZXJzIGZvciBpbWFnZSBsb2FkaW5nXG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBjb25zb2xlLmxvZyhgJHtsYWJlbH0gaW1hZ2UgbG9hZGVkIHN1Y2Nlc3NmdWxseWApO1xuICAgICAgICBpbWcub25lcnJvciA9IChlKSA9PiBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nICR7bGFiZWx9IGltYWdlOmAsIGUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgbGFiZWxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGxhYmVsRWxlbWVudC50ZXh0Q29udGVudCA9IGxhYmVsO1xuICAgICAgICBsYWJlbEVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIGA7XG4gICAgICAgIFxuICAgICAgICBwcmV2aWV3LmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIHByZXZpZXcuYXBwZW5kQ2hpbGQobGFiZWxFbGVtZW50KTtcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgY29uc29sZS5sb2coYCR7bGFiZWx9IHByZXZpZXcgZWxlbWVudCBhZGRlZCB0byBjb250YWluZXJgKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBhZGRpbmcgJHtsYWJlbH0gcHJldmlldzpgLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIC8vIEFkZCBib3RoIGltYWdlcyB0byBwcmV2aWV3IGlmIGF2YWlsYWJsZVxuICAgIGlmIChzY3JlZW5JbWFnZSkge1xuICAgICAgYWRkSW1hZ2VQcmV2aWV3KHNjcmVlbkltYWdlLCAnU2NyZWVuIENhcHR1cmUnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgICBhZGRJbWFnZVByZXZpZXcod2ViY2FtSW1hZ2UsICdXZWJjYW0gQ2FwdHVyZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgZG90IHBvc2l0aW9uIGluZm8gaWYgYXZhaWxhYmxlXG4gICAgaWYgKGRvdFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHBvc2l0aW9uSW5mby50ZXh0Q29udGVudCA9IGBEb3QgcG9zaXRpb246IHg9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLngpfSwgeT0ke01hdGgucm91bmQoZG90UG9zaXRpb24ueSl9YDtcbiAgICAgIHBvc2l0aW9uSW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogI2ZmY2MwMDtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTUwcHg7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3NpdGlvbkluZm8pO1xuICAgICAgY29uc29sZS5sb2coXCJEb3QgcG9zaXRpb24gaW5mbyBhZGRlZFwiKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIGNvdW50ZG93biB0aW1lclxuICAgIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIGJvdHRvbTogLTI1cHg7XG4gICAgICByaWdodDogMjBweDtcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gICAgXG4gICAgLy8gQWRkIHRvIGRvY3VtZW50IGJvZHlcbiAgICB0cnkge1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiUHJldmlldyBjb250YWluZXIgYWRkZWQgdG8gRE9NXCIpO1xuICAgIH0gY2F0Y2ggKGFwcGVuZEVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgYWRkaW5nIHByZXZpZXcgY29udGFpbmVyIHRvIERPTTpcIiwgYXBwZW5kRXJyb3IpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDb3VudGRvd24gYW5kIHJlbW92ZSB0aGUgcHJldmlldyBhZnRlciAyIHNlY29uZHNcbiAgICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgLy8gRmFkZSBvdXRcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMC4zcyBlYXNlJztcbiAgICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAvLyBSZW1vdmUgYWZ0ZXIgZmFkZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlbW92aW5nIHByZXZpZXcgY29udGFpbmVyIGZyb20gRE9NXCIpO1xuICAgICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgICB9XG4gICAgfSwgMTAwKTtcbiAgICBcbiAgICAvLyBTYWZldHkgY2xlYW51cCBhZnRlciA1IHNlY29uZHMgaW4gY2FzZSBhbnl0aGluZyBnb2VzIHdyb25nXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2FmZXR5IGNsZWFudXAgb2YgcHJldmlldyBjb250YWluZXJcIik7XG4gICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9LCA1MDAwKTtcbiAgfTtcbiAgICBcbiAgICAvLyBJbml0aWFsIHNpemluZ1xuICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICBcbiAgICAvLyBMaXN0ZW4gZm9yIHdpbmRvdyByZXNpemVcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdXBkYXRlRGltZW5zaW9ucyk7XG4gICAgXG4gICAgLy8gQ2xlYW4gdXBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZURpbWVuc2lvbnMpO1xuICAgIH07XG4gIH0sIFthY3RpdmVDYW52YXNSZWYsIGN1cnJlbnREb3RdKTtcbiAgXG4gIC8vIEdlbmVyYXRlIGEgcmFuZG9tIHBvc2l0aW9uIG9uIHRoZSBjYW52YXNcbiAgY29uc3QgZ2V0UmFuZG9tUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gYWN0aXZlQ2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcmVmIGlzIG51bGwgaW4gZ2V0UmFuZG9tUG9zaXRpb25cIik7XG4gICAgICByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICAgIH1cbiAgICBcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aCB8fCA0MDA7ICAvLyBGYWxsYmFjayBpZiB3aWR0aCBpcyAwXG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCB8fCAzMDA7IC8vIEZhbGxiYWNrIGlmIGhlaWdodCBpcyAwXG4gICAgXG4gICAgY29uc29sZS5sb2coXCJDYW52YXMgZGltZW5zaW9ucyBmb3IgcmFuZG9tIHBvc2l0aW9uOlwiLCB7IHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgXG4gICAgLy8gRW5zdXJlIHdlJ3JlIG5vdCB0b28gY2xvc2UgdG8gdGhlIGVkZ2VzXG4gICAgY29uc3QgcGFkZGluZyA9IDQwOyAvLyBJbmNyZWFzZWQgcGFkZGluZ1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAod2lkdGggLSAyICogcGFkZGluZykpICsgcGFkZGluZyxcbiAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyICogcGFkZGluZykpICsgcGFkZGluZ1xuICAgIH07XG4gIH07XG4gIFxuICAvLyBEcmF3IGEgZG90IG9uIHRoZSBjYW52YXNcbiAgY29uc3QgZHJhd0RvdCA9ICh4LCB5LCBjb2xvciA9ICdyZWQnLCByYWRpdXMgPSAxMikgPT4geyAvLyBJbmNyZWFzZWQgcmFkaXVzXG4gICAgY29uc29sZS5sb2coXCJEcmF3aW5nIGRvdCBhdDpcIiwgeyB4LCB5LCBjb2xvciwgcmFkaXVzIH0pO1xuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZiBpcyBudWxsIGluIGRyYXdEb3RcIik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgXG4gICAgLy8gQ2xlYXIgY2FudmFzXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIERyYXcgZG90IHdpdGggZ2xvdyBlZmZlY3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA1LCAwLCBNYXRoLlBJICogMik7IC8vIEluY3JlYXNlZCBnbG93XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJzsgLy8gTW9yZSB2aXNpYmxlIGdsb3dcbiAgICBjdHgubGluZVdpZHRoID0gMzsgLy8gVGhpY2tlciBsaW5lXG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIFxuICAgIC8vIFN0b3JlIGN1cnJlbnQgZG90IHBvc2l0aW9uIC0gdXNpbmcgY2FsbGJhY2sgZm9ybSB0byBlbnN1cmUgaXQgdXBkYXRlc1xuICAgIHNldEN1cnJlbnREb3QocHJldiA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcIlVwZGF0aW5nIGN1cnJlbnREb3Qgc3RhdGUgZnJvbTpcIiwgcHJldiwgXCJ0bzpcIiwgeyB4LCB5IH0pO1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfTtcbiAgXG4gIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJDbGVhcmluZyBjYW52YXNcIik7XG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gYWN0aXZlQ2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcmVmIGlzIG51bGwgaW4gY2xlYXJDYW52YXNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICAgIHNldENvdW50ZG93blZhbHVlKG51bGwpO1xuICAgIHNldEZvcmNlU2hvd0NvdW50ZG93bihmYWxzZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FudmFzIGNsZWFyZWQnKTtcbiAgICBcbiAgICAvLyBDbGVhciB0aGUgbWVzc2FnZSBhZnRlciBhIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICB9LCAxNTAwKTtcbiAgfTtcbiAgXG4gIC8vIFN0YXJ0IGNvdW50ZG93biB0aW1lclxuICBjb25zdCBzdGFydENvdW50ZG93biA9IChjb3VudCwgb25Db21wbGV0ZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgY291bnRkb3duIGZyb206XCIsIGNvdW50KTtcbiAgICBcbiAgICAvLyBTZXQgY291bnRkb3duIHZhbHVlIGluIHN0YXRlXG4gICAgc2V0Q291bnRkb3duVmFsdWUoY291bnQpO1xuICAgIHNldEZvcmNlU2hvd0NvdW50ZG93bih0cnVlKTtcbiAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBwYXJlbnQgY29tcG9uZW50XG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY291bnQgPiAxKSB7XG4gICAgICAgIHN0YXJ0Q291bnRkb3duKGNvdW50IC0gMSwgb25Db21wbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGaW5hbCBjb3VudGRvd24gc3RlcFxuICAgICAgICBjb25zb2xlLmxvZyhcIkNvdW50ZG93biBmaW5pc2hlZCwgY2xlYXJpbmcgY291bnRkb3duIGRpc3BsYXlcIik7XG4gICAgICAgIHNldENvdW50ZG93blZhbHVlKG51bGwpO1xuICAgICAgICBzZXRGb3JjZVNob3dDb3VudGRvd24oZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgcGFyZW50IGNvbXBvbmVudFxuICAgICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJpbmcuLi4nLFxuICAgICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRXhlY3V0ZSBjb21wbGV0aW9uIGNhbGxiYWNrIGltbWVkaWF0ZWx5XG4gICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJFeGVjdXRpbmcgY29tcGxldGlvbiBjYWxsYmFja1wiKTtcbiAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCA4MDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xuICB9O1xuICBcbiAgLy8gU2F2ZSBhbiBpbWFnZSB0byB0aGUgc2VydmVyXG4gIGNvbnN0IHNhdmVJbWFnZVRvU2VydmVyID0gYXN5bmMgKGltYWdlRGF0YSwgZmlsZW5hbWUsIHR5cGUpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYEF0dGVtcHRpbmcgdG8gc2F2ZSAke3R5cGV9IGltYWdlOiAke2ZpbGVuYW1lfWApO1xuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgZmlsZW5hbWUsXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBmb2xkZXI6IGNhcHR1cmVGb2xkZXJcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIHJlc3BvbmRlZCB3aXRoICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgJHt0eXBlfSBpbWFnZTpgLCByZXN1bHQpO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYSBuZXcgY2FwdHVyZSBudW1iZXIsIHVwZGF0ZSBvdXIgY291bnRlclxuICAgICAgaWYgKHJlc3VsdC5jYXB0dXJlTnVtYmVyKSB7XG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyKHJlc3VsdC5jYXB0dXJlTnVtYmVyICsgMSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHNhdmluZyAke3R5cGV9IGltYWdlOmAsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgLy8gTW9kaWZpZWQgY2FwdHVyZUltYWdlIGZ1bmN0aW9uIGluIFdoaXRlU2NyZWVuTWFpbi5qc1xuXG4vLyBNb2RpZmllZCBjYXB0dXJlSW1hZ2UgZnVuY3Rpb24gZm9yIFdoaXRlU2NyZWVuTWFpbi5qc1xuXG4vLyBGaXhlZCBjYXB0dXJlSW1hZ2UgZnVuY3Rpb24gZm9yIFdoaXRlU2NyZWVuTWFpbi5qc1xuY29uc3QgY2FwdHVyZUltYWdlID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiQ2FwdHVyaW5nIGltYWdlcy4uLlwiKTtcbiAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhdGUgZmlsZW5hbWVzIHdpdGggY291bnRlclxuICAgICAgY29uc3Qgc2NyZWVuRmlsZW5hbWUgPSBgc2NyZWVuXyR7U3RyaW5nKGNhcHR1cmVDb3VudGVyKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xuICAgICAgY29uc3Qgd2ViY2FtRmlsZW5hbWUgPSBgd2ViY2FtXyR7U3RyaW5nKGNhcHR1cmVDb3VudGVyKS5wYWRTdGFydCgzLCAnMCcpfS5qcGdgO1xuICAgICAgY29uc3QgcGFyYW1ldGVyRmlsZW5hbWUgPSBgcGFyYW1ldGVyXyR7U3RyaW5nKGNhcHR1cmVDb3VudGVyKS5wYWRTdGFydCgzLCAnMCcpfS5jc3ZgO1xuICAgICAgXG4gICAgICAvLyBDYXB0dXJlIHNjcmVlbiBpbWFnZSAoY2FudmFzIHdpdGggZG90KVxuICAgICAgY29uc3QgY2FudmFzID0gYWN0aXZlQ2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBsZXQgc2NyZWVuSW1hZ2UgPSBudWxsO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkNhcHR1cmluZyBzY3JlZW4gZnJvbSBjYW52YXNcIik7XG4gICAgICAgIHNjcmVlbkltYWdlID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKHNjcmVlbkltYWdlLCBzY3JlZW5GaWxlbmFtZSwgJ3NjcmVlbicpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgc2NyZWVuIGltYWdlOiAke3NjcmVlbkZpbGVuYW1lfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbm5vdCBjYXB0dXJlIHNjcmVlbiAtIGNhbnZhcyByZWYgaXMgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSB3ZWJjYW0gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gICAgICBsZXQgd2ViY2FtSW1hZ2UgPSBudWxsO1xuICAgICAgaWYgKHdpbmRvdy52aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDYXB0dXJpbmcgZnJvbSB3ZWJjYW1cIik7XG4gICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGVtcENhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gd2luZG93LnZpZGVvRWxlbWVudC52aWRlb1dpZHRoO1xuICAgICAgICB0ZW1wQ2FudmFzLmhlaWdodCA9IHdpbmRvdy52aWRlb0VsZW1lbnQudmlkZW9IZWlnaHQ7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2Uod2luZG93LnZpZGVvRWxlbWVudCwgMCwgMCwgdGVtcENhbnZhcy53aWR0aCwgdGVtcENhbnZhcy5oZWlnaHQpO1xuICAgICAgICB3ZWJjYW1JbWFnZSA9IHRlbXBDYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKHdlYmNhbUltYWdlLCB3ZWJjYW1GaWxlbmFtZSwgJ3dlYmNhbScpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgd2ViY2FtIGltYWdlOiAke3dlYmNhbUZpbGVuYW1lfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IHRvIHNpbGVudGx5IGNhcHR1cmUgZnJvbSB3ZWJjYW1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgc3RyZWFtIGZvciBqdXN0IHRoaXMgY2FwdHVyZVxuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHsgXG4gICAgICAgICAgICB2aWRlbzogdHJ1ZSwgXG4gICAgICAgICAgICBhdWRpbzogZmFsc2UgXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgaGlkZGVuIHZpZGVvIGVsZW1lbnQgdG8gcmVjZWl2ZSB0aGUgc3RyZWFtXG4gICAgICAgICAgY29uc3QgdGVtcFZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICB0ZW1wVmlkZW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICAgIHRlbXBWaWRlby5wbGF5c0lubGluZSA9IHRydWU7XG4gICAgICAgICAgdGVtcFZpZGVvLm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICB0ZW1wVmlkZW8uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgIHRlbXBWaWRlby5zdHlsZS5sZWZ0ID0gJy05OTk5cHgnOyAvLyBQb3NpdGlvbiBvZmYtc2NyZWVuXG4gICAgICAgICAgdGVtcFZpZGVvLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCB0aGUgc3RyZWFtIHRvIHRoZSB2aWRlbyBlbGVtZW50XG4gICAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXYWl0IGZvciB2aWRlbyB0byBpbml0aWFsaXplXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJWaWRlbyBsb2FkaW5nIHRpbWVkIG91dCwgY29udGludWluZyBhbnl3YXlcIik7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0ZW1wVmlkZW8ub25sb2FkZWRkYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTbWFsbCBkZWxheSB0byBlbnN1cmUgYSBjbGVhciBmcmFtZVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDYXB0dXJlIHRoZSBmcmFtZSB0byBhIGNhbnZhc1xuICAgICAgICAgIGNvbnN0IHRlbXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICB0ZW1wQ2FudmFzLndpZHRoID0gdGVtcFZpZGVvLnZpZGVvV2lkdGggfHwgNjQwO1xuICAgICAgICAgIHRlbXBDYW52YXMuaGVpZ2h0ID0gdGVtcFZpZGVvLnZpZGVvSGVpZ2h0IHx8IDQ4MDtcbiAgICAgICAgICBjb25zdCBjdHggPSB0ZW1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0ZW1wVmlkZW8sIDAsIDAsIHRlbXBDYW52YXMud2lkdGgsIHRlbXBDYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YVxuICAgICAgICAgIHdlYmNhbUltYWdlID0gdGVtcENhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJlZCB3ZWJjYW0gc2lsZW50bHk6ICR7d2ViY2FtRmlsZW5hbWV9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgYXdhaXQgc2F2ZUltYWdlVG9TZXJ2ZXIod2ViY2FtSW1hZ2UsIHdlYmNhbUZpbGVuYW1lLCAnd2ViY2FtJyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSU1QT1JUQU5UOiBDbGVhbiB1cCAtIHN0b3Agc3RyZWFtIGFuZCByZW1vdmUgdmlkZW8gZWxlbWVudFxuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHRyYWNrLnN0b3AoKSk7XG4gICAgICAgICAgdGVtcFZpZGVvLnNyY09iamVjdCA9IG51bGw7XG4gICAgICAgICAgaWYgKHRlbXBWaWRlby5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0ZW1wVmlkZW8ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wVmlkZW8pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAod2ViY2FtRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIldlYmNhbSBlbGVtZW50IG5vdCBhdmFpbGFibGUgYW5kIHNpbGVudCBjYXB0dXJlIGZhaWxlZDpcIiwgd2ViY2FtRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNhdmUgcGFyYW1ldGVycyB0byBDU1ZcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENyZWF0ZSBDU1YgY29udGVudCB3aXRoIHR3byBjb2x1bW5zOiBuYW1lIGFuZCB2YWx1ZVxuICAgICAgICBjb25zdCBjc3ZEYXRhID0gW1xuICAgICAgICAgIFwibmFtZSx2YWx1ZVwiLFxuICAgICAgICAgIGBkb3RfeCwke2N1cnJlbnREb3QgPyBjdXJyZW50RG90LnggOiAwfWAsXG4gICAgICAgICAgYGRvdF95LCR7Y3VycmVudERvdCA/IGN1cnJlbnREb3QueSA6IDB9YCxcbiAgICAgICAgICBgY2FudmFzX3dpZHRoLCR7Y2FudmFzID8gY2FudmFzLndpZHRoIDogMH1gLFxuICAgICAgICAgIGBjYW52YXNfaGVpZ2h0LCR7Y2FudmFzID8gY2FudmFzLmhlaWdodCA6IDB9YCxcbiAgICAgICAgICBgd2luZG93X3dpZHRoLCR7d2luZG93LmlubmVyV2lkdGh9YCxcbiAgICAgICAgICBgd2luZG93X2hlaWdodCwke3dpbmRvdy5pbm5lckhlaWdodH1gLFxuICAgICAgICAgIGB0aW1lc3RhbXAsJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YFxuICAgICAgICBdLmpvaW4oJ1xcbicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ29udmVydCBDU1YgdG8gZGF0YSBVUkxcbiAgICAgICAgY29uc3QgY3N2QmxvYiA9IG5ldyBCbG9iKFtjc3ZEYXRhXSwgeyB0eXBlOiAndGV4dC9jc3YnIH0pO1xuICAgICAgICBjb25zdCBjc3ZSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgY3N2RGF0YVVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgY3N2UmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHJlc29sdmUoY3N2UmVhZGVyLnJlc3VsdCk7XG4gICAgICAgICAgY3N2UmVhZGVyLnJlYWRBc0RhdGFVUkwoY3N2QmxvYik7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gU2F2ZSBDU1YgdXNpbmcgdGhlIHNhbWUgQVBJXG4gICAgICAgIGF3YWl0IHNhdmVJbWFnZVRvU2VydmVyKGNzdkRhdGFVcmwsIHBhcmFtZXRlckZpbGVuYW1lLCAncGFyYW1ldGVycycpO1xuICAgICAgICBjb25zb2xlLmxvZyhgU2F2ZWQgcGFyYW1ldGVycyBDU1Y6ICR7cGFyYW1ldGVyRmlsZW5hbWV9YCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoY3N2RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNhdmluZyBwYXJhbWV0ZXIgQ1NWOlwiLCBjc3ZFcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFRISVMgSVMgVEhFIE1JU1NJTkcgUElFQ0UgLSBTaG93IHByZXZpZXcgYWZ0ZXIgY2FwdHVyaW5nXG4gICAgICBjb25zb2xlLmxvZyhcIlNob3dpbmcgaW1hZ2UgcHJldmlldyB3aXRoOlwiLCB7IFxuICAgICAgICBoYXNTY3JlZW5JbWFnZTogISFzY3JlZW5JbWFnZSwgXG4gICAgICAgIGhhc1dlYmNhbUltYWdlOiAhIXdlYmNhbUltYWdlIFxuICAgICAgfSk7XG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXcoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlLCBjdXJyZW50RG90KTtcbiAgICAgIFxuICAgICAgLy8gSW5jcmVtZW50IHRoZSBjb3VudGVyIGZvciBuZXh0IGNhcHR1cmVcbiAgICAgIHNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlZCB3aXRoIGRvdCBhdDogeD0ke2N1cnJlbnREb3Q/Lnh9LCB5PSR7Y3VycmVudERvdD8ueX1gKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHBhcmVudCBjb21wb25lbnRcbiAgICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgICBvblN0YXR1c1VwZGF0ZShgSW1hZ2VzIGFuZCBwYXJhbWV0ZXJzIHNhdmVkIGZvciBjYXB0dXJlICMke2NhcHR1cmVDb3VudGVyfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBjYXB0dXJlIHdpdGggYSBkZWxheSB0byBsZXQgcHJldmlldyBmaW5pc2hcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlNob3dpbmcgVG9wQmFyIGFmdGVyIGNhcHR1cmVcIik7XG4gICAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAyNTAwKTsgLy8gSW5jcmVhc2VkIHRvIHdhaXQgZm9yIHByZXZpZXcgdG8gZmluaXNoXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBjYXB0dXJlOicsIGVycm9yKTtcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yIGNhcHR1cmluZyBpbWFnZXM6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIH0sIDMwMDApO1xuICB9O1xuICAvLyBBZGQgdGhpcyBuZXcgZnVuY3Rpb24gdG8gc2hvdyBhIHByZXZpZXcgb2YgY2FwdHVyZWQgaW1hZ2VzXG4gIGNvbnN0IHNob3dDYXB0dXJlUHJldmlldyA9IChzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIGRvdFBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKCFzY3JlZW5JbWFnZSAmJiAhd2ViY2FtSW1hZ2UpIHJldHVybjtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSBwcmV2aWV3XG4gICAgY29uc3QgcHJldmlld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIHRvcDogNTAlO1xuICAgICAgbGVmdDogNTAlO1xuICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZ2FwOiAyMHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg1KTtcbiAgICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICAgIGA7XG4gICAgXG4gICAgLy8gQWRkIHNjcmVlbiBpbWFnZSBwcmV2aWV3XG4gICAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCBzY3JlZW5JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIHNjcmVlbkltZy5zcmMgPSBzY3JlZW5JbWFnZTtcbiAgICAgIHNjcmVlbkltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBtYXgtd2lkdGg6IDMwMHB4O1xuICAgICAgICBtYXgtaGVpZ2h0OiAyMDBweDtcbiAgICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIGNvbnN0IHNjcmVlbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgICBzY3JlZW5MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkltZyk7XG4gICAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc2NyZWVuUHJldmlldyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCB3ZWJjYW0gaW1hZ2UgcHJldmlld1xuICAgIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgICAgY29uc3Qgd2ViY2FtUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd2ViY2FtUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgY29uc3Qgd2ViY2FtSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICB3ZWJjYW1JbWcuc3JjID0gd2ViY2FtSW1hZ2U7XG4gICAgICB3ZWJjYW1JbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgbWF4LXdpZHRoOiAzMDBweDtcbiAgICAgICAgbWF4LWhlaWdodDogMjAwcHg7XG4gICAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBgO1xuICAgICAgXG4gICAgICBjb25zdCB3ZWJjYW1MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgd2ViY2FtTGFiZWwudGV4dENvbnRlbnQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgICAgd2ViY2FtTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1JbWcpO1xuICAgICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1MYWJlbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBBZGQgcG9zaXRpb24gaW5kaWNhdG9yIGlmIGF2YWlsYWJsZVxuICAgIGlmIChkb3RQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBwb3NpdGlvbkluZm8udGV4dENvbnRlbnQgPSBgRG90IHBvc2l0aW9uOiB4PSR7TWF0aC5yb3VuZChkb3RQb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKGRvdFBvc2l0aW9uLnkpfWA7XG4gICAgICBwb3NpdGlvbkluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IC0zMHB4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgICAgYDtcbiAgICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9zaXRpb25JbmZvKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQWRkIHRoZSBwcmV2aWV3IHRvIHRoZSBkb2N1bWVudFxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgXG4gICAgLy8gUmVtb3ZlIHByZXZpZXcgYWZ0ZXIgMiBzZWNvbmRzXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIH0sIDIwMDApO1xuICB9O1xuICBcbiAgLy8gUmFuZG9tIERvdCBhY3Rpb25cbiAgY29uc3QgaGFuZGxlUmFuZG9tRG90ID0gKCkgPT4ge1xuICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyBkb3RcbiAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKCdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nKTtcbiAgICBcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGltZSB0byB1cGRhdGVcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGRpbWVuc2lvbnMgYXJlIHByb3Blcmx5IHNldFxuICAgICAgICBjb25zdCBwYXJlbnQgPSBjYW52YXMucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGNvbnRlbnRcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGRvdCB3aXRoIGEgbGFyZ2VyIHJhZGl1cyBmb3IgdmlzaWJpbGl0eVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5hcmMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIGdsb3cgZWZmZWN0IHRvIHRoZSBkb3RcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDE1LCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBjdXJyZW50IGRvdCBwb3NpdGlvbiBkaXJlY3RseVxuICAgICAgICBzZXRDdXJyZW50RG90KHBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgY2FudmFzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICAgICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBDcmVhdGUgdGhlIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IGFib3ZlIHRoZSBkb3RcbiAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdmb3JjZWQtY291bnRkb3duJztcbiAgICAgICAgXG4gICAgICAgIC8vIFBvc2l0aW9uIGl0IGFib3ZlIHRoZSBkb3QgKGNhbGN1bGF0ZSBhYnNvbHV0ZSBwb3NpdGlvbiBjb25zaWRlcmluZyB0aGUgY2FudmFzIHBvc2l0aW9uKVxuICAgICAgICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVkgPSBjYW52YXNSZWN0LnRvcCArIHBvc2l0aW9uLnk7XG4gICAgICAgIFxuICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIGxlZnQ6ICR7YWJzb2x1dGVYfXB4O1xuICAgICAgICAgIHRvcDogJHthYnNvbHV0ZVkgLSA2MH1weDtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICB6LWluZGV4OiA5OTk5O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93biBpbXBsZW1lbnRhdGlvblxuICAgICAgICBsZXQgY291bnQgPSAzO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBjb3VudGRvd25JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGNvdW50ZG93bkludGVydmFsKTtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgICAgICBjYXB0dXJlSW1hZ2UoKTsgLy8gUHJvY2VlZCB3aXRoIGNhcHR1cmVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgODAwKTtcbiAgICAgIH1cbiAgICB9LCAyMDApO1xuICB9O1xuICBcbiAgLy8gTXVsdGlwbGUgcmFuZG9tIGRvdHMgc2VxdWVuY2VcbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIFBhcnNlIGlucHV0IHZhbHVlcyAodXNlIGRlZmF1bHRzIGlmIGludmFsaWQpXG4gICAgY29uc3QgdGltZXMgPSBwYXJzZUludChyYW5kb21UaW1lcykgfHwgMTtcbiAgICBjb25zdCBkZWxheSA9IHBhcnNlSW50KGRlbGF5U2Vjb25kcykgfHwgMztcbiAgICBcbiAgICBpZiAodGltZXMgPD0gMCB8fCBkZWxheSA8PSAwKSB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdQbGVhc2UgdXNlIHBvc2l0aXZlIHZhbHVlcyBmb3IgdGltZXMgYW5kIGRlbGF5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBTdGFydGluZyAke3RpbWVzfSByYW5kb20gY2FwdHVyZXMuLi5gKTtcbiAgICBcbiAgICAvLyBTdGFydCBzZXF1ZW5jZVxuICAgIHNjaGVkdWxlUmFuZG9tQ2FwdHVyZXModGltZXMsIHRpbWVzLCBkZWxheSk7XG4gIH07XG4gIFxuICAvLyBTY2hlZHVsZSBzZXF1ZW5jZSBvZiByYW5kb20gY2FwdHVyZXNcbiAgY29uc3Qgc2NoZWR1bGVSYW5kb21DYXB0dXJlcyA9IChyZW1haW5pbmcsIHRvdGFsLCBkZWxheSkgPT4ge1xuICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHJlbWFpbmluZyk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke3RvdGFsIC0gcmVtYWluaW5nICsgMX0gb2YgJHt0b3RhbH1gKTtcbiAgICBcbiAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb24gYW5kIGRyYXdcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhbmRvbVBvc2l0aW9uKCk7XG4gICAgZHJhd0RvdChwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICBcbiAgICAvLyBTdGFydCBjb3VudGRvd24gYW5kIGNhcHR1cmVcbiAgICBzdGFydENvdW50ZG93bigzLCAoKSA9PiB7XG4gICAgICBjYXB0dXJlSW1hZ2UoKTtcbiAgICAgIFxuICAgICAgLy8gU2NoZWR1bGUgbmV4dCBjYXB0dXJlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2NoZWR1bGVSYW5kb21DYXB0dXJlcyhyZW1haW5pbmcgLSAxLCB0b3RhbCwgZGVsYXkpO1xuICAgICAgfSwgZGVsYXkgKiAxMDAwKTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1xuICBjb25zdCBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmICghY2FudmFzKSByZXR1cm4gW107XG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICBcbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gZm9yIHJvdW5kaW5nXG4gICAgY29uc3QgY29uZGl0aW9uYWxSb3VuZCA9IChkaW1lbnNpb24sIHBlcmNlbnRhZ2UpID0+IHtcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGRpbWVuc2lvbiAqIHBlcmNlbnRhZ2UpO1xuICAgIH07XG4gICAgXG4gICAgLy8gRGVmaW5lIHBlcmNlbnRhZ2UgdmFsdWVzIGZvciBvdXRlciBhbmQgaW5uZXIgZnJhbWVzXG4gICAgY29uc3QgZmlyc3RGcmFtZVBlcmNlbnRhZ2UgPSAwLjEyOyAgLy8gT3V0ZXIgZnJhbWUgYXQgMTIlIGZyb20gZWRnZXNcbiAgICBjb25zdCBzZWNvbmRGcmFtZVBlcmNlbnRhZ2UgPSAwLjI2OyAvLyBJbm5lciBmcmFtZSBhdCAyNiUgZnJvbSBlZGdlc1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwb2ludHMgZm9yIG91dGVyIGZyYW1lIChmaXJzdCBmcmFtZSlcbiAgICBjb25zdCB4TGVmdEZpcnN0ID0gY29uZGl0aW9uYWxSb3VuZCh3aWR0aCwgZmlyc3RGcmFtZVBlcmNlbnRhZ2UpO1xuICAgIGNvbnN0IHhSaWdodEZpcnN0ID0gd2lkdGggLSBjb25kaXRpb25hbFJvdW5kKHdpZHRoLCBmaXJzdEZyYW1lUGVyY2VudGFnZSk7XG4gICAgY29uc3QgeVRvcEZpcnN0ID0gY29uZGl0aW9uYWxSb3VuZChoZWlnaHQsIGZpcnN0RnJhbWVQZXJjZW50YWdlKTtcbiAgICBjb25zdCB5Qm90dG9tRmlyc3QgPSBoZWlnaHQgLSBjb25kaXRpb25hbFJvdW5kKGhlaWdodCwgZmlyc3RGcmFtZVBlcmNlbnRhZ2UpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBwb2ludHMgZm9yIGlubmVyIGZyYW1lIChzZWNvbmQgZnJhbWUpXG4gICAgY29uc3QgeExlZnRTZWNvbmQgPSBjb25kaXRpb25hbFJvdW5kKHdpZHRoLCBzZWNvbmRGcmFtZVBlcmNlbnRhZ2UpO1xuICAgIGNvbnN0IHhSaWdodFNlY29uZCA9IHdpZHRoIC0gY29uZGl0aW9uYWxSb3VuZCh3aWR0aCwgc2Vjb25kRnJhbWVQZXJjZW50YWdlKTtcbiAgICBjb25zdCB5VG9wU2Vjb25kID0gY29uZGl0aW9uYWxSb3VuZChoZWlnaHQsIHNlY29uZEZyYW1lUGVyY2VudGFnZSk7XG4gICAgY29uc3QgeUJvdHRvbVNlY29uZCA9IGhlaWdodCAtIGNvbmRpdGlvbmFsUm91bmQoaGVpZ2h0LCBzZWNvbmRGcmFtZVBlcmNlbnRhZ2UpO1xuICAgIFxuICAgIC8vIFJldHVybiBhcnJheSBvZiBwb2ludHMgaW4gc3BlY2lmaWMgb3JkZXJcbiAgICByZXR1cm4gW1xuICAgICAgLy8gRmlyc3QgZnJhbWUgLSBvdXRlciBwb2ludHNcbiAgICAgIHsgeDogeExlZnRGaXJzdCwgeTogeVRvcEZpcnN0IH0sXG4gICAgICB7IHg6IE1hdGguZmxvb3Iod2lkdGggLyAyKSwgeTogeVRvcEZpcnN0IH0sXG4gICAgICB7IHg6IHhSaWdodEZpcnN0LCB5OiB5VG9wRmlyc3QgfSxcbiAgICAgIHsgeDogeExlZnRGaXJzdCwgeTogTWF0aC5mbG9vcihoZWlnaHQgLyAyKSB9LFxuICAgICAgeyB4OiB4UmlnaHRGaXJzdCwgeTogTWF0aC5mbG9vcihoZWlnaHQgLyAyKSB9LFxuICAgICAgeyB4OiB4TGVmdEZpcnN0LCB5OiB5Qm90dG9tRmlyc3QgfSxcbiAgICAgIHsgeDogTWF0aC5mbG9vcih3aWR0aCAvIDIpLCB5OiB5Qm90dG9tRmlyc3QgfSxcbiAgICAgIHsgeDogeFJpZ2h0Rmlyc3QsIHk6IHlCb3R0b21GaXJzdCB9LFxuICAgICAgXG4gICAgICAvLyBTZWNvbmQgZnJhbWUgLSBpbm5lciBwb2ludHNcbiAgICAgIHsgeDogeExlZnRTZWNvbmQsIHk6IHlUb3BTZWNvbmQgfSxcbiAgICAgIHsgeDogTWF0aC5mbG9vcih3aWR0aCAvIDIpLCB5OiB5VG9wU2Vjb25kIH0sXG4gICAgICB7IHg6IHhSaWdodFNlY29uZCwgeTogeVRvcFNlY29uZCB9LFxuICAgICAgeyB4OiB4TGVmdFNlY29uZCwgeTogTWF0aC5mbG9vcihoZWlnaHQgLyAyKSB9LFxuICAgICAgeyB4OiB4UmlnaHRTZWNvbmQsIHk6IE1hdGguZmxvb3IoaGVpZ2h0IC8gMikgfSxcbiAgICAgIHsgeDogeExlZnRTZWNvbmQsIHk6IHlCb3R0b21TZWNvbmQgfSxcbiAgICAgIHsgeDogTWF0aC5mbG9vcih3aWR0aCAvIDIpLCB5OiB5Qm90dG9tU2Vjb25kIH0sXG4gICAgICB7IHg6IHhSaWdodFNlY29uZCwgeTogeUJvdHRvbVNlY29uZCB9XG4gICAgXTtcbiAgfTtcbiAgLy8gSW4gV2hpdGVTY3JlZW5NYWluLmpzIC0gVXBkYXRlIHRoZSB1c2VFZmZlY3QgZm9yIGJ1dHRvbiBjbGljayByZWdpc3RyYXRpb25cblxuICAvLyBNYWtlIHN1cmUgdGhlIGNhbGlicmF0ZSBhY3Rpb24gaXMgcHJvcGVybHkgcmVnaXN0ZXJlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFNraXAgZHVyaW5nIFNTUlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKFwiUmVnaXN0ZXJpbmcgYWN0aW9uIGhhbmRsZXJzIHdpdGggcGFyZW50XCIpO1xuICAgIFxuICAgIGlmIChvbkJ1dHRvbkNsaWNrKSB7XG4gICAgICAvLyBDcmVhdGUgYWN0aW9uIGhhbmRsZXJzIHdpdGggcHJvcGVyIG1ldGhvZCByZWZlcmVuY2VzXG4gICAgICBjb25zdCBhY3Rpb25IYW5kbGVycyA9IHtcbiAgICAgICAgcmFuZG9tRG90OiBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICAgIHNldFJhbmRvbTogaGFuZGxlU2V0UmFuZG9tLFxuICAgICAgICBjYWxpYnJhdGU6IGhhbmRsZVNldENhbGlicmF0ZSwgLy8gTWFrZSBzdXJlIHRoaXMgaGFuZGxlciBleGlzdHNcbiAgICAgICAgY2xlYXJBbGw6IGNsZWFyQ2FudmFzXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBTdG9yZSBpbiBwYXJlbnQgY29tcG9uZW50IGNvbnRleHRcbiAgICAgIG9uQnV0dG9uQ2xpY2soJ3JlZ2lzdGVyQWN0aW9ucycsIGFjdGlvbkhhbmRsZXJzKTtcbiAgICAgIFxuICAgICAgLy8gQWxzbyBtYWtlIHRoZW0gZ2xvYmFsbHkgYXZhaWxhYmxlIGZvciBkaXJlY3QgYWNjZXNzXG4gICAgICB3aW5kb3cud2hpdGVTY3JlZW5BY3Rpb25zID0gYWN0aW9uSGFuZGxlcnM7XG4gICAgfVxuICAgIFxuICAgIC8vIENsZWFudXAgb24gdW5tb3VudFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LndoaXRlU2NyZWVuQWN0aW9ucykge1xuICAgICAgICB3aW5kb3cud2hpdGVTY3JlZW5BY3Rpb25zID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbb25CdXR0b25DbGlja10pO1xuXG4gIC8vIEFkZCB0aGlzIGltcG9ydCBhdCB0aGUgdG9wIG9mIFdoaXRlU2NyZWVuTWFpbi5qc1xuXG4gIC8vIFJlcGxhY2UgdGhlIGhhbmRsZVNldENhbGlicmF0ZSBmdW5jdGlvbiB3aXRoIHRoaXMgaW1wcm92ZWQgdmVyc2lvblxuICBjb25zdCBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNURVAgMTogSElERSBUSEUgVE9QIEJBUiBJTU1FRElBVEVMWSAoYmVmb3JlIGFueXRoaW5nIGVsc2UgaGFwcGVucylcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFkZCBhIHNtYWxsIGRlbGF5IHRvIGVuc3VyZSBVSSB1cGRhdGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTApKTtcbiAgICAgIFxuICAgICAgLy8gU1RFUCAyOiBJbml0aWFsIHNldHVwXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyk7XG4gICAgICBcbiAgICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlJyxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgc3RhdHVzIGluZGljYXRvclxuICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMTBweDtcbiAgICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgcGFkZGluZzogOHB4IDEycHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggOHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgIGA7XG4gICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRlIFNldCBBY3RpdmU6IEluaXRpYWxpemluZy4uLic7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICBcbiAgICAgIC8vIFNURVAgMzogU2V0dXAgY2FudmFzIGFuZCBnZW5lcmF0ZSBwb2ludHNcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGFjdGl2ZUNhbnZhc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBFbnN1cmUgY2FudmFzIGRpbWVuc2lvbnMgYXJlIHNldFxuICAgICAgY29uc3QgcGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHBhcmVudC5jbGllbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKFwiQ2FudmFzIGRpbWVuc2lvbnMgZm9yIGNhbGlicmF0aW9uOlwiLCB7IHdpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCB9KTtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIHVzaW5nIHRoZSBpbXBvcnRlZCBmdW5jdGlvblxuICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgc2V0Q2FsaWJyYXRpb25Qb2ludHMocG9pbnRzKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYEdlbmVyYXRlZCAke3BvaW50cy5sZW5ndGh9IGNhbGlicmF0aW9uIHBvaW50c2ApO1xuICAgICAgXG4gICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cycpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcyhwb2ludHMubGVuZ3RoKTtcbiAgICAgIFxuICAgICAgLy8gU1RFUCA0OiBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnQgaW4gc2VxdWVuY2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0ZVxuICAgICAgICBzZXRDdXJyZW50Q2FsaWJyYXRpb25JbmRleChpKTtcbiAgICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMocG9pbnRzLmxlbmd0aCAtIGkpO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgICBjb25zdCBzdGF0dXNUZXh0ID0gYENhbGlicmF0aW9uICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1c1RleHQpO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRlIFNldCBBY3RpdmU6IFByb2Nlc3NpbmcgcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgIFxuICAgICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZShzdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA1OiBEcmF3IHRoZSByZWQgZG90IEZJUlNULCBiZWZvcmUgYW55IGNvdW50ZG93blxuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgZHJhd0RvdChwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYSBtb21lbnQgdG8gZW5zdXJlIGRvdCBpcyB2aXNpYmxlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA2OiBHZXQgY2FudmFzIHBvc2l0aW9uIGZvciBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGNvdW50ZG93biBlbGVtZW50IGFib3ZlIHRoZSBkb3RcbiAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICAgICAgXG4gICAgICAgIC8vIFBvc2l0aW9uIGl0IGFib3ZlIHRoZSBkb3RcbiAgICAgICAgY29uc3QgYWJzb2x1dGVYID0gY2FudmFzUmVjdC5sZWZ0ICsgcG9pbnQueDtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVZID0gY2FudmFzUmVjdC50b3AgKyBwb2ludC55O1xuICAgICAgICBcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICAgICAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgNzogUnVuIDMtMi0xIGNvdW50ZG93biAodGhlIGRvdCBzdGF5cyB2aXNpYmxlIGR1cmluZyB0aGlzIHRpbWUpXG4gICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGUgU2V0IEFjdGl2ZTogY291bnRkb3duICR7Y291bnR9ICgke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9KWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gV2FpdCBmb3IgbmV4dCBjb3VudGRvd24gc3RlcFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCA4OiBTaG93IGNhcHR1cmluZyBpbmRpY2F0b3JcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYXB0dXJpbmcgcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgIFxuICAgICAgICAvLyBTVEVQIDk6IFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBidXQgS0VFUCB0aGUgZG90IHZpc2libGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNURVAgMTA6IENhcHR1cmUgaW1hZ2VzICh0aGUgZG90IGlzIHN0aWxsIHZpc2libGUpXG4gICAgICAgIGF3YWl0IGNhcHR1cmVJbWFnZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gU1RFUCAxMTogV2FpdCBmb3IgcHJldmlldyB0byBjb21wbGV0ZSBiZWZvcmUgbW92aW5nIHRvIG5leHQgcG9pbnRcbiAgICAgICAgLy8gRHVyaW5nIHRoaXMgdGltZSwgdGhlIGRvdCByZW1haW5zIHZpc2libGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIzMDApKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU1RFUCAxMjogQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDAwKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDYWxpYnJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICAgIG9uU3RhdHVzVXBkYXRlKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluXG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gRml4IGZvciBzdGFydENvdW50ZG93biBmdW5jdGlvbiB0byBoaWRlIFRvcEJhciBpbW1lZGlhdGVseVxuICAvLyBjb25zdCBzdGFydENvdW50ZG93biA9IChjb3VudCwgb25Db21wbGV0ZSkgPT4ge1xuICAvLyAgIGNvbnNvbGUubG9nKFwiU3RhcnRpbmcgY291bnRkb3duIGZyb206XCIsIGNvdW50KTtcbiAgICBcbiAgLy8gICAvLyBIaWRlIFRvcEJhciBpbW1lZGlhdGVseSB3aGVuIGNvdW50ZG93biBzdGFydHNcbiAgLy8gICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgLy8gICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgLy8gICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAvLyAgIH1cbiAgICBcbiAgLy8gICAvLyBTZXQgY291bnRkb3duIHZhbHVlIGluIHN0YXRlXG4gIC8vICAgc2V0Q291bnRkb3duVmFsdWUoY291bnQpO1xuICAvLyAgIHNldEZvcmNlU2hvd0NvdW50ZG93bih0cnVlKTtcbiAgLy8gICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICBcbiAgLy8gICAvLyBVcGRhdGUgc3RhdHVzIGZvciBwYXJlbnQgY29tcG9uZW50XG4gIC8vICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gIC8vICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gIC8vICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgLy8gICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAvLyAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAvLyAgICAgfSk7XG4gIC8vICAgfVxuICAgIFxuICAvLyAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gIC8vICAgICBpZiAoY291bnQgPiAxKSB7XG4gIC8vICAgICAgIHN0YXJ0Q291bnRkb3duKGNvdW50IC0gMSwgb25Db21wbGV0ZSk7XG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICAvLyBGaW5hbCBjb3VudGRvd24gc3RlcFxuICAvLyAgICAgICBjb25zb2xlLmxvZyhcIkNvdW50ZG93biBmaW5pc2hlZCwgY2xlYXJpbmcgY291bnRkb3duIGRpc3BsYXlcIik7XG4gIC8vICAgICAgIHNldENvdW50ZG93blZhbHVlKG51bGwpO1xuICAvLyAgICAgICBzZXRGb3JjZVNob3dDb3VudGRvd24oZmFsc2UpO1xuICAgICAgICBcbiAgLy8gICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgcGFyZW50IGNvbXBvbmVudFxuICAvLyAgICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgLy8gICAgICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gIC8vICAgICAgICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgLy8gICAgICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJpbmcuLi4nLFxuICAvLyAgICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgLy8gICAgICAgICB9KTtcbiAgLy8gICAgICAgfVxuICAgICAgICBcbiAgLy8gICAgICAgLy8gRXhlY3V0ZSBjb21wbGV0aW9uIGNhbGxiYWNrIGltbWVkaWF0ZWx5XG4gIC8vICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gIC8vICAgICAgICAgY29uc29sZS5sb2coXCJFeGVjdXRpbmcgY29tcGxldGlvbiBjYWxsYmFja1wiKTtcbiAgLy8gICAgICAgICBvbkNvbXBsZXRlKCk7XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9LCA4MDApO1xuICAgIFxuICAvLyAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAvLyB9O1xuICAvLyBNb3ZlIHRvIG5leHQgY2FsaWJyYXRpb24gcG9pbnRcbiAgY29uc3QgbW92ZVRvTmV4dENhbGlicmF0aW9uUG9pbnQgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV4dEluZGV4ID0gY3VycmVudENhbGlicmF0aW9uSW5kZXggKyAxO1xuICAgIFxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRvbmVcbiAgICBpZiAobmV4dEluZGV4ID49IGNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXMoMCk7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKCdDYWxpYnJhdGlvbiBjb21wbGV0ZWQnKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgc3RhdHVzIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgICAgXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBzdGF0ZSBhbmQgcHJvZ3Jlc3NcbiAgICBzZXRDdXJyZW50Q2FsaWJyYXRpb25JbmRleChuZXh0SW5kZXgpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKGNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aCAtIG5leHRJbmRleCk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gJHtuZXh0SW5kZXggKyAxfS8ke2NhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH1gKTtcbiAgICBcbiAgICAvLyBEcmF3IG5leHQgcG9pbnRcbiAgICBjb25zdCBuZXh0UG9pbnQgPSBjYWxpYnJhdGlvblBvaW50c1tuZXh0SW5kZXhdO1xuICAgIGRyYXdEb3QobmV4dFBvaW50LngsIG5leHRQb2ludC55KTtcbiAgICBcbiAgICAvLyBTdGFydCBjb3VudGRvd24gZm9yIHRoaXMgcG9pbnRcbiAgICBzdGFydENvdW50ZG93bigzLCAoKSA9PiB7XG4gICAgICBjYXB0dXJlSW1hZ2UoKTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gbW92ZVRvTmV4dENhbGlicmF0aW9uUG9pbnQoKSwgMTAwMCk7XG4gICAgfSk7XG4gIH07XG4gIFxuICAvLyBNYXAgYnV0dG9uIGNsaWNrcyB0byBhcHByb3ByaWF0ZSBoYW5kbGVyc1xuICBjb25zdCBoYW5kbGVTY3JlZW5BY3Rpb24gPSAoYWN0aW9uVHlwZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGBTY3JlZW4gYWN0aW9uIHJlY2VpdmVkOiAke2FjdGlvblR5cGV9YCk7XG4gICAgXG4gICAgc3dpdGNoKGFjdGlvblR5cGUpIHtcbiAgICAgIGNhc2UgJ3JhbmRvbURvdCc6XG4gICAgICAgIGhhbmRsZVJhbmRvbURvdCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NldFJhbmRvbSc6XG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NhbGlicmF0ZSc6XG4gICAgICAgIGhhbmRsZVNldENhbGlicmF0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsZWFyQWxsJzpcbiAgICAgICAgY2xlYXJDYW52YXMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGb3J3YXJkIHRvIHBhcmVudCBpZiBub3QgaGFuZGxlZCBoZXJlXG4gICAgICAgIGlmIChvbkJ1dHRvbkNsaWNrKSB7XG4gICAgICAgICAgb25CdXR0b25DbGljayhhY3Rpb25UeXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfTtcbiAgXG4gIC8vIC8vIFBhc3MgYWN0aW9ucyB1cCB0byBwYXJlbnQgY29tcG9uZW50XG4gIC8vIHVzZUVmZmVjdCgoKSA9PiB7XG4gIC8vICAgLy8gU2tpcCBkdXJpbmcgU1NSXG4gIC8vICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gIC8vICAgY29uc29sZS5sb2coXCJSZWdpc3RlcmluZyBhY3Rpb24gaGFuZGxlcnMgd2l0aCBwYXJlbnRcIik7XG4gICAgXG4gIC8vICAgaWYgKG9uQnV0dG9uQ2xpY2spIHtcbiAgLy8gICAgIC8vIENyZWF0ZSBhY3Rpb24gaGFuZGxlcnNcbiAgLy8gICAgIGNvbnN0IGFjdGlvbkhhbmRsZXJzID0ge1xuICAvLyAgICAgICByYW5kb21Eb3Q6IGhhbmRsZVJhbmRvbURvdCxcbiAgLy8gICAgICAgc2V0UmFuZG9tOiBoYW5kbGVTZXRSYW5kb20sXG4gIC8vICAgICAgIGNhbGlicmF0ZTogaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAvLyAgICAgICBjbGVhckFsbDogY2xlYXJDYW52YXNcbiAgLy8gICAgIH07XG4gICAgICBcbiAgLy8gICAgIC8vIFN0b3JlIGluIHBhcmVudCBjb21wb25lbnQgY29udGV4dFxuICAvLyAgICAgb25CdXR0b25DbGljaygncmVnaXN0ZXJBY3Rpb25zJywgYWN0aW9uSGFuZGxlcnMpO1xuICAvLyAgIH1cbiAgLy8gfSwgW29uQnV0dG9uQ2xpY2tdKTtcbiAgXG4gIC8vIFVwZGF0ZSBwYXJlbnQgd2l0aCBzdGF0dXMgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChvblN0YXR1c1VwZGF0ZSAmJiBwcm9jZXNzU3RhdHVzKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZShwcm9jZXNzU3RhdHVzKTtcbiAgICB9XG4gIH0sIFtwcm9jZXNzU3RhdHVzLCBvblN0YXR1c1VwZGF0ZV0pO1xuICBcbiAgLy8gTG9nIHdoZW4gY29tcG9uZW50IG1vdW50cyB0byB2ZXJpZnkgaXQncyBiZWluZyByZW5kZXJlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiV2hpdGVTY3JlZW5NYWluIGNvbXBvbmVudCBtb3VudGVkXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiUHJvcHM6XCIsIHsgXG4gICAgICBoYXNTdGF0dXNVcGRhdGU6ICEhb25TdGF0dXNVcGRhdGUsIFxuICAgICAgaGFzQ2FtZXJhQWNjZXNzOiAhIXRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICBoYXNCdXR0b25DbGljazogISFvbkJ1dHRvbkNsaWNrLFxuICAgICAgaGFzQ2FudmFzUmVmOiAhIWNhbnZhc1JlZixcbiAgICAgIGhhc1RvZ2dsZVRvcEJhcjogISF0b2dnbGVUb3BCYXIgXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2hpdGVTY3JlZW5NYWluIGNvbXBvbmVudCB1bm1vdW50aW5nXCIpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3aGl0ZS1zY3JlZW4tY29udGFpbmVyXCIgc3R5bGU9e3sgXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICB6SW5kZXg6IDUwLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjUpJyAvLyBTbGlnaHQgdHJhbnNwYXJlbmN5IHRvIHNlZSBpZiBpdCdzIHJlbmRlcmVkXG4gICAgfX0+XG4gICAgICB7LyogV2hpdGUgc2NyZWVuIGNhbnZhcyAtIE1ha2UgaXQgY292ZXIgdGhlIGVudGlyZSBjb250YWluZXIgKi99XG4gICAgICA8ZGl2IFxuICAgICAgICBjbGFzc05hbWU9XCJ3aGl0ZS1zY3JlZW4tY2FudmFzLWNvbnRhaW5lclwiXG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAjY2NjJywgLy8gTW9yZSB2aXNpYmxlIGJvcmRlclxuICAgICAgICAgIHpJbmRleDogNTFcbiAgICAgICAgfX1cbiAgICAgID5cbiAgICAgICAgey8qIENhbnZhcyAtIEFsd2F5cyByZW5kZXIgaXQgKi99XG4gICAgICAgIDxjYW52YXNcbiAgICAgICAgICByZWY9e2NhbnZhc1JlZiA/IGNhbnZhc1JlZiA6IGludGVybmFsQ2FudmFzUmVmfVxuICAgICAgICAgIGNsYXNzTmFtZT1cIndoaXRlLXNjcmVlbi1jYW52YXNcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgICAgICAgfX1cbiAgICAgICAgLz5cbiAgICAgICAgXG4gICAgICAgIHsvKiBPdmVybGF5IGZvciBjb3VudGRvd24gbmVhciBkb3QgLSB3aXRoIGltcHJvdmVkIHZpc2liaWxpdHkgYW5kIGEgZmFsbGJhY2sgKi99XG4gICAgICAgIHsoY291bnRkb3duVmFsdWUgIT09IG51bGwgfHwgZm9yY2VTaG93Q291bnRkb3duKSAmJiBjdXJyZW50RG90ICYmIChcbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZG90LWNvdW50ZG93blwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgbGVmdDogYCR7Y3VycmVudERvdC54IC0gMzB9cHhgLFxuICAgICAgICAgICAgICB0b3A6IGAke2N1cnJlbnREb3QueSAtIDcwfXB4YCxcbiAgICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzQ4cHgnLCAvLyBNdWNoIGxhcmdlclxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgIHRleHRTaGFkb3c6ICcwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGUnLCAvLyBTdHJvbmdlciBzaGFkb3dcbiAgICAgICAgICAgICAgekluZGV4OiA5OTksXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC44KScsIC8vIEJhY2tncm91bmQgdG8gbWFrZSBpdCBtb3JlIHZpc2libGVcbiAgICAgICAgICAgICAgcGFkZGluZzogJzEwcHggMjBweCcsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgICAgICAgICAgIGJveFNoYWRvdzogJzAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKScsXG4gICAgICAgICAgICAgIHdpZHRoOiAnNjBweCcsXG4gICAgICAgICAgICAgIGhlaWdodDogJzYwcHgnLFxuICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGJvcmRlcjogJzJweCBzb2xpZCByZWQnIC8vIEJvcmRlciB0byBtYWtlIGl0IHN0YW5kIG91dFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y291bnRkb3duVmFsdWUgfHwgM31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBCYWNrdXAgY2VudGVyZWQgY291bnRkb3duIGZvciBiZXR0ZXIgdmlzaWJpbGl0eSAqL31cbiAgICAgICAgeyhjb3VudGRvd25WYWx1ZSAhPT0gbnVsbCB8fCBmb3JjZVNob3dDb3VudGRvd24pICYmIChcbiAgICAgICAgICA8ZGl2IFxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2VudGVyLWNvdW50ZG93bi1iYWNrdXBcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknLFxuICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgZm9udFNpemU6ICcxMjBweCcsIC8vIFZlcnkgbGFyZ2VcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICB0ZXh0U2hhZG93OiAnMCAwIDIwcHggYmxhY2snLFxuICAgICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAwLCAwLCAwLjcpJywgLy8gUmVkIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgd2lkdGg6ICcyMDBweCcsXG4gICAgICAgICAgICAgIGhlaWdodDogJzIwMHB4JyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDAgMzBweCByZ2JhKDAsIDAsIDAsIDAuNSknXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjb3VudGRvd25WYWx1ZSB8fCAzfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuICAgICAgICBcbiAgICAgICAgey8qIEluZGljYXRvciB0aGF0IHRoZSBkb3QgaXMgcHJlc2VudCAtIGhlbHBzIHdpdGggZGVidWdnaW5nICovfVxuICAgICAgICB7Y3VycmVudERvdCAmJiAoXG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImRvdC1pbmRpY2F0b3JcIlxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgIHRvcDogJzEwcHgnLFxuICAgICAgICAgICAgICByaWdodDogJzEwcHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDI1NSwgMCwgMC43KScsXG4gICAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgICBwYWRkaW5nOiAnNXB4IDEwcHgnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzEycHgnLFxuICAgICAgICAgICAgICB6SW5kZXg6IDUyXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIERvdCBhdCB4OntjdXJyZW50RG90Lnh9LCB5OntjdXJyZW50RG90Lnl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICAgIFxuICAgICAgICB7LyogU3RhdHVzIG92ZXJsYXkgKi99XG4gICAgICAgIHsocHJvY2Vzc1N0YXR1cyB8fCByZW1haW5pbmdDYXB0dXJlcyA+IDApICYmIChcbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJzdGF0dXMtb3ZlcmxheVwiXG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgYm90dG9tOiAnMTBweCcsXG4gICAgICAgICAgICAgIGxlZnQ6ICcxMHB4JyxcbiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjgpJywgLy8gRGFya2VyIGZvciB2aXNpYmlsaXR5XG4gICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLCAvLyBXaGl0ZSB0ZXh0XG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcxMHB4IDE1cHgnLFxuICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLCAvLyBMYXJnZXJcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLDAsMCwwLjMpJyxcbiAgICAgICAgICAgICAgekluZGV4OiA1M1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7cHJvY2Vzc1N0YXR1cyAmJiA8ZGl2Pntwcm9jZXNzU3RhdHVzfTwvZGl2Pn1cbiAgICAgICAgICAgIHtyZW1haW5pbmdDYXB0dXJlcyA+IDAgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGNvbG9yOiAnI2ZmY2MwMCcgfX0+XG4gICAgICAgICAgICAgICAgUmVtYWluaW5nOiB7cmVtYWluaW5nQ2FwdHVyZXN9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cbiAgICAgICAgXG4gICAgICAgIHsvKiBDYW52YXMgdmlzaWJpbGl0eSBpbmRpY2F0b3IgLSBkZWJ1Z2dpbmcgb25seSAqL31cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbnZhcy1pbmRpY2F0b3JcIlxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogJzEwcHgnLFxuICAgICAgICAgICAgbGVmdDogJzEwcHgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjYW52YXNWaXNpYmxlID8gJ3JnYmEoMCwgMjU1LCAwLCAwLjcpJyA6ICdyZ2JhKDI1NSwgMCwgMCwgMC43KScsXG4gICAgICAgICAgICBjb2xvcjogJ2JsYWNrJyxcbiAgICAgICAgICAgIHBhZGRpbmc6ICc1cHggMTBweCcsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgICAgICAgIHpJbmRleDogNTJcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgQ2FudmFzOiB7Y2FudmFzVmlzaWJsZSA/ICdWaXNpYmxlJyA6ICdIaWRkZW4nfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgXG4gICAgICB7LyogTWFudWFsIHRlc3QgYnV0dG9uIGZvciBkaXJlY3QgdGVzdGluZ1xuICAgICAgPGJ1dHRvblxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVSYW5kb21Eb3R9XG4gICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgYm90dG9tOiAnNzBweCcsXG4gICAgICAgICAgcmlnaHQ6ICcyMHB4JyxcbiAgICAgICAgICBwYWRkaW5nOiAnMTBweCAyMHB4JyxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdibHVlJyxcbiAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCAxMHB4IHJnYmEoMCwwLDAsMC4zKScsXG4gICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgICAgICAgekluZGV4OiAxMDAwXG4gICAgICAgIH19XG4gICAgICA+XG4gICAgICAgIFRFU1QgRE9UIE5PV1xuICAgICAgPC9idXR0b24+ICovfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuLy8gRXhwb3J0IGEgZHluYW1pYyB2ZXJzaW9uIHdpdGggU1NSIGRpc2FibGVkIHRvIGF2b2lkIHVzZUxheW91dEVmZmVjdCB3YXJuaW5nc1xuZXhwb3J0IGRlZmF1bHQgZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoV2hpdGVTY3JlZW5NYWluKSwgeyBzc3I6IGZhbHNlIH0pOyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiZHluYW1pYyIsIldoaXRlU2NyZWVuTWFpbiIsIm9uU3RhdHVzVXBkYXRlIiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsIm9uQnV0dG9uQ2xpY2siLCJjYW52YXNSZWYiLCJ0b2dnbGVUb3BCYXIiLCJpbnRlcm5hbENhbnZhc1JlZiIsImFjdGl2ZUNhbnZhc1JlZiIsImN1cnJlbnREb3QiLCJzZXRDdXJyZW50RG90IiwiaXNDYXB0dXJpbmciLCJzZXRJc0NhcHR1cmluZyIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJyZW1haW5pbmdDYXB0dXJlcyIsInNldFJlbWFpbmluZ0NhcHR1cmVzIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsInJhbmRvbVRpbWVzIiwic2V0UmFuZG9tVGltZXMiLCJkZWxheVNlY29uZHMiLCJzZXREZWxheVNlY29uZHMiLCJjYWxpYnJhdGlvblBvaW50cyIsInNldENhbGlicmF0aW9uUG9pbnRzIiwiY3VycmVudENhbGlicmF0aW9uSW5kZXgiLCJzZXRDdXJyZW50Q2FsaWJyYXRpb25JbmRleCIsImNhbnZhc1Zpc2libGUiLCJzZXRDYW52YXNWaXNpYmxlIiwiZm9yY2VTaG93Q291bnRkb3duIiwic2V0Rm9yY2VTaG93Q291bnRkb3duIiwiY2FudmFzIiwiY3VycmVudCIsImNvbnNvbGUiLCJlcnJvciIsImxvZyIsImhhc0NhbnZhcyIsImNhbnZhc0hlaWdodCIsImhlaWdodCIsImNhbnZhc1dpZHRoIiwid2lkdGgiLCJ1cGRhdGVEaW1lbnNpb25zIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsInBhcmVudFdpZHRoIiwiY2xpZW50V2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJkcmF3RG90IiwieCIsInkiLCJzaG93Q2FwdHVyZVByZXZpZXciLCJzY3JlZW5JbWFnZSIsIndlYmNhbUltYWdlIiwiZG90UG9zaXRpb24iLCJ3YXJuIiwiZXhpc3RpbmdQcmV2aWV3cyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJwcmV2aWV3IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2xlYW51cEVycm9yIiwicHJldmlld0NvbnRhaW5lciIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJkZWJ1Z0luZm8iLCJ0ZXh0Q29udGVudCIsImFwcGVuZENoaWxkIiwiYWRkSW1hZ2VQcmV2aWV3IiwiaW1hZ2UiLCJsYWJlbCIsImxlbmd0aCIsImltZyIsInNyYyIsImFsdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJlIiwibGFiZWxFbGVtZW50IiwicG9zaXRpb25JbmZvIiwiTWF0aCIsInJvdW5kIiwidGltZXJFbGVtZW50IiwiYm9keSIsImFwcGVuZEVycm9yIiwidGltZUxlZnQiLCJpbnRlcnZhbCIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsInRyYW5zaXRpb24iLCJvcGFjaXR5Iiwic2V0VGltZW91dCIsInRvRml4ZWQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImdldFJhbmRvbVBvc2l0aW9uIiwicGFkZGluZyIsImZsb29yIiwicmFuZG9tIiwiY29sb3IiLCJyYWRpdXMiLCJjbGVhclJlY3QiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsInByZXYiLCJjbGVhckNhbnZhcyIsInN0YXJ0Q291bnRkb3duIiwiY291bnQiLCJvbkNvbXBsZXRlIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJzYXZlSW1hZ2VUb1NlcnZlciIsImltYWdlRGF0YSIsImZpbGVuYW1lIiwidHlwZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsImZvbGRlciIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJyZXN1bHQiLCJqc29uIiwiY2FwdHVyZU51bWJlciIsImNhcHR1cmVJbWFnZSIsInNjcmVlbkZpbGVuYW1lIiwiU3RyaW5nIiwicGFkU3RhcnQiLCJ3ZWJjYW1GaWxlbmFtZSIsInBhcmFtZXRlckZpbGVuYW1lIiwidG9EYXRhVVJMIiwidmlkZW9FbGVtZW50IiwidGVtcENhbnZhcyIsInZpZGVvV2lkdGgiLCJ2aWRlb0hlaWdodCIsImRyYXdJbWFnZSIsInN0cmVhbSIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImdldFVzZXJNZWRpYSIsInZpZGVvIiwiYXVkaW8iLCJ0ZW1wVmlkZW8iLCJhdXRvcGxheSIsInBsYXlzSW5saW5lIiwibXV0ZWQiLCJwb3NpdGlvbiIsImxlZnQiLCJzcmNPYmplY3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInRpbWVvdXRJZCIsIm9ubG9hZGVkZGF0YSIsImdldFRyYWNrcyIsInRyYWNrIiwic3RvcCIsIndlYmNhbUVycm9yIiwiY3N2RGF0YSIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJjc3ZCbG9iIiwiQmxvYiIsImNzdlJlYWRlciIsIkZpbGVSZWFkZXIiLCJjc3ZEYXRhVXJsIiwib25sb2FkZW5kIiwicmVhZEFzRGF0YVVSTCIsImNzdkVycm9yIiwiaGFzU2NyZWVuSW1hZ2UiLCJoYXNXZWJjYW1JbWFnZSIsIm1lc3NhZ2UiLCJzY3JlZW5QcmV2aWV3Iiwic2NyZWVuSW1nIiwic2NyZWVuTGFiZWwiLCJ3ZWJjYW1QcmV2aWV3Iiwid2ViY2FtSW1nIiwid2ViY2FtTGFiZWwiLCJoYW5kbGVSYW5kb21Eb3QiLCJjYW52YXNSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY291bnRkb3duRWxlbWVudCIsImFic29sdXRlWCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkludGVydmFsIiwicmVtb3ZlIiwiaGFuZGxlU2V0UmFuZG9tIiwidGltZXMiLCJwYXJzZUludCIsImRlbGF5Iiwic2NoZWR1bGVSYW5kb21DYXB0dXJlcyIsInJlbWFpbmluZyIsInRvdGFsIiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsImNvbmRpdGlvbmFsUm91bmQiLCJkaW1lbnNpb24iLCJwZXJjZW50YWdlIiwiZmlyc3RGcmFtZVBlcmNlbnRhZ2UiLCJzZWNvbmRGcmFtZVBlcmNlbnRhZ2UiLCJ4TGVmdEZpcnN0IiwieFJpZ2h0Rmlyc3QiLCJ5VG9wRmlyc3QiLCJ5Qm90dG9tRmlyc3QiLCJ4TGVmdFNlY29uZCIsInhSaWdodFNlY29uZCIsInlUb3BTZWNvbmQiLCJ5Qm90dG9tU2Vjb25kIiwiYWN0aW9uSGFuZGxlcnMiLCJyYW5kb21Eb3QiLCJzZXRSYW5kb20iLCJjYWxpYnJhdGUiLCJoYW5kbGVTZXRDYWxpYnJhdGUiLCJjbGVhckFsbCIsIndoaXRlU2NyZWVuQWN0aW9ucyIsInN0YXR1c0luZGljYXRvciIsInBvaW50cyIsImkiLCJzdGF0dXNUZXh0IiwicG9pbnQiLCJtb3ZlVG9OZXh0Q2FsaWJyYXRpb25Qb2ludCIsIm5leHRJbmRleCIsIm5leHRQb2ludCIsImhhbmRsZVNjcmVlbkFjdGlvbiIsImFjdGlvblR5cGUiLCJoYXNTdGF0dXNVcGRhdGUiLCJoYXNDYW1lcmFBY2Nlc3MiLCJoYXNCdXR0b25DbGljayIsImhhc0NhbnZhc1JlZiIsImhhc1RvZ2dsZVRvcEJhciIsImRpdiIsInpJbmRleCIsImJhY2tncm91bmRDb2xvciIsIm92ZXJmbG93IiwiYm9yZGVyIiwicmVmIiwiZGlzcGxheSIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInRleHRTaGFkb3ciLCJib3JkZXJSYWRpdXMiLCJib3hTaGFkb3ciLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJ0cmFuc2Zvcm0iLCJyaWdodCIsImJvdHRvbSIsInNzciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./pages/collected-dataset/components-gui/WhiteScreenMain.js\n");

/***/ })

};
;