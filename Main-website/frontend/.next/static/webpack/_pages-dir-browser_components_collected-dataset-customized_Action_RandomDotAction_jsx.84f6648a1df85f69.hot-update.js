"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_RandomDotAction_jsx",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/RandomDotAction.jsx ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n// RandomDotAction.jsx\n// Handles the random dot generation and countdown functionality\n\n\nclass RandomDotAction {\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        var _this_canvasRef;\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    constructor(config){\n        // Main function to handle random dot generation and capture\n        this.handleRandomDot = async ()=>{\n            // Hide the TopBar before showing dot\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Generating random dot...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Generating random dot...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                const canvas = this.getCanvas();\n                if (canvas) {\n                    // Use canvas manager to ensure proper initialization\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate random position\n                    const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.getRandomPosition)(canvas);\n                    // Draw the dot with consistent size\n                    const ctx = canvas.getContext('2d');\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y, 12, false);\n                    // Store current dot position\n                    this.setCurrentDot(position);\n                    try {\n                        // Use the shared capture and preview process\n                        await (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.captureAndPreviewProcess)({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            position,\n                            captureCounter: this.captureCounter,\n                            saveImageToServer: this.saveImageToServer,\n                            setCaptureCounter: this.setCaptureCounter,\n                            setProcessStatus: this.setProcessStatus,\n                            toggleTopBar: this.toggleTopBar,\n                            onStatusUpdate: this.onStatusUpdate,\n                            captureFolder: 'eye_tracking_captures'\n                        });\n                        // Clear the dot after capture\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        // Set capturing state to false after reasonable delay\n                        setTimeout(()=>{\n                            this.setIsCapturing(false);\n                        }, 2200); // Wait a bit longer than the preview duration\n                    } catch (error) {\n                        console.error(\"Error in capture and preview process:\", error);\n                        this.setProcessStatus('Error during capture process');\n                        this.setIsCapturing(false);\n                        // Clear error message after delay\n                        setTimeout(()=>{\n                            this.setProcessStatus('');\n                        }, 3000);\n                    }\n                } else {\n                    console.error(\"Canvas reference is null - cannot draw dot\");\n                    this.setProcessStatus('Error: Canvas not available');\n                    this.setIsCapturing(false);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  true ? window.canvasManager : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RandomDotAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsc0JBQXNCO0FBQ3RCLGdFQUFnRTtBQUV0QztBQUtMO0FBRXJCLE1BQU1JO0lBa0JKLG1EQUFtRDtJQUNuREMsWUFBWTtZQU1IO1FBTFAsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QixPQUFPLElBQUksQ0FBQ0EsYUFBYSxDQUFDRCxTQUFTLE1BQU0sSUFBSSxDQUFDQyxhQUFhLENBQUNDLFlBQVk7UUFDMUU7UUFFQSx1REFBdUQ7UUFDdkQsT0FBTyx3QkFBSSxDQUFDQyxTQUFTLGNBQWQsc0RBQWdCQyxPQUFPLEtBQUlDLFNBQVNDLGFBQWEsQ0FBQztJQUMzRDtJQXpCQUMsWUFBWUMsTUFBTSxDQUFFO1FBMkJwQiw0REFBNEQ7YUFDNURDLGtCQUFrQjtZQUNoQixxQ0FBcUM7WUFDckMsSUFBSSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLLFlBQVk7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxLQUE2QixJQUFJQyxPQUFPRCxZQUFZLEVBQUU7Z0JBQy9EQyxPQUFPRCxZQUFZLENBQUM7WUFDdEI7WUFFQSxJQUFJLENBQUNFLGNBQWMsQ0FBQztZQUNwQixJQUFJLENBQUNDLGdCQUFnQixDQUFDO1lBRXRCLHVDQUF1QztZQUN2QyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQztvQkFDbEJDLGVBQWU7b0JBQ2ZDLGFBQWE7Z0JBQ2Y7WUFDRjtZQUVBLG9DQUFvQztZQUNwQ0MsV0FBVztnQkFDVCxNQUFNQyxTQUFTLElBQUksQ0FBQ2xCLFNBQVM7Z0JBQzdCLElBQUlrQixRQUFRO29CQUNWLHFEQUFxRDtvQkFDckQsSUFBSSxJQUFJLENBQUNqQixhQUFhLEVBQUU7d0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDa0IsZUFBZTtvQkFDcEM7b0JBRUEsMkJBQTJCO29CQUMzQixNQUFNQyxXQUFXeEIsNkRBQWlCQSxDQUFDc0I7b0JBRW5DLG9DQUFvQztvQkFDcEMsTUFBTUcsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO29CQUM5QnpCLHNEQUFVQSxDQUFDd0IsS0FBS0QsU0FBU0csQ0FBQyxFQUFFSCxTQUFTSSxDQUFDLEVBQUUsSUFBSTtvQkFFNUMsNkJBQTZCO29CQUM3QixJQUFJLENBQUNDLGFBQWEsQ0FBQ0w7b0JBRW5CLElBQUk7d0JBQ0YsNkNBQTZDO3dCQUM3QyxNQUFNdEIsb0VBQXdCQSxDQUFDOzRCQUM3QkssV0FBVztnQ0FBRUMsU0FBU2M7NEJBQU87NEJBQzdCRTs0QkFDQU0sZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNDLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQjs0QkFDekNDLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQjs0QkFDekNmLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjs0QkFDdkNILGNBQWMsSUFBSSxDQUFDQSxZQUFZOzRCQUMvQkksZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNlLGVBQWU7d0JBQ2pCO3dCQUVBLDhCQUE4Qjt3QkFDOUIsTUFBTVIsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO3dCQUM5QkQsSUFBSVMsU0FBUyxDQUFDLEdBQUcsR0FBR1osT0FBT2EsS0FBSyxFQUFFYixPQUFPYyxNQUFNO3dCQUMvQ1gsSUFBSVksU0FBUyxHQUFHO3dCQUNoQlosSUFBSWEsUUFBUSxDQUFDLEdBQUcsR0FBR2hCLE9BQU9hLEtBQUssRUFBRWIsT0FBT2MsTUFBTTt3QkFFOUMsc0RBQXNEO3dCQUN0RGYsV0FBVzs0QkFDVCxJQUFJLENBQUNMLGNBQWMsQ0FBQzt3QkFDdEIsR0FBRyxPQUFPLDhDQUE4QztvQkFFMUQsRUFBRSxPQUFPdUIsT0FBTzt3QkFDZEMsUUFBUUQsS0FBSyxDQUFDLHlDQUF5Q0E7d0JBQ3ZELElBQUksQ0FBQ3RCLGdCQUFnQixDQUFDO3dCQUN0QixJQUFJLENBQUNELGNBQWMsQ0FBQzt3QkFFcEIsa0NBQWtDO3dCQUNsQ0ssV0FBVzs0QkFDVCxJQUFJLENBQUNKLGdCQUFnQixDQUFDO3dCQUN4QixHQUFHO29CQUNMO2dCQUNGLE9BQU87b0JBQ0x1QixRQUFRRCxLQUFLLENBQUM7b0JBQ2QsSUFBSSxDQUFDdEIsZ0JBQWdCLENBQUM7b0JBQ3RCLElBQUksQ0FBQ0QsY0FBYyxDQUFDO2dCQUN0QjtZQUNGLEdBQUc7UUFDTDtRQTFHRSxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDVCxTQUFTLEdBQUdLLE9BQU9MLFNBQVM7UUFDakMsSUFBSSxDQUFDTyxZQUFZLEdBQUdGLE9BQU9FLFlBQVk7UUFDdkMsSUFBSSxDQUFDRSxjQUFjLEdBQUdKLE9BQU9JLGNBQWM7UUFDM0MsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0wsT0FBT0ssZ0JBQWdCO1FBQy9DLElBQUksQ0FBQ1ksYUFBYSxHQUFHakIsT0FBT2lCLGFBQWE7UUFDekMsSUFBSSxDQUFDWSxtQkFBbUIsR0FBRzdCLE9BQU82QixtQkFBbUI7UUFDckQsSUFBSSxDQUFDdkIsY0FBYyxHQUFHTixPQUFPTSxjQUFjO1FBQzNDLElBQUksQ0FBQ2EsaUJBQWlCLEdBQUduQixPQUFPbUIsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdwQixPQUFPb0IsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0YsY0FBYyxHQUFHbEIsT0FBT2tCLGNBQWM7UUFFM0MsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQ3pCLGFBQWEsR0FBRyxLQUE2QixHQUFHVSxPQUFPVixhQUFhLEdBQUcsQ0FBSTtJQUNsRjtBQTZGRjtBQUVBLGlFQUFlRixlQUFlQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSYW5kb21Eb3RBY3Rpb24uanN4XG4vLyBIYW5kbGVzIHRoZSByYW5kb20gZG90IGdlbmVyYXRpb24gYW5kIGNvdW50ZG93biBmdW5jdGlvbmFsaXR5XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICBnZXRSYW5kb21Qb3NpdGlvbixcbiAgZHJhd1JlZERvdCxcbiAgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXG59IGZyb20gJy4vY291bnRTYXZlJztcblxuY2xhc3MgUmFuZG9tRG90QWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLy8gUmVxdWlyZWQgcHJvcGVydGllc1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyA9IGNvbmZpZy5zZXRJc0NhcHR1cmluZztcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBjb25maWcuc2V0UHJvY2Vzc1N0YXR1cztcbiAgICB0aGlzLnNldEN1cnJlbnREb3QgPSBjb25maWcuc2V0Q3VycmVudERvdDtcbiAgICB0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MgPSBjb25maWcudHJpZ2dlckNhbWVyYUFjY2VzcztcbiAgICB0aGlzLm9uU3RhdHVzVXBkYXRlID0gY29uZmlnLm9uU3RhdHVzVXBkYXRlO1xuICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBjb25maWcuc2F2ZUltYWdlVG9TZXJ2ZXI7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBmcm9tIGdsb2JhbCBzY29wZVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIG5ldyBDYW52YXNNYW5hZ2VyXG4gIGdldENhbnZhcygpIHtcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBNYWluIGZ1bmN0aW9uIHRvIGhhbmRsZSByYW5kb20gZG90IGdlbmVyYXRpb24gYW5kIGNhcHR1cmVcbiAgaGFuZGxlUmFuZG9tRG90ID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyBkb3RcbiAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwYXJlbnQgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLm9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRpbWUgdG8gdXBkYXRlXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAvLyBVc2UgY2FudmFzIG1hbmFnZXIgdG8gZW5zdXJlIHByb3BlciBpbml0aWFsaXphdGlvblxuICAgICAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb25cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgZG90IHdpdGggY29uc2lzdGVudCBzaXplXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgZG90IHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudERvdChwb3NpdGlvbik7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFVzZSB0aGUgc2hhcmVkIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2Vzc1xuICAgICAgICAgIGF3YWl0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzcyh7XG4gICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGNhcHR1cmVDb3VudGVyOiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXI6IHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcjogdGhpcy5zZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM6IHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgICAgIHRvZ2dsZVRvcEJhcjogdGhpcy50b2dnbGVUb3BCYXIsXG4gICAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogdGhpcy5vblN0YXR1c1VwZGF0ZSxcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIGRvdCBhZnRlciBjYXB0dXJlXG4gICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGUgdG8gZmFsc2UgYWZ0ZXIgcmVhc29uYWJsZSBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfSwgMjIwMCk7IC8vIFdhaXQgYSBiaXQgbG9uZ2VyIHRoYW4gdGhlIHByZXZpZXcgZHVyYXRpb25cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvciBkdXJpbmcgY2FwdHVyZSBwcm9jZXNzJyk7XG4gICAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgZXJyb3IgbWVzc2FnZSBhZnRlciBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbCAtIGNhbm5vdCBkcmF3IGRvdFwiKTtcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZG9tRG90QWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsImRyYXdSZWREb3QiLCJjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MiLCJSYW5kb21Eb3RBY3Rpb24iLCJnZXRDYW52YXMiLCJjYW52YXNNYW5hZ2VyIiwiY3JlYXRlQ2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiaGFuZGxlUmFuZG9tRG90IiwidG9nZ2xlVG9wQmFyIiwid2luZG93Iiwic2V0SXNDYXB0dXJpbmciLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJwcm9jZXNzU3RhdHVzIiwiaXNDYXB0dXJpbmciLCJzZXRUaW1lb3V0IiwiY2FudmFzIiwiZW50ZXJGdWxsc2NyZWVuIiwicG9zaXRpb24iLCJjdHgiLCJnZXRDb250ZXh0IiwieCIsInkiLCJzZXRDdXJyZW50RG90IiwiY2FwdHVyZUNvdW50ZXIiLCJzYXZlSW1hZ2VUb1NlcnZlciIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsImNsZWFyUmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJlcnJvciIsImNvbnNvbGUiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx\n"));

/***/ })

});