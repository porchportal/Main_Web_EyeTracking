"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_SetCalibrateAction_jsx",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx":
/*!*******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.jsx ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countSave.jsx */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.jsx\n// Handles the calibration sequence functionality\n\n\n\n\nclass SetCalibrateAction {\n    // Get or create canvas using the canvas management system from actionButton.js\n    getCanvas() {\n        var _this_canvasRef;\n        // First try to use canvasUtils from actionButton.js\n        if (this.canvasUtils && typeof this.canvasUtils.getCanvas === 'function') {\n            return this.canvasUtils.getCanvas();\n        }\n        // Fallback to canvasManager\n        if (this.canvasManager && typeof this.canvasManager.getCanvas === 'function') {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    // Enter fullscreen using the canvas management system\n    enterFullscreen() {\n        if (this.canvasUtils && typeof this.canvasUtils.enterFullscreen === 'function') {\n            return this.canvasUtils.enterFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.enterFullscreen === 'function') {\n            this.canvasManager.enterFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually enter fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            document.body.appendChild(canvas);\n            canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        z-index: 99999;\\n        background-color: white;\\n        border: none;\\n        display: block;\\n        opacity: 1;\\n        pointer-events: auto;\\n        margin: 0;\\n        padding: 0;\\n        box-sizing: border-box;\\n      \";\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            // Clear with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        return canvas;\n    }\n    // Exit fullscreen using the canvas management system\n    exitFullscreen() {\n        if (this.canvasUtils && typeof this.canvasUtils.exitFullscreen === 'function') {\n            return this.canvasUtils.exitFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.exitFullscreen === 'function') {\n            this.canvasManager.exitFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually exit fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            container.appendChild(canvas);\n            canvas.style.position = 'relative';\n            canvas.style.top = '';\n            canvas.style.left = '';\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.zIndex = '';\n            canvas.style.backgroundColor = 'white';\n        }\n        return canvas;\n    }\n    // Clear canvas using the canvas management system\n    clearCanvas() {\n        if (this.canvasUtils && typeof this.canvasUtils.clear === 'function') {\n            this.canvasUtils.clear();\n            return;\n        }\n        if (this.canvasManager && typeof this.canvasManager.clear === 'function') {\n            this.canvasManager.clear();\n            return;\n        }\n        // Fallback: manually clear canvas\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    }\n    // Draw dot using the canvas management system\n    drawDot(x, y) {\n        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n        if (this.canvasUtils && typeof this.canvasUtils.drawDot === 'function') {\n            return this.canvasUtils.drawDot(x, y, radius);\n        }\n        // Fallback: manually draw dot\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            (0,_countSave_jsx__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, x, y, radius, false);\n            return true;\n        }\n        return false;\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas() {\n        let maxTries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20, interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Starting calibration sequence...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Use canvas management system to enter fullscreen\n                    this.enterFullscreen();\n                    // Generate calibration points based on canvas size\n                    const points = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_1__.generateCalibrationPoints)(canvas.width, canvas.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = \"\\n          position: fixed;\\n          top: 20px;\\n          right: 20px;\\n          background-color: rgba(0, 102, 204, 0.9);\\n          color: white;\\n          font-size: 16px;\\n          font-weight: bold;\\n          padding: 10px 15px;\\n          border-radius: 8px;\\n          z-index: 10000;\\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n        \";\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        // Update status displays\n                        statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                        this.setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                        // Clear canvas with white background using canvas management system\n                        this.clearCanvas();\n                        // Draw the calibration point using canvas management system\n                        const radius = 24; // Larger size for better visibility\n                        this.drawDot(point.x, point.y, radius);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            this.drawDot(point.x, point.y, radius);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element positioned at the same location as the dot\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = \"\\n            position: fixed;\\n            left: \".concat(point.x, \"px;\\n            top: \").concat(point.y, \"px;\\n            transform: translate(-50%, -50%);\\n            color: red;\\n            font-size: 24px;\\n            font-weight: bold;\\n            text-shadow: 0 0 10px white, 0 0 20px white;\\n            z-index: 10000;\\n            background-color: rgba(255, 255, 255, 0.9);\\n            border: 2px solid red;\\n            border-radius: 50%;\\n            width: 48px;\\n            height: 48px;\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);\\n          \");\n                        document.body.appendChild(countdownElement);\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                                // Force redraw to ensure dot stays visible\n                                this.drawDot(point.x, point.y, radius);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                this.drawDot(point.x, point.y, radius);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"âœ“\";\n                            this.drawDot(point.x, point.y, radius);\n                            // Remove countdown element immediately\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Make sure dot is still visible\n                            this.drawDot(point.x, point.y, radius);\n                            // Capture images at this point\n                            console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_3__.captureImagesAtPoint)({\n                                point: point,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave_jsx__WEBPACK_IMPORTED_MODULE_2__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait a moment before clearing to ensure capture is complete\n                            await new Promise((resolve)=>setTimeout(resolve, 500));\n                            // Clear the dot after capture using canvas management system\n                            this.clearCanvas();\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                    }\n                    this.setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(\"Calibration error: \".concat(error.message));\n                } finally{\n                    // Exit fullscreen and restore canvas using canvas management system\n                    this.exitFullscreen();\n                    this.setIsCapturing(false);\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(true);\n                        }\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager and utilities from global scope (from actionButton.js)\n        this.canvasManager =  true ? window.canvasManager : 0;\n        this.canvasUtils =  true ? window.canvasUtils : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaURBQWlEO0FBRXZCO0FBQ29DO0FBQ2lCO0FBQ3JCO0FBRTFELE1BQU1NO0lBbUJKLCtFQUErRTtJQUMvRUMsWUFBWTtZQVlIO1FBWFAsb0RBQW9EO1FBQ3BELElBQUksSUFBSSxDQUFDQyxXQUFXLElBQUksT0FBTyxJQUFJLENBQUNBLFdBQVcsQ0FBQ0QsU0FBUyxLQUFLLFlBQVk7WUFDeEUsT0FBTyxJQUFJLENBQUNDLFdBQVcsQ0FBQ0QsU0FBUztRQUNuQztRQUVBLDRCQUE0QjtRQUM1QixJQUFJLElBQUksQ0FBQ0UsYUFBYSxJQUFJLE9BQU8sSUFBSSxDQUFDQSxhQUFhLENBQUNGLFNBQVMsS0FBSyxZQUFZO1lBQzVFLE9BQU8sSUFBSSxDQUFDRSxhQUFhLENBQUNGLFNBQVMsTUFBTSxJQUFJLENBQUNFLGFBQWEsQ0FBQ0MsWUFBWTtRQUMxRTtRQUVBLHVEQUF1RDtRQUN2RCxPQUFPLHdCQUFJLENBQUNDLFNBQVMsY0FBZCxzREFBZ0JDLE9BQU8sS0FBSUMsU0FBU0MsYUFBYSxDQUFDO0lBQzNEO0lBRUEsc0RBQXNEO0lBQ3REQyxrQkFBa0I7UUFDaEIsSUFBSSxJQUFJLENBQUNQLFdBQVcsSUFBSSxPQUFPLElBQUksQ0FBQ0EsV0FBVyxDQUFDTyxlQUFlLEtBQUssWUFBWTtZQUM5RSxPQUFPLElBQUksQ0FBQ1AsV0FBVyxDQUFDTyxlQUFlO1FBQ3pDO1FBRUEsSUFBSSxJQUFJLENBQUNOLGFBQWEsSUFBSSxPQUFPLElBQUksQ0FBQ0EsYUFBYSxDQUFDTSxlQUFlLEtBQUssWUFBWTtZQUNsRixJQUFJLENBQUNOLGFBQWEsQ0FBQ00sZUFBZTtZQUNsQyxPQUFPLElBQUksQ0FBQ04sYUFBYSxDQUFDRixTQUFTO1FBQ3JDO1FB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LElBQUksQ0FBQzVDLFNBQVMsR0FBRzBDLE9BQU8xQyxTQUFTO1FBQ2pDLElBQUksQ0FBQzRDLFlBQVksR0FBR0YsT0FBT0UsWUFBWTtRQUN2QyxJQUFJLENBQUNDLGNBQWMsR0FBR0gsT0FBT0csY0FBYztRQUMzQyxJQUFJLENBQUNDLGdCQUFnQixHQUFHSixPQUFPSSxnQkFBZ0I7UUFDL0MsSUFBSSxDQUFDa0MsYUFBYSxHQUFHdEMsT0FBT3NDLGFBQWE7UUFDekMsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR3ZDLE9BQU91QyxtQkFBbUI7UUFDckQsSUFBSSxDQUFDbEMsY0FBYyxHQUFHTCxPQUFPSyxjQUFjO1FBQzNDLElBQUksQ0FBQ21DLGlCQUFpQixHQUFHeEMsT0FBT3dDLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNSLGlCQUFpQixHQUFHaEMsT0FBT2dDLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNGLGNBQWMsR0FBRzlCLE9BQU84QixjQUFjO1FBRTNDLDRFQUE0RTtRQUM1RSxJQUFJLENBQUMxRSxhQUFhLEdBQUcsS0FBNkIsR0FBR2EsT0FBT2IsYUFBYSxHQUFHLENBQUk7UUFDaEYsSUFBSSxDQUFDRCxXQUFXLEdBQUcsS0FBNkIsR0FBR2MsT0FBT2QsV0FBVyxHQUFHLENBQUk7SUFDOUU7QUF5VkY7QUFFQSxpRUFBZUYsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXRDYWxpYnJhdGVBY3Rpb24uanN4XG4vLyBIYW5kbGVzIHRoZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZSBmdW5jdGlvbmFsaXR5XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSBmcm9tICcuL2NvdW50U2F2ZS5qc3gnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi9IZWxwZXIvc2F2ZWZpbGUnO1xuXG5jbGFzcyBTZXRDYWxpYnJhdGVBY3Rpb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvLyBSZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldElzQ2FwdHVyaW5nID0gY29uZmlnLnNldElzQ2FwdHVyaW5nO1xuICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyA9IGNvbmZpZy5zZXRQcm9jZXNzU3RhdHVzO1xuICAgIHRoaXMuc2V0Q3VycmVudERvdCA9IGNvbmZpZy5zZXRDdXJyZW50RG90O1xuICAgIHRoaXMudHJpZ2dlckNhbWVyYUFjY2VzcyA9IGNvbmZpZy50cmlnZ2VyQ2FtZXJhQWNjZXNzO1xuICAgIHRoaXMub25TdGF0dXNVcGRhdGUgPSBjb25maWcub25TdGF0dXNVcGRhdGU7XG4gICAgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlciA9IGNvbmZpZy5zYXZlSW1hZ2VUb1NlcnZlcjtcbiAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyID0gY29uZmlnLnNldENhcHR1cmVDb3VudGVyO1xuICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBjb25maWcuY2FwdHVyZUNvdW50ZXI7XG4gICAgXG4gICAgLy8gR2V0IGNhbnZhcyBtYW5hZ2VyIGFuZCB1dGlsaXRpZXMgZnJvbSBnbG9iYWwgc2NvcGUgKGZyb20gYWN0aW9uQnV0dG9uLmpzKVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICAgIHRoaXMuY2FudmFzVXRpbHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNVdGlscyA6IG51bGw7XG4gIH1cblxuICAvLyBHZXQgb3IgY3JlYXRlIGNhbnZhcyB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtIGZyb20gYWN0aW9uQnV0dG9uLmpzXG4gIGdldENhbnZhcygpIHtcbiAgICAvLyBGaXJzdCB0cnkgdG8gdXNlIGNhbnZhc1V0aWxzIGZyb20gYWN0aW9uQnV0dG9uLmpzXG4gICAgaWYgKHRoaXMuY2FudmFzVXRpbHMgJiYgdHlwZW9mIHRoaXMuY2FudmFzVXRpbHMuZ2V0Q2FudmFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNVdGlscy5nZXRDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzTWFuYWdlclxuICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIgJiYgdHlwZW9mIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCkgfHwgdGhpcy5jYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBjYW52YXNSZWYgaWYgY2FudmFzTWFuYWdlciBub3QgYXZhaWxhYmxlXG4gICAgcmV0dXJuIHRoaXMuY2FudmFzUmVmPy5jdXJyZW50IHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKTtcbiAgfVxuXG4gIC8vIEVudGVyIGZ1bGxzY3JlZW4gdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBlbnRlckZ1bGxzY3JlZW4oKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzVXRpbHMgJiYgdHlwZW9mIHRoaXMuY2FudmFzVXRpbHMuZW50ZXJGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNVdGlscy5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgdGhpcy5jYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbigpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGVudGVyIGZ1bGxzY3JlZW5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICB6LWluZGV4OiA5OTk5OTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICBgO1xuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBDbGVhciB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIC8vIEV4aXQgZnVsbHNjcmVlbiB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmV4aXRGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNVdGlscy5leGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLmNhbnZhc01hbmFnZXIuZXhpdEZ1bGxzY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGV4aXQgZnVsbHNjcmVlblxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluLWNvbnRlbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvLyBDbGVhciBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBjbGVhckNhbnZhcygpIHtcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5jbGVhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jYW52YXNVdGlscy5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLmNhbnZhc01hbmFnZXIuY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjazogbWFudWFsbHkgY2xlYXIgY2FudmFzXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRHJhdyBkb3QgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBkcmF3RG90KHgsIHksIHJhZGl1cyA9IDEyKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzVXRpbHMgJiYgdHlwZW9mIHRoaXMuY2FudmFzVXRpbHMuZHJhd0RvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVXRpbHMuZHJhd0RvdCh4LCB5LCByYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjazogbWFudWFsbHkgZHJhdyBkb3RcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHgsIHksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFdhaXQgdW50aWwgY2FudmFzIGlzIGZ1bGx5IHJlYWR5XG4gIGFzeW5jIHdhaXRGb3JDYW52YXMobWF4VHJpZXMgPSAyMCwgaW50ZXJ2YWwgPSAxMDApIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRyaWVzOyBpKyspIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICBpZiAoY2FudmFzICYmIGNhbnZhcy53aWR0aCA+IDAgJiYgY2FudmFzLmhlaWdodCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbnRlcnZhbCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IHJlYWR5IGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzXCIpO1xuICB9XG5cbiAgLy8gTWFpbiBmdW5jdGlvbiB0byBoYW5kbGUgY2FsaWJyYXRpb24gc2VxdWVuY2VcbiAgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc3RhcnRpbmcgY2FsaWJyYXRpb25cbiAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHBhcmVudCBjb21wb25lbnQgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMub25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIHRoaXMub25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aW1lIHRvIHVwZGF0ZVxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gYXdhaXQgdGhpcy53YWl0Rm9yQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVc2UgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtIHRvIGVudGVyIGZ1bGxzY3JlZW5cbiAgICAgICAgdGhpcy5lbnRlckZ1bGxzY3JlZW4oKTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgc3RhdHVzIGluZGljYXRvclxuICAgICAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgIGA7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbjogSW5pdGlhbGl6aW5nLi4uJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGRpc3BsYXlzXG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmQgdXNpbmcgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgICAgICAgdGhpcy5jbGVhckNhbnZhcygpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERyYXcgdGhlIGNhbGlicmF0aW9uIHBvaW50IHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDI0OyAvLyBMYXJnZXIgc2l6ZSBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICB0aGlzLmRyYXdEb3QocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgIGNvbnN0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmF3RG90KHBvaW50LngsIHBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50IHBvc2l0aW9uZWQgYXQgdGhlIHNhbWUgbG9jYXRpb24gYXMgdGhlIGRvdFxuICAgICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgICBsZWZ0OiAke3BvaW50Lnh9cHg7XG4gICAgICAgICAgICB0b3A6ICR7cG9pbnQueX1weDtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgICAgd2lkdGg6IDQ4cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDE1cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgICAgIGA7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICAgICAgdGhpcy5kcmF3RG90KHBvaW50LngsIHBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0XG4gICAgICAgICAgICAgIHRoaXMuZHJhd0RvdChwb2ludC54LCBwb2ludC55LCByYWRpdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgICAgICB0aGlzLmRyYXdEb3QocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgICB0aGlzLmRyYXdEb3QocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzKTtcblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtwb2ludC54fSwgJHtwb2ludC55fSlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICBjYXB0dXJlQ291bnQ6IHRoaXMuY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiB0aGlzLnNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWl0IGEgbW9tZW50IGJlZm9yZSBjbGVhcmluZyB0byBlbnN1cmUgY2FwdHVyZSBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZG90IGFmdGVyIGNhcHR1cmUgdXNpbmcgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKCk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYXIgcmVkcmF3IGludGVydmFsXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbGlicmF0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEV4aXQgZnVsbHNjcmVlbiBhbmQgcmVzdG9yZSBjYW52YXMgdXNpbmcgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgICAgIHRoaXMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgYSBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTtcbiAgICAgIH1cbiAgICB9LCAyMDApO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBTZXRDYWxpYnJhdGVBY3Rpb247ICJdLCJuYW1lcyI6WyJSZWFjdCIsImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJkcmF3UmVkRG90IiwicnVuQ291bnRkb3duIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJTZXRDYWxpYnJhdGVBY3Rpb24iLCJnZXRDYW52YXMiLCJjYW52YXNVdGlscyIsImNhbnZhc01hbmFnZXIiLCJjcmVhdGVDYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZW50ZXJGdWxsc2NyZWVuIiwiY2FudmFzIiwiYm9keSIsImFwcGVuZENoaWxkIiwic3R5bGUiLCJjc3NUZXh0Iiwid2lkdGgiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJleGl0RnVsbHNjcmVlbiIsImNvbnRhaW5lciIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInpJbmRleCIsImJhY2tncm91bmRDb2xvciIsImNsZWFyQ2FudmFzIiwiY2xlYXIiLCJjbGVhclJlY3QiLCJkcmF3RG90IiwieCIsInkiLCJyYWRpdXMiLCJ3YWl0Rm9yQ2FudmFzIiwibWF4VHJpZXMiLCJpbnRlcnZhbCIsImkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwidG9nZ2xlVG9wQmFyIiwic2V0SXNDYXB0dXJpbmciLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJwcm9jZXNzU3RhdHVzIiwiaXNDYXB0dXJpbmciLCJwb2ludHMiLCJsZW5ndGgiLCJzdGF0dXNJbmRpY2F0b3IiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwidGV4dENvbnRlbnQiLCJzdWNjZXNzQ291bnQiLCJwb2ludCIsInJlZHJhd0ludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJleGlzdGluZ0NvdW50ZG93bnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY291bnRkb3duRWxlbWVudCIsImNvdW50IiwiY29uc29sZSIsImxvZyIsImNhcHR1cmVSZXN1bHQiLCJjYXB0dXJlQ291bnQiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudGVyIiwic2NyZWVuSW1hZ2UiLCJzdWNjZXNzIiwiZXJyb3IiLCJjbGVhckludGVydmFsIiwibWVzc2FnZSIsInNldEN1cnJlbnREb3QiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwic2F2ZUltYWdlVG9TZXJ2ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\n"));

/***/ })

});