"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/ClearAllAction.js":
/*!**************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/ClearAllAction.js ***!
  \**************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useClearAll: () => (/* binding */ useClearAll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// components/Action/ClearAllAction.js\nvar _s = $RefreshSig$();\n\nconst useClearAll = (param)=>{\n    let { canvasRef, onStatusUpdate } = param;\n    _s();\n    // Clear the canvas\n    const clearCanvas = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useClearAll.useCallback[clearCanvas]\": ()=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n        }\n    }[\"useClearAll.useCallback[clearCanvas]\"], [\n        canvasRef\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useClearAll.useCallback[handleClearAll]\": ()=>{\n            clearCanvas();\n            // Reset status\n            onStatusUpdate({\n                processStatus: '',\n                remainingCaptures: 0,\n                isCapturing: false,\n                countdownValue: null\n            });\n            // Briefly show cleared message\n            onStatusUpdate({\n                processStatus: 'Canvas cleared'\n            });\n            // Clear the message after a delay\n            setTimeout({\n                \"useClearAll.useCallback[handleClearAll]\": ()=>{\n                    onStatusUpdate({\n                        processStatus: ''\n                    });\n                }\n            }[\"useClearAll.useCallback[handleClearAll]\"], 1500);\n        }\n    }[\"useClearAll.useCallback[handleClearAll]\"], [\n        clearCanvas,\n        onStatusUpdate\n    ]);\n    return {\n        clearCanvas,\n        handleAction: handleClearAll\n    };\n};\n_s(useClearAll, \"dI7u4oMCs0dkM8ZRzOO4GLKqW2Q=\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (useClearAll);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2xlYXJBbGxBY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLHNDQUFzQzs7QUFDRjtBQUU3QixNQUFNQyxjQUFjO1FBQUMsRUFBRUMsU0FBUyxFQUFFQyxjQUFjLEVBQUU7O0lBQ3ZELG1CQUFtQjtJQUNuQixNQUFNQyxjQUFjSixrREFBV0E7Z0RBQUM7WUFDOUIsTUFBTUssU0FBU0gsVUFBVUksT0FBTztZQUNoQyxJQUFJLENBQUNELFFBQVE7WUFFYixNQUFNRSxNQUFNRixPQUFPRyxVQUFVLENBQUM7WUFDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUdKLE9BQU9LLEtBQUssRUFBRUwsT0FBT00sTUFBTTtRQUNqRDsrQ0FBRztRQUFDVDtLQUFVO0lBRWQsc0NBQXNDO0lBQ3RDLE1BQU1VLGlCQUFpQlosa0RBQVdBO21EQUFDO1lBQ2pDSTtZQUVBLGVBQWU7WUFDZkQsZUFBZTtnQkFDYlUsZUFBZTtnQkFDZkMsbUJBQW1CO2dCQUNuQkMsYUFBYTtnQkFDYkMsZ0JBQWdCO1lBQ2xCO1lBRUEsK0JBQStCO1lBQy9CYixlQUFlO2dCQUNiVSxlQUFlO1lBQ2pCO1lBRUEsa0NBQWtDO1lBQ2xDSTsyREFBVztvQkFDVGQsZUFBZTt3QkFDYlUsZUFBZTtvQkFDakI7Z0JBQ0Y7MERBQUc7UUFDTDtrREFBRztRQUFDVDtRQUFhRDtLQUFlO0lBRWhDLE9BQU87UUFDTEM7UUFDQWMsY0FBY047SUFDaEI7QUFDRixFQUFFO0dBdkNXWDtBQXlDYixpRUFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NsZWFyQWxsQWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbXBvbmVudHMvQWN0aW9uL0NsZWFyQWxsQWN0aW9uLmpzXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGNvbnN0IHVzZUNsZWFyQWxsID0gKHsgY2FudmFzUmVmLCBvblN0YXR1c1VwZGF0ZSB9KSA9PiB7XG4gIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgY29uc3QgY2xlYXJDYW52YXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH0sIFtjYW52YXNSZWZdKTtcblxuICAvLyBDbGVhciBBbGwgQnV0dG9uIC0gUmVzZXQgZXZlcnl0aGluZ1xuICBjb25zdCBoYW5kbGVDbGVhckFsbCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjbGVhckNhbnZhcygpO1xuICAgIFxuICAgIC8vIFJlc2V0IHN0YXR1c1xuICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgIHByb2Nlc3NTdGF0dXM6ICcnLFxuICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IDAsXG4gICAgICBpc0NhcHR1cmluZzogZmFsc2UsXG4gICAgICBjb3VudGRvd25WYWx1ZTogbnVsbFxuICAgIH0pO1xuICAgIFxuICAgIC8vIEJyaWVmbHkgc2hvdyBjbGVhcmVkIG1lc3NhZ2VcbiAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FudmFzIGNsZWFyZWQnXG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ2xlYXIgdGhlIG1lc3NhZ2UgYWZ0ZXIgYSBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnJ1xuICAgICAgfSk7XG4gICAgfSwgMTUwMCk7XG4gIH0sIFtjbGVhckNhbnZhcywgb25TdGF0dXNVcGRhdGVdKTtcblxuICByZXR1cm4ge1xuICAgIGNsZWFyQ2FudmFzLFxuICAgIGhhbmRsZUFjdGlvbjogaGFuZGxlQ2xlYXJBbGxcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUNsZWFyQWxsOyJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUNsZWFyQWxsIiwiY2FudmFzUmVmIiwib25TdGF0dXNVcGRhdGUiLCJjbGVhckNhbnZhcyIsImNhbnZhcyIsImN1cnJlbnQiLCJjdHgiLCJnZXRDb250ZXh0IiwiY2xlYXJSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJoYW5kbGVDbGVhckFsbCIsInByb2Nlc3NTdGF0dXMiLCJyZW1haW5pbmdDYXB0dXJlcyIsImlzQ2FwdHVyaW5nIiwiY291bnRkb3duVmFsdWUiLCJzZXRUaW1lb3V0IiwiaGFuZGxlQWN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/ClearAllAction.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.js":
/*!***************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/RandomDotAction.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n// RandomDotActions.js\n// Handles the random dot generation and countdown functionality\n\nclass RandomDotActions {\n    constructor(config){\n        // Main function to handle random dot generation and capture\n        this.handleRandomDot = async ()=>{\n            // Hide the TopBar before showing dot\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Generating random dot...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Generating random dot...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                const canvas = this.canvasRef.current;\n                if (canvas) {\n                    // Make sure canvas dimensions are properly set\n                    const parent = canvas.parentElement;\n                    // if (!initializeCanvas(canvas, parent)) {\n                    //   console.error(\"Could not initialize canvas\");\n                    //   this.setProcessStatus('Error: Canvas initialization failed');\n                    //   this.setIsCapturing(false);\n                    //   return;\n                    // }\n                    if ( true && window.initializeCanvas) {\n                        window.initializeCanvas(canvas, parent);\n                    }\n                    // Generate random position\n                    const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.getRandomPosition)(canvas);\n                    // Draw the dot\n                    const ctx = canvas.getContext('2d');\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.drawRedDot)(ctx, position.x, position.y);\n                    // Store current dot position\n                    this.setCurrentDot(position);\n                    try {\n                        // Use the shared capture and preview process\n                        await (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.captureAndPreviewProcess)({\n                            canvasRef: this.canvasRef,\n                            position,\n                            captureCounter: this.captureCounter,\n                            saveImageToServer: this.saveImageToServer,\n                            setCaptureCounter: this.setCaptureCounter,\n                            setProcessStatus: this.setProcessStatus,\n                            toggleTopBar: this.toggleTopBar,\n                            onStatusUpdate: this.onStatusUpdate,\n                            captureFolder: 'eye_tracking_captures'\n                        });\n                        // Set capturing state to false after reasonable delay\n                        setTimeout(()=>{\n                            this.setIsCapturing(false);\n                        }, 2200); // Wait a bit longer than the preview duration\n                    } catch (error) {\n                        console.error(\"Error in capture and preview process:\", error);\n                        this.setProcessStatus('Error during capture process');\n                        this.setIsCapturing(false);\n                        // Clear error message after delay\n                        setTimeout(()=>{\n                            this.setProcessStatus('');\n                        }, 3000);\n                    }\n                } else {\n                    console.error(\"Canvas reference is null - cannot draw dot\");\n                    this.setProcessStatus('Error: Canvas not available');\n                    this.setIsCapturing(false);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RandomDotActions);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsc0JBQXNCO0FBQ3RCLGdFQUFnRTtBQU8zQztBQUdyQixNQUFNRztJQUNKQyxZQUFZQyxNQUFNLENBQUU7UUFjcEIsNERBQTREO2FBQzVEQyxrQkFBa0I7WUFDaEIscUNBQXFDO1lBQ3JDLElBQUksT0FBTyxJQUFJLENBQUNDLFlBQVksS0FBSyxZQUFZO2dCQUMzQyxJQUFJLENBQUNBLFlBQVksQ0FBQztZQUNwQixPQUFPLElBQUksS0FBNkIsSUFBSUMsT0FBT0QsWUFBWSxFQUFFO2dCQUMvREMsT0FBT0QsWUFBWSxDQUFDO1lBQ3RCO1lBRUEsSUFBSSxDQUFDRSxjQUFjLENBQUM7WUFDcEIsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQztZQUV0Qix1Q0FBdUM7WUFDdkMsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtnQkFDdkIsSUFBSSxDQUFDQSxjQUFjLENBQUM7b0JBQ2xCQyxlQUFlO29CQUNmQyxhQUFhO2dCQUNmO1lBQ0Y7WUFFQSxvQ0FBb0M7WUFDcENDLFdBQVc7Z0JBQ1QsTUFBTUMsU0FBUyxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTztnQkFDckMsSUFBSUYsUUFBUTtvQkFDViwrQ0FBK0M7b0JBQy9DLE1BQU1HLFNBQVNILE9BQU9JLGFBQWE7b0JBQ25DLDJDQUEyQztvQkFDM0Msa0RBQWtEO29CQUNsRCxrRUFBa0U7b0JBQ2xFLGdDQUFnQztvQkFDaEMsWUFBWTtvQkFDWixJQUFJO29CQUNKLElBQUksS0FBNkIsSUFBSVgsT0FBT1ksZ0JBQWdCLEVBQUU7d0JBQzVEWixPQUFPWSxnQkFBZ0IsQ0FBQ0wsUUFBUUc7b0JBQ2xDO29CQUVBLDJCQUEyQjtvQkFDM0IsTUFBTUcsV0FBV3JCLDZEQUFpQkEsQ0FBQ2U7b0JBRW5DLGVBQWU7b0JBQ2YsTUFBTU8sTUFBTVAsT0FBT1EsVUFBVSxDQUFDO29CQUM5QnRCLHNEQUFVQSxDQUFDcUIsS0FBS0QsU0FBU0csQ0FBQyxFQUFFSCxTQUFTSSxDQUFDO29CQUV0Qyw2QkFBNkI7b0JBQzdCLElBQUksQ0FBQ0MsYUFBYSxDQUFDTDtvQkFFbkIsSUFBSTt3QkFDRiw2Q0FBNkM7d0JBQzdDLE1BQU1uQixvRUFBd0JBLENBQUM7NEJBQzdCYyxXQUFXLElBQUksQ0FBQ0EsU0FBUzs0QkFDekJLOzRCQUNBTSxnQkFBZ0IsSUFBSSxDQUFDQSxjQUFjOzRCQUNuQ0MsbUJBQW1CLElBQUksQ0FBQ0EsaUJBQWlCOzRCQUN6Q0MsbUJBQW1CLElBQUksQ0FBQ0EsaUJBQWlCOzRCQUN6Q25CLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjs0QkFDdkNILGNBQWMsSUFBSSxDQUFDQSxZQUFZOzRCQUMvQkksZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNtQixlQUFlO3dCQUNqQjt3QkFFQSxzREFBc0Q7d0JBQ3REaEIsV0FBVzs0QkFDVCxJQUFJLENBQUNMLGNBQWMsQ0FBQzt3QkFDdEIsR0FBRyxPQUFPLDhDQUE4QztvQkFFMUQsRUFBRSxPQUFPc0IsT0FBTzt3QkFDZEMsUUFBUUQsS0FBSyxDQUFDLHlDQUF5Q0E7d0JBQ3ZELElBQUksQ0FBQ3JCLGdCQUFnQixDQUFDO3dCQUN0QixJQUFJLENBQUNELGNBQWMsQ0FBQzt3QkFFcEIsa0NBQWtDO3dCQUNsQ0ssV0FBVzs0QkFDVCxJQUFJLENBQUNKLGdCQUFnQixDQUFDO3dCQUN4QixHQUFHO29CQUNMO2dCQUNGLE9BQU87b0JBQ0xzQixRQUFRRCxLQUFLLENBQUM7b0JBQ2QsSUFBSSxDQUFDckIsZ0JBQWdCLENBQUM7b0JBQ3RCLElBQUksQ0FBQ0QsY0FBYyxDQUFDO2dCQUN0QjtZQUNGLEdBQUc7UUFDTDtRQTlGRSxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDTyxTQUFTLEdBQUdYLE9BQU9XLFNBQVM7UUFDakMsSUFBSSxDQUFDVCxZQUFZLEdBQUdGLE9BQU9FLFlBQVk7UUFDdkMsSUFBSSxDQUFDRSxjQUFjLEdBQUdKLE9BQU9JLGNBQWM7UUFDM0MsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0wsT0FBT0ssZ0JBQWdCO1FBQy9DLElBQUksQ0FBQ2dCLGFBQWEsR0FBR3JCLE9BQU9xQixhQUFhO1FBQ3pDLElBQUksQ0FBQ08sbUJBQW1CLEdBQUc1QixPQUFPNEIsbUJBQW1CO1FBQ3JELElBQUksQ0FBQ3RCLGNBQWMsR0FBR04sT0FBT00sY0FBYztRQUMzQyxJQUFJLENBQUNpQixpQkFBaUIsR0FBR3ZCLE9BQU91QixpQkFBaUI7UUFDakQsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR3hCLE9BQU93QixpQkFBaUI7UUFDakQsSUFBSSxDQUFDRixjQUFjLEdBQUd0QixPQUFPc0IsY0FBYztJQUM3QztBQW9GRjtBQUVBLGlFQUFleEIsZ0JBQWdCQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFJhbmRvbURvdEFjdGlvbnMuanNcbi8vIEhhbmRsZXMgdGhlIHJhbmRvbSBkb3QgZ2VuZXJhdGlvbiBhbmQgY291bnRkb3duIGZ1bmN0aW9uYWxpdHlcblxuaW1wb3J0IHtcbiAgLy8gaW5pdGlhbGl6ZUNhbnZhcyxcbiAgZ2V0UmFuZG9tUG9zaXRpb24sXG4gIGRyYXdSZWREb3QsXG4gIGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc1xufSBmcm9tICcuL2NvdW50U2F2ZSc7XG5cblxuY2xhc3MgUmFuZG9tRG90QWN0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8vIFJlcXVpcmVkIHByb3BlcnRpZXNcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcgPSBjb25maWcuc2V0SXNDYXB0dXJpbmc7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzID0gY29uZmlnLnNldFByb2Nlc3NTdGF0dXM7XG4gICAgdGhpcy5zZXRDdXJyZW50RG90ID0gY29uZmlnLnNldEN1cnJlbnREb3Q7XG4gICAgdGhpcy50cmlnZ2VyQ2FtZXJhQWNjZXNzID0gY29uZmlnLnRyaWdnZXJDYW1lcmFBY2Nlc3M7XG4gICAgdGhpcy5vblN0YXR1c1VwZGF0ZSA9IGNvbmZpZy5vblN0YXR1c1VwZGF0ZTtcbiAgICB0aGlzLnNhdmVJbWFnZVRvU2VydmVyID0gY29uZmlnLnNhdmVJbWFnZVRvU2VydmVyO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlcjtcbiAgfVxuXG4gIC8vIE1haW4gZnVuY3Rpb24gdG8gaGFuZGxlIHJhbmRvbSBkb3QgZ2VuZXJhdGlvbiBhbmQgY2FwdHVyZVxuICBoYW5kbGVSYW5kb21Eb3QgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzaG93aW5nIGRvdFxuICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnR2VuZXJhdGluZyByYW5kb20gZG90Li4uJyk7XG4gICAgXG4gICAgLy8gVXBkYXRlIHBhcmVudCBjb21wb25lbnQgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMub25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIHRoaXMub25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnR2VuZXJhdGluZyByYW5kb20gZG90Li4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGltZSB0byB1cGRhdGVcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgZGltZW5zaW9ucyBhcmUgcHJvcGVybHkgc2V0XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgICAvLyBpZiAoIWluaXRpYWxpemVDYW52YXMoY2FudmFzLCBwYXJlbnQpKSB7XG4gICAgICAgIC8vICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBpbml0aWFsaXplIGNhbnZhc1wiKTtcbiAgICAgICAgLy8gICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiBDYW52YXMgaW5pdGlhbGl6YXRpb24gZmFpbGVkJyk7XG4gICAgICAgIC8vICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgIC8vICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaW5pdGlhbGl6ZUNhbnZhcykge1xuICAgICAgICAgIHdpbmRvdy5pbml0aWFsaXplQ2FudmFzKGNhbnZhcywgcGFyZW50KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGRvdFxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcmUgY3VycmVudCBkb3QgcG9zaXRpb25cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50RG90KHBvc2l0aW9uKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBzaGFyZWQgY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzXG4gICAgICAgICAgYXdhaXQgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzKHtcbiAgICAgICAgICAgIGNhbnZhc1JlZjogdGhpcy5jYW52YXNSZWYsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGNhcHR1cmVDb3VudGVyOiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXI6IHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIsXG4gICAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcjogdGhpcy5zZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM6IHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgICAgIHRvZ2dsZVRvcEJhcjogdGhpcy50b2dnbGVUb3BCYXIsXG4gICAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogdGhpcy5vblN0YXR1c1VwZGF0ZSxcbiAgICAgICAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZSB0byBmYWxzZSBhZnRlciByZWFzb25hYmxlIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICB9LCAyMjAwKTsgLy8gV2FpdCBhIGJpdCBsb25nZXIgdGhhbiB0aGUgcHJldmlldyBkdXJhdGlvblxuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3M6XCIsIGVycm9yKTtcbiAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yIGR1cmluZyBjYXB0dXJlIHByb2Nlc3MnKTtcbiAgICAgICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBlcnJvciBtZXNzYWdlIGFmdGVyIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgICAgICAgIH0sIDMwMDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsIC0gY2Fubm90IGRyYXcgZG90XCIpO1xuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiBDYW52YXMgbm90IGF2YWlsYWJsZScpO1xuICAgICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LCAyMDApO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBSYW5kb21Eb3RBY3Rpb25zOyJdLCJuYW1lcyI6WyJnZXRSYW5kb21Qb3NpdGlvbiIsImRyYXdSZWREb3QiLCJjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MiLCJSYW5kb21Eb3RBY3Rpb25zIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJoYW5kbGVSYW5kb21Eb3QiLCJ0b2dnbGVUb3BCYXIiLCJ3aW5kb3ciLCJzZXRJc0NhcHR1cmluZyIsInNldFByb2Nlc3NTdGF0dXMiLCJvblN0YXR1c1VwZGF0ZSIsInByb2Nlc3NTdGF0dXMiLCJpc0NhcHR1cmluZyIsInNldFRpbWVvdXQiLCJjYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50IiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsImluaXRpYWxpemVDYW52YXMiLCJwb3NpdGlvbiIsImN0eCIsImdldENvbnRleHQiLCJ4IiwieSIsInNldEN1cnJlbnREb3QiLCJjYXB0dXJlQ291bnRlciIsInNhdmVJbWFnZVRvU2VydmVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJjYXB0dXJlRm9sZGVyIiwiZXJyb3IiLCJjb25zb2xlIiwidHJpZ2dlckNhbWVyYUFjY2VzcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.js":
/*!******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// Fixed SetRandomAction.js\n\n\nconst SetRandomAction = (param)=>{\n    let { canvasRef, onStatusUpdate, setCaptureCounter, toggleTopBar, captureCounter = 1, triggerCameraAccess } = param;\n    // Wait until canvas is fully ready\n    const waitForCanvas = async function() {\n        let maxTries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20, interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n        for(let i = 0; i < maxTries; i++){\n            const canvas = canvasRef.current;\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    };\n    // Main handler for Set Random button\n    const handleSetRandom = async ()=>{\n        try {\n            // Get control values from the TopBar\n            const timeInput = document.querySelector('.control-input-field');\n            const delayInput = document.querySelectorAll('.control-input-field')[1];\n            // Default values if inputs can't be found\n            let times = 1;\n            let delay = 3;\n            // Parse input values if available\n            if (timeInput) {\n                const parsedTime = parseInt(timeInput.value, 10);\n                if (!isNaN(parsedTime) && parsedTime > 0) {\n                    times = parsedTime;\n                }\n            }\n            if (delayInput) {\n                const parsedDelay = parseInt(delayInput.value, 10);\n                if (!isNaN(parsedDelay) && parsedDelay > 0) {\n                    delay = parsedDelay;\n                }\n            }\n            // Hide UI during capture process\n            if (toggleTopBar) toggleTopBar(false);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"),\n                isCapturing: true,\n                remainingCaptures: times\n            });\n            // Wait for canvas to be ready\n            const canvas = await waitForCanvas();\n            // Process all captures sequentially\n            let successCount = 0;\n            let currentCapture = 1;\n            while(currentCapture <= times){\n                // Update status for current capture\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Capture \".concat(currentCapture, \" of \").concat(times),\n                    remainingCaptures: times - currentCapture + 1,\n                    isCapturing: true\n                });\n                // Clear canvas before each capture\n                const ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                // Generate random position for this capture\n                const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.getRandomPosition)(canvas, 20);\n                // Draw the dot\n                (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.drawRedDot)(ctx, position.x, position.y);\n                // Create a redrawInterval to ensure dot stays visible\n                let redrawInterval = setInterval(()=>{\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.drawRedDot)(ctx, position.x, position.y, 12, false);\n                }, 200);\n                // Run countdown and wait for it to complete\n                await new Promise((resolve)=>{\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_0__.runCountdown)(position, canvas, (status)=>{\n                        // Update UI based on status\n                        if (status.processStatus) {\n                            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                                processStatus: \"Capture \".concat(currentCapture, \"/\").concat(times, \": \").concat(status.processStatus),\n                                remainingCaptures: times - currentCapture + 1,\n                                isCapturing: true\n                            });\n                        }\n                    }, resolve // This will be called when countdown completes\n                    );\n                });\n                // Clear redrawInterval after countdown\n                clearInterval(redrawInterval);\n                // Trigger camera access before capture\n                if (triggerCameraAccess) triggerCameraAccess(true);\n                // Wait briefly for camera to initialize\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Capture images at this point\n                try {\n                    const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n                        point: position,\n                        captureCount: captureCounter,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCounter,\n                        showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_0__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Increment counter\n                    if (setCaptureCounter) {\n                        setCaptureCounter((prev)=>prev + 1);\n                    }\n                } catch (error) {\n                    console.error(\"Error capturing point \".concat(currentCapture, \":\"), error);\n                }\n                // Wait between captures for the specified delay time\n                if (currentCapture < times) {\n                    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                        processStatus: \"Waiting \".concat(delay, \"s before next capture...\"),\n                        remainingCaptures: times - currentCapture,\n                        isCapturing: true\n                    });\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n                // Move to next capture\n                currentCapture++;\n            }\n            // Sequence complete\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"),\n                remainingCaptures: 0,\n                isCapturing: false\n            });\n            // Turn TopBar back on\n            if (toggleTopBar) {\n                toggleTopBar(true);\n            }\n        } catch (err) {\n            console.error('Random sequence error:', err);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Random sequence failed: \".concat(err.message),\n                isCapturing: false,\n                remainingCaptures: 0\n            });\n            // Make sure to restore the UI\n            if (toggleTopBar) toggleTopBar(true);\n        }\n    };\n    return {\n        handleAction: handleSetRandom\n    };\n};\n_c = SetRandomAction;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetRandomAction);\nvar _c;\n$RefreshReg$(_c, \"SetRandomAction\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDJCQUEyQjtBQUNtRTtBQUNwQztBQUUxRCxNQUFNSyxrQkFBa0I7UUFBQyxFQUN2QkMsU0FBUyxFQUNUQyxjQUFjLEVBQ2RDLGlCQUFpQixFQUNqQkMsWUFBWSxFQUNaQyxpQkFBaUIsQ0FBQyxFQUNsQkMsbUJBQW1CLEVBQ3BCO0lBQ0MsbUNBQW1DO0lBQ25DLE1BQU1DLGdCQUFnQjtZQUFPQyw0RUFBVyxJQUFJQyw0RUFBVztRQUNyRCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUUsSUFBSztZQUNqQyxNQUFNQyxTQUFTVixVQUFVVyxPQUFPO1lBQ2hDLElBQUlELFVBQVVBLE9BQU9FLEtBQUssR0FBRyxLQUFLRixPQUFPRyxNQUFNLEdBQUcsR0FBRztnQkFDbkQsT0FBT0g7WUFDVDtZQUNBLE1BQU0sSUFBSUksUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU1A7UUFDbkQ7UUFDQSxNQUFNLElBQUlTLE1BQU07SUFDbEI7SUFFQSxxQ0FBcUM7SUFDckMsTUFBTUMsa0JBQWtCO1FBQ3RCLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsTUFBTUMsWUFBWUMsU0FBU0MsYUFBYSxDQUFDO1lBQ3pDLE1BQU1DLGFBQWFGLFNBQVNHLGdCQUFnQixDQUFDLHVCQUF1QixDQUFDLEVBQUU7WUFFdkUsMENBQTBDO1lBQzFDLElBQUlDLFFBQVE7WUFDWixJQUFJQyxRQUFRO1lBRVosa0NBQWtDO1lBQ2xDLElBQUlOLFdBQVc7Z0JBQ2IsTUFBTU8sYUFBYUMsU0FBU1IsVUFBVVMsS0FBSyxFQUFFO2dCQUM3QyxJQUFJLENBQUNDLE1BQU1ILGVBQWVBLGFBQWEsR0FBRztvQkFDeENGLFFBQVFFO2dCQUNWO1lBQ0Y7WUFFQSxJQUFJSixZQUFZO2dCQUNkLE1BQU1R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QkFDckQsSUFBSXBCLGlCQUFpQlgsT0FBTztvQkFDMUJ2QiwyQkFBQUEscUNBQUFBLGVBQWlCO3dCQUNmOEIsZUFBZSxXQUFpQixPQUFOTixPQUFNO3dCQUNoQ1EsbUJBQW1CVCxRQUFRVzt3QkFDM0JILGFBQWE7b0JBQ2Y7b0JBRUEsTUFBTSxJQUFJbEIsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU1UsUUFBUTtnQkFDM0Q7Z0JBRUEsdUJBQXVCO2dCQUN2QlU7WUFDRjtZQUVBLG9CQUFvQjtZQUNwQmxDLDJCQUFBQSxxQ0FBQUEsZUFBaUI7Z0JBQ2Y4QixlQUFlLHNDQUFzRFAsT0FBaEJVLGNBQWEsS0FBUyxPQUFOVixPQUFNO2dCQUMzRVMsbUJBQW1CO2dCQUNuQkQsYUFBYTtZQUNmO1lBRUEsc0JBQXNCO1lBQ3RCLElBQUk3QixjQUFjO2dCQUNoQkEsYUFBYTtZQUNmO1FBRUYsRUFBRSxPQUFPc0QsS0FBSztZQUNaRCxRQUFRRCxLQUFLLENBQUMsMEJBQTBCRTtZQUN4Q3hELDJCQUFBQSxxQ0FBQUEsZUFBaUI7Z0JBQ2Y4QixlQUFlLDJCQUF1QyxPQUFaMEIsSUFBSUMsT0FBTztnQkFDckQxQixhQUFhO2dCQUNiQyxtQkFBbUI7WUFDckI7WUFFQSw4QkFBOEI7WUFDOUIsSUFBSTlCLGNBQWNBLGFBQWE7UUFDakM7SUFDRjtJQUVBLE9BQU87UUFDTHdELGNBQWN6QztJQUNoQjtBQUNGO0tBcExNbkI7QUFzTE4saUVBQWVBLGVBQWVBLEVBQUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9TZXRDYWxpYnJhdGVBY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRml4ZWQgU2V0UmFuZG9tQWN0aW9uLmpzXG5pbXBvcnQgeyBnZXRSYW5kb21Qb3NpdGlvbiwgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSBmcm9tICcuL2NvdW50U2F2ZSc7XG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uL0hlbHBlci9zYXZlZmlsZSc7XG5cbmNvbnN0IFNldFJhbmRvbUFjdGlvbiA9ICh7IFxuICBjYW52YXNSZWYsIFxuICBvblN0YXR1c1VwZGF0ZSwgXG4gIHNldENhcHR1cmVDb3VudGVyLFxuICB0b2dnbGVUb3BCYXIsXG4gIGNhcHR1cmVDb3VudGVyID0gMSxcbiAgdHJpZ2dlckNhbWVyYUFjY2Vzc1xufSkgPT4ge1xuICAvLyBXYWl0IHVudGlsIGNhbnZhcyBpcyBmdWxseSByZWFkeVxuICBjb25zdCB3YWl0Rm9yQ2FudmFzID0gYXN5bmMgKG1heFRyaWVzID0gMjAsIGludGVydmFsID0gMTAwKSA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmllczsgaSsrKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLndpZHRoID4gMCAmJiBjYW52YXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgcmVhZHkgYWZ0ZXIgbXVsdGlwbGUgYXR0ZW1wdHNcIik7XG4gIH07XG5cbiAgLy8gTWFpbiBoYW5kbGVyIGZvciBTZXQgUmFuZG9tIGJ1dHRvblxuICBjb25zdCBoYW5kbGVTZXRSYW5kb20gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBjb250cm9sIHZhbHVlcyBmcm9tIHRoZSBUb3BCYXJcbiAgICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkJyk7XG4gICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNvbnRyb2wtaW5wdXQtZmllbGQnKVsxXTtcbiAgICAgIFxuICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgaWYgaW5wdXRzIGNhbid0IGJlIGZvdW5kXG4gICAgICBsZXQgdGltZXMgPSAxO1xuICAgICAgbGV0IGRlbGF5ID0gMztcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgaW5wdXQgdmFsdWVzIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4ocGFyc2VkVGltZSkgJiYgcGFyc2VkVGltZSA+IDApIHtcbiAgICAgICAgICB0aW1lcyA9IHBhcnNlZFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRGVsYXkgPSBwYXJzZUludChkZWxheUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4ocGFyc2VkRGVsYXkpICYmIHBhcnNlZERlbGF5ID4gMCkge1xuICAgICAgICAgIGRlbGF5ID0gcGFyc2VkRGVsYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGlkZSBVSSBkdXJpbmcgY2FwdHVyZSBwcm9jZXNzXG4gICAgICBpZiAodG9nZ2xlVG9wQmFyKSB0b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYFN0YXJ0aW5nICR7dGltZXN9IHJhbmRvbSBjYXB0dXJlcyB3aXRoICR7ZGVsYXl9cyBkZWxheS4uLmAsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlLFxuICAgICAgICByZW1haW5pbmdDYXB0dXJlczogdGltZXNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBjYW52YXMgdG8gYmUgcmVhZHlcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHdhaXRGb3JDYW52YXMoKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbGwgY2FwdHVyZXMgc2VxdWVudGlhbGx5XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGxldCBjdXJyZW50Q2FwdHVyZSA9IDE7XG4gICAgICBcbiAgICAgIHdoaWxlIChjdXJyZW50Q2FwdHVyZSA8PSB0aW1lcykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0gb2YgJHt0aW1lc31gLFxuICAgICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiB0aW1lcyAtIGN1cnJlbnRDYXB0dXJlICsgMSxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBiZWZvcmUgZWFjaCBjYXB0dXJlXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvbiBmb3IgdGhpcyBjYXB0dXJlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgIGxldCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJ1biBjb3VudGRvd24gYW5kIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHJ1bkNvdW50ZG93bihcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgVUkgYmFzZWQgb24gc3RhdHVzXG4gICAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0vJHt0aW1lc306ICR7c3RhdHVzLnByb2Nlc3NTdGF0dXN9YCxcbiAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiB0aW1lcyAtIGN1cnJlbnRDYXB0dXJlICsgMSxcbiAgICAgICAgICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvbHZlIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbCBhZnRlciBjb3VudGRvd25cbiAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIGNhbWVyYSBhY2Nlc3MgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgaWYgKHRyaWdnZXJDYW1lcmFBY2Nlc3MpIHRyaWdnZXJDYW1lcmFBY2Nlc3ModHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJyaWVmbHkgZm9yIGNhbWVyYSB0byBpbml0aWFsaXplXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcbiAgICAgICAgICBpZiAoc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYXB0dXJpbmcgcG9pbnQgJHtjdXJyZW50Q2FwdHVyZX06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgZm9yIHRoZSBzcGVjaWZpZWQgZGVsYXkgdGltZVxuICAgICAgICBpZiAoY3VycmVudENhcHR1cmUgPCB0aW1lcykge1xuICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gLFxuICAgICAgICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IHRpbWVzIC0gY3VycmVudENhcHR1cmUsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSAqIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IGNhcHR1cmVcbiAgICAgICAgY3VycmVudENhcHR1cmUrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2VxdWVuY2UgY29tcGxldGVcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBgUmFuZG9tIGNhcHR1cmUgc2VxdWVuY2UgY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gY2FwdHVyZXMgc3VjY2Vzc2Z1bGAsXG4gICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiAwLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBUdXJuIFRvcEJhciBiYWNrIG9uXG4gICAgICBpZiAodG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignUmFuZG9tIHNlcXVlbmNlIGVycm9yOicsIGVycik7XG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYFJhbmRvbSBzZXF1ZW5jZSBmYWlsZWQ6ICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlLFxuICAgICAgICByZW1haW5pbmdDYXB0dXJlczogMFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byByZXN0b3JlIHRoZSBVSVxuICAgICAgaWYgKHRvZ2dsZVRvcEJhcikgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGhhbmRsZUFjdGlvbjogaGFuZGxlU2V0UmFuZG9tXG4gIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZXRSYW5kb21BY3Rpb247Il0sIm5hbWVzIjpbImdldFJhbmRvbVBvc2l0aW9uIiwiZHJhd1JlZERvdCIsInJ1bkNvdW50ZG93biIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiU2V0UmFuZG9tQWN0aW9uIiwiY2FudmFzUmVmIiwib25TdGF0dXNVcGRhdGUiLCJzZXRDYXB0dXJlQ291bnRlciIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVDb3VudGVyIiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsIndhaXRGb3JDYW52YXMiLCJtYXhUcmllcyIsImludGVydmFsIiwiaSIsImNhbnZhcyIsImN1cnJlbnQiLCJ3aWR0aCIsImhlaWdodCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkVycm9yIiwiaGFuZGxlU2V0UmFuZG9tIiwidGltZUlucHV0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZGVsYXlJbnB1dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJ0aW1lcyIsImRlbGF5IiwicGFyc2VkVGltZSIsInBhcnNlSW50IiwidmFsdWUiLCJpc05hTiIsInBhcnNlZERlbGF5IiwicHJvY2Vzc1N0YXR1cyIsImlzQ2FwdHVyaW5nIiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzdWNjZXNzQ291bnQiLCJjdXJyZW50Q2FwdHVyZSIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInBvc2l0aW9uIiwieCIsInkiLCJyZWRyYXdJbnRlcnZhbCIsInNldEludGVydmFsIiwic3RhdHVzIiwiY2xlYXJJbnRlcnZhbCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsInByZXYiLCJlcnJvciIsImNvbnNvbGUiLCJlcnIiLCJtZXNzYWdlIiwiaGFuZGxlQWN0aW9uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/SetRandomAction.js":
/*!***************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetRandomAction.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n// components/Action/SetRandomAction.js\n\nvar _s = $RefreshSig$();\n\nconst SetRandomAction = (param)=>{\n    let { canvasRef, onStatusUpdate } = param;\n    _s();\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Generate a random position on the canvas\n    const getRandomPosition = ()=>{\n        if (!canvasRef.current) return {\n            x: 0,\n            y: 0\n        };\n        const width = canvasRef.current.width;\n        const height = canvasRef.current.height;\n        return {\n            x: Math.floor(Math.random() * (width - 20)) + 10,\n            y: Math.floor(Math.random() * (height - 20)) + 10\n        };\n    };\n    // Draw a dot on the canvas\n    const drawDot = function(x, y) {\n        let color = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 'red', radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const ctx = canvas.getContext('2d');\n        // Clear previous dot\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw new dot\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = color;\n        ctx.fill();\n        return {\n            x,\n            y\n        }; // Return the position for reference\n    };\n    // Start countdown timer\n    const startCountdown = (count, onComplete)=>{\n        // Update status with countdown\n        onStatusUpdate({\n            processStatus: \"Countdown\",\n            countdownValue: count,\n            isCapturing: true\n        });\n        const timer = setTimeout(()=>{\n            if (count > 1) {\n                startCountdown(count - 1, onComplete);\n            } else {\n                // Final countdown step\n                onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    // Clear countdown\n                    onStatusUpdate({\n                        countdownValue: null\n                    });\n                    // Execute completion callback\n                    if (onComplete) onComplete();\n                }, 1000);\n            }\n        }, 800);\n        return ()=>clearTimeout(timer);\n    };\n    // Simulate capturing an image\n    const captureImage = (position)=>{\n        console.log('Capturing image at dot position:', position);\n        // In a real implementation, this would access the webcam and save\n        setTimeout(()=>{\n            onStatusUpdate({\n                isCapturing: false\n            });\n        }, 800);\n    };\n    // Generate multiple random dots\n    const scheduleMultipleCaptures = (remaining, times, delay)=>{\n        if (remaining <= 0) {\n            onStatusUpdate({\n                processStatus: 'Random capture sequence completed',\n                remainingCaptures: 0,\n                isCapturing: false\n            });\n            return;\n        }\n        onStatusUpdate({\n            processStatus: \"Capture \".concat(times - remaining + 1, \" of \").concat(times),\n            remainingCaptures: remaining\n        });\n        // Generate random position and draw dot\n        const position = getRandomPosition();\n        const dotPosition = drawDot(position.x, position.y);\n        // Start countdown and then capture\n        startCountdown(3, ()=>{\n            captureImage(dotPosition);\n            // Schedule next capture after delay\n            setTimeout(()=>{\n                scheduleMultipleCaptures(remaining - 1, times, delay);\n            }, delay * 1000);\n        });\n    };\n    // Main handler for Set Random button\n    const handleSetRandom = ()=>{\n        if (isCapturing) return;\n        // Parse input values\n        const times = parseInt(randomTimes);\n        const delay = parseInt(delaySeconds);\n        if (isNaN(times) || times <= 0 || isNaN(delay) || delay <= 0) {\n            alert(\"Please enter positive numbers for Times and Delay\");\n            return;\n        }\n        setIsCapturing(true);\n        // Update UI status\n        onStatusUpdate({\n            processStatus: \"Starting \".concat(times, \" random captures...\"),\n            remainingCaptures: times,\n            isCapturing: true\n        });\n        // Start capture sequence after a small delay\n        setTimeout(()=>{\n            scheduleMultipleCaptures(times, times, delay);\n        }, 100);\n    };\n    return {\n        component: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"set-random-action\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"input-controls flex mb-2\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"input-group mr-4\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    className: \"block text-sm mb-1\",\n                                    children: \"Times:\"\n                                }, void 0, false, {\n                                    fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                                    lineNumber: 151,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"number\",\n                                    value: randomTimes,\n                                    onChange: (e)=>setRandomTimes(e.target.value),\n                                    className: \"w-16 bg-mint-green p-1 border border-gray-300 rounded\",\n                                    min: \"1\",\n                                    disabled: isCapturing\n                                }, void 0, false, {\n                                    fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                                    lineNumber: 152,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                            lineNumber: 150,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"input-group\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    className: \"block text-sm mb-1\",\n                                    children: \"Delay(s):\"\n                                }, void 0, false, {\n                                    fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                                    lineNumber: 163,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"number\",\n                                    value: delaySeconds,\n                                    onChange: (e)=>setDelaySeconds(e.target.value),\n                                    className: \"w-16 bg-mint-green p-1 border border-gray-300 rounded\",\n                                    min: \"1\",\n                                    disabled: isCapturing\n                                }, void 0, false, {\n                                    fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                                    lineNumber: 164,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                            lineNumber: 162,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                    lineNumber: 149,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    onClick: handleSetRandom,\n                    disabled: isCapturing,\n                    className: \"app-button w-full\",\n                    style: {\n                        backgroundColor: '#7CFFDA',\n                        border: '1px solid #000',\n                        padding: '3px 10px',\n                        marginBottom: '5px',\n                        cursor: isCapturing ? 'not-allowed' : 'pointer',\n                        opacity: isCapturing ? 0.6 : 1\n                    },\n                    children: \"Set Random\"\n                }, void 0, false, {\n                    fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n                    lineNumber: 175,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/app/components/collected-dataset-customized/Action/SetRandomAction.js\",\n            lineNumber: 148,\n            columnNumber: 7\n        }, undefined),\n        isCapturing,\n        drawDot,\n        getRandomPosition,\n        startCountdown,\n        handleAction: handleSetRandom\n    };\n};\n_s(SetRandomAction, \"tEiK1XpQmYSJTkL9FW3+MOQbhJU=\");\n_c = SetRandomAction;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetRandomAction);\nvar _c;\n$RefreshReg$(_c, \"SetRandomAction\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0UmFuZG9tQWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsdUNBQXVDOzs7QUFDQztBQUV4QyxNQUFNRSxrQkFBa0I7UUFBQyxFQUFFQyxTQUFTLEVBQUVDLGNBQWMsRUFBRTs7SUFDcEQsTUFBTSxDQUFDQyxhQUFhQyxlQUFlLEdBQUdMLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ00sY0FBY0MsZ0JBQWdCLEdBQUdQLCtDQUFRQSxDQUFDO0lBQ2pELE1BQU0sQ0FBQ1EsYUFBYUMsZUFBZSxHQUFHVCwrQ0FBUUEsQ0FBQztJQUUvQywyQ0FBMkM7SUFDM0MsTUFBTVUsb0JBQW9CO1FBQ3hCLElBQUksQ0FBQ1IsVUFBVVMsT0FBTyxFQUFFLE9BQU87WUFBRUMsR0FBRztZQUFHQyxHQUFHO1FBQUU7UUFFNUMsTUFBTUMsUUFBUVosVUFBVVMsT0FBTyxDQUFDRyxLQUFLO1FBQ3JDLE1BQU1DLFNBQVNiLFVBQVVTLE9BQU8sQ0FBQ0ksTUFBTTtRQUV2QyxPQUFPO1lBQ0xILEdBQUdJLEtBQUtDLEtBQUssQ0FBQ0QsS0FBS0UsTUFBTSxLQUFNSixDQUFBQSxRQUFRLEVBQUMsS0FBTTtZQUM5Q0QsR0FBR0csS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxNQUFNLEtBQU1ILENBQUFBLFNBQVMsRUFBQyxLQUFNO1FBQ2pEO0lBQ0Y7SUFFQSwyQkFBMkI7SUFDM0IsTUFBTUksVUFBVSxTQUFDUCxHQUFHQztZQUFHTyx5RUFBUSxPQUFPQywwRUFBUztRQUM3QyxNQUFNQyxTQUFTcEIsVUFBVVMsT0FBTztRQUNoQyxJQUFJLENBQUNXLFFBQVE7UUFFYixNQUFNQyxNQUFNRCxPQUFPRSxVQUFVLENBQUM7UUFFOUIscUJBQXFCO1FBQ3JCRCxJQUFJRSxTQUFTLENBQUMsR0FBRyxHQUFHSCxPQUFPUixLQUFLLEVBQUVRLE9BQU9QLE1BQU07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OERBQUM4Qzs0QkFBSUMsV0FBVTs7OENBQ2IsOERBQUNDO29DQUFNRCxXQUFVOzhDQUFxQjs7Ozs7OzhDQUN0Qyw4REFBQ0U7b0NBQ0NDLE1BQUs7b0NBQ0xDLE9BQU9yRDtvQ0FDUHNELFVBQVUsQ0FBQ0MsSUFBTXRELGdCQUFnQnNELEVBQUVDLE1BQU0sQ0FBQ0gsS0FBSztvQ0FDL0NKLFdBQVU7b0NBQ1ZRLEtBQUk7b0NBQ0pDLFVBQVV4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhCQUtoQiw4REFBQ3lEO29CQUNDQyxTQUFTakI7b0JBQ1RlLFVBQVV4RDtvQkFDVitDLFdBQVU7b0JBQ1ZZLE9BQU87d0JBQ0xDLGlCQUFpQjt3QkFDakJDLFFBQVE7d0JBQ1JDLFNBQVM7d0JBQ1RDLGNBQWM7d0JBQ2RDLFFBQVFoRSxjQUFjLGdCQUFnQjt3QkFDdENpRSxTQUFTakUsY0FBYyxNQUFNO29CQUMvQjs4QkFDRDs7Ozs7Ozs7Ozs7O1FBS0xBO1FBQ0FXO1FBQ0FUO1FBQ0FxQjtRQUNBMkMsY0FBY3pCO0lBQ2hCO0FBQ0Y7R0FsTU1oRDtLQUFBQTtBQW9NTixpRUFBZUEsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL1NldFJhbmRvbUFjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21wb25lbnRzL0FjdGlvbi9TZXRSYW5kb21BY3Rpb24uanNcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgU2V0UmFuZG9tQWN0aW9uID0gKHsgY2FudmFzUmVmLCBvblN0YXR1c1VwZGF0ZSB9KSA9PiB7XG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gR2VuZXJhdGUgYSByYW5kb20gcG9zaXRpb24gb24gdGhlIGNhbnZhc1xuICBjb25zdCBnZXRSYW5kb21Qb3NpdGlvbiA9ICgpID0+IHtcbiAgICBpZiAoIWNhbnZhc1JlZi5jdXJyZW50KSByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgXG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXNSZWYuY3VycmVudC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXNSZWYuY3VycmVudC5oZWlnaHQ7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh3aWR0aCAtIDIwKSkgKyAxMCxcbiAgICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyMCkpICsgMTBcbiAgICB9O1xuICB9O1xuXG4gIC8vIERyYXcgYSBkb3Qgb24gdGhlIGNhbnZhc1xuICBjb25zdCBkcmF3RG90ID0gKHgsIHksIGNvbG9yID0gJ3JlZCcsIHJhZGl1cyA9IDUpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIFxuICAgIC8vIENsZWFyIHByZXZpb3VzIGRvdFxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICAvLyBEcmF3IG5ldyBkb3RcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBcbiAgICByZXR1cm4geyB4LCB5IH07IC8vIFJldHVybiB0aGUgcG9zaXRpb24gZm9yIHJlZmVyZW5jZVxuICB9O1xuXG4gIC8vIFN0YXJ0IGNvdW50ZG93biB0aW1lclxuICBjb25zdCBzdGFydENvdW50ZG93biA9IChjb3VudCwgb25Db21wbGV0ZSkgPT4ge1xuICAgIC8vIFVwZGF0ZSBzdGF0dXMgd2l0aCBjb3VudGRvd25cbiAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICBwcm9jZXNzU3RhdHVzOiBcIkNvdW50ZG93blwiLFxuICAgICAgY291bnRkb3duVmFsdWU6IGNvdW50LFxuICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKGNvdW50ID4gMSkge1xuICAgICAgICBzdGFydENvdW50ZG93bihjb3VudCAtIDEsIG9uQ29tcGxldGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmluYWwgY291bnRkb3duIHN0ZXBcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gQ2xlYXIgY291bnRkb3duXG4gICAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgICAgY291bnRkb3duVmFsdWU6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBFeGVjdXRlIGNvbXBsZXRpb24gY2FsbGJhY2tcbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkgb25Db21wbGV0ZSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICAgIH1cbiAgICB9LCA4MDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpO1xuICB9O1xuXG4gIC8vIFNpbXVsYXRlIGNhcHR1cmluZyBhbiBpbWFnZVxuICBjb25zdCBjYXB0dXJlSW1hZ2UgPSAocG9zaXRpb24pID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ2FwdHVyaW5nIGltYWdlIGF0IGRvdCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgXG4gICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGFjY2VzcyB0aGUgd2ViY2FtIGFuZCBzYXZlXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSwgODAwKTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBtdWx0aXBsZSByYW5kb20gZG90c1xuICBjb25zdCBzY2hlZHVsZU11bHRpcGxlQ2FwdHVyZXMgPSAocmVtYWluaW5nLCB0aW1lcywgZGVsYXkpID0+IHtcbiAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1JhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZCcsXG4gICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiAwLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICBwcm9jZXNzU3RhdHVzOiBgQ2FwdHVyZSAke3RpbWVzIC0gcmVtYWluaW5nICsgMX0gb2YgJHt0aW1lc31gLFxuICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IHJlbWFpbmluZ1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvbiBhbmQgZHJhdyBkb3RcbiAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJhbmRvbVBvc2l0aW9uKCk7XG4gICAgY29uc3QgZG90UG9zaXRpb24gPSBkcmF3RG90KHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgIFxuICAgIC8vIFN0YXJ0IGNvdW50ZG93biBhbmQgdGhlbiBjYXB0dXJlXG4gICAgc3RhcnRDb3VudGRvd24oMywgKCkgPT4ge1xuICAgICAgY2FwdHVyZUltYWdlKGRvdFBvc2l0aW9uKTtcbiAgICAgIFxuICAgICAgLy8gU2NoZWR1bGUgbmV4dCBjYXB0dXJlIGFmdGVyIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2NoZWR1bGVNdWx0aXBsZUNhcHR1cmVzKHJlbWFpbmluZyAtIDEsIHRpbWVzLCBkZWxheSk7XG4gICAgICB9LCBkZWxheSAqIDEwMDApO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIE1haW4gaGFuZGxlciBmb3IgU2V0IFJhbmRvbSBidXR0b25cbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIFBhcnNlIGlucHV0IHZhbHVlc1xuICAgIGNvbnN0IHRpbWVzID0gcGFyc2VJbnQocmFuZG9tVGltZXMpO1xuICAgIGNvbnN0IGRlbGF5ID0gcGFyc2VJbnQoZGVsYXlTZWNvbmRzKTtcbiAgICBcbiAgICBpZiAoaXNOYU4odGltZXMpIHx8IHRpbWVzIDw9IDAgfHwgaXNOYU4oZGVsYXkpIHx8IGRlbGF5IDw9IDApIHtcbiAgICAgIGFsZXJ0KFwiUGxlYXNlIGVudGVyIHBvc2l0aXZlIG51bWJlcnMgZm9yIFRpbWVzIGFuZCBEZWxheVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgXG4gICAgLy8gVXBkYXRlIFVJIHN0YXR1c1xuICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgIHByb2Nlc3NTdGF0dXM6IGBTdGFydGluZyAke3RpbWVzfSByYW5kb20gY2FwdHVyZXMuLi5gLFxuICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IHRpbWVzLFxuICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTdGFydCBjYXB0dXJlIHNlcXVlbmNlIGFmdGVyIGEgc21hbGwgZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNjaGVkdWxlTXVsdGlwbGVDYXB0dXJlcyh0aW1lcywgdGltZXMsIGRlbGF5KTtcbiAgICB9LCAxMDApO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgY29tcG9uZW50OiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInNldC1yYW5kb20tYWN0aW9uXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5wdXQtY29udHJvbHMgZmxleCBtYi0yXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbnB1dC1ncm91cCBtci00XCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBtYi0xXCI+VGltZXM6PC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgdmFsdWU9e3JhbmRvbVRpbWVzfVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFJhbmRvbVRpbWVzKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy0xNiBiZy1taW50LWdyZWVuIHAtMSBib3JkZXIgYm9yZGVyLWdyYXktMzAwIHJvdW5kZWRcIlxuICAgICAgICAgICAgICBtaW49XCIxXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e2lzQ2FwdHVyaW5nfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICBcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlucHV0LWdyb3VwXCI+XG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBtYi0xXCI+RGVsYXkocyk6PC9sYWJlbD5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgICAgdmFsdWU9e2RlbGF5U2Vjb25kc31cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXREZWxheVNlY29uZHMoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTE2IGJnLW1pbnQtZ3JlZW4gcC0xIGJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZFwiXG4gICAgICAgICAgICAgIG1pbj1cIjFcIlxuICAgICAgICAgICAgICBkaXNhYmxlZD17aXNDYXB0dXJpbmd9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgXG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTZXRSYW5kb219XG4gICAgICAgICAgZGlzYWJsZWQ9e2lzQ2FwdHVyaW5nfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImFwcC1idXR0b24gdy1mdWxsXCJcbiAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzdDRkZEQScsXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgIzAwMCcsXG4gICAgICAgICAgICBwYWRkaW5nOiAnM3B4IDEwcHgnLFxuICAgICAgICAgICAgbWFyZ2luQm90dG9tOiAnNXB4JyxcbiAgICAgICAgICAgIGN1cnNvcjogaXNDYXB0dXJpbmcgPyAnbm90LWFsbG93ZWQnIDogJ3BvaW50ZXInLFxuICAgICAgICAgICAgb3BhY2l0eTogaXNDYXB0dXJpbmcgPyAwLjYgOiAxXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIFNldCBSYW5kb21cbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICApLFxuICAgIGlzQ2FwdHVyaW5nLFxuICAgIGRyYXdEb3QsXG4gICAgZ2V0UmFuZG9tUG9zaXRpb24sXG4gICAgc3RhcnRDb3VudGRvd24sXG4gICAgaGFuZGxlQWN0aW9uOiBoYW5kbGVTZXRSYW5kb21cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNldFJhbmRvbUFjdGlvbjsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsIlNldFJhbmRvbUFjdGlvbiIsImNhbnZhc1JlZiIsIm9uU3RhdHVzVXBkYXRlIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJnZXRSYW5kb21Qb3NpdGlvbiIsImN1cnJlbnQiLCJ4IiwieSIsIndpZHRoIiwiaGVpZ2h0IiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiZHJhd0RvdCIsImNvbG9yIiwicmFkaXVzIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0YXJ0Q291bnRkb3duIiwiY291bnQiLCJvbkNvbXBsZXRlIiwicHJvY2Vzc1N0YXR1cyIsImNvdW50ZG93blZhbHVlIiwidGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiY2FwdHVyZUltYWdlIiwicG9zaXRpb24iLCJjb25zb2xlIiwibG9nIiwic2NoZWR1bGVNdWx0aXBsZUNhcHR1cmVzIiwicmVtYWluaW5nIiwidGltZXMiLCJkZWxheSIsInJlbWFpbmluZ0NhcHR1cmVzIiwiZG90UG9zaXRpb24iLCJoYW5kbGVTZXRSYW5kb20iLCJwYXJzZUludCIsImlzTmFOIiwiYWxlcnQiLCJjb21wb25lbnQiLCJkaXYiLCJjbGFzc05hbWUiLCJsYWJlbCIsImlucHV0IiwidHlwZSIsInZhbHVlIiwib25DaGFuZ2UiLCJlIiwidGFyZ2V0IiwibWluIiwiZGlzYWJsZWQiLCJidXR0b24iLCJvbkNsaWNrIiwic3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJwYWRkaW5nIiwibWFyZ2luQm90dG9tIiwiY3Vyc29yIiwib3BhY2l0eSIsImhhbmRsZUFjdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/SetRandomAction.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/index.js":
/*!*****************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/index.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClearAllAction: () => (/* reexport safe */ _ClearAllAction__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   RandomDotAction: () => (/* reexport safe */ _RandomDotAction__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   SetCalibrateAction: () => (/* reexport safe */ _SetCalibrateAction__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   SetRandomAction: () => (/* reexport safe */ _SetRandomAction__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _SetRandomAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SetRandomAction */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/SetRandomAction.js\");\n/* harmony import */ var _RandomDotAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RandomDotAction */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.js\");\n/* harmony import */ var _SetCalibrateAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SetCalibrateAction */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.js\");\n/* harmony import */ var _ClearAllAction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ClearAllAction */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/ClearAllAction.js\");\n// components/Action/index.js\n\n\n\n\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDbUI7QUFDQTtBQUNNO0FBQ1I7QUFPNUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb21wb25lbnRzL0FjdGlvbi9pbmRleC5qc1xuaW1wb3J0IFNldFJhbmRvbUFjdGlvbiBmcm9tICcuL1NldFJhbmRvbUFjdGlvbic7XG5pbXBvcnQgUmFuZG9tRG90QWN0aW9uIGZyb20gJy4vUmFuZG9tRG90QWN0aW9uJztcbmltcG9ydCBTZXRDYWxpYnJhdGVBY3Rpb24gZnJvbSAnLi9TZXRDYWxpYnJhdGVBY3Rpb24nO1xuaW1wb3J0IENsZWFyQWxsQWN0aW9uIGZyb20gJy4vQ2xlYXJBbGxBY3Rpb24nO1xuXG5leHBvcnQge1xuICBTZXRSYW5kb21BY3Rpb24sXG4gIFJhbmRvbURvdEFjdGlvbixcbiAgU2V0Q2FsaWJyYXRlQWN0aW9uLFxuICBDbGVhckFsbEFjdGlvblxufTsiXSwibmFtZXMiOlsiU2V0UmFuZG9tQWN0aW9uIiwiUmFuZG9tRG90QWN0aW9uIiwiU2V0Q2FsaWJyYXRlQWN0aW9uIiwiQ2xlYXJBbGxBY3Rpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/index.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Import the action classes (optional - for future integration)\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 94,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 91,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Global canvas manager instance - initialize only once\n    const canvasManager = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[canvasManager]\": ()=>new CanvasManager()\n    }[\"ActionButtonGroupInner.useMemo[canvasManager]\"], []);\n    // Replace the complex canvas functions with simplified versions\n    const getMainCanvas = ()=>{\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    };\n    const ensureCanvasExists = ()=>{\n        return canvasManager.createCanvas();\n    };\n    const restoreCanvasToContainer = (canvas)=>{\n        canvasManager.exitFullscreen();\n    };\n    const cleanupCanvas = ()=>{\n        canvasManager.destroy();\n    };\n    const clearCanvas = ()=>{\n        canvasManager.clear();\n    };\n    // Utility function to easily manage canvas operations\n    const canvasUtils = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>({\n                // Get or create canvas\n                getCanvas: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>canvasManager.getCanvas() || canvasManager.createCanvas()\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Enter fullscreen mode\n                enterFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.enterFullscreen();\n                        return canvasManager.getCanvas();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Exit fullscreen mode\n                exitFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.exitFullscreen();\n                        return canvasManager.getCanvas();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Clear canvas\n                clear: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.clear();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Draw dot at position\n                drawDot: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": function(x, y) {\n                        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas) return false;\n                        const ctx = canvas.getContext('2d');\n                        (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, x, y, radius, false);\n                        return true;\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Get canvas dimensions\n                getDimensions: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas) return {\n                            width: 0,\n                            height: 0\n                        };\n                        return {\n                            width: canvas.width,\n                            height: canvas.height\n                        };\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Check if canvas is in fullscreen\n                isFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>canvasManager.isInFullscreen()\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Update canvas size to match container\n                resizeToContainer: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": (container)=>{\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas || !container) return false;\n                        const rect = container.getBoundingClientRect();\n                        canvas.width = rect.width || container.clientWidth || 800;\n                        canvas.height = rect.height || container.clientHeight || 600;\n                        // Clear and redraw white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        return true;\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"]\n            })\n    }[\"ActionButtonGroupInner.useMemo[canvasUtils]\"], []);\n    // Make canvas utilities globally available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (true) {\n                window.canvasUtils = canvasUtils;\n                window.canvasManager = canvasManager;\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.canvasUtils;\n                        delete window.canvasManager;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        canvasUtils,\n        canvasManager\n    ]);\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Only initialize if canvas doesn't exist\n            if (!document.querySelector('#tracking-canvas')) {\n                const canvas = getMainCanvas();\n                console.log('Canvas initialized:', canvas ? 'success' : 'failed');\n            }\n            // Cleanup function\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    // Don't remove canvas on cleanup to prevent recreation issues\n                    console.log('ActionButton cleanup - canvas preserved');\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Initialize canvas on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const initializeCanvas = {\n                \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                    // Remove any existing canvas\n                    const existingCanvas = document.querySelector('.tracking-canvas');\n                    if (existingCanvas) {\n                        existingCanvas.remove();\n                    }\n                    // Create new canvas\n                    const canvas = document.createElement('canvas');\n                    canvas.className = 'tracking-canvas';\n                    canvas.id = 'tracking-canvas';\n                    canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        opacity: 0;\\n        pointer-events: none;\\n        z-index: 5;\\n      \";\n                    // Set canvas dimensions\n                    canvas.width = window.innerWidth;\n                    canvas.height = window.innerHeight;\n                    // Add canvas to body\n                    document.body.appendChild(canvas);\n                    // Store reference\n                    canvasRef.current = canvas;\n                    if (true) {\n                        window.whiteScreenCanvas = canvas;\n                    }\n                    // Initialize with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Add resize handler\n                    const handleResize = {\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\": ()=>{\n                            canvas.width = window.innerWidth;\n                            canvas.height = window.innerHeight;\n                            ctx.fillStyle = 'white';\n                            ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        }\n                    }[\"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\"];\n                    window.addEventListener('resize', handleResize);\n                    return ({\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                            window.removeEventListener('resize', handleResize);\n                            if (canvas.parentNode) {\n                                canvas.parentNode.removeChild(canvas);\n                            }\n                        }\n                    })[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n                }\n            }[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n            const cleanup = initializeCanvas();\n            return cleanup;\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Simplified Canvas Manager - More flexible and maintainable\n    class CanvasManager {\n        // Create or get canvas with automatic sizing\n        createCanvas() {\n            let container = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n            // Try to find existing canvas first\n            let canvas = document.querySelector('#tracking-canvas');\n            if (!canvas) {\n                canvas = document.createElement('canvas');\n                canvas.className = 'tracking-canvas';\n                canvas.id = 'tracking-canvas';\n            }\n            // Determine container\n            const targetContainer = container || document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            // Set initial dimensions based on container\n            this.updateCanvasSize(canvas, targetContainer);\n            // Initialize with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Add to container if not already there\n            if (!canvas.parentNode) {\n                targetContainer.appendChild(canvas);\n            }\n            // Store reference\n            this.canvas = canvas;\n            window.whiteScreenCanvas = canvas;\n            // Set up responsive behavior\n            this.setupResponsiveCanvas(canvas, targetContainer);\n            console.log(\"Canvas created/updated: \".concat(canvas.width, \"x\").concat(canvas.height));\n            return canvas;\n        }\n        // Update canvas size to match container\n        updateCanvasSize(canvas, container) {\n            if (!canvas || !container) return;\n            const rect = container.getBoundingClientRect();\n            const width = rect.width || container.clientWidth || 800;\n            const height = rect.height || container.clientHeight || 600;\n            canvas.width = width;\n            canvas.height = height;\n            // Update CSS to match\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.display = 'block';\n            canvas.style.backgroundColor = 'white';\n        }\n        // Set up responsive canvas that adapts to container size\n        setupResponsiveCanvas(canvas, container) {\n            if (!canvas || !container) return;\n            // Remove existing resize observer\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            // Create new resize observer\n            this.resizeObserver = new ResizeObserver((entries)=>{\n                for (const entry of entries){\n                    if (entry.target === container) {\n                        this.updateCanvasSize(canvas, container);\n                        // Redraw white background after resize\n                        const ctx = canvas.getContext('2d');\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    }\n                }\n            });\n            // Observe container for size changes\n            this.resizeObserver.observe(container);\n            // Also listen for window resize as fallback\n            const handleWindowResize = ()=>{\n                this.updateCanvasSize(canvas, container);\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            };\n            window.addEventListener('resize', handleWindowResize);\n            canvas._windowResizeHandler = handleWindowResize;\n        }\n        // Switch to fullscreen mode\n        enterFullscreen() {\n            if (!this.canvas) {\n                this.canvas = this.createCanvas();\n            }\n            // Save original state\n            this.originalState = {\n                parent: this.canvas.parentElement,\n                position: this.canvas.style.position,\n                top: this.canvas.style.top,\n                left: this.canvas.style.left,\n                width: this.canvas.style.width,\n                height: this.canvas.style.height,\n                zIndex: this.canvas.style.zIndex\n            };\n            // Move to body and make fullscreen\n            document.body.appendChild(this.canvas);\n            // Set fullscreen styles\n            this.canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        z-index: 99999;\\n        background-color: white;\\n        border: none;\\n        display: block;\\n        opacity: 1;\\n        pointer-events: auto;\\n        margin: 0;\\n        padding: 0;\\n        box-sizing: border-box;\\n      \";\n            // Set canvas dimensions to window size\n            this.canvas.width = window.innerWidth;\n            this.canvas.height = window.innerHeight;\n            // Clear with white background\n            const ctx = this.canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Hide UI elements\n            this.hideUIElements();\n            this.isFullscreen = true;\n            console.log('Canvas entered fullscreen mode');\n        }\n        // Exit fullscreen mode\n        exitFullscreen() {\n            if (!this.canvas || !this.originalState) return;\n            // Show UI elements\n            this.showUIElements();\n            // Find appropriate container\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            // Move canvas back to container\n            container.appendChild(this.canvas);\n            // Restore original styles\n            this.canvas.style.position = 'relative';\n            this.canvas.style.top = '';\n            this.canvas.style.left = '';\n            this.canvas.style.width = '100%';\n            this.canvas.style.height = '100%';\n            this.canvas.style.zIndex = '';\n            this.canvas.style.backgroundColor = 'white';\n            // Update size to match container\n            this.updateCanvasSize(this.canvas, container);\n            // Clear with white background\n            const ctx = this.canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Clear original state\n            this.originalState = null;\n            this.isFullscreen = false;\n            console.log('Canvas exited fullscreen mode');\n        }\n        // Hide UI elements during fullscreen\n        hideUIElements() {\n            const elementsToHide = [\n                '.topbar',\n                '.canvas-container',\n                '.main-content',\n                '.metrics-panel',\n                '.display-metrics',\n                'nav',\n                'header',\n                '.button-groups',\n                '.control-buttons'\n            ];\n            elementsToHide.forEach((selector)=>{\n                const elements = document.querySelectorAll(selector);\n                elements.forEach((el)=>{\n                    el.style.display = 'none';\n                    el.setAttribute('data-hidden-by-canvas', 'true');\n                });\n            });\n        }\n        // Show UI elements after fullscreen\n        showUIElements() {\n            const hiddenElements = document.querySelectorAll('[data-hidden-by-canvas=\"true\"]');\n            hiddenElements.forEach((el)=>{\n                el.style.display = '';\n                el.removeAttribute('data-hidden-by-canvas');\n            });\n        }\n        // Clear canvas content\n        clear() {\n            if (!this.canvas) return;\n            const ctx = this.canvas.getContext('2d');\n            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n        // Cleanup\n        destroy() {\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            if (this.canvas && this.canvas._windowResizeHandler) {\n                window.removeEventListener('resize', this.canvas._windowResizeHandler);\n            }\n            if (this.canvas && this.canvas.parentNode) {\n                this.canvas.parentNode.removeChild(this.canvas);\n            }\n            if (window.whiteScreenCanvas === this.canvas) {\n                delete window.whiteScreenCanvas;\n            }\n            this.canvas = null;\n            this.originalState = null;\n            this.isFullscreen = false;\n        }\n        // Get current canvas\n        getCanvas() {\n            return this.canvas;\n        }\n        // Check if canvas is in fullscreen mode\n        isInFullscreen() {\n            return this.isFullscreen;\n        }\n        constructor(){\n            this.canvas = null;\n            this.originalState = null;\n            this.resizeObserver = null;\n            this.isFullscreen = false;\n        }\n    }\n    // Modified handleDotProcess function with improved dot and countdown alignment\n    // Complete handleDotProcess function with proper canvas management\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        let canvas = null;\n        let keepDotVisibleInterval = null;\n        let countdownElement = null;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Use ensureCanvasExists to get or create canvas\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                throw new Error(\"Failed to create or find canvas\");\n            }\n            // Canvas is already set to fullscreen by ensureCanvasExists\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n            // Get context and clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement && countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        } finally{\n            // Clear redraw interval first\n            if (keepDotVisibleInterval) {\n                clearInterval(keepDotVisibleInterval);\n                keepDotVisibleInterval = null;\n            }\n            // Remove countdown element if it still exists\n            if (countdownElement && countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Remove any remaining countdown elements\n            const remainingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            remainingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Use restoreCanvasToContainer to properly restore canvas\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for calibration');\n                return;\n            }\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"✓\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for set random');\n                return;\n            }\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            const canvas = document.querySelector('#tracking-canvas');\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for random dot');\n                return;\n            }\n            // Use the consolidated function with random position\n            await handleDotProcess({\n                useRandomPosition: true,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                },\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                triggerCameraAccess,\n                setIsCapturing,\n                captureCount,\n                setCaptureCount: setCaptureCount,\n                postCountdownDelay: 1000\n            });\n        } catch (error) {\n            console.error('Random dot error:', error);\n        } finally{\n            // Clean up canvas after process completes\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 2000); // Wait 2 seconds before cleanup\n        }\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        if (!canvas) return null;\n        // Save original state if not already saved\n        if (!canvas._originalState) {\n            canvas._originalState = {\n                parent: canvas.parentElement,\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex,\n                canvasWidth: canvas.width,\n                canvasHeight: canvas.height\n            };\n        }\n        // Move to body and make fullscreen\n        document.body.appendChild(canvas);\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '10';\n        canvas.style.backgroundColor = 'white';\n        // Set canvas dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        return canvas;\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        // Clear canvas content\n        const canvas = document.querySelector('#tracking-canvas');\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Restore canvas to container mode\n            restoreCanvasToContainer(canvas);\n        }\n        // Reset states\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n        setCurrentDot(null);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1652,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1651,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1656,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1655,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1687,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1697,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1715,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1728,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1707,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1677,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1662,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1649,\n        columnNumber: 5\n    }, undefined);\n}, \"3m6WU+NWDgNRt++RkwBY6SLMuUQ=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1750,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRztBQUNsRTtBQUNpRjtBQU96QztBQUM2QjtBQUNoRTtBQUNXO0FBRW5ELGdFQUFnRTtBQUMyQztBQUUzRyw4QkFBOEI7QUFDOUIsTUFBTW1CLFVBQVUsQ0FBQ0MsTUFBTUM7SUFDckIsSUFBSUQsU0FBU0MsTUFBTSxPQUFPO0lBQzFCLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9DLFNBQVMsVUFBVSxPQUFPO0lBQ2pFLElBQUlELFNBQVMsUUFBUUMsU0FBUyxNQUFNLE9BQU87SUFFM0MsTUFBTUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSjtJQUMxQixNQUFNSyxRQUFRRixPQUFPQyxJQUFJLENBQUNIO0lBRTFCLElBQUlDLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFLE9BQU87SUFFMUMsT0FBT0osTUFBTUssS0FBSyxDQUFDQyxDQUFBQSxNQUNqQkgsTUFBTUksUUFBUSxDQUFDRCxRQUFRVCxRQUFRQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO0FBRXZEO0FBRUEsMERBQTBEO0FBQzFELE1BQU1FLGVBQWU7UUFBQyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsRUFBRUMsT0FBTyxFQUFFQyxjQUFjLEVBQUUsRUFBRUMsV0FBVyxLQUFLLEVBQUVDLFNBQVMsS0FBSyxFQUFFOztJQUMxRyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHckMsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxFQUFFc0MsUUFBUSxFQUFFLEdBQUd2QixnRUFBZ0JBO0lBQ3JDLE1BQU0sQ0FBQ3dCLGVBQWVDLGlCQUFpQixHQUFHeEMsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDeUMsYUFBYUMsZUFBZSxHQUFHMUMsK0NBQVFB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QUFFbVAsS0FBSztBQUFNOztBQUNoQixvREFBb0Q7QUFDcEQsb0dBQW9HO0FBRXBHLCtCQUErQjtBQUNoQixTQUFTQztJQUN0QixPQUFPLE1BQU0sOERBQThEO0FBQzdFO01BRndCQTtBQUltQiIsInNvdXJjZXMiOlsiL2FwcC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FjdGlvbkJ1dHRvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBcbiAgc2hvd0NhcHR1cmVQcmV2aWV3LCBcbiAgZHJhd1JlZERvdCwgXG4gIGdldFJhbmRvbVBvc2l0aW9uLFxuICBjcmVhdGVDb3VudGRvd25FbGVtZW50LFxuICBydW5Db3VudGRvd25cbn0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCB7IHVzZUFkbWluU2V0dGluZ3MgfSBmcm9tICcuL2FkbWluU2V0dGluZ3MnO1xuXG4vLyBJbXBvcnQgdGhlIGFjdGlvbiBjbGFzc2VzIChvcHRpb25hbCAtIGZvciBmdXR1cmUgaW50ZWdyYXRpb24pXG5pbXBvcnQgeyBSYW5kb21Eb3RBY3Rpb24sIFNldFJhbmRvbUFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24nO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuLy8gQ3JlYXRlIGEgYmFzaWMgQWN0aW9uQnV0dG9uIGNvbXBvbmVudCB3aXRoIG9wdGltaXphdGlvblxuY29uc3QgQWN0aW9uQnV0dG9uID0gKHsgdGV4dCwgYWJicmV2aWF0ZWRUZXh0LCBvbkNsaWNrLCBjdXN0b21DbGFzcyA9ICcnLCBkaXNhYmxlZCA9IGZhbHNlLCBhY3RpdmUgPSBmYWxzZSB9KSA9PiB7XG4gIGNvbnN0IFtpc0FiYnJldmlhdGVkLCBzZXRJc0FiYnJldmlhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncygpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIHByb3BzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICBjb25zdCBidXR0b25Qcm9wcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjbGFzc05hbWU6IGBhY3Rpb24tYnV0dG9uICR7Y3VzdG9tQ2xhc3N9ICR7aXNBYmJyZXZpYXRlZCA/ICdhYmJyZXZpYXRlZCcgOiAnJ30gJHthY3RpdmUgPyAnYWN0aXZlJyA6ICcnfWAsXG4gICAgb25DbGljayxcbiAgICBkaXNhYmxlZCxcbiAgICB0aXRsZTogdGV4dFxuICB9KSwgW2N1c3RvbUNsYXNzLCBpc0FiYnJldmlhdGVkLCBhY3RpdmUsIG9uQ2xpY2ssIGRpc2FibGVkLCB0ZXh0XSk7XG5cbiAgLy8gQ2hlY2sgd2luZG93IHNpemUgYW5kIHNldCBhYmJyZXZpYXRlZCBtb2RlIHdpdGggZGVib3VuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHNldElzQWJicmV2aWF0ZWQod2lkdGggPCA3NjgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIGhhbmRsZVJlc2l6ZSgpOyAvLyBJbml0aWFsIGNhbGxcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQWRkIGVmZmVjdCB0byBsaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlcyB3aXRoIG9wdGltaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgaWYgKG5ld1VzZXJJZCAhPT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxidXR0b24gey4uLmJ1dHRvblByb3BzfT5cbiAgICAgIHtpc0FiYnJldmlhdGVkID8gYWJicmV2aWF0ZWRUZXh0IDogdGV4dH1cbiAgICAgIHtwcm9jZXNzU3RhdHVzICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9jZXNzLXN0YXR1c1wiPlxuICAgICAgICAgIHtwcm9jZXNzU3RhdHVzfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIEFjdGlvbkJ1dHRvbkdyb3VwIGNvbXBvbmVudCB3aXRoIGNsaWVudC1zaWRlIG9ubHkgcmVuZGVyaW5nIGFuZCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgPSBmb3J3YXJkUmVmKCh7IHRyaWdnZXJDYW1lcmFBY2Nlc3MsIGlzQ29tcGFjdE1vZGUsIG9uQWN0aW9uQ2xpY2sgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncyhyZWYpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGJ1dHRvbiBhY3Rpb25zXG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtjb3VudGRvd25WYWx1ZSwgc2V0Q291bnRkb3duVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50RG90LCBzZXRDdXJyZW50RG90XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FsaWJyYXRpb25Qb2ludHMsIHNldENhbGlicmF0aW9uUG9pbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JlbWFpbmluZ0NhcHR1cmVzLCBzZXRSZW1haW5pbmdDYXB0dXJlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Nob3dDYW52YXMsIHNldFNob3dDYW52YXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIFxuICAvLyBUcmFjayB0aGUgY2FwdHVyZSBjb3VudFxuICBjb25zdCBbY2FsaWJyYXRpb25IYW5kbGVyLCBzZXRDYWxpYnJhdGlvbkhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnQsIHNldENhcHR1cmVDb3VudF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBUb2dnbGUgc3RhdGVzXG4gIGNvbnN0IFtzaG93SGVhZFBvc2UsIHNldFNob3dIZWFkUG9zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93Qm91bmRpbmdCb3gsIHNldFNob3dCb3VuZGluZ0JveF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TWFzaywgc2V0U2hvd01hc2tdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1BhcmFtZXRlcnMsIHNldFNob3dQYXJhbWV0ZXJzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ2FtZXJhQWN0aXZlLCBzZXRJc0NhbWVyYUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGVybWlzc2lvblBvcHVwLCBzZXRTaG93UGVybWlzc2lvblBvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcblxuICAvLyBBZGQgY2FjaGUgZm9yIHNldHRpbmdzXG4gIGNvbnN0IHNldHRpbmdzQ2FjaGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgbGFzdFNldHRpbmdzVXBkYXRlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG5cbiAgLy8gR2xvYmFsIGNhbnZhcyBtYW5hZ2VyIGluc3RhbmNlIC0gaW5pdGlhbGl6ZSBvbmx5IG9uY2VcbiAgY29uc3QgY2FudmFzTWFuYWdlciA9IHVzZU1lbW8oKCkgPT4gbmV3IENhbnZhc01hbmFnZXIoKSwgW10pO1xuXG4gIC8vIFJlcGxhY2UgdGhlIGNvbXBsZXggY2FudmFzIGZ1bmN0aW9ucyB3aXRoIHNpbXBsaWZpZWQgdmVyc2lvbnNcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpO1xuICB9O1xuXG4gIGNvbnN0IGVuc3VyZUNhbnZhc0V4aXN0cyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgfTtcblxuICBjb25zdCByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgPSAoY2FudmFzKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFudXBDYW52YXMgPSAoKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5kZXN0cm95KCk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gZWFzaWx5IG1hbmFnZSBjYW52YXMgb3BlcmF0aW9uc1xuICBjb25zdCBjYW52YXNVdGlscyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGNhbnZhc1xuICAgIGdldENhbnZhczogKCkgPT4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpLFxuICAgIFxuICAgIC8vIEVudGVyIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGVudGVyRnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgIHJldHVybiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRXhpdCBmdWxsc2NyZWVuIG1vZGVcbiAgICBleGl0RnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgcmV0dXJuIGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBDbGVhciBjYW52YXNcbiAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRHJhdyBkb3QgYXQgcG9zaXRpb25cbiAgICBkcmF3RG90OiAoeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCB4LCB5LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgLy8gR2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgZ2V0RGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuXG4gICAgaXNGdWxsc2NyZWVuOiAoKSA9PiBjYW52YXNNYW5hZ2VyLmlzSW5GdWxsc2NyZWVuKCksXG4gICAgXG4gICAgLy8gVXBkYXRlIGNhbnZhcyBzaXplIHRvIG1hdGNoIGNvbnRhaW5lclxuICAgIHJlc2l6ZVRvQ29udGFpbmVyOiAoY29udGFpbmVyKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMgfHwgIWNvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCB8fCBjb250YWluZXIuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IHx8IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBhbmQgcmVkcmF3IHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSwgW10pO1xuXG4gIC8vIE1ha2UgY2FudmFzIHV0aWxpdGllcyBnbG9iYWxseSBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5jYW52YXNVdGlscyA9IGNhbnZhc1V0aWxzO1xuICAgICAgd2luZG93LmNhbnZhc01hbmFnZXIgPSBjYW52YXNNYW5hZ2VyO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzVXRpbHM7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzTWFuYWdlcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXJdKTtcblxuICBcbiAgLy8gT3B0aW1pemUgc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdKSB7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldChjdXJyZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc0VxdWFsKGNhY2hlZFNldHRpbmdzLCB1c2VyU2V0dGluZ3MpKSB7XG4gICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgbmV3IHVzZXJcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzW25ld1VzZXJJZF0pIHtcbiAgICAgICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tuZXdVc2VySWRdO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzX3NldF9yYW5kb20sIGRlbGF5X3NldF9yYW5kb20gfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGlmICh0aW1lc19zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVzID0gTnVtYmVyKHRpbWVzX3NldF9yYW5kb20pIHx8IDE7XG4gICAgICAgICAgICBzZXRSYW5kb21UaW1lcyhuZXdUaW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWxheV9zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlbGF5ID0gTnVtYmVyKGRlbGF5X3NldF9yYW5kb20pIHx8IDM7XG4gICAgICAgICAgICBzZXREZWxheVNlY29uZHMobmV3RGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTWFrZSBmdW5jdGlvbnMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBhcyBhIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zID0ge1xuICAgICAgICBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSxcbiAgICAgICAgaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAgICAgICBoYW5kbGVDbGVhckFsbFxuICAgICAgfTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9uIGZ1bmN0aW9ucyBleHBvc2VkIHRvIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucztcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gT25seSBpbml0aWFsaXplIGlmIGNhbnZhcyBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJykpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgaW5pdGlhbGl6ZWQ6JywgY2FudmFzID8gJ3N1Y2Nlc3MnIDogJ2ZhaWxlZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIERvbid0IHJlbW92ZSBjYW52YXMgb24gY2xlYW51cCB0byBwcmV2ZW50IHJlY3JlYXRpb24gaXNzdWVzXG4gICAgICBjb25zb2xlLmxvZygnQWN0aW9uQnV0dG9uIGNsZWFudXAgLSBjYW52YXMgcHJlc2VydmVkJyk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICAvLyBGdW5jdGlvbiB0byBnZXQgY29udHJvbCB2YWx1ZXMgZnJvbSBUb3BCYXJcbiAgICBjb25zdCB1cGRhdGVDb250cm9sVmFsdWVzID0gKCkgPT4ge1xuICAgICAgLy8gR2V0IHRoZSB0aW1lIGlucHV0IGVsZW1lbnRcbiAgICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgY29uc3QgdGltZVZhbHVlID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4odGltZVZhbHVlKSAmJiB0aW1lVmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHJhbmRvbVRpbWVzIHRvOicsIHRpbWVWYWx1ZSk7XG4gICAgICAgICAgc2V0UmFuZG9tVGltZXModGltZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGRlbGF5IGlucHV0IGVsZW1lbnRcbiAgICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgY29uc3QgZGVsYXlWYWx1ZSA9IHBhcnNlSW50KGRlbGF5SW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihkZWxheVZhbHVlKSAmJiBkZWxheVZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBkZWxheVNlY29uZHMgdG86JywgZGVsYXlWYWx1ZSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKGRlbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBjb250cm9sIGlucHV0c1xuICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICBcbiAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICB0aW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB0aW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTsgLy8gQWxzbyBsaXN0ZW4gZm9yIGlucHV0IGV2ZW50c1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIGRlbGF5SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTsgLy8gQWxzbyBsaXN0ZW4gZm9yIGlucHV0IGV2ZW50c1xuICAgIH1cbiAgICBcbiAgICAvLyBJbml0aWFsIHVwZGF0ZVxuICAgIHVwZGF0ZUNvbnRyb2xWYWx1ZXMoKTtcbiAgICBcbiAgICAvLyBDbGVhbnVwIGV2ZW50IGxpc3RlbmVyc1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgIHRpbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGRlbGF5SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICAgIGRlbGF5SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgb24gY29tcG9uZW50IG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZUNhbnZhcyA9ICgpID0+IHtcbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY2FudmFzXG4gICAgICBjb25zdCBleGlzdGluZ0NhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50cmFja2luZy1jYW52YXMnKTtcbiAgICAgIGlmIChleGlzdGluZ0NhbnZhcykge1xuICAgICAgICBleGlzdGluZ0NhbnZhcy5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIG5ldyBjYW52YXNcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLmNsYXNzTmFtZSA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgY2FudmFzLmlkID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICBjYW52YXMuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIHotaW5kZXg6IDU7XG4gICAgICBgO1xuXG4gICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnNcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgLy8gQWRkIGNhbnZhcyB0byBib2R5XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cbiAgICAgIC8vIFN0b3JlIHJlZmVyZW5jZVxuICAgICAgY2FudmFzUmVmLmN1cnJlbnQgPSBjYW52YXM7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBBZGQgcmVzaXplIGhhbmRsZXJcbiAgICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcbiAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgY29uc3QgY2xlYW51cCA9IGluaXRpYWxpemVDYW52YXMoKTtcbiAgICByZXR1cm4gY2xlYW51cDtcbiAgfSwgW10pO1xuXG4gIC8vIFNpbXBsaWZpZWQgQ2FudmFzIE1hbmFnZXIgLSBNb3JlIGZsZXhpYmxlIGFuZCBtYWludGFpbmFibGVcbiAgY2xhc3MgQ2FudmFzTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLm9yaWdpbmFsU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvciBnZXQgY2FudmFzIHdpdGggYXV0b21hdGljIHNpemluZ1xuICAgIGNyZWF0ZUNhbnZhcyhjb250YWluZXIgPSBudWxsKSB7XG4gICAgICAvLyBUcnkgdG8gZmluZCBleGlzdGluZyBjYW52YXMgZmlyc3RcbiAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICAgIGNhbnZhcy5pZCA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgY29udGFpbmVyXG4gICAgICBjb25zdCB0YXJnZXRDb250YWluZXIgPSBjb250YWluZXIgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluLWNvbnRlbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAvLyBTZXQgaW5pdGlhbCBkaW1lbnNpb25zIGJhc2VkIG9uIGNvbnRhaW5lclxuICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKGNhbnZhcywgdGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gQWRkIHRvIGNvbnRhaW5lciBpZiBub3QgYWxyZWFkeSB0aGVyZVxuICAgICAgaWYgKCFjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICB0YXJnZXRDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcblxuICAgICAgLy8gU2V0IHVwIHJlc3BvbnNpdmUgYmVoYXZpb3JcbiAgICAgIHRoaXMuc2V0dXBSZXNwb25zaXZlQ2FudmFzKGNhbnZhcywgdGFyZ2V0Q29udGFpbmVyKTtcblxuICAgICAgY29uc29sZS5sb2coYENhbnZhcyBjcmVhdGVkL3VwZGF0ZWQ6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjYW52YXMgc2l6ZSB0byBtYXRjaCBjb250YWluZXJcbiAgICB1cGRhdGVDYW52YXNTaXplKGNhbnZhcywgY29udGFpbmVyKSB7XG4gICAgICBpZiAoIWNhbnZhcyB8fCAhY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGggfHwgY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0IHx8IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgNjAwO1xuXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIC8vIFVwZGF0ZSBDU1MgdG8gbWF0Y2hcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgcmVzcG9uc2l2ZSBjYW52YXMgdGhhdCBhZGFwdHMgdG8gY29udGFpbmVyIHNpemVcbiAgICBzZXR1cFJlc3BvbnNpdmVDYW52YXMoY2FudmFzLCBjb250YWluZXIpIHtcbiAgICAgIGlmICghY2FudmFzIHx8ICFjb250YWluZXIpIHJldHVybjtcblxuICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHJlc2l6ZSBvYnNlcnZlclxuICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgcmVzaXplIG9ic2VydmVyXG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKGNhbnZhcywgY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIFJlZHJhdyB3aGl0ZSBiYWNrZ3JvdW5kIGFmdGVyIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9ic2VydmUgY29udGFpbmVyIGZvciBzaXplIGNoYW5nZXNcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuXG4gICAgICAvLyBBbHNvIGxpc3RlbiBmb3Igd2luZG93IHJlc2l6ZSBhcyBmYWxsYmFja1xuICAgICAgY29uc3QgaGFuZGxlV2luZG93UmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUoY2FudmFzLCBjb250YWluZXIpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICBjYW52YXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIgPSBoYW5kbGVXaW5kb3dSZXNpemU7XG4gICAgfVxuXG4gICAgLy8gU3dpdGNoIHRvIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGVudGVyRnVsbHNjcmVlbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHN0YXRlXG4gICAgICB0aGlzLm9yaWdpbmFsU3RhdGUgPSB7XG4gICAgICAgIHBhcmVudDogdGhpcy5jYW52YXMucGFyZW50RWxlbWVudCxcbiAgICAgICAgcG9zaXRpb246IHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IHRoaXMuY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogdGhpcy5jYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IHRoaXMuY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiB0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXhcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdmUgdG8gYm9keSBhbmQgbWFrZSBmdWxsc2NyZWVuXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICB6LWluZGV4OiA5OTk5OTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICBgO1xuXG4gICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gd2luZG93IHNpemVcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBIaWRlIFVJIGVsZW1lbnRzXG4gICAgICB0aGlzLmhpZGVVSUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZW50ZXJlZCBmdWxsc2NyZWVuIG1vZGUnKTtcbiAgICB9XG5cbiAgICAvLyBFeGl0IGZ1bGxzY3JlZW4gbW9kZVxuICAgIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5vcmlnaW5hbFN0YXRlKSByZXR1cm47XG5cbiAgICAgIC8vIFNob3cgVUkgZWxlbWVudHNcbiAgICAgIHRoaXMuc2hvd1VJRWxlbWVudHMoKTtcblxuICAgICAgLy8gRmluZCBhcHByb3ByaWF0ZSBjb250YWluZXJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIC8vIE1vdmUgY2FudmFzIGJhY2sgdG8gY29udGFpbmVyXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIHN0eWxlc1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJyc7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9ICcnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcblxuICAgICAgLy8gVXBkYXRlIHNpemUgdG8gbWF0Y2ggY29udGFpbmVyXG4gICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUodGhpcy5jYW52YXMsIGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBDbGVhciBvcmlnaW5hbCBzdGF0ZVxuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZXhpdGVkIGZ1bGxzY3JlZW4gbW9kZScpO1xuICAgIH1cblxuICAgIC8vIEhpZGUgVUkgZWxlbWVudHMgZHVyaW5nIGZ1bGxzY3JlZW5cbiAgICBoaWRlVUlFbGVtZW50cygpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzVG9IaWRlID0gW1xuICAgICAgICAnLnRvcGJhcicsXG4gICAgICAgICcuY2FudmFzLWNvbnRhaW5lcicsIFxuICAgICAgICAnLm1haW4tY29udGVudCcsXG4gICAgICAgICcubWV0cmljcy1wYW5lbCcsXG4gICAgICAgICcuZGlzcGxheS1tZXRyaWNzJyxcbiAgICAgICAgJ25hdicsXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnLmJ1dHRvbi1ncm91cHMnLFxuICAgICAgICAnLmNvbnRyb2wtYnV0dG9ucydcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGVsZW1lbnRzVG9IaWRlLmZvckVhY2goc2VsZWN0b3IgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1oaWRkZW4tYnktY2FudmFzJywgJ3RydWUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaG93IFVJIGVsZW1lbnRzIGFmdGVyIGZ1bGxzY3JlZW5cbiAgICBzaG93VUlFbGVtZW50cygpIHtcbiAgICAgIGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaGlkZGVuLWJ5LWNhbnZhcz1cInRydWVcIl0nKTtcbiAgICAgIGhpZGRlbkVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1oaWRkZW4tYnktY2FudmFzJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBjYW52YXMgY29udGVudFxuICAgIGNsZWFyKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIENsZWFudXBcbiAgICBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fd2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5jYW52YXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9PT0gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgY2FudmFzXG4gICAgZ2V0Q2FudmFzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICBpc0luRnVsbHNjcmVlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRnVsbHNjcmVlbjtcbiAgICB9XG4gIH1cblxuXG4gIFxuICAvLyBNb2RpZmllZCBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggaW1wcm92ZWQgZG90IGFuZCBjb3VudGRvd24gYWxpZ25tZW50XG4gIC8vIENvbXBsZXRlIGhhbmRsZURvdFByb2Nlc3MgZnVuY3Rpb24gd2l0aCBwcm9wZXIgY2FudmFzIG1hbmFnZW1lbnRcbiAgY29uc3QgaGFuZGxlRG90UHJvY2VzcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvblN0YXR1c1VwZGF0ZSxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgIHNldENhcHR1cmVDb3VudCxcbiAgICAgIHVzZVJhbmRvbVBvc2l0aW9uID0gZmFsc2UsXG4gICAgICBwb3N0Q291bnRkb3duRGVsYXkgPSA1MDAgXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgXG4gICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgbGV0IGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIGxldCBjb3VudGRvd25FbGVtZW50ID0gbnVsbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzaG93aW5nIHRoZSBkb3RcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGVcbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogdXNlUmFuZG9tUG9zaXRpb24gPyAnR2VuZXJhdGluZyByYW5kb20gZG90Li4uJyA6ICdTdGFydGluZyBkb3QgcHJvY2Vzcy4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgVUkgdXBkYXRlcyB0byB0YWtlIGVmZmVjdFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgXG4gICAgICAvLyBVc2UgZW5zdXJlQ2FudmFzRXhpc3RzIHRvIGdldCBvciBjcmVhdGUgY2FudmFzXG4gICAgICBjYW52YXMgPSBlbnN1cmVDYW52YXNFeGlzdHMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgb3IgZmluZCBjYW52YXNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbnZhcyBpcyBhbHJlYWR5IHNldCB0byBmdWxsc2NyZWVuIGJ5IGVuc3VyZUNhbnZhc0V4aXN0c1xuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dCBhbmQgY2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgICAgY29uc3QgZG90UG9zaXRpb24gPSB1c2VSYW5kb21Qb3NpdGlvbiBcbiAgICAgICAgPyBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKSBcbiAgICAgICAgOiBwb3NpdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKCFkb3RQb3NpdGlvbiB8fCB0eXBlb2YgZG90UG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDEyO1xuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSByZWRyYXcgaW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICBrZWVwRG90VmlzaWJsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9LCA1MCk7ICAvLyBNb3JlIGZyZXF1ZW50IHVwZGF0ZXMgZm9yIHJlbGlhYmlsaXR5XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IG9uIHRvcCBvZiB0aGUgZG90XG4gICAgICBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBsZWZ0OiAke2RvdFBvc2l0aW9uLnh9cHg7XG4gICAgICAgIHRvcDogJHtkb3RQb3NpdGlvbi55fXB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICBcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgZG90IGZvciByZWxpYWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGRpdGlvbmFsIHJlZHJhdyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBhZnRlciBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9zdENvdW50ZG93bkRlbGF5KSk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgcG9pbnQ6IGRvdFBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJlIGNvbXBsZXRlZCcsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZVJlc3VsdFxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlRG90UHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgICAgXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbCBmaXJzdFxuICAgICAgaWYgKGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChrZWVwRG90VmlzaWJsZUludGVydmFsKTtcbiAgICAgICAga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgcmVtYWluaW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgcmVtYWluaW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgdG8gcHJvcGVybHkgcmVzdG9yZSBjYW52YXNcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIERlY2xhcmUgdGhlc2UgdmFyaWFibGVzIE9VVFNJREUgdGhlIHRyeSBibG9ja1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1BhcmVudCA9IG51bGw7XG4gICAgbGV0IG9yaWdpbmFsQ2FudmFzU3R5bGUgPSB7fTtcbiAgICBsZXQgc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjYW52YXMgPSBlbnN1cmVDYW52YXNFeGlzdHMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY2FudmFzIGZvciBjYWxpYnJhdGlvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBIaWRlIFRvcEJhclxuICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIlN0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlXG4gICAgICBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKFwiRXJyb3I6IENhbnZhcyBub3QgZm91bmRcIik7XG4gICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGVcbiAgICAgIG9yaWdpbmFsQ2FudmFzUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBvcmlnaW5hbENhbnZhc1N0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTW92ZSBjYW52YXMgdG8gYm9keSBmb3IgbWF4aW11bSByZWxpYWJpbGl0eVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgXG4gICAgICAvLyBNYWtlIGNhbnZhcyBmdWxsc2NyZWVuIHdpdGggZml4ZWQgcG9zaXRpb25pbmdcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgIFxuICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93IGV4YWN0bHlcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgc2V0IHRvIGZ1bGxzY3JlZW46ICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcblxuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIHRoZSBjYW52YXMgc2l6ZVxuICAgICAgY29uc3QgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJyk7XG4gICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgXG4gICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgIHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgcmVkcmF3IGludGVydmFsXG4gICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBkaXNwbGF5c1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGNhbnZhcyBpZiBkaW1lbnNpb25zIGNoYW5nZWRcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYW52YXMgZGltZW5zaW9ucyBjaGFuZ2VkLiBSZXNldHRpbmcgdG8gJHtjYW52YXNXaWR0aH14JHtjYW52YXNIZWlnaHR9YCk7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5IGFuZCBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBjb25zdCByYWRpdXMgPSAxNDsgLy8gU2xpZ2h0bHkgbGFyZ2VyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGZ1bmN0aW9uIGZvciB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHJlZHJhd0N1cnJlbnREb3QgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVmVyaWZ5IGNhbnZhcyBkaW1lbnNpb25zIGFuZCBwYXJlbnRcbiAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGJvZHlcbiAgICAgICAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVkcmF3IGRvdCB3aXRob3V0IGNsZWFyaW5nXG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgcmVkcmF3IGludGVydmFsIC0gbW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJsZSBkb3QgdmlzaWJpbGl0eVxuICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChyZWRyYXdDdXJyZW50RG90LCA1MCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7IC8vIENvbnNpc3RlbnQgY2xhc3MgbmFtZVxuICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIGxlZnQ6ICR7cG9pbnQueH1weDtcbiAgICAgICAgICB0b3A6ICR7cG9pbnQueSAtIDYwfXB4O1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3IG11bHRpcGxlIHRpbWVzIGR1cmluZyBjb3VudGRvd24gdG8gZW5zdXJlIHZpc2liaWxpdHlcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0IHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuXG4gICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFudWFsIGZvcmNlIHJlZHJhdyBvbmUgbW9yZSB0aW1lIGp1c3QgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICB9XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgcmVkcmF3IGludGVydmFsXG4gICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yICYmIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cENhbnZhcygpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lcihjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBlbnN1cmVDYW52YXNFeGlzdHMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY2FudmFzIGZvciBzZXQgcmFuZG9tJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEFsd2F5cyBnZXQgdGhlIGxhdGVzdCBzZXR0aW5ncyBmcm9tIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdID8gc2V0dGluZ3NbY3VycmVudFVzZXJJZF0gOiB7fTtcbiAgICAgIGNvbnN0IHRpbWVzID0gTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCBOdW1iZXIocmFuZG9tVGltZXMpIHx8IDE7XG4gICAgICBjb25zdCBkZWxheSA9IE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgTnVtYmVyKGRlbGF5U2Vjb25kcykgfHwgMztcblxuICAgICAgLy8gTG9nIGN1cnJlbnQgc2V0dGluZ3MgYmVmb3JlIHN0YXJ0aW5nXG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgU2V0IFJhbmRvbSB3aXRoIHNldHRpbmdzOicsIHtcbiAgICAgICAgcmFuZG9tVGltZXMsXG4gICAgICAgIGRlbGF5U2Vjb25kcyxcbiAgICAgICAgY3VycmVudFVzZXJJZCxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgIHVzZXJTZXR0aW5ncyxcbiAgICAgICAgdGltZXMsXG4gICAgICAgIGRlbGF5XG4gICAgICB9KTtcblxuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgU3RhcnRpbmcgJHt0aW1lc30gcmFuZG9tIGNhcHR1cmVzIHdpdGggJHtkZWxheX1zIGRlbGF5Li4uYCk7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIGNhcHR1cmVzIGluIHNlcXVlbmNlXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgY3VycmVudEluZGV4ID0gMTsgY3VycmVudEluZGV4IDw9IHRpbWVzOyBjdXJyZW50SW5kZXgrKykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMgLSBjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlICR7Y3VycmVudEluZGV4fSBvZiAke3RpbWVzfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIGhhbmRsZURvdFByb2Nlc3MgZm9yIGVhY2ggY2FwdHVyZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgICAgICB1c2VSYW5kb21Qb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9LyR7dGltZXN9OiAke3N0YXR1cy5wcm9jZXNzU3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IFRvcEJhciBhZnRlciB0aGUgbGFzdCBjYXB0dXJlXG4gICAgICAgICAgICBpZiAoc2hvdyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHNob3cgeWV0IGZvciBpbnRlcm1lZGlhdGUgY2FwdHVyZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoc2hvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgICAgIHNldElzQ2FwdHVyaW5nOiAoY2FwdHVyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCBjYXB0dXJpbmcgdG8gZmFsc2UgYWZ0ZXIgYWxsIGNhcHR1cmVzXG4gICAgICAgICAgICBpZiAoIWNhcHR1cmluZyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIFN0YXkgaW4gY2FwdHVyaW5nIHN0YXRlIGJldHdlZW4gZG90c1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoY2FwdHVyaW5nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiA4MDBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgY2FwdHVyZSAke2N1cnJlbnRJbmRleH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG1heSBoYXZlIGZhaWxlZDpgLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgLSBidXQgb25seSBpZiB0aGVyZSBhcmUgbW9yZSBjYXB0dXJlcyB0byBnb1xuICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IGNhcHR1cmVzIHN1Y2Nlc3NmdWxgKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgICAgY29uc29sZS5sb2coYENvbXBsZXRlZCBhbGwgY2FwdHVyZXM6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBzdWNjZXNzZnVsYCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJhbmRvbSBzZXF1ZW5jZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUmFuZG9tIHNlcXVlbmNlIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cENhbnZhcygpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lcihjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmFuZG9tRG90ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGVuc3VyZUNhbnZhc0V4aXN0cygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgZm9yIHJhbmRvbSBkb3QnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGNvbnNvbGlkYXRlZCBmdW5jdGlvbiB3aXRoIHJhbmRvbSBwb3NpdGlvblxuICAgICAgYXdhaXQgaGFuZGxlRG90UHJvY2Vzcyh7XG4gICAgICAgIHVzZVJhbmRvbVBvc2l0aW9uOiB0cnVlLFxuICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXMucHJvY2Vzc1N0YXR1cyk7XG4gICAgICAgICAgaWYgKHN0YXR1cy5pc0NhcHR1cmluZyAhPT0gdW5kZWZpbmVkKSBzZXRJc0NhcHR1cmluZyhzdGF0dXMuaXNDYXB0dXJpbmcpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICAgIHNldElzQ2FwdHVyaW5nLFxuICAgICAgICBjYXB0dXJlQ291bnQsXG4gICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICBwb3N0Q291bnRkb3duRGVsYXk6IDEwMDBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUmFuZG9tIGRvdCBlcnJvcjonLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFuIHVwIGNhbnZhcyBhZnRlciBwcm9jZXNzIGNvbXBsZXRlc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFudXBDYW52YXMoKTtcbiAgICAgIH0sIDIwMDApOyAvLyBXYWl0IDIgc2Vjb25kcyBiZWZvcmUgY2xlYW51cFxuICAgIH1cbiAgICBcbiAgfTtcbiAgY29uc3QgbWFrZUNhbnZhc0Z1bGxzY3JlZW4gPSAoY2FudmFzKSA9PiB7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiBudWxsO1xuICAgIFxuICAgIC8vIFNhdmUgb3JpZ2luYWwgc3RhdGUgaWYgbm90IGFscmVhZHkgc2F2ZWRcbiAgICBpZiAoIWNhbnZhcy5fb3JpZ2luYWxTdGF0ZSkge1xuICAgICAgY2FudmFzLl9vcmlnaW5hbFN0YXRlID0ge1xuICAgICAgICBwYXJlbnQ6IGNhbnZhcy5wYXJlbnRFbGVtZW50LFxuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleCxcbiAgICAgICAgY2FudmFzV2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgY2FudmFzSGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBNb3ZlIHRvIGJvZHkgYW5kIG1ha2UgZnVsbHNjcmVlblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuICBcblxuICAvLyBMb2FkIGNhbGlicmF0aW9uIHNldHVwXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBjb25zdCBzZXR1cENhbGlicmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBDYWxpYnJhdGVIYW5kbGVyIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlcicpO1xuICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHNldHVwQ2FsaWJyYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBtYWtlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXMgc2l6ZTonLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgY2FsaWJyYXRpb24gcG9pbnRzOicsIHBvaW50cyk7XG4gICAgICAgIHNldENhbGlicmF0aW9uUG9pbnRzKHBvaW50cyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbGlicmF0ZUhhbmRsZXIgPSBuZXcgQ2FsaWJyYXRlSGFuZGxlcih7XG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIGNhbGlicmF0aW9uUG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4gb25BY3Rpb25DbGljaz8uKCd0b2dnbGVUb3BCYXInLCBzaG93KSxcbiAgICAgICAgICBzZXRPdXRwdXRUZXh0OiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnRlcjogY2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyOiAobmV3Q291bnRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdDb3VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudChwcmV2ID0+IG5ld0NvdW50ZXIocHJldikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KG5ld0NvdW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUZvbGRlcjogJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25IYW5kbGVyKHtcbiAgICAgICAgICBoYW5kbGVBY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24uLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGlicmF0ZUhhbmRsZXIuc3RhcnRDYWxpYnJhdGlvbigpO1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICByZXN0b3JlQ2FudmFzU2l6ZShjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNhbGlicmF0aW9uOicsIGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldHVwQ2FsaWJyYXRpb24oKTtcbiAgfSwgW2NhcHR1cmVDb3VudCwgb25BY3Rpb25DbGlja10pO1xuICBcbiAgLy8gQ2xlYXIgQWxsIEJ1dHRvbiAtIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgY29uc3QgaGFuZGxlQ2xlYXJBbGwgPSAoKSA9PiB7XG4gICAgLy8gQ2xlYXIgY2FudmFzIGNvbnRlbnRcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIGNhbnZhcyB0byBjb250YWluZXIgbW9kZVxuICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IHN0YXRlc1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgIHNldEN1cnJlbnREb3QobnVsbCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEhlYWQgUG9zZSB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUhlYWRQb3NlID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0hlYWRQb3NlU3RhdGUgPSAhc2hvd0hlYWRQb3NlO1xuICAgIHNldFNob3dIZWFkUG9zZShuZXdIZWFkUG9zZVN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBIZWFkIHBvc2UgdmlzdWFsaXphdGlvbiAke25ld0hlYWRQb3NlU3RhdGUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdoZWFkUG9zZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dIZWFkUG9zZTogbmV3SGVhZFBvc2VTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGhlYWQgcG9zZTogJHtuZXdIZWFkUG9zZVN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgQm91bmRpbmcgQm94IHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3ggPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Qm91bmRpbmdCb3hTdGF0ZSA9ICFzaG93Qm91bmRpbmdCb3g7XG4gICAgc2V0U2hvd0JvdW5kaW5nQm94KG5ld0JvdW5kaW5nQm94U3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYEJvdW5kaW5nIGJveCAke25ld0JvdW5kaW5nQm94U3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ2JvdW5kaW5nQm94Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd0JvdW5kaW5nQm94OiBuZXdCb3VuZGluZ0JveFN0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgYm91bmRpbmcgYm94OiAke25ld0JvdW5kaW5nQm94U3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBNYXNrIHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlTWFzayA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdNYXNrU3RhdGUgPSAhc2hvd01hc2s7XG4gICAgc2V0U2hvd01hc2sobmV3TWFza1N0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBNYXNrICR7bmV3TWFza1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdtYXNrJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd01hc2s6IG5ld01hc2tTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIG1hc2s6ICR7bmV3TWFza1N0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgUGFyYW1ldGVycyBkaXNwbGF5XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3UGFyYW1ldGVyc1N0YXRlID0gIXNob3dQYXJhbWV0ZXJzO1xuICAgIHNldFNob3dQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnNTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgUGFyYW1ldGVycyAke25ld1BhcmFtZXRlcnNTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygncGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dQYXJhbWV0ZXJzOiBuZXdQYXJhbWV0ZXJzU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBwYXJhbWV0ZXJzOiAke25ld1BhcmFtZXRlcnNTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIGNhbWVyYSBwcmV2aWV3XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUNhbWVyYSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdDYW1lcmFTdGF0ZSA9ICFpc0NhbWVyYUFjdGl2ZTtcbiAgICBzZXRJc0NhbWVyYUFjdGl2ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgd2l0aCAncHJldmlldycgYWN0aW9uXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3ByZXZpZXcnLCBuZXdDYW1lcmFTdGF0ZSk7IC8vIFBhc3MgdGhlIG5ldyBzdGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgdHJpZ2dlciBpZiBubyBhY3Rpb24gaGFuZGxlclxuICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgdHVybmluZyBvbiBjYW1lcmEsIGVuc3VyZSB3ZSBhcHBseSBjdXJyZW50IHZpc3VhbGl6YXRpb24gc2V0dGluZ3NcbiAgICBpZiAobmV3Q2FtZXJhU3RhdGUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAvLyBXYWl0IGEgc2hvcnQgbW9tZW50IHRvIGVuc3VyZSB0aGUgdmlkZW8gZWxlbWVudCBpcyByZWFkeVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICBzaG93SGVhZFBvc2UsXG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3gsXG4gICAgICAgICAgICBzaG93TWFzayxcbiAgICAgICAgICAgIHNob3dQYXJhbWV0ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBiYWNrIGJ1dHRvbiBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZUdvQmFjayA9ICgpID0+IHtcbiAgICByb3V0ZXIucHVzaCgnLycpO1xuICB9O1xuXG4gIC8vIE1vYmlsZSBsYXlvdXQgLSAyeDUgZ3JpZFxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICB7aXNDb21wYWN0TW9kZSA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yIG1iLTRcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMlwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cblxuICAgICAgey8qIENhbWVyYSBQZXJtaXNzaW9uIFBvcHVwICovfVxuICAgICAge3Nob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMTVcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWRpYWxvZ1wiIFxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aDMgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDE1cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENhbWVyYSBBY2Nlc3MgUmVxdWlyZWRcbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tbWVzc2FnZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICBnYXA6ICcxMHB4J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7XG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFxuICBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiA8QWN0aW9uQnV0dG9uR3JvdXBJbm5lciB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPilcbiksIHsgc3NyOiBmYWxzZSB9KTtcbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgQWN0aW9uQnV0dG9uR3JvdXBcbi8vIGNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoQWN0aW9uQnV0dG9uR3JvdXBJbm5lciksIHsgc3NyOiBmYWxzZSB9KTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWN0aW9uQnV0dG9uUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59XG5cbmV4cG9ydCB7IEFjdGlvbkJ1dHRvbiwgQWN0aW9uQnV0dG9uR3JvdXAgfTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImR5bmFtaWMiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInJ1bkNvdW50ZG93biIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwidXNlUm91dGVyIiwidXNlQWRtaW5TZXR0aW5ncyIsIlJhbmRvbURvdEFjdGlvbiIsIlNldFJhbmRvbUFjdGlvbiIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsIkFjdGlvbkJ1dHRvbiIsInRleHQiLCJhYmJyZXZpYXRlZFRleHQiLCJvbkNsaWNrIiwiY3VzdG9tQ2xhc3MiLCJkaXNhYmxlZCIsImFjdGl2ZSIsImlzQWJicmV2aWF0ZWQiLCJzZXRJc0FiYnJldmlhdGVkIiwic2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJidXR0b25Qcm9wcyIsImNsYXNzTmFtZSIsInRpdGxlIiwidGltZW91dElkIiwiaGFuZGxlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJ0eXBlIiwibmV3VXNlcklkIiwidXNlcklkIiwiYnV0dG9uIiwiZGl2IiwiQWN0aW9uQnV0dG9uR3JvdXBJbm5lciIsInJlZiIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsInJvdXRlciIsInVwZGF0ZVNldHRpbmdzIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbnZhc1JlZiIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJyZW1haW5pbmdDYXB0dXJlcyIsInNldFJlbWFpbmluZ0NhcHR1cmVzIiwic2hvd0NhbnZhcyIsInNldFNob3dDYW52YXMiLCJjYWxpYnJhdGlvbkhhbmRsZXIiLCJzZXRDYWxpYnJhdGlvbkhhbmRsZXIiLCJjYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzaG93SGVhZFBvc2UiLCJzZXRTaG93SGVhZFBvc2UiLCJzaG93Qm91bmRpbmdCb3giLCJzZXRTaG93Qm91bmRpbmdCb3giLCJzaG93TWFzayIsInNldFNob3dNYXNrIiwic2hvd1BhcmFtZXRlcnMiLCJzZXRTaG93UGFyYW1ldGVycyIsImlzQ2FtZXJhQWN0aXZlIiwic2V0SXNDYW1lcmFBY3RpdmUiLCJzaG93UGVybWlzc2lvblBvcHVwIiwic2V0U2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldHRpbmdzQ2FjaGUiLCJNYXAiLCJsYXN0U2V0dGluZ3NVcGRhdGUiLCJjYW52YXNNYW5hZ2VyIiwiQ2FudmFzTWFuYWdlciIsImdldE1haW5DYW52YXMiLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJlbnN1cmVDYW52YXNFeGlzdHMiLCJyZXN0b3JlQ2FudmFzVG9Db250YWluZXIiLCJjYW52YXMiLCJleGl0RnVsbHNjcmVlbiIsImNsZWFudXBDYW52YXMiLCJkZXN0cm95IiwiY2xlYXJDYW52YXMiLCJjbGVhciIsImNhbnZhc1V0aWxzIiwiZW50ZXJGdWxsc2NyZWVuIiwiZHJhd0RvdCIsIngiLCJ5IiwicmFkaXVzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImdldERpbWVuc2lvbnMiLCJoZWlnaHQiLCJpc0Z1bGxzY3JlZW4iLCJpc0luRnVsbHNjcmVlbiIsInJlc2l6ZVRvQ29udGFpbmVyIiwiY29udGFpbmVyIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ1c2VyU2V0dGluZ3MiLCJjYWNoZWRTZXR0aW5ncyIsImN1cnJlbnQiLCJnZXQiLCJOdW1iZXIiLCJ0aW1lc19zZXRfcmFuZG9tIiwiZGVsYXlfc2V0X3JhbmRvbSIsInNldCIsIkRhdGUiLCJub3ciLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsInVuZGVmaW5lZCIsIm5ld1RpbWVzIiwibmV3RGVsYXkiLCJhY3Rpb25CdXR0b25GdW5jdGlvbnMiLCJoYW5kbGVSYW5kb21Eb3QiLCJoYW5kbGVTZXRSYW5kb20iLCJoYW5kbGVTZXRDYWxpYnJhdGUiLCJoYW5kbGVDbGVhckFsbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNvbnNvbGUiLCJsb2ciLCJ1cGRhdGVDb250cm9sVmFsdWVzIiwidGltZUlucHV0IiwidGltZVZhbHVlIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImlzTmFOIiwiZGVsYXlJbnB1dCIsImRlbGF5VmFsdWUiLCJpbml0aWFsaXplQ2FudmFzIiwiZXhpc3RpbmdDYW52YXMiLCJyZW1vdmUiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJzdHlsZSIsImNzc1RleHQiLCJpbm5lckhlaWdodCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIndoaXRlU2NyZWVuQ2FudmFzIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY2xlYW51cCIsInRhcmdldENvbnRhaW5lciIsInVwZGF0ZUNhbnZhc1NpemUiLCJzZXR1cFJlc3BvbnNpdmVDYW52YXMiLCJkaXNwbGF5IiwiYmFja2dyb3VuZENvbG9yIiwicmVzaXplT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJ0YXJnZXQiLCJvYnNlcnZlIiwiaGFuZGxlV2luZG93UmVzaXplIiwiX3dpbmRvd1Jlc2l6ZUhhbmRsZXIiLCJvcmlnaW5hbFN0YXRlIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInpJbmRleCIsImhpZGVVSUVsZW1lbnRzIiwic2hvd1VJRWxlbWVudHMiLCJlbGVtZW50c1RvSGlkZSIsImZvckVhY2giLCJzZWxlY3RvciIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImVsIiwic2V0QXR0cmlidXRlIiwiaGlkZGVuRWxlbWVudHMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJjbGVhclJlY3QiLCJjb25zdHJ1Y3RvciIsImhhbmRsZURvdFByb2Nlc3MiLCJvcHRpb25zIiwib25TdGF0dXNVcGRhdGUiLCJ0b2dnbGVUb3BCYXIiLCJ1c2VSYW5kb21Qb3NpdGlvbiIsInBvc3RDb3VudGRvd25EZWxheSIsImtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwiLCJjb3VudGRvd25FbGVtZW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJFcnJvciIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZG90UG9zaXRpb24iLCJkb3RSYWRpdXMiLCJzZXRJbnRlcnZhbCIsImV4aXN0aW5nQ291bnRkb3ducyIsImNvdW50IiwidGV4dENvbnRlbnQiLCJjYXB0dXJlUmVzdWx0IiwicG9pbnQiLCJzdWNjZXNzIiwiZXJyb3IiLCJtZXNzYWdlIiwiY2xlYXJJbnRlcnZhbCIsInJlbWFpbmluZ0NvdW50ZG93bnMiLCJvcmlnaW5hbENhbnZhc1BhcmVudCIsIm9yaWdpbmFsQ2FudmFzU3R5bGUiLCJzdGF0dXNJbmRpY2F0b3IiLCJjdXJyZW50UmVkcmF3SW50ZXJ2YWwiLCJwb2ludHMiLCJzdWNjZXNzQ291bnQiLCJpIiwid2FybiIsInJlZHJhd0N1cnJlbnREb3QiLCJzY3JlZW5JbWFnZSIsInRpbWVzIiwiZGVsYXkiLCJjdXJyZW50SW5kZXgiLCJyZXN1bHQiLCJzdGF0dXMiLCJzaG93IiwiY2FwdHVyaW5nIiwibWFrZUNhbnZhc0Z1bGxzY3JlZW4iLCJfb3JpZ2luYWxTdGF0ZSIsInNldHVwQ2FsaWJyYXRpb24iLCJkZWZhdWx0IiwiQ2FsaWJyYXRlSGFuZGxlciIsImNhbGlicmF0ZUhhbmRsZXIiLCJzZXRPdXRwdXRUZXh0IiwibmV3Q291bnRlciIsInByZXYiLCJjYXB0dXJlRm9sZGVyIiwib25Db21wbGV0ZSIsImhhbmRsZUFjdGlvbiIsInN0YXJ0Q2FsaWJyYXRpb24iLCJyZXN0b3JlQ2FudmFzU2l6ZSIsImVyciIsImhhbmRsZVRvZ2dsZUhlYWRQb3NlIiwibmV3SGVhZFBvc2VTdGF0ZSIsInZpZGVvUHJvY2Vzc29yIiwidXBkYXRlT3B0aW9ucyIsImhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94IiwibmV3Qm91bmRpbmdCb3hTdGF0ZSIsImhhbmRsZVRvZ2dsZU1hc2siLCJuZXdNYXNrU3RhdGUiLCJoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzIiwibmV3UGFyYW1ldGVyc1N0YXRlIiwiaGFuZGxlVG9nZ2xlQ2FtZXJhIiwibmV3Q2FtZXJhU3RhdGUiLCJoYW5kbGVHb0JhY2siLCJwdXNoIiwianVzdGlmeUNvbnRlbnQiLCJhbGlnbkl0ZW1zIiwiYm9yZGVyUmFkaXVzIiwicGFkZGluZyIsImJveFNoYWRvdyIsImgzIiwibWFyZ2luIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwicCIsImxpbmVIZWlnaHQiLCJnYXAiLCJoYW5kbGVQZXJtaXNzaW9uRGVuaWVkIiwiYm9yZGVyIiwiY3Vyc29yIiwiaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkIiwiY29sb3IiLCJBY3Rpb25CdXR0b25Hcm91cCIsInByb3BzIiwic3NyIiwiQWN0aW9uQnV0dG9uUGFnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});