"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.jsx":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CalibratePoints.jsx ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearCalibrationPoints: () => (/* binding */ clearCalibrationPoints),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawCalibrationGrid: () => (/* binding */ drawCalibrationGrid),\n/* harmony export */   drawCalibrationPoint: () => (/* binding */ drawCalibrationPoint),\n/* harmony export */   drawCalibrationPointLegacy: () => (/* binding */ drawCalibrationPointLegacy),\n/* harmony export */   generateCalibrationPoints: () => (/* binding */ generateCalibrationPoints)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// CalibratePoints.jsx\n// Utility for generating and managing calibration points on a canvas\n\n/**\n * Get canvas management utilities from global scope (from actionButton.js)\n * @returns {Object} Canvas utilities object\n */ const getCanvasUtils = ()=>{\n    if (true) {\n        return {\n            canvasUtils: window.canvasUtils,\n            canvasManager: window.canvasManager\n        };\n    }\n    return {\n        canvasUtils: null,\n        canvasManager: null\n    };\n};\n/**\n * Get or create canvas using the canvas management system from actionButton.js\n * @returns {HTMLCanvasElement} Canvas element\n */ const getCanvas = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    // First try to use canvasUtils from actionButton.js\n    if (canvasUtils && typeof canvasUtils.getCanvas === 'function') {\n        return canvasUtils.getCanvas();\n    }\n    // Fallback to canvasManager\n    if (canvasManager && typeof canvasManager.getCanvas === 'function') {\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    }\n    // Fallback to direct query\n    return document.querySelector('#tracking-canvas');\n};\n/**\n * Transform canvas coordinates to viewport coordinates when in fullscreen\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Object} point - {x, y} point coordinates\n * @returns {Object} Transformed point coordinates\n */ const transformCoordinates = (canvas, point)=>{\n    if (!canvas || !point) return point;\n    // Check if canvas is in fullscreen mode\n    const isFullscreen = canvas.style.position === 'fixed' && (canvas.style.width === '100vw' || canvas.style.width === '100%');\n    if (isFullscreen) {\n        // Get the canvas's bounding rect to understand its position in the viewport\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate the scale factors\n        const scaleX = canvasRect.width / canvas.width;\n        const scaleY = canvasRect.height / canvas.height;\n        // Transform the coordinates\n        const transformedPoint = {\n            x: point.x * scaleX + canvasRect.left,\n            y: point.y * scaleY + canvasRect.top,\n            label: point.label\n        };\n        console.log('Coordinate transformation in CalibratePoints:', {\n            original: point,\n            transformed: transformedPoint,\n            canvasRect,\n            scale: {\n                x: scaleX,\n                y: scaleY\n            }\n        });\n        return transformedPoint;\n    }\n    // If not fullscreen, return original coordinates\n    return point;\n};\n/**\n * Draw dot using the canvas management system\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @returns {boolean} Success status\n */ const drawDotWithCanvasManager = function(x, y) {\n    let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n    const { canvasUtils } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.drawDot === 'function') {\n        return canvasUtils.drawDot(x, y, radius);\n    }\n    // Fallback: manually draw dot\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        drawCalibrationPointLegacy(ctx, x, y, radius);\n        return true;\n    }\n    return false;\n};\n/**\n * Clear canvas using the canvas management system\n */ const clearCanvasWithManager = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.clear === 'function') {\n        canvasUtils.clear();\n        return;\n    }\n    if (canvasManager && typeof canvasManager.clear === 'function') {\n        canvasManager.clear();\n        return;\n    }\n    // Fallback: manually clear canvas\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n};\n/**\n * Generate a grid of calibration points based on canvas dimensions\n * @param {number} width - Canvas width\n * @param {number} height - Canvas height\n * @returns {Array} Array of point objects with x,y coordinates\n */ const generateCalibrationPoints = (width, height)=>{\n    if (!width || !height || width <= 0 || height <= 0) {\n        console.error(\"generateCalibrationPoints: Invalid canvas dimensions\", {\n            width,\n            height\n        });\n        return [];\n    }\n    const conditionalRound = (dimension, percentage)=>Math.round(dimension * percentage);\n    // Outer frame (12% from edges)\n    const xLeftOuter = conditionalRound(width, 0.12);\n    const xRightOuter = width - xLeftOuter;\n    const yTopOuter = conditionalRound(height, 0.12);\n    const yBottomOuter = height - yTopOuter;\n    // Inner frame (26% from edges)\n    const xLeftInner = conditionalRound(width, 0.26);\n    const xRightInner = width - xLeftInner;\n    const yTopInner = conditionalRound(height, 0.26);\n    const yBottomInner = height - yTopInner;\n    const xCenter = Math.floor(width / 2);\n    const yCenter = Math.floor(height / 2);\n    return [\n        // Outer frame (8 points)\n        {\n            x: xLeftOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopOuter,\n            label: \"Outer Top-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yCenter,\n            label: \"Outer Middle-Left\"\n        },\n        {\n            x: xRightOuter,\n            y: yCenter,\n            label: \"Outer Middle-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Right\"\n        },\n        // Inner frame (8 points)\n        {\n            x: xLeftInner,\n            y: yTopInner,\n            label: \"Inner Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopInner,\n            label: \"Inner Top-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yTopInner,\n            label: \"Inner Top-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yCenter,\n            label: \"Inner Middle-Left\"\n        },\n        {\n            x: xRightInner,\n            y: yCenter,\n            label: \"Inner Middle-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomInner,\n            label: \"Inner Bottom-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Right\"\n        }\n    ];\n};\n/**\n * Draw a calibration point on a canvas using the canvas management system\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {Object} options - Optional settings (color, radius)\n * @returns {Object} Point position object {x, y}\n */ const drawCalibrationPoint = function(x, y) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const radius = options.radius || 12; // Use standard radius\n    const success = drawDotWithCanvasManager(x, y, radius);\n    return {\n        x,\n        y,\n        success\n    };\n};\n/**\n * Legacy function for backward compatibility (draws directly on canvas context)\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @returns {Object} Point position object {x, y}\n */ const drawCalibrationPointLegacy = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12;\n    if (!ctx) return {\n        x,\n        y\n    };\n    const canvas = ctx.canvas;\n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'white';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * Draw all calibration points on a canvas (for debugging/visualization)\n * @param {Array} points - Array of point objects\n * @param {number} activeIndex - Index of the currently active point\n */ const drawCalibrationGrid = function(points) {\n    let activeIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;\n    if (!points || !points.length) return;\n    const canvas = getCanvas();\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    clearCanvasWithManager();\n    points.forEach((point, index)=>{\n        const isActive = index === activeIndex;\n        const radius = isActive ? 12 : 6; // Use standard radius for active, smaller for inactive\n        // Draw the point\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = isActive ? 'red' : 'rgba(0, 102, 204, 0.7)';\n        ctx.fill();\n        // Add glow effect for active points\n        if (isActive) {\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, radius + 3, 0, Math.PI * 2);\n            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n            ctx.lineWidth = 3;\n            ctx.stroke();\n        }\n        // Draw point number\n        ctx.fillStyle = 'white';\n        ctx.font = '10px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(\"\".concat(index + 1), point.x, point.y);\n        // Draw label for active point\n        if (isActive && point.label) {\n            ctx.font = '12px Arial';\n            ctx.fillStyle = 'black';\n            ctx.fillText(point.label, point.x, point.y - 25);\n        }\n    });\n    // Draw connecting lines (optional)\n    if (points.length > 1) {\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        for(let i = 1; i < points.length; i++){\n            ctx.lineTo(points[i].x, points[i].y);\n        }\n        ctx.strokeStyle = 'rgba(0, 102, 204, 0.3)';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n    }\n};\n/**\n * Clear all calibration points from canvas\n */ const clearCalibrationPoints = ()=>{\n    clearCanvasWithManager();\n};\n// Default export for React compatibility\nconst CalibratePoints = ()=>null; // This is a utility file, so we don't need to render anything\n_c = CalibratePoints;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibratePoints);\nvar _c;\n$RefreshReg$(_c, \"CalibratePoints\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHNCQUFzQjtBQUN0QixxRUFBcUU7QUFFM0M7QUFFMUI7OztDQUdDLEdBQ0QsTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUksSUFBNkIsRUFBRTtRQUNqQyxPQUFPO1lBQ0xDLGFBQWFDLE9BQU9ELFdBQVc7WUFDL0JFLGVBQWVELE9BQU9DLGFBQWE7UUFDckM7SUFDRjtJQUNBLE9BQU87UUFBRUYsYUFBYTtRQUFNRSxlQUFlO0lBQUs7QUFDbEQ7QUFFQTs7O0NBR0MsR0FDRCxNQUFNQyxZQUFZO0lBQ2hCLE1BQU0sRUFBRUgsV0FBVyxFQUFFRSxhQUFhLEVBQUUsR0FBR0g7SUFFdkMsb0RBQW9EO0lBQ3BELElBQUlDLGVBQWUsT0FBT0EsWUFBWUcsU0FBUyxLQUFLLFlBQVk7UUFDOUQsT0FBT0gsWUFBWUcsU0FBUztJQUM5QjtJQUVBLDRCQUE0QjtJQUM1QixJQUFJRCxpQkFBaUIsT0FBT0EsY0FBY0MsU0FBUyxLQUFLLFlBQVk7UUFDbEUsT0FBT0QsY0FBY0MsU0FBUyxNQUFNRCxjQUFjRSxZQUFZO0lBQ2hFO0lBRUEsMkJBQTJCO0lBQzNCLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztBQUNoQztBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUMsdUJBQXVCLENBQUNDLFFBQVFDO0lBQ3BDLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxPQUFPLE9BQU9BO0lBRTlCLHdDQUF3QztJQUN4QyxNQUFNQyxlQUFlRixPQUFPRyxLQUFLLENBQUNDLFFBQVEsS0FBSyxXQUMxQkosQ0FBQUEsT0FBT0csS0FBSyxDQUFDRSxLQUFLLEtBQUssV0FBV0wsT0FBT0csS0FBSyxDQUFDRSxLQUFLLEtBQUssTUFBSztJQUVuRixJQUFJSCxjQUFjO1FBQ2hCLDRFQUE0RTtRQUM1RSxNQUFNSSxh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Q25CN0MsSUFBSThDLFFBQVEsQ0FBQyxHQUFhLE9BQVZMLFFBQVEsSUFBS2pFLE1BQU1XLENBQUMsRUFBRVgsTUFBTWEsQ0FBQztRQUU3Qyw4QkFBOEI7UUFDOUIsSUFBSXFELFlBQVlsRSxNQUFNZSxLQUFLLEVBQUU7WUFDM0JTLElBQUkyQyxJQUFJLEdBQUc7WUFDWDNDLElBQUlNLFNBQVMsR0FBRztZQUNoQk4sSUFBSThDLFFBQVEsQ0FBQ3RFLE1BQU1lLEtBQUssRUFBRWYsTUFBTVcsQ0FBQyxFQUFFWCxNQUFNYSxDQUFDLEdBQUc7UUFDL0M7SUFDRjtJQUVBLG1DQUFtQztJQUNuQyxJQUFJZ0QsT0FBT0UsTUFBTSxHQUFHLEdBQUc7UUFDckJ2QyxJQUFJNkIsU0FBUztRQUNiN0IsSUFBSStDLE1BQU0sQ0FBQ1YsTUFBTSxDQUFDLEVBQUUsQ0FBQ2xELENBQUMsRUFBRWtELE1BQU0sQ0FBQyxFQUFFLENBQUNoRCxDQUFDO1FBQ25DLElBQUssSUFBSTJELElBQUksR0FBR0EsSUFBSVgsT0FBT0UsTUFBTSxFQUFFUyxJQUFLO1lBQ3RDaEQsSUFBSWlELE1BQU0sQ0FBQ1osTUFBTSxDQUFDVyxFQUFFLENBQUM3RCxDQUFDLEVBQUVrRCxNQUFNLENBQUNXLEVBQUUsQ0FBQzNELENBQUM7UUFDckM7UUFDQVcsSUFBSWlDLFdBQVcsR0FBRztRQUNsQmpDLElBQUlrQyxTQUFTLEdBQUc7UUFDaEJsQyxJQUFJbUMsTUFBTTtJQUNaO0FBQ0YsRUFBRTtBQUVGOztDQUVDLEdBQ00sTUFBTWUseUJBQXlCO0lBQ3BDL0M7QUFDRixFQUFFO0FBRUYseUNBQXlDO0FBQ3pDLE1BQU1nRCxrQkFBa0IsSUFBTSxNQUFNLDhEQUE4RDtLQUE1RkE7QUFFTixpRUFBZUEsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cy5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlUG9pbnRzLmpzeFxuLy8gVXRpbGl0eSBmb3IgZ2VuZXJhdGluZyBhbmQgbWFuYWdpbmcgY2FsaWJyYXRpb24gcG9pbnRzIG9uIGEgY2FudmFzXG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogR2V0IGNhbnZhcyBtYW5hZ2VtZW50IHV0aWxpdGllcyBmcm9tIGdsb2JhbCBzY29wZSAoZnJvbSBhY3Rpb25CdXR0b24uanMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDYW52YXMgdXRpbGl0aWVzIG9iamVjdFxuICovXG5jb25zdCBnZXRDYW52YXNVdGlscyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhc1V0aWxzOiB3aW5kb3cuY2FudmFzVXRpbHMsXG4gICAgICBjYW52YXNNYW5hZ2VyOiB3aW5kb3cuY2FudmFzTWFuYWdlclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgY2FudmFzVXRpbHM6IG51bGwsIGNhbnZhc01hbmFnZXI6IG51bGwgfTtcbn07XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgZWxlbWVudFxuICovXG5jb25zdCBnZXRDYW52YXMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXIgfSA9IGdldENhbnZhc1V0aWxzKCk7XG4gIFxuICAvLyBGaXJzdCB0cnkgdG8gdXNlIGNhbnZhc1V0aWxzIGZyb20gYWN0aW9uQnV0dG9uLmpzXG4gIGlmIChjYW52YXNVdGlscyAmJiB0eXBlb2YgY2FudmFzVXRpbHMuZ2V0Q2FudmFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNhbnZhc1V0aWxzLmdldENhbnZhcygpO1xuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBjYW52YXNNYW5hZ2VyXG4gIGlmIChjYW52YXNNYW5hZ2VyICYmIHR5cGVvZiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IGNhbnZhc01hbmFnZXIuY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCBxdWVyeVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gY2FudmFzIGNvb3JkaW5hdGVzIHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHdoZW4gaW4gZnVsbHNjcmVlblxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIHt4LCB5fSBwb2ludCBjb29yZGluYXRlc1xuICogQHJldHVybnMge09iamVjdH0gVHJhbnNmb3JtZWQgcG9pbnQgY29vcmRpbmF0ZXNcbiAqL1xuY29uc3QgdHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSAoY2FudmFzLCBwb2ludCkgPT4ge1xuICBpZiAoIWNhbnZhcyB8fCAhcG9pbnQpIHJldHVybiBwb2ludDtcbiAgXG4gIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgY29uc3QgaXNGdWxsc2NyZWVuID0gY2FudmFzLnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnICYmIFxuICAgICAgICAgICAgICAgICAgICAgIChjYW52YXMuc3R5bGUud2lkdGggPT09ICcxMDB2dycgfHwgY2FudmFzLnN0eWxlLndpZHRoID09PSAnMTAwJScpO1xuICBcbiAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgIC8vIEdldCB0aGUgY2FudmFzJ3MgYm91bmRpbmcgcmVjdCB0byB1bmRlcnN0YW5kIGl0cyBwb3NpdGlvbiBpbiB0aGUgdmlld3BvcnRcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yc1xuICAgIGNvbnN0IHNjYWxlWCA9IGNhbnZhc1JlY3Qud2lkdGggLyBjYW52YXMud2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gY2FudmFzUmVjdC5oZWlnaHQgLyBjYW52YXMuaGVpZ2h0O1xuICAgIFxuICAgIC8vIFRyYW5zZm9ybSB0aGUgY29vcmRpbmF0ZXNcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0ge1xuICAgICAgeDogcG9pbnQueCAqIHNjYWxlWCArIGNhbnZhc1JlY3QubGVmdCxcbiAgICAgIHk6IHBvaW50LnkgKiBzY2FsZVkgKyBjYW52YXNSZWN0LnRvcCxcbiAgICAgIGxhYmVsOiBwb2ludC5sYWJlbFxuICAgIH07XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0Nvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24gaW4gQ2FsaWJyYXRlUG9pbnRzOicsIHtcbiAgICAgIG9yaWdpbmFsOiBwb2ludCxcbiAgICAgIHRyYW5zZm9ybWVkOiB0cmFuc2Zvcm1lZFBvaW50LFxuICAgICAgY2FudmFzUmVjdCxcbiAgICAgIHNjYWxlOiB7IHg6IHNjYWxlWCwgeTogc2NhbGVZIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRQb2ludDtcbiAgfVxuICBcbiAgLy8gSWYgbm90IGZ1bGxzY3JlZW4sIHJldHVybiBvcmlnaW5hbCBjb29yZGluYXRlc1xuICByZXR1cm4gcG9pbnQ7XG59O1xuXG4vKipcbiAqIERyYXcgZG90IHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIERvdCByYWRpdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBTdWNjZXNzIHN0YXR1c1xuICovXG5jb25zdCBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIgPSAoeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgY29uc3QgeyBjYW52YXNVdGlscyB9ID0gZ2V0Q2FudmFzVXRpbHMoKTtcbiAgXG4gIGlmIChjYW52YXNVdGlscyAmJiB0eXBlb2YgY2FudmFzVXRpbHMuZHJhd0RvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYW52YXNVdGlscy5kcmF3RG90KHgsIHksIHJhZGl1cyk7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrOiBtYW51YWxseSBkcmF3IGRvdFxuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoKTtcbiAgaWYgKGNhbnZhcykge1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRyYXdDYWxpYnJhdGlvblBvaW50TGVnYWN5KGN0eCwgeCwgeSwgcmFkaXVzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENsZWFyIGNhbnZhcyB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gKi9cbmNvbnN0IGNsZWFyQ2FudmFzV2l0aE1hbmFnZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXIgfSA9IGdldENhbnZhc1V0aWxzKCk7XG4gIFxuICBpZiAoY2FudmFzVXRpbHMgJiYgdHlwZW9mIGNhbnZhc1V0aWxzLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FudmFzVXRpbHMuY2xlYXIoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIGlmIChjYW52YXNNYW5hZ2VyICYmIHR5cGVvZiBjYW52YXNNYW5hZ2VyLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGNsZWFyIGNhbnZhc1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoKTtcbiAgaWYgKGNhbnZhcykge1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGdyaWQgb2YgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIGNhbnZhcyBkaW1lbnNpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBDYW52YXMgd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBDYW52YXMgaGVpZ2h0XG4gKiBAcmV0dXJucyB7QXJyYXl9IEFycmF5IG9mIHBvaW50IG9iamVjdHMgd2l0aCB4LHkgY29vcmRpbmF0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQgfHwgd2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzOiBJbnZhbGlkIGNhbnZhcyBkaW1lbnNpb25zXCIsIHsgd2lkdGgsIGhlaWdodCB9KTtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBjb25kaXRpb25hbFJvdW5kID0gKGRpbWVuc2lvbiwgcGVyY2VudGFnZSkgPT4gTWF0aC5yb3VuZChkaW1lbnNpb24gKiBwZXJjZW50YWdlKTtcblxuICAvLyBPdXRlciBmcmFtZSAoMTIlIGZyb20gZWRnZXMpXG4gIGNvbnN0IHhMZWZ0T3V0ZXIgPSBjb25kaXRpb25hbFJvdW5kKHdpZHRoLCAwLjEyKTtcbiAgY29uc3QgeFJpZ2h0T3V0ZXIgPSB3aWR0aCAtIHhMZWZ0T3V0ZXI7XG4gIGNvbnN0IHlUb3BPdXRlciA9IGNvbmRpdGlvbmFsUm91bmQoaGVpZ2h0LCAwLjEyKTtcbiAgY29uc3QgeUJvdHRvbU91dGVyID0gaGVpZ2h0IC0geVRvcE91dGVyO1xuXG4gIC8vIElubmVyIGZyYW1lICgyNiUgZnJvbSBlZGdlcylcbiAgY29uc3QgeExlZnRJbm5lciA9IGNvbmRpdGlvbmFsUm91bmQod2lkdGgsIDAuMjYpO1xuICBjb25zdCB4UmlnaHRJbm5lciA9IHdpZHRoIC0geExlZnRJbm5lcjtcbiAgY29uc3QgeVRvcElubmVyID0gY29uZGl0aW9uYWxSb3VuZChoZWlnaHQsIDAuMjYpO1xuICBjb25zdCB5Qm90dG9tSW5uZXIgPSBoZWlnaHQgLSB5VG9wSW5uZXI7XG5cbiAgY29uc3QgeENlbnRlciA9IE1hdGguZmxvb3Iod2lkdGggLyAyKTtcbiAgY29uc3QgeUNlbnRlciA9IE1hdGguZmxvb3IoaGVpZ2h0IC8gMik7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBPdXRlciBmcmFtZSAoOCBwb2ludHMpXG4gICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5VG9wT3V0ZXIsIGxhYmVsOiBcIk91dGVyIFRvcC1MZWZ0XCIgfSxcbiAgICB7IHg6IHhDZW50ZXIsIHk6IHlUb3BPdXRlciwgbGFiZWw6IFwiT3V0ZXIgVG9wLUNlbnRlclwiIH0sXG4gICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeVRvcE91dGVyLCBsYWJlbDogXCJPdXRlciBUb3AtUmlnaHRcIiB9LFxuICAgIHsgeDogeExlZnRPdXRlciwgeTogeUNlbnRlciwgbGFiZWw6IFwiT3V0ZXIgTWlkZGxlLUxlZnRcIiB9LFxuICAgIHsgeDogeFJpZ2h0T3V0ZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIk91dGVyIE1pZGRsZS1SaWdodFwiIH0sXG4gICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5Qm90dG9tT3V0ZXIsIGxhYmVsOiBcIk91dGVyIEJvdHRvbS1MZWZ0XCIgfSxcbiAgICB7IHg6IHhDZW50ZXIsIHk6IHlCb3R0b21PdXRlciwgbGFiZWw6IFwiT3V0ZXIgQm90dG9tLUNlbnRlclwiIH0sXG4gICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeUJvdHRvbU91dGVyLCBsYWJlbDogXCJPdXRlciBCb3R0b20tUmlnaHRcIiB9LFxuXG4gICAgLy8gSW5uZXIgZnJhbWUgKDggcG9pbnRzKVxuICAgIHsgeDogeExlZnRJbm5lciwgeTogeVRvcElubmVyLCBsYWJlbDogXCJJbm5lciBUb3AtTGVmdFwiIH0sXG4gICAgeyB4OiB4Q2VudGVyLCB5OiB5VG9wSW5uZXIsIGxhYmVsOiBcIklubmVyIFRvcC1DZW50ZXJcIiB9LFxuICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlUb3BJbm5lciwgbGFiZWw6IFwiSW5uZXIgVG9wLVJpZ2h0XCIgfSxcbiAgICB7IHg6IHhMZWZ0SW5uZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIklubmVyIE1pZGRsZS1MZWZ0XCIgfSxcbiAgICB7IHg6IHhSaWdodElubmVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJJbm5lciBNaWRkbGUtUmlnaHRcIiB9LFxuICAgIHsgeDogeExlZnRJbm5lciwgeTogeUJvdHRvbUlubmVyLCBsYWJlbDogXCJJbm5lciBCb3R0b20tTGVmdFwiIH0sXG4gICAgeyB4OiB4Q2VudGVyLCB5OiB5Qm90dG9tSW5uZXIsIGxhYmVsOiBcIklubmVyIEJvdHRvbS1DZW50ZXJcIiB9LFxuICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlCb3R0b21Jbm5lciwgbGFiZWw6IFwiSW5uZXIgQm90dG9tLVJpZ2h0XCIgfVxuICBdO1xufTtcblxuLyoqXG4gKiBEcmF3IGEgY2FsaWJyYXRpb24gcG9pbnQgb24gYSBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbmFsIHNldHRpbmdzIChjb2xvciwgcmFkaXVzKVxuICogQHJldHVybnMge09iamVjdH0gUG9pbnQgcG9zaXRpb24gb2JqZWN0IHt4LCB5fVxuICovXG5leHBvcnQgY29uc3QgZHJhd0NhbGlicmF0aW9uUG9pbnQgPSAoeCwgeSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDEyOyAvLyBVc2Ugc3RhbmRhcmQgcmFkaXVzXG4gIGNvbnN0IHN1Y2Nlc3MgPSBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIoeCwgeSwgcmFkaXVzKTtcbiAgcmV0dXJuIHsgeCwgeSwgc3VjY2VzcyB9O1xufTtcblxuLyoqXG4gKiBMZWdhY3kgZnVuY3Rpb24gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKGRyYXdzIGRpcmVjdGx5IG9uIGNhbnZhcyBjb250ZXh0KVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQb2ludCBwb3NpdGlvbiBvYmplY3Qge3gsIHl9XG4gKi9cbmV4cG9ydCBjb25zdCBkcmF3Q2FsaWJyYXRpb25Qb2ludExlZ2FjeSA9IChjdHgsIHgsIHksIHJhZGl1cyA9IDEyKSA9PiB7XG4gIGlmICghY3R4KSByZXR1cm4geyB4LCB5IH07XG5cbiAgY29uc3QgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgXG4gIC8vIENsZWFyIHRoZSBjYW52YXNcbiAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICBjdHguZmlsbCgpO1xuICBcbiAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICBjdHgubGluZVdpZHRoID0gMztcbiAgY3R4LnN0cm9rZSgpO1xuICBcbiAgLy8gQWRkIGEgc2Vjb25kIGxhcmdlciBnbG93IGZvciBldmVuIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4zKSc7XG4gIGN0eC5saW5lV2lkdGggPSAyO1xuICBjdHguc3Ryb2tlKCk7XG5cbiAgcmV0dXJuIHsgeCwgeSB9O1xufTtcblxuLyoqXG4gKiBEcmF3IGFsbCBjYWxpYnJhdGlvbiBwb2ludHMgb24gYSBjYW52YXMgKGZvciBkZWJ1Z2dpbmcvdmlzdWFsaXphdGlvbilcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyAtIEFycmF5IG9mIHBvaW50IG9iamVjdHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhY3RpdmVJbmRleCAtIEluZGV4IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHBvaW50XG4gKi9cbmV4cG9ydCBjb25zdCBkcmF3Q2FsaWJyYXRpb25HcmlkID0gKHBvaW50cywgYWN0aXZlSW5kZXggPSAtMSkgPT4ge1xuICBpZiAoIXBvaW50cyB8fCAhcG9pbnRzLmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjbGVhckNhbnZhc1dpdGhNYW5hZ2VyKCk7XG5cbiAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaW5kZXggPT09IGFjdGl2ZUluZGV4O1xuICAgIGNvbnN0IHJhZGl1cyA9IGlzQWN0aXZlID8gMTIgOiA2OyAvLyBVc2Ugc3RhbmRhcmQgcmFkaXVzIGZvciBhY3RpdmUsIHNtYWxsZXIgZm9yIGluYWN0aXZlXG5cbiAgICAvLyBEcmF3IHRoZSBwb2ludFxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBpc0FjdGl2ZSA/ICdyZWQnIDogJ3JnYmEoMCwgMTAyLCAyMDQsIDAuNyknO1xuICAgIGN0eC5maWxsKCk7XG5cbiAgICAvLyBBZGQgZ2xvdyBlZmZlY3QgZm9yIGFjdGl2ZSBwb2ludHNcbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjUpJztcbiAgICAgIGN0eC5saW5lV2lkdGggPSAzO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIC8vIERyYXcgcG9pbnQgbnVtYmVyXG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZvbnQgPSAnMTBweCBBcmlhbCc7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZmlsbFRleHQoYCR7aW5kZXggKyAxfWAsIHBvaW50LngsIHBvaW50LnkpO1xuXG4gICAgLy8gRHJhdyBsYWJlbCBmb3IgYWN0aXZlIHBvaW50XG4gICAgaWYgKGlzQWN0aXZlICYmIHBvaW50LmxhYmVsKSB7XG4gICAgICBjdHguZm9udCA9ICcxMnB4IEFyaWFsJztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnYmxhY2snO1xuICAgICAgY3R4LmZpbGxUZXh0KHBvaW50LmxhYmVsLCBwb2ludC54LCBwb2ludC55IC0gMjUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gRHJhdyBjb25uZWN0aW5nIGxpbmVzIChvcHRpb25hbClcbiAgaWYgKHBvaW50cy5sZW5ndGggPiAxKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLCAxMDIsIDIwNCwgMC4zKSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFyIGFsbCBjYWxpYnJhdGlvbiBwb2ludHMgZnJvbSBjYW52YXNcbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFyQ2FsaWJyYXRpb25Qb2ludHMgPSAoKSA9PiB7XG4gIGNsZWFyQ2FudmFzV2l0aE1hbmFnZXIoKTtcbn07XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBSZWFjdCBjb21wYXRpYmlsaXR5XG5jb25zdCBDYWxpYnJhdGVQb2ludHMgPSAoKSA9PiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xuXG5leHBvcnQgZGVmYXVsdCBDYWxpYnJhdGVQb2ludHM7ICJdLCJuYW1lcyI6WyJSZWFjdCIsImdldENhbnZhc1V0aWxzIiwiY2FudmFzVXRpbHMiLCJ3aW5kb3ciLCJjYW52YXNNYW5hZ2VyIiwiZ2V0Q2FudmFzIiwiY3JlYXRlQ2FudmFzIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwidHJhbnNmb3JtQ29vcmRpbmF0ZXMiLCJjYW52YXMiLCJwb2ludCIsImlzRnVsbHNjcmVlbiIsInN0eWxlIiwicG9zaXRpb24iLCJ3aWR0aCIsImNhbnZhc1JlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJoZWlnaHQiLCJ0cmFuc2Zvcm1lZFBvaW50IiwieCIsImxlZnQiLCJ5IiwidG9wIiwibGFiZWwiLCJjb25zb2xlIiwibG9nIiwib3JpZ2luYWwiLCJ0cmFuc2Zvcm1lZCIsInNjYWxlIiwiZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyIiwicmFkaXVzIiwiZHJhd0RvdCIsImN0eCIsImdldENvbnRleHQiLCJkcmF3Q2FsaWJyYXRpb25Qb2ludExlZ2FjeSIsImNsZWFyQ2FudmFzV2l0aE1hbmFnZXIiLCJjbGVhciIsImNsZWFyUmVjdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsImVycm9yIiwiY29uZGl0aW9uYWxSb3VuZCIsImRpbWVuc2lvbiIsInBlcmNlbnRhZ2UiLCJNYXRoIiwicm91bmQiLCJ4TGVmdE91dGVyIiwieFJpZ2h0T3V0ZXIiLCJ5VG9wT3V0ZXIiLCJ5Qm90dG9tT3V0ZXIiLCJ4TGVmdElubmVyIiwieFJpZ2h0SW5uZXIiLCJ5VG9wSW5uZXIiLCJ5Qm90dG9tSW5uZXIiLCJ4Q2VudGVyIiwiZmxvb3IiLCJ5Q2VudGVyIiwiZHJhd0NhbGlicmF0aW9uUG9pbnQiLCJvcHRpb25zIiwic3VjY2VzcyIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiZHJhd0NhbGlicmF0aW9uR3JpZCIsInBvaW50cyIsImFjdGl2ZUluZGV4IiwibGVuZ3RoIiwiZm9yRWFjaCIsImluZGV4IiwiaXNBY3RpdmUiLCJmb250IiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwiZmlsbFRleHQiLCJtb3ZlVG8iLCJpIiwibGluZVRvIiwiY2xlYXJDYWxpYnJhdGlvblBvaW50cyIsIkNhbGlicmF0ZVBvaW50cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.jsx\n"));

/***/ })

});