"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx":
/*!**********************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/countSave.jsx ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calibrationCapture: () => (/* binding */ calibrationCapture),\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// Fixed countSave.jsx - Resolving redrawInterval reference error\n// Shared functionality for countdown and image capture processes\n\n\n/**\n * Get canvas management utilities from global scope (from actionButton.js)\n * @returns {Object} Canvas utilities object\n */ const getCanvasUtils = ()=>{\n    if (true) {\n        return {\n            canvasUtils: window.canvasUtils,\n            canvasManager: window.canvasManager\n        };\n    }\n    return {\n        canvasUtils: null,\n        canvasManager: null\n    };\n};\n/**\n * Get or create canvas using the canvas management system from actionButton.js\n * @returns {HTMLCanvasElement} Canvas element\n */ const getCanvas = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    // First try to use canvasUtils from actionButton.js\n    if (canvasUtils && typeof canvasUtils.getCanvas === 'function') {\n        return canvasUtils.getCanvas();\n    }\n    // Fallback to canvasManager\n    if (canvasManager && typeof canvasManager.getCanvas === 'function') {\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    }\n    // Fallback to direct query\n    return document.querySelector('#tracking-canvas');\n};\n/**\n * Transform canvas coordinates to viewport coordinates when in fullscreen\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Object} point - {x, y} point coordinates\n * @returns {Object} Transformed point coordinates\n */ const transformCoordinates = (canvas, point)=>{\n    if (!canvas || !point) return point;\n    // Check if canvas is in fullscreen mode\n    const isFullscreen = canvas.style.position === 'fixed' && (canvas.style.width === '100vw' || canvas.style.width === '100%');\n    if (isFullscreen) {\n        // Get the canvas's bounding rect to understand its position in the viewport\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate the scale factors\n        const scaleX = canvasRect.width / canvas.width;\n        const scaleY = canvasRect.height / canvas.height;\n        // Transform the coordinates\n        const transformedPoint = {\n            x: point.x * scaleX + canvasRect.left,\n            y: point.y * scaleY + canvasRect.top,\n            label: point.label\n        };\n        console.log('Coordinate transformation in countSave:', {\n            original: point,\n            transformed: transformedPoint,\n            canvasRect,\n            scale: {\n                x: scaleX,\n                y: scaleY\n            }\n        });\n        return transformedPoint;\n    }\n    // If not fullscreen, return original coordinates\n    return point;\n};\n/**\n * Draw dot using the canvas management system\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @returns {boolean} Success status\n */ const drawDotWithCanvasManager = function(x, y) {\n    let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n    const { canvasUtils } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.drawDot === 'function') {\n        return canvasUtils.drawDot(x, y, radius);\n    }\n    // Fallback: manually draw dot\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, x, y, radius, false);\n        return true;\n    }\n    return false;\n};\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    // Remove any existing countdown elements\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup, .dot-countdown, .test-countdown');\n    existingCountdowns.forEach((el)=>{\n        console.log('Removing existing countdown element:', el);\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    });\n    // Get canvas to check if we need coordinate transformation\n    const canvas = getCanvas();\n    let displayPosition = position;\n    if (canvas) {\n        // Check if canvas is in fullscreen mode\n        const isFullscreen = canvas.style.position === 'fixed' && (canvas.style.width === '100vw' || canvas.style.width === '100%');\n        if (isFullscreen) {\n            // Canvas is in fullscreen mode, use direct coordinates\n            displayPosition = {\n                x: position.x,\n                y: position.y\n            };\n        } else {\n            // Canvas is in normal mode, use canvas-relative coordinates\n            displayPosition = {\n                x: canvasRect.left + position.x,\n                y: canvasRect.top + position.y\n            };\n        }\n    }\n    console.log('[createCountdownElement] Creating countdown at position:', {\n        original: position,\n        display: displayPosition,\n        canvasRect: canvasRect,\n        canvasFullscreen: canvas ? canvas.style.position === 'fixed' && canvas.style.width === '100vw' : false\n    });\n    // Create the main countdown element\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(displayPosition.x, \"px;\\n    top: \").concat(displayPosition.y - 80, \"px;\\n    transform: translateX(-50%);\\n    color: red;\\n    font-size: 64px;\\n    font-weight: bold;\\n    text-shadow: 0 0 20px white, 0 0 30px white, 0 0 40px white;\\n    z-index: 100000;\\n    background-color: rgba(255, 255, 255, 0.98);\\n    border: 4px solid red;\\n    border-radius: 50%;\\n    width: 100px;\\n    height: 100px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 30px rgba(0, 0, 0, 0.7), 0 0 50px rgba(255, 0, 0, 0.5);\\n    animation: countdownPulse 1s infinite;\\n    pointer-events: none;\\n    user-select: none;\\n  \");\n    // Add CSS animation for pulse effect\n    if (!document.querySelector('#countdown-styles')) {\n        const style = document.createElement('style');\n        style.id = 'countdown-styles';\n        style.textContent = \"\\n      @keyframes countdownPulse {\\n        0% { transform: translateX(-50%) scale(1); }\\n        50% { transform: translateX(-50%) scale(1.1); }\\n        100% { transform: translateX(-50%) scale(1); }\\n      }\\n    \";\n        document.head.appendChild(style);\n    }\n    document.body.appendChild(countdownElement);\n    console.log('createCountdownElement created at:', {\n        originalPosition: position,\n        displayPosition,\n        canvasRect,\n        canvasInfo: canvas ? {\n            position: canvas.style.position,\n            width: canvas.style.width,\n            height: canvas.style.height,\n            rect: canvas.getBoundingClientRect()\n        } : null\n    });\n    // // Create a backup countdown element centered on screen as fallback\n    // const backupCountdown = document.createElement('div');\n    // backupCountdown.className = 'backup-countdown';\n    // backupCountdown.style.cssText = `\n    //   position: fixed;\n    //   top: 50%;\n    //   left: 50%;\n    //   transform: translate(-50%, -50%);\n    //   color: red;\n    //   font-size: 72px;\n    //   font-weight: bold;\n    //   text-shadow: 0 0 25px white, 0 0 35px white, 0 0 45px white;\n    //   z-index: 100001;\n    //   background-color: rgba(255, 255, 255, 0.98);\n    //   border: 5px solid red;\n    //   border-radius: 50%;\n    //   width: 120px;\n    //   height: 120px;\n    //   display: flex;\n    //   justify-content: center;\n    //   align-items: center;\n    //   box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 60px rgba(255, 0, 0, 0.6);\n    //   animation: countdownPulse 1s infinite;\n    //   pointer-events: none;\n    //   user-select: none;\n    // `;\n    // document.body.appendChild(backupCountdown);\n    // Add a temporary visual indicator to show where the countdown is positioned\n    const indicator = document.createElement('div');\n    indicator.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(displayPosition.x, \"px;\\n    top: \").concat(displayPosition.y, \"px;\\n    width: 10px;\\n    height: 10px;\\n    background-color: blue;\\n    border-radius: 50%;\\n    z-index: 10000;\\n    pointer-events: none;\\n  \");\n    document.body.appendChild(indicator);\n    // Remove indicator after 2 seconds\n    setTimeout(()=>{\n        if (indicator.parentNode) {\n            indicator.parentNode.removeChild(indicator);\n        }\n    }, 2000);\n    return countdownElement;\n};\n/**\n * Display a preview of the captured images\n * @param {string} screenImage - Data URL of the screen image\n * @param {string} webcamImage - Data URL of the webcam image\n * @param {Object} point - {x, y} position of the dot\n */ const showCapturePreview = (screenImage, webcamImage, point)=>{\n    if (!screenImage && !webcamImage) return;\n    // Remove any existing previews\n    const existingPreviews = document.querySelectorAll('.capture-preview-container');\n    existingPreviews.forEach((preview)=>{\n        if (preview.parentNode) {\n            preview.parentNode.removeChild(preview);\n        }\n    });\n    // Create preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    display: flex;\\n    gap: 20px;\\n    background-color: rgba(0, 0, 0, 0.85);\\n    padding: 20px;\\n    border-radius: 12px;\\n    z-index: 999999;\\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n  \";\n    // Add screen image if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.alt = 'Screen Capture';\n        screenImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam image if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.alt = 'Webcam Capture';\n        webcamImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add point info\n    if (point) {\n        const pointInfo = document.createElement('div');\n        pointInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Point: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n        pointInfo.style.cssText = \"\\n      color: #ffcc00;\\n      font-size: 14px;\\n      position: absolute;\\n      top: -40px;\\n      left: 0;\\n      width: 100%;\\n      text-align: center;\\n    \";\n        previewContainer.appendChild(pointInfo);\n    }\n    // Add timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n    position: absolute;\\n    bottom: -25px;\\n    right: 20px;\\n    color: white;\\n    font-size: 12px;\\n    background-color: rgba(0, 0, 0, 0.7);\\n    padding: 3px 8px;\\n    border-radius: 4px;\\n  \";\n    previewContainer.appendChild(timerElement);\n    // Add to document\n    document.body.appendChild(previewContainer);\n    // Countdown\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            previewContainer.style.opacity = '0';\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    // Get the backup countdown element\n    const backupCountdown1 = document.querySelector('.backup-countdown');\n    // Use canvas management system to draw dot\n    drawDotWithCanvasManager(position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    if (backupCountdown1) {\n        backupCountdown1.textContent = count;\n    }\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    // Create redrawInterval for keeping dot visible during countdown\n    let redrawInterval = setInterval(()=>{\n        drawDotWithCanvasManager(position.x, position.y);\n    }, 200);\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                if (backupCountdown1) {\n                    backupCountdown1.textContent = \"✓\";\n                }\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    // Remove both countdown elements\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    if (backupCountdown1 && backupCountdown1.parentNode) {\n                        backupCountdown1.parentNode.removeChild(backupCountdown1);\n                    }\n                    drawDotWithCanvasManager(position.x, position.y);\n                    // Clear the redrawInterval we defined above\n                    if (redrawInterval) {\n                        clearInterval(redrawInterval);\n                    }\n                    if (onComplete) {\n                        drawDotWithCanvasManager(position.x, position.y);\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                if (backupCountdown1) {\n                    backupCountdown1.textContent = count;\n                }\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n * Draw a red dot on the canvas (legacy function for backward compatibility)\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n * @returns {Object} - {x, y} position\n */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'yellow';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    console.log(\"Drew red dot at (\".concat(x, \", \").concat(y, \") with radius \").concat(radius));\n    return {\n        x,\n        y\n    };\n};\n/**\n * Get highest resolution camera constraints\n * @returns {Promise<Object>} - Camera constraints\n */ const getHighestResolutionConstraints = async ()=>{\n    try {\n        // Get all video input devices\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const videoDevices = devices.filter((device)=>device.kind === 'videoinput');\n        if (videoDevices.length === 0) {\n            console.warn('No video devices found, using default constraints');\n            return {\n                video: true\n            };\n        }\n        // Try to get capabilities for the first video device\n        const stream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        const videoTrack = stream.getVideoTracks()[0];\n        if (!videoTrack.getCapabilities) {\n            console.warn('getCapabilities not supported, using default constraints');\n            stream.getTracks().forEach((track)=>track.stop());\n            return {\n                video: true\n            };\n        }\n        const capabilities = videoTrack.getCapabilities();\n        stream.getTracks().forEach((track)=>track.stop());\n        if (!capabilities.width || !capabilities.height) {\n            console.warn('No width/height capabilities, using default constraints');\n            return {\n                video: true\n            };\n        }\n        // Get the highest resolution available\n        const maxWidth = Math.max(...capabilities.width.values);\n        const maxHeight = Math.max(...capabilities.height.values);\n        console.log(\"Using highest resolution: \".concat(maxWidth, \"x\").concat(maxHeight));\n        return {\n            video: {\n                width: {\n                    ideal: maxWidth\n                },\n                height: {\n                    ideal: maxHeight\n                },\n                frameRate: {\n                    ideal: 30\n                }\n            }\n        };\n    } catch (error) {\n        console.warn('Error getting camera constraints, using default:', error);\n        return {\n            video: true\n        };\n    }\n};\n/**\n * Capture images at a specific point\n * @param {Object} options - Capture options\n * @returns {Promise} - Promise that resolves with the capture result\n */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[captureImages] Invalid position object:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid capture position');\n        return null;\n    }\n    try {\n        // Get highest resolution constraints\n        const constraints = await getHighestResolutionConstraints();\n        console.log('Using camera constraints:', constraints);\n        // Get a new stream with the highest resolution\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        const videoTrack = stream.getVideoTracks()[0];\n        const settings = videoTrack.getSettings();\n        console.log('Actual camera settings:', settings);\n        // Update video element with new stream\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            videoElement.srcObject = stream;\n            await videoElement.play();\n        }\n        // Call the captureImagesAtPoint with all necessary parameters\n        const result = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        console.log('Capture successful with ID:', result.captureId);\n        // Clean up the stream\n        stream.getTracks().forEach((track)=>track.stop());\n        return {\n            screenImage: (result === null || result === void 0 ? void 0 : result.screenImage) || '',\n            webcamImage: (result === null || result === void 0 ? void 0 : result.webcamImage) || '',\n            success: true,\n            captureId: result === null || result === void 0 ? void 0 : result.captureId,\n            resolution: {\n                width: settings.width,\n                height: settings.height\n            }\n        };\n    } catch (err) {\n        console.error('[captureImages] Unexpected error:', err);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: err.message\n        };\n    }\n};\n/**\n * Generate a random dot position within the canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} padding - Padding from the edges\n * @returns {Object} - {x, y} position\n */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n * Special calibration capture function that behaves like random dot capture\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ const calibrationCapture = async (options)=>{\n    const { canvasRef, point, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures', pointIndex, totalPoints } = options;\n    try {\n        console.log(\"Starting calibration capture for point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Get canvas using canvas management system\n        const canvas = getCanvas();\n        if (!canvas) {\n            console.error(\"Canvas reference is null in calibrationCapture\");\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: Canvas not available\");\n            return {\n                success: false\n            };\n        }\n        // Use canvas management system to draw dot\n        drawDotWithCanvasManager(point.x, point.y);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Calibration point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Use the same countdown element creation method\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = createCountdownElement(point, canvasRect);\n        if (!countdownElement) {\n            console.error(\"Failed to create countdown element\");\n            return {\n                success: false\n            };\n        }\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawDotWithCanvasManager(point.x, point.y);\n        }, 200);\n        // Run the same countdown as random dot\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Point \".concat(pointIndex + 1, \"/\").concat(totalPoints, \" - countdown \").concat(count));\n            // Redraw the dot at each step to ensure it remains visible\n            drawDotWithCanvasManager(point.x, point.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show checkmark\n        countdownElement.textContent = \"✓\";\n        // Remove countdown element\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Clear redrawInterval\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureAndPreviewProcess instead of directly calling captureImagesAtPoint\n        const captureResult = await captureAndPreviewProcess({\n            canvasRef,\n            position: point,\n            captureCounter,\n            setCaptureCounter,\n            setProcessStatus: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            captureFolder\n        });\n        // Ensure proper return even if captureResult is null\n        const safeResult = captureResult && typeof captureResult === 'object' ? captureResult : {\n            screenImage: '',\n            webcamImage: '',\n            success: false\n        };\n        return {\n            screenImage: safeResult.screenImage || '',\n            webcamImage: safeResult.webcamImage || '',\n            success: true,\n            point\n        };\n    } catch (error) {\n        console.error(\"Error in calibrationCapture:\", error);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(error.message));\n        // Always return a valid object with default values\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Complete capture and preview process\n * @param {Object} options - Process options\n */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder } = options;\n    try {\n        // Get canvas using canvas management system\n        const canvas = getCanvas();\n        if (!canvas) {\n            console.error(\"[captureAndPreviewProcess] Canvas reference is null\");\n            if (setProcessStatus) setProcessStatus('Error: Canvas is not available');\n            return null;\n        }\n        // Draw the dot using canvas management system\n        drawDotWithCanvasManager(position.x, position.y);\n        // Countdown before capture\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Starting countdown...',\n                isCapturing: true\n            });\n        }\n        // Remove any existing countdown elements first\n        const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .dot-countdown, .forced-countdown, .center-countdown-backup');\n        existingCountdowns.forEach((el)=>{\n            console.log('captureAndPreviewProcess: Removing existing countdown:', el);\n            el.remove();\n        });\n        // Create a custom countdown element\n        const canvasRect = canvas.getBoundingClientRect();\n        // Transform coordinates for fullscreen display\n        let displayPosition = position;\n        if (canvas.style.position === 'fixed' && canvas.style.width === '100vw') {\n            // Canvas is in fullscreen mode, use direct coordinates\n            displayPosition = {\n                x: position.x,\n                y: position.y\n            };\n        } else {\n            // Canvas is in normal mode, use canvas-relative coordinates\n            displayPosition = {\n                x: canvasRect.left + position.x,\n                y: canvasRect.top + position.y\n            };\n        }\n        console.log('captureAndPreviewProcess: Creating countdown at:', {\n            originalPosition: position,\n            displayPosition,\n            canvasRect,\n            canvasStyle: {\n                position: canvas.style.position,\n                width: canvas.style.width,\n                height: canvas.style.height\n            }\n        });\n        const countdownElement = document.createElement('div');\n        countdownElement.className = 'calibrate-countdown';\n        countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(displayPosition.x, \"px;\\n      top: \").concat(displayPosition.y - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 48px;\\n      font-weight: bold;\\n      text-shadow: 0 0 15px white, 0 0 25px white, 0 0 35px white;\\n      z-index: 100000;\\n      background-color: rgba(255, 255, 255, 0.95);\\n      border: 3px solid red;\\n      border-radius: 50%;\\n      width: 80px;\\n      height: 80px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), 0 0 40px rgba(255, 0, 0, 0.3);\\n      animation: pulse 1s infinite;\\n    \");\n        document.body.appendChild(countdownElement);\n        console.log('captureAndPreviewProcess: Created countdown element:', {\n            element: countdownElement,\n            style: countdownElement.style.cssText,\n            position: {\n                x: displayPosition.x,\n                y: displayPosition.y - 60\n            }\n        });\n        // Create a backup countdown in the center of the screen\n        // const backupCountdown = document.createElement('div');\n        // backupCountdown.className = 'backup-countdown';\n        // backupCountdown.textContent = '3';\n        // backupCountdown.style.cssText = `\n        //   position: fixed;\n        //   left: 50%;\n        //   top: 50%;\n        //   transform: translate(-50%, -50%);\n        //   color: red;\n        //   font-size: 72px;\n        //   font-weight: bold;\n        //   text-shadow: 0 0 20px white, 0 0 30px white, 0 0 40px white;\n        //   z-index: 100001;\n        //   background-color: rgba(255, 255, 255, 0.95);\n        //   border: 4px solid red;\n        //   border-radius: 50%;\n        //   width: 120px;\n        //   height: 120px;\n        //   display: flex;\n        //   justify-content: center;\n        //   align-items: center;\n        //   box-shadow: 0 0 30px rgba(0, 0, 0, 0.7), 0 0 60px rgba(255, 0, 0, 0.5);\n        // `;\n        // document.body.appendChild(backupCountdown);\n        // console.log('captureAndPreviewProcess: Created backup countdown in center');\n        console.log('Countdown element created at:', {\n            position,\n            displayPosition,\n            canvasRect,\n            canvasStyle: {\n                position: canvas.style.position,\n                width: canvas.style.width,\n                height: canvas.style.height\n            }\n        });\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawDotWithCanvasManager(position.x, position.y);\n        }, 200);\n        // Manual countdown\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            backupCountdown.textContent = count;\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n            // Redraw dot to ensure it's visible\n            drawDotWithCanvasManager(position.x, position.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Change to checkmark\n        countdownElement.textContent = \"✓\";\n        backupCountdown.textContent = \"✓\";\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capturing images...',\n                countdownValue: \"Capturing...\",\n                isCapturing: true\n            });\n        }\n        // Remove countdown elements and clear redrawInterval\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            if (backupCountdown.parentNode) {\n                backupCountdown.parentNode.removeChild(backupCountdown);\n            }\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureImagesAtPoint from savefile.js\n        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured dot at x=\".concat(Math.round(position.x), \", y=\").concat(Math.round(position.y)));\n        }\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capture complete',\n                isCapturing: false\n            });\n        }\n        // Show TopBar again with delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"[captureAndPreviewProcess] Fatal error:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Fatal error: \".concat(error.message));\n        }\n        // Ensure TopBar is shown even on error\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        // Return a minimal valid object to prevent null reference errors\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n// Default export for React compatibility\nconst CountSave = ()=>null; // This is a utility file, so we don't need to render anything\n_c = CountSave;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CountSave);\nvar _c;\n$RefreshReg$(_c, \"CountSave\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ3ZDO0FBQ2dDO0FBRTFEOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQjtJQUNyQixJQUFJLElBQTZCLEVBQUU7UUFDakMsT0FBTztZQUNMQyxhQUFhQyxPQUFPRCxXQUFXO1lBQy9CRSxlQUFlRCxPQUFPQyxhQUFhO1FBQ3JDO0lBQ0Y7SUFDQSxPQUFPO1FBQUVGLGFBQWE7UUFBTUUsZUFBZTtJQUFLO0FBQ2xEO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsWUFBWTtJQUNoQixNQUFNLEVBQUVILFdBQVcsRUFBRUUsYUFBYSxFQUFFLEdBQUdIO0lBRXZDLG9EQUFvRDtJQUNwRCxJQUFJQyxlQUFlLE9BQU9BLFlBQVlHLFNBQVMsS0FBSyxZQUFZO1FBQzlELE9BQU9ILFlBQVlHLFNBQVM7SUFDOUI7SUFFQSw0QkFBNEI7SUFDNUIsSUFBSUQsaUJBQWlCLE9BQU9BLGNBQWNDLFNBQVMsS0FBSyxZQUFZO1FBQ2xFLE9BQU9ELGNBQWNDLFNBQVMsTUFBTUQsY0FBY0UsWUFBWTtJQUNoRTtJQUVBLDJCQUEyQjtJQUMzQixPQUFPQyxTQUFTQyxhQUFhLENBQUM7QUFDaEM7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLHVCQUF1QixDQUFDQyxRQUFRQztJQUNwQyxJQUFJLENBQUNELFVBQVUsQ0FBQ0MsT0FBTyxPQUFPQTtJQUU5Qix3Q0FBd0M7SUFDeEMsTUFBTUMsZUFBZUYsT0FBT0csS0FBSyxDQUFDQyxRQUFRLEtBQUssV0FDMUJKLENBQUFBLE9BQU9HLEtBQUssQ0FBQ0UsS0FBSyxLQUFLLFdBQVdMLE9BQU9HLEtBQUssQ0FBQ0UsS0FBSyxLQUFLLE1BQUs7SUFFbkYsSUFBSUgsY0FBYztRQUNoQiw0RUFBNEU7UUFDNUUsTUFB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Q3ZDakcsV0FBVztZQUNULElBQUksT0FBT2tGLGlCQUFpQixZQUFZO2dCQUN0Q0EsYUFBYTtZQUNmLE9BQU8sSUFBSSxLQUE2QixJQUFJN0ksT0FBTzZJLFlBQVksRUFBRTtnQkFDL0Q3SSxPQUFPNkksWUFBWSxDQUFDO1lBQ3RCO1FBQ0YsR0FBRztRQUVILGlFQUFpRTtRQUNqRSxPQUFPO1lBQ0xoRixhQUFhO1lBQ2JDLGFBQWE7WUFDYjJGLFNBQVM7WUFDVG5CLE9BQU9BLE1BQU1zQixPQUFPO1FBQ3RCO0lBQ0Y7QUFDRixFQUFFO0FBRUYseUNBQXlDO0FBQ3pDLE1BQU1lLFlBQVksSUFBTSxNQUFNLDhEQUE4RDtLQUF0RkE7QUFFTixpRUFBZUEsU0FBU0EsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL2NvdW50U2F2ZS5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRml4ZWQgY291bnRTYXZlLmpzeCAtIFJlc29sdmluZyByZWRyYXdJbnRlcnZhbCByZWZlcmVuY2UgZXJyb3Jcbi8vIFNoYXJlZCBmdW5jdGlvbmFsaXR5IGZvciBjb3VudGRvd24gYW5kIGltYWdlIGNhcHR1cmUgcHJvY2Vzc2VzXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi9IZWxwZXIvc2F2ZWZpbGUnO1xuXG4vKipcbiAqIEdldCBjYW52YXMgbWFuYWdlbWVudCB1dGlsaXRpZXMgZnJvbSBnbG9iYWwgc2NvcGUgKGZyb20gYWN0aW9uQnV0dG9uLmpzKVxuICogQHJldHVybnMge09iamVjdH0gQ2FudmFzIHV0aWxpdGllcyBvYmplY3RcbiAqL1xuY29uc3QgZ2V0Q2FudmFzVXRpbHMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXNVdGlsczogd2luZG93LmNhbnZhc1V0aWxzLFxuICAgICAgY2FudmFzTWFuYWdlcjogd2luZG93LmNhbnZhc01hbmFnZXJcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGNhbnZhc1V0aWxzOiBudWxsLCBjYW52YXNNYW5hZ2VyOiBudWxsIH07XG59O1xuXG4vKipcbiAqIEdldCBvciBjcmVhdGUgY2FudmFzIHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW0gZnJvbSBhY3Rpb25CdXR0b24uanNcbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH0gQ2FudmFzIGVsZW1lbnRcbiAqL1xuY29uc3QgZ2V0Q2FudmFzID0gKCkgPT4ge1xuICBjb25zdCB7IGNhbnZhc1V0aWxzLCBjYW52YXNNYW5hZ2VyIH0gPSBnZXRDYW52YXNVdGlscygpO1xuICBcbiAgLy8gRmlyc3QgdHJ5IHRvIHVzZSBjYW52YXNVdGlscyBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICBpZiAoY2FudmFzVXRpbHMgJiYgdHlwZW9mIGNhbnZhc1V0aWxzLmdldENhbnZhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYW52YXNVdGlscy5nZXRDYW52YXMoKTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gY2FudmFzTWFuYWdlclxuICBpZiAoY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgY2FudmFzTWFuYWdlci5nZXRDYW52YXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpO1xuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBkaXJlY3QgcXVlcnlcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKTtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGNhbnZhcyBjb29yZGluYXRlcyB0byB2aWV3cG9ydCBjb29yZGluYXRlcyB3aGVuIGluIGZ1bGxzY3JlZW5cbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgLSB7eCwgeX0gcG9pbnQgY29vcmRpbmF0ZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRyYW5zZm9ybWVkIHBvaW50IGNvb3JkaW5hdGVzXG4gKi9cbmNvbnN0IHRyYW5zZm9ybUNvb3JkaW5hdGVzID0gKGNhbnZhcywgcG9pbnQpID0+IHtcbiAgaWYgKCFjYW52YXMgfHwgIXBvaW50KSByZXR1cm4gcG9pbnQ7XG4gIFxuICAvLyBDaGVjayBpZiBjYW52YXMgaXMgaW4gZnVsbHNjcmVlbiBtb2RlXG4gIGNvbnN0IGlzRnVsbHNjcmVlbiA9IGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAoY2FudmFzLnN0eWxlLndpZHRoID09PSAnMTAwdncnIHx8IGNhbnZhcy5zdHlsZS53aWR0aCA9PT0gJzEwMCUnKTtcbiAgXG4gIGlmIChpc0Z1bGxzY3JlZW4pIHtcbiAgICAvLyBHZXQgdGhlIGNhbnZhcydzIGJvdW5kaW5nIHJlY3QgdG8gdW5kZXJzdGFuZCBpdHMgcG9zaXRpb24gaW4gdGhlIHZpZXdwb3J0XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvcnNcbiAgICBjb25zdCBzY2FsZVggPSBjYW52YXNSZWN0LndpZHRoIC8gY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IHNjYWxlWSA9IGNhbnZhc1JlY3QuaGVpZ2h0IC8gY2FudmFzLmhlaWdodDtcbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgdHJhbnNmb3JtZWRQb2ludCA9IHtcbiAgICAgIHg6IHBvaW50LnggKiBzY2FsZVggKyBjYW52YXNSZWN0LmxlZnQsXG4gICAgICB5OiBwb2ludC55ICogc2NhbGVZICsgY2FudmFzUmVjdC50b3AsXG4gICAgICBsYWJlbDogcG9pbnQubGFiZWxcbiAgICB9O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uIGluIGNvdW50U2F2ZTonLCB7XG4gICAgICBvcmlnaW5hbDogcG9pbnQsXG4gICAgICB0cmFuc2Zvcm1lZDogdHJhbnNmb3JtZWRQb2ludCxcbiAgICAgIGNhbnZhc1JlY3QsXG4gICAgICBzY2FsZTogeyB4OiBzY2FsZVgsIHk6IHNjYWxlWSB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkUG9pbnQ7XG4gIH1cbiAgXG4gIC8vIElmIG5vdCBmdWxsc2NyZWVuLCByZXR1cm4gb3JpZ2luYWwgY29vcmRpbmF0ZXNcbiAgcmV0dXJuIHBvaW50O1xufTtcblxuLyoqXG4gKiBEcmF3IGRvdCB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gU3VjY2VzcyBzdGF0dXNcbiAqL1xuY29uc3QgZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyID0gKHgsIHksIHJhZGl1cyA9IDEyKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzVXRpbHMgfSA9IGdldENhbnZhc1V0aWxzKCk7XG4gIFxuICBpZiAoY2FudmFzVXRpbHMgJiYgdHlwZW9mIGNhbnZhc1V0aWxzLmRyYXdEb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2FudmFzVXRpbHMuZHJhd0RvdCh4LCB5LCByYWRpdXMpO1xuICB9XG4gIFxuICAvLyBGYWxsYmFjazogbWFudWFsbHkgZHJhdyBkb3RcbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKCk7XG4gIGlmIChjYW52YXMpIHtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkcmF3UmVkRG90KGN0eCwgeCwgeSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIGRpc3BsYXlzIGEgY291bnRkb3duIGVsZW1lbnQgYWJvdmUgYSBkb3QgcG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKiBAcGFyYW0ge0RPTVJlY3R9IGNhbnZhc1JlY3QgLSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBvZiB0aGUgY2FudmFzXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IC0gVGhlIGNyZWF0ZWQgY291bnRkb3duIGVsZW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQgPSAocG9zaXRpb24sIGNhbnZhc1JlY3QpID0+IHtcbiAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgY29uc29sZS53YXJuKCdbY3JlYXRlQ291bnRkb3duRWxlbWVudF0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FsaWJyYXRlLWNvdW50ZG93biwgLmZvcmNlZC1jb3VudGRvd24sIC5jZW50ZXItY291bnRkb3duLWJhY2t1cCwgLmRvdC1jb3VudGRvd24sIC50ZXN0LWNvdW50ZG93bicpO1xuICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgY29uc29sZS5sb2coJ1JlbW92aW5nIGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50OicsIGVsKTtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBHZXQgY2FudmFzIHRvIGNoZWNrIGlmIHdlIG5lZWQgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoKTtcbiAgbGV0IGRpc3BsYXlQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICBcbiAgaWYgKGNhbnZhcykge1xuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICBjb25zdCBpc0Z1bGxzY3JlZW4gPSBjYW52YXMuc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2FudmFzLnN0eWxlLndpZHRoID09PSAnMTAwdncnIHx8IGNhbnZhcy5zdHlsZS53aWR0aCA9PT0gJzEwMCUnKTtcbiAgICBcbiAgICBpZiAoaXNGdWxsc2NyZWVuKSB7XG4gICAgICAvLyBDYW52YXMgaXMgaW4gZnVsbHNjcmVlbiBtb2RlLCB1c2UgZGlyZWN0IGNvb3JkaW5hdGVzXG4gICAgICBkaXNwbGF5UG9zaXRpb24gPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLngsXG4gICAgICAgIHk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbnZhcyBpcyBpbiBub3JtYWwgbW9kZSwgdXNlIGNhbnZhcy1yZWxhdGl2ZSBjb29yZGluYXRlc1xuICAgICAgZGlzcGxheVBvc2l0aW9uID0ge1xuICAgICAgICB4OiBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54LFxuICAgICAgICB5OiBjYW52YXNSZWN0LnRvcCArIHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY29uc29sZS5sb2coJ1tjcmVhdGVDb3VudGRvd25FbGVtZW50XSBDcmVhdGluZyBjb3VudGRvd24gYXQgcG9zaXRpb246Jywge1xuICAgIG9yaWdpbmFsOiBwb3NpdGlvbixcbiAgICBkaXNwbGF5OiBkaXNwbGF5UG9zaXRpb24sXG4gICAgY2FudmFzUmVjdDogY2FudmFzUmVjdCxcbiAgICBjYW52YXNGdWxsc2NyZWVuOiBjYW52YXMgPyAoY2FudmFzLnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnICYmIGNhbnZhcy5zdHlsZS53aWR0aCA9PT0gJzEwMHZ3JykgOiBmYWxzZVxuICB9KTtcblxuICAvLyBDcmVhdGUgdGhlIG1haW4gY291bnRkb3duIGVsZW1lbnRcbiAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBsZWZ0OiAke2Rpc3BsYXlQb3NpdGlvbi54fXB4O1xuICAgIHRvcDogJHtkaXNwbGF5UG9zaXRpb24ueSAtIDgwfXB4O1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICBjb2xvcjogcmVkO1xuICAgIGZvbnQtc2l6ZTogNjRweDtcbiAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICB0ZXh0LXNoYWRvdzogMCAwIDIwcHggd2hpdGUsIDAgMCAzMHB4IHdoaXRlLCAwIDAgNDBweCB3aGl0ZTtcbiAgICB6LWluZGV4OiAxMDAwMDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk4KTtcbiAgICBib3JkZXI6IDRweCBzb2xpZCByZWQ7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIHdpZHRoOiAxMDBweDtcbiAgICBoZWlnaHQ6IDEwMHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBib3gtc2hhZG93OiAwIDAgMzBweCByZ2JhKDAsIDAsIDAsIDAuNyksIDAgMCA1MHB4IHJnYmEoMjU1LCAwLCAwLCAwLjUpO1xuICAgIGFuaW1hdGlvbjogY291bnRkb3duUHVsc2UgMXMgaW5maW5pdGU7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIGA7XG4gIFxuICAvLyBBZGQgQ1NTIGFuaW1hdGlvbiBmb3IgcHVsc2UgZWZmZWN0XG4gIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI2NvdW50ZG93bi1zdHlsZXMnKSkge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBzdHlsZS5pZCA9ICdjb3VudGRvd24tc3R5bGVzJztcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IGBcbiAgICAgIEBrZXlmcmFtZXMgY291bnRkb3duUHVsc2Uge1xuICAgICAgICAwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSBzY2FsZSgxKTsgfVxuICAgICAgICA1MCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgc2NhbGUoMS4xKTsgfVxuICAgICAgICAxMDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHNjYWxlKDEpOyB9XG4gICAgICB9XG4gICAgYDtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gIFxuICBjb25zb2xlLmxvZygnY3JlYXRlQ291bnRkb3duRWxlbWVudCBjcmVhdGVkIGF0OicsIHtcbiAgICBvcmlnaW5hbFBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICBkaXNwbGF5UG9zaXRpb24sXG4gICAgY2FudmFzUmVjdCxcbiAgICBjYW52YXNJbmZvOiBjYW52YXMgPyB7XG4gICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgIHJlY3Q6IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIH0gOiBudWxsXG4gIH0pO1xuICBcbiAgLy8gLy8gQ3JlYXRlIGEgYmFja3VwIGNvdW50ZG93biBlbGVtZW50IGNlbnRlcmVkIG9uIHNjcmVlbiBhcyBmYWxsYmFja1xuICAvLyBjb25zdCBiYWNrdXBDb3VudGRvd24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgLy8gYmFja3VwQ291bnRkb3duLmNsYXNzTmFtZSA9ICdiYWNrdXAtY291bnRkb3duJztcbiAgLy8gYmFja3VwQ291bnRkb3duLnN0eWxlLmNzc1RleHQgPSBgXG4gIC8vICAgcG9zaXRpb246IGZpeGVkO1xuICAvLyAgIHRvcDogNTAlO1xuICAvLyAgIGxlZnQ6IDUwJTtcbiAgLy8gICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgLy8gICBjb2xvcjogcmVkO1xuICAvLyAgIGZvbnQtc2l6ZTogNzJweDtcbiAgLy8gICBmb250LXdlaWdodDogYm9sZDtcbiAgLy8gICB0ZXh0LXNoYWRvdzogMCAwIDI1cHggd2hpdGUsIDAgMCAzNXB4IHdoaXRlLCAwIDAgNDVweCB3aGl0ZTtcbiAgLy8gICB6LWluZGV4OiAxMDAwMDE7XG4gIC8vICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk4KTtcbiAgLy8gICBib3JkZXI6IDVweCBzb2xpZCByZWQ7XG4gIC8vICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAvLyAgIHdpZHRoOiAxMjBweDtcbiAgLy8gICBoZWlnaHQ6IDEyMHB4O1xuICAvLyAgIGRpc3BsYXk6IGZsZXg7XG4gIC8vICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIC8vICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgLy8gICBib3gtc2hhZG93OiAwIDAgNDBweCByZ2JhKDAsIDAsIDAsIDAuOCksIDAgMCA2MHB4IHJnYmEoMjU1LCAwLCAwLCAwLjYpO1xuICAvLyAgIGFuaW1hdGlvbjogY291bnRkb3duUHVsc2UgMXMgaW5maW5pdGU7XG4gIC8vICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIC8vICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC8vIGA7XG4gIC8vIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYmFja3VwQ291bnRkb3duKTtcbiAgXG4gIC8vIEFkZCBhIHRlbXBvcmFyeSB2aXN1YWwgaW5kaWNhdG9yIHRvIHNob3cgd2hlcmUgdGhlIGNvdW50ZG93biBpcyBwb3NpdGlvbmVkXG4gIGNvbnN0IGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBpbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgbGVmdDogJHtkaXNwbGF5UG9zaXRpb24ueH1weDtcbiAgICB0b3A6ICR7ZGlzcGxheVBvc2l0aW9uLnl9cHg7XG4gICAgd2lkdGg6IDEwcHg7XG4gICAgaGVpZ2h0OiAxMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IGJsdWU7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIHotaW5kZXg6IDEwMDAwO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBgO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluZGljYXRvcik7XG4gIFxuICAvLyBSZW1vdmUgaW5kaWNhdG9yIGFmdGVyIDIgc2Vjb25kc1xuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoaW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgIGluZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluZGljYXRvcik7XG4gICAgfVxuICB9LCAyMDAwKTtcbiAgXG4gIHJldHVybiBjb3VudGRvd25FbGVtZW50O1xufTtcblxuLyoqXG4gKiBEaXNwbGF5IGEgcHJldmlldyBvZiB0aGUgY2FwdHVyZWQgaW1hZ2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2NyZWVuSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgc2NyZWVuIGltYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gd2ViY2FtSW1hZ2UgLSBEYXRhIFVSTCBvZiB0aGUgd2ViY2FtIGltYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICovXG5leHBvcnQgY29uc3Qgc2hvd0NhcHR1cmVQcmV2aWV3ID0gKHNjcmVlbkltYWdlLCB3ZWJjYW1JbWFnZSwgcG9pbnQpID0+IHtcbiAgaWYgKCFzY3JlZW5JbWFnZSAmJiAhd2ViY2FtSW1hZ2UpIHJldHVybjtcbiAgXG4gIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgcHJldmlld3NcbiAgY29uc3QgZXhpc3RpbmdQcmV2aWV3cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXB0dXJlLXByZXZpZXctY29udGFpbmVyJyk7XG4gIGV4aXN0aW5nUHJldmlld3MuZm9yRWFjaChwcmV2aWV3ID0+IHtcbiAgICBpZiAocHJldmlldy5wYXJlbnROb2RlKSB7XG4gICAgICBwcmV2aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlldyk7XG4gICAgfVxuICB9KTtcbiAgXG4gIC8vIENyZWF0ZSBwcmV2aWV3IGNvbnRhaW5lclxuICBjb25zdCBwcmV2aWV3Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHByZXZpZXdDb250YWluZXIuY2xhc3NOYW1lID0gJ2NhcHR1cmUtcHJldmlldy1jb250YWluZXInO1xuICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogNTAlO1xuICAgIGxlZnQ6IDUwJTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuODUpO1xuICAgIHBhZGRpbmc6IDIwcHg7XG4gICAgYm9yZGVyLXJhZGl1czogMTJweDtcbiAgICB6LWluZGV4OiA5OTk5OTk7XG4gICAgYm94LXNoYWRvdzogMCA4cHggMjVweCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gIGA7XG4gIFxuICAvLyBBZGQgc2NyZWVuIGltYWdlIGlmIGF2YWlsYWJsZVxuICBpZiAoc2NyZWVuSW1hZ2UpIHtcbiAgICBjb25zdCBzY3JlZW5QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2NyZWVuUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgc2NyZWVuSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgc2NyZWVuSW1nLnNyYyA9IHNjcmVlbkltYWdlO1xuICAgIHNjcmVlbkltZy5hbHQgPSAnU2NyZWVuIENhcHR1cmUnO1xuICAgIHNjcmVlbkltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgc2NyZWVuTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JlZW5MYWJlbC50ZXh0Q29udGVudCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgc2NyZWVuTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBgO1xuICAgIFxuICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuSW1nKTtcbiAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkxhYmVsKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHNjcmVlblByZXZpZXcpO1xuICB9XG4gIFxuICAvLyBBZGQgd2ViY2FtIGltYWdlIGlmIGF2YWlsYWJsZVxuICBpZiAod2ViY2FtSW1hZ2UpIHtcbiAgICBjb25zdCB3ZWJjYW1QcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd2ViY2FtUHJldmlldy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgd2ViY2FtSW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgd2ViY2FtSW1nLnNyYyA9IHdlYmNhbUltYWdlO1xuICAgIHdlYmNhbUltZy5hbHQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgIHdlYmNhbUltZy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICAgIG1heC1oZWlnaHQ6IDI0MHB4O1xuICAgICAgYm9yZGVyOiAzcHggc29saWQgd2hpdGU7XG4gICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzMzO1xuICAgIGA7XG4gICAgXG4gICAgY29uc3Qgd2ViY2FtTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3ZWJjYW1MYWJlbC50ZXh0Q29udGVudCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgd2ViY2FtTGFiZWwuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIG1hcmdpbi10b3A6IDEwcHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICBgO1xuICAgIFxuICAgIHdlYmNhbVByZXZpZXcuYXBwZW5kQ2hpbGQod2ViY2FtSW1nKTtcbiAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUxhYmVsKTtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHdlYmNhbVByZXZpZXcpO1xuICB9XG4gIFxuICAvLyBBZGQgcG9pbnQgaW5mb1xuICBpZiAocG9pbnQpIHtcbiAgICBjb25zdCBwb2ludEluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBwb2ludEluZm8udGV4dENvbnRlbnQgPSBwb2ludC5sYWJlbCA/IFxuICAgICAgYCR7cG9pbnQubGFiZWx9OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWAgOlxuICAgICAgYFBvaW50OiB4PSR7TWF0aC5yb3VuZChwb2ludC54KX0sIHk9JHtNYXRoLnJvdW5kKHBvaW50LnkpfWA7XG4gICAgICBcbiAgICBwb2ludEluZm8uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGNvbG9yOiAjZmZjYzAwO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgdG9wOiAtNDBweDtcbiAgICAgIGxlZnQ6IDA7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBgO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQocG9pbnRJbmZvKTtcbiAgfVxuICBcbiAgLy8gQWRkIHRpbWVyXG4gIGNvbnN0IHRpbWVyRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSAnMi4wcyc7XG4gIHRpbWVyRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IC0yNXB4O1xuICAgIHJpZ2h0OiAyMHB4O1xuICAgIGNvbG9yOiB3aGl0ZTtcbiAgICBmb250LXNpemU6IDEycHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjcpO1xuICAgIHBhZGRpbmc6IDNweCA4cHg7XG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBgO1xuICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHRpbWVyRWxlbWVudCk7XG4gIFxuICAvLyBBZGQgdG8gZG9jdW1lbnRcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgXG4gIC8vIENvdW50ZG93blxuICBsZXQgdGltZUxlZnQgPSAyLjA7XG4gIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIHRpbWVMZWZ0IC09IDAuMTtcbiAgICBpZiAodGltZUxlZnQgPD0gMCkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnN0eWxlLnRyYW5zaXRpb24gPSAnb3BhY2l0eSAwLjNzIGVhc2UnO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9IGAke3RpbWVMZWZ0LnRvRml4ZWQoMSl9c2A7XG4gICAgfVxuICB9LCAxMDApO1xuICBcbiAgLy8gU2FmZXR5IGNsZWFudXBcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgIH1cbiAgfSwgNTAwMCk7XG59O1xuXG4vKipcbiAqIFJ1bnMgYSBjb3VudGRvd24gcHJvY2VzcyB0aGF0IGRpc3BsYXlzIDMtMi0xIGFib3ZlIGEgZG90XG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSB7eCwgeX0gcG9zaXRpb24gb2YgdGhlIGRvdFxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnQgd2l0aCB0aGUgZG90XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblN0YXR1c1VwZGF0ZSAtIEZ1bmN0aW9uIHRvIHVwZGF0ZSBzdGF0dXMgbWVzc2FnZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uQ29tcGxldGUgLSBDYWxsYmFjayB0byBleGVjdXRlIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICovXG5leHBvcnQgY29uc3QgcnVuQ291bnRkb3duID0gYXN5bmMgKHBvc2l0aW9uLCBjYW52YXMsIG9uU3RhdHVzVXBkYXRlLCBvbkNvbXBsZXRlKSA9PiB7XG4gIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gSW52YWxpZCBwb3NpdGlvbjonLCBwb3NpdGlvbik7XG4gICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICBwcm9jZXNzU3RhdHVzOiBcIkludmFsaWQgZG90IHBvc2l0aW9uXCIsXG4gICAgICBjb3VudGRvd25WYWx1ZTogbnVsbCxcbiAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvc2l0aW9uLCBjYW52YXNSZWN0KTtcbiAgXG4gIGlmICghY291bnRkb3duRWxlbWVudCkge1xuICAgIGNvbnNvbGUud2FybignW3J1bkNvdW50ZG93bl0gQ291bnRkb3duIGVsZW1lbnQgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gR2V0IHRoZSBiYWNrdXAgY291bnRkb3duIGVsZW1lbnRcbiAgY29uc3QgYmFja3VwQ291bnRkb3duID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmJhY2t1cC1jb3VudGRvd24nKTtcblxuICAvLyBVc2UgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtIHRvIGRyYXcgZG90XG4gIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICBsZXQgY291bnQgPSAzO1xuICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gIGlmIChiYWNrdXBDb3VudGRvd24pIHtcbiAgICBiYWNrdXBDb3VudGRvd24udGV4dENvbnRlbnQgPSBjb3VudDtcbiAgfVxuXG4gIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgY291bnRkb3duVmFsdWU6IGNvdW50LFxuICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSByZWRyYXdJbnRlcnZhbCBmb3Iga2VlcGluZyBkb3QgdmlzaWJsZSBkdXJpbmcgY291bnRkb3duXG4gIGxldCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gIH0sIDIwMCk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgY291bnRkb3duSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb3VudC0tO1xuXG4gICAgICBpZiAoY291bnQgPD0gMCkge1xuICAgICAgICBjbGVhckludGVydmFsKGNvdW50ZG93bkludGVydmFsKTtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgIGlmIChiYWNrdXBDb3VudGRvd24pIHtcbiAgICAgICAgICBiYWNrdXBDb3VudGRvd24udGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICB9XG5cbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgY291bnRkb3duVmFsdWU6IFwiQ2FwdHVyaW5nLi4uXCIsXG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJDYXB0dXJpbmcgaW1hZ2UuLi5cIixcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyBSZW1vdmUgYm90aCBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYWNrdXBDb3VudGRvd24gJiYgYmFja3VwQ291bnRkb3duLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGJhY2t1cENvdW50ZG93bi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2t1cENvdW50ZG93bik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICAgICAgICAgIC8vIENsZWFyIHRoZSByZWRyYXdJbnRlcnZhbCB3ZSBkZWZpbmVkIGFib3ZlXG4gICAgICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICAgICAgZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIGlmIChiYWNrdXBDb3VudGRvd24pIHtcbiAgICAgICAgICBiYWNrdXBDb3VudGRvd24udGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgfVxuXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgICAgICAgY291bnRkb3duVmFsdWU6IGNvdW50LFxuICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIDgwMCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3IGEgcmVkIGRvdCBvbiB0aGUgY2FudmFzIChsZWdhY3kgZnVuY3Rpb24gZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ2FudmFzIDJEIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIERvdCByYWRpdXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXJDYW52YXMgLSBXaGV0aGVyIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGRyYXdpbmcgKGRlZmF1bHQ6IHRydWUpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHt4LCB5fSBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3QgZHJhd1JlZERvdCA9IChjdHgsIHgsIHksIHJhZGl1cyA9IDEyLCBjbGVhckNhbnZhcyA9IHRydWUpID0+IHtcbiAgY29uc3QgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgXG4gIC8vIENsZWFyIHRoZSBjYW52YXMgaWYgcmVxdWVzdGVkIChkZWZhdWx0IGJlaGF2aW9yKVxuICBpZiAoY2xlYXJDYW52YXMpIHtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd5ZWxsb3cnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9XG4gIFxuICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBhIGJyaWdodCByZWQgY29sb3JcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gIGN0eC5maWxsKCk7XG4gIFxuICAvLyBBZGQgZ2xvdyBlZmZlY3QgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC41KSc7XG4gIGN0eC5saW5lV2lkdGggPSAzO1xuICBjdHguc3Ryb2tlKCk7XG4gIFxuICAvLyBBZGQgYSBzZWNvbmQgbGFyZ2VyIGdsb3cgZm9yIGV2ZW4gYmV0dGVyIHZpc2liaWxpdHlcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIHJhZGl1cyArIDYsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjMpJztcbiAgY3R4LmxpbmVXaWR0aCA9IDI7XG4gIGN0eC5zdHJva2UoKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBEcmV3IHJlZCBkb3QgYXQgKCR7eH0sICR7eX0pIHdpdGggcmFkaXVzICR7cmFkaXVzfWApO1xuICByZXR1cm4geyB4LCB5IH07XG59O1xuXG4vKipcbiAqIEdldCBoaWdoZXN0IHJlc29sdXRpb24gY2FtZXJhIGNvbnN0cmFpbnRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENhbWVyYSBjb25zdHJhaW50c1xuICovXG5jb25zdCBnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIC8vIEdldCBhbGwgdmlkZW8gaW5wdXQgZGV2aWNlc1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICBjb25zdCB2aWRlb0RldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkZXZpY2UgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgXG4gICAgaWYgKHZpZGVvRGV2aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gdmlkZW8gZGV2aWNlcyBmb3VuZCwgdXNpbmcgZGVmYXVsdCBjb25zdHJhaW50cycpO1xuICAgICAgcmV0dXJuIHsgdmlkZW86IHRydWUgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGdldCBjYXBhYmlsaXRpZXMgZm9yIHRoZSBmaXJzdCB2aWRlbyBkZXZpY2VcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICBcbiAgICBpZiAoIXZpZGVvVHJhY2suZ2V0Q2FwYWJpbGl0aWVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2dldENhcGFiaWxpdGllcyBub3Qgc3VwcG9ydGVkLCB1c2luZyBkZWZhdWx0IGNvbnN0cmFpbnRzJyk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgcmV0dXJuIHsgdmlkZW86IHRydWUgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdmlkZW9UcmFjay5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgIFxuICAgIGlmICghY2FwYWJpbGl0aWVzLndpZHRoIHx8ICFjYXBhYmlsaXRpZXMuaGVpZ2h0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHdpZHRoL2hlaWdodCBjYXBhYmlsaXRpZXMsIHVzaW5nIGRlZmF1bHQgY29uc3RyYWludHMnKTtcbiAgICAgIHJldHVybiB7IHZpZGVvOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgaGlnaGVzdCByZXNvbHV0aW9uIGF2YWlsYWJsZVxuICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5tYXgoLi4uY2FwYWJpbGl0aWVzLndpZHRoLnZhbHVlcyk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoLi4uY2FwYWJpbGl0aWVzLmhlaWdodC52YWx1ZXMpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBVc2luZyBoaWdoZXN0IHJlc29sdXRpb246ICR7bWF4V2lkdGh9eCR7bWF4SGVpZ2h0fWApO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB2aWRlbzoge1xuICAgICAgICB3aWR0aDogeyBpZGVhbDogbWF4V2lkdGggfSxcbiAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiBtYXhIZWlnaHQgfSxcbiAgICAgICAgZnJhbWVSYXRlOiB7IGlkZWFsOiAzMCB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGdldHRpbmcgY2FtZXJhIGNvbnN0cmFpbnRzLCB1c2luZyBkZWZhdWx0OicsIGVycm9yKTtcbiAgICByZXR1cm4geyB2aWRlbzogdHJ1ZSB9O1xuICB9XG59O1xuXG4vKipcbiAqIENhcHR1cmUgaW1hZ2VzIGF0IGEgc3BlY2lmaWMgcG9pbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY2FwdHVyZSByZXN1bHRcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcHR1cmVJbWFnZXMgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1JlZixcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgY2FwdHVyZUNvdW50ZXIsIFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKCdbY2FwdHVyZUltYWdlc10gSW52YWxpZCBwb3NpdGlvbiBvYmplY3Q6JywgcG9zaXRpb24pO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKCdFcnJvcjogSW52YWxpZCBjYXB0dXJlIHBvc2l0aW9uJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgaGlnaGVzdCByZXNvbHV0aW9uIGNvbnN0cmFpbnRzXG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IGdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBjYW1lcmEgY29uc3RyYWludHM6JywgY29uc3RyYWludHMpO1xuICAgICAgXG4gICAgICAvLyBHZXQgYSBuZXcgc3RyZWFtIHdpdGggdGhlIGhpZ2hlc3QgcmVzb2x1dGlvblxuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICBjb25zb2xlLmxvZygnQWN0dWFsIGNhbWVyYSBzZXR0aW5nczonLCBzZXR0aW5ncyk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB2aWRlbyBlbGVtZW50IHdpdGggbmV3IHN0cmVhbVxuICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gd2luZG93LnZpZGVvRWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgICAgaWYgKHZpZGVvRWxlbWVudCkge1xuICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICBhd2FpdCB2aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxsIHRoZSBjYXB0dXJlSW1hZ2VzQXRQb2ludCB3aXRoIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIGNhbnZhc1JlZiwgXG4gICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgfSk7XG4gIFxuICAgICAgY29uc29sZS5sb2coJ0NhcHR1cmUgc3VjY2Vzc2Z1bCB3aXRoIElEOicsIHJlc3VsdC5jYXB0dXJlSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgc3RyZWFtXG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogcmVzdWx0Py5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHJlc3VsdD8ud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGNhcHR1cmVJZDogcmVzdWx0Py5jYXB0dXJlSWQsXG4gICAgICAgIHJlc29sdXRpb246IHtcbiAgICAgICAgICB3aWR0aDogc2V0dGluZ3Mud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzZXR0aW5ncy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYXB0dXJlSW1hZ2VzXSBVbmV4cGVjdGVkIGVycm9yOicsIGVycik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGRvdCBwb3NpdGlvbiB3aXRoaW4gdGhlIGNhbnZhc1xuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gUGFkZGluZyBmcm9tIHRoZSBlZGdlc1xuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gIGlmICghY2FudmFzKSByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICBcbiAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IHx8IDMwMDsgLy8gRmFsbGJhY2sgaWYgaGVpZ2h0IGlzIDBcbiAgXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdpZHRoIC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmcsXG4gICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nXG4gIH07XG59O1xuXG4vKipcbiAqIFNwZWNpYWwgY2FsaWJyYXRpb24gY2FwdHVyZSBmdW5jdGlvbiB0aGF0IGJlaGF2ZXMgbGlrZSByYW5kb20gZG90IGNhcHR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWxsIHRoZSBjYWxpYnJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZWQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgY2FsaWJyYXRpb25DYXB0dXJlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb2ludCxcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLFxuICAgICAgcG9pbnRJbmRleCxcbiAgICAgIHRvdGFsUG9pbnRzXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FsaWJyYXRpb24gY2FwdHVyZSBmb3IgcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhcyB1c2luZyBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgICAgIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbCBpbiBjYWxpYnJhdGlvbkNhcHR1cmVcIik7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6IENhbnZhcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gVXNlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSB0byBkcmF3IGRvdFxuICAgICAgZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyKHBvaW50LngsIHBvaW50LnkpO1xuICBcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgQ2FsaWJyYXRpb24gcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgY291bnRkb3duIGVsZW1lbnQgY3JlYXRpb24gbWV0aG9kXG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9pbnQsIGNhbnZhc1JlY3QpO1xuICAgICAgXG4gICAgICBpZiAoIWNvdW50ZG93bkVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY291bnRkb3duIGVsZW1lbnRcIik7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgZm9yIGtlZXBpbmcgdGhlIGRvdCB2aXNpYmxlXG4gICAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH0sIDIwMCk7XG4gIFxuICAgICAgLy8gUnVuIHRoZSBzYW1lIGNvdW50ZG93biBhcyByYW5kb20gZG90XG4gICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgUG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c30gLSBjb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgZG90IGF0IGVhY2ggc3RlcCB0byBlbnN1cmUgaXQgcmVtYWlucyB2aXNpYmxlXG4gICAgICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIHJlZHJhd0ludGVydmFsXG4gICAgICAgIGlmIChyZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICBcbiAgICAgIC8vIFVzZSBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgaW5zdGVhZCBvZiBkaXJlY3RseSBjYWxsaW5nIGNhcHR1cmVJbWFnZXNBdFBvaW50XG4gICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzKHtcbiAgICAgICAgY2FudmFzUmVmLFxuICAgICAgICBwb3NpdGlvbjogcG9pbnQsXG4gICAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1czogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgJiYgdHlwZW9mIHN0YXR1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMucHJvY2Vzc1N0YXR1cyB8fCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXR1cyAmJiB0eXBlb2Ygc3RhdHVzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cy5wcm9jZXNzU3RhdHVzIHx8ICcnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmVGb2xkZXJcbiAgICAgIH0pO1xuICBcbiAgICAgIC8vIEVuc3VyZSBwcm9wZXIgcmV0dXJuIGV2ZW4gaWYgY2FwdHVyZVJlc3VsdCBpcyBudWxsXG4gICAgICBjb25zdCBzYWZlUmVzdWx0ID0gY2FwdHVyZVJlc3VsdCAmJiB0eXBlb2YgY2FwdHVyZVJlc3VsdCA9PT0gJ29iamVjdCcgXG4gICAgICAgID8gY2FwdHVyZVJlc3VsdCBcbiAgICAgICAgOiB7IHNjcmVlbkltYWdlOiAnJywgd2ViY2FtSW1hZ2U6ICcnLCBzdWNjZXNzOiBmYWxzZSB9O1xuICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbkltYWdlOiBzYWZlUmVzdWx0LnNjcmVlbkltYWdlIHx8ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogc2FmZVJlc3VsdC53ZWJjYW1JbWFnZSB8fCAnJyxcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgcG9pbnRcbiAgICAgIH07XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNhbGlicmF0aW9uQ2FwdHVyZTpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgXG4gICAgICAvLyBBbHdheXMgcmV0dXJuIGEgdmFsaWQgb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6ICcnLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIENvbXBsZXRlIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2Vzc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQcm9jZXNzIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjYW52YXNSZWYsXG4gICAgcG9zaXRpb24sXG4gICAgY2FwdHVyZUNvdW50ZXIsXG4gICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICB0b2dnbGVUb3BCYXIsXG4gICAgb25TdGF0dXNVcGRhdGUsXG4gICAgY2FwdHVyZUZvbGRlclxuICB9ID0gb3B0aW9ucztcblxuICB0cnkge1xuICAgIC8vIEdldCBjYW52YXMgdXNpbmcgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKCk7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBDYW52YXMgcmVmZXJlbmNlIGlzIG51bGxcIik7XG4gICAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6IENhbnZhcyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSBkb3QgdXNpbmcgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuXG4gICAgLy8gQ291bnRkb3duIGJlZm9yZSBjYXB0dXJlXG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdTdGFydGluZyBjb3VudGRvd24uLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHMgZmlyc3RcbiAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FsaWJyYXRlLWNvdW50ZG93biwgLmRvdC1jb3VudGRvd24sIC5mb3JjZWQtY291bnRkb3duLCAuY2VudGVyLWNvdW50ZG93bi1iYWNrdXAnKTtcbiAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzOiBSZW1vdmluZyBleGlzdGluZyBjb3VudGRvd246JywgZWwpO1xuICAgICAgZWwucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIGEgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBcbiAgICAvLyBUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgZm9yIGZ1bGxzY3JlZW4gZGlzcGxheVxuICAgIGxldCBkaXNwbGF5UG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBpZiAoY2FudmFzLnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnICYmIGNhbnZhcy5zdHlsZS53aWR0aCA9PT0gJzEwMHZ3Jykge1xuICAgICAgLy8gQ2FudmFzIGlzIGluIGZ1bGxzY3JlZW4gbW9kZSwgdXNlIGRpcmVjdCBjb29yZGluYXRlc1xuICAgICAgZGlzcGxheVBvc2l0aW9uID0ge1xuICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICB5OiBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYW52YXMgaXMgaW4gbm9ybWFsIG1vZGUsIHVzZSBjYW52YXMtcmVsYXRpdmUgY29vcmRpbmF0ZXNcbiAgICAgIGRpc3BsYXlQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogY2FudmFzUmVjdC5sZWZ0ICsgcG9zaXRpb24ueCxcbiAgICAgICAgeTogY2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzOiBDcmVhdGluZyBjb3VudGRvd24gYXQ6Jywge1xuICAgICAgb3JpZ2luYWxQb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICBkaXNwbGF5UG9zaXRpb24sXG4gICAgICBjYW52YXNSZWN0LFxuICAgICAgY2FudmFzU3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1jb3VudGRvd24nO1xuICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgIGxlZnQ6ICR7ZGlzcGxheVBvc2l0aW9uLnh9cHg7XG4gICAgICB0b3A6ICR7ZGlzcGxheVBvc2l0aW9uLnkgLSA2MH1weDtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgIGNvbG9yOiByZWQ7XG4gICAgICBmb250LXNpemU6IDQ4cHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHRleHQtc2hhZG93OiAwIDAgMTVweCB3aGl0ZSwgMCAwIDI1cHggd2hpdGUsIDAgMCAzNXB4IHdoaXRlO1xuICAgICAgei1pbmRleDogMTAwMDAwO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KTtcbiAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA4MHB4O1xuICAgICAgaGVpZ2h0OiA4MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAyMHB4IHJnYmEoMCwgMCwgMCwgMC41KSwgMCAwIDQwcHggcmdiYSgyNTUsIDAsIDAsIDAuMyk7XG4gICAgICBhbmltYXRpb246IHB1bHNlIDFzIGluZmluaXRlO1xuICAgIGA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzOiBDcmVhdGVkIGNvdW50ZG93biBlbGVtZW50OicsIHtcbiAgICAgIGVsZW1lbnQ6IGNvdW50ZG93bkVsZW1lbnQsXG4gICAgICBzdHlsZTogY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0LFxuICAgICAgcG9zaXRpb246IHsgeDogZGlzcGxheVBvc2l0aW9uLngsIHk6IGRpc3BsYXlQb3NpdGlvbi55IC0gNjAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGJhY2t1cCBjb3VudGRvd24gaW4gdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuXG4gICAgLy8gY29uc3QgYmFja3VwQ291bnRkb3duID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gYmFja3VwQ291bnRkb3duLmNsYXNzTmFtZSA9ICdiYWNrdXAtY291bnRkb3duJztcbiAgICAvLyBiYWNrdXBDb3VudGRvd24udGV4dENvbnRlbnQgPSAnMyc7XG4gICAgLy8gYmFja3VwQ291bnRkb3duLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgLy8gICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgLy8gICBsZWZ0OiA1MCU7XG4gICAgLy8gICB0b3A6IDUwJTtcbiAgICAvLyAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIC8vICAgY29sb3I6IHJlZDtcbiAgICAvLyAgIGZvbnQtc2l6ZTogNzJweDtcbiAgICAvLyAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIC8vICAgdGV4dC1zaGFkb3c6IDAgMCAyMHB4IHdoaXRlLCAwIDAgMzBweCB3aGl0ZSwgMCAwIDQwcHggd2hpdGU7XG4gICAgLy8gICB6LWluZGV4OiAxMDAwMDE7XG4gICAgLy8gICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTUpO1xuICAgIC8vICAgYm9yZGVyOiA0cHggc29saWQgcmVkO1xuICAgIC8vICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIC8vICAgd2lkdGg6IDEyMHB4O1xuICAgIC8vICAgaGVpZ2h0OiAxMjBweDtcbiAgICAvLyAgIGRpc3BsYXk6IGZsZXg7XG4gICAgLy8gICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAvLyAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgLy8gICBib3gtc2hhZG93OiAwIDAgMzBweCByZ2JhKDAsIDAsIDAsIDAuNyksIDAgMCA2MHB4IHJnYmEoMjU1LCAwLCAwLCAwLjUpO1xuICAgIC8vIGA7XG4gICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiYWNrdXBDb3VudGRvd24pO1xuICAgIFxuICAgIC8vIGNvbnNvbGUubG9nKCdjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3M6IENyZWF0ZWQgYmFja3VwIGNvdW50ZG93biBpbiBjZW50ZXInKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ291bnRkb3duIGVsZW1lbnQgY3JlYXRlZCBhdDonLCB7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIGRpc3BsYXlQb3NpdGlvbixcbiAgICAgIGNhbnZhc1JlY3QsXG4gICAgICBjYW52YXNTdHlsZToge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHRcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBhIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIHRoZSBkb3QgdmlzaWJsZVxuICAgIGxldCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICB9LCAyMDApO1xuXG4gICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICBiYWNrdXBDb3VudGRvd24udGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIFJlZHJhdyBkb3QgdG8gZW5zdXJlIGl0J3MgdmlzaWJsZVxuICAgICAgZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgIH1cblxuICAgIC8vIENoYW5nZSB0byBjaGVja21hcmtcbiAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICBiYWNrdXBDb3VudGRvd24udGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyaW5nIGltYWdlcy4uLicsXG4gICAgICAgIGNvdW50ZG93blZhbHVlOiBcIkNhcHR1cmluZy4uLlwiLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50cyBhbmQgY2xlYXIgcmVkcmF3SW50ZXJ2YWxcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgaWYgKGJhY2t1cENvdW50ZG93bi5wYXJlbnROb2RlKSB7XG4gICAgICAgIGJhY2t1cENvdW50ZG93bi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJhY2t1cENvdW50ZG93bik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChyZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9LCAzMDApO1xuXG4gICAgLy8gVXNlIGNhcHR1cmVJbWFnZXNBdFBvaW50IGZyb20gc2F2ZWZpbGUuanNcbiAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgIGNhbnZhc1JlZixcbiAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICB9KTtcblxuICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlZCBkb3QgYXQgeD0ke01hdGgucm91bmQocG9zaXRpb24ueCl9LCB5PSR7TWF0aC5yb3VuZChwb3NpdGlvbi55KX1gKTtcbiAgICB9XG5cbiAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0NhcHR1cmUgY29tcGxldGUnLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIHdpdGggZGVsYXlcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgIH0sIDI1MDApO1xuXG4gICAgcmV0dXJuIGNhcHR1cmVSZXN1bHQ7XG5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiW2NhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc10gRmF0YWwgZXJyb3I6XCIsIGVycm9yKTtcbiAgICBcbiAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgRmF0YWwgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIFRvcEJhciBpcyBzaG93biBldmVuIG9uIGVycm9yXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICB9LCAxNTAwKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gYSBtaW5pbWFsIHZhbGlkIG9iamVjdCB0byBwcmV2ZW50IG51bGwgcmVmZXJlbmNlIGVycm9yc1xuICAgIHJldHVybiB7XG4gICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgfTtcbiAgfVxufTtcblxuLy8gRGVmYXVsdCBleHBvcnQgZm9yIFJlYWN0IGNvbXBhdGliaWxpdHlcbmNvbnN0IENvdW50U2F2ZSA9ICgpID0+IG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG5cbmV4cG9ydCBkZWZhdWx0IENvdW50U2F2ZTsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJnZXRDYW52YXNVdGlscyIsImNhbnZhc1V0aWxzIiwid2luZG93IiwiY2FudmFzTWFuYWdlciIsImdldENhbnZhcyIsImNyZWF0ZUNhbnZhcyIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsInRyYW5zZm9ybUNvb3JkaW5hdGVzIiwiY2FudmFzIiwicG9pbnQiLCJpc0Z1bGxzY3JlZW4iLCJzdHlsZSIsInBvc2l0aW9uIiwid2lkdGgiLCJjYW52YXNSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwiaGVpZ2h0IiwidHJhbnNmb3JtZWRQb2ludCIsIngiLCJsZWZ0IiwieSIsInRvcCIsImxhYmVsIiwiY29uc29sZSIsImxvZyIsIm9yaWdpbmFsIiwidHJhbnNmb3JtZWQiLCJzY2FsZSIsImRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlciIsInJhZGl1cyIsImRyYXdEb3QiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd1JlZERvdCIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImRpc3BsYXlQb3NpdGlvbiIsImRpc3BsYXkiLCJjYW52YXNGdWxsc2NyZWVuIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJjc3NUZXh0IiwiaWQiLCJ0ZXh0Q29udGVudCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImJvZHkiLCJvcmlnaW5hbFBvc2l0aW9uIiwiY2FudmFzSW5mbyIsInJlY3QiLCJpbmRpY2F0b3IiLCJzZXRUaW1lb3V0Iiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImV4aXN0aW5nUHJldmlld3MiLCJwcmV2aWV3IiwicHJldmlld0NvbnRhaW5lciIsInNjcmVlblByZXZpZXciLCJzY3JlZW5JbWciLCJzcmMiLCJhbHQiLCJzY3JlZW5MYWJlbCIsIndlYmNhbVByZXZpZXciLCJ3ZWJjYW1JbWciLCJ3ZWJjYW1MYWJlbCIsInBvaW50SW5mbyIsIk1hdGgiLCJyb3VuZCIsInRpbWVyRWxlbWVudCIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5IiwidHJhbnNpdGlvbiIsInRvRml4ZWQiLCJydW5Db3VudGRvd24iLCJvblN0YXR1c1VwZGF0ZSIsIm9uQ29tcGxldGUiLCJwcm9jZXNzU3RhdHVzIiwiY291bnRkb3duVmFsdWUiLCJpc0NhcHR1cmluZyIsImJhY2t1cENvdW50ZG93biIsImNvdW50IiwicmVkcmF3SW50ZXJ2YWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50ZG93bkludGVydmFsIiwiY2xlYXJDYW52YXMiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImJlZ2luUGF0aCIsImFyYyIsIlBJIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlIiwiZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cyIsImRldmljZXMiLCJuYXZpZ2F0b3IiLCJtZWRpYURldmljZXMiLCJlbnVtZXJhdGVEZXZpY2VzIiwidmlkZW9EZXZpY2VzIiwiZmlsdGVyIiwiZGV2aWNlIiwia2luZCIsImxlbmd0aCIsInZpZGVvIiwic3RyZWFtIiwiZ2V0VXNlck1lZGlhIiwidmlkZW9UcmFjayIsImdldFZpZGVvVHJhY2tzIiwiZ2V0Q2FwYWJpbGl0aWVzIiwiZ2V0VHJhY2tzIiwidHJhY2siLCJzdG9wIiwiY2FwYWJpbGl0aWVzIiwibWF4V2lkdGgiLCJtYXgiLCJ2YWx1ZXMiLCJtYXhIZWlnaHQiLCJpZGVhbCIsImZyYW1lUmF0ZSIsImVycm9yIiwiY2FwdHVyZUltYWdlcyIsIm9wdGlvbnMiLCJjYW52YXNSZWYiLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwic2V0UHJvY2Vzc1N0YXR1cyIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVGb2xkZXIiLCJjb25zdHJhaW50cyIsInNldHRpbmdzIiwiZ2V0U2V0dGluZ3MiLCJ2aWRlb0VsZW1lbnQiLCJzcmNPYmplY3QiLCJwbGF5IiwicmVzdWx0IiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50IiwiY2FwdHVyZUlkIiwic3VjY2VzcyIsInJlc29sdXRpb24iLCJlcnIiLCJtZXNzYWdlIiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxpYnJhdGlvbkNhcHR1cmUiLCJwb2ludEluZGV4IiwidG90YWxQb2ludHMiLCJjYXB0dXJlUmVzdWx0IiwiY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIiwic3RhdHVzIiwic2FmZVJlc3VsdCIsInJlbW92ZSIsImNhbnZhc1N0eWxlIiwiZWxlbWVudCIsIkNvdW50U2F2ZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx\n"));

/***/ })

});