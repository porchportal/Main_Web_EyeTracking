"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/index.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Import the action classes (optional - for future integration)\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 94,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 91,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Global canvas manager instance - initialize only once\n    const canvasManager = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[canvasManager]\": ()=>new CanvasManager()\n    }[\"ActionButtonGroupInner.useMemo[canvasManager]\"], []);\n    // Replace the complex canvas functions with simplified versions\n    const getMainCanvas = ()=>{\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    };\n    const ensureCanvasExists = ()=>{\n        return canvasManager.createCanvas();\n    };\n    const restoreCanvasToContainer = (canvas)=>{\n        canvasManager.exitFullscreen();\n    };\n    const cleanupCanvas = ()=>{\n        canvasManager.destroy();\n    };\n    const clearCanvas = ()=>{\n        canvasManager.clear();\n    };\n    // Utility function to easily manage canvas operations\n    const canvasUtils = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>({\n                // Get or create canvas\n                getCanvas: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>canvasManager.getCanvas() || canvasManager.createCanvas()\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Enter fullscreen mode\n                enterFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.enterFullscreen();\n                        return canvasManager.getCanvas();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Exit fullscreen mode\n                exitFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.exitFullscreen();\n                        return canvasManager.getCanvas();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Clear canvas\n                clear: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.clear();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Draw dot at position\n                drawDot: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": function(x, y) {\n                        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas) return false;\n                        const ctx = canvas.getContext('2d');\n                        (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, x, y, radius, false);\n                        return true;\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Get canvas dimensions\n                getDimensions: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas) return {\n                            width: 0,\n                            height: 0\n                        };\n                        return {\n                            width: canvas.width,\n                            height: canvas.height\n                        };\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Check if canvas is in fullscreen\n                isFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>canvasManager.isInFullscreen()\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Update canvas size to match container\n                resizeToContainer: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": (container)=>{\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas || !container) return false;\n                        const rect = container.getBoundingClientRect();\n                        canvas.width = rect.width || container.clientWidth || 800;\n                        canvas.height = rect.height || container.clientHeight || 600;\n                        // Clear and redraw white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        return true;\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"]\n            })\n    }[\"ActionButtonGroupInner.useMemo[canvasUtils]\"], []);\n    // Make canvas utilities globally available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (true) {\n                window.canvasUtils = canvasUtils;\n                window.canvasManager = canvasManager;\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.canvasUtils;\n                        delete window.canvasManager;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        canvasUtils,\n        canvasManager\n    ]);\n    // Optional: Initialize action classes for integration\n    const actionClasses = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[actionClasses]\": ()=>{\n            // RandomDotAction integration\n            const randomDotAction = new _components_collected_dataset_customized_Action__WEBPACK_IMPORTED_MODULE_8__.RandomDotAction({\n                canvasRef: canvasRef,\n                toggleTopBar: {\n                    \"ActionButtonGroupInner.useMemo[actionClasses]\": (show)=>{\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        }\n                    }\n                }[\"ActionButtonGroupInner.useMemo[actionClasses]\"],\n                setIsCapturing: setIsCapturing,\n                setProcessStatus: setProcessStatus,\n                setCurrentDot: setCurrentDot,\n                triggerCameraAccess: triggerCameraAccess,\n                onStatusUpdate: {\n                    \"ActionButtonGroupInner.useMemo[actionClasses]\": (status)=>{\n                        if (status.processStatus) setProcessStatus(status.processStatus);\n                        if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                    }\n                }[\"ActionButtonGroupInner.useMemo[actionClasses]\"],\n                saveImageToServer: true,\n                setCaptureCounter: setCaptureCount,\n                captureCounter: captureCount\n            });\n            // SetRandomAction integration (if needed)\n            const setRandomAction = (0,_components_collected_dataset_customized_Action__WEBPACK_IMPORTED_MODULE_8__.SetRandomAction)({\n                canvasRef: canvasRef,\n                onStatusUpdate: {\n                    \"ActionButtonGroupInner.useMemo[actionClasses].setRandomAction\": (status)=>{\n                        if (status.processStatus) setProcessStatus(status.processStatus);\n                        if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                    }\n                }[\"ActionButtonGroupInner.useMemo[actionClasses].setRandomAction\"]\n            });\n            return {\n                randomDotAction,\n                setRandomAction\n            };\n        }\n    }[\"ActionButtonGroupInner.useMemo[actionClasses]\"], [\n        captureCount,\n        setCaptureCount,\n        setIsCapturing,\n        setProcessStatus,\n        setCurrentDot,\n        triggerCameraAccess,\n        onActionClick\n    ]);\n    // Alternative handlers that use the action classes\n    const handleRandomDotWithActionClass = ()=>{\n        if (actionClasses.randomDotAction) {\n            actionClasses.randomDotAction.handleRandomDot();\n        }\n    };\n    const handleSetRandomWithActionClass = ()=>{\n        if (actionClasses.setRandomAction) {\n            actionClasses.setRandomAction.handleAction();\n        }\n    };\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Only initialize if canvas doesn't exist\n            if (!document.querySelector('#tracking-canvas')) {\n                const canvas = getMainCanvas();\n                console.log('Canvas initialized:', canvas ? 'success' : 'failed');\n            }\n            // Cleanup function\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    // Don't remove canvas on cleanup to prevent recreation issues\n                    console.log('ActionButton cleanup - canvas preserved');\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Initialize canvas on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const initializeCanvas = {\n                \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                    // Remove any existing canvas\n                    const existingCanvas = document.querySelector('.tracking-canvas');\n                    if (existingCanvas) {\n                        existingCanvas.remove();\n                    }\n                    // Create new canvas\n                    const canvas = document.createElement('canvas');\n                    canvas.className = 'tracking-canvas';\n                    canvas.id = 'tracking-canvas';\n                    canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        opacity: 0;\\n        pointer-events: none;\\n        z-index: 5;\\n      \";\n                    // Set canvas dimensions\n                    canvas.width = window.innerWidth;\n                    canvas.height = window.innerHeight;\n                    // Add canvas to body\n                    document.body.appendChild(canvas);\n                    // Store reference\n                    canvasRef.current = canvas;\n                    if (true) {\n                        window.whiteScreenCanvas = canvas;\n                    }\n                    // Initialize with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Add resize handler\n                    const handleResize = {\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\": ()=>{\n                            canvas.width = window.innerWidth;\n                            canvas.height = window.innerHeight;\n                            ctx.fillStyle = 'white';\n                            ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        }\n                    }[\"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\"];\n                    window.addEventListener('resize', handleResize);\n                    return ({\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                            window.removeEventListener('resize', handleResize);\n                            if (canvas.parentNode) {\n                                canvas.parentNode.removeChild(canvas);\n                            }\n                        }\n                    })[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n                }\n            }[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n            const cleanup = initializeCanvas();\n            return cleanup;\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Simplified Canvas Manager - More flexible and maintainable\n    class CanvasManager {\n        // Create or get canvas with automatic sizing\n        createCanvas() {\n            let container = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n            // Try to find existing canvas first\n            let canvas = document.querySelector('#tracking-canvas');\n            if (!canvas) {\n                canvas = document.createElement('canvas');\n                canvas.className = 'tracking-canvas';\n                canvas.id = 'tracking-canvas';\n            }\n            // Determine container\n            const targetContainer = container || document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            // Set initial dimensions based on container\n            this.updateCanvasSize(canvas, targetContainer);\n            // Initialize with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Add to container if not already there\n            if (!canvas.parentNode) {\n                targetContainer.appendChild(canvas);\n            }\n            // Store reference\n            this.canvas = canvas;\n            window.whiteScreenCanvas = canvas;\n            // Set up responsive behavior\n            this.setupResponsiveCanvas(canvas, targetContainer);\n            console.log(\"Canvas created/updated: \".concat(canvas.width, \"x\").concat(canvas.height));\n            return canvas;\n        }\n        // Update canvas size to match container\n        updateCanvasSize(canvas, container) {\n            if (!canvas || !container) return;\n            const rect = container.getBoundingClientRect();\n            const width = rect.width || container.clientWidth || 800;\n            const height = rect.height || container.clientHeight || 600;\n            canvas.width = width;\n            canvas.height = height;\n            // Update CSS to match\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.display = 'block';\n            canvas.style.backgroundColor = 'white';\n        }\n        // Set up responsive canvas that adapts to container size\n        setupResponsiveCanvas(canvas, container) {\n            if (!canvas || !container) return;\n            // Remove existing resize observer\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            // Create new resize observer\n            this.resizeObserver = new ResizeObserver((entries)=>{\n                for (const entry of entries){\n                    if (entry.target === container) {\n                        this.updateCanvasSize(canvas, container);\n                        // Redraw white background after resize\n                        const ctx = canvas.getContext('2d');\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    }\n                }\n            });\n            // Observe container for size changes\n            this.resizeObserver.observe(container);\n            // Also listen for window resize as fallback\n            const handleWindowResize = ()=>{\n                this.updateCanvasSize(canvas, container);\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            };\n            window.addEventListener('resize', handleWindowResize);\n            canvas._windowResizeHandler = handleWindowResize;\n        }\n        // Switch to fullscreen mode\n        enterFullscreen() {\n            if (!this.canvas) {\n                this.canvas = this.createCanvas();\n            }\n            // Save original state\n            this.originalState = {\n                parent: this.canvas.parentElement,\n                position: this.canvas.style.position,\n                top: this.canvas.style.top,\n                left: this.canvas.style.left,\n                width: this.canvas.style.width,\n                height: this.canvas.style.height,\n                zIndex: this.canvas.style.zIndex\n            };\n            // Move to body and make fullscreen\n            document.body.appendChild(this.canvas);\n            // Set fullscreen styles\n            this.canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        z-index: 99999;\\n        background-color: white;\\n        border: none;\\n        display: block;\\n        opacity: 1;\\n        pointer-events: auto;\\n        margin: 0;\\n        padding: 0;\\n        box-sizing: border-box;\\n      \";\n            // Set canvas dimensions to window size\n            this.canvas.width = window.innerWidth;\n            this.canvas.height = window.innerHeight;\n            // Clear with white background\n            const ctx = this.canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Hide UI elements\n            this.hideUIElements();\n            this.isFullscreen = true;\n            console.log('Canvas entered fullscreen mode');\n        }\n        // Exit fullscreen mode\n        exitFullscreen() {\n            if (!this.canvas || !this.originalState) return;\n            // Show UI elements\n            this.showUIElements();\n            // Find appropriate container\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            // Move canvas back to container\n            container.appendChild(this.canvas);\n            // Restore original styles\n            this.canvas.style.position = 'relative';\n            this.canvas.style.top = '';\n            this.canvas.style.left = '';\n            this.canvas.style.width = '100%';\n            this.canvas.style.height = '100%';\n            this.canvas.style.zIndex = '';\n            this.canvas.style.backgroundColor = 'white';\n            // Update size to match container\n            this.updateCanvasSize(this.canvas, container);\n            // Clear with white background\n            const ctx = this.canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Clear original state\n            this.originalState = null;\n            this.isFullscreen = false;\n            console.log('Canvas exited fullscreen mode');\n        }\n        // Hide UI elements during fullscreen\n        hideUIElements() {\n            const elementsToHide = [\n                '.topbar',\n                '.canvas-container',\n                '.main-content',\n                '.metrics-panel',\n                '.display-metrics',\n                'nav',\n                'header',\n                '.button-groups',\n                '.control-buttons'\n            ];\n            elementsToHide.forEach((selector)=>{\n                const elements = document.querySelectorAll(selector);\n                elements.forEach((el)=>{\n                    el.style.display = 'none';\n                    el.setAttribute('data-hidden-by-canvas', 'true');\n                });\n            });\n        }\n        // Show UI elements after fullscreen\n        showUIElements() {\n            const hiddenElements = document.querySelectorAll('[data-hidden-by-canvas=\"true\"]');\n            hiddenElements.forEach((el)=>{\n                el.style.display = '';\n                el.removeAttribute('data-hidden-by-canvas');\n            });\n        }\n        // Clear canvas content\n        clear() {\n            if (!this.canvas) return;\n            const ctx = this.canvas.getContext('2d');\n            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n        // Cleanup\n        destroy() {\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            if (this.canvas && this.canvas._windowResizeHandler) {\n                window.removeEventListener('resize', this.canvas._windowResizeHandler);\n            }\n            if (this.canvas && this.canvas.parentNode) {\n                this.canvas.parentNode.removeChild(this.canvas);\n            }\n            if (window.whiteScreenCanvas === this.canvas) {\n                delete window.whiteScreenCanvas;\n            }\n            this.canvas = null;\n            this.originalState = null;\n            this.isFullscreen = false;\n        }\n        // Get current canvas\n        getCanvas() {\n            return this.canvas;\n        }\n        // Check if canvas is in fullscreen mode\n        isInFullscreen() {\n            return this.isFullscreen;\n        }\n        constructor(){\n            this.canvas = null;\n            this.originalState = null;\n            this.resizeObserver = null;\n            this.isFullscreen = false;\n        }\n    }\n    // Modified handleDotProcess function with improved dot and countdown alignment\n    // Complete handleDotProcess function with proper canvas management\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        let canvas = null;\n        let keepDotVisibleInterval = null;\n        let countdownElement = null;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Use ensureCanvasExists to get or create canvas\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                throw new Error(\"Failed to create or find canvas\");\n            }\n            // Canvas is already set to fullscreen by ensureCanvasExists\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n            // Get context and clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement && countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        } finally{\n            // Clear redraw interval first\n            if (keepDotVisibleInterval) {\n                clearInterval(keepDotVisibleInterval);\n                keepDotVisibleInterval = null;\n            }\n            // Remove countdown element if it still exists\n            if (countdownElement && countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Remove any remaining countdown elements\n            const remainingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            remainingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Use restoreCanvasToContainer to properly restore canvas\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for calibration');\n                return;\n            }\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"✓\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for set random');\n                return;\n            }\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            const canvas = document.querySelector('#tracking-canvas');\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for random dot');\n                return;\n            }\n            // Use the consolidated function with random position\n            await handleDotProcess({\n                useRandomPosition: true,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                },\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                triggerCameraAccess,\n                setIsCapturing,\n                captureCount,\n                setCaptureCount: setCaptureCount,\n                postCountdownDelay: 1000\n            });\n        } catch (error) {\n            console.error('Random dot error:', error);\n        } finally{\n            // Clean up canvas after process completes\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 2000); // Wait 2 seconds before cleanup\n        }\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        if (!canvas) return null;\n        // Save original state if not already saved\n        if (!canvas._originalState) {\n            canvas._originalState = {\n                parent: canvas.parentElement,\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex,\n                canvasWidth: canvas.width,\n                canvasHeight: canvas.height\n            };\n        }\n        // Move to body and make fullscreen\n        document.body.appendChild(canvas);\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '10';\n        canvas.style.backgroundColor = 'white';\n        // Set canvas dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        return canvas;\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        // Clear canvas content\n        const canvas = document.querySelector('#tracking-canvas');\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Restore canvas to container mode\n            restoreCanvasToContainer(canvas);\n        }\n        // Reset states\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n        setCurrentDot(null);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1703,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1702,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1707,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1706,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1738,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1748,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1766,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1779,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1758,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1728,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1713,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1700,\n        columnNumber: 5\n    }, undefined);\n}, \"aF0EynSu5wnDu6GCszBSsrnwR6k=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1801,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRztBQUNsRTtBQUNpRjtBQU96QztBQUM2QjtBQUNoRTtBQUNXO0FBRW5ELGdFQUFnRTtBQUMyQztBQUUzRyw4QkFBOEI7QUFDOUIsTUFBTW1CLFVBQVUsQ0FBQ0MsTUFBTUM7SUFDckIsSUFBSUQsU0FBU0MsTUFBTSxPQUFPO0lBQzFCLElBQUksT0FBT0QsU0FBUyxZQUFZLE9BQU9DLFNBQVMsVUFBVSxPQUFPO0lBQ2pFLElBQUlELFNBQVMsUUFBUUMsU0FBUyxNQUFNLE9BQU87SUFFM0MsTUFBTUMsUUFBUUMsT0FBT0MsSUFBSSxDQUFDSjtJQUMxQixNQUFNSyxRQUFRRixPQUFPQyxJQUFJLENBQUNIO0lBRTFCLElBQUlDLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFLE9BQU87SUFFMUMsT0FBT0osTUFBTUssS0FBSyxDQUFDQyxDQUFBQSxNQUNqQkgsTUFBTUksUUFBUSxDQUFDRCxRQUFRVCxRQUFRQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO0FBRXZEO0FBRUEsMERBQTBEO0FBQzFELE1BQU1FLGVBQWU7UUFBQyxFQUFFQyxJQUFJLEVBQUVDLGVBQWUsRUFBRUMsT0FBTyxFQUFFQyxjQUFjLEVBQUUsRUFBRUMsV0FBVyxLQUFLLEVBQUVDLFNBQVMsS0FBSyxFQUFFOztJQUMxRyxNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHckMsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxFQUFFc0MsUUFBUSxFQUFFLEdBQUd2QixnRUFBZ0JBO0lBQ3JDLE1BQU0sQ0FBQ3dCLGVBQWVDLGlCQUFpQixHQUFHeEMsK0NBQVFBLENBQUM7SUFDbkQsTUFBTSxDQUFDeUMsYUFBYUMsZUFBZSxHQUFHMUMsK0NBQVFB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eVQsT0FBT3hQLG9CQUFRLDhEQUFDRDtZQUF3QixHQUFHeVAsS0FBSztZQUFFeFAsS0FBS0E7Ozs7O3lCQUNsRTtJQUFFeVAsS0FBSztBQUFNOztBQUNoQixvREFBb0Q7QUFDcEQsb0dBQW9HO0FBRXBHLCtCQUErQjtBQUNoQixTQUFTQztJQUN0QixPQUFPLE1BQU0sOERBQThEO0FBQzdFO01BRndCQTtBQUltQiIsInNvdXJjZXMiOlsiL2FwcC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FjdGlvbkJ1dHRvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBcbiAgc2hvd0NhcHR1cmVQcmV2aWV3LCBcbiAgZHJhd1JlZERvdCwgXG4gIGdldFJhbmRvbVBvc2l0aW9uLFxuICBjcmVhdGVDb3VudGRvd25FbGVtZW50LFxuICBydW5Db3VudGRvd25cbn0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCB7IHVzZUFkbWluU2V0dGluZ3MgfSBmcm9tICcuL2FkbWluU2V0dGluZ3MnO1xuXG4vLyBJbXBvcnQgdGhlIGFjdGlvbiBjbGFzc2VzIChvcHRpb25hbCAtIGZvciBmdXR1cmUgaW50ZWdyYXRpb24pXG5pbXBvcnQgeyBSYW5kb21Eb3RBY3Rpb24sIFNldFJhbmRvbUFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24nO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuLy8gQ3JlYXRlIGEgYmFzaWMgQWN0aW9uQnV0dG9uIGNvbXBvbmVudCB3aXRoIG9wdGltaXphdGlvblxuY29uc3QgQWN0aW9uQnV0dG9uID0gKHsgdGV4dCwgYWJicmV2aWF0ZWRUZXh0LCBvbkNsaWNrLCBjdXN0b21DbGFzcyA9ICcnLCBkaXNhYmxlZCA9IGZhbHNlLCBhY3RpdmUgPSBmYWxzZSB9KSA9PiB7XG4gIGNvbnN0IFtpc0FiYnJldmlhdGVkLCBzZXRJc0FiYnJldmlhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncygpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIHByb3BzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICBjb25zdCBidXR0b25Qcm9wcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjbGFzc05hbWU6IGBhY3Rpb24tYnV0dG9uICR7Y3VzdG9tQ2xhc3N9ICR7aXNBYmJyZXZpYXRlZCA/ICdhYmJyZXZpYXRlZCcgOiAnJ30gJHthY3RpdmUgPyAnYWN0aXZlJyA6ICcnfWAsXG4gICAgb25DbGljayxcbiAgICBkaXNhYmxlZCxcbiAgICB0aXRsZTogdGV4dFxuICB9KSwgW2N1c3RvbUNsYXNzLCBpc0FiYnJldmlhdGVkLCBhY3RpdmUsIG9uQ2xpY2ssIGRpc2FibGVkLCB0ZXh0XSk7XG5cbiAgLy8gQ2hlY2sgd2luZG93IHNpemUgYW5kIHNldCBhYmJyZXZpYXRlZCBtb2RlIHdpdGggZGVib3VuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHNldElzQWJicmV2aWF0ZWQod2lkdGggPCA3NjgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIGhhbmRsZVJlc2l6ZSgpOyAvLyBJbml0aWFsIGNhbGxcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQWRkIGVmZmVjdCB0byBsaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlcyB3aXRoIG9wdGltaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgaWYgKG5ld1VzZXJJZCAhPT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxidXR0b24gey4uLmJ1dHRvblByb3BzfT5cbiAgICAgIHtpc0FiYnJldmlhdGVkID8gYWJicmV2aWF0ZWRUZXh0IDogdGV4dH1cbiAgICAgIHtwcm9jZXNzU3RhdHVzICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9jZXNzLXN0YXR1c1wiPlxuICAgICAgICAgIHtwcm9jZXNzU3RhdHVzfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIEFjdGlvbkJ1dHRvbkdyb3VwIGNvbXBvbmVudCB3aXRoIGNsaWVudC1zaWRlIG9ubHkgcmVuZGVyaW5nIGFuZCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgPSBmb3J3YXJkUmVmKCh7IHRyaWdnZXJDYW1lcmFBY2Nlc3MsIGlzQ29tcGFjdE1vZGUsIG9uQWN0aW9uQ2xpY2sgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncyhyZWYpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGJ1dHRvbiBhY3Rpb25zXG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtjb3VudGRvd25WYWx1ZSwgc2V0Q291bnRkb3duVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50RG90LCBzZXRDdXJyZW50RG90XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FsaWJyYXRpb25Qb2ludHMsIHNldENhbGlicmF0aW9uUG9pbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JlbWFpbmluZ0NhcHR1cmVzLCBzZXRSZW1haW5pbmdDYXB0dXJlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Nob3dDYW52YXMsIHNldFNob3dDYW52YXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIFxuICAvLyBUcmFjayB0aGUgY2FwdHVyZSBjb3VudFxuICBjb25zdCBbY2FsaWJyYXRpb25IYW5kbGVyLCBzZXRDYWxpYnJhdGlvbkhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnQsIHNldENhcHR1cmVDb3VudF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBUb2dnbGUgc3RhdGVzXG4gIGNvbnN0IFtzaG93SGVhZFBvc2UsIHNldFNob3dIZWFkUG9zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93Qm91bmRpbmdCb3gsIHNldFNob3dCb3VuZGluZ0JveF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TWFzaywgc2V0U2hvd01hc2tdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1BhcmFtZXRlcnMsIHNldFNob3dQYXJhbWV0ZXJzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ2FtZXJhQWN0aXZlLCBzZXRJc0NhbWVyYUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGVybWlzc2lvblBvcHVwLCBzZXRTaG93UGVybWlzc2lvblBvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcblxuICAvLyBBZGQgY2FjaGUgZm9yIHNldHRpbmdzXG4gIGNvbnN0IHNldHRpbmdzQ2FjaGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgbGFzdFNldHRpbmdzVXBkYXRlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG5cbiAgLy8gR2xvYmFsIGNhbnZhcyBtYW5hZ2VyIGluc3RhbmNlIC0gaW5pdGlhbGl6ZSBvbmx5IG9uY2VcbiAgY29uc3QgY2FudmFzTWFuYWdlciA9IHVzZU1lbW8oKCkgPT4gbmV3IENhbnZhc01hbmFnZXIoKSwgW10pO1xuXG4gIC8vIFJlcGxhY2UgdGhlIGNvbXBsZXggY2FudmFzIGZ1bmN0aW9ucyB3aXRoIHNpbXBsaWZpZWQgdmVyc2lvbnNcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpO1xuICB9O1xuXG4gIGNvbnN0IGVuc3VyZUNhbnZhc0V4aXN0cyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgfTtcblxuICBjb25zdCByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgPSAoY2FudmFzKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFudXBDYW52YXMgPSAoKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5kZXN0cm95KCk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gZWFzaWx5IG1hbmFnZSBjYW52YXMgb3BlcmF0aW9uc1xuICBjb25zdCBjYW52YXNVdGlscyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGNhbnZhc1xuICAgIGdldENhbnZhczogKCkgPT4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpLFxuICAgIFxuICAgIC8vIEVudGVyIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGVudGVyRnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgIHJldHVybiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRXhpdCBmdWxsc2NyZWVuIG1vZGVcbiAgICBleGl0RnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgcmV0dXJuIGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBDbGVhciBjYW52YXNcbiAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRHJhdyBkb3QgYXQgcG9zaXRpb25cbiAgICBkcmF3RG90OiAoeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCB4LCB5LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgLy8gR2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgZ2V0RGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuXG4gICAgaXNGdWxsc2NyZWVuOiAoKSA9PiBjYW52YXNNYW5hZ2VyLmlzSW5GdWxsc2NyZWVuKCksXG4gICAgXG4gICAgLy8gVXBkYXRlIGNhbnZhcyBzaXplIHRvIG1hdGNoIGNvbnRhaW5lclxuICAgIHJlc2l6ZVRvQ29udGFpbmVyOiAoY29udGFpbmVyKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMgfHwgIWNvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCB8fCBjb250YWluZXIuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IHx8IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBhbmQgcmVkcmF3IHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSwgW10pO1xuXG4gIC8vIE1ha2UgY2FudmFzIHV0aWxpdGllcyBnbG9iYWxseSBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5jYW52YXNVdGlscyA9IGNhbnZhc1V0aWxzO1xuICAgICAgd2luZG93LmNhbnZhc01hbmFnZXIgPSBjYW52YXNNYW5hZ2VyO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzVXRpbHM7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzTWFuYWdlcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXJdKTtcblxuICAvLyBPcHRpb25hbDogSW5pdGlhbGl6ZSBhY3Rpb24gY2xhc3NlcyBmb3IgaW50ZWdyYXRpb25cbiAgY29uc3QgYWN0aW9uQ2xhc3NlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIC8vIFJhbmRvbURvdEFjdGlvbiBpbnRlZ3JhdGlvblxuICAgIGNvbnN0IHJhbmRvbURvdEFjdGlvbiA9IG5ldyBSYW5kb21Eb3RBY3Rpb24oe1xuICAgICAgY2FudmFzUmVmOiBjYW52YXNSZWYsXG4gICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0SXNDYXB0dXJpbmc6IHNldElzQ2FwdHVyaW5nLFxuICAgICAgc2V0UHJvY2Vzc1N0YXR1czogc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgIHNldEN1cnJlbnREb3Q6IHNldEN1cnJlbnREb3QsXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzOiB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgaWYgKHN0YXR1cy5pc0NhcHR1cmluZyAhPT0gdW5kZWZpbmVkKSBzZXRJc0NhcHR1cmluZyhzdGF0dXMuaXNDYXB0dXJpbmcpO1xuICAgICAgfSxcbiAgICAgIHNhdmVJbWFnZVRvU2VydmVyOiB0cnVlLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IHNldENhcHR1cmVDb3VudCxcbiAgICAgIGNhcHR1cmVDb3VudGVyOiBjYXB0dXJlQ291bnRcbiAgICB9KTtcblxuICAgIC8vIFNldFJhbmRvbUFjdGlvbiBpbnRlZ3JhdGlvbiAoaWYgbmVlZGVkKVxuICAgIGNvbnN0IHNldFJhbmRvbUFjdGlvbiA9IFNldFJhbmRvbUFjdGlvbih7XG4gICAgICBjYW52YXNSZWY6IGNhbnZhc1JlZixcbiAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXMucHJvY2Vzc1N0YXR1cyk7XG4gICAgICAgIGlmIChzdGF0dXMuaXNDYXB0dXJpbmcgIT09IHVuZGVmaW5lZCkgc2V0SXNDYXB0dXJpbmcoc3RhdHVzLmlzQ2FwdHVyaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICByYW5kb21Eb3RBY3Rpb24sXG4gICAgICBzZXRSYW5kb21BY3Rpb25cbiAgICB9O1xuICB9LCBbY2FwdHVyZUNvdW50LCBzZXRDYXB0dXJlQ291bnQsIHNldElzQ2FwdHVyaW5nLCBzZXRQcm9jZXNzU3RhdHVzLCBzZXRDdXJyZW50RG90LCB0cmlnZ2VyQ2FtZXJhQWNjZXNzLCBvbkFjdGlvbkNsaWNrXSk7XG5cbiAgLy8gQWx0ZXJuYXRpdmUgaGFuZGxlcnMgdGhhdCB1c2UgdGhlIGFjdGlvbiBjbGFzc2VzXG4gIGNvbnN0IGhhbmRsZVJhbmRvbURvdFdpdGhBY3Rpb25DbGFzcyA9ICgpID0+IHtcbiAgICBpZiAoYWN0aW9uQ2xhc3Nlcy5yYW5kb21Eb3RBY3Rpb24pIHtcbiAgICAgIGFjdGlvbkNsYXNzZXMucmFuZG9tRG90QWN0aW9uLmhhbmRsZVJhbmRvbURvdCgpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTZXRSYW5kb21XaXRoQWN0aW9uQ2xhc3MgPSAoKSA9PiB7XG4gICAgaWYgKGFjdGlvbkNsYXNzZXMuc2V0UmFuZG9tQWN0aW9uKSB7XG4gICAgICBhY3Rpb25DbGFzc2VzLnNldFJhbmRvbUFjdGlvbi5oYW5kbGVBY3Rpb24oKTtcbiAgICB9XG4gIH07XG5cbiAgXG4gIC8vIE9wdGltaXplIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2V0dGluZ3MgJiYgY3VycmVudFVzZXJJZCAmJiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSkge1xuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbY3VycmVudFVzZXJJZF07XG4gICAgICBjb25zdCBjYWNoZWRTZXR0aW5ncyA9IHNldHRpbmdzQ2FjaGUuY3VycmVudC5nZXQoY3VycmVudFVzZXJJZCk7XG4gICAgICBcbiAgICAgIGlmICghaXNFcXVhbChjYWNoZWRTZXR0aW5ncywgdXNlclNldHRpbmdzKSkge1xuICAgICAgICBzZXRSYW5kb21UaW1lcyhOdW1iZXIodXNlclNldHRpbmdzLnRpbWVzX3NldF9yYW5kb20pIHx8IDEpO1xuICAgICAgICBzZXREZWxheVNlY29uZHMoTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheV9zZXRfcmFuZG9tKSB8fCAzKTtcbiAgICAgICAgc2V0dGluZ3NDYWNoZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCB1c2VyU2V0dGluZ3MpO1xuICAgICAgICBsYXN0U2V0dGluZ3NVcGRhdGUuY3VycmVudC5zZXQoY3VycmVudFVzZXJJZCwgRGF0ZS5ub3coKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc2V0dGluZ3MsIGN1cnJlbnRVc2VySWRdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgc2V0Q3VycmVudFVzZXJJZChuZXdVc2VySWQpO1xuICAgICAgICAvLyBVcGRhdGUgc2V0dGluZ3MgZm9yIG5ldyB1c2VyXG4gICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5nc1tuZXdVc2VySWRdKSB7XG4gICAgICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbbmV3VXNlcklkXTtcbiAgICAgICAgICBzZXRSYW5kb21UaW1lcyhOdW1iZXIodXNlclNldHRpbmdzLnRpbWVzX3NldF9yYW5kb20pIHx8IDEpO1xuICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCB0aW1lc19zZXRfcmFuZG9tLCBkZWxheV9zZXRfcmFuZG9tIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGlmICh1c2VySWQgPT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBpZiAodGltZXNfc2V0X3JhbmRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUaW1lcyA9IE51bWJlcih0aW1lc19zZXRfcmFuZG9tKSB8fCAxO1xuICAgICAgICAgICAgc2V0UmFuZG9tVGltZXMobmV3VGltZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVsYXlfc2V0X3JhbmRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZWxheSA9IE51bWJlcihkZWxheV9zZXRfcmFuZG9tKSB8fCAzO1xuICAgICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKG5ld0RlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE1ha2UgZnVuY3Rpb25zIGdsb2JhbGx5IGFjY2Vzc2libGUgYXMgYSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyA9IHtcbiAgICAgICAgaGFuZGxlUmFuZG9tRG90LFxuICAgICAgICBoYW5kbGVTZXRSYW5kb20sXG4gICAgICAgIGhhbmRsZVNldENhbGlicmF0ZSxcbiAgICAgICAgaGFuZGxlQ2xlYXJBbGxcbiAgICAgIH07XG4gICAgICAvLyBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbiBmdW5jdGlvbnMgZXhwb3NlZCB0byB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnM7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE9ubHkgaW5pdGlhbGl6ZSBpZiBjYW52YXMgZG9lc24ndCBleGlzdFxuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBjb25zb2xlLmxvZygnQ2FudmFzIGluaXRpYWxpemVkOicsIGNhbnZhcyA/ICdzdWNjZXNzJyA6ICdmYWlsZWQnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW51cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBEb24ndCByZW1vdmUgY2FudmFzIG9uIGNsZWFudXAgdG8gcHJldmVudCByZWNyZWF0aW9uIGlzc3Vlc1xuICAgICAgY29uc29sZS5sb2coJ0FjdGlvbkJ1dHRvbiBjbGVhbnVwIC0gY2FudmFzIHByZXNlcnZlZCcpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gZ2V0IGNvbnRyb2wgdmFsdWVzIGZyb20gVG9wQmFyXG4gICAgY29uc3QgdXBkYXRlQ29udHJvbFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIC8vIEdldCB0aGUgdGltZSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IHBhcnNlSW50KHRpbWVJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHRpbWVWYWx1ZSkgJiYgdGltZVZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyByYW5kb21UaW1lcyB0bzonLCB0aW1lVmFsdWUpO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKHRpbWVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBkZWxheSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRlbGF5VmFsdWUgPSBwYXJzZUludChkZWxheUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4oZGVsYXlWYWx1ZSkgJiYgZGVsYXlWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgZGVsYXlTZWNvbmRzIHRvOicsIGRlbGF5VmFsdWUpO1xuICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhkZWxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgY29udHJvbCBpbnB1dHNcbiAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgXG4gICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgdGltZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgdGltZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7IC8vIEFsc28gbGlzdGVuIGZvciBpbnB1dCBldmVudHNcbiAgICB9XG4gICAgXG4gICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgIGRlbGF5SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7IC8vIEFsc28gbGlzdGVuIGZvciBpbnB1dCBldmVudHNcbiAgICB9XG4gICAgXG4gICAgLy8gSW5pdGlhbCB1cGRhdGVcbiAgICB1cGRhdGVDb250cm9sVmFsdWVzKCk7XG4gICAgXG4gICAgLy8gQ2xlYW51cCBldmVudCBsaXN0ZW5lcnNcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICAgIHRpbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBkZWxheUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICBkZWxheUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEluaXRpYWxpemUgY2FudmFzIG9uIGNvbXBvbmVudCBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxpemVDYW52YXMgPSAoKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNhbnZhc1xuICAgICAgY29uc3QgZXhpc3RpbmdDYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBpZiAoZXhpc3RpbmdDYW52YXMpIHtcbiAgICAgICAgZXhpc3RpbmdDYW52YXMucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgY2FudmFzXG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICAgIGNhbnZhcy5pZCA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwdnc7XG4gICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB6LWluZGV4OiA1O1xuICAgICAgYDtcblxuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIC8vIEFkZCBjYW52YXMgdG8gYm9keVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuXG4gICAgICAvLyBTdG9yZSByZWZlcmVuY2VcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gQWRkIHJlc2l6ZSBoYW5kbGVyXG4gICAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGNsZWFudXAgPSBpbml0aWFsaXplQ2FudmFzKCk7XG4gICAgcmV0dXJuIGNsZWFudXA7XG4gIH0sIFtdKTtcblxuICAvLyBTaW1wbGlmaWVkIENhbnZhcyBNYW5hZ2VyIC0gTW9yZSBmbGV4aWJsZSBhbmQgbWFpbnRhaW5hYmxlXG4gIGNsYXNzIENhbnZhc01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgdGhpcy5pc0Z1bGxzY3JlZW4gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgb3IgZ2V0IGNhbnZhcyB3aXRoIGF1dG9tYXRpYyBzaXppbmdcbiAgICBjcmVhdGVDYW52YXMoY29udGFpbmVyID0gbnVsbCkge1xuICAgICAgLy8gVHJ5IHRvIGZpbmQgZXhpc3RpbmcgY2FudmFzIGZpcnN0XG4gICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICAgICAgXG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmNsYXNzTmFtZSA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgICBjYW52YXMuaWQgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIGNvbnRhaW5lclxuICAgICAgY29uc3QgdGFyZ2V0Q29udGFpbmVyID0gY29udGFpbmVyIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keTtcblxuICAgICAgLy8gU2V0IGluaXRpYWwgZGltZW5zaW9ucyBiYXNlZCBvbiBjb250YWluZXJcbiAgICAgIHRoaXMudXBkYXRlQ2FudmFzU2l6ZShjYW52YXMsIHRhcmdldENvbnRhaW5lcik7XG4gICAgICBcbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIC8vIEFkZCB0byBjb250YWluZXIgaWYgbm90IGFscmVhZHkgdGhlcmVcbiAgICAgIGlmICghY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3JlIHJlZmVyZW5jZVxuICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPSBjYW52YXM7XG5cbiAgICAgIC8vIFNldCB1cCByZXNwb25zaXZlIGJlaGF2aW9yXG4gICAgICB0aGlzLnNldHVwUmVzcG9uc2l2ZUNhbnZhcyhjYW52YXMsIHRhcmdldENvbnRhaW5lcik7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgY3JlYXRlZC91cGRhdGVkOiAke2NhbnZhcy53aWR0aH14JHtjYW52YXMuaGVpZ2h0fWApO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgY2FudmFzIHNpemUgdG8gbWF0Y2ggY29udGFpbmVyXG4gICAgdXBkYXRlQ2FudmFzU2l6ZShjYW52YXMsIGNvbnRhaW5lcikge1xuICAgICAgaWYgKCFjYW52YXMgfHwgIWNvbnRhaW5lcikgcmV0dXJuO1xuXG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3Qgd2lkdGggPSByZWN0LndpZHRoIHx8IGNvbnRhaW5lci5jbGllbnRXaWR0aCB8fCA4MDA7XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0LmhlaWdodCB8fCBjb250YWluZXIuY2xpZW50SGVpZ2h0IHx8IDYwMDtcblxuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAvLyBVcGRhdGUgQ1NTIHRvIG1hdGNoXG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG4gICAgfVxuXG4gICAgLy8gU2V0IHVwIHJlc3BvbnNpdmUgY2FudmFzIHRoYXQgYWRhcHRzIHRvIGNvbnRhaW5lciBzaXplXG4gICAgc2V0dXBSZXNwb25zaXZlQ2FudmFzKGNhbnZhcywgY29udGFpbmVyKSB7XG4gICAgICBpZiAoIWNhbnZhcyB8fCAhY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIC8vIFJlbW92ZSBleGlzdGluZyByZXNpemUgb2JzZXJ2ZXJcbiAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgbmV3IHJlc2l6ZSBvYnNlcnZlclxuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBpZiAoZW50cnkudGFyZ2V0ID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ2FudmFzU2l6ZShjYW52YXMsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyBSZWRyYXcgd2hpdGUgYmFja2dyb3VuZCBhZnRlciByZXNpemVcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBPYnNlcnZlIGNvbnRhaW5lciBmb3Igc2l6ZSBjaGFuZ2VzXG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcblxuICAgICAgLy8gQWxzbyBsaXN0ZW4gZm9yIHdpbmRvdyByZXNpemUgYXMgZmFsbGJhY2tcbiAgICAgIGNvbnN0IGhhbmRsZVdpbmRvd1Jlc2l6ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKGNhbnZhcywgY29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIH07XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgY2FudmFzLl93aW5kb3dSZXNpemVIYW5kbGVyID0gaGFuZGxlV2luZG93UmVzaXplO1xuICAgIH1cblxuICAgIC8vIFN3aXRjaCB0byBmdWxsc2NyZWVuIG1vZGVcbiAgICBlbnRlckZ1bGxzY3JlZW4oKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMuY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZVxuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0ge1xuICAgICAgICBwYXJlbnQ6IHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQsXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgdG9wOiB0aGlzLmNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IHRoaXMuY2FudmFzLnN0eWxlLmxlZnQsXG4gICAgICAgIHdpZHRoOiB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogdGhpcy5jYW52YXMuc3R5bGUuekluZGV4XG4gICAgICB9O1xuXG4gICAgICAvLyBNb3ZlIHRvIGJvZHkgYW5kIG1ha2UgZnVsbHNjcmVlblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICBcbiAgICAgIC8vIFNldCBmdWxsc2NyZWVuIHN0eWxlc1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgICAgei1pbmRleDogOTk5OTk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgYDtcblxuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIHdpbmRvdyBzaXplXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAvLyBDbGVhciB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gSGlkZSBVSSBlbGVtZW50c1xuICAgICAgdGhpcy5oaWRlVUlFbGVtZW50cygpO1xuXG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IHRydWU7XG4gICAgICBjb25zb2xlLmxvZygnQ2FudmFzIGVudGVyZWQgZnVsbHNjcmVlbiBtb2RlJyk7XG4gICAgfVxuXG4gICAgLy8gRXhpdCBmdWxsc2NyZWVuIG1vZGVcbiAgICBleGl0RnVsbHNjcmVlbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMgfHwgIXRoaXMub3JpZ2luYWxTdGF0ZSkgcmV0dXJuO1xuXG4gICAgICAvLyBTaG93IFVJIGVsZW1lbnRzXG4gICAgICB0aGlzLnNob3dVSUVsZW1lbnRzKCk7XG5cbiAgICAgIC8vIEZpbmQgYXBwcm9wcmlhdGUgY29udGFpbmVyXG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4tY29udGVudCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAvLyBNb3ZlIGNhbnZhcyBiYWNrIHRvIGNvbnRhaW5lclxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcblxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBzdHlsZXNcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXggPSAnJztcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG5cbiAgICAgIC8vIFVwZGF0ZSBzaXplIHRvIG1hdGNoIGNvbnRhaW5lclxuICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKHRoaXMuY2FudmFzLCBjb250YWluZXIpO1xuXG4gICAgICAvLyBDbGVhciB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gQ2xlYXIgb3JpZ2luYWwgc3RhdGVcbiAgICAgIHRoaXMub3JpZ2luYWxTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuXG4gICAgICBjb25zb2xlLmxvZygnQ2FudmFzIGV4aXRlZCBmdWxsc2NyZWVuIG1vZGUnKTtcbiAgICB9XG5cbiAgICAvLyBIaWRlIFVJIGVsZW1lbnRzIGR1cmluZyBmdWxsc2NyZWVuXG4gICAgaGlkZVVJRWxlbWVudHMoKSB7XG4gICAgICBjb25zdCBlbGVtZW50c1RvSGlkZSA9IFtcbiAgICAgICAgJy50b3BiYXInLFxuICAgICAgICAnLmNhbnZhcy1jb250YWluZXInLCBcbiAgICAgICAgJy5tYWluLWNvbnRlbnQnLFxuICAgICAgICAnLm1ldHJpY3MtcGFuZWwnLFxuICAgICAgICAnLmRpc3BsYXktbWV0cmljcycsXG4gICAgICAgICduYXYnLFxuICAgICAgICAnaGVhZGVyJyxcbiAgICAgICAgJy5idXR0b24tZ3JvdXBzJyxcbiAgICAgICAgJy5jb250cm9sLWJ1dHRvbnMnXG4gICAgICBdO1xuICAgICAgXG4gICAgICBlbGVtZW50c1RvSGlkZS5mb3JFYWNoKHNlbGVjdG9yID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaGlkZGVuLWJ5LWNhbnZhcycsICd0cnVlJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdyBVSSBlbGVtZW50cyBhZnRlciBmdWxsc2NyZWVuXG4gICAgc2hvd1VJRWxlbWVudHMoKSB7XG4gICAgICBjb25zdCBoaWRkZW5FbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWhpZGRlbi1ieS1jYW52YXM9XCJ0cnVlXCJdJyk7XG4gICAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlkZGVuLWJ5LWNhbnZhcycpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXIgY2FudmFzIGNvbnRlbnRcbiAgICBjbGVhcigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwXG4gICAgZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuY2FudmFzLl93aW5kb3dSZXNpemVIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMuY2FudmFzLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5jYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3aW5kb3cud2hpdGVTY3JlZW5DYW52YXMgPT09IHRoaXMuY2FudmFzKSB7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cud2hpdGVTY3JlZW5DYW52YXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMub3JpZ2luYWxTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IGNhbnZhc1xuICAgIGdldENhbnZhcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBjYW52YXMgaXMgaW4gZnVsbHNjcmVlbiBtb2RlXG4gICAgaXNJbkZ1bGxzY3JlZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Z1bGxzY3JlZW47XG4gICAgfVxuICB9XG5cblxuICBcbiAgLy8gTW9kaWZpZWQgaGFuZGxlRG90UHJvY2VzcyBmdW5jdGlvbiB3aXRoIGltcHJvdmVkIGRvdCBhbmQgY291bnRkb3duIGFsaWdubWVudFxuICAvLyBDb21wbGV0ZSBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggcHJvcGVyIGNhbnZhcyBtYW5hZ2VtZW50XG4gIGNvbnN0IGhhbmRsZURvdFByb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgb25TdGF0dXNVcGRhdGUsXG4gICAgICB0b2dnbGVUb3BCYXIsXG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICBjYXB0dXJlQ291bnQsXG4gICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICB1c2VSYW5kb21Qb3NpdGlvbiA9IGZhbHNlLFxuICAgICAgcG9zdENvdW50ZG93bkRlbGF5ID0gNTAwIFxuICAgIH0gPSBvcHRpb25zO1xuICAgIFxuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGxldCBrZWVwRG90VmlzaWJsZUludGVydmFsID0gbnVsbDtcbiAgICBsZXQgY291bnRkb3duRWxlbWVudCA9IG51bGw7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyB0aGUgZG90XG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTZXQgY2FwdHVyaW5nIHN0YXRlXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6IHVzZVJhbmRvbVBvc2l0aW9uID8gJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicgOiAnU3RhcnRpbmcgZG90IHByb2Nlc3MuLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIFVJIHVwZGF0ZXMgdG8gdGFrZSBlZmZlY3RcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyMDApKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIGVuc3VyZUNhbnZhc0V4aXN0cyB0byBnZXQgb3IgY3JlYXRlIGNhbnZhc1xuICAgICAgY2FudmFzID0gZW5zdXJlQ2FudmFzRXhpc3RzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIG9yIGZpbmQgY2FudmFzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYW52YXMgaXMgYWxyZWFkeSBzZXQgdG8gZnVsbHNjcmVlbiBieSBlbnN1cmVDYW52YXNFeGlzdHNcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNvbnRleHQgYW5kIGNsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBHZXQgcG9zaXRpb24gZm9yIHRoZSBkb3QgLSBlaXRoZXIgdXNlIHByb3ZpZGVkIHBvc2l0aW9uIG9yIGdlbmVyYXRlIHJhbmRvbSBvbmVcbiAgICAgIGNvbnN0IGRvdFBvc2l0aW9uID0gdXNlUmFuZG9tUG9zaXRpb24gXG4gICAgICAgID8gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCkgXG4gICAgICAgIDogcG9zaXRpb247XG4gICAgICBcbiAgICAgIGlmICghZG90UG9zaXRpb24gfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBkb3RQb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRvdCBwb3NpdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRHJhdyB0aGUgZG90XG4gICAgICBjb25zdCBkb3RSYWRpdXMgPSAxMjtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgfSwgNTApOyAgLy8gTW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJpbGl0eVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBjb3VudGRvd24gZWxlbWVudCBkaXJlY3RseSBvbiB0b3Agb2YgdGhlIGRvdFxuICAgICAgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgbGVmdDogJHtkb3RQb3NpdGlvbi54fXB4O1xuICAgICAgICB0b3A6ICR7ZG90UG9zaXRpb24ueX1weDtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICBcbiAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRyYXcgdGhlIGRvdCBmb3IgcmVsaWFiaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkaXRpb25hbCByZWRyYXcgZHVyaW5nIGNvdW50ZG93biB0byBlbnN1cmUgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudCAmJiBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCk7XG4gICAgICBcbiAgICAgIC8vIFdhaXQgYWZ0ZXIgY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHBvc3RDb3VudGRvd25EZWxheSkpO1xuICAgICAgXG4gICAgICAvLyBFbnN1cmUgdGhlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgIHBvaW50OiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyZSBjb21wbGV0ZWQnLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogZG90UG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVSZXN1bHRcbiAgICAgIH07XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGhhbmRsZURvdFByb2Nlc3M6XCIsIGVycm9yKTtcbiAgICAgIFxuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6IGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWwgZmlyc3RcbiAgICAgIGlmIChrZWVwRG90VmlzaWJsZUludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoa2VlcERvdFZpc2libGVJbnRlcnZhbCk7XG4gICAgICAgIGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICBpZiAoY291bnRkb3duRWxlbWVudCAmJiBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgIGNvbnN0IHJlbWFpbmluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgIHJlbWFpbmluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBVc2UgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyIHRvIHByb3Blcmx5IHJlc3RvcmUgY2FudmFzXG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lcihjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICAvLyBEZWNsYXJlIHRoZXNlIHZhcmlhYmxlcyBPVVRTSURFIHRoZSB0cnkgYmxvY2tcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBsZXQgb3JpZ2luYWxDYW52YXNQYXJlbnQgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1N0eWxlID0ge307XG4gICAgbGV0IHN0YXR1c0luZGljYXRvciA9IG51bGw7XG4gICAgbGV0IGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgY2FudmFzID0gZW5zdXJlQ2FudmFzRXhpc3RzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyBmb3IgY2FsaWJyYXRpb24nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0U2hvd0NhbnZhcyh0cnVlKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoXCJTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLlwiKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgVUkgdXBkYXRlcyB0byB0YWtlIGVmZmVjdFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDMwMCkpO1xuICAgICAgXG4gICAgICAvLyBHZXQgY2FudmFzIHJlZmVyZW5jZVxuICAgICAgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIkVycm9yOiBDYW52YXMgbm90IGZvdW5kXCIpO1xuICAgICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBwYXJlbnQgYW5kIHN0eWxlXG4gICAgICBvcmlnaW5hbENhbnZhc1BhcmVudCA9IGNhbnZhcy5wYXJlbnRFbGVtZW50O1xuICAgICAgb3JpZ2luYWxDYW52YXNTdHlsZSA9IHtcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgdG9wOiBjYW52YXMuc3R5bGUudG9wLFxuICAgICAgICBsZWZ0OiBjYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICB6SW5kZXg6IGNhbnZhcy5zdHlsZS56SW5kZXhcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIE1vdmUgY2FudmFzIHRvIGJvZHkgZm9yIG1heGltdW0gcmVsaWFiaWxpdHlcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBjYW52YXMgZnVsbHNjcmVlbiB3aXRoIGZpeGVkIHBvc2l0aW9uaW5nXG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgICBcbiAgICAgIC8vIFNldCBkaW1lbnNpb25zIHRvIG1hdGNoIHdpbmRvdyBleGFjdGx5XG4gICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHNldCB0byBmdWxsc2NyZWVuOiAke2NhbnZhc1dpZHRofXgke2NhbnZhc0hlaWdodH1gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNvbnRleHRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG5cbiAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cyBiYXNlZCBvbiB0aGUgY2FudmFzIHNpemVcbiAgICAgIGNvbnN0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cycpO1xuICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgIFxuICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHN0YXR1c0luZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgYDtcbiAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbjogSW5pdGlhbGl6aW5nLi4uJztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgYW55IGV4aXN0aW5nIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgIGN1cnJlbnRSZWRyYXdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGlzcGxheXNcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXNldCBjYW52YXMgaWYgZGltZW5zaW9ucyBjaGFuZ2VkXG4gICAgICAgIGlmIChjYW52YXMud2lkdGggIT09IGNhbnZhc1dpZHRoIHx8IGNhbnZhcy5oZWlnaHQgIT09IGNhbnZhc0hlaWdodCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FudmFzIGRpbWVuc2lvbnMgY2hhbmdlZC4gUmVzZXR0aW5nIHRvICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBjYW52YXMgaXMgc3RpbGwgYXR0YWNoZWQgdG8gYm9keSBhbmQgaW4gZnVsbHNjcmVlbiBtb2RlXG4gICAgICAgIGlmIChjYW52YXMucGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgICAgY29uc3QgcmFkaXVzID0gMTQ7IC8vIFNsaWdodGx5IGxhcmdlciBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBmdW5jdGlvbiBmb3IgdGhpcyBwb2ludFxuICAgICAgICBjb25zdCByZWRyYXdDdXJyZW50RG90ID0gKCkgPT4ge1xuICAgICAgICAgIC8vIFZlcmlmeSBjYW52YXMgZGltZW5zaW9ucyBhbmQgcGFyZW50XG4gICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5XG4gICAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlZHJhdyBkb3Qgd2l0aG91dCBjbGVhcmluZ1xuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0YXJ0IHJlZHJhdyBpbnRlcnZhbCAtIG1vcmUgZnJlcXVlbnQgdXBkYXRlcyBmb3IgcmVsaWFibGUgZG90IHZpc2liaWxpdHlcbiAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwocmVkcmF3Q3VycmVudERvdCwgNTApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nOyAvLyBDb25zaXN0ZW50IGNsYXNzIG5hbWVcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICBsZWZ0OiAke3BvaW50Lnh9cHg7XG4gICAgICAgICAgdG9wOiAke3BvaW50LnkgLSA2MH1weDtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofTogQ291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVkcmF3IGFnYWluIGhhbGZ3YXkgdGhyb3VnaCB0aGUgd2FpdCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgICAgICByZWRyYXdDdXJyZW50RG90KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGFmdGVyIGRlbGF5XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcblxuICAgICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FwdHVyaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9IGF0ICgke3BvaW50Lnh9LCAke3BvaW50Lnl9KWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1hbnVhbCBmb3JjZSByZWRyYXcgb25lIG1vcmUgdGltZSBqdXN0IGJlZm9yZSBjYXB0dXJlXG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgIFxuICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50LFxuICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNhcHR1cmVSZXN1bHQgJiYgKGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgY2FwdHVyZVJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEyMDApKTtcbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gQ2xlYW4gdXAgY291bnRkb3duIGlmIGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgcmVkcmF3IGludGVydmFsXG4gICAgICAgICAgaWYgKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgfVxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FsaWJyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFuIHVwIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgaWYgKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGlmIGl0IGV4aXN0c1xuICAgICAgaWYgKHN0YXR1c0luZGljYXRvciAmJiBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFudXBDYW52YXMoKTtcbiAgICAgIH0sIDMwMDApO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICByZXN0b3JlQ2FudmFzVG9Db250YWluZXIoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNldFJhbmRvbSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FudmFzID0gZW5zdXJlQ2FudmFzRXhpc3RzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGNhbnZhcyBmb3Igc2V0IHJhbmRvbScpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBBbHdheXMgZ2V0IHRoZSBsYXRlc3Qgc2V0dGluZ3MgZnJvbSBjb250ZXh0IGZvciB0aGUgY3VycmVudCB1c2VyXG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5ncyAmJiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSA/IHNldHRpbmdzW2N1cnJlbnRVc2VySWRdIDoge307XG4gICAgICBjb25zdCB0aW1lcyA9IE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgTnVtYmVyKHJhbmRvbVRpbWVzKSB8fCAxO1xuICAgICAgY29uc3QgZGVsYXkgPSBOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IE51bWJlcihkZWxheVNlY29uZHMpIHx8IDM7XG5cbiAgICAgIC8vIExvZyBjdXJyZW50IHNldHRpbmdzIGJlZm9yZSBzdGFydGluZ1xuICAgICAgY29uc29sZS5sb2coJ1N0YXJ0aW5nIFNldCBSYW5kb20gd2l0aCBzZXR0aW5nczonLCB7XG4gICAgICAgIHJhbmRvbVRpbWVzLFxuICAgICAgICBkZWxheVNlY29uZHMsXG4gICAgICAgIGN1cnJlbnRVc2VySWQsXG4gICAgICAgIHNldHRpbmdzLFxuICAgICAgICB1c2VyU2V0dGluZ3MsXG4gICAgICAgIHRpbWVzLFxuICAgICAgICBkZWxheVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEhpZGUgVG9wQmFyXG4gICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFN0YXJ0aW5nICR7dGltZXN9IHJhbmRvbSBjYXB0dXJlcyB3aXRoICR7ZGVsYXl9cyBkZWxheS4uLmApO1xuXG4gICAgICAvLyBQcm9jZXNzIGFsbCBjYXB0dXJlcyBpbiBzZXF1ZW5jZVxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBcbiAgICAgIGZvciAobGV0IGN1cnJlbnRJbmRleCA9IDE7IGN1cnJlbnRJbmRleCA8PSB0aW1lczsgY3VycmVudEluZGV4KyspIHtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgY3VycmVudCBjYXB0dXJlXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG9mICR7dGltZXN9YCk7XG4gICAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKHRpbWVzIC0gY3VycmVudEluZGV4ICsgMSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFVzZSBoYW5kbGVEb3RQcm9jZXNzIGZvciBlYWNoIGNhcHR1cmVcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlRG90UHJvY2Vzcyh7XG4gICAgICAgICAgdXNlUmFuZG9tUG9zaXRpb246IHRydWUsXG4gICAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fS8ke3RpbWVzfTogJHtzdGF0dXMucHJvY2Vzc1N0YXR1c31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgc2hvdyBUb3BCYXIgYWZ0ZXIgdGhlIGxhc3QgY2FwdHVyZVxuICAgICAgICAgICAgaWYgKHNob3cgJiYgY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBEb24ndCBzaG93IHlldCBmb3IgaW50ZXJtZWRpYXRlIGNhcHR1cmVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHNob3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgICAgICBzZXRJc0NhcHR1cmluZzogKGNhcHR1cmluZykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzZXQgY2FwdHVyaW5nIHRvIGZhbHNlIGFmdGVyIGFsbCBjYXB0dXJlc1xuICAgICAgICAgICAgaWYgKCFjYXB0dXJpbmcgJiYgY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvLyBTdGF5IGluIGNhcHR1cmluZyBzdGF0ZSBiZXR3ZWVuIGRvdHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGNhcHR1cmluZyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHBvc3RDb3VudGRvd25EZWxheTogODAwXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgY29tcGxldGVkIGNhcHR1cmUgJHtjdXJyZW50SW5kZXh9YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYXB0dXJlICR7Y3VycmVudEluZGV4fSBtYXkgaGF2ZSBmYWlsZWQ6YCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIGNhcHR1cmVzIC0gYnV0IG9ubHkgaWYgdGhlcmUgYXJlIG1vcmUgY2FwdHVyZXMgdG8gZ29cbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IHRpbWVzKSB7XG4gICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgV2FpdGluZyAke2RlbGF5fXMgYmVmb3JlIG5leHQgY2FwdHVyZS4uLmApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5ICogMTAwMCkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvbXBsZXRpb24gbm90aWZpY2F0aW9uXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBjYXB0dXJlcyBzdWNjZXNzZnVsYCk7XG4gICAgICBzZXRSZW1haW5pbmdDYXB0dXJlcygwKTtcbiAgICAgIGNvbnNvbGUubG9nKGBDb21wbGV0ZWQgYWxsIGNhcHR1cmVzOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gc3VjY2Vzc2Z1bGApO1xuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYW5kb20gc2VxdWVuY2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBzZXF1ZW5jZSBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFudXBDYW52YXMoKTtcbiAgICAgIH0sIDMwMDApO1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICByZXN0b3JlQ2FudmFzVG9Db250YWluZXIoY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVJhbmRvbURvdCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBlbnN1cmVDYW52YXNFeGlzdHMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY2FudmFzIGZvciByYW5kb20gZG90Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVXNlIHRoZSBjb25zb2xpZGF0ZWQgZnVuY3Rpb24gd2l0aCByYW5kb20gcG9zaXRpb25cbiAgICAgIGF3YWl0IGhhbmRsZURvdFByb2Nlc3Moe1xuICAgICAgICB1c2VSYW5kb21Qb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICAgIGlmIChzdGF0dXMuaXNDYXB0dXJpbmcgIT09IHVuZGVmaW5lZCkgc2V0SXNDYXB0dXJpbmcoc3RhdHVzLmlzQ2FwdHVyaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgc2hvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgICAgY2FwdHVyZUNvdW50LFxuICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiAxMDAwXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1JhbmRvbSBkb3QgZXJyb3I6JywgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBDbGVhbiB1cCBjYW52YXMgYWZ0ZXIgcHJvY2VzcyBjb21wbGV0ZXNcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhbnVwQ2FudmFzKCk7XG4gICAgICB9LCAyMDAwKTsgLy8gV2FpdCAyIHNlY29uZHMgYmVmb3JlIGNsZWFudXBcbiAgICB9XG4gICAgXG4gIH07XG4gIGNvbnN0IG1ha2VDYW52YXNGdWxsc2NyZWVuID0gKGNhbnZhcykgPT4ge1xuICAgIGlmICghY2FudmFzKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICAvLyBTYXZlIG9yaWdpbmFsIHN0YXRlIGlmIG5vdCBhbHJlYWR5IHNhdmVkXG4gICAgaWYgKCFjYW52YXMuX29yaWdpbmFsU3RhdGUpIHtcbiAgICAgIGNhbnZhcy5fb3JpZ2luYWxTdGF0ZSA9IHtcbiAgICAgICAgcGFyZW50OiBjYW52YXMucGFyZW50RWxlbWVudCxcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgdG9wOiBjYW52YXMuc3R5bGUudG9wLFxuICAgICAgICBsZWZ0OiBjYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgICB6SW5kZXg6IGNhbnZhcy5zdHlsZS56SW5kZXgsXG4gICAgICAgIGNhbnZhc1dpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGNhbnZhc0hlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gTW92ZSB0byBib2R5IGFuZCBtYWtlIGZ1bGxzY3JlZW5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgY2FudmFzLnN0eWxlLnpJbmRleCA9ICcxMCc7XG4gICAgY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XG4gICAgXG4gICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHdpbmRvd1xuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfTtcbiAgXG5cbiAgLy8gTG9hZCBjYWxpYnJhdGlvbiBzZXR1cFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuO1xuXG4gICAgY29uc3Qgc2V0dXBDYWxpYnJhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdDogQ2FsaWJyYXRlSGFuZGxlciB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXInKTtcbiAgICBcbiAgICAgICAgY29uc3QgY2FudmFzID0gZ2V0TWFpbkNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbnZhcyBub3QgYXZhaWxhYmxlIGR1cmluZyBzZXR1cENhbGlicmF0aW9uXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgbWFrZUNhbnZhc0Z1bGxzY3JlZW4oY2FudmFzKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2FudmFzIHNpemU6JywgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnR2VuZXJhdGVkIGNhbGlicmF0aW9uIHBvaW50czonLCBwb2ludHMpO1xuICAgICAgICBzZXRDYWxpYnJhdGlvblBvaW50cyhwb2ludHMpO1xuICAgIFxuICAgICAgICBjb25zdCBjYWxpYnJhdGVIYW5kbGVyID0gbmV3IENhbGlicmF0ZUhhbmRsZXIoe1xuICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICBjYWxpYnJhdGlvblBvaW50czogcG9pbnRzLFxuICAgICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IG9uQWN0aW9uQ2xpY2s/LigndG9nZ2xlVG9wQmFyJywgc2hvdyksXG4gICAgICAgICAgc2V0T3V0cHV0VGV4dDogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUNvdW50ZXI6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnRlcjogKG5ld0NvdW50ZXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3Q291bnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQocHJldiA9PiBuZXdDb3VudGVyKHByZXYpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudChuZXdDb3VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVGb2xkZXI6ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLFxuICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ0NhbGlicmF0aW9uIGNvbXBsZXRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHNldENhbGlicmF0aW9uSGFuZGxlcih7XG4gICAgICAgICAgaGFuZGxlQWN0aW9uOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoJ1N0YXJ0aW5nIGNhbGlicmF0aW9uLi4uJyk7XG4gICAgICAgICAgICBhd2FpdCBjYWxpYnJhdGVIYW5kbGVyLnN0YXJ0Q2FsaWJyYXRpb24oKTtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgICAgcmVzdG9yZUNhbnZhc1NpemUoY2FudmFzKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBjYWxpYnJhdGlvbjonLCBlcnIpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZXR1cENhbGlicmF0aW9uKCk7XG4gIH0sIFtjYXB0dXJlQ291bnQsIG9uQWN0aW9uQ2xpY2tdKTtcbiAgXG4gIC8vIENsZWFyIEFsbCBCdXR0b24gLSBSZXNldCBldmVyeXRoaW5nXG4gIGNvbnN0IGhhbmRsZUNsZWFyQWxsID0gKCkgPT4ge1xuICAgIC8vIENsZWFyIGNhbnZhcyBjb250ZW50XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBjYW52YXMgdG8gY29udGFpbmVyIG1vZGVcbiAgICAgIHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lcihjYW52YXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXNldCBzdGF0ZXNcbiAgICBzZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICBzZXRSZW1haW5pbmdDYXB0dXJlcygwKTtcbiAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgc2V0Q291bnRkb3duVmFsdWUobnVsbCk7XG4gICAgc2V0U2hvd0NhbnZhcyh0cnVlKTtcbiAgICBzZXRDdXJyZW50RG90KG51bGwpO1xuICB9O1xuXG4gIC8vIFRvZ2dsZSBIZWFkIFBvc2UgdmlzdWFsaXphdGlvblxuICBjb25zdCBoYW5kbGVUb2dnbGVIZWFkUG9zZSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdIZWFkUG9zZVN0YXRlID0gIXNob3dIZWFkUG9zZTtcbiAgICBzZXRTaG93SGVhZFBvc2UobmV3SGVhZFBvc2VTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgSGVhZCBwb3NlIHZpc3VhbGl6YXRpb24gJHtuZXdIZWFkUG9zZVN0YXRlID8gJ2VuYWJsZWQnIDogJ2Rpc2FibGVkJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnaGVhZFBvc2UnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93SGVhZFBvc2U6IG5ld0hlYWRQb3NlU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBoZWFkIHBvc2U6ICR7bmV3SGVhZFBvc2VTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEJvdW5kaW5nIEJveCB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94ID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0JvdW5kaW5nQm94U3RhdGUgPSAhc2hvd0JvdW5kaW5nQm94O1xuICAgIHNldFNob3dCb3VuZGluZ0JveChuZXdCb3VuZGluZ0JveFN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBCb3VuZGluZyBib3ggJHtuZXdCb3VuZGluZ0JveFN0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdib3VuZGluZ0JveCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dCb3VuZGluZ0JveDogbmV3Qm91bmRpbmdCb3hTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGJvdW5kaW5nIGJveDogJHtuZXdCb3VuZGluZ0JveFN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgTWFzayB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZU1hc2sgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFza1N0YXRlID0gIXNob3dNYXNrO1xuICAgIHNldFNob3dNYXNrKG5ld01hc2tTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgTWFzayAke25ld01hc2tTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygnbWFzaycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dNYXNrOiBuZXdNYXNrU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBtYXNrOiAke25ld01hc2tTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIFBhcmFtZXRlcnMgZGlzcGxheVxuICBjb25zdCBoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld1BhcmFtZXRlcnNTdGF0ZSA9ICFzaG93UGFyYW1ldGVycztcbiAgICBzZXRTaG93UGFyYW1ldGVycyhuZXdQYXJhbWV0ZXJzU3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYFBhcmFtZXRlcnMgJHtuZXdQYXJhbWV0ZXJzU3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3BhcmFtZXRlcnMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHZpZGVvUHJvY2Vzc29yIG9wdGlvbnMgZGlyZWN0bHkgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICBzaG93UGFyYW1ldGVyczogbmV3UGFyYW1ldGVyc1N0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgcGFyYW1ldGVyczogJHtuZXdQYXJhbWV0ZXJzU3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBjYW1lcmEgcHJldmlld1xuICBjb25zdCBoYW5kbGVUb2dnbGVDYW1lcmEgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Q2FtZXJhU3RhdGUgPSAhaXNDYW1lcmFBY3RpdmU7XG4gICAgc2V0SXNDYW1lcmFBY3RpdmUobmV3Q2FtZXJhU3RhdGUpO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHdpdGggJ3ByZXZpZXcnIGFjdGlvblxuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdwcmV2aWV3JywgbmV3Q2FtZXJhU3RhdGUpOyAvLyBQYXNzIHRoZSBuZXcgc3RhdGVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IHRyaWdnZXIgaWYgbm8gYWN0aW9uIGhhbmRsZXJcbiAgICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAodHJ1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHR1cm5pbmcgb24gY2FtZXJhLCBlbnN1cmUgd2UgYXBwbHkgY3VycmVudCB2aXN1YWxpemF0aW9uIHNldHRpbmdzXG4gICAgaWYgKG5ld0NhbWVyYVN0YXRlICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy52aWRlb1Byb2Nlc3Nvcikge1xuICAgICAgLy8gV2FpdCBhIHNob3J0IG1vbWVudCB0byBlbnN1cmUgdGhlIHZpZGVvIGVsZW1lbnQgaXMgcmVhZHlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAod2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgd2luZG93LnZpZGVvUHJvY2Vzc29yLnVwZGF0ZU9wdGlvbnMoe1xuICAgICAgICAgICAgc2hvd0hlYWRQb3NlLFxuICAgICAgICAgICAgc2hvd0JvdW5kaW5nQm94LFxuICAgICAgICAgICAgc2hvd01hc2ssXG4gICAgICAgICAgICBzaG93UGFyYW1ldGVyc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCAxMDApO1xuICAgIH1cbiAgfTtcblxuICAvLyBBZGQgYmFjayBidXR0b24gaGFuZGxlclxuICBjb25zdCBoYW5kbGVHb0JhY2sgPSAoKSA9PiB7XG4gICAgcm91dGVyLnB1c2goJy8nKTtcbiAgfTtcblxuICAvLyBNb2JpbGUgbGF5b3V0IC0gMng1IGdyaWRcbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAge2lzQ29tcGFjdE1vZGUgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMiBtYi00XCI+XG4gICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTIgZ2FwLTJcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG5cbiAgICAgIHsvKiBDYW1lcmEgUGVybWlzc2lvbiBQb3B1cCAqL31cbiAgICAgIHtzaG93UGVybWlzc2lvblBvcHVwICYmIChcbiAgICAgICAgPGRpdiBcbiAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1wb3B1cFwiIFxuICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gICAgICAgICAgICB6SW5kZXg6IDE1XG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi1kaWFsb2dcIiBcbiAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgIHdpZHRoOiAnNDAwcHgnLFxuICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzhweCcsXG4gICAgICAgICAgICAgIHBhZGRpbmc6ICcyMHB4JyxcbiAgICAgICAgICAgICAgYm94U2hhZG93OiAnMCA0cHggOHB4IHJnYmEoMCwgMCwgMCwgMC4yKSdcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGgzIFxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYW1lcmEtcGVybWlzc2lvbi10aXRsZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAxNXB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE4cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBDYW1lcmEgQWNjZXNzIFJlcXVpcmVkXG4gICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgPHAgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLW1lc3NhZ2VcIiBcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBtYXJnaW46ICcwIDAgMjBweCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6ICcxNHB4JyxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMS40J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBUaGlzIGFwcGxpY2F0aW9uIG5lZWRzIGFjY2VzcyB0byB5b3VyIGNhbWVyYSB0byBmdW5jdGlvbiBwcm9wZXJseS4gV2hlbiBwcm9tcHRlZCBieSB5b3VyIGJyb3dzZXIsIHBsZWFzZSBjbGljayBcIkFsbG93XCIgdG8gZ3JhbnQgY2FtZXJhIGFjY2Vzcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxkaXYgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWJ1dHRvbnNcIiBcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LWVuZCcsXG4gICAgICAgICAgICAgICAgZ2FwOiAnMTBweCdcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uRGVuaWVkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1idG5cIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnI2YwZjBmMCcsXG4gICAgICAgICAgICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogJzRweCcsXG4gICAgICAgICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJ1xuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1idG5cIlxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiAnOHB4IDE2cHgnLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzAwNjZjYycsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENvbnRpbnVlXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn0pO1xuY29uc3QgQWN0aW9uQnV0dG9uR3JvdXAgPSBkeW5hbWljKCgpID0+IFByb21pc2UucmVzb2x2ZShcbiAgZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4gPEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgey4uLnByb3BzfSByZWY9e3JlZn0gLz4pXG4pLCB7IHNzcjogZmFsc2UgfSk7XG4vLyBDcmVhdGUgYSBjbGllbnQtb25seSB2ZXJzaW9uIG9mIEFjdGlvbkJ1dHRvbkdyb3VwXG4vLyBjb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIpLCB7IHNzcjogZmFsc2UgfSk7XG5cbi8vIEFkZCBkZWZhdWx0IGV4cG9ydCBjb21wb25lbnRcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFjdGlvbkJ1dHRvblBhZ2UoKSB7XG4gIHJldHVybiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xufVxuXG5leHBvcnQgeyBBY3Rpb25CdXR0b24sIEFjdGlvbkJ1dHRvbkdyb3VwIH07Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJmb3J3YXJkUmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZU1lbW8iLCJkeW5hbWljIiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsInNob3dDYXB0dXJlUHJldmlldyIsImRyYXdSZWREb3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJydW5Db3VudGRvd24iLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsInVzZVJvdXRlciIsInVzZUFkbWluU2V0dGluZ3MiLCJSYW5kb21Eb3RBY3Rpb24iLCJTZXRSYW5kb21BY3Rpb24iLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJrZXlzMSIsIk9iamVjdCIsImtleXMiLCJrZXlzMiIsImxlbmd0aCIsImV2ZXJ5Iiwia2V5IiwiaW5jbHVkZXMiLCJBY3Rpb25CdXR0b24iLCJ0ZXh0IiwiYWJicmV2aWF0ZWRUZXh0Iiwib25DbGljayIsImN1c3RvbUNsYXNzIiwiZGlzYWJsZWQiLCJhY3RpdmUiLCJpc0FiYnJldmlhdGVkIiwic2V0SXNBYmJyZXZpYXRlZCIsInNldHRpbmdzIiwiY3VycmVudFVzZXJJZCIsInNldEN1cnJlbnRVc2VySWQiLCJpc0NhcHR1cmluZyIsInNldElzQ2FwdHVyaW5nIiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsInByb2Nlc3NTdGF0dXMiLCJzZXRQcm9jZXNzU3RhdHVzIiwiYnV0dG9uUHJvcHMiLCJjbGFzc05hbWUiLCJ0aXRsZSIsInRpbWVvdXRJZCIsImhhbmRsZVJlc2l6ZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ3aWR0aCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVVzZXJJZENoYW5nZSIsImV2ZW50IiwiZGV0YWlsIiwidHlwZSIsIm5ld1VzZXJJZCIsInVzZXJJZCIsImJ1dHRvbiIsImRpdiIsIkFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIiLCJyZWYiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwiaXNDb21wYWN0TW9kZSIsIm9uQWN0aW9uQ2xpY2siLCJyb3V0ZXIiLCJ1cGRhdGVTZXR0aW5ncyIsInJhbmRvbVRpbWVzIiwic2V0UmFuZG9tVGltZXMiLCJkZWxheVNlY29uZHMiLCJzZXREZWxheVNlY29uZHMiLCJjYW52YXNSZWYiLCJjb3VudGRvd25WYWx1ZSIsInNldENvdW50ZG93blZhbHVlIiwiY3VycmVudERvdCIsInNldEN1cnJlbnREb3QiLCJjYWxpYnJhdGlvblBvaW50cyIsInNldENhbGlicmF0aW9uUG9pbnRzIiwicmVtYWluaW5nQ2FwdHVyZXMiLCJzZXRSZW1haW5pbmdDYXB0dXJlcyIsInNob3dDYW52YXMiLCJzZXRTaG93Q2FudmFzIiwiY2FsaWJyYXRpb25IYW5kbGVyIiwic2V0Q2FsaWJyYXRpb25IYW5kbGVyIiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50Iiwic2hvd0hlYWRQb3NlIiwic2V0U2hvd0hlYWRQb3NlIiwic2hvd0JvdW5kaW5nQm94Iiwic2V0U2hvd0JvdW5kaW5nQm94Iiwic2hvd01hc2siLCJzZXRTaG93TWFzayIsInNob3dQYXJhbWV0ZXJzIiwic2V0U2hvd1BhcmFtZXRlcnMiLCJpc0NhbWVyYUFjdGl2ZSIsInNldElzQ2FtZXJhQWN0aXZlIiwic2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldFNob3dQZXJtaXNzaW9uUG9wdXAiLCJzZXR0aW5nc0NhY2hlIiwiTWFwIiwibGFzdFNldHRpbmdzVXBkYXRlIiwiY2FudmFzTWFuYWdlciIsIkNhbnZhc01hbmFnZXIiLCJnZXRNYWluQ2FudmFzIiwiZ2V0Q2FudmFzIiwiY3JlYXRlQ2FudmFzIiwiZW5zdXJlQ2FudmFzRXhpc3RzIiwicmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyIiwiY2FudmFzIiwiZXhpdEZ1bGxzY3JlZW4iLCJjbGVhbnVwQ2FudmFzIiwiZGVzdHJveSIsImNsZWFyQ2FudmFzIiwiY2xlYXIiLCJjYW52YXNVdGlscyIsImVudGVyRnVsbHNjcmVlbiIsImRyYXdEb3QiLCJ4IiwieSIsInJhZGl1cyIsImN0eCIsImdldENvbnRleHQiLCJnZXREaW1lbnNpb25zIiwiaGVpZ2h0IiwiaXNGdWxsc2NyZWVuIiwiaXNJbkZ1bGxzY3JlZW4iLCJyZXNpemVUb0NvbnRhaW5lciIsImNvbnRhaW5lciIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYWN0aW9uQ2xhc3NlcyIsInJhbmRvbURvdEFjdGlvbiIsInRvZ2dsZVRvcEJhciIsInNob3ciLCJvblN0YXR1c1VwZGF0ZSIsInN0YXR1cyIsInVuZGVmaW5lZCIsInNhdmVJbWFnZVRvU2VydmVyIiwic2V0UmFuZG9tQWN0aW9uIiwiaGFuZGxlUmFuZG9tRG90V2l0aEFjdGlvbkNsYXNzIiwiaGFuZGxlUmFuZG9tRG90IiwiaGFuZGxlU2V0UmFuZG9tV2l0aEFjdGlvbkNsYXNzIiwiaGFuZGxlQWN0aW9uIiwidXNlclNldHRpbmdzIiwiY2FjaGVkU2V0dGluZ3MiLCJjdXJyZW50IiwiZ2V0IiwiTnVtYmVyIiwidGltZXNfc2V0X3JhbmRvbSIsImRlbGF5X3NldF9yYW5kb20iLCJzZXQiLCJEYXRlIiwibm93IiwiaGFuZGxlU2V0dGluZ3NVcGRhdGUiLCJuZXdUaW1lcyIsIm5ld0RlbGF5IiwiYWN0aW9uQnV0dG9uRnVuY3Rpb25zIiwiaGFuZGxlU2V0UmFuZG9tIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwiaGFuZGxlQ2xlYXJBbGwiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjb25zb2xlIiwibG9nIiwidXBkYXRlQ29udHJvbFZhbHVlcyIsInRpbWVJbnB1dCIsInRpbWVWYWx1ZSIsInBhcnNlSW50IiwidmFsdWUiLCJpc05hTiIsImRlbGF5SW5wdXQiLCJkZWxheVZhbHVlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImV4aXN0aW5nQ2FudmFzIiwicmVtb3ZlIiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJjc3NUZXh0IiwiaW5uZXJIZWlnaHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJ3aGl0ZVNjcmVlbkNhbnZhcyIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNsZWFudXAiLCJ0YXJnZXRDb250YWluZXIiLCJ1cGRhdGVDYW52YXNTaXplIiwic2V0dXBSZXNwb25zaXZlQ2FudmFzIiwiZGlzcGxheSIsImJhY2tncm91bmRDb2xvciIsInJlc2l6ZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwidGFyZ2V0Iiwib2JzZXJ2ZSIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIl93aW5kb3dSZXNpemVIYW5kbGVyIiwib3JpZ2luYWxTdGF0ZSIsInBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ6SW5kZXgiLCJoaWRlVUlFbGVtZW50cyIsInNob3dVSUVsZW1lbnRzIiwiZWxlbWVudHNUb0hpZGUiLCJmb3JFYWNoIiwic2VsZWN0b3IiLCJlbGVtZW50cyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJlbCIsInNldEF0dHJpYnV0ZSIsImhpZGRlbkVsZW1lbnRzIiwicmVtb3ZlQXR0cmlidXRlIiwiY2xlYXJSZWN0IiwiY29uc3RydWN0b3IiLCJoYW5kbGVEb3RQcm9jZXNzIiwib3B0aW9ucyIsInVzZVJhbmRvbVBvc2l0aW9uIiwicG9zdENvdW50ZG93bkRlbGF5Iiwia2VlcERvdFZpc2libGVJbnRlcnZhbCIsImNvdW50ZG93bkVsZW1lbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkVycm9yIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJkb3RQb3NpdGlvbiIsImRvdFJhZGl1cyIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiY291bnQiLCJ0ZXh0Q29udGVudCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsInN1Y2Nlc3MiLCJlcnJvciIsIm1lc3NhZ2UiLCJjbGVhckludGVydmFsIiwicmVtYWluaW5nQ291bnRkb3ducyIsIm9yaWdpbmFsQ2FudmFzUGFyZW50Iiwib3JpZ2luYWxDYW52YXNTdHlsZSIsInN0YXR1c0luZGljYXRvciIsImN1cnJlbnRSZWRyYXdJbnRlcnZhbCIsInBvaW50cyIsInN1Y2Nlc3NDb3VudCIsImkiLCJ3YXJuIiwicmVkcmF3Q3VycmVudERvdCIsInNjcmVlbkltYWdlIiwidGltZXMiLCJkZWxheSIsImN1cnJlbnRJbmRleCIsInJlc3VsdCIsImNhcHR1cmluZyIsIm1ha2VDYW52YXNGdWxsc2NyZWVuIiwiX29yaWdpbmFsU3RhdGUiLCJzZXR1cENhbGlicmF0aW9uIiwiZGVmYXVsdCIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjYWxpYnJhdGVIYW5kbGVyIiwic2V0T3V0cHV0VGV4dCIsIm5ld0NvdW50ZXIiLCJwcmV2IiwiY2FwdHVyZUZvbGRlciIsIm9uQ29tcGxldGUiLCJzdGFydENhbGlicmF0aW9uIiwicmVzdG9yZUNhbnZhc1NpemUiLCJlcnIiLCJoYW5kbGVUb2dnbGVIZWFkUG9zZSIsIm5ld0hlYWRQb3NlU3RhdGUiLCJ2aWRlb1Byb2Nlc3NvciIsInVwZGF0ZU9wdGlvbnMiLCJoYW5kbGVUb2dnbGVCb3VuZGluZ0JveCIsIm5ld0JvdW5kaW5nQm94U3RhdGUiLCJoYW5kbGVUb2dnbGVNYXNrIiwibmV3TWFza1N0YXRlIiwiaGFuZGxlVG9nZ2xlUGFyYW1ldGVycyIsIm5ld1BhcmFtZXRlcnNTdGF0ZSIsImhhbmRsZVRvZ2dsZUNhbWVyYSIsIm5ld0NhbWVyYVN0YXRlIiwiaGFuZGxlR29CYWNrIiwicHVzaCIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJoMyIsIm1hcmdpbiIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiaGFuZGxlUGVybWlzc2lvbkRlbmllZCIsImJvcmRlciIsImN1cnNvciIsImhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCIsImNvbG9yIiwiQWN0aW9uQnV0dG9uR3JvdXAiLCJwcm9wcyIsInNzciIsIkFjdGlvbkJ1dHRvblBhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});