"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Only initialize if canvas doesn't exist\n            if (!document.querySelector('#tracking-canvas')) {\n                const canvas = getMainCanvas();\n                console.log('Canvas initialized:', canvas ? 'success' : 'failed');\n            }\n            // Cleanup function\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    // Don't remove canvas on cleanup to prevent recreation issues\n                    console.log('ActionButton cleanup - canvas preserved');\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Initialize canvas on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const initializeCanvas = {\n                \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                    // Remove any existing canvas\n                    const existingCanvas = document.querySelector('.tracking-canvas');\n                    if (existingCanvas) {\n                        existingCanvas.remove();\n                    }\n                    // Create new canvas\n                    const canvas = document.createElement('canvas');\n                    canvas.className = 'tracking-canvas';\n                    canvas.id = 'tracking-canvas';\n                    canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        opacity: 0;\\n        pointer-events: none;\\n        z-index: 5;\\n      \";\n                    // Set canvas dimensions\n                    canvas.width = window.innerWidth;\n                    canvas.height = window.innerHeight;\n                    // Add canvas to body\n                    document.body.appendChild(canvas);\n                    // Store reference\n                    canvasRef.current = canvas;\n                    if (true) {\n                        window.whiteScreenCanvas = canvas;\n                    }\n                    // Initialize with white background\n                    const ctx = canvas.getContext('2d');\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Add resize handler\n                    const handleResize = {\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\": ()=>{\n                            canvas.width = window.innerWidth;\n                            canvas.height = window.innerHeight;\n                            ctx.fillStyle = 'white';\n                            ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        }\n                    }[\"ActionButtonGroupInner.useEffect.initializeCanvas.handleResize\"];\n                    window.addEventListener('resize', handleResize);\n                    return ({\n                        \"ActionButtonGroupInner.useEffect.initializeCanvas\": ()=>{\n                            window.removeEventListener('resize', handleResize);\n                            if (canvas.parentNode) {\n                                canvas.parentNode.removeChild(canvas);\n                            }\n                        }\n                    })[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n                }\n            }[\"ActionButtonGroupInner.useEffect.initializeCanvas\"];\n            const cleanup = initializeCanvas();\n            return cleanup;\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Helper function to get the main canvas - improved to be more reliable\n    const getMainCanvas = ()=>{\n        // First check if we have a valid canvas reference\n        if (canvasRef.current && document.contains(canvasRef.current)) {\n            return canvasRef.current;\n        }\n        // Try to find existing canvas in DOM\n        let existingCanvas = document.querySelector('#tracking-canvas');\n        if (existingCanvas && document.contains(existingCanvas)) {\n            canvasRef.current = existingCanvas;\n            window.whiteScreenCanvas = existingCanvas;\n            return existingCanvas;\n        }\n        // Create new canvas only if none exists\n        console.log('Creating new canvas...');\n        const canvas = document.createElement('canvas');\n        canvas.className = 'tracking-canvas';\n        canvas.id = 'tracking-canvas';\n        // Set initial dimensions and style\n        canvas.width = 800;\n        canvas.height = 400;\n        canvas.style.cssText = \"\\n      position: relative;\\n      width: 100%;\\n      height: 400px;\\n      background-color: white;\\n      border: 1px solid #ccc;\\n      display: block;\\n    \";\n        // Initialize with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Find container and append\n        const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n        container.appendChild(canvas);\n        // Store references\n        canvasRef.current = canvas;\n        window.whiteScreenCanvas = canvas;\n        return canvas;\n    };\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    // Handler to cancel permission popup\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n    };\n    // Helper function to restore the canvas to its original parent and styling\n    const restoreCanvas = (canvas)=>{\n        if (!canvas || !canvas._originalState) return;\n        const original = canvas._originalState;\n        try {\n            // Restore to original parent\n            if (original.parent && document.contains(original.parent)) {\n                original.parent.appendChild(canvas);\n            } else {\n                // Fallback to a container if original parent is gone\n                const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n                container.appendChild(canvas);\n            }\n            // Restore styles\n            canvas.style.position = original.position || 'relative';\n            canvas.style.top = original.top || '';\n            canvas.style.left = original.left || '';\n            canvas.style.width = original.width || '100%';\n            canvas.style.height = original.height || '400px';\n            canvas.style.zIndex = original.zIndex || '';\n            canvas.style.backgroundColor = 'white';\n            // Restore dimensions\n            canvas.width = original.canvasWidth || 800;\n            canvas.height = original.canvasHeight || 400;\n            // Clear with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Clear the saved state\n            delete canvas._originalState;\n        } catch (error) {\n            console.error('Error restoring canvas:', error);\n            // Fallback: just clear the canvas\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    };\n    // Clear the canvas\n    const clearCanvas = ()=>{\n        const canvas = getMainCanvas();\n        if (!canvas) {\n            console.warn(\"No canvas found for clearing\");\n            return;\n        }\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        setCurrentDot(null);\n    };\n    // Add this function to actionButton.js\n    /**\n   * Consolidated function that handles the entire dot process: drawing, countdown, capture, and preview\n   * @param {Object} options - Configuration options\n   * @param {Object} options.position - {x, y} coordinates where to draw the dot\n   * @param {Function} options.onStatusUpdate - Callback for status updates\n   * @param {Function} options.toggleTopBar - Function to toggle top bar visibility\n   * @param {Function} options.triggerCameraAccess - Function to ensure camera is available\n   * @param {Function} options.setIsCapturing - Function to update capturing state\n   * @param {Number} options.captureCount - Current capture counter\n   * @param {Function} options.setCaptureCount - Function to update the capture counter\n   * @param {Boolean} options.useRandomPosition - Whether to generate a random position\n   * @returns {Promise<Object>} - Result object with capture data\n   */ // Add a centralized canvas configuration system\n    const CANVAS_CONFIG = {\n        // Default dimensions\n        defaultWidth: 800,\n        defaultHeight: 400,\n        // Responsive breakpoints\n        breakpoints: {\n            mobile: {\n                maxWidth: 768,\n                height: 300\n            },\n            tablet: {\n                maxWidth: 1024,\n                height: 400\n            },\n            desktop: {\n                minWidth: 1025,\n                height: 500\n            }\n        },\n        // Canvas modes\n        modes: {\n            container: {\n                position: 'relative',\n                width: '100%',\n                height: '400px',\n                backgroundColor: 'white',\n                border: '1px solid #ccc',\n                display: 'block',\n                zIndex: 'auto',\n                opacity: '1',\n                pointerEvents: 'auto'\n            },\n            fullscreen: {\n                position: 'fixed',\n                top: '0',\n                left: '0',\n                width: '100vw',\n                height: '100vh',\n                backgroundColor: 'white',\n                border: 'none',\n                display: 'block',\n                zIndex: '99999',\n                opacity: '1',\n                pointerEvents: 'auto',\n                margin: '0',\n                padding: '0',\n                boxSizing: 'border-box'\n            },\n            overlay: {\n                position: 'fixed',\n                top: '0',\n                left: '0',\n                width: '100vw',\n                height: '100vh',\n                backgroundColor: 'rgba(255, 255, 255, 0.95)',\n                border: 'none',\n                display: 'block',\n                zIndex: '9999',\n                opacity: '1',\n                pointerEvents: 'auto'\n            }\n        },\n        // Animation settings\n        animations: {\n            transition: 'all 0.3s ease-in-out',\n            fadeIn: 'opacity 0.3s ease-in',\n            fadeOut: 'opacity 0.3s ease-out'\n        }\n    };\n    // Canvas manager class for better organization\n    class CanvasManager {\n        // Get responsive dimensions based on screen size\n        getResponsiveDimensions() {\n            const width = window.innerWidth;\n            const height = window.innerHeight;\n            if (width <= this.config.breakpoints.mobile.maxWidth) {\n                return {\n                    width: width,\n                    height: this.config.breakpoints.mobile.height\n                };\n            } else if (width <= this.config.breakpoints.tablet.maxWidth) {\n                return {\n                    width: width,\n                    height: this.config.breakpoints.tablet.height\n                };\n            } else {\n                return {\n                    width: width,\n                    height: this.config.breakpoints.desktop.height\n                };\n            }\n        }\n        // Create or get canvas with proper initialization\n        createCanvas() {\n            let canvas = document.querySelector('#tracking-canvas');\n            if (!canvas) {\n                canvas = document.createElement('canvas');\n                canvas.className = 'tracking-canvas';\n                canvas.id = 'tracking-canvas';\n                // Set initial responsive dimensions\n                const dimensions = this.getResponsiveDimensions();\n                canvas.width = dimensions.width;\n                canvas.height = dimensions.height;\n                // Apply container mode styles\n                this.applyMode(canvas, 'container');\n                // Find appropriate container\n                const container = this.findContainer();\n                container.appendChild(canvas);\n                // Initialize with white background\n                this.clearCanvas(canvas);\n                console.log(\"Canvas created with dimensions: \".concat(dimensions.width, \"x\").concat(dimensions.height));\n            }\n            this.canvas = canvas;\n            window.whiteScreenCanvas = canvas;\n            return canvas;\n        }\n        // Find the best container for the canvas\n        findContainer() {\n            const containers = [\n                '.canvas-container',\n                '.main-content',\n                '.preview-area',\n                'body'\n            ];\n            for (const selector of containers){\n                const container = document.querySelector(selector);\n                if (container) {\n                    return container;\n                }\n            }\n            return document.body;\n        }\n        // Apply a specific mode to the canvas\n        applyMode(canvas, mode) {\n            if (!canvas || !this.config.modes[mode]) {\n                console.warn(\"Invalid canvas or mode: \".concat(mode));\n                return;\n            }\n            const modeConfig = this.config.modes[mode];\n            const style = canvas.style;\n            // Apply all mode properties\n            Object.entries(modeConfig).forEach((param)=>{\n                let [property, value] = param;\n                style[property] = value;\n            });\n            // Add transition for smooth mode changes\n            style.transition = this.config.animations.transition;\n            this.currentMode = mode;\n            console.log(\"Canvas mode changed to: \".concat(mode));\n        }\n        // Switch canvas to fullscreen mode\n        switchToFullscreen() {\n            if (!this.canvas) {\n                this.createCanvas();\n            }\n            // Save original state if not already saved\n            if (!this.originalState) {\n                this.saveOriginalState();\n            }\n            // Move to body for fullscreen\n            document.body.appendChild(this.canvas);\n            // Apply fullscreen mode\n            this.applyMode(this.canvas, 'fullscreen');\n            // Update dimensions to match window\n            const dimensions = this.getResponsiveDimensions();\n            this.canvas.width = dimensions.width;\n            this.canvas.height = dimensions.height;\n            // Clear and redraw\n            this.clearCanvas(this.canvas);\n            // Hide UI elements\n            this.hideUIElements();\n            // Set up resize observer\n            this.setupResizeObserver();\n        }\n        // Restore canvas to container mode\n        restoreToContainer() {\n            if (!this.canvas) return;\n            // Remove resize observer\n            this.removeResizeObserver();\n            // Show UI elements\n            this.showUIElements();\n            // Find container and move canvas\n            const container = this.findContainer();\n            container.appendChild(this.canvas);\n            // Apply container mode\n            this.applyMode(this.canvas, 'container');\n            // Update dimensions based on container\n            const containerRect = container.getBoundingClientRect();\n            this.canvas.width = containerRect.width || this.config.defaultWidth;\n            this.canvas.height = containerRect.height || this.config.defaultHeight;\n            // Clear and redraw\n            this.clearCanvas(this.canvas);\n            // Restore original state if available\n            if (this.originalState) {\n                this.restoreOriginalState();\n            }\n        }\n        // Save original canvas state\n        saveOriginalState() {\n            if (!this.canvas) return;\n            this.originalState = {\n                parent: this.canvas.parentElement,\n                width: this.canvas.width,\n                height: this.canvas.height,\n                style: {\n                    position: this.canvas.style.position,\n                    top: this.canvas.style.top,\n                    left: this.canvas.style.left,\n                    width: this.canvas.style.width,\n                    height: this.canvas.style.height,\n                    zIndex: this.canvas.style.zIndex,\n                    backgroundColor: this.canvas.style.backgroundColor\n                }\n            };\n        }\n        // Restore original canvas state\n        restoreOriginalState() {\n            if (!this.canvas || !this.originalState) return;\n            try {\n                // Restore dimensions\n                this.canvas.width = this.originalState.width;\n                this.canvas.height = this.originalState.height;\n                // Restore styles\n                Object.entries(this.originalState.style).forEach((param)=>{\n                    let [property, value] = param;\n                    this.canvas.style[property] = value;\n                });\n                // Clear saved state\n                this.originalState = null;\n            } catch (error) {\n                console.error('Error restoring canvas state:', error);\n            }\n        }\n        // Clear canvas with white background\n        clearCanvas(canvas) {\n            if (!canvas) return;\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        // Hide UI elements during fullscreen\n        hideUIElements() {\n            const elementsToHide = [\n                '.topbar',\n                '.canvas-container',\n                '.main-content',\n                '.metrics-panel',\n                '.display-metrics',\n                'nav',\n                'header',\n                '.button-groups',\n                '.control-buttons'\n            ];\n            elementsToHide.forEach((selector)=>{\n                const elements = document.querySelectorAll(selector);\n                elements.forEach((el)=>{\n                    if (el.style.display !== 'none') {\n                        el.setAttribute('data-original-display', el.style.display);\n                        el.style.display = 'none';\n                        el.setAttribute('data-hidden-by-canvas', 'true');\n                    }\n                });\n            });\n        }\n        // Show previously hidden UI elements\n        showUIElements() {\n            const hiddenElements = document.querySelectorAll('[data-hidden-by-canvas=\"true\"]');\n            hiddenElements.forEach((el)=>{\n                const originalDisplay = el.getAttribute('data-original-display') || '';\n                el.style.display = originalDisplay;\n                el.removeAttribute('data-original-display');\n                el.removeAttribute('data-hidden-by-canvas');\n            });\n        }\n        // Set up resize observer for responsive behavior\n        setupResizeObserver() {\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            this.resizeObserver = new ResizeObserver((entries)=>{\n                for (const entry of entries){\n                    if (entry.target === this.canvas) {\n                        this.handleResize();\n                    }\n                }\n            });\n            this.resizeObserver.observe(this.canvas);\n            // Also listen for window resize\n            window.addEventListener('resize', this.handleResize.bind(this));\n        }\n        // Handle canvas resize\n        handleResize() {\n            if (!this.canvas) return;\n            const dimensions = this.getResponsiveDimensions();\n            // Update canvas dimensions\n            this.canvas.width = dimensions.width;\n            this.canvas.height = dimensions.height;\n            // Redraw white background\n            this.clearCanvas(this.canvas);\n            console.log(\"Canvas resized to: \".concat(dimensions.width, \"x\").concat(dimensions.height));\n        }\n        // Remove resize observer\n        removeResizeObserver() {\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n                this.resizeObserver = null;\n            }\n            window.removeEventListener('resize', this.handleResize.bind(this));\n        }\n        // Cleanup canvas\n        cleanup() {\n            this.removeResizeObserver();\n            if (this.canvas && this.canvas.parentNode) {\n                this.canvas.parentNode.removeChild(this.canvas);\n            }\n            if (window.whiteScreenCanvas === this.canvas) {\n                delete window.whiteScreenCanvas;\n            }\n            this.canvas = null;\n            this.originalState = null;\n            this.currentMode = 'container';\n        }\n        // Get current canvas\n        getCanvas() {\n            return this.canvas || this.createCanvas();\n        }\n        // Check if canvas is in fullscreen mode\n        isFullscreen() {\n            return this.currentMode === 'fullscreen';\n        }\n        constructor(){\n            this.canvas = null;\n            this.currentMode = 'container';\n            this.originalState = null;\n            this.resizeObserver = null;\n            this.config = CANVAS_CONFIG;\n        }\n    }\n    // Create global canvas manager instance\n    const canvasManager = new CanvasManager();\n    // Replace the old ensureCanvasExists function with the new manager\n    const ensureCanvasExists = ()=>{\n        return canvasManager.getCanvas();\n    };\n    // Update the existing functions to use the new canvas manager\n    const restoreCanvasToContainer = (canvas)=>{\n        canvasManager.restoreToContainer();\n    };\n    const cleanupCanvas = ()=>{\n        canvasManager.cleanup();\n    };\n    // Modified handleDotProcess function with improved dot and countdown alignment\n    // Complete handleDotProcess function with proper canvas management\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        let canvas = null;\n        let keepDotVisibleInterval = null;\n        let countdownElement = null;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Use canvas manager to switch to fullscreen mode\n            canvasManager.switchToFullscreen();\n            canvas = canvasManager.getCanvas();\n            if (!canvas) {\n                throw new Error(\"Failed to create or find canvas\");\n            }\n            // Get canvas dimensions\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n            // Get context and clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"âœ“\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement && countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        } finally{\n            // Clear redraw interval first\n            if (keepDotVisibleInterval) {\n                clearInterval(keepDotVisibleInterval);\n                keepDotVisibleInterval = null;\n            }\n            // Remove countdown element if it still exists\n            if (countdownElement && countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Remove any remaining countdown elements\n            const remainingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            remainingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Use restoreCanvasToContainer to properly restore canvas\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        // Declare these variables OUTSIDE the try block\n        let canvas = null;\n        let originalCanvasParent = null;\n        let originalCanvasStyle = {};\n        let statusIndicator = null;\n        let currentRedrawInterval = null;\n        try {\n            canvasManager.switchToFullscreen();\n            canvas = canvasManager.getCanvas();\n            if (!canvas) {\n                console.error('Failed to create canvas for calibration');\n                return;\n            }\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setShowCanvas(true);\n            setProcessStatus(\"Starting calibration sequence...\");\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 300));\n            // Get canvas reference\n            canvas = getMainCanvas();\n            if (!canvas) {\n                setProcessStatus(\"Error: Canvas not found\");\n                setIsCapturing(false);\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                }\n                return;\n            }\n            // Save original parent and style\n            originalCanvasParent = canvas.parentElement;\n            originalCanvasStyle = {\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex\n            };\n            // Move canvas to body for maximum reliability\n            document.body.appendChild(canvas);\n            // Make canvas fullscreen with fixed positioning\n            canvas.style.position = 'fixed';\n            canvas.style.top = '0';\n            canvas.style.left = '0';\n            canvas.style.width = '100vw';\n            canvas.style.height = '100vh';\n            canvas.style.zIndex = '10';\n            // Set dimensions to match window exactly\n            const canvasWidth = window.innerWidth;\n            const canvasHeight = window.innerHeight;\n            canvas.width = canvasWidth;\n            canvas.height = canvasHeight;\n            console.log(\"Canvas set to fullscreen: \".concat(canvasWidth, \"x\").concat(canvasHeight));\n            // Get context\n            const ctx = canvas.getContext('2d');\n            // Clear canvas with white background\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Generate calibration points based on the canvas size\n            const { generateCalibrationPoints } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\"));\n            const points = generateCalibrationPoints(canvasWidth, canvasHeight);\n            if (!points || points.length === 0) {\n                throw new Error(\"Failed to generate calibration points\");\n            }\n            // Create a status indicator\n            statusIndicator = document.createElement('div');\n            statusIndicator.className = 'calibrate-status-indicator';\n            statusIndicator.style.cssText = \"\\n        position: fixed;\\n        top: 20px;\\n        right: 20px;\\n        background-color: rgba(0, 102, 204, 0.9);\\n        color: white;\\n        font-size: 16px;\\n        font-weight: bold;\\n        padding: 10px 15px;\\n        border-radius: 8px;\\n        z-index: 10000;\\n        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n      \";\n            statusIndicator.textContent = 'Calibration: Initializing...';\n            document.body.appendChild(statusIndicator);\n            // Process each calibration point\n            let successCount = 0;\n            for(let i = 0; i < points.length; i++){\n                const point = points[i];\n                // Clear any existing redraw interval\n                if (currentRedrawInterval) {\n                    clearInterval(currentRedrawInterval);\n                    currentRedrawInterval = null;\n                }\n                // Update status displays\n                statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                // Reset canvas if dimensions changed\n                if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                    console.warn(\"Canvas dimensions changed. Resetting to \".concat(canvasWidth, \"x\").concat(canvasHeight));\n                    canvas.width = canvasWidth;\n                    canvas.height = canvasHeight;\n                }\n                // Make sure canvas is still attached to body and in fullscreen mode\n                if (canvas.parentElement !== document.body) {\n                    document.body.appendChild(canvas);\n                    canvas.style.position = 'fixed';\n                    canvas.style.top = '0';\n                    canvas.style.left = '0';\n                    canvas.style.width = '100vw';\n                    canvas.style.height = '100vh';\n                    canvas.style.zIndex = '10';\n                }\n                // Clear canvas with white background\n                ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                // Draw the calibration point\n                const radius = 14; // Slightly larger for better visibility\n                (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                // Create redraw function for this point\n                const redrawCurrentDot = ()=>{\n                    // Verify canvas dimensions and parent\n                    if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {\n                        canvas.width = canvasWidth;\n                        canvas.height = canvasHeight;\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n                    }\n                    // Make sure canvas is still attached to body\n                    if (canvas.parentElement !== document.body) {\n                        document.body.appendChild(canvas);\n                    }\n                    // Redraw dot without clearing\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                };\n                // Start redraw interval - more frequent updates for reliable dot visibility\n                currentRedrawInterval = setInterval(redrawCurrentDot, 50);\n                // Remove any existing countdown elements\n                const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                existingCountdowns.forEach((el)=>{\n                    if (el.parentNode) el.parentNode.removeChild(el);\n                });\n                // Create custom countdown element\n                const countdownElement = document.createElement('div');\n                countdownElement.className = 'dot-countdown'; // Consistent class name\n                countdownElement.style.cssText = \"\\n          position: fixed;\\n          left: \".concat(point.x, \"px;\\n          top: \").concat(point.y - 60, \"px;\\n          transform: translateX(-50%);\\n          color: red;\\n          font-size: 36px;\\n          font-weight: bold;\\n          text-shadow: 0 0 10px white, 0 0 20px white;\\n          z-index: 10000;\\n          background-color: rgba(255, 255, 255, 0.8);\\n          border: 2px solid red;\\n          border-radius: 50%;\\n          width: 50px;\\n          height: 50px;\\n          display: flex;\\n          justify-content: center;\\n          align-items: center;\\n          box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n        \");\n                document.body.appendChild(countdownElement);\n                try {\n                    // Manual countdown\n                    for(let count = 3; count > 0; count--){\n                        countdownElement.textContent = count;\n                        setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                        // Force redraw multiple times during countdown to ensure visibility\n                        redrawCurrentDot();\n                        await new Promise((resolve)=>setTimeout(resolve, 800));\n                        // Redraw again halfway through the wait to ensure dot stays visible\n                        redrawCurrentDot();\n                    }\n                    // Show checkmark\n                    countdownElement.textContent = \"âœ“\";\n                    redrawCurrentDot();\n                    // Remove countdown element after delay\n                    setTimeout(()=>{\n                        if (countdownElement.parentNode) {\n                            countdownElement.parentNode.removeChild(countdownElement);\n                        }\n                    }, 300);\n                    // Make sure dot is still visible\n                    redrawCurrentDot();\n                    // Capture images at this point\n                    console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                    // Manual force redraw one more time just before capture\n                    (0,_components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                    const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                        point: point,\n                        captureCount: captureCount,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCount,\n                        showCapturePreview: _components_collected_dataset_customized_Action_countSave__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Wait between points\n                    await new Promise((resolve)=>setTimeout(resolve, 1200));\n                } catch (error) {\n                    console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                } finally{\n                    // Clean up countdown if it still exists\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    // Clear redraw interval\n                    if (currentRedrawInterval) {\n                        clearInterval(currentRedrawInterval);\n                        currentRedrawInterval = null;\n                    }\n                }\n            }\n            // Calibration complete\n            if (statusIndicator) {\n                statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n            }\n            setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            // Clean up redraw interval\n            if (currentRedrawInterval) {\n                clearInterval(currentRedrawInterval);\n            }\n        } finally{\n            // Remove status indicator if it exists\n            if (statusIndicator && statusIndicator.parentNode) {\n                setTimeout(()=>{\n                    statusIndicator.parentNode.removeChild(statusIndicator);\n                }, 3000);\n            }\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            canvasManager.switchToFullscreen();\n            const canvas = canvasManager.getCanvas();\n            if (!canvas) {\n                console.error('Failed to create canvas for set random');\n                return;\n            }\n            // Always get the latest settings from context for the current user\n            const userSettings = settings && settings[currentUserId] ? settings[currentUserId] : {};\n            const times = Number(userSettings.times_set_random) || Number(randomTimes) || 1;\n            const delay = Number(userSettings.delay_set_random) || Number(delaySeconds) || 3;\n            // Log current settings before starting\n            console.log('Starting Set Random with settings:', {\n                randomTimes,\n                delaySeconds,\n                currentUserId,\n                settings,\n                userSettings,\n                times,\n                delay\n            });\n            // Hide TopBar\n            if (typeof onActionClick === 'function') {\n                onActionClick('toggleTopBar', false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            setIsCapturing(true);\n            setRemainingCaptures(times);\n            setProcessStatus(\"Starting \".concat(times, \" random captures with \").concat(delay, \"s delay...\"));\n            // Process all captures in sequence\n            let successCount = 0;\n            for(let currentIndex = 1; currentIndex <= times; currentIndex++){\n                // Update status for current capture\n                setProcessStatus(\"Capture \".concat(currentIndex, \" of \").concat(times));\n                setRemainingCaptures(times - currentIndex + 1);\n                console.log(\"Starting capture \".concat(currentIndex, \" of \").concat(times));\n                // Use handleDotProcess for each capture\n                const result = await handleDotProcess({\n                    useRandomPosition: true,\n                    onStatusUpdate: (status)=>{\n                        if (status.processStatus) {\n                            setProcessStatus(\"Capture \".concat(currentIndex, \"/\").concat(times, \": \").concat(status.processStatus));\n                        }\n                    },\n                    toggleTopBar: (show)=>{\n                        // Only show TopBar after the last capture\n                        if (show && currentIndex < times) {\n                            return; // Don't show yet for intermediate captures\n                        }\n                        if (typeof onActionClick === 'function') {\n                            onActionClick('toggleTopBar', show);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(show);\n                        }\n                    },\n                    triggerCameraAccess,\n                    setIsCapturing: (capturing)=>{\n                        // Only set capturing to false after all captures\n                        if (!capturing && currentIndex < times) {\n                            return; // Stay in capturing state between dots\n                        }\n                        setIsCapturing(capturing);\n                    },\n                    captureCount,\n                    setCaptureCount,\n                    postCountdownDelay: 800\n                });\n                if (result && result.success) {\n                    successCount++;\n                    console.log(\"Successfully completed capture \".concat(currentIndex));\n                } else {\n                    console.warn(\"Capture \".concat(currentIndex, \" may have failed:\"), result);\n                }\n                // Wait between captures - but only if there are more captures to go\n                if (currentIndex < times) {\n                    setProcessStatus(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    console.log(\"Waiting \".concat(delay, \"s before next capture...\"));\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n            }\n            // Completion notification\n            setProcessStatus(\"Random capture sequence completed: \".concat(successCount, \"/\").concat(times, \" captures successful\"));\n            setRemainingCaptures(0);\n            console.log(\"Completed all captures: \".concat(successCount, \"/\").concat(times, \" successful\"));\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n        } finally{\n            setIsCapturing(false);\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 3000);\n            const canvas = document.querySelector('#tracking-canvas');\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again\n            setTimeout(()=>{\n                if (typeof onActionClick === 'function') {\n                    onActionClick('toggleTopBar', true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        try {\n            const canvas = ensureCanvasExists();\n            if (!canvas) {\n                console.error('Failed to create canvas for random dot');\n                return;\n            }\n            // Use the consolidated function with random position\n            await handleDotProcess({\n                useRandomPosition: true,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                },\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                triggerCameraAccess,\n                setIsCapturing,\n                captureCount,\n                setCaptureCount: setCaptureCount,\n                postCountdownDelay: 1000\n            });\n        } catch (error) {\n            console.error('Random dot error:', error);\n        } finally{\n            // Clean up canvas after process completes\n            setTimeout(()=>{\n                cleanupCanvas();\n            }, 2000); // Wait 2 seconds before cleanup\n        }\n    };\n    const makeCanvasFullscreen = (canvas)=>{\n        if (!canvas) return null;\n        // Save original state if not already saved\n        if (!canvas._originalState) {\n            canvas._originalState = {\n                parent: canvas.parentElement,\n                position: canvas.style.position,\n                top: canvas.style.top,\n                left: canvas.style.left,\n                width: canvas.style.width,\n                height: canvas.style.height,\n                zIndex: canvas.style.zIndex,\n                canvasWidth: canvas.width,\n                canvasHeight: canvas.height\n            };\n        }\n        // Move to body and make fullscreen\n        document.body.appendChild(canvas);\n        canvas.style.position = 'fixed';\n        canvas.style.top = '0';\n        canvas.style.left = '0';\n        canvas.style.width = '100vw';\n        canvas.style.height = '100vh';\n        canvas.style.zIndex = '10';\n        canvas.style.backgroundColor = 'white';\n        // Set canvas dimensions to match window\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        return canvas;\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        // Clear canvas content\n        const canvas = document.querySelector('#tracking-canvas');\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Restore canvas to container mode\n            restoreCanvasToContainer(canvas);\n        }\n        // Reset states\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n        setCurrentDot(null);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1830,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1829,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1834,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1833,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1865,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1875,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1893,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1906,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1885,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1855,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1840,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1827,\n        columnNumber: 5\n    }, undefined);\n}, \"l311k0juR60uxpHVRV/MyFvStaI=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1928,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3pDO0FBQzZCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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Yzt3Q0FDZFEsUUFBUTtvQ0FDVjs4Q0FDRDs7Ozs7OzhDQUdELDhEQUFDM1E7b0NBQ0NqQyxTQUFTa0k7b0NBQ1RsSCxXQUFVO29DQUNWa0csT0FBTzt3Q0FDTGlELFNBQVM7d0NBQ1R2QixpQkFBaUI7d0NBQ2pCaUssT0FBTzt3Q0FDUGhKLFFBQVE7d0NBQ1J1SSxjQUFjO3dDQUNkUSxRQUFRO29DQUNWOzhDQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNmOztRQWp5RGlCNVQsa0RBQVNBO1FBQ2FDLDREQUFnQkE7OztNQUZqRGtEO0FBbXlETixNQUFNMlEsb0JBQW9CdFUsbURBQU9BLE9BQUMsSUFBTTRQLFFBQVFDLE9BQU8sZUFDckRoUSxpREFBVUEsQ0FBQyxDQUFDMFUsT0FBTzNRLG9CQUFRLDhEQUFDRDtZQUF3QixHQUFHNFEsS0FBSztZQUFFM1EsS0FBS0E7Ozs7O3lCQUNsRTtJQUFFNFEsS0FBSztBQUFNOztBQUNoQixvREFBb0Q7QUFDcEQsb0dBQW9HO0FBRXBHLCtCQUErQjtBQUNoQixTQUFTQztJQUN0QixPQUFPLE1BQU0sOERBQThEO0FBQzdFO01BRndCQTtBQUltQiIsInNvdXJjZXMiOlsiL2FwcC9wYWdlcy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL2NvbXBvbmVudHMtZ3VpL2FjdGlvbkJ1dHRvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCBmb3J3YXJkUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGR5bmFtaWMgZnJvbSAnbmV4dC9keW5hbWljJztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBcbiAgc2hvd0NhcHR1cmVQcmV2aWV3LCBcbiAgZHJhd1JlZERvdCwgXG4gIGdldFJhbmRvbVBvc2l0aW9uLFxuICBjcmVhdGVDb3VudGRvd25FbGVtZW50LFxuICBydW5Db3VudGRvd25cbn0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9jb3VudFNhdmUnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCB7IHVzZUFkbWluU2V0dGluZ3MgfSBmcm9tICcuL2FkbWluU2V0dGluZ3MnO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuLy8gQ3JlYXRlIGEgYmFzaWMgQWN0aW9uQnV0dG9uIGNvbXBvbmVudCB3aXRoIG9wdGltaXphdGlvblxuY29uc3QgQWN0aW9uQnV0dG9uID0gKHsgdGV4dCwgYWJicmV2aWF0ZWRUZXh0LCBvbkNsaWNrLCBjdXN0b21DbGFzcyA9ICcnLCBkaXNhYmxlZCA9IGZhbHNlLCBhY3RpdmUgPSBmYWxzZSB9KSA9PiB7XG4gIGNvbnN0IFtpc0FiYnJldmlhdGVkLCBzZXRJc0FiYnJldmlhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncygpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIHByb3BzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICBjb25zdCBidXR0b25Qcm9wcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjbGFzc05hbWU6IGBhY3Rpb24tYnV0dG9uICR7Y3VzdG9tQ2xhc3N9ICR7aXNBYmJyZXZpYXRlZCA/ICdhYmJyZXZpYXRlZCcgOiAnJ30gJHthY3RpdmUgPyAnYWN0aXZlJyA6ICcnfWAsXG4gICAgb25DbGljayxcbiAgICBkaXNhYmxlZCxcbiAgICB0aXRsZTogdGV4dFxuICB9KSwgW2N1c3RvbUNsYXNzLCBpc0FiYnJldmlhdGVkLCBhY3RpdmUsIG9uQ2xpY2ssIGRpc2FibGVkLCB0ZXh0XSk7XG5cbiAgLy8gQ2hlY2sgd2luZG93IHNpemUgYW5kIHNldCBhYmJyZXZpYXRlZCBtb2RlIHdpdGggZGVib3VuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHNldElzQWJicmV2aWF0ZWQod2lkdGggPCA3NjgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIGhhbmRsZVJlc2l6ZSgpOyAvLyBJbml0aWFsIGNhbGxcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQWRkIGVmZmVjdCB0byBsaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlcyB3aXRoIG9wdGltaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgaWYgKG5ld1VzZXJJZCAhPT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxidXR0b24gey4uLmJ1dHRvblByb3BzfT5cbiAgICAgIHtpc0FiYnJldmlhdGVkID8gYWJicmV2aWF0ZWRUZXh0IDogdGV4dH1cbiAgICAgIHtwcm9jZXNzU3RhdHVzICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9jZXNzLXN0YXR1c1wiPlxuICAgICAgICAgIHtwcm9jZXNzU3RhdHVzfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIEFjdGlvbkJ1dHRvbkdyb3VwIGNvbXBvbmVudCB3aXRoIGNsaWVudC1zaWRlIG9ubHkgcmVuZGVyaW5nIGFuZCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgPSBmb3J3YXJkUmVmKCh7IHRyaWdnZXJDYW1lcmFBY2Nlc3MsIGlzQ29tcGFjdE1vZGUsIG9uQWN0aW9uQ2xpY2sgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncyhyZWYpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGJ1dHRvbiBhY3Rpb25zXG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtjb3VudGRvd25WYWx1ZSwgc2V0Q291bnRkb3duVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50RG90LCBzZXRDdXJyZW50RG90XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FsaWJyYXRpb25Qb2ludHMsIHNldENhbGlicmF0aW9uUG9pbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JlbWFpbmluZ0NhcHR1cmVzLCBzZXRSZW1haW5pbmdDYXB0dXJlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Nob3dDYW52YXMsIHNldFNob3dDYW52YXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIFxuICAvLyBUcmFjayB0aGUgY2FwdHVyZSBjb3VudFxuICBjb25zdCBbY2FsaWJyYXRpb25IYW5kbGVyLCBzZXRDYWxpYnJhdGlvbkhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnQsIHNldENhcHR1cmVDb3VudF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBUb2dnbGUgc3RhdGVzXG4gIGNvbnN0IFtzaG93SGVhZFBvc2UsIHNldFNob3dIZWFkUG9zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93Qm91bmRpbmdCb3gsIHNldFNob3dCb3VuZGluZ0JveF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TWFzaywgc2V0U2hvd01hc2tdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1BhcmFtZXRlcnMsIHNldFNob3dQYXJhbWV0ZXJzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ2FtZXJhQWN0aXZlLCBzZXRJc0NhbWVyYUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGVybWlzc2lvblBvcHVwLCBzZXRTaG93UGVybWlzc2lvblBvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcblxuICAvLyBBZGQgY2FjaGUgZm9yIHNldHRpbmdzXG4gIGNvbnN0IHNldHRpbmdzQ2FjaGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgbGFzdFNldHRpbmdzVXBkYXRlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG5cbiAgXG4gIC8vIE9wdGltaXplIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc2V0dGluZ3MgJiYgY3VycmVudFVzZXJJZCAmJiBzZXR0aW5nc1tjdXJyZW50VXNlcklkXSkge1xuICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbY3VycmVudFVzZXJJZF07XG4gICAgICBjb25zdCBjYWNoZWRTZXR0aW5ncyA9IHNldHRpbmdzQ2FjaGUuY3VycmVudC5nZXQoY3VycmVudFVzZXJJZCk7XG4gICAgICBcbiAgICAgIGlmICghaXNFcXVhbChjYWNoZWRTZXR0aW5ncywgdXNlclNldHRpbmdzKSkge1xuICAgICAgICBzZXRSYW5kb21UaW1lcyhOdW1iZXIodXNlclNldHRpbmdzLnRpbWVzX3NldF9yYW5kb20pIHx8IDEpO1xuICAgICAgICBzZXREZWxheVNlY29uZHMoTnVtYmVyKHVzZXJTZXR0aW5ncy5kZWxheV9zZXRfcmFuZG9tKSB8fCAzKTtcbiAgICAgICAgc2V0dGluZ3NDYWNoZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCB1c2VyU2V0dGluZ3MpO1xuICAgICAgICBsYXN0U2V0dGluZ3NVcGRhdGUuY3VycmVudC5zZXQoY3VycmVudFVzZXJJZCwgRGF0ZS5ub3coKSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc2V0dGluZ3MsIGN1cnJlbnRVc2VySWRdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgc2V0Q3VycmVudFVzZXJJZChuZXdVc2VySWQpO1xuICAgICAgICAvLyBVcGRhdGUgc2V0dGluZ3MgZm9yIG5ldyB1c2VyXG4gICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5nc1tuZXdVc2VySWRdKSB7XG4gICAgICAgICAgY29uc3QgdXNlclNldHRpbmdzID0gc2V0dGluZ3NbbmV3VXNlcklkXTtcbiAgICAgICAgICBzZXRSYW5kb21UaW1lcyhOdW1iZXIodXNlclNldHRpbmdzLnRpbWVzX3NldF9yYW5kb20pIHx8IDEpO1xuICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW3NldHRpbmdzXSk7XG5cbiAgLy8gTGlzdGVuIGZvciBzZXR0aW5ncyB1cGRhdGVzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlU2V0dGluZ3NVcGRhdGUgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwgJiYgZXZlbnQuZGV0YWlsLnR5cGUgPT09ICdjYXB0dXJlU2V0dGluZ3MnKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcklkLCB0aW1lc19zZXRfcmFuZG9tLCBkZWxheV9zZXRfcmFuZG9tIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgIGlmICh1c2VySWQgPT09IGN1cnJlbnRVc2VySWQpIHtcbiAgICAgICAgICBpZiAodGltZXNfc2V0X3JhbmRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdUaW1lcyA9IE51bWJlcih0aW1lc19zZXRfcmFuZG9tKSB8fCAxO1xuICAgICAgICAgICAgc2V0UmFuZG9tVGltZXMobmV3VGltZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVsYXlfc2V0X3JhbmRvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZWxheSA9IE51bWJlcihkZWxheV9zZXRfcmFuZG9tKSB8fCAzO1xuICAgICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKG5ld0RlbGF5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjYXB0dXJlU2V0dGluZ3NVcGRhdGUnLCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE1ha2UgZnVuY3Rpb25zIGdsb2JhbGx5IGFjY2Vzc2libGUgYXMgYSBmYWxsYmFja1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucyA9IHtcbiAgICAgICAgaGFuZGxlUmFuZG9tRG90LFxuICAgICAgICBoYW5kbGVTZXRSYW5kb20sXG4gICAgICAgIGhhbmRsZVNldENhbGlicmF0ZSxcbiAgICAgICAgaGFuZGxlQ2xlYXJBbGxcbiAgICAgIH07XG4gICAgICAvLyBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbiBmdW5jdGlvbnMgZXhwb3NlZCB0byB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnM7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIE9ubHkgaW5pdGlhbGl6ZSBpZiBjYW52YXMgZG9lc24ndCBleGlzdFxuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBjb25zb2xlLmxvZygnQ2FudmFzIGluaXRpYWxpemVkOicsIGNhbnZhcyA/ICdzdWNjZXNzJyA6ICdmYWlsZWQnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2xlYW51cCBmdW5jdGlvblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBEb24ndCByZW1vdmUgY2FudmFzIG9uIGNsZWFudXAgdG8gcHJldmVudCByZWNyZWF0aW9uIGlzc3Vlc1xuICAgICAgY29uc29sZS5sb2coJ0FjdGlvbkJ1dHRvbiBjbGVhbnVwIC0gY2FudmFzIHByZXNlcnZlZCcpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG4gICAgXG4gICAgLy8gRnVuY3Rpb24gdG8gZ2V0IGNvbnRyb2wgdmFsdWVzIGZyb20gVG9wQmFyXG4gICAgY29uc3QgdXBkYXRlQ29udHJvbFZhbHVlcyA9ICgpID0+IHtcbiAgICAgIC8vIEdldCB0aGUgdGltZSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgIGNvbnN0IHRpbWVWYWx1ZSA9IHBhcnNlSW50KHRpbWVJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHRpbWVWYWx1ZSkgJiYgdGltZVZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyByYW5kb21UaW1lcyB0bzonLCB0aW1lVmFsdWUpO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKHRpbWVWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IHRoZSBkZWxheSBpbnB1dCBlbGVtZW50XG4gICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGNvbnN0IGRlbGF5VmFsdWUgPSBwYXJzZUludChkZWxheUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4oZGVsYXlWYWx1ZSkgJiYgZGVsYXlWYWx1ZSA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnVXBkYXRpbmcgZGVsYXlTZWNvbmRzIHRvOicsIGRlbGF5VmFsdWUpO1xuICAgICAgICAgIHNldERlbGF5U2Vjb25kcyhkZWxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgY29udHJvbCBpbnB1dHNcbiAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cImRlbGF5XCJdJyk7XG4gICAgXG4gICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgdGltZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgdGltZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7IC8vIEFsc28gbGlzdGVuIGZvciBpbnB1dCBldmVudHNcbiAgICB9XG4gICAgXG4gICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgIGRlbGF5SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICBkZWxheUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7IC8vIEFsc28gbGlzdGVuIGZvciBpbnB1dCBldmVudHNcbiAgICB9XG4gICAgXG4gICAgLy8gSW5pdGlhbCB1cGRhdGVcbiAgICB1cGRhdGVDb250cm9sVmFsdWVzKCk7XG4gICAgXG4gICAgLy8gQ2xlYW51cCBldmVudCBsaXN0ZW5lcnNcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICB0aW1lSW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICAgIHRpbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgICBkZWxheUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbnRyb2xWYWx1ZXMpO1xuICAgICAgICBkZWxheUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIEluaXRpYWxpemUgY2FudmFzIG9uIGNvbXBvbmVudCBtb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxpemVDYW52YXMgPSAoKSA9PiB7XG4gICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNhbnZhc1xuICAgICAgY29uc3QgZXhpc3RpbmdDYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBpZiAoZXhpc3RpbmdDYW52YXMpIHtcbiAgICAgICAgZXhpc3RpbmdDYW52YXMucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgY2FudmFzXG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICAgIGNhbnZhcy5pZCA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwdnc7XG4gICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICB6LWluZGV4OiA1O1xuICAgICAgYDtcblxuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIC8vIEFkZCBjYW52YXMgdG8gYm9keVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuXG4gICAgICAvLyBTdG9yZSByZWZlcmVuY2VcbiAgICAgIGNhbnZhc1JlZi5jdXJyZW50ID0gY2FudmFzO1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gQWRkIHJlc2l6ZSBoYW5kbGVyXG4gICAgICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcblxuICAgIGNvbnN0IGNsZWFudXAgPSBpbml0aWFsaXplQ2FudmFzKCk7XG4gICAgcmV0dXJuIGNsZWFudXA7XG4gIH0sIFtdKTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBtYWluIGNhbnZhcyAtIGltcHJvdmVkIHRvIGJlIG1vcmUgcmVsaWFibGVcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBoYXZlIGEgdmFsaWQgY2FudmFzIHJlZmVyZW5jZVxuICAgIGlmIChjYW52YXNSZWYuY3VycmVudCAmJiBkb2N1bWVudC5jb250YWlucyhjYW52YXNSZWYuY3VycmVudCkpIHtcbiAgICAgIHJldHVybiBjYW52YXNSZWYuY3VycmVudDtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGZpbmQgZXhpc3RpbmcgY2FudmFzIGluIERPTVxuICAgIGxldCBleGlzdGluZ0NhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKTtcbiAgICBcbiAgICBpZiAoZXhpc3RpbmdDYW52YXMgJiYgZG9jdW1lbnQuY29udGFpbnMoZXhpc3RpbmdDYW52YXMpKSB7XG4gICAgICBjYW52YXNSZWYuY3VycmVudCA9IGV4aXN0aW5nQ2FudmFzO1xuICAgICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gZXhpc3RpbmdDYW52YXM7XG4gICAgICByZXR1cm4gZXhpc3RpbmdDYW52YXM7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5ldyBjYW52YXMgb25seSBpZiBub25lIGV4aXN0c1xuICAgIGNvbnNvbGUubG9nKCdDcmVhdGluZyBuZXcgY2FudmFzLi4uJyk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgIGNhbnZhcy5pZCA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgIFxuICAgIC8vIFNldCBpbml0aWFsIGRpbWVuc2lvbnMgYW5kIHN0eWxlXG4gICAgY2FudmFzLndpZHRoID0gODAwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSA0MDA7XG4gICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICAgIGhlaWdodDogNDAwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcbiAgICAgIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XG4gICAgICBkaXNwbGF5OiBibG9jaztcbiAgICBgO1xuICAgIFxuICAgIC8vIEluaXRpYWxpemUgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgLy8gRmluZCBjb250YWluZXIgYW5kIGFwcGVuZFxuICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4tY29udGVudCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keTtcbiAgICBcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBcbiAgICAvLyBTdG9yZSByZWZlcmVuY2VzXG4gICAgY2FudmFzUmVmLmN1cnJlbnQgPSBjYW52YXM7XG4gICAgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzID0gY2FudmFzO1xuICAgIFxuICAgIHJldHVybiBjYW52YXM7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUGVybWlzc2lvbkFjY2VwdGVkID0gKCkgPT4ge1xuICAgIHNldFNob3dQZXJtaXNzaW9uUG9wdXAoZmFsc2UpO1xuICAgIGlmICh0cmlnZ2VyQ2FtZXJhQWNjZXNzKSB7XG4gICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIYW5kbGVyIHRvIGNhbmNlbCBwZXJtaXNzaW9uIHBvcHVwXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25EZW5pZWQgPSAoKSA9PiB7XG4gICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cChmYWxzZSk7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHJlc3RvcmUgdGhlIGNhbnZhcyB0byBpdHMgb3JpZ2luYWwgcGFyZW50IGFuZCBzdHlsaW5nXG4gIGNvbnN0IHJlc3RvcmVDYW52YXMgPSAoY2FudmFzKSA9PiB7XG4gICAgaWYgKCFjYW52YXMgfHwgIWNhbnZhcy5fb3JpZ2luYWxTdGF0ZSkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IG9yaWdpbmFsID0gY2FudmFzLl9vcmlnaW5hbFN0YXRlO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBSZXN0b3JlIHRvIG9yaWdpbmFsIHBhcmVudFxuICAgICAgaWYgKG9yaWdpbmFsLnBhcmVudCAmJiBkb2N1bWVudC5jb250YWlucyhvcmlnaW5hbC5wYXJlbnQpKSB7XG4gICAgICAgIG9yaWdpbmFsLnBhcmVudC5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gYSBjb250YWluZXIgaWYgb3JpZ2luYWwgcGFyZW50IGlzIGdvbmVcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNhbnZhcy1jb250YWluZXInKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluLWNvbnRlbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgc3R5bGVzXG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBvcmlnaW5hbC5wb3NpdGlvbiB8fCAncmVsYXRpdmUnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IG9yaWdpbmFsLnRvcCB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS5sZWZ0ID0gb3JpZ2luYWwubGVmdCB8fCAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IG9yaWdpbmFsLndpZHRoIHx8ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBvcmlnaW5hbC5oZWlnaHQgfHwgJzQwMHB4JztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSBvcmlnaW5hbC56SW5kZXggfHwgJyc7XG4gICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBkaW1lbnNpb25zXG4gICAgICBjYW52YXMud2lkdGggPSBvcmlnaW5hbC5jYW52YXNXaWR0aCB8fCA4MDA7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gb3JpZ2luYWwuY2FudmFzSGVpZ2h0IHx8IDQwMDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHRoZSBzYXZlZCBzdGF0ZVxuICAgICAgZGVsZXRlIGNhbnZhcy5fb3JpZ2luYWxTdGF0ZTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXN0b3JpbmcgY2FudmFzOicsIGVycm9yKTtcbiAgICAgIC8vIEZhbGxiYWNrOiBqdXN0IGNsZWFyIHRoZSBjYW52YXNcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gIH07XG5cblxuICAvLyBDbGVhciB0aGUgY2FudmFzXG4gIGNvbnN0IGNsZWFyQ2FudmFzID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgY29uc29sZS53YXJuKFwiTm8gY2FudmFzIGZvdW5kIGZvciBjbGVhcmluZ1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIHNldEN1cnJlbnREb3QobnVsbCk7XG4gIH07XG4gIC8vIEFkZCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGlvbkJ1dHRvbi5qc1xuXG4gIC8qKlxuICAgKiBDb25zb2xpZGF0ZWQgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIHRoZSBlbnRpcmUgZG90IHByb2Nlc3M6IGRyYXdpbmcsIGNvdW50ZG93biwgY2FwdHVyZSwgYW5kIHByZXZpZXdcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMucG9zaXRpb24gLSB7eCwgeX0gY29vcmRpbmF0ZXMgd2hlcmUgdG8gZHJhdyB0aGUgZG90XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMub25TdGF0dXNVcGRhdGUgLSBDYWxsYmFjayBmb3Igc3RhdHVzIHVwZGF0ZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9ucy50b2dnbGVUb3BCYXIgLSBGdW5jdGlvbiB0byB0b2dnbGUgdG9wIGJhciB2aXNpYmlsaXR5XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMudHJpZ2dlckNhbWVyYUFjY2VzcyAtIEZ1bmN0aW9uIHRvIGVuc3VyZSBjYW1lcmEgaXMgYXZhaWxhYmxlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2V0SXNDYXB0dXJpbmcgLSBGdW5jdGlvbiB0byB1cGRhdGUgY2FwdHVyaW5nIHN0YXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLmNhcHR1cmVDb3VudCAtIEN1cnJlbnQgY2FwdHVyZSBjb3VudGVyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbnMuc2V0Q2FwdHVyZUNvdW50IC0gRnVuY3Rpb24gdG8gdXBkYXRlIHRoZSBjYXB0dXJlIGNvdW50ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnVzZVJhbmRvbVBvc2l0aW9uIC0gV2hldGhlciB0byBnZW5lcmF0ZSBhIHJhbmRvbSBwb3NpdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIFJlc3VsdCBvYmplY3Qgd2l0aCBjYXB0dXJlIGRhdGFcbiAgICovXG5cbiAgLy8gQWRkIGEgY2VudHJhbGl6ZWQgY2FudmFzIGNvbmZpZ3VyYXRpb24gc3lzdGVtXG4gIGNvbnN0IENBTlZBU19DT05GSUcgPSB7XG4gICAgLy8gRGVmYXVsdCBkaW1lbnNpb25zXG4gICAgZGVmYXVsdFdpZHRoOiA4MDAsXG4gICAgZGVmYXVsdEhlaWdodDogNDAwLFxuICAgIFxuICAgIC8vIFJlc3BvbnNpdmUgYnJlYWtwb2ludHNcbiAgICBicmVha3BvaW50czoge1xuICAgICAgbW9iaWxlOiB7IG1heFdpZHRoOiA3NjgsIGhlaWdodDogMzAwIH0sXG4gICAgICB0YWJsZXQ6IHsgbWF4V2lkdGg6IDEwMjQsIGhlaWdodDogNDAwIH0sXG4gICAgICBkZXNrdG9wOiB7IG1pbldpZHRoOiAxMDI1LCBoZWlnaHQ6IDUwMCB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBDYW52YXMgbW9kZXNcbiAgICBtb2Rlczoge1xuICAgICAgY29udGFpbmVyOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICc0MDBweCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkICNjY2MnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICB6SW5kZXg6ICdhdXRvJyxcbiAgICAgICAgb3BhY2l0eTogJzEnLFxuICAgICAgICBwb2ludGVyRXZlbnRzOiAnYXV0bydcbiAgICAgIH0sXG4gICAgICBmdWxsc2NyZWVuOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICB3aWR0aDogJzEwMHZ3JyxcbiAgICAgICAgaGVpZ2h0OiAnMTAwdmgnLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxuICAgICAgICB6SW5kZXg6ICc5OTk5OScsXG4gICAgICAgIG9wYWNpdHk6ICcxJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ2F1dG8nLFxuICAgICAgICBtYXJnaW46ICcwJyxcbiAgICAgICAgcGFkZGluZzogJzAnLFxuICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94J1xuICAgICAgfSxcbiAgICAgIG92ZXJsYXk6IHtcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgIHdpZHRoOiAnMTAwdncnLFxuICAgICAgICBoZWlnaHQ6ICcxMDB2aCcsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSknLFxuICAgICAgICBib3JkZXI6ICdub25lJyxcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgekluZGV4OiAnOTk5OScsXG4gICAgICAgIG9wYWNpdHk6ICcxJyxcbiAgICAgICAgcG9pbnRlckV2ZW50czogJ2F1dG8nXG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBBbmltYXRpb24gc2V0dGluZ3NcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICB0cmFuc2l0aW9uOiAnYWxsIDAuM3MgZWFzZS1pbi1vdXQnLFxuICAgICAgZmFkZUluOiAnb3BhY2l0eSAwLjNzIGVhc2UtaW4nLFxuICAgICAgZmFkZU91dDogJ29wYWNpdHkgMC4zcyBlYXNlLW91dCdcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2FudmFzIG1hbmFnZXIgY2xhc3MgZm9yIGJldHRlciBvcmdhbml6YXRpb25cbiAgY2xhc3MgQ2FudmFzTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN1cnJlbnRNb2RlID0gJ2NvbnRhaW5lcic7XG4gICAgICB0aGlzLm9yaWdpbmFsU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLmNvbmZpZyA9IENBTlZBU19DT05GSUc7XG4gICAgfVxuXG4gICAgLy8gR2V0IHJlc3BvbnNpdmUgZGltZW5zaW9ucyBiYXNlZCBvbiBzY3JlZW4gc2l6ZVxuICAgIGdldFJlc3BvbnNpdmVEaW1lbnNpb25zKCkge1xuICAgICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIFxuICAgICAgaWYgKHdpZHRoIDw9IHRoaXMuY29uZmlnLmJyZWFrcG9pbnRzLm1vYmlsZS5tYXhXaWR0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29uZmlnLmJyZWFrcG9pbnRzLm1vYmlsZS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAod2lkdGggPD0gdGhpcy5jb25maWcuYnJlYWtwb2ludHMudGFibGV0Lm1heFdpZHRoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogdGhpcy5jb25maWcuYnJlYWtwb2ludHMudGFibGV0LmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbmZpZy5icmVha3BvaW50cy5kZXNrdG9wLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvciBnZXQgY2FudmFzIHdpdGggcHJvcGVyIGluaXRpYWxpemF0aW9uXG4gICAgY3JlYXRlQ2FudmFzKCkge1xuICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN0cmFja2luZy1jYW52YXMnKTtcbiAgICAgIFxuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSAndHJhY2tpbmctY2FudmFzJztcbiAgICAgICAgY2FudmFzLmlkID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgaW5pdGlhbCByZXNwb25zaXZlIGRpbWVuc2lvbnNcbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZ2V0UmVzcG9uc2l2ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gQXBwbHkgY29udGFpbmVyIG1vZGUgc3R5bGVzXG4gICAgICAgIHRoaXMuYXBwbHlNb2RlKGNhbnZhcywgJ2NvbnRhaW5lcicpO1xuICAgICAgICBcbiAgICAgICAgLy8gRmluZCBhcHByb3ByaWF0ZSBjb250YWluZXJcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5maW5kQ29udGFpbmVyKCk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcyhjYW52YXMpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYENhbnZhcyBjcmVhdGVkIHdpdGggZGltZW5zaW9uczogJHtkaW1lbnNpb25zLndpZHRofXgke2RpbWVuc2lvbnMuaGVpZ2h0fWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgLy8gRmluZCB0aGUgYmVzdCBjb250YWluZXIgZm9yIHRoZSBjYW52YXNcbiAgICBmaW5kQ29udGFpbmVyKCkge1xuICAgICAgY29uc3QgY29udGFpbmVycyA9IFtcbiAgICAgICAgJy5jYW52YXMtY29udGFpbmVyJyxcbiAgICAgICAgJy5tYWluLWNvbnRlbnQnLFxuICAgICAgICAnLnByZXZpZXctYXJlYScsXG4gICAgICAgICdib2R5J1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBjb250YWluZXJzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICAvLyBBcHBseSBhIHNwZWNpZmljIG1vZGUgdG8gdGhlIGNhbnZhc1xuICAgIGFwcGx5TW9kZShjYW52YXMsIG1vZGUpIHtcbiAgICAgIGlmICghY2FudmFzIHx8ICF0aGlzLmNvbmZpZy5tb2Rlc1ttb2RlXSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgY2FudmFzIG9yIG1vZGU6ICR7bW9kZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBtb2RlQ29uZmlnID0gdGhpcy5jb25maWcubW9kZXNbbW9kZV07XG4gICAgICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgYWxsIG1vZGUgcHJvcGVydGllc1xuICAgICAgT2JqZWN0LmVudHJpZXMobW9kZUNvbmZpZykuZm9yRWFjaCgoW3Byb3BlcnR5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gQWRkIHRyYW5zaXRpb24gZm9yIHNtb290aCBtb2RlIGNoYW5nZXNcbiAgICAgIHN0eWxlLnRyYW5zaXRpb24gPSB0aGlzLmNvbmZpZy5hbmltYXRpb25zLnRyYW5zaXRpb247XG4gICAgICBcbiAgICAgIHRoaXMuY3VycmVudE1vZGUgPSBtb2RlO1xuICAgICAgY29uc29sZS5sb2coYENhbnZhcyBtb2RlIGNoYW5nZWQgdG86ICR7bW9kZX1gKTtcbiAgICB9XG5cbiAgICAvLyBTd2l0Y2ggY2FudmFzIHRvIGZ1bGxzY3JlZW4gbW9kZVxuICAgIHN3aXRjaFRvRnVsbHNjcmVlbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2F2ZSBvcmlnaW5hbCBzdGF0ZSBpZiBub3QgYWxyZWFkeSBzYXZlZFxuICAgICAgaWYgKCF0aGlzLm9yaWdpbmFsU3RhdGUpIHtcbiAgICAgICAgdGhpcy5zYXZlT3JpZ2luYWxTdGF0ZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBNb3ZlIHRvIGJvZHkgZm9yIGZ1bGxzY3JlZW5cbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgXG4gICAgICAvLyBBcHBseSBmdWxsc2NyZWVuIG1vZGVcbiAgICAgIHRoaXMuYXBwbHlNb2RlKHRoaXMuY2FudmFzLCAnZnVsbHNjcmVlbicpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgZGltZW5zaW9ucyB0byBtYXRjaCB3aW5kb3dcbiAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSB0aGlzLmdldFJlc3BvbnNpdmVEaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgYW5kIHJlZHJhd1xuICAgICAgdGhpcy5jbGVhckNhbnZhcyh0aGlzLmNhbnZhcyk7XG4gICAgICBcbiAgICAgIC8vIEhpZGUgVUkgZWxlbWVudHNcbiAgICAgIHRoaXMuaGlkZVVJRWxlbWVudHMoKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IHVwIHJlc2l6ZSBvYnNlcnZlclxuICAgICAgdGhpcy5zZXR1cFJlc2l6ZU9ic2VydmVyKCk7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBjYW52YXMgdG8gY29udGFpbmVyIG1vZGVcbiAgICByZXN0b3JlVG9Db250YWluZXIoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSByZXR1cm47XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSByZXNpemUgb2JzZXJ2ZXJcbiAgICAgIHRoaXMucmVtb3ZlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICAgIFxuICAgICAgLy8gU2hvdyBVSSBlbGVtZW50c1xuICAgICAgdGhpcy5zaG93VUlFbGVtZW50cygpO1xuICAgICAgXG4gICAgICAvLyBGaW5kIGNvbnRhaW5lciBhbmQgbW92ZSBjYW52YXNcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZmluZENvbnRhaW5lcigpO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gQXBwbHkgY29udGFpbmVyIG1vZGVcbiAgICAgIHRoaXMuYXBwbHlNb2RlKHRoaXMuY2FudmFzLCAnY29udGFpbmVyJyk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBkaW1lbnNpb25zIGJhc2VkIG9uIGNvbnRhaW5lclxuICAgICAgY29uc3QgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gY29udGFpbmVyUmVjdC53aWR0aCB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBjb250YWluZXJSZWN0LmhlaWdodCB8fCB0aGlzLmNvbmZpZy5kZWZhdWx0SGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBDbGVhciBhbmQgcmVkcmF3XG4gICAgICB0aGlzLmNsZWFyQ2FudmFzKHRoaXMuY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBzdGF0ZSBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh0aGlzLm9yaWdpbmFsU3RhdGUpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNhdmUgb3JpZ2luYWwgY2FudmFzIHN0YXRlXG4gICAgc2F2ZU9yaWdpbmFsU3RhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzKSByZXR1cm47XG4gICAgICBcbiAgICAgIHRoaXMub3JpZ2luYWxTdGF0ZSA9IHtcbiAgICAgICAgcGFyZW50OiB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50LFxuICAgICAgICB3aWR0aDogdGhpcy5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5jYW52YXMuaGVpZ2h0LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgICB0b3A6IHRoaXMuY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgICBsZWZ0OiB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICAgIHdpZHRoOiB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgICB6SW5kZXg6IHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvclxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgY2FudmFzIHN0YXRlXG4gICAgcmVzdG9yZU9yaWdpbmFsU3RhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuY2FudmFzIHx8ICF0aGlzLm9yaWdpbmFsU3RhdGUpIHJldHVybjtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gUmVzdG9yZSBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5vcmlnaW5hbFN0YXRlLndpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLm9yaWdpbmFsU3RhdGUuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzdG9yZSBzdHlsZXNcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcmlnaW5hbFN0YXRlLnN0eWxlKS5mb3JFYWNoKChbcHJvcGVydHksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIHNhdmVkIHN0YXRlXG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGF0ZSA9IG51bGw7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZXN0b3JpbmcgY2FudmFzIHN0YXRlOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY2xlYXJDYW52YXMoY2FudmFzKSB7XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLy8gSGlkZSBVSSBlbGVtZW50cyBkdXJpbmcgZnVsbHNjcmVlblxuICAgIGhpZGVVSUVsZW1lbnRzKCkge1xuICAgICAgY29uc3QgZWxlbWVudHNUb0hpZGUgPSBbXG4gICAgICAgICcudG9wYmFyJyxcbiAgICAgICAgJy5jYW52YXMtY29udGFpbmVyJywgXG4gICAgICAgICcubWFpbi1jb250ZW50JyxcbiAgICAgICAgJy5tZXRyaWNzLXBhbmVsJyxcbiAgICAgICAgJy5kaXNwbGF5LW1ldHJpY3MnLFxuICAgICAgICAnbmF2JyxcbiAgICAgICAgJ2hlYWRlcicsXG4gICAgICAgICcuYnV0dG9uLWdyb3VwcycsXG4gICAgICAgICcuY29udHJvbC1idXR0b25zJ1xuICAgICAgXTtcbiAgICAgIFxuICAgICAgZWxlbWVudHNUb0hpZGUuZm9yRWFjaChzZWxlY3RvciA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC1kaXNwbGF5JywgZWwuc3R5bGUuZGlzcGxheSk7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLWhpZGRlbi1ieS1jYW52YXMnLCAndHJ1ZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaG93IHByZXZpb3VzbHkgaGlkZGVuIFVJIGVsZW1lbnRzXG4gICAgc2hvd1VJRWxlbWVudHMoKSB7XG4gICAgICBjb25zdCBoaWRkZW5FbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWhpZGRlbi1ieS1jYW52YXM9XCJ0cnVlXCJdJyk7XG4gICAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxEaXNwbGF5ID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWRpc3BsYXknKSB8fCAnJztcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLWRpc3BsYXknKTtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWhpZGRlbi1ieS1jYW52YXMnKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCByZXNpemUgb2JzZXJ2ZXIgZm9yIHJlc3BvbnNpdmUgYmVoYXZpb3JcbiAgICBzZXR1cFJlc2l6ZU9ic2VydmVyKCkge1xuICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKGVudHJ5LnRhcmdldCA9PT0gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMuY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gQWxzbyBsaXN0ZW4gZm9yIHdpbmRvdyByZXNpemVcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY2FudmFzIHJlc2l6ZVxuICAgIGhhbmRsZVJlc2l6ZSgpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHJldHVybjtcbiAgICAgIFxuICAgICAgY29uc3QgZGltZW5zaW9ucyA9IHRoaXMuZ2V0UmVzcG9uc2l2ZURpbWVuc2lvbnMoKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIGNhbnZhcyBkaW1lbnNpb25zXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gUmVkcmF3IHdoaXRlIGJhY2tncm91bmRcbiAgICAgIHRoaXMuY2xlYXJDYW52YXModGhpcy5jYW52YXMpO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgQ2FudmFzIHJlc2l6ZWQgdG86ICR7ZGltZW5zaW9ucy53aWR0aH14JHtkaW1lbnNpb25zLmhlaWdodH1gKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgcmVzaXplIG9ic2VydmVyXG4gICAgcmVtb3ZlUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgICBpZiAodGhpcy5yZXNpemVPYnNlcnZlcikge1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLmhhbmRsZVJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIGNhbnZhc1xuICAgIGNsZWFudXAoKSB7XG4gICAgICB0aGlzLnJlbW92ZVJlc2l6ZU9ic2VydmVyKCk7XG4gICAgICBcbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAod2luZG93LndoaXRlU2NyZWVuQ2FudmFzID09PSB0aGlzLmNhbnZhcykge1xuICAgICAgICBkZWxldGUgd2luZG93LndoaXRlU2NyZWVuQ2FudmFzO1xuICAgICAgfVxuICAgICAgXG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLm9yaWdpbmFsU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5jdXJyZW50TW9kZSA9ICdjb250YWluZXInO1xuICAgIH1cblxuICAgIC8vIEdldCBjdXJyZW50IGNhbnZhc1xuICAgIGdldENhbnZhcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcyB8fCB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICBpc0Z1bGxzY3JlZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50TW9kZSA9PT0gJ2Z1bGxzY3JlZW4nO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBnbG9iYWwgY2FudmFzIG1hbmFnZXIgaW5zdGFuY2VcbiAgY29uc3QgY2FudmFzTWFuYWdlciA9IG5ldyBDYW52YXNNYW5hZ2VyKCk7XG5cbiAgLy8gUmVwbGFjZSB0aGUgb2xkIGVuc3VyZUNhbnZhc0V4aXN0cyBmdW5jdGlvbiB3aXRoIHRoZSBuZXcgbWFuYWdlclxuICBjb25zdCBlbnN1cmVDYW52YXNFeGlzdHMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gIH07XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBmdW5jdGlvbnMgdG8gdXNlIHRoZSBuZXcgY2FudmFzIG1hbmFnZXJcbiAgY29uc3QgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyID0gKGNhbnZhcykgPT4ge1xuICAgIGNhbnZhc01hbmFnZXIucmVzdG9yZVRvQ29udGFpbmVyKCk7XG4gIH07XG5cbiAgY29uc3QgY2xlYW51cENhbnZhcyA9ICgpID0+IHtcbiAgICBjYW52YXNNYW5hZ2VyLmNsZWFudXAoKTtcbiAgfTtcbiAgXG4gIC8vIE1vZGlmaWVkIGhhbmRsZURvdFByb2Nlc3MgZnVuY3Rpb24gd2l0aCBpbXByb3ZlZCBkb3QgYW5kIGNvdW50ZG93biBhbGlnbm1lbnRcbiAgLy8gQ29tcGxldGUgaGFuZGxlRG90UHJvY2VzcyBmdW5jdGlvbiB3aXRoIHByb3BlciBjYW52YXMgbWFuYWdlbWVudFxuICBjb25zdCBoYW5kbGVEb3RQcm9jZXNzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgIHNldElzQ2FwdHVyaW5nLFxuICAgICAgY2FwdHVyZUNvdW50LFxuICAgICAgc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgdXNlUmFuZG9tUG9zaXRpb24gPSBmYWxzZSxcbiAgICAgIHBvc3RDb3VudGRvd25EZWxheSA9IDUwMCBcbiAgICB9ID0gb3B0aW9ucztcbiAgICBcbiAgICBsZXQgY2FudmFzID0gbnVsbDtcbiAgICBsZXQga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IG51bGw7XG4gICAgbGV0IGNvdW50ZG93bkVsZW1lbnQgPSBudWxsO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHNob3dpbmcgdGhlIGRvdFxuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZVxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSBzdGF0dXNcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiB1c2VSYW5kb21Qb3NpdGlvbiA/ICdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nIDogJ1N0YXJ0aW5nIGRvdCBwcm9jZXNzLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjAwKSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBjYW52YXMgbWFuYWdlciB0byBzd2l0Y2ggdG8gZnVsbHNjcmVlbiBtb2RlXG4gICAgICBjYW52YXNNYW5hZ2VyLnN3aXRjaFRvRnVsbHNjcmVlbigpO1xuICAgICAgY2FudmFzID0gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgb3IgZmluZCBjYW52YXNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgZGltZW5zaW9uc1xuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dCBhbmQgY2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgICAgY29uc3QgZG90UG9zaXRpb24gPSB1c2VSYW5kb21Qb3NpdGlvbiBcbiAgICAgICAgPyBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKSBcbiAgICAgICAgOiBwb3NpdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKCFkb3RQb3NpdGlvbiB8fCB0eXBlb2YgZG90UG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDEyO1xuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSByZWRyYXcgaW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICBrZWVwRG90VmlzaWJsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9LCA1MCk7ICAvLyBNb3JlIGZyZXF1ZW50IHVwZGF0ZXMgZm9yIHJlbGlhYmlsaXR5XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IG9uIHRvcCBvZiB0aGUgZG90XG4gICAgICBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBsZWZ0OiAke2RvdFBvc2l0aW9uLnh9cHg7XG4gICAgICAgIHRvcDogJHtkb3RQb3NpdGlvbi55fXB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICBcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgZG90IGZvciByZWxpYWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGRpdGlvbmFsIHJlZHJhdyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBhZnRlciBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9zdENvdW50ZG93bkRlbGF5KSk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgcG9pbnQ6IGRvdFBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJlIGNvbXBsZXRlZCcsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZVJlc3VsdFxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlRG90UHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgICAgXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbCBmaXJzdFxuICAgICAgaWYgKGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChrZWVwRG90VmlzaWJsZUludGVydmFsKTtcbiAgICAgICAga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgcmVtYWluaW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgcmVtYWluaW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgdG8gcHJvcGVybHkgcmVzdG9yZSBjYW52YXNcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIC8vIERlY2xhcmUgdGhlc2UgdmFyaWFibGVzIE9VVFNJREUgdGhlIHRyeSBibG9ja1xuICAgIGxldCBjYW52YXMgPSBudWxsO1xuICAgIGxldCBvcmlnaW5hbENhbnZhc1BhcmVudCA9IG51bGw7XG4gICAgbGV0IG9yaWdpbmFsQ2FudmFzU3R5bGUgPSB7fTtcbiAgICBsZXQgc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcblxuICAgIHRyeSB7XG4gICAgICBjYW52YXNNYW5hZ2VyLnN3aXRjaFRvRnVsbHNjcmVlbigpO1xuICAgICAgY2FudmFzID0gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY2FudmFzIGZvciBjYWxpYnJhdGlvbicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBIaWRlIFRvcEJhclxuICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhcIlN0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uXCIpO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBVSSB1cGRhdGVzIHRvIHRha2UgZWZmZWN0XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMzAwKSk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgcmVmZXJlbmNlXG4gICAgICBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKFwiRXJyb3I6IENhbnZhcyBub3QgZm91bmRcIik7XG4gICAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHBhcmVudCBhbmQgc3R5bGVcbiAgICAgIG9yaWdpbmFsQ2FudmFzUGFyZW50ID0gY2FudmFzLnBhcmVudEVsZW1lbnQ7XG4gICAgICBvcmlnaW5hbENhbnZhc1N0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gTW92ZSBjYW52YXMgdG8gYm9keSBmb3IgbWF4aW11bSByZWxpYWJpbGl0eVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgXG4gICAgICAvLyBNYWtlIGNhbnZhcyBmdWxsc2NyZWVuIHdpdGggZml4ZWQgcG9zaXRpb25pbmdcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJzAnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICAgIFxuICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93IGV4YWN0bHlcbiAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBDYW52YXMgc2V0IHRvIGZ1bGxzY3JlZW46ICR7Y2FudmFzV2lkdGh9eCR7Y2FudmFzSGVpZ2h0fWApO1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcblxuICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIHRoZSBjYW52YXMgc2l6ZVxuICAgICAgY29uc3QgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJyk7XG4gICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgXG4gICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgIHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgXG4gICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBhbnkgZXhpc3RpbmcgcmVkcmF3IGludGVydmFsXG4gICAgICAgIGlmIChjdXJyZW50UmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgY3VycmVudFJlZHJhd0ludGVydmFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBkaXNwbGF5c1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlc2V0IGNhbnZhcyBpZiBkaW1lbnNpb25zIGNoYW5nZWRcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKGBDYW52YXMgZGltZW5zaW9ucyBjaGFuZ2VkLiBSZXNldHRpbmcgdG8gJHtjYW52YXNXaWR0aH14JHtjYW52YXNIZWlnaHR9YCk7XG4gICAgICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIGNhbnZhcyBpcyBzdGlsbCBhdHRhY2hlZCB0byBib2R5IGFuZCBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICAgICAgaWYgKGNhbnZhcy5wYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnMTAnO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBjb25zdCByYWRpdXMgPSAxNDsgLy8gU2xpZ2h0bHkgbGFyZ2VyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGZ1bmN0aW9uIGZvciB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHJlZHJhd0N1cnJlbnREb3QgPSAoKSA9PiB7XG4gICAgICAgICAgLy8gVmVyaWZ5IGNhbnZhcyBkaW1lbnNpb25zIGFuZCBwYXJlbnRcbiAgICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBNYWtlIHN1cmUgY2FudmFzIGlzIHN0aWxsIGF0dGFjaGVkIHRvIGJvZHlcbiAgICAgICAgICBpZiAoY2FudmFzLnBhcmVudEVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVkcmF3IGRvdCB3aXRob3V0IGNsZWFyaW5nXG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgcmVkcmF3IGludGVydmFsIC0gbW9yZSBmcmVxdWVudCB1cGRhdGVzIGZvciByZWxpYWJsZSBkb3QgdmlzaWJpbGl0eVxuICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChyZWRyYXdDdXJyZW50RG90LCA1MCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7IC8vIENvbnNpc3RlbnQgY2xhc3MgbmFtZVxuICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIGxlZnQ6ICR7cG9pbnQueH1weDtcbiAgICAgICAgICB0b3A6ICR7cG9pbnQueSAtIDYwfXB4O1xuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3IG11bHRpcGxlIHRpbWVzIGR1cmluZyBjb3VudGRvd24gdG8gZW5zdXJlIHZpc2liaWxpdHlcbiAgICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0IHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgIHJlZHJhd0N1cnJlbnREb3QoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgcmVkcmF3Q3VycmVudERvdCgpO1xuXG4gICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFudWFsIGZvcmNlIHJlZHJhdyBvbmUgbW9yZSB0aW1lIGp1c3QgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnQsXG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGN1cnJlbnRSZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgICBjdXJyZW50UmVkcmF3SW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICB9XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgcmVkcmF3IGludGVydmFsXG4gICAgICBpZiAoY3VycmVudFJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY3VycmVudFJlZHJhd0ludGVydmFsKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yICYmIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cENhbnZhcygpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lcihjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjYW52YXNNYW5hZ2VyLnN3aXRjaFRvRnVsbHNjcmVlbigpO1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgY2FudmFzIGZvciBzZXQgcmFuZG9tJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIEFsd2F5cyBnZXQgdGhlIGxhdGVzdCBzZXR0aW5ncyBmcm9tIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHVzZXJcbiAgICAgIGNvbnN0IHVzZXJTZXR0aW5ncyA9IHNldHRpbmdzICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdID8gc2V0dGluZ3NbY3VycmVudFVzZXJJZF0gOiB7fTtcbiAgICAgIGNvbnN0IHRpbWVzID0gTnVtYmVyKHVzZXJTZXR0aW5ncy50aW1lc19zZXRfcmFuZG9tKSB8fCBOdW1iZXIocmFuZG9tVGltZXMpIHx8IDE7XG4gICAgICBjb25zdCBkZWxheSA9IE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgTnVtYmVyKGRlbGF5U2Vjb25kcykgfHwgMztcblxuICAgICAgLy8gTG9nIGN1cnJlbnQgc2V0dGluZ3MgYmVmb3JlIHN0YXJ0aW5nXG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgU2V0IFJhbmRvbSB3aXRoIHNldHRpbmdzOicsIHtcbiAgICAgICAgcmFuZG9tVGltZXMsXG4gICAgICAgIGRlbGF5U2Vjb25kcyxcbiAgICAgICAgY3VycmVudFVzZXJJZCxcbiAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgIHVzZXJTZXR0aW5ncyxcbiAgICAgICAgdGltZXMsXG4gICAgICAgIGRlbGF5XG4gICAgICB9KTtcblxuICAgICAgLy8gSGlkZSBUb3BCYXJcbiAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgU3RhcnRpbmcgJHt0aW1lc30gcmFuZG9tIGNhcHR1cmVzIHdpdGggJHtkZWxheX1zIGRlbGF5Li4uYCk7XG5cbiAgICAgIC8vIFByb2Nlc3MgYWxsIGNhcHR1cmVzIGluIHNlcXVlbmNlXG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgY3VycmVudEluZGV4ID0gMTsgY3VycmVudEluZGV4IDw9IHRpbWVzOyBjdXJyZW50SW5kZXgrKykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZSAke2N1cnJlbnRJbmRleH0gb2YgJHt0aW1lc31gKTtcbiAgICAgICAgc2V0UmVtYWluaW5nQ2FwdHVyZXModGltZXMgLSBjdXJyZW50SW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBjYXB0dXJlICR7Y3VycmVudEluZGV4fSBvZiAke3RpbWVzfWApO1xuICAgICAgICBcbiAgICAgICAgLy8gVXNlIGhhbmRsZURvdFByb2Nlc3MgZm9yIGVhY2ggY2FwdHVyZVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBoYW5kbGVEb3RQcm9jZXNzKHtcbiAgICAgICAgICB1c2VSYW5kb21Qb3NpdGlvbjogdHJ1ZSxcbiAgICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9LyR7dGltZXN9OiAke3N0YXR1cy5wcm9jZXNzU3RhdHVzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICAgICAgLy8gT25seSBzaG93IFRvcEJhciBhZnRlciB0aGUgbGFzdCBjYXB0dXJlXG4gICAgICAgICAgICBpZiAoc2hvdyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHNob3cgeWV0IGZvciBpbnRlcm1lZGlhdGUgY2FwdHVyZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoc2hvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmlnZ2VyQ2FtZXJhQWNjZXNzLFxuICAgICAgICAgIHNldElzQ2FwdHVyaW5nOiAoY2FwdHVyaW5nKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IHNldCBjYXB0dXJpbmcgdG8gZmFsc2UgYWZ0ZXIgYWxsIGNhcHR1cmVzXG4gICAgICAgICAgICBpZiAoIWNhcHR1cmluZyAmJiBjdXJyZW50SW5kZXggPCB0aW1lcykge1xuICAgICAgICAgICAgICByZXR1cm47IC8vIFN0YXkgaW4gY2FwdHVyaW5nIHN0YXRlIGJldHdlZW4gZG90c1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoY2FwdHVyaW5nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgICAgICBzZXRDYXB0dXJlQ291bnQsXG4gICAgICAgICAgcG9zdENvdW50ZG93bkRlbGF5OiA4MDBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgY2FwdHVyZSAke2N1cnJlbnRJbmRleH1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYENhcHR1cmUgJHtjdXJyZW50SW5kZXh9IG1heSBoYXZlIGZhaWxlZDpgLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgLSBidXQgb25seSBpZiB0aGVyZSBhcmUgbW9yZSBjYXB0dXJlcyB0byBnb1xuICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgdGltZXMpIHtcbiAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKGBXYWl0aW5nICR7ZGVsYXl9cyBiZWZvcmUgbmV4dCBjYXB0dXJlLi4uYCk7XG4gICAgICAgICAgY29uc29sZS5sb2coYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBjYXB0dXJlIHNlcXVlbmNlIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGltZXN9IGNhcHR1cmVzIHN1Y2Nlc3NmdWxgKTtcbiAgICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgICAgY29uc29sZS5sb2coYENvbXBsZXRlZCBhbGwgY2FwdHVyZXM6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBzdWNjZXNzZnVsYCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIlJhbmRvbSBzZXF1ZW5jZSBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgUmFuZG9tIHNlcXVlbmNlIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY2xlYW51cENhbnZhcygpO1xuICAgICAgfSwgMzAwMCk7XG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBpZiAoY2FudmFzKSB7XG4gICAgICAgIHJlc3RvcmVDYW52YXNUb0NvbnRhaW5lcihjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IFRvcEJhciBhZ2FpblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmFuZG9tRG90ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGVuc3VyZUNhbnZhc0V4aXN0cygpO1xuICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBjYW52YXMgZm9yIHJhbmRvbSBkb3QnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBVc2UgdGhlIGNvbnNvbGlkYXRlZCBmdW5jdGlvbiB3aXRoIHJhbmRvbSBwb3NpdGlvblxuICAgICAgYXdhaXQgaGFuZGxlRG90UHJvY2Vzcyh7XG4gICAgICAgIHVzZVJhbmRvbVBvc2l0aW9uOiB0cnVlLFxuICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cyhzdGF0dXMucHJvY2Vzc1N0YXR1cyk7XG4gICAgICAgICAgaWYgKHN0YXR1cy5pc0NhcHR1cmluZyAhPT0gdW5kZWZpbmVkKSBzZXRJc0NhcHR1cmluZyhzdGF0dXMuaXNDYXB0dXJpbmcpO1xuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICAgIHNldElzQ2FwdHVyaW5nLFxuICAgICAgICBjYXB0dXJlQ291bnQsXG4gICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50LFxuICAgICAgICBwb3N0Q291bnRkb3duRGVsYXk6IDEwMDBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignUmFuZG9tIGRvdCBlcnJvcjonLCBlcnJvcik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFuIHVwIGNhbnZhcyBhZnRlciBwcm9jZXNzIGNvbXBsZXRlc1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNsZWFudXBDYW52YXMoKTtcbiAgICAgIH0sIDIwMDApOyAvLyBXYWl0IDIgc2Vjb25kcyBiZWZvcmUgY2xlYW51cFxuICAgIH1cbiAgICBcbiAgfTtcbiAgY29uc3QgbWFrZUNhbnZhc0Z1bGxzY3JlZW4gPSAoY2FudmFzKSA9PiB7XG4gICAgaWYgKCFjYW52YXMpIHJldHVybiBudWxsO1xuICAgIFxuICAgIC8vIFNhdmUgb3JpZ2luYWwgc3RhdGUgaWYgbm90IGFscmVhZHkgc2F2ZWRcbiAgICBpZiAoIWNhbnZhcy5fb3JpZ2luYWxTdGF0ZSkge1xuICAgICAgY2FudmFzLl9vcmlnaW5hbFN0YXRlID0ge1xuICAgICAgICBwYXJlbnQ6IGNhbnZhcy5wYXJlbnRFbGVtZW50LFxuICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGNhbnZhcy5zdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGNhbnZhcy5zdHlsZS5sZWZ0LFxuICAgICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICAgIHpJbmRleDogY2FudmFzLnN0eWxlLnpJbmRleCxcbiAgICAgICAgY2FudmFzV2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgY2FudmFzSGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBNb3ZlIHRvIGJvZHkgYW5kIG1ha2UgZnVsbHNjcmVlblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIGNhbnZhcy5zdHlsZS50b3AgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnMCc7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJzEwJztcbiAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcbiAgICBcbiAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gbWF0Y2ggd2luZG93XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBcbiAgICAvLyBDbGVhciB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBcbiAgICByZXR1cm4gY2FudmFzO1xuICB9O1xuICBcblxuICAvLyBMb2FkIGNhbGlicmF0aW9uIHNldHVwXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBjb25zdCBzZXR1cENhbGlicmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBDYWxpYnJhdGVIYW5kbGVyIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlcicpO1xuICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHNldHVwQ2FsaWJyYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBtYWtlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXMgc2l6ZTonLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgY2FsaWJyYXRpb24gcG9pbnRzOicsIHBvaW50cyk7XG4gICAgICAgIHNldENhbGlicmF0aW9uUG9pbnRzKHBvaW50cyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbGlicmF0ZUhhbmRsZXIgPSBuZXcgQ2FsaWJyYXRlSGFuZGxlcih7XG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIGNhbGlicmF0aW9uUG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4gb25BY3Rpb25DbGljaz8uKCd0b2dnbGVUb3BCYXInLCBzaG93KSxcbiAgICAgICAgICBzZXRPdXRwdXRUZXh0OiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnRlcjogY2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyOiAobmV3Q291bnRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdDb3VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudChwcmV2ID0+IG5ld0NvdW50ZXIocHJldikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KG5ld0NvdW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUZvbGRlcjogJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25IYW5kbGVyKHtcbiAgICAgICAgICBoYW5kbGVBY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24uLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGlicmF0ZUhhbmRsZXIuc3RhcnRDYWxpYnJhdGlvbigpO1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICByZXN0b3JlQ2FudmFzU2l6ZShjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNhbGlicmF0aW9uOicsIGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldHVwQ2FsaWJyYXRpb24oKTtcbiAgfSwgW2NhcHR1cmVDb3VudCwgb25BY3Rpb25DbGlja10pO1xuICBcbiAgLy8gQ2xlYXIgQWxsIEJ1dHRvbiAtIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgY29uc3QgaGFuZGxlQ2xlYXJBbGwgPSAoKSA9PiB7XG4gICAgLy8gQ2xlYXIgY2FudmFzIGNvbnRlbnRcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIGNhbnZhcyB0byBjb250YWluZXIgbW9kZVxuICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IHN0YXRlc1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgIHNldEN1cnJlbnREb3QobnVsbCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEhlYWQgUG9zZSB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUhlYWRQb3NlID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0hlYWRQb3NlU3RhdGUgPSAhc2hvd0hlYWRQb3NlO1xuICAgIHNldFNob3dIZWFkUG9zZShuZXdIZWFkUG9zZVN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBIZWFkIHBvc2UgdmlzdWFsaXphdGlvbiAke25ld0hlYWRQb3NlU3RhdGUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdoZWFkUG9zZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dIZWFkUG9zZTogbmV3SGVhZFBvc2VTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGhlYWQgcG9zZTogJHtuZXdIZWFkUG9zZVN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgQm91bmRpbmcgQm94IHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3ggPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Qm91bmRpbmdCb3hTdGF0ZSA9ICFzaG93Qm91bmRpbmdCb3g7XG4gICAgc2V0U2hvd0JvdW5kaW5nQm94KG5ld0JvdW5kaW5nQm94U3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYEJvdW5kaW5nIGJveCAke25ld0JvdW5kaW5nQm94U3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ2JvdW5kaW5nQm94Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd0JvdW5kaW5nQm94OiBuZXdCb3VuZGluZ0JveFN0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgYm91bmRpbmcgYm94OiAke25ld0JvdW5kaW5nQm94U3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBNYXNrIHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlTWFzayA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdNYXNrU3RhdGUgPSAhc2hvd01hc2s7XG4gICAgc2V0U2hvd01hc2sobmV3TWFza1N0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBNYXNrICR7bmV3TWFza1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdtYXNrJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd01hc2s6IG5ld01hc2tTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIG1hc2s6ICR7bmV3TWFza1N0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgUGFyYW1ldGVycyBkaXNwbGF5XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3UGFyYW1ldGVyc1N0YXRlID0gIXNob3dQYXJhbWV0ZXJzO1xuICAgIHNldFNob3dQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnNTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgUGFyYW1ldGVycyAke25ld1BhcmFtZXRlcnNTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygncGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dQYXJhbWV0ZXJzOiBuZXdQYXJhbWV0ZXJzU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBwYXJhbWV0ZXJzOiAke25ld1BhcmFtZXRlcnNTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIGNhbWVyYSBwcmV2aWV3XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUNhbWVyYSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdDYW1lcmFTdGF0ZSA9ICFpc0NhbWVyYUFjdGl2ZTtcbiAgICBzZXRJc0NhbWVyYUFjdGl2ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgd2l0aCAncHJldmlldycgYWN0aW9uXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3ByZXZpZXcnLCBuZXdDYW1lcmFTdGF0ZSk7IC8vIFBhc3MgdGhlIG5ldyBzdGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgdHJpZ2dlciBpZiBubyBhY3Rpb24gaGFuZGxlclxuICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgdHVybmluZyBvbiBjYW1lcmEsIGVuc3VyZSB3ZSBhcHBseSBjdXJyZW50IHZpc3VhbGl6YXRpb24gc2V0dGluZ3NcbiAgICBpZiAobmV3Q2FtZXJhU3RhdGUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAvLyBXYWl0IGEgc2hvcnQgbW9tZW50IHRvIGVuc3VyZSB0aGUgdmlkZW8gZWxlbWVudCBpcyByZWFkeVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICBzaG93SGVhZFBvc2UsXG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3gsXG4gICAgICAgICAgICBzaG93TWFzayxcbiAgICAgICAgICAgIHNob3dQYXJhbWV0ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFkZCBiYWNrIGJ1dHRvbiBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZUdvQmFjayA9ICgpID0+IHtcbiAgICByb3V0ZXIucHVzaCgnLycpO1xuICB9O1xuXG4gIC8vIE1vYmlsZSBsYXlvdXQgLSAyeDUgZ3JpZFxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICB7aXNDb21wYWN0TW9kZSA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yIG1iLTRcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMlwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cblxuICAgICAgey8qIENhbWVyYSBQZXJtaXNzaW9uIFBvcHVwICovfVxuICAgICAge3Nob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMTVcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWRpYWxvZ1wiIFxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aDMgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDE1cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENhbWVyYSBBY2Nlc3MgUmVxdWlyZWRcbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tbWVzc2FnZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICBnYXA6ICcxMHB4J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7XG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFxuICBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiA8QWN0aW9uQnV0dG9uR3JvdXBJbm5lciB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPilcbiksIHsgc3NyOiBmYWxzZSB9KTtcbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgQWN0aW9uQnV0dG9uR3JvdXBcbi8vIGNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoQWN0aW9uQnV0dG9uR3JvdXBJbm5lciksIHsgc3NyOiBmYWxzZSB9KTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWN0aW9uQnV0dG9uUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59XG5cbmV4cG9ydCB7IEFjdGlvbkJ1dHRvbiwgQWN0aW9uQnV0dG9uR3JvdXAgfTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImR5bmFtaWMiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInJ1bkNvdW50ZG93biIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwidXNlUm91dGVyIiwidXNlQWRtaW5TZXR0aW5ncyIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsIkFjdGlvbkJ1dHRvbiIsInRleHQiLCJhYmJyZXZpYXRlZFRleHQiLCJvbkNsaWNrIiwiY3VzdG9tQ2xhc3MiLCJkaXNhYmxlZCIsImFjdGl2ZSIsImlzQWJicmV2aWF0ZWQiLCJzZXRJc0FiYnJldmlhdGVkIiwic2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJidXR0b25Qcm9wcyIsImNsYXNzTmFtZSIsInRpdGxlIiwidGltZW91dElkIiwiaGFuZGxlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJ0eXBlIiwibmV3VXNlcklkIiwidXNlcklkIiwiYnV0dG9uIiwiZGl2IiwiQWN0aW9uQnV0dG9uR3JvdXBJbm5lciIsInJlZiIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsInJvdXRlciIsInVwZGF0ZVNldHRpbmdzIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbnZhc1JlZiIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJyZW1haW5pbmdDYXB0dXJlcyIsInNldFJlbWFpbmluZ0NhcHR1cmVzIiwic2hvd0NhbnZhcyIsInNldFNob3dDYW52YXMiLCJjYWxpYnJhdGlvbkhhbmRsZXIiLCJzZXRDYWxpYnJhdGlvbkhhbmRsZXIiLCJjYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzaG93SGVhZFBvc2UiLCJzZXRTaG93SGVhZFBvc2UiLCJzaG93Qm91bmRpbmdCb3giLCJzZXRTaG93Qm91bmRpbmdCb3giLCJzaG93TWFzayIsInNldFNob3dNYXNrIiwic2hvd1BhcmFtZXRlcnMiLCJzZXRTaG93UGFyYW1ldGVycyIsImlzQ2FtZXJhQWN0aXZlIiwic2V0SXNDYW1lcmFBY3RpdmUiLCJzaG93UGVybWlzc2lvblBvcHVwIiwic2V0U2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldHRpbmdzQ2FjaGUiLCJNYXAiLCJsYXN0U2V0dGluZ3NVcGRhdGUiLCJ1c2VyU2V0dGluZ3MiLCJjYWNoZWRTZXR0aW5ncyIsImN1cnJlbnQiLCJnZXQiLCJOdW1iZXIiLCJ0aW1lc19zZXRfcmFuZG9tIiwiZGVsYXlfc2V0X3JhbmRvbSIsInNldCIsIkRhdGUiLCJub3ciLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsInVuZGVmaW5lZCIsIm5ld1RpbWVzIiwibmV3RGVsYXkiLCJhY3Rpb25CdXR0b25GdW5jdGlvbnMiLCJoYW5kbGVSYW5kb21Eb3QiLCJoYW5kbGVTZXRSYW5kb20iLCJoYW5kbGVTZXRDYWxpYnJhdGUiLCJoYW5kbGVDbGVhckFsbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNhbnZhcyIsImdldE1haW5DYW52YXMiLCJjb25zb2xlIiwibG9nIiwidXBkYXRlQ29udHJvbFZhbHVlcyIsInRpbWVJbnB1dCIsInRpbWVWYWx1ZSIsInBhcnNlSW50IiwidmFsdWUiLCJpc05hTiIsImRlbGF5SW5wdXQiLCJkZWxheVZhbHVlIiwiaW5pdGlhbGl6ZUNhbnZhcyIsImV4aXN0aW5nQ2FudmFzIiwicmVtb3ZlIiwiY3JlYXRlRWxlbWVudCIsImlkIiwic3R5bGUiLCJjc3NUZXh0IiwiaGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJ3aGl0ZVNjcmVlbkNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNsZWFudXAiLCJjb250YWlucyIsImNvbnRhaW5lciIsImhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCIsImhhbmRsZVBlcm1pc3Npb25EZW5pZWQiLCJyZXN0b3JlQ2FudmFzIiwiX29yaWdpbmFsU3RhdGUiLCJvcmlnaW5hbCIsInBhcmVudCIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInpJbmRleCIsImJhY2tncm91bmRDb2xvciIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiZXJyb3IiLCJjbGVhckNhbnZhcyIsIndhcm4iLCJjbGVhclJlY3QiLCJDQU5WQVNfQ09ORklHIiwiZGVmYXVsdFdpZHRoIiwiZGVmYXVsdEhlaWdodCIsImJyZWFrcG9pbnRzIiwibW9iaWxlIiwibWF4V2lkdGgiLCJ0YWJsZXQiLCJkZXNrdG9wIiwibWluV2lkdGgiLCJtb2RlcyIsImJvcmRlciIsImRpc3BsYXkiLCJvcGFjaXR5IiwicG9pbnRlckV2ZW50cyIsImZ1bGxzY3JlZW4iLCJtYXJnaW4iLCJwYWRkaW5nIiwiYm94U2l6aW5nIiwib3ZlcmxheSIsImFuaW1hdGlvbnMiLCJ0cmFuc2l0aW9uIiwiZmFkZUluIiwiZmFkZU91dCIsIkNhbnZhc01hbmFnZXIiLCJnZXRSZXNwb25zaXZlRGltZW5zaW9ucyIsImNvbmZpZyIsImNyZWF0ZUNhbnZhcyIsImRpbWVuc2lvbnMiLCJhcHBseU1vZGUiLCJmaW5kQ29udGFpbmVyIiwiY29udGFpbmVycyIsInNlbGVjdG9yIiwibW9kZSIsIm1vZGVDb25maWciLCJlbnRyaWVzIiwiZm9yRWFjaCIsInByb3BlcnR5IiwiY3VycmVudE1vZGUiLCJzd2l0Y2hUb0Z1bGxzY3JlZW4iLCJvcmlnaW5hbFN0YXRlIiwic2F2ZU9yaWdpbmFsU3RhdGUiLCJoaWRlVUlFbGVtZW50cyIsInNldHVwUmVzaXplT2JzZXJ2ZXIiLCJyZXN0b3JlVG9Db250YWluZXIiLCJyZW1vdmVSZXNpemVPYnNlcnZlciIsInNob3dVSUVsZW1lbnRzIiwiY29udGFpbmVyUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInJlc3RvcmVPcmlnaW5hbFN0YXRlIiwicGFyZW50RWxlbWVudCIsImVsZW1lbnRzVG9IaWRlIiwiZWxlbWVudHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZWwiLCJzZXRBdHRyaWJ1dGUiLCJoaWRkZW5FbGVtZW50cyIsIm9yaWdpbmFsRGlzcGxheSIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInJlc2l6ZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsIlJlc2l6ZU9ic2VydmVyIiwiZW50cnkiLCJ0YXJnZXQiLCJvYnNlcnZlIiwiYmluZCIsImdldENhbnZhcyIsImlzRnVsbHNjcmVlbiIsImNvbnN0cnVjdG9yIiwiY2FudmFzTWFuYWdlciIsImVuc3VyZUNhbnZhc0V4aXN0cyIsInJlc3RvcmVDYW52YXNUb0NvbnRhaW5lciIsImNsZWFudXBDYW52YXMiLCJoYW5kbGVEb3RQcm9jZXNzIiwib3B0aW9ucyIsIm9uU3RhdHVzVXBkYXRlIiwidG9nZ2xlVG9wQmFyIiwidXNlUmFuZG9tUG9zaXRpb24iLCJwb3N0Q291bnRkb3duRGVsYXkiLCJrZWVwRG90VmlzaWJsZUludGVydmFsIiwiY291bnRkb3duRWxlbWVudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiRXJyb3IiLCJkb3RQb3NpdGlvbiIsIngiLCJ5IiwiZG90UmFkaXVzIiwic2V0SW50ZXJ2YWwiLCJleGlzdGluZ0NvdW50ZG93bnMiLCJjb3VudCIsInRleHRDb250ZW50IiwiY2FwdHVyZVJlc3VsdCIsInBvaW50Iiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJjbGVhckludGVydmFsIiwicmVtYWluaW5nQ291bnRkb3ducyIsIm9yaWdpbmFsQ2FudmFzUGFyZW50Iiwib3JpZ2luYWxDYW52YXNTdHlsZSIsInN0YXR1c0luZGljYXRvciIsImN1cnJlbnRSZWRyYXdJbnRlcnZhbCIsInBvaW50cyIsInN1Y2Nlc3NDb3VudCIsImkiLCJyYWRpdXMiLCJyZWRyYXdDdXJyZW50RG90Iiwic2NyZWVuSW1hZ2UiLCJ0aW1lcyIsImRlbGF5IiwiY3VycmVudEluZGV4IiwicmVzdWx0Iiwic3RhdHVzIiwic2hvdyIsImNhcHR1cmluZyIsIm1ha2VDYW52YXNGdWxsc2NyZWVuIiwic2V0dXBDYWxpYnJhdGlvbiIsImRlZmF1bHQiLCJDYWxpYnJhdGVIYW5kbGVyIiwiY2FsaWJyYXRlSGFuZGxlciIsInNldE91dHB1dFRleHQiLCJuZXdDb3VudGVyIiwicHJldiIsImNhcHR1cmVGb2xkZXIiLCJvbkNvbXBsZXRlIiwiaGFuZGxlQWN0aW9uIiwic3RhcnRDYWxpYnJhdGlvbiIsInJlc3RvcmVDYW52YXNTaXplIiwiZXJyIiwiaGFuZGxlVG9nZ2xlSGVhZFBvc2UiLCJuZXdIZWFkUG9zZVN0YXRlIiwidmlkZW9Qcm9jZXNzb3IiLCJ1cGRhdGVPcHRpb25zIiwiaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3giLCJuZXdCb3VuZGluZ0JveFN0YXRlIiwiaGFuZGxlVG9nZ2xlTWFzayIsIm5ld01hc2tTdGF0ZSIsImhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMiLCJuZXdQYXJhbWV0ZXJzU3RhdGUiLCJoYW5kbGVUb2dnbGVDYW1lcmEiLCJuZXdDYW1lcmFTdGF0ZSIsImhhbmRsZUdvQmFjayIsInB1c2giLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJib3JkZXJSYWRpdXMiLCJib3hTaGFkb3ciLCJoMyIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiY3Vyc29yIiwiY29sb3IiLCJBY3Rpb25CdXR0b25Hcm91cCIsInByb3BzIiwic3NyIiwiQWN0aW9uQnV0dG9uUGFnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});