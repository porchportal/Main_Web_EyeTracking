"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx":
/*!**********************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/countSave.jsx ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calibrationCapture: () => (/* binding */ calibrationCapture),\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// Fixed countSave.jsx - Resolving redrawInterval reference error\n// Shared functionality for countdown and image capture processes\n\n\n/**\n * Get canvas management utilities from global scope (from actionButton.js)\n * @returns {Object} Canvas utilities object\n */ const getCanvasUtils = ()=>{\n    if (true) {\n        return {\n            canvasUtils: window.canvasUtils,\n            canvasManager: window.canvasManager\n        };\n    }\n    return {\n        canvasUtils: null,\n        canvasManager: null\n    };\n};\n/**\n * Get or create canvas using the canvas management system from actionButton.js\n * @returns {HTMLCanvasElement} Canvas element\n */ const getCanvas = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    // First try to use canvasUtils from actionButton.js\n    if (canvasUtils && typeof canvasUtils.getCanvas === 'function') {\n        return canvasUtils.getCanvas();\n    }\n    // Fallback to canvasManager\n    if (canvasManager && typeof canvasManager.getCanvas === 'function') {\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    }\n    // Fallback to direct query\n    return document.querySelector('#tracking-canvas');\n};\n/**\n * Transform canvas coordinates to viewport coordinates when in fullscreen\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Object} point - {x, y} point coordinates\n * @returns {Object} Transformed point coordinates\n */ const transformCoordinates = (canvas, point)=>{\n    if (!canvas || !point) return point;\n    // Check if canvas is in fullscreen mode\n    const isFullscreen = canvas.style.position === 'fixed' && (canvas.style.width === '100vw' || canvas.style.width === '100%');\n    if (isFullscreen) {\n        // Get the canvas's bounding rect to understand its position in the viewport\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate the scale factors\n        const scaleX = canvasRect.width / canvas.width;\n        const scaleY = canvasRect.height / canvas.height;\n        // Transform the coordinates\n        const transformedPoint = {\n            x: point.x * scaleX + canvasRect.left,\n            y: point.y * scaleY + canvasRect.top,\n            label: point.label\n        };\n        console.log('Coordinate transformation in countSave:', {\n            original: point,\n            transformed: transformedPoint,\n            canvasRect,\n            scale: {\n                x: scaleX,\n                y: scaleY\n            }\n        });\n        return transformedPoint;\n    }\n    // If not fullscreen, return original coordinates\n    return point;\n};\n/**\n * Draw dot using the canvas management system\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @returns {boolean} Success status\n */ const drawDotWithCanvasManager = function(x, y) {\n    let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n    const { canvasUtils } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.drawDot === 'function') {\n        return canvasUtils.drawDot(x, y, radius);\n    }\n    // Fallback: manually draw dot\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, x, y, radius, false);\n        return true;\n    }\n    return false;\n};\n/**\n * Clear canvas using the canvas management system\n */ const clearCanvasWithManager = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.clear === 'function') {\n        canvasUtils.clear();\n        return;\n    }\n    if (canvasManager && typeof canvasManager.clear === 'function') {\n        canvasManager.clear();\n        return;\n    }\n    // Fallback: manually clear canvas\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'yellow';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n};\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    // Remove any existing countdown elements\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup, .dot-countdown, .test-countdown');\n    existingCountdowns.forEach((el)=>{\n        console.log('Removing existing countdown element:', el);\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    });\n    // Get canvas to check if we need coordinate transformation\n    const canvas = getCanvas();\n    let displayPosition = position;\n    if (canvas) {\n        // Check if canvas is in fullscreen mode\n        const isFullscreen = canvas.style.position === 'fixed' && (canvas.style.width === '100vw' || canvas.style.width === '100%');\n        if (isFullscreen) {\n            // Canvas is in fullscreen mode, use direct coordinates\n            displayPosition = {\n                x: position.x,\n                y: position.y\n            };\n        } else {\n            // Canvas is in normal mode, use canvas-relative coordinates\n            displayPosition = {\n                x: canvasRect.left + position.x,\n                y: canvasRect.top + position.y\n            };\n        }\n    }\n    console.log('[createCountdownElement] Creating countdown at position:', {\n        original: position,\n        display: displayPosition,\n        canvasRect: canvasRect,\n        canvasFullscreen: canvas ? canvas.style.position === 'fixed' && canvas.style.width === '100vw' : false\n    });\n    // Create the main countdown element\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(displayPosition.x, \"px;\\n    top: \").concat(displayPosition.y - 80, \"px;\\n    transform: translateX(-50%);\\n    color: red;\\n    font-size: 64px;\\n    font-weight: bold;\\n    text-shadow: 0 0 20px white, 0 0 30px white, 0 0 40px white;\\n    z-index: 100000;\\n    background-color: rgba(255, 255, 255, 0.98);\\n    border: 4px solid red;\\n    border-radius: 50%;\\n    width: 100px;\\n    height: 100px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 30px rgba(0, 0, 0, 0.7), 0 0 50px rgba(255, 0, 0, 0.5);\\n    animation: countdownPulse 1s infinite;\\n    pointer-events: none;\\n    user-select: none;\\n  \");\n    // Add CSS animation for pulse effect\n    if (!document.querySelector('#countdown-styles')) {\n        const style = document.createElement('style');\n        style.id = 'countdown-styles';\n        style.textContent = \"\\n      @keyframes countdownPulse {\\n        0% { transform: translateX(-50%) scale(1); }\\n        50% { transform: translateX(-50%) scale(1.1); }\\n        100% { transform: translateX(-50%) scale(1); }\\n      }\\n    \";\n        document.head.appendChild(style);\n    }\n    document.body.appendChild(countdownElement);\n    console.log('createCountdownElement created at:', {\n        originalPosition: position,\n        displayPosition,\n        canvasRect,\n        canvasInfo: canvas ? {\n            position: canvas.style.position,\n            width: canvas.style.width,\n            height: canvas.style.height,\n            rect: canvas.getBoundingClientRect()\n        } : null\n    });\n    // Create a backup countdown element centered on screen as fallback\n    const backupCountdown = document.createElement('div');\n    backupCountdown.className = 'backup-countdown';\n    backupCountdown.style.cssText = \"\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    color: red;\\n    font-size: 72px;\\n    font-weight: bold;\\n    text-shadow: 0 0 25px white, 0 0 35px white, 0 0 45px white;\\n    z-index: 100001;\\n    background-color: rgba(255, 255, 255, 0.98);\\n    border: 5px solid red;\\n    border-radius: 50%;\\n    width: 120px;\\n    height: 120px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 40px rgba(0, 0, 0, 0.8), 0 0 60px rgba(255, 0, 0, 0.6);\\n    animation: countdownPulse 1s infinite;\\n    pointer-events: none;\\n    user-select: none;\\n  \";\n    document.body.appendChild(backupCountdown);\n    // Add a temporary visual indicator to show where the countdown is positioned\n    const indicator = document.createElement('div');\n    indicator.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(displayPosition.x, \"px;\\n    top: \").concat(displayPosition.y, \"px;\\n    width: 10px;\\n    height: 10px;\\n    background-color: blue;\\n    border-radius: 50%;\\n    z-index: 10000;\\n    pointer-events: none;\\n  \");\n    document.body.appendChild(indicator);\n    // Remove indicator after 2 seconds\n    setTimeout(()=>{\n        if (indicator.parentNode) {\n            indicator.parentNode.removeChild(indicator);\n        }\n    }, 2000);\n    return countdownElement;\n};\n/**\n * Display a preview of the captured images\n * @param {string} screenImage - Data URL of the screen image\n * @param {string} webcamImage - Data URL of the webcam image\n * @param {Object} point - {x, y} position of the dot\n */ const showCapturePreview = (screenImage, webcamImage, point)=>{\n    if (!screenImage && !webcamImage) return;\n    // Remove any existing previews\n    const existingPreviews = document.querySelectorAll('.capture-preview-container');\n    existingPreviews.forEach((preview)=>{\n        if (preview.parentNode) {\n            preview.parentNode.removeChild(preview);\n        }\n    });\n    // Create preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    display: flex;\\n    gap: 20px;\\n    background-color: rgba(0, 0, 0, 0.85);\\n    padding: 20px;\\n    border-radius: 12px;\\n    z-index: 999999;\\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n  \";\n    // Add screen image if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.alt = 'Screen Capture';\n        screenImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam image if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.alt = 'Webcam Capture';\n        webcamImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add point info\n    if (point) {\n        const pointInfo = document.createElement('div');\n        pointInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Point: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n        pointInfo.style.cssText = \"\\n      color: #ffcc00;\\n      font-size: 14px;\\n      position: absolute;\\n      top: -40px;\\n      left: 0;\\n      width: 100%;\\n      text-align: center;\\n    \";\n        previewContainer.appendChild(pointInfo);\n    }\n    // Add timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n    position: absolute;\\n    bottom: -25px;\\n    right: 20px;\\n    color: white;\\n    font-size: 12px;\\n    background-color: rgba(0, 0, 0, 0.7);\\n    padding: 3px 8px;\\n    border-radius: 4px;\\n  \";\n    previewContainer.appendChild(timerElement);\n    // Add to document\n    document.body.appendChild(previewContainer);\n    // Countdown\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            previewContainer.style.opacity = '0';\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    // Use canvas management system to draw dot\n    drawDotWithCanvasManager(position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    // Create redrawInterval for keeping dot visible during countdown\n    let redrawInterval = setInterval(()=>{\n        drawDotWithCanvasManager(position.x, position.y);\n    }, 200);\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    drawDotWithCanvasManager(position.x, position.y);\n                    // Clear the redrawInterval we defined above\n                    if (redrawInterval) {\n                        clearInterval(redrawInterval);\n                    }\n                    if (onComplete) {\n                        drawDotWithCanvasManager(position.x, position.y);\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n * Draw a red dot on the canvas (legacy function for backward compatibility)\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n * @returns {Object} - {x, y} position\n */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'yellow';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    console.log(\"Drew red dot at (\".concat(x, \", \").concat(y, \") with radius \").concat(radius));\n    return {\n        x,\n        y\n    };\n};\n/**\n * Get highest resolution camera constraints\n * @returns {Promise<Object>} - Camera constraints\n */ const getHighestResolutionConstraints = async ()=>{\n    try {\n        // Get all video input devices\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const videoDevices = devices.filter((device)=>device.kind === 'videoinput');\n        if (videoDevices.length === 0) {\n            console.warn('No video devices found, using default constraints');\n            return {\n                video: true\n            };\n        }\n        // Try to get capabilities for the first video device\n        const stream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        const videoTrack = stream.getVideoTracks()[0];\n        if (!videoTrack.getCapabilities) {\n            console.warn('getCapabilities not supported, using default constraints');\n            stream.getTracks().forEach((track)=>track.stop());\n            return {\n                video: true\n            };\n        }\n        const capabilities = videoTrack.getCapabilities();\n        stream.getTracks().forEach((track)=>track.stop());\n        if (!capabilities.width || !capabilities.height) {\n            console.warn('No width/height capabilities, using default constraints');\n            return {\n                video: true\n            };\n        }\n        // Get the highest resolution available\n        const maxWidth = Math.max(...capabilities.width.values);\n        const maxHeight = Math.max(...capabilities.height.values);\n        console.log(\"Using highest resolution: \".concat(maxWidth, \"x\").concat(maxHeight));\n        return {\n            video: {\n                width: {\n                    ideal: maxWidth\n                },\n                height: {\n                    ideal: maxHeight\n                },\n                frameRate: {\n                    ideal: 30\n                }\n            }\n        };\n    } catch (error) {\n        console.warn('Error getting camera constraints, using default:', error);\n        return {\n            video: true\n        };\n    }\n};\n/**\n * Capture images at a specific point\n * @param {Object} options - Capture options\n * @returns {Promise} - Promise that resolves with the capture result\n */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[captureImages] Invalid position object:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid capture position');\n        return null;\n    }\n    try {\n        // Get highest resolution constraints\n        const constraints = await getHighestResolutionConstraints();\n        console.log('Using camera constraints:', constraints);\n        // Get a new stream with the highest resolution\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        const videoTrack = stream.getVideoTracks()[0];\n        const settings = videoTrack.getSettings();\n        console.log('Actual camera settings:', settings);\n        // Update video element with new stream\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            videoElement.srcObject = stream;\n            await videoElement.play();\n        }\n        // Call the captureImagesAtPoint with all necessary parameters\n        const result = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        console.log('Capture successful with ID:', result.captureId);\n        // Clean up the stream\n        stream.getTracks().forEach((track)=>track.stop());\n        return {\n            screenImage: (result === null || result === void 0 ? void 0 : result.screenImage) || '',\n            webcamImage: (result === null || result === void 0 ? void 0 : result.webcamImage) || '',\n            success: true,\n            captureId: result === null || result === void 0 ? void 0 : result.captureId,\n            resolution: {\n                width: settings.width,\n                height: settings.height\n            }\n        };\n    } catch (err) {\n        console.error('[captureImages] Unexpected error:', err);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: err.message\n        };\n    }\n};\n/**\n * Generate a random dot position within the canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} padding - Padding from the edges\n * @returns {Object} - {x, y} position\n */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n * Special calibration capture function that behaves like random dot capture\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ const calibrationCapture = async (options)=>{\n    const { canvasRef, point, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures', pointIndex, totalPoints } = options;\n    try {\n        console.log(\"Starting calibration capture for point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Get canvas using canvas management system\n        const canvas = getCanvas();\n        if (!canvas) {\n            console.error(\"Canvas reference is null in calibrationCapture\");\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: Canvas not available\");\n            return {\n                success: false\n            };\n        }\n        // Use canvas management system to draw dot\n        drawDotWithCanvasManager(point.x, point.y);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Calibration point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Use the same countdown element creation method\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = createCountdownElement(point, canvasRect);\n        if (!countdownElement) {\n            console.error(\"Failed to create countdown element\");\n            return {\n                success: false\n            };\n        }\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawDotWithCanvasManager(point.x, point.y);\n        }, 200);\n        // Run the same countdown as random dot\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Point \".concat(pointIndex + 1, \"/\").concat(totalPoints, \" - countdown \").concat(count));\n            // Redraw the dot at each step to ensure it remains visible\n            drawDotWithCanvasManager(point.x, point.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show checkmark\n        countdownElement.textContent = \"✓\";\n        // Remove countdown element\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Clear redrawInterval\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureAndPreviewProcess instead of directly calling captureImagesAtPoint\n        const captureResult = await captureAndPreviewProcess({\n            canvasRef,\n            position: point,\n            captureCounter,\n            setCaptureCounter,\n            setProcessStatus: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            captureFolder\n        });\n        // Ensure proper return even if captureResult is null\n        const safeResult = captureResult && typeof captureResult === 'object' ? captureResult : {\n            screenImage: '',\n            webcamImage: '',\n            success: false\n        };\n        return {\n            screenImage: safeResult.screenImage || '',\n            webcamImage: safeResult.webcamImage || '',\n            success: true,\n            point\n        };\n    } catch (error) {\n        console.error(\"Error in calibrationCapture:\", error);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(error.message));\n        // Always return a valid object with default values\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Complete capture and preview process\n * @param {Object} options - Process options\n */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder } = options;\n    try {\n        // Get canvas using canvas management system\n        const canvas = getCanvas();\n        if (!canvas) {\n            console.error(\"[captureAndPreviewProcess] Canvas reference is null\");\n            if (setProcessStatus) setProcessStatus('Error: Canvas is not available');\n            return null;\n        }\n        // Draw the dot using canvas management system\n        drawDotWithCanvasManager(position.x, position.y);\n        // Countdown before capture\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Starting countdown...',\n                isCapturing: true\n            });\n        }\n        // Remove any existing countdown elements first\n        const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .dot-countdown, .forced-countdown, .center-countdown-backup');\n        existingCountdowns.forEach((el)=>{\n            console.log('captureAndPreviewProcess: Removing existing countdown:', el);\n            el.remove();\n        });\n        // Create a custom countdown element\n        const canvasRect = canvas.getBoundingClientRect();\n        // Transform coordinates for fullscreen display\n        let displayPosition = position;\n        if (canvas.style.position === 'fixed' && canvas.style.width === '100vw') {\n            // Canvas is in fullscreen mode, use direct coordinates\n            displayPosition = {\n                x: position.x,\n                y: position.y\n            };\n        } else {\n            // Canvas is in normal mode, use canvas-relative coordinates\n            displayPosition = {\n                x: canvasRect.left + position.x,\n                y: canvasRect.top + position.y\n            };\n        }\n        console.log('captureAndPreviewProcess: Creating countdown at:', {\n            originalPosition: position,\n            displayPosition,\n            canvasRect,\n            canvasStyle: {\n                position: canvas.style.position,\n                width: canvas.style.width,\n                height: canvas.style.height\n            }\n        });\n        const countdownElement = document.createElement('div');\n        countdownElement.className = 'calibrate-countdown';\n        countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(displayPosition.x, \"px;\\n      top: \").concat(displayPosition.y - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 48px;\\n      font-weight: bold;\\n      text-shadow: 0 0 15px white, 0 0 25px white, 0 0 35px white;\\n      z-index: 100000;\\n      background-color: rgba(255, 255, 255, 0.95);\\n      border: 3px solid red;\\n      border-radius: 50%;\\n      width: 80px;\\n      height: 80px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), 0 0 40px rgba(255, 0, 0, 0.3);\\n      animation: pulse 1s infinite;\\n    \");\n        document.body.appendChild(countdownElement);\n        console.log('captureAndPreviewProcess: Created countdown element:', {\n            element: countdownElement,\n            style: countdownElement.style.cssText,\n            position: {\n                x: displayPosition.x,\n                y: displayPosition.y - 60\n            }\n        });\n        // Create a backup countdown in the center of the screen\n        const backupCountdown = document.createElement('div');\n        backupCountdown.className = 'backup-countdown';\n        backupCountdown.textContent = '3';\n        backupCountdown.style.cssText = \"\\n      position: fixed;\\n      left: 50%;\\n      top: 50%;\\n      transform: translate(-50%, -50%);\\n      color: red;\\n      font-size: 72px;\\n      font-weight: bold;\\n      text-shadow: 0 0 20px white, 0 0 30px white, 0 0 40px white;\\n      z-index: 100001;\\n      background-color: rgba(255, 255, 255, 0.95);\\n      border: 4px solid red;\\n      border-radius: 50%;\\n      width: 120px;\\n      height: 120px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 30px rgba(0, 0, 0, 0.7), 0 0 60px rgba(255, 0, 0, 0.5);\\n    \";\n        document.body.appendChild(backupCountdown);\n        console.log('captureAndPreviewProcess: Created backup countdown in center');\n        console.log('Countdown element created at:', {\n            position,\n            displayPosition,\n            canvasRect,\n            canvasStyle: {\n                position: canvas.style.position,\n                width: canvas.style.width,\n                height: canvas.style.height\n            }\n        });\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawDotWithCanvasManager(position.x, position.y);\n        }, 200);\n        // Manual countdown\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            backupCountdown.textContent = count;\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n            // Redraw dot to ensure it's visible\n            drawDotWithCanvasManager(position.x, position.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Change to checkmark\n        countdownElement.textContent = \"✓\";\n        backupCountdown.textContent = \"✓\";\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capturing images...',\n                countdownValue: \"Capturing...\",\n                isCapturing: true\n            });\n        }\n        // Remove countdown elements and clear redrawInterval\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            if (backupCountdown.parentNode) {\n                backupCountdown.parentNode.removeChild(backupCountdown);\n            }\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureImagesAtPoint from savefile.js\n        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured dot at x=\".concat(Math.round(position.x), \", y=\").concat(Math.round(position.y)));\n        }\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capture complete',\n                isCapturing: false\n            });\n        }\n        // Show TopBar again with delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"[captureAndPreviewProcess] Fatal error:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Fatal error: \".concat(error.message));\n        }\n        // Ensure TopBar is shown even on error\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        // Return a minimal valid object to prevent null reference errors\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n// Default export for React compatibility\nconst CountSave = ()=>null; // This is a utility file, so we don't need to render anything\n_c = CountSave;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CountSave);\nvar _c;\n$RefreshReg$(_c, \"CountSave\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ3ZDO0FBQ2dDO0FBRTFEOzs7Q0FHQyxHQUNELE1BQU1FLGlCQUFpQjtJQUNyQixJQUFJLElBQTZCLEVBQUU7UUFDakMsT0FBTztZQUNMQyxhQUFhQyxPQUFPRCxXQUFXO1lBQy9CRSxlQUFlRCxPQUFPQyxhQUFhO1FBQ3JDO0lBQ0Y7SUFDQSxPQUFPO1FBQUVGLGFBQWE7UUFBTUUsZUFBZTtJQUFLO0FBQ2xEO0FBRUE7OztDQUdDLEdBQ0QsTUFBTUMsWUFBWTtJQUNoQixNQUFNLEVBQUVILFdBQVcsRUFBRUUsYUFBYSxFQUFFLEdBQUdIO0lBRXZDLG9EQUFvRDtJQUNwRCxJQUFJQyxlQUFlLE9BQU9BLFlBQVlHLFNBQVMsS0FBSyxZQUFZO1FBQzlELE9BQU9ILFlBQVlHLFNBQVM7SUFDOUI7SUFFQSw0QkFBNEI7SUFDNUIsSUFBSUQsaUJBQWlCLE9BQU9BLGNBQWNDLFNBQVMsS0FBSyxZQUFZO1FBQ2xFLE9BQU9ELGNBQWNDLFNBQVMsTUFBTUQsY0FBY0UsWUFBWTtJQUNoRTtJQUVBLDJCQUEyQjtJQUMzQixPQUFPQyxTQUFTQyxhQUFhLENBQUM7QUFDaEM7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1DLHVCQUF1QixDQUFDQyxRQUFRQztJQUNwQyxJQUFJLENBQUNELFVBQVUsQ0FBQ0MsT0FBTyxPQUFPQTtJQUU5Qix3Q0FBd0M7SUFDeEMsTUFBTUMsZUFBZUYsT0FBT0csS0FBSyxDQUFDQyxRQUFRLEtBQUssV0FDMUJKLENBQUFBLE9BQU9HLEtBQUssQ0FBQ0UsS0FBSyxLQUFLLFdBQVdMLE9BQU9HLEtBQUssQ0FBQ0UsS0FBSyxLQUFLLE1BQUs7SUFFbkYsSUFBSUgsY0FBYztRQUNoQiw0RUFBNEU7UUFDNUUsTUFB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QU87WUFDTDVFLGFBQWE7WUFDYkMsYUFBYTtZQUNidUYsU0FBUztZQUNUbkIsT0FBT0EsTUFBTXNCLE9BQU87UUFDdEI7SUFDRjtBQUNGLEVBQUU7QUFFRix5Q0FBeUM7QUFDekMsTUFBTWUsWUFBWSxJQUFNLE1BQU0sOERBQThEO0tBQXRGQTtBQUVOLGlFQUFlQSxTQUFTQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaXhlZCBjb3VudFNhdmUuanN4IC0gUmVzb2x2aW5nIHJlZHJhd0ludGVydmFsIHJlZmVyZW5jZSBlcnJvclxuLy8gU2hhcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGNvdW50ZG93biBhbmQgaW1hZ2UgY2FwdHVyZSBwcm9jZXNzZXNcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uL0hlbHBlci9zYXZlZmlsZSc7XG5cbi8qKlxuICogR2V0IGNhbnZhcyBtYW5hZ2VtZW50IHV0aWxpdGllcyBmcm9tIGdsb2JhbCBzY29wZSAoZnJvbSBhY3Rpb25CdXR0b24uanMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDYW52YXMgdXRpbGl0aWVzIG9iamVjdFxuICovXG5jb25zdCBnZXRDYW52YXNVdGlscyA9ICgpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhc1V0aWxzOiB3aW5kb3cuY2FudmFzVXRpbHMsXG4gICAgICBjYW52YXNNYW5hZ2VyOiB3aW5kb3cuY2FudmFzTWFuYWdlclxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgY2FudmFzVXRpbHM6IG51bGwsIGNhbnZhc01hbmFnZXI6IG51bGwgfTtcbn07XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgZWxlbWVudFxuICovXG5jb25zdCBnZXRDYW52YXMgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXIgfSA9IGdldENhbnZhc1V0aWxzKCk7XG4gIFxuICAvLyBGaXJzdCB0cnkgdG8gdXNlIGNhbnZhc1V0aWxzIGZyb20gYWN0aW9uQnV0dG9uLmpzXG4gIGlmIChjYW52YXNVdGlscyAmJiB0eXBlb2YgY2FudmFzVXRpbHMuZ2V0Q2FudmFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNhbnZhc1V0aWxzLmdldENhbnZhcygpO1xuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byBjYW52YXNNYW5hZ2VyXG4gIGlmIChjYW52YXNNYW5hZ2VyICYmIHR5cGVvZiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IGNhbnZhc01hbmFnZXIuY3JlYXRlQ2FudmFzKCk7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGRpcmVjdCBxdWVyeVxuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gY2FudmFzIGNvb3JkaW5hdGVzIHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHdoZW4gaW4gZnVsbHNjcmVlblxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIHt4LCB5fSBwb2ludCBjb29yZGluYXRlc1xuICogQHJldHVybnMge09iamVjdH0gVHJhbnNmb3JtZWQgcG9pbnQgY29vcmRpbmF0ZXNcbiAqL1xuY29uc3QgdHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSAoY2FudmFzLCBwb2ludCkgPT4ge1xuICBpZiAoIWNhbnZhcyB8fCAhcG9pbnQpIHJldHVybiBwb2ludDtcbiAgXG4gIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgY29uc3QgaXNGdWxsc2NyZWVuID0gY2FudmFzLnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnICYmIFxuICAgICAgICAgICAgICAgICAgICAgIChjYW52YXMuc3R5bGUud2lkdGggPT09ICcxMDB2dycgfHwgY2FudmFzLnN0eWxlLndpZHRoID09PSAnMTAwJScpO1xuICBcbiAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgIC8vIEdldCB0aGUgY2FudmFzJ3MgYm91bmRpbmcgcmVjdCB0byB1bmRlcnN0YW5kIGl0cyBwb3NpdGlvbiBpbiB0aGUgdmlld3BvcnRcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yc1xuICAgIGNvbnN0IHNjYWxlWCA9IGNhbnZhc1JlY3Qud2lkdGggLyBjYW52YXMud2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gY2FudmFzUmVjdC5oZWlnaHQgLyBjYW52YXMuaGVpZ2h0O1xuICAgIFxuICAgIC8vIFRyYW5zZm9ybSB0aGUgY29vcmRpbmF0ZXNcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0ge1xuICAgICAgeDogcG9pbnQueCAqIHNjYWxlWCArIGNhbnZhc1JlY3QubGVmdCxcbiAgICAgIHk6IHBvaW50LnkgKiBzY2FsZVkgKyBjYW52YXNSZWN0LnRvcCxcbiAgICAgIGxhYmVsOiBwb2ludC5sYWJlbFxuICAgIH07XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0Nvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24gaW4gY291bnRTYXZlOicsIHtcbiAgICAgIG9yaWdpbmFsOiBwb2ludCxcbiAgICAgIHRyYW5zZm9ybWVkOiB0cmFuc2Zvcm1lZFBvaW50LFxuICAgICAgY2FudmFzUmVjdCxcbiAgICAgIHNjYWxlOiB7IHg6IHNjYWxlWCwgeTogc2NhbGVZIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gdHJhbnNmb3JtZWRQb2ludDtcbiAgfVxuICBcbiAgLy8gSWYgbm90IGZ1bGxzY3JlZW4sIHJldHVybiBvcmlnaW5hbCBjb29yZGluYXRlc1xuICByZXR1cm4gcG9pbnQ7XG59O1xuXG4vKipcbiAqIERyYXcgZG90IHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIERvdCByYWRpdXNcbiAqIEByZXR1cm5zIHtib29sZWFufSBTdWNjZXNzIHN0YXR1c1xuICovXG5jb25zdCBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIgPSAoeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgY29uc3QgeyBjYW52YXNVdGlscyB9ID0gZ2V0Q2FudmFzVXRpbHMoKTtcbiAgXG4gIGlmIChjYW52YXNVdGlscyAmJiB0eXBlb2YgY2FudmFzVXRpbHMuZHJhd0RvdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBjYW52YXNVdGlscy5kcmF3RG90KHgsIHksIHJhZGl1cyk7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrOiBtYW51YWxseSBkcmF3IGRvdFxuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoKTtcbiAgaWYgKGNhbnZhcykge1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGRyYXdSZWREb3QoY3R4LCB4LCB5LCByYWRpdXMsIGZhbHNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENsZWFyIGNhbnZhcyB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gKi9cbmNvbnN0IGNsZWFyQ2FudmFzV2l0aE1hbmFnZXIgPSAoKSA9PiB7XG4gIGNvbnN0IHsgY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXIgfSA9IGdldENhbnZhc1V0aWxzKCk7XG4gIFxuICBpZiAoY2FudmFzVXRpbHMgJiYgdHlwZW9mIGNhbnZhc1V0aWxzLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FudmFzVXRpbHMuY2xlYXIoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgXG4gIGlmIChjYW52YXNNYW5hZ2VyICYmIHR5cGVvZiBjYW52YXNNYW5hZ2VyLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGNsZWFyIGNhbnZhc1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoKTtcbiAgaWYgKGNhbnZhcykge1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3llbGxvdyc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgYSBjb3VudGRvd24gZWxlbWVudCBhYm92ZSBhIGRvdCBwb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqIEBwYXJhbSB7RE9NUmVjdH0gY2FudmFzUmVjdCAtIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIG9mIHRoZSBjYW52YXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBUaGUgY3JlYXRlZCBjb3VudGRvd24gZWxlbWVudFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ291bnRkb3duRWxlbWVudCA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVDb3VudGRvd25FbGVtZW50XSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtY291bnRkb3duLCAuZm9yY2VkLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwLCAuZG90LWNvdW50ZG93biwgLnRlc3QtY291bnRkb3duJyk7XG4gIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICBjb25zb2xlLmxvZygnUmVtb3ZpbmcgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnQ6JywgZWwpO1xuICAgIGlmIChlbC5wYXJlbnROb2RlKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEdldCBjYW52YXMgdG8gY2hlY2sgaWYgd2UgbmVlZCBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uXG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICBsZXQgZGlzcGxheVBvc2l0aW9uID0gcG9zaXRpb247XG4gIFxuICBpZiAoY2FudmFzKSB7XG4gICAgLy8gQ2hlY2sgaWYgY2FudmFzIGlzIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGNvbnN0IGlzRnVsbHNjcmVlbiA9IGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIChjYW52YXMuc3R5bGUud2lkdGggPT09ICcxMDB2dycgfHwgY2FudmFzLnN0eWxlLndpZHRoID09PSAnMTAwJScpO1xuICAgIFxuICAgIGlmIChpc0Z1bGxzY3JlZW4pIHtcbiAgICAgIC8vIENhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGUsIHVzZSBkaXJlY3QgY29vcmRpbmF0ZXNcbiAgICAgIGRpc3BsYXlQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgeTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FudmFzIGlzIGluIG5vcm1hbCBtb2RlLCB1c2UgY2FudmFzLXJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gICAgICBkaXNwbGF5UG9zaXRpb24gPSB7XG4gICAgICAgIHg6IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLngsXG4gICAgICAgIHk6IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBjb25zb2xlLmxvZygnW2NyZWF0ZUNvdW50ZG93bkVsZW1lbnRdIENyZWF0aW5nIGNvdW50ZG93biBhdCBwb3NpdGlvbjonLCB7XG4gICAgb3JpZ2luYWw6IHBvc2l0aW9uLFxuICAgIGRpc3BsYXk6IGRpc3BsYXlQb3NpdGlvbixcbiAgICBjYW52YXNSZWN0OiBjYW52YXNSZWN0LFxuICAgIGNhbnZhc0Z1bGxzY3JlZW46IGNhbnZhcyA/IChjYW52YXMuc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcgJiYgY2FudmFzLnN0eWxlLndpZHRoID09PSAnMTAwdncnKSA6IGZhbHNlXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgbWFpbiBjb3VudGRvd24gZWxlbWVudFxuICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGxlZnQ6ICR7ZGlzcGxheVBvc2l0aW9uLnh9cHg7XG4gICAgdG9wOiAke2Rpc3BsYXlQb3NpdGlvbi55IC0gODB9cHg7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgIGNvbG9yOiByZWQ7XG4gICAgZm9udC1zaXplOiA2NHB4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHRleHQtc2hhZG93OiAwIDAgMjBweCB3aGl0ZSwgMCAwIDMwcHggd2hpdGUsIDAgMCA0MHB4IHdoaXRlO1xuICAgIHotaW5kZXg6IDEwMDAwMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTgpO1xuICAgIGJvcmRlcjogNHB4IHNvbGlkIHJlZDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgd2lkdGg6IDEwMHB4O1xuICAgIGhlaWdodDogMTAwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJveC1zaGFkb3c6IDAgMCAzMHB4IHJnYmEoMCwgMCwgMCwgMC43KSwgMCAwIDUwcHggcmdiYSgyNTUsIDAsIDAsIDAuNSk7XG4gICAgYW5pbWF0aW9uOiBjb3VudGRvd25QdWxzZSAxcyBpbmZpbml0ZTtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgYDtcbiAgXG4gIC8vIEFkZCBDU1MgYW5pbWF0aW9uIGZvciBwdWxzZSBlZmZlY3RcbiAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY291bnRkb3duLXN0eWxlcycpKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLmlkID0gJ2NvdW50ZG93bi1zdHlsZXMnO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gYFxuICAgICAgQGtleWZyYW1lcyBjb3VudGRvd25QdWxzZSB7XG4gICAgICAgIDAlIHsgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpIHNjYWxlKDEpOyB9XG4gICAgICAgIDUwJSB7IHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKSBzY2FsZSgxLjEpOyB9XG4gICAgICAgIDEwMCUgeyB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSkgc2NhbGUoMSk7IH1cbiAgICAgIH1cbiAgICBgO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgXG4gIGNvbnNvbGUubG9nKCdjcmVhdGVDb3VudGRvd25FbGVtZW50IGNyZWF0ZWQgYXQ6Jywge1xuICAgIG9yaWdpbmFsUG9zaXRpb246IHBvc2l0aW9uLFxuICAgIGRpc3BsYXlQb3NpdGlvbixcbiAgICBjYW52YXNSZWN0LFxuICAgIGNhbnZhc0luZm86IGNhbnZhcyA/IHtcbiAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICB3aWR0aDogY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0LFxuICAgICAgcmVjdDogY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgfSA6IG51bGxcbiAgfSk7XG4gIFxuICAvLyBDcmVhdGUgYSBiYWNrdXAgY291bnRkb3duIGVsZW1lbnQgY2VudGVyZWQgb24gc2NyZWVuIGFzIGZhbGxiYWNrXG4gIGNvbnN0IGJhY2t1cENvdW50ZG93biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBiYWNrdXBDb3VudGRvd24uY2xhc3NOYW1lID0gJ2JhY2t1cC1jb3VudGRvd24nO1xuICBiYWNrdXBDb3VudGRvd24uc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGNvbG9yOiByZWQ7XG4gICAgZm9udC1zaXplOiA3MnB4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHRleHQtc2hhZG93OiAwIDAgMjVweCB3aGl0ZSwgMCAwIDM1cHggd2hpdGUsIDAgMCA0NXB4IHdoaXRlO1xuICAgIHotaW5kZXg6IDEwMDAwMTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOTgpO1xuICAgIGJvcmRlcjogNXB4IHNvbGlkIHJlZDtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgd2lkdGg6IDEyMHB4O1xuICAgIGhlaWdodDogMTIwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJveC1zaGFkb3c6IDAgMCA0MHB4IHJnYmEoMCwgMCwgMCwgMC44KSwgMCAwIDYwcHggcmdiYSgyNTUsIDAsIDAsIDAuNik7XG4gICAgYW5pbWF0aW9uOiBjb3VudGRvd25QdWxzZSAxcyBpbmZpbml0ZTtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgYDtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChiYWNrdXBDb3VudGRvd24pO1xuICBcbiAgLy8gQWRkIGEgdGVtcG9yYXJ5IHZpc3VhbCBpbmRpY2F0b3IgdG8gc2hvdyB3aGVyZSB0aGUgY291bnRkb3duIGlzIHBvc2l0aW9uZWRcbiAgY29uc3QgaW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBsZWZ0OiAke2Rpc3BsYXlQb3NpdGlvbi54fXB4O1xuICAgIHRvcDogJHtkaXNwbGF5UG9zaXRpb24ueX1weDtcbiAgICB3aWR0aDogMTBweDtcbiAgICBoZWlnaHQ6IDEwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogYmx1ZTtcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgei1pbmRleDogMTAwMDA7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIGA7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaW5kaWNhdG9yKTtcbiAgXG4gIC8vIFJlbW92ZSBpbmRpY2F0b3IgYWZ0ZXIgMiBzZWNvbmRzXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChpbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5kaWNhdG9yKTtcbiAgICB9XG4gIH0sIDIwMDApO1xuICBcbiAgcmV0dXJuIGNvdW50ZG93bkVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIERpc3BsYXkgYSBwcmV2aWV3IG9mIHRoZSBjYXB0dXJlZCBpbWFnZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY3JlZW5JbWFnZSAtIERhdGEgVVJMIG9mIHRoZSBzY3JlZW4gaW1hZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJjYW1JbWFnZSAtIERhdGEgVVJMIG9mIHRoZSB3ZWJjYW0gaW1hZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludCAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKi9cbmV4cG9ydCBjb25zdCBzaG93Q2FwdHVyZVByZXZpZXcgPSAoc2NyZWVuSW1hZ2UsIHdlYmNhbUltYWdlLCBwb2ludCkgPT4ge1xuICBpZiAoIXNjcmVlbkltYWdlICYmICF3ZWJjYW1JbWFnZSkgcmV0dXJuO1xuICBcbiAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBwcmV2aWV3c1xuICBjb25zdCBleGlzdGluZ1ByZXZpZXdzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhcHR1cmUtcHJldmlldy1jb250YWluZXInKTtcbiAgZXhpc3RpbmdQcmV2aWV3cy5mb3JFYWNoKHByZXZpZXcgPT4ge1xuICAgIGlmIChwcmV2aWV3LnBhcmVudE5vZGUpIHtcbiAgICAgIHByZXZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3KTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gQ3JlYXRlIHByZXZpZXcgY29udGFpbmVyXG4gIGNvbnN0IHByZXZpZXdDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJldmlld0NvbnRhaW5lci5jbGFzc05hbWUgPSAnY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcic7XG4gIHByZXZpZXdDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiA1MCU7XG4gICAgbGVmdDogNTAlO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiAyMHB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC44NSk7XG4gICAgcGFkZGluZzogMjBweDtcbiAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgIHotaW5kZXg6IDk5OTk5OTtcbiAgICBib3gtc2hhZG93OiAwIDhweCAyNXB4IHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgYDtcbiAgXG4gIC8vIEFkZCBzY3JlZW4gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gIGlmIChzY3JlZW5JbWFnZSkge1xuICAgIGNvbnN0IHNjcmVlblByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JlZW5QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYDtcbiAgICBcbiAgICBjb25zdCBzY3JlZW5JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICBzY3JlZW5JbWcuc3JjID0gc2NyZWVuSW1hZ2U7XG4gICAgc2NyZWVuSW1nLmFsdCA9ICdTY3JlZW4gQ2FwdHVyZSc7XG4gICAgc2NyZWVuSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgYDtcbiAgICBcbiAgICBjb25zdCBzY3JlZW5MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNjcmVlbkxhYmVsLnRleHRDb250ZW50ID0gJ1NjcmVlbiBDYXB0dXJlJztcbiAgICBzY3JlZW5MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIGA7XG4gICAgXG4gICAgc2NyZWVuUHJldmlldy5hcHBlbmRDaGlsZChzY3JlZW5JbWcpO1xuICAgIHNjcmVlblByZXZpZXcuYXBwZW5kQ2hpbGQoc2NyZWVuTGFiZWwpO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQoc2NyZWVuUHJldmlldyk7XG4gIH1cbiAgXG4gIC8vIEFkZCB3ZWJjYW0gaW1hZ2UgaWYgYXZhaWxhYmxlXG4gIGlmICh3ZWJjYW1JbWFnZSkge1xuICAgIGNvbnN0IHdlYmNhbVByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3ZWJjYW1QcmV2aWV3LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgYDtcbiAgICBcbiAgICBjb25zdCB3ZWJjYW1JbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICB3ZWJjYW1JbWcuc3JjID0gd2ViY2FtSW1hZ2U7XG4gICAgd2ViY2FtSW1nLmFsdCA9ICdXZWJjYW0gQ2FwdHVyZSc7XG4gICAgd2ViY2FtSW1nLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgICAgbWF4LWhlaWdodDogMjQwcHg7XG4gICAgICBib3JkZXI6IDNweCBzb2xpZCB3aGl0ZTtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICMzMzM7XG4gICAgYDtcbiAgICBcbiAgICBjb25zdCB3ZWJjYW1MYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHdlYmNhbUxhYmVsLnRleHRDb250ZW50ID0gJ1dlYmNhbSBDYXB0dXJlJztcbiAgICB3ZWJjYW1MYWJlbC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgbWFyZ2luLXRvcDogMTBweDtcbiAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIGA7XG4gICAgXG4gICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1JbWcpO1xuICAgIHdlYmNhbVByZXZpZXcuYXBwZW5kQ2hpbGQod2ViY2FtTGFiZWwpO1xuICAgIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQod2ViY2FtUHJldmlldyk7XG4gIH1cbiAgXG4gIC8vIEFkZCBwb2ludCBpbmZvXG4gIGlmIChwb2ludCkge1xuICAgIGNvbnN0IHBvaW50SW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBvaW50SW5mby50ZXh0Q29udGVudCA9IHBvaW50LmxhYmVsID8gXG4gICAgICBgJHtwb2ludC5sYWJlbH06IHg9JHtNYXRoLnJvdW5kKHBvaW50LngpfSwgeT0ke01hdGgucm91bmQocG9pbnQueSl9YCA6XG4gICAgICBgUG9pbnQ6IHg9JHtNYXRoLnJvdW5kKHBvaW50LngpfSwgeT0ke01hdGgucm91bmQocG9pbnQueSl9YDtcbiAgICAgIFxuICAgIHBvaW50SW5mby5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgY29sb3I6ICNmZmNjMDA7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICB0b3A6IC00MHB4O1xuICAgICAgbGVmdDogMDtcbiAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIGA7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb2ludEluZm8pO1xuICB9XG4gIFxuICAvLyBBZGQgdGltZXJcbiAgY29uc3QgdGltZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRpbWVyRWxlbWVudC50ZXh0Q29udGVudCA9ICcyLjBzJztcbiAgdGltZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogLTI1cHg7XG4gICAgcmlnaHQ6IDIwcHg7XG4gICAgY29sb3I6IHdoaXRlO1xuICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNyk7XG4gICAgcGFkZGluZzogM3B4IDhweDtcbiAgICBib3JkZXItcmFkaXVzOiA0cHg7XG4gIGA7XG4gIHByZXZpZXdDb250YWluZXIuYXBwZW5kQ2hpbGQodGltZXJFbGVtZW50KTtcbiAgXG4gIC8vIEFkZCB0byBkb2N1bWVudFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICBcbiAgLy8gQ291bnRkb3duXG4gIGxldCB0aW1lTGVmdCA9IDIuMDtcbiAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgdGltZUxlZnQgLT0gMC4xO1xuICAgIGlmICh0aW1lTGVmdCA8PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUub3BhY2l0eSA9ICcwJztcbiAgICAgIHByZXZpZXdDb250YWluZXIuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5IDAuM3MgZWFzZSc7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gYCR7dGltZUxlZnQudG9GaXhlZCgxKX1zYDtcbiAgICB9XG4gIH0sIDEwMCk7XG4gIFxuICAvLyBTYWZldHkgY2xlYW51cFxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICBwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gICAgfVxuICB9LCA1MDAwKTtcbn07XG5cbi8qKlxuICogUnVucyBhIGNvdW50ZG93biBwcm9jZXNzIHRoYXQgZGlzcGxheXMgMy0yLTEgYWJvdmUgYSBkb3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIHt4LCB5fSBwb3NpdGlvbiBvZiB0aGUgZG90XG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSBkb3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uU3RhdHVzVXBkYXRlIC0gRnVuY3Rpb24gdG8gdXBkYXRlIHN0YXR1cyBtZXNzYWdlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gb25Db21wbGV0ZSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBjb3VudGRvd24gY29tcGxldGVzXG4gKi9cbmV4cG9ydCBjb25zdCBydW5Db3VudGRvd24gPSBhc3luYyAocG9zaXRpb24sIGNhbnZhcywgb25TdGF0dXNVcGRhdGUsIG9uQ29tcGxldGUpID0+IHtcbiAgaWYgKCFwb3NpdGlvbiB8fCB0eXBlb2YgcG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgY29uc29sZS53YXJuKCdbcnVuQ291bnRkb3duXSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgIHByb2Nlc3NTdGF0dXM6IFwiSW52YWxpZCBkb3QgcG9zaXRpb25cIixcbiAgICAgIGNvdW50ZG93blZhbHVlOiBudWxsLFxuICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9zaXRpb24sIGNhbnZhc1JlY3QpO1xuICBcbiAgaWYgKCFjb3VudGRvd25FbGVtZW50KSB7XG4gICAgY29uc29sZS53YXJuKCdbcnVuQ291bnRkb3duXSBDb3VudGRvd24gZWxlbWVudCBjb3VsZCBub3QgYmUgY3JlYXRlZC4nKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBVc2UgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtIHRvIGRyYXcgZG90XG4gIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICBsZXQgY291bnQgPSAzO1xuICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG5cbiAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgfSk7XG5cbiAgLy8gQ3JlYXRlIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIGRvdCB2aXNpYmxlIGR1cmluZyBjb3VudGRvd25cbiAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgfSwgMjAwKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBjb3VudGRvd25JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvdW50LS07XG5cbiAgICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY291bnRkb3duSW50ZXJ2YWwpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcblxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogXCJDYXB0dXJpbmcuLi5cIixcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkNhcHR1cmluZyBpbWFnZS4uLlwiLFxuICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZHJhd0RvdFdpdGhDYW52YXNNYW5hZ2VyKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuXG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIHJlZHJhd0ludGVydmFsIHdlIGRlZmluZWQgYWJvdmVcbiAgICAgICAgICBpZiAocmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcblxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkNvdW50ZG93blwiLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCA4MDApO1xuICB9KTtcbn07XG5cbi8qKlxuICogRHJhdyBhIHJlZCBkb3Qgb24gdGhlIGNhbnZhcyAobGVnYWN5IGZ1bmN0aW9uIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5KVxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIENhbnZhcyAyRCBjb250ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBEb3QgcmFkaXVzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyQ2FudmFzIC0gV2hldGhlciB0byBjbGVhciB0aGUgY2FudmFzIGJlZm9yZSBkcmF3aW5nIChkZWZhdWx0OiB0cnVlKVxuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYXdSZWREb3QgPSAoY3R4LCB4LCB5LCByYWRpdXMgPSAxMiwgY2xlYXJDYW52YXMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gIFxuICAvLyBDbGVhciB0aGUgY2FudmFzIGlmIHJlcXVlc3RlZCAoZGVmYXVsdCBiZWhhdmlvcilcbiAgaWYgKGNsZWFyQ2FudmFzKSB7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAneWVsbG93JztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfVxuICBcbiAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICBjdHguZmlsbCgpO1xuICBcbiAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICBjdHgubGluZVdpZHRoID0gMztcbiAgY3R4LnN0cm9rZSgpO1xuICBcbiAgLy8gQWRkIGEgc2Vjb25kIGxhcmdlciBnbG93IGZvciBldmVuIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4zKSc7XG4gIGN0eC5saW5lV2lkdGggPSAyO1xuICBjdHguc3Ryb2tlKCk7XG4gIFxuICBjb25zb2xlLmxvZyhgRHJldyByZWQgZG90IGF0ICgke3h9LCAke3l9KSB3aXRoIHJhZGl1cyAke3JhZGl1c31gKTtcbiAgcmV0dXJuIHsgeCwgeSB9O1xufTtcblxuLyoqXG4gKiBHZXQgaGlnaGVzdCByZXNvbHV0aW9uIGNhbWVyYSBjb25zdHJhaW50c1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gLSBDYW1lcmEgY29uc3RyYWludHNcbiAqL1xuY29uc3QgZ2V0SGlnaGVzdFJlc29sdXRpb25Db25zdHJhaW50cyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICAvLyBHZXQgYWxsIHZpZGVvIGlucHV0IGRldmljZXNcbiAgICBjb25zdCBkZXZpY2VzID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgY29uc3QgdmlkZW9EZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZGV2aWNlID0+IGRldmljZS5raW5kID09PSAndmlkZW9pbnB1dCcpO1xuICAgIFxuICAgIGlmICh2aWRlb0RldmljZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHZpZGVvIGRldmljZXMgZm91bmQsIHVzaW5nIGRlZmF1bHQgY29uc3RyYWludHMnKTtcbiAgICAgIHJldHVybiB7IHZpZGVvOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBnZXQgY2FwYWJpbGl0aWVzIGZvciB0aGUgZmlyc3QgdmlkZW8gZGV2aWNlXG4gICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyB2aWRlbzogdHJ1ZSB9KTtcbiAgICBjb25zdCB2aWRlb1RyYWNrID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKClbMF07XG4gICAgXG4gICAgaWYgKCF2aWRlb1RyYWNrLmdldENhcGFiaWxpdGllcykge1xuICAgICAgY29uc29sZS53YXJuKCdnZXRDYXBhYmlsaXRpZXMgbm90IHN1cHBvcnRlZCwgdXNpbmcgZGVmYXVsdCBjb25zdHJhaW50cycpO1xuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIHJldHVybiB7IHZpZGVvOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHZpZGVvVHJhY2suZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICBcbiAgICBpZiAoIWNhcGFiaWxpdGllcy53aWR0aCB8fCAhY2FwYWJpbGl0aWVzLmhlaWdodCkge1xuICAgICAgY29uc29sZS53YXJuKCdObyB3aWR0aC9oZWlnaHQgY2FwYWJpbGl0aWVzLCB1c2luZyBkZWZhdWx0IGNvbnN0cmFpbnRzJyk7XG4gICAgICByZXR1cm4geyB2aWRlbzogdHJ1ZSB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBHZXQgdGhlIGhpZ2hlc3QgcmVzb2x1dGlvbiBhdmFpbGFibGVcbiAgICBjb25zdCBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLmNhcGFiaWxpdGllcy53aWR0aC52YWx1ZXMpO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KC4uLmNhcGFiaWxpdGllcy5oZWlnaHQudmFsdWVzKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgVXNpbmcgaGlnaGVzdCByZXNvbHV0aW9uOiAke21heFdpZHRofXgke21heEhlaWdodH1gKTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW86IHtcbiAgICAgICAgd2lkdGg6IHsgaWRlYWw6IG1heFdpZHRoIH0sXG4gICAgICAgIGhlaWdodDogeyBpZGVhbDogbWF4SGVpZ2h0IH0sXG4gICAgICAgIGZyYW1lUmF0ZTogeyBpZGVhbDogMzAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdFcnJvciBnZXR0aW5nIGNhbWVyYSBjb25zdHJhaW50cywgdXNpbmcgZGVmYXVsdDonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgdmlkZW86IHRydWUgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYXB0dXJlIGltYWdlcyBhdCBhIHNwZWNpZmljIHBvaW50XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENhcHR1cmUgb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2V9IC0gUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIGNhcHR1cmUgcmVzdWx0XG4gKi9cbmV4cG9ydCBjb25zdCBjYXB0dXJlSW1hZ2VzID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudGVyLCBcbiAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIGNhcHR1cmVGb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJ1xuICAgIH0gPSBvcHRpb25zO1xuICBcbiAgICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnNvbGUud2FybignW2NhcHR1cmVJbWFnZXNdIEludmFsaWQgcG9zaXRpb24gb2JqZWN0OicsIHBvc2l0aW9uKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LignRXJyb3I6IEludmFsaWQgY2FwdHVyZSBwb3NpdGlvbicpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgLy8gR2V0IGhpZ2hlc3QgcmVzb2x1dGlvbiBjb25zdHJhaW50c1xuICAgICAgY29uc3QgY29uc3RyYWludHMgPSBhd2FpdCBnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzKCk7XG4gICAgICBjb25zb2xlLmxvZygnVXNpbmcgY2FtZXJhIGNvbnN0cmFpbnRzOicsIGNvbnN0cmFpbnRzKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGEgbmV3IHN0cmVhbSB3aXRoIHRoZSBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgIGNvbnN0IHN0cmVhbSA9IGF3YWl0IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICAgIGNvbnN0IHNldHRpbmdzID0gdmlkZW9UcmFjay5nZXRTZXR0aW5ncygpO1xuICAgICAgY29uc29sZS5sb2coJ0FjdHVhbCBjYW1lcmEgc2V0dGluZ3M6Jywgc2V0dGluZ3MpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdmlkZW8gZWxlbWVudCB3aXRoIG5ldyBzdHJlYW1cbiAgICAgIGNvbnN0IHZpZGVvRWxlbWVudCA9IHdpbmRvdy52aWRlb0VsZW1lbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndmlkZW8nKTtcbiAgICAgIGlmICh2aWRlb0VsZW1lbnQpIHtcbiAgICAgICAgdmlkZW9FbGVtZW50LnNyY09iamVjdCA9IHN0cmVhbTtcbiAgICAgICAgYXdhaXQgdmlkZW9FbGVtZW50LnBsYXkoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2FsbCB0aGUgY2FwdHVyZUltYWdlc0F0UG9pbnQgd2l0aCBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgICBjYW52YXNSZWYsIFxuICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgIH0pO1xuICBcbiAgICAgIGNvbnNvbGUubG9nKCdDYXB0dXJlIHN1Y2Nlc3NmdWwgd2l0aCBJRDonLCByZXN1bHQuY2FwdHVyZUlkKTtcbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgdGhlIHN0cmVhbVxuICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4gdHJhY2suc3RvcCgpKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6IHJlc3VsdD8uc2NyZWVuSW1hZ2UgfHwgJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiByZXN1bHQ/LndlYmNhbUltYWdlIHx8ICcnLFxuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICBjYXB0dXJlSWQ6IHJlc3VsdD8uY2FwdHVyZUlkLFxuICAgICAgICByZXNvbHV0aW9uOiB7XG4gICAgICAgICAgd2lkdGg6IHNldHRpbmdzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogc2V0dGluZ3MuaGVpZ2h0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbY2FwdHVyZUltYWdlc10gVW5leHBlY3RlZCBlcnJvcjonLCBlcnIpO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6ICcnLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGVyci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSBkb3QgcG9zaXRpb24gd2l0aGluIHRoZSBjYW52YXNcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50XG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIFBhZGRpbmcgZnJvbSB0aGUgZWRnZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0ge3gsIHl9IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRSYW5kb21Qb3NpdGlvbiA9IChjYW52YXMsIHBhZGRpbmcgPSA0MCkgPT4ge1xuICBpZiAoIWNhbnZhcykgcmV0dXJuIHsgeDogMTAwLCB5OiAxMDAgfTsgLy8gRmFsbGJhY2sgcG9zaXRpb25cbiAgXG4gIGNvbnN0IHdpZHRoID0gY2FudmFzLndpZHRoIHx8IDQwMDsgIC8vIEZhbGxiYWNrIGlmIHdpZHRoIGlzIDBcbiAgY29uc3QgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCB8fCAzMDA7IC8vIEZhbGxiYWNrIGlmIGhlaWdodCBpcyAwXG4gIFxuICByZXR1cm4ge1xuICAgIHg6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh3aWR0aCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nLFxuICAgIHk6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChoZWlnaHQgLSAyICogcGFkZGluZykpICsgcGFkZGluZ1xuICB9O1xufTtcblxuLyoqXG4gKiBTcGVjaWFsIGNhbGlicmF0aW9uIGNhcHR1cmUgZnVuY3Rpb24gdGhhdCBiZWhhdmVzIGxpa2UgcmFuZG9tIGRvdCBjYXB0dXJlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFsbCB0aGUgY2FsaWJyYXRpb24gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUmVzdWx0IG9iamVjdCB3aXRoIGNhcHR1cmVkIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbGlicmF0aW9uQ2FwdHVyZSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzUmVmLFxuICAgICAgcG9pbnQsXG4gICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIGNhcHR1cmVGb2xkZXIgPSAnZXllX3RyYWNraW5nX2NhcHR1cmVzJyxcbiAgICAgIHBvaW50SW5kZXgsXG4gICAgICB0b3RhbFBvaW50c1xuICAgIH0gPSBvcHRpb25zO1xuICBcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGNhbGlicmF0aW9uIGNhcHR1cmUgZm9yIHBvaW50ICR7cG9pbnRJbmRleCArIDF9LyR7dG90YWxQb2ludHN9YCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBjYW52YXMgdXNpbmcgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gICAgICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcmVmZXJlbmNlIGlzIG51bGwgaW4gY2FsaWJyYXRpb25DYXB0dXJlXCIpO1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYEVycm9yOiBDYW52YXMgbm90IGF2YWlsYWJsZWApO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgICAgfVxuICBcbiAgICAgIC8vIFVzZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW0gdG8gZHJhdyBkb3RcbiAgICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb2ludC54LCBwb2ludC55KTtcbiAgXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYENhbGlicmF0aW9uIHBvaW50ICR7cG9pbnRJbmRleCArIDF9LyR7dG90YWxQb2ludHN9YCk7XG4gIFxuICAgICAgLy8gVXNlIHRoZSBzYW1lIGNvdW50ZG93biBlbGVtZW50IGNyZWF0aW9uIG1ldGhvZFxuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBjcmVhdGVDb3VudGRvd25FbGVtZW50KHBvaW50LCBjYW52YXNSZWN0KTtcbiAgICAgIFxuICAgICAgaWYgKCFjb3VudGRvd25FbGVtZW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIGNvdW50ZG93biBlbGVtZW50XCIpO1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSB9O1xuICAgICAgfVxuICBcbiAgICAgIC8vIENyZWF0ZSBhIHJlZHJhd0ludGVydmFsIGZvciBrZWVwaW5nIHRoZSBkb3QgdmlzaWJsZVxuICAgICAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICB9LCAyMDApO1xuICBcbiAgICAgIC8vIFJ1biB0aGUgc2FtZSBjb3VudGRvd24gYXMgcmFuZG9tIGRvdFxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYFBvaW50ICR7cG9pbnRJbmRleCArIDF9LyR7dG90YWxQb2ludHN9IC0gY291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZWRyYXcgdGhlIGRvdCBhdCBlYWNoIHN0ZXAgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdmlzaWJsZVxuICAgICAgICBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbFxuICAgICAgICBpZiAocmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgXG4gICAgICAvLyBVc2UgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIGluc3RlYWQgb2YgZGlyZWN0bHkgY2FsbGluZyBjYXB0dXJlSW1hZ2VzQXRQb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzcyh7XG4gICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgcG9zaXRpb246IHBvaW50LFxuICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzLnByb2Nlc3NTdGF0dXMgfHwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgJiYgdHlwZW9mIHN0YXR1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMucHJvY2Vzc1N0YXR1cyB8fCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICB9KTtcbiAgXG4gICAgICAvLyBFbnN1cmUgcHJvcGVyIHJldHVybiBldmVuIGlmIGNhcHR1cmVSZXN1bHQgaXMgbnVsbFxuICAgICAgY29uc3Qgc2FmZVJlc3VsdCA9IGNhcHR1cmVSZXN1bHQgJiYgdHlwZW9mIGNhcHR1cmVSZXN1bHQgPT09ICdvYmplY3QnIFxuICAgICAgICA/IGNhcHR1cmVSZXN1bHQgXG4gICAgICAgIDogeyBzY3JlZW5JbWFnZTogJycsIHdlYmNhbUltYWdlOiAnJywgc3VjY2VzczogZmFsc2UgfTtcbiAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogc2FmZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHNhZmVSZXN1bHQud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvaW50XG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYWxpYnJhdGlvbkNhcHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQWx3YXlzIHJldHVybiBhIHZhbGlkIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBDb21wbGV0ZSBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvY2VzcyBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgY2FudmFzUmVmLFxuICAgIHBvc2l0aW9uLFxuICAgIGNhcHR1cmVDb3VudGVyLFxuICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgdG9nZ2xlVG9wQmFyLFxuICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgIGNhcHR1cmVGb2xkZXJcbiAgfSA9IG9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICAvLyBHZXQgY2FudmFzIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICAgIGlmICghY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW2NhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc10gQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsXCIpO1xuICAgICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiBDYW52YXMgaXMgbm90IGF2YWlsYWJsZScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gRHJhdyB0aGUgZG90IHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcblxuICAgIC8vIENvdW50ZG93biBiZWZvcmUgY2FwdHVyZVxuICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnU3RhcnRpbmcgY291bnRkb3duLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzIGZpcnN0XG4gICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmNhbGlicmF0ZS1jb3VudGRvd24sIC5kb3QtY291bnRkb3duLCAuZm9yY2VkLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwJyk7XG4gICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ2NhcHR1cmVBbmRQcmV2aWV3UHJvY2VzczogUmVtb3ZpbmcgZXhpc3RpbmcgY291bnRkb3duOicsIGVsKTtcbiAgICAgIGVsLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENyZWF0ZSBhIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudFxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgXG4gICAgLy8gVHJhbnNmb3JtIGNvb3JkaW5hdGVzIGZvciBmdWxsc2NyZWVuIGRpc3BsYXlcbiAgICBsZXQgZGlzcGxheVBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgaWYgKGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyAmJiBjYW52YXMuc3R5bGUud2lkdGggPT09ICcxMDB2dycpIHtcbiAgICAgIC8vIENhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGUsIHVzZSBkaXJlY3QgY29vcmRpbmF0ZXNcbiAgICAgIGRpc3BsYXlQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgeTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FudmFzIGlzIGluIG5vcm1hbCBtb2RlLCB1c2UgY2FudmFzLXJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gICAgICBkaXNwbGF5UG9zaXRpb24gPSB7XG4gICAgICAgIHg6IGNhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLngsXG4gICAgICAgIHk6IGNhbnZhc1JlY3QudG9wICsgcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ2NhcHR1cmVBbmRQcmV2aWV3UHJvY2VzczogQ3JlYXRpbmcgY291bnRkb3duIGF0OicsIHtcbiAgICAgIG9yaWdpbmFsUG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgZGlzcGxheVBvc2l0aW9uLFxuICAgICAgY2FudmFzUmVjdCxcbiAgICAgIGNhbnZhc1N0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodFxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2Rpc3BsYXlQb3NpdGlvbi54fXB4O1xuICAgICAgdG9wOiAke2Rpc3BsYXlQb3NpdGlvbi55IC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiA0OHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDE1cHggd2hpdGUsIDAgMCAyNXB4IHdoaXRlLCAwIDAgMzVweCB3aGl0ZTtcbiAgICAgIHotaW5kZXg6IDEwMDAwMDtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45NSk7XG4gICAgICBib3JkZXI6IDNweCBzb2xpZCByZWQ7XG4gICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB3aWR0aDogODBweDtcbiAgICAgIGhlaWdodDogODBweDtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICBib3gtc2hhZG93OiAwIDAgMjBweCByZ2JhKDAsIDAsIDAsIDAuNSksIDAgMCA0MHB4IHJnYmEoMjU1LCAwLCAwLCAwLjMpO1xuICAgICAgYW5pbWF0aW9uOiBwdWxzZSAxcyBpbmZpbml0ZTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ2NhcHR1cmVBbmRQcmV2aWV3UHJvY2VzczogQ3JlYXRlZCBjb3VudGRvd24gZWxlbWVudDonLCB7XG4gICAgICBlbGVtZW50OiBjb3VudGRvd25FbGVtZW50LFxuICAgICAgc3R5bGU6IGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCxcbiAgICAgIHBvc2l0aW9uOiB7IHg6IGRpc3BsYXlQb3NpdGlvbi54LCB5OiBkaXNwbGF5UG9zaXRpb24ueSAtIDYwIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBDcmVhdGUgYSBiYWNrdXAgY291bnRkb3duIGluIHRoZSBjZW50ZXIgb2YgdGhlIHNjcmVlblxuICAgIGNvbnN0IGJhY2t1cENvdW50ZG93biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJhY2t1cENvdW50ZG93bi5jbGFzc05hbWUgPSAnYmFja3VwLWNvdW50ZG93bic7XG4gICAgYmFja3VwQ291bnRkb3duLnRleHRDb250ZW50ID0gJzMnO1xuICAgIGJhY2t1cENvdW50ZG93bi5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgbGVmdDogNTAlO1xuICAgICAgdG9wOiA1MCU7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgIGNvbG9yOiByZWQ7XG4gICAgICBmb250LXNpemU6IDcycHg7XG4gICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgIHRleHQtc2hhZG93OiAwIDAgMjBweCB3aGl0ZSwgMCAwIDMwcHggd2hpdGUsIDAgMCA0MHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogMTAwMDAxO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KTtcbiAgICAgIGJvcmRlcjogNHB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiAxMjBweDtcbiAgICAgIGhlaWdodDogMTIwcHg7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgYm94LXNoYWRvdzogMCAwIDMwcHggcmdiYSgwLCAwLCAwLCAwLjcpLCAwIDAgNjBweCByZ2JhKDI1NSwgMCwgMCwgMC41KTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYmFja3VwQ291bnRkb3duKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzOiBDcmVhdGVkIGJhY2t1cCBjb3VudGRvd24gaW4gY2VudGVyJyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ0NvdW50ZG93biBlbGVtZW50IGNyZWF0ZWQgYXQ6Jywge1xuICAgICAgcG9zaXRpb24sXG4gICAgICBkaXNwbGF5UG9zaXRpb24sXG4gICAgICBjYW52YXNSZWN0LFxuICAgICAgY2FudmFzU3R5bGU6IHtcbiAgICAgICAgcG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgYSByZWRyYXdJbnRlcnZhbCBmb3Iga2VlcGluZyB0aGUgZG90IHZpc2libGVcbiAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkcmF3RG90V2l0aENhbnZhc01hbmFnZXIocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgfSwgMjAwKTtcblxuICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgYmFja3VwQ291bnRkb3duLnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZWRyYXcgZG90IHRvIGVuc3VyZSBpdCdzIHZpc2libGVcbiAgICAgIGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcihwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdG8gY2hlY2ttYXJrXG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgYmFja3VwQ291bnRkb3duLnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0NhcHR1cmluZyBpbWFnZXMuLi4nLFxuICAgICAgICBjb3VudGRvd25WYWx1ZTogXCJDYXB0dXJpbmcuLi5cIixcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudHMgYW5kIGNsZWFyIHJlZHJhd0ludGVydmFsXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChiYWNrdXBDb3VudGRvd24ucGFyZW50Tm9kZSkge1xuICAgICAgICBiYWNrdXBDb3VudGRvd24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiYWNrdXBDb3VudGRvd24pO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAocmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSwgMzAwKTtcblxuICAgIC8vIFVzZSBjYXB0dXJlSW1hZ2VzQXRQb2ludCBmcm9tIHNhdmVmaWxlLmpzXG4gICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgIHBvaW50OiBwb3NpdGlvbixcbiAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50ZXIsXG4gICAgICBjYW52YXNSZWYsXG4gICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgfSk7XG5cbiAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cyhgQ2FwdHVyZWQgZG90IGF0IHg9JHtNYXRoLnJvdW5kKHBvc2l0aW9uLngpfSwgeT0ke01hdGgucm91bmQocG9zaXRpb24ueSl9YCk7XG4gICAgfVxuXG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJlIGNvbXBsZXRlJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiB3aXRoIGRlbGF5XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICB9LCAyNTAwKTtcblxuICAgIHJldHVybiBjYXB0dXJlUmVzdWx0O1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIltjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3NdIEZhdGFsIGVycm9yOlwiLCBlcnJvcik7XG4gICAgXG4gICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYEZhdGFsIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSBUb3BCYXIgaXMgc2hvd24gZXZlbiBvbiBlcnJvclxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgMTUwMCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgbWluaW1hbCB2YWxpZCBvYmplY3QgdG8gcHJldmVudCBudWxsIHJlZmVyZW5jZSBlcnJvcnNcbiAgICByZXR1cm4ge1xuICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgd2ViY2FtSW1hZ2U6ICcnLFxuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5cbi8vIERlZmF1bHQgZXhwb3J0IGZvciBSZWFjdCBjb21wYXRpYmlsaXR5XG5jb25zdCBDb3VudFNhdmUgPSAoKSA9PiBudWxsOyAvLyBUaGlzIGlzIGEgdXRpbGl0eSBmaWxlLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHJlbmRlciBhbnl0aGluZ1xuXG5leHBvcnQgZGVmYXVsdCBDb3VudFNhdmU7ICJdLCJuYW1lcyI6WyJSZWFjdCIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiZ2V0Q2FudmFzVXRpbHMiLCJjYW52YXNVdGlscyIsIndpbmRvdyIsImNhbnZhc01hbmFnZXIiLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ0cmFuc2Zvcm1Db29yZGluYXRlcyIsImNhbnZhcyIsInBvaW50IiwiaXNGdWxsc2NyZWVuIiwic3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiY2FudmFzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsImhlaWdodCIsInRyYW5zZm9ybWVkUG9pbnQiLCJ4IiwibGVmdCIsInkiLCJ0b3AiLCJsYWJlbCIsImNvbnNvbGUiLCJsb2ciLCJvcmlnaW5hbCIsInRyYW5zZm9ybWVkIiwic2NhbGUiLCJkcmF3RG90V2l0aENhbnZhc01hbmFnZXIiLCJyYWRpdXMiLCJkcmF3RG90IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdSZWREb3QiLCJjbGVhckNhbnZhc1dpdGhNYW5hZ2VyIiwiY2xlYXIiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImRpc3BsYXlQb3NpdGlvbiIsImRpc3BsYXkiLCJjYW52YXNGdWxsc2NyZWVuIiwiY291bnRkb3duRWxlbWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJjc3NUZXh0IiwiaWQiLCJ0ZXh0Q29udGVudCIsImhlYWQiLCJhcHBlbmRDaGlsZCIsImJvZHkiLCJvcmlnaW5hbFBvc2l0aW9uIiwiY2FudmFzSW5mbyIsInJlY3QiLCJiYWNrdXBDb3VudGRvd24iLCJpbmRpY2F0b3IiLCJzZXRUaW1lb3V0Iiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImV4aXN0aW5nUHJldmlld3MiLCJwcmV2aWV3IiwicHJldmlld0NvbnRhaW5lciIsInNjcmVlblByZXZpZXciLCJzY3JlZW5JbWciLCJzcmMiLCJhbHQiLCJzY3JlZW5MYWJlbCIsIndlYmNhbVByZXZpZXciLCJ3ZWJjYW1JbWciLCJ3ZWJjYW1MYWJlbCIsInBvaW50SW5mbyIsIk1hdGgiLCJyb3VuZCIsInRpbWVyRWxlbWVudCIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5IiwidHJhbnNpdGlvbiIsInRvRml4ZWQiLCJydW5Db3VudGRvd24iLCJvblN0YXR1c1VwZGF0ZSIsIm9uQ29tcGxldGUiLCJwcm9jZXNzU3RhdHVzIiwiY291bnRkb3duVmFsdWUiLCJpc0NhcHR1cmluZyIsImNvdW50IiwicmVkcmF3SW50ZXJ2YWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50ZG93bkludGVydmFsIiwiY2xlYXJDYW52YXMiLCJiZWdpblBhdGgiLCJhcmMiLCJQSSIsImZpbGwiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZSIsImdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMiLCJkZXZpY2VzIiwibmF2aWdhdG9yIiwibWVkaWFEZXZpY2VzIiwiZW51bWVyYXRlRGV2aWNlcyIsInZpZGVvRGV2aWNlcyIsImZpbHRlciIsImRldmljZSIsImtpbmQiLCJsZW5ndGgiLCJ2aWRlbyIsInN0cmVhbSIsImdldFVzZXJNZWRpYSIsInZpZGVvVHJhY2siLCJnZXRWaWRlb1RyYWNrcyIsImdldENhcGFiaWxpdGllcyIsImdldFRyYWNrcyIsInRyYWNrIiwic3RvcCIsImNhcGFiaWxpdGllcyIsIm1heFdpZHRoIiwibWF4IiwidmFsdWVzIiwibWF4SGVpZ2h0IiwiaWRlYWwiLCJmcmFtZVJhdGUiLCJlcnJvciIsImNhcHR1cmVJbWFnZXMiLCJvcHRpb25zIiwiY2FudmFzUmVmIiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsInNldFByb2Nlc3NTdGF0dXMiLCJ0b2dnbGVUb3BCYXIiLCJjYXB0dXJlRm9sZGVyIiwiY29uc3RyYWludHMiLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwidmlkZW9FbGVtZW50Iiwic3JjT2JqZWN0IiwicGxheSIsInJlc3VsdCIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsImNhcHR1cmVJZCIsInN1Y2Nlc3MiLCJyZXNvbHV0aW9uIiwiZXJyIiwibWVzc2FnZSIsImdldFJhbmRvbVBvc2l0aW9uIiwicGFkZGluZyIsImZsb29yIiwicmFuZG9tIiwiY2FsaWJyYXRpb25DYXB0dXJlIiwicG9pbnRJbmRleCIsInRvdGFsUG9pbnRzIiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsInN0YXR1cyIsInNhZmVSZXN1bHQiLCJyZW1vdmUiLCJjYW52YXNTdHlsZSIsImVsZW1lbnQiLCJDb3VudFNhdmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx\n"));

/***/ })

});