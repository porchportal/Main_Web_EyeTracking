"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx":
/*!**********************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/countSave.jsx ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calibrationCapture: () => (/* binding */ calibrationCapture),\n/* harmony export */   captureAndPreviewProcess: () => (/* binding */ captureAndPreviewProcess),\n/* harmony export */   captureImages: () => (/* binding */ captureImages),\n/* harmony export */   createCountdownElement: () => (/* binding */ createCountdownElement),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawRedDot: () => (/* binding */ drawRedDot),\n/* harmony export */   getRandomPosition: () => (/* binding */ getRandomPosition),\n/* harmony export */   runCountdown: () => (/* binding */ runCountdown),\n/* harmony export */   showCapturePreview: () => (/* binding */ showCapturePreview)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// Fixed countSave.jsx - Resolving redrawInterval reference error\n// Shared functionality for countdown and image capture processes\n\n\n/**\n * Creates and displays a countdown element above a dot position\n * @param {Object} position - {x, y} position of the dot\n * @param {DOMRect} canvasRect - getBoundingClientRect() of the canvas\n * @returns {HTMLElement} - The created countdown element\n */ const createCountdownElement = (position, canvasRect)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[createCountdownElement] Invalid position:', position);\n        return null;\n    }\n    const existingCountdowns = document.querySelectorAll('.calibrate-countdown, .forced-countdown, .center-countdown-backup');\n    existingCountdowns.forEach((el)=>el.remove());\n    const absoluteX = canvasRect.left + position.x;\n    const absoluteY = canvasRect.top + position.y;\n    const countdownElement = document.createElement('div');\n    countdownElement.className = 'dot-countdown';\n    countdownElement.style.cssText = \"\\n    position: fixed;\\n    left: \".concat(absoluteX, \"px;\\n    top: \").concat(absoluteY - 60, \"px;\\n    transform: translateX(-50%);\\n    color: red;\\n    font-size: 36px;\\n    font-weight: bold;\\n    text-shadow: 0 0 10px white, 0 0 20px white;\\n    z-index: 9999;\\n    background-color: rgba(255, 255, 255, 0.8);\\n    border: 2px solid red;\\n    border-radius: 50%;\\n    width: 50px;\\n    height: 50px;\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n  \");\n    document.body.appendChild(countdownElement);\n    return countdownElement;\n};\n/**\n * Display a preview of the captured images\n * @param {string} screenImage - Data URL of the screen image\n * @param {string} webcamImage - Data URL of the webcam image\n * @param {Object} point - {x, y} position of the dot\n */ const showCapturePreview = (screenImage, webcamImage, point)=>{\n    if (!screenImage && !webcamImage) return;\n    // Remove any existing previews\n    const existingPreviews = document.querySelectorAll('.capture-preview-container');\n    existingPreviews.forEach((preview)=>{\n        if (preview.parentNode) {\n            preview.parentNode.removeChild(preview);\n        }\n    });\n    // Create preview container\n    const previewContainer = document.createElement('div');\n    previewContainer.className = 'capture-preview-container';\n    previewContainer.style.cssText = \"\\n    position: fixed;\\n    top: 50%;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    display: flex;\\n    gap: 20px;\\n    background-color: rgba(0, 0, 0, 0.85);\\n    padding: 20px;\\n    border-radius: 12px;\\n    z-index: 999999;\\n    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);\\n  \";\n    // Add screen image if available\n    if (screenImage) {\n        const screenPreview = document.createElement('div');\n        screenPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const screenImg = document.createElement('img');\n        screenImg.src = screenImage;\n        screenImg.alt = 'Screen Capture';\n        screenImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const screenLabel = document.createElement('div');\n        screenLabel.textContent = 'Screen Capture';\n        screenLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        screenPreview.appendChild(screenImg);\n        screenPreview.appendChild(screenLabel);\n        previewContainer.appendChild(screenPreview);\n    }\n    // Add webcam image if available\n    if (webcamImage) {\n        const webcamPreview = document.createElement('div');\n        webcamPreview.style.cssText = \"\\n      display: flex;\\n      flex-direction: column;\\n      align-items: center;\\n    \";\n        const webcamImg = document.createElement('img');\n        webcamImg.src = webcamImage;\n        webcamImg.alt = 'Webcam Capture';\n        webcamImg.style.cssText = \"\\n      max-width: 320px;\\n      max-height: 240px;\\n      border: 3px solid white;\\n      border-radius: 8px;\\n      background-color: #333;\\n    \";\n        const webcamLabel = document.createElement('div');\n        webcamLabel.textContent = 'Webcam Capture';\n        webcamLabel.style.cssText = \"\\n      color: white;\\n      font-size: 14px;\\n      margin-top: 10px;\\n      font-weight: bold;\\n    \";\n        webcamPreview.appendChild(webcamImg);\n        webcamPreview.appendChild(webcamLabel);\n        previewContainer.appendChild(webcamPreview);\n    }\n    // Add point info\n    if (point) {\n        const pointInfo = document.createElement('div');\n        pointInfo.textContent = point.label ? \"\".concat(point.label, \": x=\").concat(Math.round(point.x), \", y=\").concat(Math.round(point.y)) : \"Point: x=\".concat(Math.round(point.x), \", y=\").concat(Math.round(point.y));\n        pointInfo.style.cssText = \"\\n      color: #ffcc00;\\n      font-size: 14px;\\n      position: absolute;\\n      top: -40px;\\n      left: 0;\\n      width: 100%;\\n      text-align: center;\\n    \";\n        previewContainer.appendChild(pointInfo);\n    }\n    // Add timer\n    const timerElement = document.createElement('div');\n    timerElement.textContent = '2.0s';\n    timerElement.style.cssText = \"\\n    position: absolute;\\n    bottom: -25px;\\n    right: 20px;\\n    color: white;\\n    font-size: 12px;\\n    background-color: rgba(0, 0, 0, 0.7);\\n    padding: 3px 8px;\\n    border-radius: 4px;\\n  \";\n    previewContainer.appendChild(timerElement);\n    // Add to document\n    document.body.appendChild(previewContainer);\n    // Countdown\n    let timeLeft = 2.0;\n    const interval = setInterval(()=>{\n        timeLeft -= 0.1;\n        if (timeLeft <= 0) {\n            clearInterval(interval);\n            previewContainer.style.opacity = '0';\n            previewContainer.style.transition = 'opacity 0.3s ease';\n            setTimeout(()=>{\n                if (previewContainer.parentNode) {\n                    previewContainer.parentNode.removeChild(previewContainer);\n                }\n            }, 300);\n        } else {\n            timerElement.textContent = \"\".concat(timeLeft.toFixed(1), \"s\");\n        }\n    }, 100);\n    // Safety cleanup\n    setTimeout(()=>{\n        if (previewContainer.parentNode) {\n            previewContainer.parentNode.removeChild(previewContainer);\n        }\n    }, 5000);\n};\n/**\n * Runs a countdown process that displays 3-2-1 above a dot\n * @param {Object} position - {x, y} position of the dot\n * @param {HTMLCanvasElement} canvas - Canvas element with the dot\n * @param {Function} onStatusUpdate - Function to update status messages\n * @param {Function} onComplete - Callback to execute when countdown completes\n */ const runCountdown = async (position, canvas, onStatusUpdate, onComplete)=>{\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[runCountdown] Invalid position:', position);\n        onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n            processStatus: \"Invalid dot position\",\n            countdownValue: null,\n            isCapturing: false\n        });\n        return;\n    }\n    const canvasRect = canvas.getBoundingClientRect();\n    const countdownElement = createCountdownElement(position, canvasRect);\n    if (!countdownElement) {\n        console.warn('[runCountdown] Countdown element could not be created.');\n        return;\n    }\n    const ctx = canvas.getContext('2d');\n    drawRedDot(ctx, position.x, position.y);\n    let count = 3;\n    countdownElement.textContent = count;\n    onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n        processStatus: \"Countdown\",\n        countdownValue: count,\n        isCapturing: true\n    });\n    // Create redrawInterval for keeping dot visible during countdown\n    let redrawInterval = setInterval(()=>{\n        drawRedDot(ctx, position.x, position.y, 12, false);\n    }, 200);\n    return new Promise((resolve)=>{\n        const countdownInterval = setInterval(()=>{\n            count--;\n            if (count <= 0) {\n                clearInterval(countdownInterval);\n                countdownElement.textContent = \"✓\";\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    countdownValue: \"Capturing...\",\n                    processStatus: \"Capturing image...\",\n                    isCapturing: true\n                });\n                setTimeout(()=>{\n                    if (countdownElement.parentNode) {\n                        countdownElement.parentNode.removeChild(countdownElement);\n                    }\n                    drawRedDot(ctx, position.x, position.y, 12, false);\n                    // Clear the redrawInterval we defined above\n                    if (redrawInterval) {\n                        clearInterval(redrawInterval);\n                    }\n                    if (onComplete) {\n                        drawRedDot(ctx, position.x, position.y, 12, false);\n                        onComplete();\n                    }\n                    resolve();\n                }, 300);\n            } else {\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown\",\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n        }, 800);\n    });\n};\n/**\n * Draw a red dot on the canvas\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @param {boolean} clearCanvas - Whether to clear the canvas before drawing (default: true)\n * @returns {Object} - {x, y} position\n */ const drawRedDot = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12, clearCanvas = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;\n    const canvas = ctx.canvas;\n    // Clear the canvas if requested (default behavior)\n    if (clearCanvas) {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    return {\n        x,\n        y\n    };\n};\n/**\n * Get highest resolution camera constraints\n * @returns {Promise<Object>} - Camera constraints\n */ const getHighestResolutionConstraints = async ()=>{\n    try {\n        // Get all video input devices\n        const devices = await navigator.mediaDevices.enumerateDevices();\n        const videoDevices = devices.filter((device)=>device.kind === 'videoinput');\n        if (videoDevices.length === 0) {\n            console.warn('No video devices found, using default constraints');\n            return {\n                video: true\n            };\n        }\n        // Try to get capabilities for the first video device\n        const stream = await navigator.mediaDevices.getUserMedia({\n            video: true\n        });\n        const videoTrack = stream.getVideoTracks()[0];\n        if (!videoTrack.getCapabilities) {\n            console.warn('getCapabilities not supported, using default constraints');\n            stream.getTracks().forEach((track)=>track.stop());\n            return {\n                video: true\n            };\n        }\n        const capabilities = videoTrack.getCapabilities();\n        stream.getTracks().forEach((track)=>track.stop());\n        if (!capabilities.width || !capabilities.height) {\n            console.warn('No width/height capabilities, using default constraints');\n            return {\n                video: true\n            };\n        }\n        // Get the highest resolution available\n        const maxWidth = Math.max(...capabilities.width.values);\n        const maxHeight = Math.max(...capabilities.height.values);\n        console.log(\"Using highest resolution: \".concat(maxWidth, \"x\").concat(maxHeight));\n        return {\n            video: {\n                width: {\n                    ideal: maxWidth\n                },\n                height: {\n                    ideal: maxHeight\n                },\n                frameRate: {\n                    ideal: 30\n                }\n            }\n        };\n    } catch (error) {\n        console.warn('Error getting camera constraints, using default:', error);\n        return {\n            video: true\n        };\n    }\n};\n/**\n * Capture images at a specific point\n * @param {Object} options - Capture options\n * @returns {Promise} - Promise that resolves with the capture result\n */ const captureImages = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures' } = options;\n    if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {\n        console.warn('[captureImages] Invalid position object:', position);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus('Error: Invalid capture position');\n        return null;\n    }\n    try {\n        // Get highest resolution constraints\n        const constraints = await getHighestResolutionConstraints();\n        console.log('Using camera constraints:', constraints);\n        // Get a new stream with the highest resolution\n        const stream = await navigator.mediaDevices.getUserMedia(constraints);\n        const videoTrack = stream.getVideoTracks()[0];\n        const settings = videoTrack.getSettings();\n        console.log('Actual camera settings:', settings);\n        // Update video element with new stream\n        const videoElement = window.videoElement || document.querySelector('video');\n        if (videoElement) {\n            videoElement.srcObject = stream;\n            await videoElement.play();\n        }\n        // Call the captureImagesAtPoint with all necessary parameters\n        const result = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        console.log('Capture successful with ID:', result.captureId);\n        // Clean up the stream\n        stream.getTracks().forEach((track)=>track.stop());\n        return {\n            screenImage: (result === null || result === void 0 ? void 0 : result.screenImage) || '',\n            webcamImage: (result === null || result === void 0 ? void 0 : result.webcamImage) || '',\n            success: true,\n            captureId: result === null || result === void 0 ? void 0 : result.captureId,\n            resolution: {\n                width: settings.width,\n                height: settings.height\n            }\n        };\n    } catch (err) {\n        console.error('[captureImages] Unexpected error:', err);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(err.message));\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: err.message\n        };\n    }\n};\n/**\n * Generate a random dot position within the canvas\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {number} padding - Padding from the edges\n * @returns {Object} - {x, y} position\n */ const getRandomPosition = function(canvas) {\n    let padding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 40;\n    if (!canvas) return {\n        x: 100,\n        y: 100\n    }; // Fallback position\n    const width = canvas.width || 400; // Fallback if width is 0\n    const height = canvas.height || 300; // Fallback if height is 0\n    return {\n        x: Math.floor(Math.random() * (width - 2 * padding)) + padding,\n        y: Math.floor(Math.random() * (height - 2 * padding)) + padding\n    };\n};\n/**\n * Special calibration capture function that behaves like random dot capture\n * @param {Object} options - All the calibration options\n * @returns {Promise<Object>} Result object with captured data\n */ const calibrationCapture = async (options)=>{\n    const { canvasRef, point, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, captureFolder = 'eye_tracking_captures', pointIndex, totalPoints } = options;\n    try {\n        console.log(\"Starting calibration capture for point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Get canvas\n        const canvas = canvasRef.current;\n        if (!canvas) {\n            console.error(\"Canvas reference is null in calibrationCapture\");\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: Canvas not available\");\n            return {\n                success: false\n            };\n        }\n        // Use the exact same drawing method as random dots\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, point.x, point.y);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Calibration point \".concat(pointIndex + 1, \"/\").concat(totalPoints));\n        // Use the same countdown element creation method\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = createCountdownElement(point, canvasRect);\n        if (!countdownElement) {\n            console.error(\"Failed to create countdown element\");\n            return {\n                success: false\n            };\n        }\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, point.x, point.y, 12, false);\n        }, 200);\n        // Run the same countdown as random dot\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Point \".concat(pointIndex + 1, \"/\").concat(totalPoints, \" - countdown \").concat(count));\n            // Redraw the dot at each step to ensure it remains visible\n            drawRedDot(ctx, point.x, point.y, 12, false);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Show checkmark\n        countdownElement.textContent = \"✓\";\n        // Remove countdown element\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Clear redrawInterval\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureAndPreviewProcess instead of directly calling captureImagesAtPoint\n        const captureResult = await captureAndPreviewProcess({\n            canvasRef,\n            position: point,\n            captureCounter,\n            setCaptureCounter,\n            setProcessStatus: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            toggleTopBar,\n            onStatusUpdate: (status)=>{\n                if (typeof status === 'string') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status);\n                } else if (status && typeof status === 'object') {\n                    setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(status.processStatus || '');\n                }\n            },\n            captureFolder\n        });\n        // Ensure proper return even if captureResult is null\n        const safeResult = captureResult && typeof captureResult === 'object' ? captureResult : {\n            screenImage: '',\n            webcamImage: '',\n            success: false\n        };\n        return {\n            screenImage: safeResult.screenImage || '',\n            webcamImage: safeResult.webcamImage || '',\n            success: true,\n            point\n        };\n    } catch (error) {\n        console.error(\"Error in calibrationCapture:\", error);\n        setProcessStatus === null || setProcessStatus === void 0 ? void 0 : setProcessStatus(\"Error: \".concat(error.message));\n        // Always return a valid object with default values\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n/**\n * Complete capture and preview process\n * @param {Object} options - Process options\n */ const captureAndPreviewProcess = async (options)=>{\n    const { canvasRef, position, captureCounter, setCaptureCounter, setProcessStatus, toggleTopBar, onStatusUpdate, captureFolder } = options;\n    try {\n        const canvas = canvasRef === null || canvasRef === void 0 ? void 0 : canvasRef.current;\n        if (!canvas) {\n            console.error(\"[captureAndPreviewProcess] Canvas reference is null\");\n            if (setProcessStatus) setProcessStatus('Error: Canvas is not available');\n            return null;\n        }\n        // Draw the dot\n        const ctx = canvas.getContext('2d');\n        drawRedDot(ctx, position.x, position.y);\n        // Countdown before capture\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Starting countdown...',\n                isCapturing: true\n            });\n        }\n        // Create a custom countdown element\n        const canvasRect = canvas.getBoundingClientRect();\n        const countdownElement = document.createElement('div');\n        countdownElement.className = 'calibrate-countdown';\n        countdownElement.style.cssText = \"\\n      position: fixed;\\n      left: \".concat(canvasRect.left + position.x, \"px;\\n      top: \").concat(canvasRect.top + position.y - 60, \"px;\\n      transform: translateX(-50%);\\n      color: red;\\n      font-size: 36px;\\n      font-weight: bold;\\n      text-shadow: 0 0 10px white, 0 0 20px white;\\n      z-index: 9999;\\n      background-color: rgba(255, 255, 255, 0.8);\\n      border: 2px solid red;\\n      border-radius: 50%;\\n      width: 50px;\\n      height: 50px;\\n      display: flex;\\n      justify-content: center;\\n      align-items: center;\\n      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n    \");\n        document.body.appendChild(countdownElement);\n        // Create a redrawInterval for keeping the dot visible\n        let redrawInterval = setInterval(()=>{\n            drawRedDot(ctx, position.x, position.y, 12, false);\n        }, 200);\n        // Manual countdown\n        for(let count = 3; count > 0; count--){\n            countdownElement.textContent = count;\n            if (onStatusUpdate) {\n                onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n            }\n            // Redraw dot to ensure it's visible\n            drawRedDot(ctx, position.x, position.y);\n            await new Promise((resolve)=>setTimeout(resolve, 800));\n        }\n        // Change to checkmark\n        countdownElement.textContent = \"✓\";\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capturing images...',\n                countdownValue: \"Capturing...\",\n                isCapturing: true\n            });\n        }\n        // Remove countdown element and clear redrawInterval\n        setTimeout(()=>{\n            if (countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            if (redrawInterval) {\n                clearInterval(redrawInterval);\n            }\n        }, 300);\n        // Use captureImagesAtPoint from savefile.js\n        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_1__.captureImagesAtPoint)({\n            point: position,\n            captureCount: captureCounter,\n            canvasRef,\n            setCaptureCount: setCaptureCounter,\n            showCapturePreview\n        });\n        if (setProcessStatus) {\n            setProcessStatus(\"Captured dot at x=\".concat(Math.round(position.x), \", y=\").concat(Math.round(position.y)));\n        }\n        if (onStatusUpdate) {\n            onStatusUpdate({\n                processStatus: 'Capture complete',\n                isCapturing: false\n            });\n        }\n        // Show TopBar again with delay\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 2500);\n        return captureResult;\n    } catch (error) {\n        console.error(\"[captureAndPreviewProcess] Fatal error:\", error);\n        if (setProcessStatus) {\n            setProcessStatus(\"Fatal error: \".concat(error.message));\n        }\n        // Ensure TopBar is shown even on error\n        setTimeout(()=>{\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(true);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(true);\n            }\n        }, 1500);\n        // Return a minimal valid object to prevent null reference errors\n        return {\n            screenImage: '',\n            webcamImage: '',\n            success: false,\n            error: error.message\n        };\n    }\n};\n// Default export for React compatibility\nconst CountSave = ()=>null; // This is a utility file, so we don't need to render anything\n_c = CountSave;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CountSave);\nvar _c;\n$RefreshReg$(_c, \"CountSave\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vY291bnRTYXZlLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxpRUFBaUU7QUFDakUsaUVBQWlFO0FBQ3ZDO0FBQ2dDO0FBRTFEOzs7OztDQUtDLEdBQ00sTUFBTUUseUJBQXlCLENBQUNDLFVBQVVDO0lBQy9DLElBQUksQ0FBQ0QsWUFBWSxPQUFPQSxTQUFTRSxDQUFDLEtBQUssWUFBWSxPQUFPRixTQUFTRyxDQUFDLEtBQUssVUFBVTtRQUNqRkMsUUFBUUMsSUFBSSxDQUFDLDhDQUE4Q0w7UUFDM0QsT0FBTztJQUNUO0lBRUEsTUFBTU0scUJBQXFCQyxTQUFTQyxnQkFBZ0IsQ0FBQztJQUNyREYsbUJBQW1CRyxPQUFPLENBQUNDLENBQUFBLEtBQU1BLEdBQUdDLE1BQU07SUFFMUMsTUFBTUMsWUFBWVgsV0FBV1ksSUFBSSxHQUFHYixTQUFTRSxDQUFDO0lBQzlDLE1BQU1ZLFlBQVliLFdBQVdjLEdBQUcsR0FBR2YsU0FBU0csQ0FBQztJQUU3QyxNQUFNYSxtQkFBbUJULFNBQVNVLGFBQWEsQ0FBQztJQUNoREQsaUJBQWlCRSxTQUFTLEdBQUc7SUFDN0JGLGlCQUFpQkcsS0FBSyxDQUFDQyxPQUFPLEdBQUcscUNBR3hCTixPQURDRixXQUFVLGtCQUNJLE9BQWZFLFlBQVksSUFBRztJQWtCeEJQLFNBQVNjLElBQUksQ0FBQ0MsV0FBVyxDQUFDTjtJQUMxQixPQUFPQTtBQUNULEVBQUU7QUFFRjs7Ozs7Q0FLQyxHQUNNLE1BQU1PLHFCQUFxQixDQUFDQyxhQUFhQyxhQUFhQztJQUMzRCxJQUFJLENBQUNGLGVBQWUsQ0FBQ0MsYUFBYTtJQUVsQywrQkFBK0I7SUFDL0IsTUFBTUUsbUJBQW1CcEIsU0FBU0MsZ0JBQWdCLENBQUM7SUFDbkRtQixpQkFBaUJsQixPQUFPLENBQUNtQixDQUFBQTtRQUN2QixJQUFJQSxRQUFRQyxV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dG9taXplZC9BY3Rpb24vY291bnRTYXZlLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaXhlZCBjb3VudFNhdmUuanN4IC0gUmVzb2x2aW5nIHJlZHJhd0ludGVydmFsIHJlZmVyZW5jZSBlcnJvclxuLy8gU2hhcmVkIGZ1bmN0aW9uYWxpdHkgZm9yIGNvdW50ZG93biBhbmQgaW1hZ2UgY2FwdHVyZSBwcm9jZXNzZXNcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uL0hlbHBlci9zYXZlZmlsZSc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgZGlzcGxheXMgYSBjb3VudGRvd24gZWxlbWVudCBhYm92ZSBhIGRvdCBwb3NpdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqIEBwYXJhbSB7RE9NUmVjdH0gY2FudmFzUmVjdCAtIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIG9mIHRoZSBjYW52YXNcbiAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gLSBUaGUgY3JlYXRlZCBjb3VudGRvd24gZWxlbWVudFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQ291bnRkb3duRWxlbWVudCA9IChwb3NpdGlvbiwgY2FudmFzUmVjdCkgPT4ge1xuICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tjcmVhdGVDb3VudGRvd25FbGVtZW50XSBJbnZhbGlkIHBvc2l0aW9uOicsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYWxpYnJhdGUtY291bnRkb3duLCAuZm9yY2VkLWNvdW50ZG93biwgLmNlbnRlci1jb3VudGRvd24tYmFja3VwJyk7XG4gIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IGVsLnJlbW92ZSgpKTtcblxuICBjb25zdCBhYnNvbHV0ZVggPSBjYW52YXNSZWN0LmxlZnQgKyBwb3NpdGlvbi54O1xuICBjb25zdCBhYnNvbHV0ZVkgPSBjYW52YXNSZWN0LnRvcCArIHBvc2l0aW9uLnk7XG5cbiAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICBsZWZ0OiAke2Fic29sdXRlWH1weDtcbiAgICB0b3A6ICR7YWJzb2x1dGVZIC0gNjB9cHg7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgIGNvbG9yOiByZWQ7XG4gICAgZm9udC1zaXplOiAzNnB4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgei1pbmRleDogOTk5OTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICB3aWR0aDogNTBweDtcbiAgICBoZWlnaHQ6IDUwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgYDtcblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICByZXR1cm4gY291bnRkb3duRWxlbWVudDtcbn07XG5cbi8qKlxuICogRGlzcGxheSBhIHByZXZpZXcgb2YgdGhlIGNhcHR1cmVkIGltYWdlc1xuICogQHBhcmFtIHtzdHJpbmd9IHNjcmVlbkltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHNjcmVlbiBpbWFnZVxuICogQHBhcmFtIHtzdHJpbmd9IHdlYmNhbUltYWdlIC0gRGF0YSBVUkwgb2YgdGhlIHdlYmNhbSBpbWFnZVxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50IC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqL1xuZXhwb3J0IGNvbnN0IHNob3dDYXB0dXJlUHJldmlldyA9IChzY3JlZW5JbWFnZSwgd2ViY2FtSW1hZ2UsIHBvaW50KSA9PiB7XG4gIGlmICghc2NyZWVuSW1hZ2UgJiYgIXdlYmNhbUltYWdlKSByZXR1cm47XG4gIFxuICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIHByZXZpZXdzXG4gIGNvbnN0IGV4aXN0aW5nUHJldmlld3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FwdHVyZS1wcmV2aWV3LWNvbnRhaW5lcicpO1xuICBleGlzdGluZ1ByZXZpZXdzLmZvckVhY2gocHJldmlldyA9PiB7XG4gICAgaWYgKHByZXZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgcHJldmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXcpO1xuICAgIH1cbiAgfSk7XG4gIFxuICAvLyBDcmVhdGUgcHJldmlldyBjb250YWluZXJcbiAgY29uc3QgcHJldmlld0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcmV2aWV3Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdjYXB0dXJlLXByZXZpZXctY29udGFpbmVyJztcbiAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICB0b3A6IDUwJTtcbiAgICBsZWZ0OiA1MCU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6IDIwcHg7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjg1KTtcbiAgICBwYWRkaW5nOiAyMHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG4gICAgei1pbmRleDogOTk5OTk5O1xuICAgIGJveC1zaGFkb3c6IDAgOHB4IDI1cHggcmdiYSgwLCAwLCAwLCAwLjYpO1xuICBgO1xuICBcbiAgLy8gQWRkIHNjcmVlbiBpbWFnZSBpZiBhdmFpbGFibGVcbiAgaWYgKHNjcmVlbkltYWdlKSB7XG4gICAgY29uc3Qgc2NyZWVuUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNjcmVlblByZXZpZXcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBgO1xuICAgIFxuICAgIGNvbnN0IHNjcmVlbkltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIHNjcmVlbkltZy5zcmMgPSBzY3JlZW5JbWFnZTtcbiAgICBzY3JlZW5JbWcuYWx0ID0gJ1NjcmVlbiBDYXB0dXJlJztcbiAgICBzY3JlZW5JbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICBtYXgtaGVpZ2h0OiAyNDBweDtcbiAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICBgO1xuICAgIFxuICAgIGNvbnN0IHNjcmVlbkxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc2NyZWVuTGFiZWwudGV4dENvbnRlbnQgPSAnU2NyZWVuIENhcHR1cmUnO1xuICAgIHNjcmVlbkxhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgYDtcbiAgICBcbiAgICBzY3JlZW5QcmV2aWV3LmFwcGVuZENoaWxkKHNjcmVlbkltZyk7XG4gICAgc2NyZWVuUHJldmlldy5hcHBlbmRDaGlsZChzY3JlZW5MYWJlbCk7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZChzY3JlZW5QcmV2aWV3KTtcbiAgfVxuICBcbiAgLy8gQWRkIHdlYmNhbSBpbWFnZSBpZiBhdmFpbGFibGVcbiAgaWYgKHdlYmNhbUltYWdlKSB7XG4gICAgY29uc3Qgd2ViY2FtUHJldmlldyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHdlYmNhbVByZXZpZXcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBgO1xuICAgIFxuICAgIGNvbnN0IHdlYmNhbUltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIHdlYmNhbUltZy5zcmMgPSB3ZWJjYW1JbWFnZTtcbiAgICB3ZWJjYW1JbWcuYWx0ID0gJ1dlYmNhbSBDYXB0dXJlJztcbiAgICB3ZWJjYW1JbWcuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIG1heC13aWR0aDogMzIwcHg7XG4gICAgICBtYXgtaGVpZ2h0OiAyNDBweDtcbiAgICAgIGJvcmRlcjogM3B4IHNvbGlkIHdoaXRlO1xuICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzMzMztcbiAgICBgO1xuICAgIFxuICAgIGNvbnN0IHdlYmNhbUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgd2ViY2FtTGFiZWwudGV4dENvbnRlbnQgPSAnV2ViY2FtIENhcHR1cmUnO1xuICAgIHdlYmNhbUxhYmVsLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBjb2xvcjogd2hpdGU7XG4gICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICBtYXJnaW4tdG9wOiAxMHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgYDtcbiAgICBcbiAgICB3ZWJjYW1QcmV2aWV3LmFwcGVuZENoaWxkKHdlYmNhbUltZyk7XG4gICAgd2ViY2FtUHJldmlldy5hcHBlbmRDaGlsZCh3ZWJjYW1MYWJlbCk7XG4gICAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3ZWJjYW1QcmV2aWV3KTtcbiAgfVxuICBcbiAgLy8gQWRkIHBvaW50IGluZm9cbiAgaWYgKHBvaW50KSB7XG4gICAgY29uc3QgcG9pbnRJbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcG9pbnRJbmZvLnRleHRDb250ZW50ID0gcG9pbnQubGFiZWwgPyBcbiAgICAgIGAke3BvaW50LmxhYmVsfTogeD0ke01hdGgucm91bmQocG9pbnQueCl9LCB5PSR7TWF0aC5yb3VuZChwb2ludC55KX1gIDpcbiAgICAgIGBQb2ludDogeD0ke01hdGgucm91bmQocG9pbnQueCl9LCB5PSR7TWF0aC5yb3VuZChwb2ludC55KX1gO1xuICAgICAgXG4gICAgcG9pbnRJbmZvLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBjb2xvcjogI2ZmY2MwMDtcbiAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgIHRvcDogLTQwcHg7XG4gICAgICBsZWZ0OiAwO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgYDtcbiAgICBwcmV2aWV3Q29udGFpbmVyLmFwcGVuZENoaWxkKHBvaW50SW5mbyk7XG4gIH1cbiAgXG4gIC8vIEFkZCB0aW1lclxuICBjb25zdCB0aW1lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGltZXJFbGVtZW50LnRleHRDb250ZW50ID0gJzIuMHMnO1xuICB0aW1lckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgYm90dG9tOiAtMjVweDtcbiAgICByaWdodDogMjBweDtcbiAgICBjb2xvcjogd2hpdGU7XG4gICAgZm9udC1zaXplOiAxMnB4O1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43KTtcbiAgICBwYWRkaW5nOiAzcHggOHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgYDtcbiAgcHJldmlld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aW1lckVsZW1lbnQpO1xuICBcbiAgLy8gQWRkIHRvIGRvY3VtZW50XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocHJldmlld0NvbnRhaW5lcik7XG4gIFxuICAvLyBDb3VudGRvd25cbiAgbGV0IHRpbWVMZWZ0ID0gMi4wO1xuICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICB0aW1lTGVmdCAtPSAwLjE7XG4gICAgaWYgKHRpbWVMZWZ0IDw9IDApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgcHJldmlld0NvbnRhaW5lci5zdHlsZS50cmFuc2l0aW9uID0gJ29wYWNpdHkgMC4zcyBlYXNlJztcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAocHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcHJldmlld0NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZpZXdDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aW1lckVsZW1lbnQudGV4dENvbnRlbnQgPSBgJHt0aW1lTGVmdC50b0ZpeGVkKDEpfXNgO1xuICAgIH1cbiAgfSwgMTAwKTtcbiAgXG4gIC8vIFNhZmV0eSBjbGVhbnVwXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGlmIChwcmV2aWV3Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgIHByZXZpZXdDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2aWV3Q29udGFpbmVyKTtcbiAgICB9XG4gIH0sIDUwMDApO1xufTtcblxuLyoqXG4gKiBSdW5zIGEgY291bnRkb3duIHByb2Nlc3MgdGhhdCBkaXNwbGF5cyAzLTItMSBhYm92ZSBhIGRvdFxuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0ge3gsIHl9IHBvc2l0aW9uIG9mIHRoZSBkb3RcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIGRvdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25TdGF0dXNVcGRhdGUgLSBGdW5jdGlvbiB0byB1cGRhdGUgc3RhdHVzIG1lc3NhZ2VzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkNvbXBsZXRlIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIGNvdW50ZG93biBjb21wbGV0ZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHJ1bkNvdW50ZG93biA9IGFzeW5jIChwb3NpdGlvbiwgY2FudmFzLCBvblN0YXR1c1VwZGF0ZSwgb25Db21wbGV0ZSkgPT4ge1xuICBpZiAoIXBvc2l0aW9uIHx8IHR5cGVvZiBwb3NpdGlvbi54ICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgcG9zaXRpb24ueSAhPT0gJ251bWJlcicpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tydW5Db3VudGRvd25dIEludmFsaWQgcG9zaXRpb246JywgcG9zaXRpb24pO1xuICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgcHJvY2Vzc1N0YXR1czogXCJJbnZhbGlkIGRvdCBwb3NpdGlvblwiLFxuICAgICAgY291bnRkb3duVmFsdWU6IG51bGwsXG4gICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gY3JlYXRlQ291bnRkb3duRWxlbWVudChwb3NpdGlvbiwgY2FudmFzUmVjdCk7XG4gIFxuICBpZiAoIWNvdW50ZG93bkVsZW1lbnQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tydW5Db3VudGRvd25dIENvdW50ZG93biBlbGVtZW50IGNvdWxkIG5vdCBiZSBjcmVhdGVkLicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cbiAgbGV0IGNvdW50ID0gMztcbiAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuXG4gIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgIHByb2Nlc3NTdGF0dXM6IFwiQ291bnRkb3duXCIsXG4gICAgY291bnRkb3duVmFsdWU6IGNvdW50LFxuICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gIH0pO1xuXG4gIC8vIENyZWF0ZSByZWRyYXdJbnRlcnZhbCBmb3Iga2VlcGluZyBkb3QgdmlzaWJsZSBkdXJpbmcgY291bnRkb3duXG4gIGxldCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgfSwgMjAwKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBjb3VudGRvd25JbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGNvdW50LS07XG5cbiAgICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoY291bnRkb3duSW50ZXJ2YWwpO1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcblxuICAgICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogXCJDYXB0dXJpbmcuLi5cIixcbiAgICAgICAgICBwcm9jZXNzU3RhdHVzOiBcIkNhcHR1cmluZyBpbWFnZS4uLlwiLFxuICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG5cbiAgICAgICAgICAvLyBDbGVhciB0aGUgcmVkcmF3SW50ZXJ2YWwgd2UgZGVmaW5lZCBhYm92ZVxuICAgICAgICAgIGlmIChyZWRyYXdJbnRlcnZhbCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAxMiwgZmFsc2UpO1xuICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG5cbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogXCJDb3VudGRvd25cIixcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwgODAwKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERyYXcgYSByZWQgZG90IG9uIHRoZSBjYW52YXNcbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBDYW52YXMgMkQgY29udGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gRG90IHJhZGl1c1xuICogQHBhcmFtIHtib29sZWFufSBjbGVhckNhbnZhcyAtIFdoZXRoZXIgdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZHJhd2luZyAoZGVmYXVsdDogdHJ1ZSlcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0ge3gsIHl9IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBkcmF3UmVkRG90ID0gKGN0eCwgeCwgeSwgcmFkaXVzID0gMTIsIGNsZWFyQ2FudmFzID0gdHJ1ZSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICBcbiAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBpZiByZXF1ZXN0ZWQgKGRlZmF1bHQgYmVoYXZpb3IpXG4gIGlmIChjbGVhckNhbnZhcykge1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfVxuICBcbiAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICBjdHguZmlsbCgpO1xuICBcbiAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICBjdHgubGluZVdpZHRoID0gMztcbiAgY3R4LnN0cm9rZSgpO1xuICBcbiAgLy8gQWRkIGEgc2Vjb25kIGxhcmdlciBnbG93IGZvciBldmVuIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4zKSc7XG4gIGN0eC5saW5lV2lkdGggPSAyO1xuICBjdHguc3Ryb2tlKCk7XG4gIFxuICByZXR1cm4geyB4LCB5IH07XG59O1xuXG4vKipcbiAqIEdldCBoaWdoZXN0IHJlc29sdXRpb24gY2FtZXJhIGNvbnN0cmFpbnRzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSAtIENhbWVyYSBjb25zdHJhaW50c1xuICovXG5jb25zdCBnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIC8vIEdldCBhbGwgdmlkZW8gaW5wdXQgZGV2aWNlc1xuICAgIGNvbnN0IGRldmljZXMgPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMoKTtcbiAgICBjb25zdCB2aWRlb0RldmljZXMgPSBkZXZpY2VzLmZpbHRlcihkZXZpY2UgPT4gZGV2aWNlLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgXG4gICAgaWYgKHZpZGVvRGV2aWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gdmlkZW8gZGV2aWNlcyBmb3VuZCwgdXNpbmcgZGVmYXVsdCBjb25zdHJhaW50cycpO1xuICAgICAgcmV0dXJuIHsgdmlkZW86IHRydWUgfTtcbiAgICB9XG4gICAgXG4gICAgLy8gVHJ5IHRvIGdldCBjYXBhYmlsaXRpZXMgZm9yIHRoZSBmaXJzdCB2aWRlbyBkZXZpY2VcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7IHZpZGVvOiB0cnVlIH0pO1xuICAgIGNvbnN0IHZpZGVvVHJhY2sgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKVswXTtcbiAgICBcbiAgICBpZiAoIXZpZGVvVHJhY2suZ2V0Q2FwYWJpbGl0aWVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2dldENhcGFiaWxpdGllcyBub3Qgc3VwcG9ydGVkLCB1c2luZyBkZWZhdWx0IGNvbnN0cmFpbnRzJyk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgcmV0dXJuIHsgdmlkZW86IHRydWUgfTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdmlkZW9UcmFjay5nZXRDYXBhYmlsaXRpZXMoKTtcbiAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgIFxuICAgIGlmICghY2FwYWJpbGl0aWVzLndpZHRoIHx8ICFjYXBhYmlsaXRpZXMuaGVpZ2h0KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ05vIHdpZHRoL2hlaWdodCBjYXBhYmlsaXRpZXMsIHVzaW5nIGRlZmF1bHQgY29uc3RyYWludHMnKTtcbiAgICAgIHJldHVybiB7IHZpZGVvOiB0cnVlIH07XG4gICAgfVxuICAgIFxuICAgIC8vIEdldCB0aGUgaGlnaGVzdCByZXNvbHV0aW9uIGF2YWlsYWJsZVxuICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5tYXgoLi4uY2FwYWJpbGl0aWVzLndpZHRoLnZhbHVlcyk7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5tYXgoLi4uY2FwYWJpbGl0aWVzLmhlaWdodC52YWx1ZXMpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBVc2luZyBoaWdoZXN0IHJlc29sdXRpb246ICR7bWF4V2lkdGh9eCR7bWF4SGVpZ2h0fWApO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB2aWRlbzoge1xuICAgICAgICB3aWR0aDogeyBpZGVhbDogbWF4V2lkdGggfSxcbiAgICAgICAgaGVpZ2h0OiB7IGlkZWFsOiBtYXhIZWlnaHQgfSxcbiAgICAgICAgZnJhbWVSYXRlOiB7IGlkZWFsOiAzMCB9XG4gICAgICB9XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGdldHRpbmcgY2FtZXJhIGNvbnN0cmFpbnRzLCB1c2luZyBkZWZhdWx0OicsIGVycm9yKTtcbiAgICByZXR1cm4geyB2aWRlbzogdHJ1ZSB9O1xuICB9XG59O1xuXG4vKipcbiAqIENhcHR1cmUgaW1hZ2VzIGF0IGEgc3BlY2lmaWMgcG9pbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQ2FwdHVyZSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgY2FwdHVyZSByZXN1bHRcbiAqL1xuZXhwb3J0IGNvbnN0IGNhcHR1cmVJbWFnZXMgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNhbnZhc1JlZixcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgY2FwdHVyZUNvdW50ZXIsIFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIGlmICghcG9zaXRpb24gfHwgdHlwZW9mIHBvc2l0aW9uLnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb3NpdGlvbi55ICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc29sZS53YXJuKCdbY2FwdHVyZUltYWdlc10gSW52YWxpZCBwb3NpdGlvbiBvYmplY3Q6JywgcG9zaXRpb24pO1xuICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKCdFcnJvcjogSW52YWxpZCBjYXB0dXJlIHBvc2l0aW9uJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIFxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgaGlnaGVzdCByZXNvbHV0aW9uIGNvbnN0cmFpbnRzXG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IGF3YWl0IGdldEhpZ2hlc3RSZXNvbHV0aW9uQ29uc3RyYWludHMoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdVc2luZyBjYW1lcmEgY29uc3RyYWludHM6JywgY29uc3RyYWludHMpO1xuICAgICAgXG4gICAgICAvLyBHZXQgYSBuZXcgc3RyZWFtIHdpdGggdGhlIGhpZ2hlc3QgcmVzb2x1dGlvblxuICAgICAgY29uc3Qgc3RyZWFtID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB2aWRlb1RyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICBjb25zb2xlLmxvZygnQWN0dWFsIGNhbWVyYSBzZXR0aW5nczonLCBzZXR0aW5ncyk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB2aWRlbyBlbGVtZW50IHdpdGggbmV3IHN0cmVhbVxuICAgICAgY29uc3QgdmlkZW9FbGVtZW50ID0gd2luZG93LnZpZGVvRWxlbWVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd2aWRlbycpO1xuICAgICAgaWYgKHZpZGVvRWxlbWVudCkge1xuICAgICAgICB2aWRlb0VsZW1lbnQuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICBhd2FpdCB2aWRlb0VsZW1lbnQucGxheSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxsIHRoZSBjYXB0dXJlSW1hZ2VzQXRQb2ludCB3aXRoIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICAgIGNhcHR1cmVDb3VudDogY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIGNhbnZhc1JlZiwgXG4gICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgfSk7XG4gIFxuICAgICAgY29uc29sZS5sb2coJ0NhcHR1cmUgc3VjY2Vzc2Z1bCB3aXRoIElEOicsIHJlc3VsdC5jYXB0dXJlSWQpO1xuICAgICAgXG4gICAgICAvLyBDbGVhbiB1cCB0aGUgc3RyZWFtXG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB0cmFjay5zdG9wKCkpO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogcmVzdWx0Py5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHJlc3VsdD8ud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIGNhcHR1cmVJZDogcmVzdWx0Py5jYXB0dXJlSWQsXG4gICAgICAgIHJlc29sdXRpb246IHtcbiAgICAgICAgICB3aWR0aDogc2V0dGluZ3Mud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBzZXR0aW5ncy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYXB0dXJlSW1hZ2VzXSBVbmV4cGVjdGVkIGVycm9yOicsIGVycik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oYEVycm9yOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NyZWVuSW1hZ2U6ICcnLFxuICAgICAgICB3ZWJjYW1JbWFnZTogJycsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLm1lc3NhZ2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgcmFuZG9tIGRvdCBwb3NpdGlvbiB3aXRoaW4gdGhlIGNhbnZhc1xuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gQ2FudmFzIGVsZW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nIC0gUGFkZGluZyBmcm9tIHRoZSBlZGdlc1xuICogQHJldHVybnMge09iamVjdH0gLSB7eCwgeX0gcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJhbmRvbVBvc2l0aW9uID0gKGNhbnZhcywgcGFkZGluZyA9IDQwKSA9PiB7XG4gIGlmICghY2FudmFzKSByZXR1cm4geyB4OiAxMDAsIHk6IDEwMCB9OyAvLyBGYWxsYmFjayBwb3NpdGlvblxuICBcbiAgY29uc3Qgd2lkdGggPSBjYW52YXMud2lkdGggfHwgNDAwOyAgLy8gRmFsbGJhY2sgaWYgd2lkdGggaXMgMFxuICBjb25zdCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0IHx8IDMwMDsgLy8gRmFsbGJhY2sgaWYgaGVpZ2h0IGlzIDBcbiAgXG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHdpZHRoIC0gMiAqIHBhZGRpbmcpKSArIHBhZGRpbmcsXG4gICAgeTogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGhlaWdodCAtIDIgKiBwYWRkaW5nKSkgKyBwYWRkaW5nXG4gIH07XG59O1xuXG4vKipcbiAqIFNwZWNpYWwgY2FsaWJyYXRpb24gY2FwdHVyZSBmdW5jdGlvbiB0aGF0IGJlaGF2ZXMgbGlrZSByYW5kb20gZG90IGNhcHR1cmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWxsIHRoZSBjYWxpYnJhdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fSBSZXN1bHQgb2JqZWN0IHdpdGggY2FwdHVyZWQgZGF0YVxuICovXG5leHBvcnQgY29uc3QgY2FsaWJyYXRpb25DYXB0dXJlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNSZWYsXG4gICAgICBwb2ludCxcbiAgICAgIGNhcHR1cmVDb3VudGVyLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICBzZXRQcm9jZXNzU3RhdHVzLFxuICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgY2FwdHVyZUZvbGRlciA9ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnLFxuICAgICAgcG9pbnRJbmRleCxcbiAgICAgIHRvdGFsUG9pbnRzXG4gICAgfSA9IG9wdGlvbnM7XG4gIFxuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZyhgU3RhcnRpbmcgY2FsaWJyYXRpb24gY2FwdHVyZSBmb3IgcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgICAgIFxuICAgICAgLy8gR2V0IGNhbnZhc1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FudmFzIHJlZmVyZW5jZSBpcyBudWxsIGluIGNhbGlicmF0aW9uQ2FwdHVyZVwiKTtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGVgKTtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICAgIH1cbiAgXG4gICAgICAvLyBVc2UgdGhlIGV4YWN0IHNhbWUgZHJhd2luZyBtZXRob2QgYXMgcmFuZG9tIGRvdHNcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnkpO1xuICBcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgQ2FsaWJyYXRpb24gcG9pbnQgJHtwb2ludEluZGV4ICsgMX0vJHt0b3RhbFBvaW50c31gKTtcbiAgXG4gICAgICAvLyBVc2UgdGhlIHNhbWUgY291bnRkb3duIGVsZW1lbnQgY3JlYXRpb24gbWV0aG9kXG4gICAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQocG9pbnQsIGNhbnZhc1JlY3QpO1xuICAgICAgXG4gICAgICBpZiAoIWNvdW50ZG93bkVsZW1lbnQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY291bnRkb3duIGVsZW1lbnRcIik7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlIH07XG4gICAgICB9XG4gIFxuICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgZm9yIGtlZXBpbmcgdGhlIGRvdCB2aXNpYmxlXG4gICAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCAxMiwgZmFsc2UpO1xuICAgICAgfSwgMjAwKTtcbiAgXG4gICAgICAvLyBSdW4gdGhlIHNhbWUgY291bnRkb3duIGFzIHJhbmRvbSBkb3RcbiAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKGBQb2ludCAke3BvaW50SW5kZXggKyAxfS8ke3RvdGFsUG9pbnRzfSAtIGNvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVkcmF3IHRoZSBkb3QgYXQgZWFjaCBzdGVwIHRvIGVuc3VyZSBpdCByZW1haW5zIHZpc2libGVcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIDEyLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICB9XG4gIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgXG4gICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbFxuICAgICAgICBpZiAocmVkcmF3SW50ZXJ2YWwpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgXG4gICAgICAvLyBVc2UgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIGluc3RlYWQgb2YgZGlyZWN0bHkgY2FsbGluZyBjYXB0dXJlSW1hZ2VzQXRQb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzcyh7XG4gICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgcG9zaXRpb246IHBvaW50LFxuICAgICAgICBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXM6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdHVzICYmIHR5cGVvZiBzdGF0dXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzPy4oc3RhdHVzLnByb2Nlc3NTdGF0dXMgfHwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyLFxuICAgICAgICBvblN0YXR1c1VwZGF0ZTogKHN0YXR1cykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cz8uKHN0YXR1cyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0dXMgJiYgdHlwZW9mIHN0YXR1cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihzdGF0dXMucHJvY2Vzc1N0YXR1cyB8fCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYXB0dXJlRm9sZGVyXG4gICAgICB9KTtcbiAgXG4gICAgICAvLyBFbnN1cmUgcHJvcGVyIHJldHVybiBldmVuIGlmIGNhcHR1cmVSZXN1bHQgaXMgbnVsbFxuICAgICAgY29uc3Qgc2FmZVJlc3VsdCA9IGNhcHR1cmVSZXN1bHQgJiYgdHlwZW9mIGNhcHR1cmVSZXN1bHQgPT09ICdvYmplY3QnIFxuICAgICAgICA/IGNhcHR1cmVSZXN1bHQgXG4gICAgICAgIDogeyBzY3JlZW5JbWFnZTogJycsIHdlYmNhbUltYWdlOiAnJywgc3VjY2VzczogZmFsc2UgfTtcbiAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogc2FmZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6IHNhZmVSZXN1bHQud2ViY2FtSW1hZ2UgfHwgJycsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvaW50XG4gICAgICB9O1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBjYWxpYnJhdGlvbkNhcHR1cmU6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXM/LihgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIFxuICAgICAgLy8gQWx3YXlzIHJldHVybiBhIHZhbGlkIG9iamVjdCB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY3JlZW5JbWFnZTogJycsXG4gICAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBDb21wbGV0ZSBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUHJvY2VzcyBvcHRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICBjb25zdCB7XG4gICAgY2FudmFzUmVmLFxuICAgIHBvc2l0aW9uLFxuICAgIGNhcHR1cmVDb3VudGVyLFxuICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgdG9nZ2xlVG9wQmFyLFxuICAgIG9uU3RhdHVzVXBkYXRlLFxuICAgIGNhcHR1cmVGb2xkZXJcbiAgfSA9IG9wdGlvbnM7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWY/LmN1cnJlbnQ7XG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBDYW52YXMgcmVmZXJlbmNlIGlzIG51bGxcIik7XG4gICAgICBpZiAoc2V0UHJvY2Vzc1N0YXR1cykgc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6IENhbnZhcyBpcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG5cbiAgICAvLyBDb3VudGRvd24gYmVmb3JlIGNhcHR1cmVcbiAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIG9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNvdW50ZG93bi4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBjdXN0b20gY291bnRkb3duIGVsZW1lbnRcbiAgICBjb25zdCBjYW52YXNSZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtY291bnRkb3duJztcbiAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICBsZWZ0OiAke2NhbnZhc1JlY3QubGVmdCArIHBvc2l0aW9uLnh9cHg7XG4gICAgICB0b3A6ICR7Y2FudmFzUmVjdC50b3AgKyBwb3NpdGlvbi55IC0gNjB9cHg7XG4gICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICBjb2xvcjogcmVkO1xuICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgei1pbmRleDogOTk5OTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICBgO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG5cbiAgICAvLyBDcmVhdGUgYSByZWRyYXdJbnRlcnZhbCBmb3Iga2VlcGluZyB0aGUgZG90IHZpc2libGVcbiAgICBsZXQgcmVkcmF3SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICB9LCAyMDApO1xuXG4gICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICBpZiAob25TdGF0dXNVcGRhdGUpIHtcbiAgICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDb3VudGRvd246ICR7Y291bnR9YCxcbiAgICAgICAgICBjb3VudGRvd25WYWx1ZTogY291bnQsXG4gICAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBSZWRyYXcgZG90IHRvIGVuc3VyZSBpdCdzIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2UgdG8gY2hlY2ttYXJrXG4gICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgaWYgKG9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICBvblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJpbmcgaW1hZ2VzLi4uJyxcbiAgICAgICAgY291bnRkb3duVmFsdWU6IFwiQ2FwdHVyaW5nLi4uXCIsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYW5kIGNsZWFyIHJlZHJhd0ludGVydmFsXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKHJlZHJhd0ludGVydmFsKSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH0sIDMwMCk7XG5cbiAgICAvLyBVc2UgY2FwdHVyZUltYWdlc0F0UG9pbnQgZnJvbSBzYXZlZmlsZS5qc1xuICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudGVyLFxuICAgICAgY2FudmFzUmVmLFxuICAgICAgc2V0Q2FwdHVyZUNvdW50OiBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgIH0pO1xuXG4gICAgaWYgKHNldFByb2Nlc3NTdGF0dXMpIHtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhcHR1cmVkIGRvdCBhdCB4PSR7TWF0aC5yb3VuZChwb3NpdGlvbi54KX0sIHk9JHtNYXRoLnJvdW5kKHBvc2l0aW9uLnkpfWApO1xuICAgIH1cblxuICAgIGlmIChvblN0YXR1c1VwZGF0ZSkge1xuICAgICAgb25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnQ2FwdHVyZSBjb21wbGV0ZScsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gd2l0aCBkZWxheVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB0b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICB9XG4gICAgfSwgMjUwMCk7XG5cbiAgICByZXR1cm4gY2FwdHVyZVJlc3VsdDtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJbY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXSBGYXRhbCBlcnJvcjpcIiwgZXJyb3IpO1xuICAgIFxuICAgIGlmIChzZXRQcm9jZXNzU3RhdHVzKSB7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBGYXRhbCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgVG9wQmFyIGlzIHNob3duIGV2ZW4gb24gZXJyb3JcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgIH0sIDE1MDApO1xuICAgIFxuICAgIC8vIFJldHVybiBhIG1pbmltYWwgdmFsaWQgb2JqZWN0IHRvIHByZXZlbnQgbnVsbCByZWZlcmVuY2UgZXJyb3JzXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgIHdlYmNhbUltYWdlOiAnJyxcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2VcbiAgICB9O1xuICB9XG59O1xuXG4vLyBEZWZhdWx0IGV4cG9ydCBmb3IgUmVhY3QgY29tcGF0aWJpbGl0eVxuY29uc3QgQ291bnRTYXZlID0gKCkgPT4gbnVsbDsgLy8gVGhpcyBpcyBhIHV0aWxpdHkgZmlsZSwgc28gd2UgZG9uJ3QgbmVlZCB0byByZW5kZXIgYW55dGhpbmdcblxuZXhwb3J0IGRlZmF1bHQgQ291bnRTYXZlOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsImNyZWF0ZUNvdW50ZG93bkVsZW1lbnQiLCJwb3NpdGlvbiIsImNhbnZhc1JlY3QiLCJ4IiwieSIsImNvbnNvbGUiLCJ3YXJuIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImVsIiwicmVtb3ZlIiwiYWJzb2x1dGVYIiwibGVmdCIsImFic29sdXRlWSIsInRvcCIsImNvdW50ZG93bkVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwiYm9keSIsImFwcGVuZENoaWxkIiwic2hvd0NhcHR1cmVQcmV2aWV3Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsInBvaW50IiwiZXhpc3RpbmdQcmV2aWV3cyIsInByZXZpZXciLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJwcmV2aWV3Q29udGFpbmVyIiwic2NyZWVuUHJldmlldyIsInNjcmVlbkltZyIsInNyYyIsImFsdCIsInNjcmVlbkxhYmVsIiwidGV4dENvbnRlbnQiLCJ3ZWJjYW1QcmV2aWV3Iiwid2ViY2FtSW1nIiwid2ViY2FtTGFiZWwiLCJwb2ludEluZm8iLCJsYWJlbCIsIk1hdGgiLCJyb3VuZCIsInRpbWVyRWxlbWVudCIsInRpbWVMZWZ0IiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJvcGFjaXR5IiwidHJhbnNpdGlvbiIsInNldFRpbWVvdXQiLCJ0b0ZpeGVkIiwicnVuQ291bnRkb3duIiwiY2FudmFzIiwib25TdGF0dXNVcGRhdGUiLCJvbkNvbXBsZXRlIiwicHJvY2Vzc1N0YXR1cyIsImNvdW50ZG93blZhbHVlIiwiaXNDYXB0dXJpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjdHgiLCJnZXRDb250ZXh0IiwiZHJhd1JlZERvdCIsImNvdW50IiwicmVkcmF3SW50ZXJ2YWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvdW50ZG93bkludGVydmFsIiwicmFkaXVzIiwiY2xlYXJDYW52YXMiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJnZXRIaWdoZXN0UmVzb2x1dGlvbkNvbnN0cmFpbnRzIiwiZGV2aWNlcyIsIm5hdmlnYXRvciIsIm1lZGlhRGV2aWNlcyIsImVudW1lcmF0ZURldmljZXMiLCJ2aWRlb0RldmljZXMiLCJmaWx0ZXIiLCJkZXZpY2UiLCJraW5kIiwibGVuZ3RoIiwidmlkZW8iLCJzdHJlYW0iLCJnZXRVc2VyTWVkaWEiLCJ2aWRlb1RyYWNrIiwiZ2V0VmlkZW9UcmFja3MiLCJnZXRDYXBhYmlsaXRpZXMiLCJnZXRUcmFja3MiLCJ0cmFjayIsInN0b3AiLCJjYXBhYmlsaXRpZXMiLCJtYXhXaWR0aCIsIm1heCIsInZhbHVlcyIsIm1heEhlaWdodCIsImxvZyIsImlkZWFsIiwiZnJhbWVSYXRlIiwiZXJyb3IiLCJjYXB0dXJlSW1hZ2VzIiwib3B0aW9ucyIsImNhbnZhc1JlZiIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzZXRQcm9jZXNzU3RhdHVzIiwidG9nZ2xlVG9wQmFyIiwiY2FwdHVyZUZvbGRlciIsImNvbnN0cmFpbnRzIiwic2V0dGluZ3MiLCJnZXRTZXR0aW5ncyIsInZpZGVvRWxlbWVudCIsIndpbmRvdyIsInF1ZXJ5U2VsZWN0b3IiLCJzcmNPYmplY3QiLCJwbGF5IiwicmVzdWx0IiwiY2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50IiwiY2FwdHVyZUlkIiwic3VjY2VzcyIsInJlc29sdXRpb24iLCJlcnIiLCJtZXNzYWdlIiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJwYWRkaW5nIiwiZmxvb3IiLCJyYW5kb20iLCJjYWxpYnJhdGlvbkNhcHR1cmUiLCJwb2ludEluZGV4IiwidG90YWxQb2ludHMiLCJjdXJyZW50IiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVBbmRQcmV2aWV3UHJvY2VzcyIsInN0YXR1cyIsInNhZmVSZXN1bHQiLCJDb3VudFNhdmUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx\n"));

/***/ }),

/***/ "(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js":
/*!***************************************************************************!*\
  !*** ./pages/collected-dataset-customized/components-gui/actionButton.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActionButton: () => (/* binding */ ActionButton),\n/* harmony export */   ActionButtonGroup: () => (/* binding */ ActionButtonGroup),\n/* harmony export */   \"default\": () => (/* binding */ ActionButtonPage)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(pages-dir-browser)/./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dynamic */ \"(pages-dir-browser)/./node_modules/next/dynamic.js\");\n/* harmony import */ var next_dynamic__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dynamic__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Action/countSave.jsx */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.jsx\");\n/* harmony import */ var _components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../components/collected-dataset-customized/Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! next/router */ \"(pages-dir-browser)/./node_modules/next/router.js\");\n/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _adminSettings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./adminSettings */ \"(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/adminSettings.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\n\n\n\n// Add deep comparison utility\nconst isEqual = (obj1, obj2)=>{\n    if (obj1 === obj2) return true;\n    if (typeof obj1 !== 'object' || typeof obj2 !== 'object') return false;\n    if (obj1 === null || obj2 === null) return false;\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    return keys1.every((key)=>keys2.includes(key) && isEqual(obj1[key], obj2[key]));\n};\n// Create a basic ActionButton component with optimization\nconst ActionButton = (param)=>{\n    let { text, abbreviatedText, onClick, customClass = '', disabled = false, active = false } = param;\n    _s();\n    const [isAbbreviated, setIsAbbreviated] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { settings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)();\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [captureCounter, setCaptureCounter1] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    // Memoize button props to prevent unnecessary re-renders\n    const buttonProps = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButton.useMemo[buttonProps]\": ()=>({\n                className: \"action-button \".concat(customClass, \" \").concat(isAbbreviated ? 'abbreviated' : '', \" \").concat(active ? 'active' : ''),\n                onClick,\n                disabled,\n                title: text\n            })\n    }[\"ActionButton.useMemo[buttonProps]\"], [\n        customClass,\n        isAbbreviated,\n        active,\n        onClick,\n        disabled,\n        text\n    ]);\n    // Check window size and set abbreviated mode with debounce\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            if (false) {}\n            let timeoutId;\n            const handleResize = {\n                \"ActionButton.useEffect.handleResize\": ()=>{\n                    clearTimeout(timeoutId);\n                    timeoutId = setTimeout({\n                        \"ActionButton.useEffect.handleResize\": ()=>{\n                            const width = window.innerWidth;\n                            setIsAbbreviated(width < 768);\n                        }\n                    }[\"ActionButton.useEffect.handleResize\"], 100);\n                }\n            }[\"ActionButton.useEffect.handleResize\"];\n            window.addEventListener('resize', handleResize);\n            handleResize(); // Initial call\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('resize', handleResize);\n                    clearTimeout(timeoutId);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], []);\n    // Add effect to listen for user ID changes with optimization\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButton.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButton.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        if (newUserId !== currentUserId) {\n                            setCurrentUserId(newUserId);\n                        }\n                    }\n                }\n            }[\"ActionButton.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButton.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButton.useEffect\"];\n        }\n    }[\"ActionButton.useEffect\"], [\n        currentUserId\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n        ...buttonProps,\n        children: [\n            isAbbreviated ? abbreviatedText : text,\n            processStatus && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"process-status\",\n                children: processStatus\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 88,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ActionButton, \"Nkz1GO/Uf3mvhA1uh+EhQBsi9aE=\", false, function() {\n    return [\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n});\n_c = ActionButton;\n// Create the ActionButtonGroup component with client-side only rendering and optimization\nconst ActionButtonGroupInner = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(_s1((param, ref)=>{\n    let { triggerCameraAccess, isCompactMode, onActionClick } = param;\n    _s1();\n    const router = (0,next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter)();\n    const { settings, updateSettings } = (0,_adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings)(ref);\n    // State for button actions\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(3);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [processStatus, setProcessStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('');\n    const [countdownValue, setCountdownValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [currentDot, setCurrentDot] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [calibrationPoints, setCalibrationPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [remainingCaptures, setRemainingCaptures] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [showCanvas, setShowCanvas] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    // Track the capture count\n    const [calibrationHandler, setCalibrationHandler] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [captureCount, setCaptureCount] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Toggle states\n    const [showHeadPose, setShowHeadPose] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showBoundingBox, setShowBoundingBox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showMask, setShowMask] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showParameters, setShowParameters] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [isCameraActive, setIsCameraActive] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [showPermissionPopup, setShowPermissionPopup] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [currentUserId, setCurrentUserId] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)('default');\n    // Add cache for settings\n    const settingsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    const lastSettingsUpdate = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Map());\n    // Global canvas manager instance - initialize only once\n    const canvasManager = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[canvasManager]\": ()=>new CanvasManager()\n    }[\"ActionButtonGroupInner.useMemo[canvasManager]\"], []);\n    // Replace the complex canvas functions with simplified versions\n    const getMainCanvas = ()=>{\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    };\n    const ensureCanvasExists = ()=>{\n        return canvasManager.createCanvas();\n    };\n    const restoreCanvasToContainer = (canvas)=>{\n        canvasManager.exitFullscreen();\n    };\n    const cleanupCanvas = ()=>{\n        canvasManager.destroy();\n    };\n    const clearCanvas = ()=>{\n        canvasManager.clear();\n    };\n    // Utility function to easily manage canvas operations\n    const canvasUtils = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>({\n                // Get or create canvas\n                getCanvas: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>canvasManager.getCanvas() || canvasManager.createCanvas()\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Enter fullscreen mode\n                enterFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.enterFullscreen();\n                        return canvasManager.getCanvas();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Exit fullscreen mode\n                exitFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.exitFullscreen();\n                        return canvasManager.getCanvas();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Clear canvas\n                clear: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        canvasManager.clear();\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Draw dot at position\n                drawDot: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": function(x, y) {\n                        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas) return false;\n                        const ctx = canvas.getContext('2d');\n                        (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, x, y, radius, false);\n                        return true;\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Get canvas dimensions\n                getDimensions: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>{\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas) return {\n                            width: 0,\n                            height: 0\n                        };\n                        return {\n                            width: canvas.width,\n                            height: canvas.height\n                        };\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Check if canvas is in fullscreen\n                isFullscreen: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": ()=>canvasManager.isInFullscreen()\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"],\n                // Update canvas size to match container\n                resizeToContainer: ({\n                    \"ActionButtonGroupInner.useMemo[canvasUtils]\": (container)=>{\n                        const canvas = canvasManager.getCanvas();\n                        if (!canvas || !container) return false;\n                        const rect = container.getBoundingClientRect();\n                        canvas.width = rect.width || container.clientWidth || 800;\n                        canvas.height = rect.height || container.clientHeight || 600;\n                        // Clear and redraw white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        return true;\n                    }\n                })[\"ActionButtonGroupInner.useMemo[canvasUtils]\"]\n            })\n    }[\"ActionButtonGroupInner.useMemo[canvasUtils]\"], []);\n    // Make canvas utilities globally available\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (true) {\n                window.canvasUtils = canvasUtils;\n                window.canvasManager = canvasManager;\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.canvasUtils;\n                        delete window.canvasManager;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        canvasUtils,\n        canvasManager\n    ]);\n    // Optimize settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (settings && currentUserId && settings[currentUserId]) {\n                const userSettings = settings[currentUserId];\n                const cachedSettings = settingsCache.current.get(currentUserId);\n                if (!isEqual(cachedSettings, userSettings)) {\n                    setRandomTimes(Number(userSettings.times_set_random) || 1);\n                    setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                    settingsCache.current.set(currentUserId, userSettings);\n                    lastSettingsUpdate.current.set(currentUserId, Date.now());\n                }\n            }\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings,\n        currentUserId\n    ]);\n    // Listen for user ID changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleUserIdChange = {\n                \"ActionButtonGroupInner.useEffect.handleUserIdChange\": (event)=>{\n                    if (event.detail && event.detail.type === 'userIdChange') {\n                        const newUserId = event.detail.userId;\n                        setCurrentUserId(newUserId);\n                        // Update settings for new user\n                        if (settings && settings[newUserId]) {\n                            const userSettings = settings[newUserId];\n                            setRandomTimes(Number(userSettings.times_set_random) || 1);\n                            setDelaySeconds(Number(userSettings.delay_set_random) || 3);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleUserIdChange\"];\n            window.addEventListener('userIdChange', handleUserIdChange);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('userIdChange', handleUserIdChange);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        settings\n    ]);\n    // Listen for settings updates\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            const handleSettingsUpdate = {\n                \"ActionButtonGroupInner.useEffect.handleSettingsUpdate\": (event)=>{\n                    if (event.detail && event.detail.type === 'captureSettings') {\n                        const { userId, times_set_random, delay_set_random } = event.detail;\n                        if (userId === currentUserId) {\n                            if (times_set_random !== undefined) {\n                                const newTimes = Number(times_set_random) || 1;\n                                setRandomTimes(newTimes);\n                            }\n                            if (delay_set_random !== undefined) {\n                                const newDelay = Number(delay_set_random) || 3;\n                                setDelaySeconds(newDelay);\n                            }\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.handleSettingsUpdate\"];\n            window.addEventListener('captureSettingsUpdate', handleSettingsUpdate);\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    window.removeEventListener('captureSettingsUpdate', handleSettingsUpdate);\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        currentUserId\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Make functions globally accessible as a fallback\n            if (true) {\n                window.actionButtonFunctions = {\n                    handleRandomDot,\n                    handleSetRandom,\n                    handleSetCalibrate,\n                    handleClearAll\n                };\n            // console.log('Action button functions exposed to window.actionButtonFunctions');\n            }\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (true) {\n                        delete window.actionButtonFunctions;\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Only initialize if canvas doesn't exist\n            if (!document.querySelector('#tracking-canvas')) {\n                const canvas = getMainCanvas();\n                console.log('Canvas initialized:', canvas ? 'success' : 'failed');\n            }\n            // Cleanup function\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    // Don't remove canvas on cleanup to prevent recreation issues\n                    console.log('ActionButton cleanup - canvas preserved');\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            // Function to get control values from TopBar\n            const updateControlValues = {\n                \"ActionButtonGroupInner.useEffect.updateControlValues\": ()=>{\n                    // Get the time input element\n                    const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                    if (timeInput) {\n                        const timeValue = parseInt(timeInput.value, 10);\n                        if (!isNaN(timeValue) && timeValue > 0) {\n                            console.log('Updating randomTimes to:', timeValue);\n                            setRandomTimes(timeValue);\n                        }\n                    }\n                    // Get the delay input element\n                    const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                    if (delayInput) {\n                        const delayValue = parseInt(delayInput.value, 10);\n                        if (!isNaN(delayValue) && delayValue > 0) {\n                            console.log('Updating delaySeconds to:', delayValue);\n                            setDelaySeconds(delayValue);\n                        }\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.updateControlValues\"];\n            // Add event listeners to the control inputs\n            const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n            const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n            if (timeInput) {\n                timeInput.addEventListener('change', updateControlValues);\n                timeInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            if (delayInput) {\n                delayInput.addEventListener('change', updateControlValues);\n                delayInput.addEventListener('input', updateControlValues); // Also listen for input events\n            }\n            // Initial update\n            updateControlValues();\n            // Cleanup event listeners\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    if (timeInput) {\n                        timeInput.removeEventListener('change', updateControlValues);\n                        timeInput.removeEventListener('input', updateControlValues);\n                    }\n                    if (delayInput) {\n                        delayInput.removeEventListener('change', updateControlValues);\n                        delayInput.removeEventListener('input', updateControlValues);\n                    }\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Initialize canvas on component mount\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            // Canvas is now managed by CanvasManager\n            const canvas = getMainCanvas();\n            console.log('Canvas initialized:', canvas ? 'success' : 'failed');\n            return ({\n                \"ActionButtonGroupInner.useEffect\": ()=>{\n                    // Cleanup is handled by CanvasManager\n                    console.log('ActionButton cleanup - canvas preserved');\n                }\n            })[\"ActionButtonGroupInner.useEffect\"];\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], []);\n    // Canvas Manager - Simplified and centralized\n    class CanvasManager {\n        // Create or get canvas with automatic sizing\n        createCanvas() {\n            let container = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;\n            // Try to find existing canvas first\n            let canvas = document.querySelector('#tracking-canvas');\n            if (!canvas) {\n                canvas = document.createElement('canvas');\n                canvas.className = 'tracking-canvas';\n                canvas.id = 'tracking-canvas';\n            }\n            // Determine container\n            const targetContainer = container || document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            // Set initial dimensions based on container\n            this.updateCanvasSize(canvas, targetContainer);\n            // Initialize with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Add to container if not already there\n            if (!canvas.parentNode) {\n                targetContainer.appendChild(canvas);\n            }\n            // Store reference\n            this.canvas = canvas;\n            window.whiteScreenCanvas = canvas;\n            // Set up responsive behavior\n            this.setupResponsiveCanvas(canvas, targetContainer);\n            console.log(\"Canvas created/updated: \".concat(canvas.width, \"x\").concat(canvas.height));\n            return canvas;\n        }\n        // Update canvas size to match container\n        updateCanvasSize(canvas, container) {\n            if (!canvas || !container) return;\n            const rect = container.getBoundingClientRect();\n            const width = rect.width || container.clientWidth || 800;\n            const height = rect.height || container.clientHeight || 600;\n            canvas.width = width;\n            canvas.height = height;\n            // Update CSS to match\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.display = 'block';\n            canvas.style.backgroundColor = 'white';\n        }\n        // Set up responsive canvas that adapts to container size\n        setupResponsiveCanvas(canvas, container) {\n            if (!canvas || !container) return;\n            // Remove existing resize observer\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            // Create new resize observer\n            this.resizeObserver = new ResizeObserver((entries)=>{\n                for (const entry of entries){\n                    if (entry.target === container) {\n                        this.updateCanvasSize(canvas, container);\n                        // Redraw white background after resize\n                        const ctx = canvas.getContext('2d');\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    }\n                }\n            });\n            // Observe container for size changes\n            this.resizeObserver.observe(container);\n            // Also listen for window resize as fallback\n            const handleWindowResize = ()=>{\n                this.updateCanvasSize(canvas, container);\n                const ctx = canvas.getContext('2d');\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            };\n            window.addEventListener('resize', handleWindowResize);\n            canvas._windowResizeHandler = handleWindowResize;\n        }\n        // Switch to fullscreen mode\n        enterFullscreen() {\n            if (!this.canvas) {\n                this.canvas = this.createCanvas();\n            }\n            // Save original state\n            this.originalState = {\n                parent: this.canvas.parentElement,\n                position: this.canvas.style.position,\n                top: this.canvas.style.top,\n                left: this.canvas.style.left,\n                width: this.canvas.style.width,\n                height: this.canvas.style.height,\n                zIndex: this.canvas.style.zIndex\n            };\n            // Move to body and make fullscreen\n            document.body.appendChild(this.canvas);\n            // Set fullscreen styles\n            this.canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        z-index: 99999;\\n        background-color: white;\\n        border: none;\\n        display: block;\\n        opacity: 1;\\n        pointer-events: auto;\\n        margin: 0;\\n        padding: 0;\\n        box-sizing: border-box;\\n      \";\n            // Set canvas dimensions to window size\n            this.canvas.width = window.innerWidth;\n            this.canvas.height = window.innerHeight;\n            // Clear with white background\n            const ctx = this.canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Hide UI elements\n            this.hideUIElements();\n            this.isFullscreen = true;\n            console.log('Canvas entered fullscreen mode');\n        }\n        // Exit fullscreen mode\n        exitFullscreen() {\n            if (!this.canvas || !this.originalState) return;\n            // Show UI elements\n            this.showUIElements();\n            // Find appropriate container\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            // Move canvas back to container\n            container.appendChild(this.canvas);\n            // Restore original styles\n            this.canvas.style.position = 'relative';\n            this.canvas.style.top = '';\n            this.canvas.style.left = '';\n            this.canvas.style.width = '100%';\n            this.canvas.style.height = '100%';\n            this.canvas.style.zIndex = '';\n            this.canvas.style.backgroundColor = 'white';\n            // Update size to match container\n            this.updateCanvasSize(this.canvas, container);\n            // Clear with white background\n            const ctx = this.canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n            // Clear original state\n            this.originalState = null;\n            this.isFullscreen = false;\n            console.log('Canvas exited fullscreen mode');\n        }\n        // Hide UI elements during fullscreen\n        hideUIElements() {\n            const elementsToHide = [\n                '.topbar',\n                '.canvas-container',\n                '.main-content',\n                '.metrics-panel',\n                '.display-metrics',\n                'nav',\n                'header',\n                '.button-groups',\n                '.control-buttons'\n            ];\n            elementsToHide.forEach((selector)=>{\n                const elements = document.querySelectorAll(selector);\n                elements.forEach((el)=>{\n                    el.style.display = 'none';\n                    el.setAttribute('data-hidden-by-canvas', 'true');\n                });\n            });\n        }\n        // Show UI elements after fullscreen\n        showUIElements() {\n            const hiddenElements = document.querySelectorAll('[data-hidden-by-canvas=\"true\"]');\n            hiddenElements.forEach((el)=>{\n                el.style.display = '';\n                el.removeAttribute('data-hidden-by-canvas');\n            });\n        }\n        // Clear canvas content\n        clear() {\n            if (!this.canvas) return;\n            const ctx = this.canvas.getContext('2d');\n            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        }\n        // Cleanup\n        destroy() {\n            if (this.resizeObserver) {\n                this.resizeObserver.disconnect();\n            }\n            if (this.canvas && this.canvas._windowResizeHandler) {\n                window.removeEventListener('resize', this.canvas._windowResizeHandler);\n            }\n            if (this.canvas && this.canvas.parentNode) {\n                this.canvas.parentNode.removeChild(this.canvas);\n            }\n            if (window.whiteScreenCanvas === this.canvas) {\n                delete window.whiteScreenCanvas;\n            }\n            this.canvas = null;\n            this.originalState = null;\n            this.isFullscreen = false;\n        }\n        // Get current canvas\n        getCanvas() {\n            return this.canvas;\n        }\n        // Check if canvas is in fullscreen mode\n        isInFullscreen() {\n            return this.isFullscreen;\n        }\n        constructor(){\n            this.canvas = null;\n            this.originalState = null;\n            this.resizeObserver = null;\n            this.isFullscreen = false;\n        }\n    }\n    // Modified handleDotProcess function with improved dot and countdown alignment\n    // Complete handleDotProcess function with proper canvas management\n    const handleDotProcess = async (options)=>{\n        const { position, onStatusUpdate, toggleTopBar, triggerCameraAccess, setIsCapturing, captureCount, setCaptureCount, useRandomPosition = false, postCountdownDelay = 500 } = options;\n        let canvas = null;\n        let keepDotVisibleInterval = null;\n        let countdownElement = null;\n        try {\n            // Hide the TopBar before showing the dot\n            if (typeof toggleTopBar === 'function') {\n                toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            // Set capturing state\n            setIsCapturing(true);\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: useRandomPosition ? 'Generating random dot...' : 'Starting dot process...',\n                isCapturing: true\n            });\n            // Wait for UI updates to take effect\n            await new Promise((resolve)=>setTimeout(resolve, 200));\n            // Use ensureCanvasExists to get or create canvas\n            canvas = ensureCanvasExists();\n            if (!canvas) {\n                throw new Error(\"Failed to create or find canvas\");\n            }\n            // Canvas is already set to fullscreen by ensureCanvasExists\n            const canvasWidth = canvas.width;\n            const canvasHeight = canvas.height;\n            // Get context and clear canvas with white background\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvasWidth, canvasHeight);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvasWidth, canvasHeight);\n            // Get position for the dot - either use provided position or generate random one\n            const dotPosition = useRandomPosition ? (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.getRandomPosition)(canvas, 20) : position;\n            if (!dotPosition || typeof dotPosition.x !== 'number' || typeof dotPosition.y !== 'number') {\n                throw new Error(\"Invalid dot position\");\n            }\n            // Draw the dot\n            const dotRadius = 12;\n            (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Create a redraw interval to ensure dot stays visible\n            keepDotVisibleInterval = setInterval(()=>{\n                (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }, 50); // More frequent updates for reliability\n            // Remove any existing countdown elements\n            const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            existingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Create a countdown element directly on top of the dot\n            countdownElement = document.createElement('div');\n            countdownElement.className = 'dot-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(dotPosition.x, \"px;\\n        top: \").concat(dotPosition.y, \"px;\\n        transform: translate(-50%, -50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 10000;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Manual countdown\n            for(let count = 3; count > 0; count--){\n                countdownElement.textContent = count;\n                onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                    processStatus: \"Countdown: \".concat(count),\n                    countdownValue: count,\n                    isCapturing: true\n                });\n                // Redraw the dot for reliability\n                (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n                // Additional redraw during countdown to ensure visibility\n                (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            }\n            // Show checkmark\n            countdownElement.textContent = \"✓\";\n            // Make sure dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Remove countdown element after delay\n            setTimeout(()=>{\n                if (countdownElement && countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Wait after countdown completes\n            await new Promise((resolve)=>setTimeout(resolve, postCountdownDelay));\n            // Ensure the dot is still visible\n            (0,_components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.drawRedDot)(ctx, dotPosition.x, dotPosition.y, dotRadius, false);\n            // Capture images at this point\n            const captureResult = await (0,_components_collected_dataset_customized_Helper_savefile__WEBPACK_IMPORTED_MODULE_5__.captureImagesAtPoint)({\n                point: dotPosition,\n                captureCount: captureCount,\n                canvasRef: {\n                    current: canvas\n                },\n                setCaptureCount: setCaptureCount,\n                showCapturePreview: _components_collected_dataset_customized_Action_countSave_jsx__WEBPACK_IMPORTED_MODULE_4__.showCapturePreview\n            });\n            // Update status\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: 'Capture completed',\n                isCapturing: false\n            });\n            return {\n                success: true,\n                position: dotPosition,\n                captureResult\n            };\n        } catch (error) {\n            console.error(\"Error in handleDotProcess:\", error);\n            onStatusUpdate === null || onStatusUpdate === void 0 ? void 0 : onStatusUpdate({\n                processStatus: \"Error: \".concat(error.message),\n                isCapturing: false\n            });\n            return {\n                success: false,\n                error: error.message\n            };\n        } finally{\n            // Clear redraw interval first\n            if (keepDotVisibleInterval) {\n                clearInterval(keepDotVisibleInterval);\n                keepDotVisibleInterval = null;\n            }\n            // Remove countdown element if it still exists\n            if (countdownElement && countdownElement.parentNode) {\n                countdownElement.parentNode.removeChild(countdownElement);\n            }\n            // Remove any remaining countdown elements\n            const remainingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n            remainingCountdowns.forEach((el)=>{\n                if (el.parentNode) el.parentNode.removeChild(el);\n            });\n            // Use restoreCanvasToContainer to properly restore canvas\n            if (canvas) {\n                restoreCanvasToContainer(canvas);\n            }\n            // Show TopBar again after a delay\n            setTimeout(()=>{\n                if (typeof toggleTopBar === 'function') {\n                    toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1000);\n        }\n    };\n    const handleSetCalibrate = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Ensure canvas is initialized first\n            const canvas = getMainCanvas();\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            // Import and use SetCalibrateAction\n            const { default: SetCalibrateAction } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_SetCalibrateAction_jsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/SetCalibrateAction.jsx */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\"));\n            const setCalibrateAction = new SetCalibrateAction({\n                canvasRef: {\n                    current: canvas\n                },\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                setIsCapturing,\n                setProcessStatus,\n                setCurrentDot,\n                triggerCameraAccess,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                },\n                saveImageToServer: true,\n                setCaptureCounter,\n                captureCounter: captureCount\n            });\n            await setCalibrateAction.handleSetCalibrate();\n        } catch (error) {\n            console.error(\"Calibration error:\", error);\n            setProcessStatus(\"Calibration error: \".concat(error.message));\n            setIsCapturing(false);\n        }\n    };\n    const handleSetRandom = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Import and use SetRandomAction\n            const { default: SetRandomAction } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_SetRandomAction_jsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/SetRandomAction.jsx */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/SetRandomAction.jsx\"));\n            const setRandomAction = new SetRandomAction({\n                canvasRef,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                    if (status.remainingCaptures !== undefined) setRemainingCaptures(status.remainingCaptures);\n                },\n                setCaptureCounter,\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                captureCounter: captureCount,\n                triggerCameraAccess\n            });\n            await setRandomAction.handleAction();\n        } catch (error) {\n            console.error(\"Random sequence error:\", error);\n            setProcessStatus(\"Random sequence failed: \".concat(error.message));\n            setIsCapturing(false);\n        }\n    };\n    const handleRandomDot = async ()=>{\n        if (isCapturing) return;\n        try {\n            // Import and use RandomDotAction\n            const { default: RandomDotAction } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_RandomDotAction_jsx\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/RandomDotAction.jsx */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx\"));\n            const randomDotAction = new RandomDotAction({\n                canvasRef,\n                toggleTopBar: (show)=>{\n                    if (typeof onActionClick === 'function') {\n                        onActionClick('toggleTopBar', show);\n                    }\n                },\n                setIsCapturing,\n                setProcessStatus,\n                setCurrentDot,\n                triggerCameraAccess,\n                onStatusUpdate: (status)=>{\n                    if (status.processStatus) setProcessStatus(status.processStatus);\n                    if (status.isCapturing !== undefined) setIsCapturing(status.isCapturing);\n                },\n                saveImageToServer: true,\n                setCaptureCounter,\n                captureCounter: captureCount\n            });\n            await randomDotAction.handleRandomDot();\n        } catch (error) {\n            console.error('Random dot error:', error);\n            setProcessStatus(\"Error: \".concat(error.message));\n            setIsCapturing(false);\n        }\n    };\n    // Load calibration setup\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ActionButtonGroupInner.useEffect\": ()=>{\n            if (false) {}\n            const setupCalibration = {\n                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                    try {\n                        const { default: CalibrateHandler } = await __webpack_require__.e(/*! import() */ \"_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js\").then(__webpack_require__.bind(__webpack_require__, /*! ../../../components/collected-dataset-customized/Action/CalibrateHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\"));\n                        const canvas = getMainCanvas();\n                        if (!canvas) {\n                            console.warn(\"Canvas not available during setupCalibration\");\n                            return;\n                        }\n                        if (canvas) {\n                            makeCanvasFullscreen(canvas);\n                        }\n                        // console.log('Canvas size:', canvas.width, canvas.height);\n                        const points = (0,_components_collected_dataset_customized_Action_CalibratePoints__WEBPACK_IMPORTED_MODULE_3__.generateCalibrationPoints)(canvas.width, canvas.height);\n                        // console.log('Generated calibration points:', points);\n                        setCalibrationPoints(points);\n                        const calibrateHandler = new CalibrateHandler({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            calibrationPoints: points,\n                            toggleTopBar: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (show)=>onActionClick === null || onActionClick === void 0 ? void 0 : onActionClick('toggleTopBar', show)\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            setOutputText: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (status)=>{\n                                    setProcessStatus(status);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureCounter: captureCount,\n                            setCaptureCounter: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": (newCounter)=>{\n                                    if (typeof newCounter === 'function') {\n                                        setCaptureCount({\n                                            \"ActionButtonGroupInner.useEffect.setupCalibration\": (prev)=>newCounter(prev)\n                                        }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]);\n                                    } else {\n                                        setCaptureCount(newCounter);\n                                    }\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"],\n                            captureFolder: 'eye_tracking_captures',\n                            onComplete: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": ()=>{\n                                    setIsCapturing(false);\n                                    setProcessStatus('Calibration completed');\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        setCalibrationHandler({\n                            handleAction: {\n                                \"ActionButtonGroupInner.useEffect.setupCalibration\": async ()=>{\n                                    setIsCapturing(true);\n                                    setProcessStatus('Starting calibration...');\n                                    await calibrateHandler.startCalibration();\n                                    setIsCapturing(false);\n                                }\n                            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"]\n                        });\n                        if (canvas) {\n                            restoreCanvasSize(canvas);\n                        }\n                    } catch (err) {\n                        console.error('Error initializing calibration:', err);\n                    }\n                }\n            }[\"ActionButtonGroupInner.useEffect.setupCalibration\"];\n            setupCalibration();\n        }\n    }[\"ActionButtonGroupInner.useEffect\"], [\n        captureCount,\n        onActionClick\n    ]);\n    // Clear All Button - Reset everything\n    const handleClearAll = ()=>{\n        // Clear canvas content\n        const canvas = document.querySelector('#tracking-canvas');\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Restore canvas to container mode\n            restoreCanvasToContainer(canvas);\n        }\n        // Reset states\n        setProcessStatus('');\n        setRemainingCaptures(0);\n        setIsCapturing(false);\n        setCountdownValue(null);\n        setShowCanvas(true);\n        setCurrentDot(null);\n    };\n    // Toggle Head Pose visualization\n    const handleToggleHeadPose = ()=>{\n        const newHeadPoseState = !showHeadPose;\n        setShowHeadPose(newHeadPoseState);\n        setProcessStatus(\"Head pose visualization \".concat(newHeadPoseState ? 'enabled' : 'disabled'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('headPose');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showHeadPose: newHeadPoseState\n            });\n        // console.log(`Updated backend head pose: ${newHeadPoseState}`);\n        }\n    };\n    // Toggle Bounding Box visualization\n    const handleToggleBoundingBox = ()=>{\n        const newBoundingBoxState = !showBoundingBox;\n        setShowBoundingBox(newBoundingBoxState);\n        setProcessStatus(\"Bounding box \".concat(newBoundingBoxState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('boundingBox');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showBoundingBox: newBoundingBoxState\n            });\n        // console.log(`Updated backend bounding box: ${newBoundingBoxState}`);\n        }\n    };\n    // Toggle Mask visualization\n    const handleToggleMask = ()=>{\n        const newMaskState = !showMask;\n        setShowMask(newMaskState);\n        setProcessStatus(\"Mask \".concat(newMaskState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('mask');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showMask: newMaskState\n            });\n        // console.log(`Updated backend mask: ${newMaskState}`);\n        }\n    };\n    // Toggle Parameters display\n    const handleToggleParameters = ()=>{\n        const newParametersState = !showParameters;\n        setShowParameters(newParametersState);\n        setProcessStatus(\"Parameters \".concat(newParametersState ? 'shown' : 'hidden'));\n        // Call the parent handler to update processor options\n        if (onActionClick) {\n            onActionClick('parameters');\n        }\n        // Update videoProcessor options directly if available\n        if ( true && window.videoProcessor) {\n            window.videoProcessor.updateOptions({\n                showParameters: newParametersState\n            });\n        // console.log(`Updated backend parameters: ${newParametersState}`);\n        }\n    };\n    // Toggle camera preview\n    const handleToggleCamera = ()=>{\n        const newCameraState = !isCameraActive;\n        setIsCameraActive(newCameraState);\n        // Call the parent handler with 'preview' action\n        if (onActionClick) {\n            onActionClick('preview', newCameraState); // Pass the new state\n        } else {\n            // Fallback to direct trigger if no action handler\n            setShowPermissionPopup(true);\n        }\n        // If turning on camera, ensure we apply current visualization settings\n        if (newCameraState && \"object\" !== 'undefined' && window.videoProcessor) {\n            // Wait a short moment to ensure the video element is ready\n            setTimeout(()=>{\n                if (window.videoProcessor) {\n                    window.videoProcessor.updateOptions({\n                        showHeadPose,\n                        showBoundingBox,\n                        showMask,\n                        showParameters\n                    });\n                }\n            }, 100);\n        }\n    };\n    // Camera permission handlers\n    const handlePermissionAccepted = ()=>{\n        setShowPermissionPopup(false);\n        if (triggerCameraAccess) {\n            triggerCameraAccess(true);\n        }\n    };\n    const handlePermissionDenied = ()=>{\n        setShowPermissionPopup(false);\n        setProcessStatus('Camera access denied');\n    };\n    // Add back button handler\n    const handleGoBack = ()=>{\n        router.push('/');\n    };\n    // Mobile layout - 2x5 grid\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            isCompactMode ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2 mb-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1210,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1209,\n                columnNumber: 9\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-2 gap-2\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {}, void 0, false, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1214,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1213,\n                columnNumber: 9\n            }, undefined),\n            showPermissionPopup && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"camera-permission-popup\",\n                style: {\n                    position: 'fixed',\n                    top: 0,\n                    left: 0,\n                    width: '100%',\n                    height: '100%',\n                    backgroundColor: 'rgba(0, 0, 0, 0.5)',\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    zIndex: 15\n                },\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"camera-permission-dialog\",\n                    style: {\n                        width: '400px',\n                        backgroundColor: 'white',\n                        borderRadius: '8px',\n                        padding: '20px',\n                        boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)'\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                            className: \"camera-permission-title\",\n                            style: {\n                                margin: '0 0 15px',\n                                fontSize: '18px',\n                                fontWeight: 'bold'\n                            },\n                            children: \"Camera Access Required\"\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1245,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                            className: \"camera-permission-message\",\n                            style: {\n                                margin: '0 0 20px',\n                                fontSize: '14px',\n                                lineHeight: '1.4'\n                            },\n                            children: 'This application needs access to your camera to function properly. When prompted by your browser, please click \"Allow\" to grant camera access.'\n                        }, void 0, false, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1255,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"camera-permission-buttons\",\n                            style: {\n                                display: 'flex',\n                                justifyContent: 'flex-end',\n                                gap: '10px'\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionDenied,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#f0f0f0',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1273,\n                                    columnNumber: 15\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    onClick: handlePermissionAccepted,\n                                    className: \"camera-btn\",\n                                    style: {\n                                        padding: '8px 16px',\n                                        backgroundColor: '#0066cc',\n                                        color: 'white',\n                                        border: 'none',\n                                        borderRadius: '4px',\n                                        cursor: 'pointer'\n                                    },\n                                    children: \"Continue\"\n                                }, void 0, false, {\n                                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                                    lineNumber: 1286,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                            lineNumber: 1265,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                    lineNumber: 1235,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n                lineNumber: 1220,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n        lineNumber: 1207,\n        columnNumber: 5\n    }, undefined);\n}, \"3m6WU+NWDgNRt++RkwBY6SLMuUQ=\", false, function() {\n    return [\n        next_router__WEBPACK_IMPORTED_MODULE_6__.useRouter,\n        _adminSettings__WEBPACK_IMPORTED_MODULE_7__.useAdminSettings\n    ];\n}));\n_c1 = ActionButtonGroupInner;\nconst ActionButtonGroup = next_dynamic__WEBPACK_IMPORTED_MODULE_2___default()(_c2 = ()=>Promise.resolve(/*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((props, ref)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ActionButtonGroupInner, {\n            ...props,\n            ref: ref\n        }, void 0, false, {\n            fileName: \"/app/pages/collected-dataset-customized/components-gui/actionButton.js\",\n            lineNumber: 1308,\n            columnNumber: 30\n        }, undefined))), {\n    ssr: false\n});\n_c3 = ActionButtonGroup;\n// Create a client-only version of ActionButtonGroup\n// const ActionButtonGroup = dynamic(() => Promise.resolve(ActionButtonGroupInner), { ssr: false });\n// Add default export component\nfunction ActionButtonPage() {\n    return null; // This is a utility file, so we don't need to render anything\n}\n_c4 = ActionButtonPage;\n\nvar _c, _c1, _c2, _c3, _c4;\n$RefreshReg$(_c, \"ActionButton\");\n$RefreshReg$(_c1, \"ActionButtonGroupInner\");\n$RefreshReg$(_c2, \"ActionButtonGroup$dynamic\");\n$RefreshReg$(_c3, \"ActionButtonGroup\");\n$RefreshReg$(_c4, \"ActionButtonPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFHO0FBQ2xFO0FBQ2lGO0FBT3JDO0FBQ3lCO0FBQ2hFO0FBQ1c7QUFFbkQsOEJBQThCO0FBQzlCLE1BQU1pQixVQUFVLENBQUNDLE1BQU1DO0lBQ3JCLElBQUlELFNBQVNDLE1BQU0sT0FBTztJQUMxQixJQUFJLE9BQU9ELFNBQVMsWUFBWSxPQUFPQyxTQUFTLFVBQVUsT0FBTztJQUNqRSxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTSxPQUFPO0lBRTNDLE1BQU1DLFFBQVFDLE9BQU9DLElBQUksQ0FBQ0o7SUFDMUIsTUFBTUssUUFBUUYsT0FBT0MsSUFBSSxDQUFDSDtJQUUxQixJQUFJQyxNQUFNSSxNQUFNLEtBQUtELE1BQU1DLE1BQU0sRUFBRSxPQUFPO0lBRTFDLE9BQU9KLE1BQU1LLEtBQUssQ0FBQ0MsQ0FBQUEsTUFDakJILE1BQU1JLFFBQVEsQ0FBQ0QsUUFBUVQsUUFBUUMsSUFBSSxDQUFDUSxJQUFJLEVBQUVQLElBQUksQ0FBQ08sSUFBSTtBQUV2RDtBQUVBLDBEQUEwRDtBQUMxRCxNQUFNRSxlQUFlO1FBQUMsRUFBRUMsSUFBSSxFQUFFQyxlQUFlLEVBQUVDLE9BQU8sRUFBRUMsY0FBYyxFQUFFLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTs7SUFDMUcsTUFBTSxDQUFDQyxlQUFlQyxpQkFBaUIsR0FBR25DLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sRUFBRW9DLFFBQVEsRUFBRSxHQUFHckIsZ0VBQWdCQTtJQUNyQyxNQUFNLENBQUNzQixlQUFlQyxpQkFBaUIsR0FBR3RDLCtDQUFRQSxDQUFDO0lBQ25ELE1BQU0sQ0FBQ3VDLGFBQWFDLGVBQWUsR0FBR3hDLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FB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Q3ZPO29DQUNDakMsU0FBU3VQO29DQUNUdk8sV0FBVTtvQ0FDVnFJLE9BQU87d0NBQ0x5RyxTQUFTO3dDQUNUdkcsaUJBQWlCO3dDQUNqQmtILE9BQU87d0NBQ1BGLFFBQVE7d0NBQ1JWLGNBQWM7d0NBQ2RXLFFBQVE7b0NBQ1Y7OENBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBU2Y7O1FBcnJDaUJ4UixrREFBU0E7UUFDYUMsNERBQWdCQTs7O01BRmpEa0Q7QUF1ckNOLE1BQU11TyxvQkFBb0JsUyxtREFBT0EsT0FBQyxJQUFNd04sUUFBUUMsT0FBTyxlQUNyRDVOLGlEQUFVQSxDQUFDLENBQUNzUyxPQUFPdk8sb0JBQVEsOERBQUNEO1lBQXdCLEdBQUd3TyxLQUFLO1lBQUV2TyxLQUFLQTs7Ozs7eUJBQ2xFO0lBQUV3TyxLQUFLO0FBQU07O0FBQ2hCLG9EQUFvRDtBQUNwRCxvR0FBb0c7QUFFcEcsK0JBQStCO0FBQ2hCLFNBQVNDO0lBQ3RCLE9BQU8sTUFBTSw4REFBOEQ7QUFDN0U7TUFGd0JBO0FBSW1CIiwic291cmNlcyI6WyIvYXBwL3BhZ2VzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvY29tcG9uZW50cy1ndWkvYWN0aW9uQnV0dG9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZHluYW1pYyBmcm9tICduZXh0L2R5bmFtaWMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzJztcbmltcG9ydCB7IFxuICBzaG93Q2FwdHVyZVByZXZpZXcsIFxuICBkcmF3UmVkRG90LCBcbiAgZ2V0UmFuZG9tUG9zaXRpb24sXG4gIGNyZWF0ZUNvdW50ZG93bkVsZW1lbnQsXG4gIHJ1bkNvdW50ZG93blxufSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL2NvdW50U2F2ZS5qc3gnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvSGVscGVyL3NhdmVmaWxlJztcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJ25leHQvcm91dGVyJztcbmltcG9ydCB7IHVzZUFkbWluU2V0dGluZ3MgfSBmcm9tICcuL2FkbWluU2V0dGluZ3MnO1xuXG4vLyBBZGQgZGVlcCBjb21wYXJpc29uIHV0aWxpdHlcbmNvbnN0IGlzRXF1YWwgPSAob2JqMSwgb2JqMikgPT4ge1xuICBpZiAob2JqMSA9PT0gb2JqMikgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2Ygb2JqMSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iajIgIT09ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxID09PSBudWxsIHx8IG9iajIgPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgXG4gIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqMSk7XG4gIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob2JqMik7XG4gIFxuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgXG4gIHJldHVybiBrZXlzMS5ldmVyeShrZXkgPT4gXG4gICAga2V5czIuaW5jbHVkZXMoa2V5KSAmJiBpc0VxdWFsKG9iajFba2V5XSwgb2JqMltrZXldKVxuICApO1xufTtcblxuLy8gQ3JlYXRlIGEgYmFzaWMgQWN0aW9uQnV0dG9uIGNvbXBvbmVudCB3aXRoIG9wdGltaXphdGlvblxuY29uc3QgQWN0aW9uQnV0dG9uID0gKHsgdGV4dCwgYWJicmV2aWF0ZWRUZXh0LCBvbkNsaWNrLCBjdXN0b21DbGFzcyA9ICcnLCBkaXNhYmxlZCA9IGZhbHNlLCBhY3RpdmUgPSBmYWxzZSB9KSA9PiB7XG4gIGNvbnN0IFtpc0FiYnJldmlhdGVkLCBzZXRJc0FiYnJldmlhdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBzZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncygpO1xuICBjb25zdCBbY3VycmVudFVzZXJJZCwgc2V0Q3VycmVudFVzZXJJZF0gPSB1c2VTdGF0ZSgnZGVmYXVsdCcpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2NhcHR1cmVDb3VudGVyLCBzZXRDYXB0dXJlQ291bnRlcl0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3Byb2Nlc3NTdGF0dXMsIHNldFByb2Nlc3NTdGF0dXNdID0gdXNlU3RhdGUoJycpO1xuXG4gIC8vIE1lbW9pemUgYnV0dG9uIHByb3BzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyc1xuICBjb25zdCBidXR0b25Qcm9wcyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICBjbGFzc05hbWU6IGBhY3Rpb24tYnV0dG9uICR7Y3VzdG9tQ2xhc3N9ICR7aXNBYmJyZXZpYXRlZCA/ICdhYmJyZXZpYXRlZCcgOiAnJ30gJHthY3RpdmUgPyAnYWN0aXZlJyA6ICcnfWAsXG4gICAgb25DbGljayxcbiAgICBkaXNhYmxlZCxcbiAgICB0aXRsZTogdGV4dFxuICB9KSwgW2N1c3RvbUNsYXNzLCBpc0FiYnJldmlhdGVkLCBhY3RpdmUsIG9uQ2xpY2ssIGRpc2FibGVkLCB0ZXh0XSk7XG5cbiAgLy8gQ2hlY2sgd2luZG93IHNpemUgYW5kIHNldCBhYmJyZXZpYXRlZCBtb2RlIHdpdGggZGVib3VuY2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICBsZXQgdGltZW91dElkO1xuICAgIGNvbnN0IGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIHNldElzQWJicmV2aWF0ZWQod2lkdGggPCA3NjgpO1xuICAgICAgfSwgMTAwKTtcbiAgICB9O1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUpO1xuICAgIGhhbmRsZVJlc2l6ZSgpOyAvLyBJbml0aWFsIGNhbGxcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVJlc2l6ZSk7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gQWRkIGVmZmVjdCB0byBsaXN0ZW4gZm9yIHVzZXIgSUQgY2hhbmdlcyB3aXRoIG9wdGltaXphdGlvblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZVVzZXJJZENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ3VzZXJJZENoYW5nZScpIHtcbiAgICAgICAgY29uc3QgbmV3VXNlcklkID0gZXZlbnQuZGV0YWlsLnVzZXJJZDtcbiAgICAgICAgaWYgKG5ld1VzZXJJZCAhPT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIHNldEN1cnJlbnRVc2VySWQobmV3VXNlcklkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VzZXJJZENoYW5nZScsIGhhbmRsZVVzZXJJZENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2N1cnJlbnRVc2VySWRdKTtcblxuICByZXR1cm4gKFxuICAgIDxidXR0b24gey4uLmJ1dHRvblByb3BzfT5cbiAgICAgIHtpc0FiYnJldmlhdGVkID8gYWJicmV2aWF0ZWRUZXh0IDogdGV4dH1cbiAgICAgIHtwcm9jZXNzU3RhdHVzICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9jZXNzLXN0YXR1c1wiPlxuICAgICAgICAgIHtwcm9jZXNzU3RhdHVzfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9idXR0b24+XG4gICk7XG59O1xuXG4vLyBDcmVhdGUgdGhlIEFjdGlvbkJ1dHRvbkdyb3VwIGNvbXBvbmVudCB3aXRoIGNsaWVudC1zaWRlIG9ubHkgcmVuZGVyaW5nIGFuZCBvcHRpbWl6YXRpb25cbmNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwSW5uZXIgPSBmb3J3YXJkUmVmKCh7IHRyaWdnZXJDYW1lcmFBY2Nlc3MsIGlzQ29tcGFjdE1vZGUsIG9uQWN0aW9uQ2xpY2sgfSwgcmVmKSA9PiB7XG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpO1xuICBjb25zdCB7IHNldHRpbmdzLCB1cGRhdGVTZXR0aW5ncyB9ID0gdXNlQWRtaW5TZXR0aW5ncyhyZWYpO1xuICBcbiAgLy8gU3RhdGUgZm9yIGJ1dHRvbiBhY3Rpb25zXG4gIGNvbnN0IFtyYW5kb21UaW1lcywgc2V0UmFuZG9tVGltZXNdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtkZWxheVNlY29uZHMsIHNldERlbGF5U2Vjb25kc10gPSB1c2VTdGF0ZSgzKTtcbiAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBbcHJvY2Vzc1N0YXR1cywgc2V0UHJvY2Vzc1N0YXR1c10gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtjb3VudGRvd25WYWx1ZSwgc2V0Q291bnRkb3duVmFsdWVdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjdXJyZW50RG90LCBzZXRDdXJyZW50RG90XSA9IHVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbY2FsaWJyYXRpb25Qb2ludHMsIHNldENhbGlicmF0aW9uUG9pbnRzXSA9IHVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW3JlbWFpbmluZ0NhcHR1cmVzLCBzZXRSZW1haW5pbmdDYXB0dXJlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW3Nob3dDYW52YXMsIHNldFNob3dDYW52YXNdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIFxuICAvLyBUcmFjayB0aGUgY2FwdHVyZSBjb3VudFxuICBjb25zdCBbY2FsaWJyYXRpb25IYW5kbGVyLCBzZXRDYWxpYnJhdGlvbkhhbmRsZXJdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtjYXB0dXJlQ291bnQsIHNldENhcHR1cmVDb3VudF0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2lzQ2FwdHVyaW5nLCBzZXRJc0NhcHR1cmluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICAvLyBUb2dnbGUgc3RhdGVzXG4gIGNvbnN0IFtzaG93SGVhZFBvc2UsIHNldFNob3dIZWFkUG9zZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93Qm91bmRpbmdCb3gsIHNldFNob3dCb3VuZGluZ0JveF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TWFzaywgc2V0U2hvd01hc2tdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd1BhcmFtZXRlcnMsIHNldFNob3dQYXJhbWV0ZXJzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzQ2FtZXJhQWN0aXZlLCBzZXRJc0NhbWVyYUFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93UGVybWlzc2lvblBvcHVwLCBzZXRTaG93UGVybWlzc2lvblBvcHVwXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnRVc2VySWQsIHNldEN1cnJlbnRVc2VySWRdID0gdXNlU3RhdGUoJ2RlZmF1bHQnKTtcblxuICAvLyBBZGQgY2FjaGUgZm9yIHNldHRpbmdzXG4gIGNvbnN0IHNldHRpbmdzQ2FjaGUgPSB1c2VSZWYobmV3IE1hcCgpKTtcbiAgY29uc3QgbGFzdFNldHRpbmdzVXBkYXRlID0gdXNlUmVmKG5ldyBNYXAoKSk7XG5cbiAgLy8gR2xvYmFsIGNhbnZhcyBtYW5hZ2VyIGluc3RhbmNlIC0gaW5pdGlhbGl6ZSBvbmx5IG9uY2VcbiAgY29uc3QgY2FudmFzTWFuYWdlciA9IHVzZU1lbW8oKCkgPT4gbmV3IENhbnZhc01hbmFnZXIoKSwgW10pO1xuXG4gIC8vIFJlcGxhY2UgdGhlIGNvbXBsZXggY2FudmFzIGZ1bmN0aW9ucyB3aXRoIHNpbXBsaWZpZWQgdmVyc2lvbnNcbiAgY29uc3QgZ2V0TWFpbkNhbnZhcyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpO1xuICB9O1xuXG4gIGNvbnN0IGVuc3VyZUNhbnZhc0V4aXN0cyA9ICgpID0+IHtcbiAgICByZXR1cm4gY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgfTtcblxuICBjb25zdCByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgPSAoY2FudmFzKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICB9O1xuXG4gIGNvbnN0IGNsZWFudXBDYW52YXMgPSAoKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5kZXN0cm95KCk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYW52YXMgPSAoKSA9PiB7XG4gICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gZWFzaWx5IG1hbmFnZSBjYW52YXMgb3BlcmF0aW9uc1xuICBjb25zdCBjYW52YXNVdGlscyA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGNhbnZhc1xuICAgIGdldENhbnZhczogKCkgPT4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpLFxuICAgIFxuICAgIC8vIEVudGVyIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGVudGVyRnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgIHJldHVybiBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRXhpdCBmdWxsc2NyZWVuIG1vZGVcbiAgICBleGl0RnVsbHNjcmVlbjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgcmV0dXJuIGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBDbGVhciBjYW52YXNcbiAgICBjbGVhcjogKCkgPT4ge1xuICAgICAgY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gRHJhdyBkb3QgYXQgcG9zaXRpb25cbiAgICBkcmF3RG90OiAoeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCB4LCB5LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXG4gICAgLy8gR2V0IGNhbnZhcyBkaW1lbnNpb25zXG4gICAgZ2V0RGltZW5zaW9uczogKCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuXG4gICAgaXNGdWxsc2NyZWVuOiAoKSA9PiBjYW52YXNNYW5hZ2VyLmlzSW5GdWxsc2NyZWVuKCksXG4gICAgXG4gICAgLy8gVXBkYXRlIGNhbnZhcyBzaXplIHRvIG1hdGNoIGNvbnRhaW5lclxuICAgIHJlc2l6ZVRvQ29udGFpbmVyOiAoY29udGFpbmVyKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgICAgaWYgKCFjYW52YXMgfHwgIWNvbnRhaW5lcikgcmV0dXJuIGZhbHNlO1xuICAgICAgXG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY2FudmFzLndpZHRoID0gcmVjdC53aWR0aCB8fCBjb250YWluZXIuY2xpZW50V2lkdGggfHwgODAwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHJlY3QuaGVpZ2h0IHx8IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgNjAwO1xuICAgICAgXG4gICAgICAvLyBDbGVhciBhbmQgcmVkcmF3IHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KSwgW10pO1xuXG4gIC8vIE1ha2UgY2FudmFzIHV0aWxpdGllcyBnbG9iYWxseSBhdmFpbGFibGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5jYW52YXNVdGlscyA9IGNhbnZhc1V0aWxzO1xuICAgICAgd2luZG93LmNhbnZhc01hbmFnZXIgPSBjYW52YXNNYW5hZ2VyO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzVXRpbHM7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3cuY2FudmFzTWFuYWdlcjtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbY2FudmFzVXRpbHMsIGNhbnZhc01hbmFnZXJdKTtcblxuICBcbiAgLy8gT3B0aW1pemUgc2V0dGluZ3MgdXBkYXRlc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzZXR0aW5ncyAmJiBjdXJyZW50VXNlcklkICYmIHNldHRpbmdzW2N1cnJlbnRVc2VySWRdKSB7XG4gICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tjdXJyZW50VXNlcklkXTtcbiAgICAgIGNvbnN0IGNhY2hlZFNldHRpbmdzID0gc2V0dGluZ3NDYWNoZS5jdXJyZW50LmdldChjdXJyZW50VXNlcklkKTtcbiAgICAgIFxuICAgICAgaWYgKCFpc0VxdWFsKGNhY2hlZFNldHRpbmdzLCB1c2VyU2V0dGluZ3MpKSB7XG4gICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgIHNldERlbGF5U2Vjb25kcyhOdW1iZXIodXNlclNldHRpbmdzLmRlbGF5X3NldF9yYW5kb20pIHx8IDMpO1xuICAgICAgICBzZXR0aW5nc0NhY2hlLmN1cnJlbnQuc2V0KGN1cnJlbnRVc2VySWQsIHVzZXJTZXR0aW5ncyk7XG4gICAgICAgIGxhc3RTZXR0aW5nc1VwZGF0ZS5jdXJyZW50LnNldChjdXJyZW50VXNlcklkLCBEYXRlLm5vdygpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtzZXR0aW5ncywgY3VycmVudFVzZXJJZF0pO1xuXG4gIC8vIExpc3RlbiBmb3IgdXNlciBJRCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlVXNlcklkQ2hhbmdlID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50eXBlID09PSAndXNlcklkQ2hhbmdlJykge1xuICAgICAgICBjb25zdCBuZXdVc2VySWQgPSBldmVudC5kZXRhaWwudXNlcklkO1xuICAgICAgICBzZXRDdXJyZW50VXNlcklkKG5ld1VzZXJJZCk7XG4gICAgICAgIC8vIFVwZGF0ZSBzZXR0aW5ncyBmb3IgbmV3IHVzZXJcbiAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzW25ld1VzZXJJZF0pIHtcbiAgICAgICAgICBjb25zdCB1c2VyU2V0dGluZ3MgPSBzZXR0aW5nc1tuZXdVc2VySWRdO1xuICAgICAgICAgIHNldFJhbmRvbVRpbWVzKE51bWJlcih1c2VyU2V0dGluZ3MudGltZXNfc2V0X3JhbmRvbSkgfHwgMSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKE51bWJlcih1c2VyU2V0dGluZ3MuZGVsYXlfc2V0X3JhbmRvbSkgfHwgMyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1c2VySWRDaGFuZ2UnLCBoYW5kbGVVc2VySWRDaGFuZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndXNlcklkQ2hhbmdlJywgaGFuZGxlVXNlcklkQ2hhbmdlKTtcbiAgICB9O1xuICB9LCBbc2V0dGluZ3NdKTtcblxuICAvLyBMaXN0ZW4gZm9yIHNldHRpbmdzIHVwZGF0ZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVTZXR0aW5nc1VwZGF0ZSA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudHlwZSA9PT0gJ2NhcHR1cmVTZXR0aW5ncycpIHtcbiAgICAgICAgY29uc3QgeyB1c2VySWQsIHRpbWVzX3NldF9yYW5kb20sIGRlbGF5X3NldF9yYW5kb20gfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgaWYgKHVzZXJJZCA9PT0gY3VycmVudFVzZXJJZCkge1xuICAgICAgICAgIGlmICh0aW1lc19zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RpbWVzID0gTnVtYmVyKHRpbWVzX3NldF9yYW5kb20pIHx8IDE7XG4gICAgICAgICAgICBzZXRSYW5kb21UaW1lcyhuZXdUaW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWxheV9zZXRfcmFuZG9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RlbGF5ID0gTnVtYmVyKGRlbGF5X3NldF9yYW5kb20pIHx8IDM7XG4gICAgICAgICAgICBzZXREZWxheVNlY29uZHMobmV3RGVsYXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhcHR1cmVTZXR0aW5nc1VwZGF0ZScsIGhhbmRsZVNldHRpbmdzVXBkYXRlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFVzZXJJZF0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gTWFrZSBmdW5jdGlvbnMgZ2xvYmFsbHkgYWNjZXNzaWJsZSBhcyBhIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3aW5kb3cuYWN0aW9uQnV0dG9uRnVuY3Rpb25zID0ge1xuICAgICAgICBoYW5kbGVSYW5kb21Eb3QsXG4gICAgICAgIGhhbmRsZVNldFJhbmRvbSxcbiAgICAgICAgaGFuZGxlU2V0Q2FsaWJyYXRlLFxuICAgICAgICBoYW5kbGVDbGVhckFsbFxuICAgICAgfTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9uIGZ1bmN0aW9ucyBleHBvc2VkIHRvIHdpbmRvdy5hY3Rpb25CdXR0b25GdW5jdGlvbnMnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkZWxldGUgd2luZG93LmFjdGlvbkJ1dHRvbkZ1bmN0aW9ucztcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gT25seSBpbml0aWFsaXplIGlmIGNhbnZhcyBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJykpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGdldE1haW5DYW52YXMoKTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgaW5pdGlhbGl6ZWQ6JywgY2FudmFzID8gJ3N1Y2Nlc3MnIDogJ2ZhaWxlZCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDbGVhbnVwIGZ1bmN0aW9uXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIERvbid0IHJlbW92ZSBjYW52YXMgb24gY2xlYW51cCB0byBwcmV2ZW50IHJlY3JlYXRpb24gaXNzdWVzXG4gICAgICBjb25zb2xlLmxvZygnQWN0aW9uQnV0dG9uIGNsZWFudXAgLSBjYW52YXMgcHJlc2VydmVkJyk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybjtcbiAgICBcbiAgICAvLyBGdW5jdGlvbiB0byBnZXQgY29udHJvbCB2YWx1ZXMgZnJvbSBUb3BCYXJcbiAgICBjb25zdCB1cGRhdGVDb250cm9sVmFsdWVzID0gKCkgPT4ge1xuICAgICAgLy8gR2V0IHRoZSB0aW1lIGlucHV0IGVsZW1lbnRcbiAgICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgY29uc3QgdGltZVZhbHVlID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4odGltZVZhbHVlKSAmJiB0aW1lVmFsdWUgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1VwZGF0aW5nIHJhbmRvbVRpbWVzIHRvOicsIHRpbWVWYWx1ZSk7XG4gICAgICAgICAgc2V0UmFuZG9tVGltZXModGltZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIGRlbGF5IGlucHV0IGVsZW1lbnRcbiAgICAgIGNvbnN0IGRlbGF5SW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJkZWxheVwiXScpO1xuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgY29uc3QgZGVsYXlWYWx1ZSA9IHBhcnNlSW50KGRlbGF5SW5wdXQudmFsdWUsIDEwKTtcbiAgICAgICAgaWYgKCFpc05hTihkZWxheVZhbHVlKSAmJiBkZWxheVZhbHVlID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdVcGRhdGluZyBkZWxheVNlY29uZHMgdG86JywgZGVsYXlWYWx1ZSk7XG4gICAgICAgICAgc2V0RGVsYXlTZWNvbmRzKGRlbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBjb250cm9sIGlucHV0c1xuICAgIGNvbnN0IHRpbWVJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLWlucHV0LWZpZWxkW2RhdGEtY29udHJvbD1cInRpbWVcIl0nKTtcbiAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICBcbiAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICB0aW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB0aW1lSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTsgLy8gQWxzbyBsaXN0ZW4gZm9yIGlucHV0IGV2ZW50c1xuICAgIH1cbiAgICBcbiAgICBpZiAoZGVsYXlJbnB1dCkge1xuICAgICAgZGVsYXlJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIGRlbGF5SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTsgLy8gQWxzbyBsaXN0ZW4gZm9yIGlucHV0IGV2ZW50c1xuICAgIH1cbiAgICBcbiAgICAvLyBJbml0aWFsIHVwZGF0ZVxuICAgIHVwZGF0ZUNvbnRyb2xWYWx1ZXMoKTtcbiAgICBcbiAgICAvLyBDbGVhbnVwIGV2ZW50IGxpc3RlbmVyc1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodGltZUlucHV0KSB7XG4gICAgICAgIHRpbWVJbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgICAgdGltZUlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGRlbGF5SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBkYXRlQ29udHJvbFZhbHVlcyk7XG4gICAgICAgIGRlbGF5SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB1cGRhdGVDb250cm9sVmFsdWVzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBjYW52YXMgb24gY29tcG9uZW50IG1vdW50XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gQ2FudmFzIGlzIG5vdyBtYW5hZ2VkIGJ5IENhbnZhc01hbmFnZXJcbiAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgY29uc29sZS5sb2coJ0NhbnZhcyBpbml0aWFsaXplZDonLCBjYW52YXMgPyAnc3VjY2VzcycgOiAnZmFpbGVkJyk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENsZWFudXAgaXMgaGFuZGxlZCBieSBDYW52YXNNYW5hZ2VyXG4gICAgICBjb25zb2xlLmxvZygnQWN0aW9uQnV0dG9uIGNsZWFudXAgLSBjYW52YXMgcHJlc2VydmVkJyk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIC8vIENhbnZhcyBNYW5hZ2VyIC0gU2ltcGxpZmllZCBhbmQgY2VudHJhbGl6ZWRcbiAgY2xhc3MgQ2FudmFzTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLm9yaWdpbmFsU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gICAgICB0aGlzLmlzRnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvciBnZXQgY2FudmFzIHdpdGggYXV0b21hdGljIHNpemluZ1xuICAgIGNyZWF0ZUNhbnZhcyhjb250YWluZXIgPSBudWxsKSB7XG4gICAgICAvLyBUcnkgdG8gZmluZCBleGlzdGluZyBjYW52YXMgZmlyc3RcbiAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgICBcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMuY2xhc3NOYW1lID0gJ3RyYWNraW5nLWNhbnZhcyc7XG4gICAgICAgIGNhbnZhcy5pZCA9ICd0cmFja2luZy1jYW52YXMnO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgY29udGFpbmVyXG4gICAgICBjb25zdCB0YXJnZXRDb250YWluZXIgPSBjb250YWluZXIgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5tYWluLWNvbnRlbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5O1xuXG4gICAgICAvLyBTZXQgaW5pdGlhbCBkaW1lbnNpb25zIGJhc2VkIG9uIGNvbnRhaW5lclxuICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKGNhbnZhcywgdGFyZ2V0Q29udGFpbmVyKTtcbiAgICAgIFxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gQWRkIHRvIGNvbnRhaW5lciBpZiBub3QgYWxyZWFkeSB0aGVyZVxuICAgICAgaWYgKCFjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICB0YXJnZXRDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcmUgcmVmZXJlbmNlXG4gICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9IGNhbnZhcztcblxuICAgICAgLy8gU2V0IHVwIHJlc3BvbnNpdmUgYmVoYXZpb3JcbiAgICAgIHRoaXMuc2V0dXBSZXNwb25zaXZlQ2FudmFzKGNhbnZhcywgdGFyZ2V0Q29udGFpbmVyKTtcblxuICAgICAgY29uc29sZS5sb2coYENhbnZhcyBjcmVhdGVkL3VwZGF0ZWQ6ICR7Y2FudmFzLndpZHRofXgke2NhbnZhcy5oZWlnaHR9YCk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBjYW52YXMgc2l6ZSB0byBtYXRjaCBjb250YWluZXJcbiAgICB1cGRhdGVDYW52YXNTaXplKGNhbnZhcywgY29udGFpbmVyKSB7XG4gICAgICBpZiAoIWNhbnZhcyB8fCAhY29udGFpbmVyKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB3aWR0aCA9IHJlY3Qud2lkdGggfHwgY29udGFpbmVyLmNsaWVudFdpZHRoIHx8IDgwMDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHJlY3QuaGVpZ2h0IHx8IGNvbnRhaW5lci5jbGllbnRIZWlnaHQgfHwgNjAwO1xuXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIC8vIFVwZGF0ZSBDU1MgdG8gbWF0Y2hcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcbiAgICB9XG5cbiAgICAvLyBTZXQgdXAgcmVzcG9uc2l2ZSBjYW52YXMgdGhhdCBhZGFwdHMgdG8gY29udGFpbmVyIHNpemVcbiAgICBzZXR1cFJlc3BvbnNpdmVDYW52YXMoY2FudmFzLCBjb250YWluZXIpIHtcbiAgICAgIGlmICghY2FudmFzIHx8ICFjb250YWluZXIpIHJldHVybjtcblxuICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHJlc2l6ZSBvYnNlcnZlclxuICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBuZXcgcmVzaXplIG9ic2VydmVyXG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDYW52YXNTaXplKGNhbnZhcywgY29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIFJlZHJhdyB3aGl0ZSBiYWNrZ3JvdW5kIGFmdGVyIHJlc2l6ZVxuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIE9ic2VydmUgY29udGFpbmVyIGZvciBzaXplIGNoYW5nZXNcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuXG4gICAgICAvLyBBbHNvIGxpc3RlbiBmb3Igd2luZG93IHJlc2l6ZSBhcyBmYWxsYmFja1xuICAgICAgY29uc3QgaGFuZGxlV2luZG93UmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUoY2FudmFzLCBjb250YWluZXIpO1xuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZVdpbmRvd1Jlc2l6ZSk7XG4gICAgICBjYW52YXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIgPSBoYW5kbGVXaW5kb3dSZXNpemU7XG4gICAgfVxuXG4gICAgLy8gU3dpdGNoIHRvIGZ1bGxzY3JlZW4gbW9kZVxuICAgIGVudGVyRnVsbHNjcmVlbigpIHtcbiAgICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIG9yaWdpbmFsIHN0YXRlXG4gICAgICB0aGlzLm9yaWdpbmFsU3RhdGUgPSB7XG4gICAgICAgIHBhcmVudDogdGhpcy5jYW52YXMucGFyZW50RWxlbWVudCxcbiAgICAgICAgcG9zaXRpb246IHRoaXMuY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IHRoaXMuY2FudmFzLnN0eWxlLnRvcCxcbiAgICAgICAgbGVmdDogdGhpcy5jYW52YXMuc3R5bGUubGVmdCxcbiAgICAgICAgd2lkdGg6IHRoaXMuY2FudmFzLnN0eWxlLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgICAgekluZGV4OiB0aGlzLmNhbnZhcy5zdHlsZS56SW5kZXhcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdmUgdG8gYm9keSBhbmQgbWFrZSBmdWxsc2NyZWVuXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMHZ3O1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgICB6LWluZGV4OiA5OTk5OTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICBgO1xuXG4gICAgICAvLyBTZXQgY2FudmFzIGRpbWVuc2lvbnMgdG8gd2luZG93IHNpemVcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBIaWRlIFVJIGVsZW1lbnRzXG4gICAgICB0aGlzLmhpZGVVSUVsZW1lbnRzKCk7XG5cbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZW50ZXJlZCBmdWxsc2NyZWVuIG1vZGUnKTtcbiAgICB9XG5cbiAgICAvLyBFeGl0IGZ1bGxzY3JlZW4gbW9kZVxuICAgIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcyB8fCAhdGhpcy5vcmlnaW5hbFN0YXRlKSByZXR1cm47XG5cbiAgICAgIC8vIFNob3cgVUkgZWxlbWVudHNcbiAgICAgIHRoaXMuc2hvd1VJRWxlbWVudHMoKTtcblxuICAgICAgLy8gRmluZCBhcHByb3ByaWF0ZSBjb250YWluZXJcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG5cbiAgICAgIC8vIE1vdmUgY2FudmFzIGJhY2sgdG8gY29udGFpbmVyXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIHN0eWxlc1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJyc7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgICB0aGlzLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnpJbmRleCA9ICcnO1xuICAgICAgdGhpcy5jYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcblxuICAgICAgLy8gVXBkYXRlIHNpemUgdG8gbWF0Y2ggY29udGFpbmVyXG4gICAgICB0aGlzLnVwZGF0ZUNhbnZhc1NpemUodGhpcy5jYW52YXMsIGNvbnRhaW5lcik7XG5cbiAgICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBDbGVhciBvcmlnaW5hbCBzdGF0ZVxuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZXhpdGVkIGZ1bGxzY3JlZW4gbW9kZScpO1xuICAgIH1cblxuICAgIC8vIEhpZGUgVUkgZWxlbWVudHMgZHVyaW5nIGZ1bGxzY3JlZW5cbiAgICBoaWRlVUlFbGVtZW50cygpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzVG9IaWRlID0gW1xuICAgICAgICAnLnRvcGJhcicsXG4gICAgICAgICcuY2FudmFzLWNvbnRhaW5lcicsIFxuICAgICAgICAnLm1haW4tY29udGVudCcsXG4gICAgICAgICcubWV0cmljcy1wYW5lbCcsXG4gICAgICAgICcuZGlzcGxheS1tZXRyaWNzJyxcbiAgICAgICAgJ25hdicsXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnLmJ1dHRvbi1ncm91cHMnLFxuICAgICAgICAnLmNvbnRyb2wtYnV0dG9ucydcbiAgICAgIF07XG4gICAgICBcbiAgICAgIGVsZW1lbnRzVG9IaWRlLmZvckVhY2goc2VsZWN0b3IgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1oaWRkZW4tYnktY2FudmFzJywgJ3RydWUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTaG93IFVJIGVsZW1lbnRzIGFmdGVyIGZ1bGxzY3JlZW5cbiAgICBzaG93VUlFbGVtZW50cygpIHtcbiAgICAgIGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaGlkZGVuLWJ5LWNhbnZhcz1cInRydWVcIl0nKTtcbiAgICAgIGhpZGRlbkVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1oaWRkZW4tYnktY2FudmFzJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBDbGVhciBjYW52YXMgY29udGVudFxuICAgIGNsZWFyKCkge1xuICAgICAgaWYgKCF0aGlzLmNhbnZhcykgcmV0dXJuO1xuICAgICAgXG4gICAgICBjb25zdCBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8vIENsZWFudXBcbiAgICBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMucmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcyAmJiB0aGlzLmNhbnZhcy5fd2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5jYW52YXMuX3dpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMgJiYgdGhpcy5jYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcyA9PT0gdGhpcy5jYW52YXMpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy53aGl0ZVNjcmVlbkNhbnZhcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5vcmlnaW5hbFN0YXRlID0gbnVsbDtcbiAgICAgIHRoaXMuaXNGdWxsc2NyZWVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgY2FudmFzXG4gICAgZ2V0Q2FudmFzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGVcbiAgICBpc0luRnVsbHNjcmVlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRnVsbHNjcmVlbjtcbiAgICB9XG4gIH1cblxuXG4gIFxuICAvLyBNb2RpZmllZCBoYW5kbGVEb3RQcm9jZXNzIGZ1bmN0aW9uIHdpdGggaW1wcm92ZWQgZG90IGFuZCBjb3VudGRvd24gYWxpZ25tZW50XG4gIC8vIENvbXBsZXRlIGhhbmRsZURvdFByb2Nlc3MgZnVuY3Rpb24gd2l0aCBwcm9wZXIgY2FudmFzIG1hbmFnZW1lbnRcbiAgY29uc3QgaGFuZGxlRG90UHJvY2VzcyA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zaXRpb24sXG4gICAgICBvblN0YXR1c1VwZGF0ZSxcbiAgICAgIHRvZ2dsZVRvcEJhcixcbiAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgIGNhcHR1cmVDb3VudCxcbiAgICAgIHNldENhcHR1cmVDb3VudCxcbiAgICAgIHVzZVJhbmRvbVBvc2l0aW9uID0gZmFsc2UsXG4gICAgICBwb3N0Q291bnRkb3duRGVsYXkgPSA1MDAgXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgXG4gICAgbGV0IGNhbnZhcyA9IG51bGw7XG4gICAgbGV0IGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwgPSBudWxsO1xuICAgIGxldCBjb3VudGRvd25FbGVtZW50ID0gbnVsbDtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzaG93aW5nIHRoZSBkb3RcbiAgICAgIGlmICh0eXBlb2YgdG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGVcbiAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgc3RhdHVzXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogdXNlUmFuZG9tUG9zaXRpb24gPyAnR2VuZXJhdGluZyByYW5kb20gZG90Li4uJyA6ICdTdGFydGluZyBkb3QgcHJvY2Vzcy4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgVUkgdXBkYXRlcyB0byB0YWtlIGVmZmVjdFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMCkpO1xuICAgICAgXG4gICAgICAvLyBVc2UgZW5zdXJlQ2FudmFzRXhpc3RzIHRvIGdldCBvciBjcmVhdGUgY2FudmFzXG4gICAgICBjYW52YXMgPSBlbnN1cmVDYW52YXNFeGlzdHMoKTtcbiAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgb3IgZmluZCBjYW52YXNcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENhbnZhcyBpcyBhbHJlYWR5IHNldCB0byBmdWxsc2NyZWVuIGJ5IGVuc3VyZUNhbnZhc0V4aXN0c1xuICAgICAgY29uc3QgY2FudmFzV2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICBjb25zdCBjYW52YXNIZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBHZXQgY29udGV4dCBhbmQgY2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEdldCBwb3NpdGlvbiBmb3IgdGhlIGRvdCAtIGVpdGhlciB1c2UgcHJvdmlkZWQgcG9zaXRpb24gb3IgZ2VuZXJhdGUgcmFuZG9tIG9uZVxuICAgICAgY29uc3QgZG90UG9zaXRpb24gPSB1c2VSYW5kb21Qb3NpdGlvbiBcbiAgICAgICAgPyBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMsIDIwKSBcbiAgICAgICAgOiBwb3NpdGlvbjtcbiAgICAgIFxuICAgICAgaWYgKCFkb3RQb3NpdGlvbiB8fCB0eXBlb2YgZG90UG9zaXRpb24ueCAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGRvdFBvc2l0aW9uLnkgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZG90IHBvc2l0aW9uXCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGRvdFJhZGl1cyA9IDEyO1xuICAgICAgZHJhd1JlZERvdChjdHgsIGRvdFBvc2l0aW9uLngsIGRvdFBvc2l0aW9uLnksIGRvdFJhZGl1cywgZmFsc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSByZWRyYXcgaW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICBrZWVwRG90VmlzaWJsZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICB9LCA1MCk7ICAvLyBNb3JlIGZyZXF1ZW50IHVwZGF0ZXMgZm9yIHJlbGlhYmlsaXR5XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGNvdW50ZG93biBlbGVtZW50IGRpcmVjdGx5IG9uIHRvcCBvZiB0aGUgZG90XG4gICAgICBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBsZWZ0OiAke2RvdFBvc2l0aW9uLnh9cHg7XG4gICAgICAgIHRvcDogJHtkb3RQb3NpdGlvbi55fXB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICBcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENvdW50ZG93bjogJHtjb3VudH1gLFxuICAgICAgICAgIGNvdW50ZG93blZhbHVlOiBjb3VudCxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlZHJhdyB0aGUgZG90IGZvciByZWxpYWJpbGl0eVxuICAgICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBBZGRpdGlvbmFsIHJlZHJhdyBkdXJpbmcgY291bnRkb3duIHRvIGVuc3VyZSB2aXNpYmlsaXR5XG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICBkcmF3UmVkRG90KGN0eCwgZG90UG9zaXRpb24ueCwgZG90UG9zaXRpb24ueSwgZG90UmFkaXVzLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBhZnRlciBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcG9zdENvdW50ZG93bkRlbGF5KSk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgIGRyYXdSZWREb3QoY3R4LCBkb3RQb3NpdGlvbi54LCBkb3RQb3NpdGlvbi55LCBkb3RSYWRpdXMsIGZhbHNlKTtcbiAgICAgIFxuICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgcG9pbnQ6IGRvdFBvc2l0aW9uLFxuICAgICAgICBjYXB0dXJlQ291bnQ6IGNhcHR1cmVDb3VudCxcbiAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHNldENhcHR1cmVDb3VudCxcbiAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXR1c1xuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdDYXB0dXJlIGNvbXBsZXRlZCcsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBkb3RQb3NpdGlvbixcbiAgICAgICAgY2FwdHVyZVJlc3VsdFxuICAgICAgfTtcbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlRG90UHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgXG4gICAgICBvblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgaXNDYXB0dXJpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlXG4gICAgICB9O1xuICAgICAgXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbCBmaXJzdFxuICAgICAgaWYgKGtlZXBEb3RWaXNpYmxlSW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChrZWVwRG90VmlzaWJsZUludGVydmFsKTtcbiAgICAgICAga2VlcERvdFZpc2libGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgIGlmIChjb3VudGRvd25FbGVtZW50ICYmIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgY29uc3QgcmVtYWluaW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgcmVtYWluaW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSByZXN0b3JlQ2FudmFzVG9Db250YWluZXIgdG8gcHJvcGVybHkgcmVzdG9yZSBjYW52YXNcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgaGFuZGxlU2V0Q2FsaWJyYXRlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBFbnN1cmUgY2FudmFzIGlzIGluaXRpYWxpemVkIGZpcnN0XG4gICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW1wb3J0IGFuZCB1c2UgU2V0Q2FsaWJyYXRlQWN0aW9uXG4gICAgICBjb25zdCB7IGRlZmF1bHQ6IFNldENhbGlicmF0ZUFjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL1NldENhbGlicmF0ZUFjdGlvbi5qc3gnKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2V0Q2FsaWJyYXRlQWN0aW9uID0gbmV3IFNldENhbGlicmF0ZUFjdGlvbih7XG4gICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb25BY3Rpb25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb25BY3Rpb25DbGljaygndG9nZ2xlVG9wQmFyJywgc2hvdyk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRJc0NhcHR1cmluZyxcbiAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cyxcbiAgICAgICAgc2V0Q3VycmVudERvdCxcbiAgICAgICAgdHJpZ2dlckNhbWVyYUFjY2VzcyxcbiAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICAgIGlmIChzdGF0dXMuaXNDYXB0dXJpbmcgIT09IHVuZGVmaW5lZCkgc2V0SXNDYXB0dXJpbmcoc3RhdHVzLmlzQ2FwdHVyaW5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZUltYWdlVG9TZXJ2ZXI6IHRydWUsXG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICBjYXB0dXJlQ291bnRlcjogY2FwdHVyZUNvdW50XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgYXdhaXQgc2V0Q2FsaWJyYXRlQWN0aW9uLmhhbmRsZVNldENhbGlicmF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQ2FsaWJyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICBzZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNldFJhbmRvbSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoaXNDYXB0dXJpbmcpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSW1wb3J0IGFuZCB1c2UgU2V0UmFuZG9tQWN0aW9uXG4gICAgICBjb25zdCB7IGRlZmF1bHQ6IFNldFJhbmRvbUFjdGlvbiB9ID0gYXdhaXQgaW1wb3J0KCcuLi8uLi8uLi9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL1NldFJhbmRvbUFjdGlvbi5qc3gnKTtcbiAgICAgIFxuICAgICAgY29uc3Qgc2V0UmFuZG9tQWN0aW9uID0gbmV3IFNldFJhbmRvbUFjdGlvbih7XG4gICAgICAgIGNhbnZhc1JlZixcbiAgICAgICAgb25TdGF0dXNVcGRhdGU6IChzdGF0dXMpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzLnByb2Nlc3NTdGF0dXMpIHNldFByb2Nlc3NTdGF0dXMoc3RhdHVzLnByb2Nlc3NTdGF0dXMpO1xuICAgICAgICAgIGlmIChzdGF0dXMuaXNDYXB0dXJpbmcgIT09IHVuZGVmaW5lZCkgc2V0SXNDYXB0dXJpbmcoc3RhdHVzLmlzQ2FwdHVyaW5nKTtcbiAgICAgICAgICBpZiAoc3RhdHVzLnJlbWFpbmluZ0NhcHR1cmVzICE9PSB1bmRlZmluZWQpIHNldFJlbWFpbmluZ0NhcHR1cmVzKHN0YXR1cy5yZW1haW5pbmdDYXB0dXJlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICB0b2dnbGVUb3BCYXI6IChzaG93KSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBvbkFjdGlvbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvbkFjdGlvbkNsaWNrKCd0b2dnbGVUb3BCYXInLCBzaG93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhcHR1cmVDb3VudGVyOiBjYXB0dXJlQ291bnQsXG4gICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3NcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBhd2FpdCBzZXRSYW5kb21BY3Rpb24uaGFuZGxlQWN0aW9uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYW5kb20gc2VxdWVuY2UgZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgIHNldFByb2Nlc3NTdGF0dXMoYFJhbmRvbSBzZXF1ZW5jZSBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmFuZG9tRG90ID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0NhcHR1cmluZykgcmV0dXJuO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEltcG9ydCBhbmQgdXNlIFJhbmRvbURvdEFjdGlvblxuICAgICAgY29uc3QgeyBkZWZhdWx0OiBSYW5kb21Eb3RBY3Rpb24gfSA9IGF3YWl0IGltcG9ydCgnLi4vLi4vLi4vY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9SYW5kb21Eb3RBY3Rpb24uanN4Jyk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJhbmRvbURvdEFjdGlvbiA9IG5ldyBSYW5kb21Eb3RBY3Rpb24oe1xuICAgICAgICBjYW52YXNSZWYsXG4gICAgICAgIHRvZ2dsZVRvcEJhcjogKHNob3cpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9uQWN0aW9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9uQWN0aW9uQ2xpY2soJ3RvZ2dsZVRvcEJhcicsIHNob3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0SXNDYXB0dXJpbmcsXG4gICAgICAgIHNldFByb2Nlc3NTdGF0dXMsXG4gICAgICAgIHNldEN1cnJlbnREb3QsXG4gICAgICAgIHRyaWdnZXJDYW1lcmFBY2Nlc3MsXG4gICAgICAgIG9uU3RhdHVzVXBkYXRlOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cy5wcm9jZXNzU3RhdHVzKTtcbiAgICAgICAgICBpZiAoc3RhdHVzLmlzQ2FwdHVyaW5nICE9PSB1bmRlZmluZWQpIHNldElzQ2FwdHVyaW5nKHN0YXR1cy5pc0NhcHR1cmluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIHNhdmVJbWFnZVRvU2VydmVyOiB0cnVlLFxuICAgICAgICBzZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgY2FwdHVyZUNvdW50ZXI6IGNhcHR1cmVDb3VudFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IHJhbmRvbURvdEFjdGlvbi5oYW5kbGVSYW5kb21Eb3QoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignUmFuZG9tIGRvdCBlcnJvcjonLCBlcnJvcik7XG4gICAgICBzZXRQcm9jZXNzU3RhdHVzKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBcblxuICAvLyBMb2FkIGNhbGlicmF0aW9uIHNldHVwXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm47XG5cbiAgICBjb25zdCBzZXR1cENhbGlicmF0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0OiBDYWxpYnJhdGVIYW5kbGVyIH0gPSBhd2FpdCBpbXBvcnQoJy4uLy4uLy4uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlcicpO1xuICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBnZXRNYWluQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiQ2FudmFzIG5vdCBhdmFpbGFibGUgZHVyaW5nIHNldHVwQ2FsaWJyYXRpb25cIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICBtYWtlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDYW52YXMgc2l6ZTonLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdHZW5lcmF0ZWQgY2FsaWJyYXRpb24gcG9pbnRzOicsIHBvaW50cyk7XG4gICAgICAgIHNldENhbGlicmF0aW9uUG9pbnRzKHBvaW50cyk7XG4gICAgXG4gICAgICAgIGNvbnN0IGNhbGlicmF0ZUhhbmRsZXIgPSBuZXcgQ2FsaWJyYXRlSGFuZGxlcih7XG4gICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgIGNhbGlicmF0aW9uUG9pbnRzOiBwb2ludHMsXG4gICAgICAgICAgdG9nZ2xlVG9wQmFyOiAoc2hvdykgPT4gb25BY3Rpb25DbGljaz8uKCd0b2dnbGVUb3BCYXInLCBzaG93KSxcbiAgICAgICAgICBzZXRPdXRwdXRUZXh0OiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYXB0dXJlQ291bnRlcjogY2FwdHVyZUNvdW50LFxuICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyOiAobmV3Q291bnRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdDb3VudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudChwcmV2ID0+IG5ld0NvdW50ZXIocHJldikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50KG5ld0NvdW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2FwdHVyZUZvbGRlcjogJ2V5ZV90cmFja2luZ19jYXB0dXJlcycsXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnQ2FsaWJyYXRpb24gY29tcGxldGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgc2V0Q2FsaWJyYXRpb25IYW5kbGVyKHtcbiAgICAgICAgICBoYW5kbGVBY3Rpb246IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgICAgICAgICAgc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24uLi4nKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGlicmF0ZUhhbmRsZXIuc3RhcnRDYWxpYnJhdGlvbigpO1xuICAgICAgICAgICAgc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICByZXN0b3JlQ2FudmFzU2l6ZShjYW52YXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNhbGlicmF0aW9uOicsIGVycik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNldHVwQ2FsaWJyYXRpb24oKTtcbiAgfSwgW2NhcHR1cmVDb3VudCwgb25BY3Rpb25DbGlja10pO1xuICBcbiAgLy8gQ2xlYXIgQWxsIEJ1dHRvbiAtIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgY29uc3QgaGFuZGxlQ2xlYXJBbGwgPSAoKSA9PiB7XG4gICAgLy8gQ2xlYXIgY2FudmFzIGNvbnRlbnRcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBSZXN0b3JlIGNhbnZhcyB0byBjb250YWluZXIgbW9kZVxuICAgICAgcmVzdG9yZUNhbnZhc1RvQ29udGFpbmVyKGNhbnZhcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc2V0IHN0YXRlc1xuICAgIHNldFByb2Nlc3NTdGF0dXMoJycpO1xuICAgIHNldFJlbWFpbmluZ0NhcHR1cmVzKDApO1xuICAgIHNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICBzZXRDb3VudGRvd25WYWx1ZShudWxsKTtcbiAgICBzZXRTaG93Q2FudmFzKHRydWUpO1xuICAgIHNldEN1cnJlbnREb3QobnVsbCk7XG4gIH07XG5cbiAgLy8gVG9nZ2xlIEhlYWQgUG9zZSB2aXN1YWxpemF0aW9uXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUhlYWRQb3NlID0gKCkgPT4ge1xuICAgIGNvbnN0IG5ld0hlYWRQb3NlU3RhdGUgPSAhc2hvd0hlYWRQb3NlO1xuICAgIHNldFNob3dIZWFkUG9zZShuZXdIZWFkUG9zZVN0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBIZWFkIHBvc2UgdmlzdWFsaXphdGlvbiAke25ld0hlYWRQb3NlU3RhdGUgPyAnZW5hYmxlZCcgOiAnZGlzYWJsZWQnfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdoZWFkUG9zZScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dIZWFkUG9zZTogbmV3SGVhZFBvc2VTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIGhlYWQgcG9zZTogJHtuZXdIZWFkUG9zZVN0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgQm91bmRpbmcgQm94IHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlQm91bmRpbmdCb3ggPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3Qm91bmRpbmdCb3hTdGF0ZSA9ICFzaG93Qm91bmRpbmdCb3g7XG4gICAgc2V0U2hvd0JvdW5kaW5nQm94KG5ld0JvdW5kaW5nQm94U3RhdGUpO1xuICAgIHNldFByb2Nlc3NTdGF0dXMoYEJvdW5kaW5nIGJveCAke25ld0JvdW5kaW5nQm94U3RhdGUgPyAnc2hvd24nIDogJ2hpZGRlbid9YCk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgdG8gdXBkYXRlIHByb2Nlc3NvciBvcHRpb25zXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ2JvdW5kaW5nQm94Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd0JvdW5kaW5nQm94OiBuZXdCb3VuZGluZ0JveFN0YXRlXG4gICAgICB9KTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBVcGRhdGVkIGJhY2tlbmQgYm91bmRpbmcgYm94OiAke25ld0JvdW5kaW5nQm94U3RhdGV9YCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRvZ2dsZSBNYXNrIHZpc3VhbGl6YXRpb25cbiAgY29uc3QgaGFuZGxlVG9nZ2xlTWFzayA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdNYXNrU3RhdGUgPSAhc2hvd01hc2s7XG4gICAgc2V0U2hvd01hc2sobmV3TWFza1N0YXRlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKGBNYXNrICR7bmV3TWFza1N0YXRlID8gJ3Nob3duJyA6ICdoaWRkZW4nfWApO1xuICAgIFxuICAgIC8vIENhbGwgdGhlIHBhcmVudCBoYW5kbGVyIHRvIHVwZGF0ZSBwcm9jZXNzb3Igb3B0aW9uc1xuICAgIGlmIChvbkFjdGlvbkNsaWNrKSB7XG4gICAgICBvbkFjdGlvbkNsaWNrKCdtYXNrJyk7XG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSB2aWRlb1Byb2Nlc3NvciBvcHRpb25zIGRpcmVjdGx5IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIHdpbmRvdy52aWRlb1Byb2Nlc3Nvci51cGRhdGVPcHRpb25zKHtcbiAgICAgICAgc2hvd01hc2s6IG5ld01hc2tTdGF0ZVxuICAgICAgfSk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhgVXBkYXRlZCBiYWNrZW5kIG1hc2s6ICR7bmV3TWFza1N0YXRlfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyBUb2dnbGUgUGFyYW1ldGVycyBkaXNwbGF5XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZVBhcmFtZXRlcnMgPSAoKSA9PiB7XG4gICAgY29uc3QgbmV3UGFyYW1ldGVyc1N0YXRlID0gIXNob3dQYXJhbWV0ZXJzO1xuICAgIHNldFNob3dQYXJhbWV0ZXJzKG5ld1BhcmFtZXRlcnNTdGF0ZSk7XG4gICAgc2V0UHJvY2Vzc1N0YXR1cyhgUGFyYW1ldGVycyAke25ld1BhcmFtZXRlcnNTdGF0ZSA/ICdzaG93bicgOiAnaGlkZGVuJ31gKTtcbiAgICBcbiAgICAvLyBDYWxsIHRoZSBwYXJlbnQgaGFuZGxlciB0byB1cGRhdGUgcHJvY2Vzc29yIG9wdGlvbnNcbiAgICBpZiAob25BY3Rpb25DbGljaykge1xuICAgICAgb25BY3Rpb25DbGljaygncGFyYW1ldGVycycpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgdmlkZW9Qcm9jZXNzb3Igb3B0aW9ucyBkaXJlY3RseSBpZiBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgIHNob3dQYXJhbWV0ZXJzOiBuZXdQYXJhbWV0ZXJzU3RhdGVcbiAgICAgIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2coYFVwZGF0ZWQgYmFja2VuZCBwYXJhbWV0ZXJzOiAke25ld1BhcmFtZXRlcnNTdGF0ZX1gKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVG9nZ2xlIGNhbWVyYSBwcmV2aWV3XG4gIGNvbnN0IGhhbmRsZVRvZ2dsZUNhbWVyYSA9ICgpID0+IHtcbiAgICBjb25zdCBuZXdDYW1lcmFTdGF0ZSA9ICFpc0NhbWVyYUFjdGl2ZTtcbiAgICBzZXRJc0NhbWVyYUFjdGl2ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgXG4gICAgLy8gQ2FsbCB0aGUgcGFyZW50IGhhbmRsZXIgd2l0aCAncHJldmlldycgYWN0aW9uXG4gICAgaWYgKG9uQWN0aW9uQ2xpY2spIHtcbiAgICAgIG9uQWN0aW9uQ2xpY2soJ3ByZXZpZXcnLCBuZXdDYW1lcmFTdGF0ZSk7IC8vIFBhc3MgdGhlIG5ldyBzdGF0ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBkaXJlY3QgdHJpZ2dlciBpZiBubyBhY3Rpb24gaGFuZGxlclxuICAgICAgc2V0U2hvd1Blcm1pc3Npb25Qb3B1cCh0cnVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgdHVybmluZyBvbiBjYW1lcmEsIGVuc3VyZSB3ZSBhcHBseSBjdXJyZW50IHZpc3VhbGl6YXRpb24gc2V0dGluZ3NcbiAgICBpZiAobmV3Q2FtZXJhU3RhdGUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAvLyBXYWl0IGEgc2hvcnQgbW9tZW50IHRvIGVuc3VyZSB0aGUgdmlkZW8gZWxlbWVudCBpcyByZWFkeVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh3aW5kb3cudmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgICAgICB3aW5kb3cudmlkZW9Qcm9jZXNzb3IudXBkYXRlT3B0aW9ucyh7XG4gICAgICAgICAgICBzaG93SGVhZFBvc2UsXG4gICAgICAgICAgICBzaG93Qm91bmRpbmdCb3gsXG4gICAgICAgICAgICBzaG93TWFzayxcbiAgICAgICAgICAgIHNob3dQYXJhbWV0ZXJzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENhbWVyYSBwZXJtaXNzaW9uIGhhbmRsZXJzXG4gIGNvbnN0IGhhbmRsZVBlcm1pc3Npb25BY2NlcHRlZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBpZiAodHJpZ2dlckNhbWVyYUFjY2Vzcykge1xuICAgICAgdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUGVybWlzc2lvbkRlbmllZCA9ICgpID0+IHtcbiAgICBzZXRTaG93UGVybWlzc2lvblBvcHVwKGZhbHNlKTtcbiAgICBzZXRQcm9jZXNzU3RhdHVzKCdDYW1lcmEgYWNjZXNzIGRlbmllZCcpO1xuICB9O1xuXG4gIC8vIEFkZCBiYWNrIGJ1dHRvbiBoYW5kbGVyXG4gIGNvbnN0IGhhbmRsZUdvQmFjayA9ICgpID0+IHtcbiAgICByb3V0ZXIucHVzaCgnLycpO1xuICB9O1xuXG4gIC8vIE1vYmlsZSBsYXlvdXQgLSAyeDUgZ3JpZFxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICB7aXNDb21wYWN0TW9kZSA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yIG1iLTRcIj5cbiAgICAgICAgICA8ZGl2PjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZ3JpZCBncmlkLWNvbHMtMiBnYXAtMlwiPlxuICAgICAgICAgIDxkaXY+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cblxuICAgICAgey8qIENhbWVyYSBQZXJtaXNzaW9uIFBvcHVwICovfVxuICAgICAge3Nob3dQZXJtaXNzaW9uUG9wdXAgJiYgKFxuICAgICAgICA8ZGl2IFxuICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXBvcHVwXCIgXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KScsXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHpJbmRleDogMTVcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLWRpYWxvZ1wiIFxuICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgd2lkdGg6ICc0MDBweCcsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnOHB4JyxcbiAgICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnLFxuICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDRweCA4cHggcmdiYSgwLCAwLCAwLCAwLjIpJ1xuICAgICAgICAgICAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8aDMgXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNhbWVyYS1wZXJtaXNzaW9uLXRpdGxlXCIgXG4gICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgbWFyZ2luOiAnMCAwIDE1cHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIENhbWVyYSBBY2Nlc3MgUmVxdWlyZWRcbiAgICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgICA8cCBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tbWVzc2FnZVwiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIG1hcmdpbjogJzAgMCAyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE0cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxLjQnXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIFRoaXMgYXBwbGljYXRpb24gbmVlZHMgYWNjZXNzIHRvIHlvdXIgY2FtZXJhIHRvIGZ1bmN0aW9uIHByb3Blcmx5LiBXaGVuIHByb21wdGVkIGJ5IHlvdXIgYnJvd3NlciwgcGxlYXNlIGNsaWNrIFwiQWxsb3dcIiB0byBncmFudCBjYW1lcmEgYWNjZXNzLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGRpdiBcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLXBlcm1pc3Npb24tYnV0dG9uc1wiIFxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2ZsZXgtZW5kJyxcbiAgICAgICAgICAgICAgICBnYXA6ICcxMHB4J1xuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZVBlcm1pc3Npb25EZW5pZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjZjBmMGYwJyxcbiAgICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnNHB4JyxcbiAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvbiBcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWR9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2FtZXJhLWJ0blwiXG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIHBhZGRpbmc6ICc4cHggMTZweCcsXG4gICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDA2NmNjJyxcbiAgICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6ICc0cHgnLFxuICAgICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQ29udGludWVcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufSk7XG5jb25zdCBBY3Rpb25CdXR0b25Hcm91cCA9IGR5bmFtaWMoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKFxuICBmb3J3YXJkUmVmKChwcm9wcywgcmVmKSA9PiA8QWN0aW9uQnV0dG9uR3JvdXBJbm5lciB7Li4ucHJvcHN9IHJlZj17cmVmfSAvPilcbiksIHsgc3NyOiBmYWxzZSB9KTtcbi8vIENyZWF0ZSBhIGNsaWVudC1vbmx5IHZlcnNpb24gb2YgQWN0aW9uQnV0dG9uR3JvdXBcbi8vIGNvbnN0IEFjdGlvbkJ1dHRvbkdyb3VwID0gZHluYW1pYygoKSA9PiBQcm9taXNlLnJlc29sdmUoQWN0aW9uQnV0dG9uR3JvdXBJbm5lciksIHsgc3NyOiBmYWxzZSB9KTtcblxuLy8gQWRkIGRlZmF1bHQgZXhwb3J0IGNvbXBvbmVudFxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQWN0aW9uQnV0dG9uUGFnZSgpIHtcbiAgcmV0dXJuIG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG59XG5cbmV4cG9ydCB7IEFjdGlvbkJ1dHRvbiwgQWN0aW9uQnV0dG9uR3JvdXAgfTsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsImZvcndhcmRSZWYiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTWVtbyIsImR5bmFtaWMiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiZHJhd1JlZERvdCIsImdldFJhbmRvbVBvc2l0aW9uIiwiY3JlYXRlQ291bnRkb3duRWxlbWVudCIsInJ1bkNvdW50ZG93biIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwidXNlUm91dGVyIiwidXNlQWRtaW5TZXR0aW5ncyIsImlzRXF1YWwiLCJvYmoxIiwib2JqMiIsImtleXMxIiwiT2JqZWN0Iiwia2V5cyIsImtleXMyIiwibGVuZ3RoIiwiZXZlcnkiLCJrZXkiLCJpbmNsdWRlcyIsIkFjdGlvbkJ1dHRvbiIsInRleHQiLCJhYmJyZXZpYXRlZFRleHQiLCJvbkNsaWNrIiwiY3VzdG9tQ2xhc3MiLCJkaXNhYmxlZCIsImFjdGl2ZSIsImlzQWJicmV2aWF0ZWQiLCJzZXRJc0FiYnJldmlhdGVkIiwic2V0dGluZ3MiLCJjdXJyZW50VXNlcklkIiwic2V0Q3VycmVudFVzZXJJZCIsImlzQ2FwdHVyaW5nIiwic2V0SXNDYXB0dXJpbmciLCJjYXB0dXJlQ291bnRlciIsInNldENhcHR1cmVDb3VudGVyIiwicHJvY2Vzc1N0YXR1cyIsInNldFByb2Nlc3NTdGF0dXMiLCJidXR0b25Qcm9wcyIsImNsYXNzTmFtZSIsInRpdGxlIiwidGltZW91dElkIiwiaGFuZGxlUmVzaXplIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlVXNlcklkQ2hhbmdlIiwiZXZlbnQiLCJkZXRhaWwiLCJ0eXBlIiwibmV3VXNlcklkIiwidXNlcklkIiwiYnV0dG9uIiwiZGl2IiwiQWN0aW9uQnV0dG9uR3JvdXBJbm5lciIsInJlZiIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiLCJpc0NvbXBhY3RNb2RlIiwib25BY3Rpb25DbGljayIsInJvdXRlciIsInVwZGF0ZVNldHRpbmdzIiwicmFuZG9tVGltZXMiLCJzZXRSYW5kb21UaW1lcyIsImRlbGF5U2Vjb25kcyIsInNldERlbGF5U2Vjb25kcyIsImNhbnZhc1JlZiIsImNvdW50ZG93blZhbHVlIiwic2V0Q291bnRkb3duVmFsdWUiLCJjdXJyZW50RG90Iiwic2V0Q3VycmVudERvdCIsImNhbGlicmF0aW9uUG9pbnRzIiwic2V0Q2FsaWJyYXRpb25Qb2ludHMiLCJyZW1haW5pbmdDYXB0dXJlcyIsInNldFJlbWFpbmluZ0NhcHR1cmVzIiwic2hvd0NhbnZhcyIsInNldFNob3dDYW52YXMiLCJjYWxpYnJhdGlvbkhhbmRsZXIiLCJzZXRDYWxpYnJhdGlvbkhhbmRsZXIiLCJjYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzaG93SGVhZFBvc2UiLCJzZXRTaG93SGVhZFBvc2UiLCJzaG93Qm91bmRpbmdCb3giLCJzZXRTaG93Qm91bmRpbmdCb3giLCJzaG93TWFzayIsInNldFNob3dNYXNrIiwic2hvd1BhcmFtZXRlcnMiLCJzZXRTaG93UGFyYW1ldGVycyIsImlzQ2FtZXJhQWN0aXZlIiwic2V0SXNDYW1lcmFBY3RpdmUiLCJzaG93UGVybWlzc2lvblBvcHVwIiwic2V0U2hvd1Blcm1pc3Npb25Qb3B1cCIsInNldHRpbmdzQ2FjaGUiLCJNYXAiLCJsYXN0U2V0dGluZ3NVcGRhdGUiLCJjYW52YXNNYW5hZ2VyIiwiQ2FudmFzTWFuYWdlciIsImdldE1haW5DYW52YXMiLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJlbnN1cmVDYW52YXNFeGlzdHMiLCJyZXN0b3JlQ2FudmFzVG9Db250YWluZXIiLCJjYW52YXMiLCJleGl0RnVsbHNjcmVlbiIsImNsZWFudXBDYW52YXMiLCJkZXN0cm95IiwiY2xlYXJDYW52YXMiLCJjbGVhciIsImNhbnZhc1V0aWxzIiwiZW50ZXJGdWxsc2NyZWVuIiwiZHJhd0RvdCIsIngiLCJ5IiwicmFkaXVzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImdldERpbWVuc2lvbnMiLCJoZWlnaHQiLCJpc0Z1bGxzY3JlZW4iLCJpc0luRnVsbHNjcmVlbiIsInJlc2l6ZVRvQ29udGFpbmVyIiwiY29udGFpbmVyIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ1c2VyU2V0dGluZ3MiLCJjYWNoZWRTZXR0aW5ncyIsImN1cnJlbnQiLCJnZXQiLCJOdW1iZXIiLCJ0aW1lc19zZXRfcmFuZG9tIiwiZGVsYXlfc2V0X3JhbmRvbSIsInNldCIsIkRhdGUiLCJub3ciLCJoYW5kbGVTZXR0aW5nc1VwZGF0ZSIsInVuZGVmaW5lZCIsIm5ld1RpbWVzIiwibmV3RGVsYXkiLCJhY3Rpb25CdXR0b25GdW5jdGlvbnMiLCJoYW5kbGVSYW5kb21Eb3QiLCJoYW5kbGVTZXRSYW5kb20iLCJoYW5kbGVTZXRDYWxpYnJhdGUiLCJoYW5kbGVDbGVhckFsbCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNvbnNvbGUiLCJsb2ciLCJ1cGRhdGVDb250cm9sVmFsdWVzIiwidGltZUlucHV0IiwidGltZVZhbHVlIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImlzTmFOIiwiZGVsYXlJbnB1dCIsImRlbGF5VmFsdWUiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJ0YXJnZXRDb250YWluZXIiLCJib2R5IiwidXBkYXRlQ2FudmFzU2l6ZSIsInBhcmVudE5vZGUiLCJhcHBlbmRDaGlsZCIsIndoaXRlU2NyZWVuQ2FudmFzIiwic2V0dXBSZXNwb25zaXZlQ2FudmFzIiwic3R5bGUiLCJkaXNwbGF5IiwiYmFja2dyb3VuZENvbG9yIiwicmVzaXplT2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZW50cnkiLCJ0YXJnZXQiLCJvYnNlcnZlIiwiaGFuZGxlV2luZG93UmVzaXplIiwiX3dpbmRvd1Jlc2l6ZUhhbmRsZXIiLCJvcmlnaW5hbFN0YXRlIiwicGFyZW50IiwicGFyZW50RWxlbWVudCIsInBvc2l0aW9uIiwidG9wIiwibGVmdCIsInpJbmRleCIsImNzc1RleHQiLCJpbm5lckhlaWdodCIsImhpZGVVSUVsZW1lbnRzIiwic2hvd1VJRWxlbWVudHMiLCJlbGVtZW50c1RvSGlkZSIsImZvckVhY2giLCJzZWxlY3RvciIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImVsIiwic2V0QXR0cmlidXRlIiwiaGlkZGVuRWxlbWVudHMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJjbGVhclJlY3QiLCJyZW1vdmVDaGlsZCIsImNvbnN0cnVjdG9yIiwiaGFuZGxlRG90UHJvY2VzcyIsIm9wdGlvbnMiLCJvblN0YXR1c1VwZGF0ZSIsInRvZ2dsZVRvcEJhciIsInVzZVJhbmRvbVBvc2l0aW9uIiwicG9zdENvdW50ZG93bkRlbGF5Iiwia2VlcERvdFZpc2libGVJbnRlcnZhbCIsImNvdW50ZG93bkVsZW1lbnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsIkVycm9yIiwiY2FudmFzV2lkdGgiLCJjYW52YXNIZWlnaHQiLCJkb3RQb3NpdGlvbiIsImRvdFJhZGl1cyIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwiY291bnQiLCJ0ZXh0Q29udGVudCIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsInN1Y2Nlc3MiLCJlcnJvciIsIm1lc3NhZ2UiLCJjbGVhckludGVydmFsIiwicmVtYWluaW5nQ291bnRkb3ducyIsImRlZmF1bHQiLCJTZXRDYWxpYnJhdGVBY3Rpb24iLCJzZXRDYWxpYnJhdGVBY3Rpb24iLCJzaG93Iiwic3RhdHVzIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJTZXRSYW5kb21BY3Rpb24iLCJzZXRSYW5kb21BY3Rpb24iLCJoYW5kbGVBY3Rpb24iLCJSYW5kb21Eb3RBY3Rpb24iLCJyYW5kb21Eb3RBY3Rpb24iLCJzZXR1cENhbGlicmF0aW9uIiwiQ2FsaWJyYXRlSGFuZGxlciIsIndhcm4iLCJtYWtlQ2FudmFzRnVsbHNjcmVlbiIsInBvaW50cyIsImNhbGlicmF0ZUhhbmRsZXIiLCJzZXRPdXRwdXRUZXh0IiwibmV3Q291bnRlciIsInByZXYiLCJjYXB0dXJlRm9sZGVyIiwib25Db21wbGV0ZSIsInN0YXJ0Q2FsaWJyYXRpb24iLCJyZXN0b3JlQ2FudmFzU2l6ZSIsImVyciIsImhhbmRsZVRvZ2dsZUhlYWRQb3NlIiwibmV3SGVhZFBvc2VTdGF0ZSIsInZpZGVvUHJvY2Vzc29yIiwidXBkYXRlT3B0aW9ucyIsImhhbmRsZVRvZ2dsZUJvdW5kaW5nQm94IiwibmV3Qm91bmRpbmdCb3hTdGF0ZSIsImhhbmRsZVRvZ2dsZU1hc2siLCJuZXdNYXNrU3RhdGUiLCJoYW5kbGVUb2dnbGVQYXJhbWV0ZXJzIiwibmV3UGFyYW1ldGVyc1N0YXRlIiwiaGFuZGxlVG9nZ2xlQ2FtZXJhIiwibmV3Q2FtZXJhU3RhdGUiLCJoYW5kbGVQZXJtaXNzaW9uQWNjZXB0ZWQiLCJoYW5kbGVQZXJtaXNzaW9uRGVuaWVkIiwiaGFuZGxlR29CYWNrIiwicHVzaCIsImp1c3RpZnlDb250ZW50IiwiYWxpZ25JdGVtcyIsImJvcmRlclJhZGl1cyIsInBhZGRpbmciLCJib3hTaGFkb3ciLCJoMyIsIm1hcmdpbiIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsInAiLCJsaW5lSGVpZ2h0IiwiZ2FwIiwiYm9yZGVyIiwiY3Vyc29yIiwiY29sb3IiLCJBY3Rpb25CdXR0b25Hcm91cCIsInByb3BzIiwic3NyIiwiQWN0aW9uQnV0dG9uUGFnZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./pages/collected-dataset-customized/components-gui/actionButton.js\n"));

/***/ })

});