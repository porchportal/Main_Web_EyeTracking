"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/collected-dataset-customized",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.jsx":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CalibratePoints.jsx ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearCalibrationPoints: () => (/* binding */ clearCalibrationPoints),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   drawCalibrationGrid: () => (/* binding */ drawCalibrationGrid),\n/* harmony export */   drawCalibrationPoint: () => (/* binding */ drawCalibrationPoint),\n/* harmony export */   drawCalibrationPointLegacy: () => (/* binding */ drawCalibrationPointLegacy),\n/* harmony export */   generateCalibrationPoints: () => (/* binding */ generateCalibrationPoints)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n// CalibratePoints.jsx\n// Utility for generating and managing calibration points on a canvas\n\n/**\n * Get canvas management utilities from global scope (from actionButton.js)\n * @returns {Object} Canvas utilities object\n */ const getCanvasUtils = ()=>{\n    if (true) {\n        return {\n            canvasUtils: window.canvasUtils,\n            canvasManager: window.canvasManager\n        };\n    }\n    return {\n        canvasUtils: null,\n        canvasManager: null\n    };\n};\n/**\n * Get or create canvas using the canvas management system from actionButton.js\n * @returns {HTMLCanvasElement} Canvas element\n */ const getCanvas = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    // First try to use canvasUtils from actionButton.js\n    if (canvasUtils && typeof canvasUtils.getCanvas === 'function') {\n        return canvasUtils.getCanvas();\n    }\n    // Fallback to canvasManager\n    if (canvasManager && typeof canvasManager.getCanvas === 'function') {\n        return canvasManager.getCanvas() || canvasManager.createCanvas();\n    }\n    // Fallback to direct query\n    return document.querySelector('#tracking-canvas');\n};\n/**\n * Transform canvas coordinates to viewport coordinates when in fullscreen\n * @param {HTMLCanvasElement} canvas - Canvas element\n * @param {Object} point - {x, y} point coordinates\n * @returns {Object} Transformed point coordinates\n */ const transformCoordinates = (canvas, point)=>{\n    if (!canvas || !point) return point;\n    // Check if canvas is in fullscreen mode\n    const isFullscreen = canvas.style.position === 'fixed' && (canvas.style.width === '100vw' || canvas.style.width === '100%');\n    if (isFullscreen) {\n        // Get the canvas's bounding rect to understand its position in the viewport\n        const canvasRect = canvas.getBoundingClientRect();\n        // Calculate the scale factors\n        const scaleX = canvasRect.width / canvas.width;\n        const scaleY = canvasRect.height / canvas.height;\n        // Transform the coordinates\n        const transformedPoint = {\n            x: point.x * scaleX + canvasRect.left,\n            y: point.y * scaleY + canvasRect.top,\n            label: point.label\n        };\n        console.log('Coordinate transformation in CalibratePoints:', {\n            original: point,\n            transformed: transformedPoint,\n            canvasRect,\n            scale: {\n                x: scaleX,\n                y: scaleY\n            }\n        });\n        return transformedPoint;\n    }\n    // If not fullscreen, return original coordinates\n    return point;\n};\n/**\n * Draw dot using the canvas management system\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @returns {boolean} Success status\n */ const drawDotWithCanvasManager = function(x, y) {\n    let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 12;\n    const { canvasUtils } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.drawDot === 'function') {\n        return canvasUtils.drawDot(x, y, radius);\n    }\n    // Fallback: manually draw dot\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        drawCalibrationPointLegacy(ctx, x, y, radius);\n        return true;\n    }\n    return false;\n};\n/**\n * Clear canvas using the canvas management system\n */ const clearCanvasWithManager = ()=>{\n    const { canvasUtils, canvasManager } = getCanvasUtils();\n    if (canvasUtils && typeof canvasUtils.clear === 'function') {\n        canvasUtils.clear();\n        return;\n    }\n    if (canvasManager && typeof canvasManager.clear === 'function') {\n        canvasManager.clear();\n        return;\n    }\n    // Fallback: manually clear canvas\n    const canvas = getCanvas();\n    if (canvas) {\n        const ctx = canvas.getContext('2d');\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n};\n/**\n * Generate a grid of calibration points based on canvas dimensions\n * @param {number} width - Canvas width\n * @param {number} height - Canvas height\n * @returns {Array} Array of point objects with x,y coordinates\n */ const generateCalibrationPoints = (width, height)=>{\n    if (!width || !height || width <= 0 || height <= 0) {\n        console.error(\"generateCalibrationPoints: Invalid canvas dimensions\", {\n            width,\n            height\n        });\n        return [];\n    }\n    const conditionalRound = (dimension, percentage)=>Math.round(dimension * percentage);\n    // Outer frame (12% from edges)\n    const xLeftOuter = conditionalRound(width, 0.12);\n    const xRightOuter = width - xLeftOuter;\n    const yTopOuter = conditionalRound(height, 0.12);\n    const yBottomOuter = height - yTopOuter;\n    // Inner frame (26% from edges)\n    const xLeftInner = conditionalRound(width, 0.26);\n    const xRightInner = width - xLeftInner;\n    const yTopInner = conditionalRound(height, 0.26);\n    const yBottomInner = height - yTopInner;\n    const xCenter = Math.floor(width / 2);\n    const yCenter = Math.floor(height / 2);\n    return [\n        // Outer frame (8 points)\n        {\n            x: xLeftOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopOuter,\n            label: \"Outer Top-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yTopOuter,\n            label: \"Outer Top-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yCenter,\n            label: \"Outer Middle-Left\"\n        },\n        {\n            x: xRightOuter,\n            y: yCenter,\n            label: \"Outer Middle-Right\"\n        },\n        {\n            x: xLeftOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Center\"\n        },\n        {\n            x: xRightOuter,\n            y: yBottomOuter,\n            label: \"Outer Bottom-Right\"\n        },\n        // Inner frame (8 points)\n        {\n            x: xLeftInner,\n            y: yTopInner,\n            label: \"Inner Top-Left\"\n        },\n        {\n            x: xCenter,\n            y: yTopInner,\n            label: \"Inner Top-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yTopInner,\n            label: \"Inner Top-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yCenter,\n            label: \"Inner Middle-Left\"\n        },\n        {\n            x: xRightInner,\n            y: yCenter,\n            label: \"Inner Middle-Right\"\n        },\n        {\n            x: xLeftInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Left\"\n        },\n        {\n            x: xCenter,\n            y: yBottomInner,\n            label: \"Inner Bottom-Center\"\n        },\n        {\n            x: xRightInner,\n            y: yBottomInner,\n            label: \"Inner Bottom-Right\"\n        }\n    ];\n};\n/**\n * Draw a calibration point on a canvas using the canvas management system\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {Object} options - Optional settings (color, radius)\n * @returns {Object} Point position object {x, y}\n */ const drawCalibrationPoint = function(x, y) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const radius = options.radius || 12; // Use standard radius\n    const success = drawDotWithCanvasManager(x, y, radius);\n    return {\n        x,\n        y,\n        success\n    };\n};\n/**\n * Legacy function for backward compatibility (draws directly on canvas context)\n * @param {CanvasRenderingContext2D} ctx - Canvas 2D context\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @param {number} radius - Dot radius\n * @returns {Object} Point position object {x, y}\n */ const drawCalibrationPointLegacy = function(ctx, x, y) {\n    let radius = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 12;\n    if (!ctx) return {\n        x,\n        y\n    };\n    const canvas = ctx.canvas;\n    // Clear the canvas\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'yellow';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    // Draw the dot with a bright red color\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fillStyle = 'red';\n    ctx.fill();\n    // Add glow effect for better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 3, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n    ctx.lineWidth = 3;\n    ctx.stroke();\n    // Add a second larger glow for even better visibility\n    ctx.beginPath();\n    ctx.arc(x, y, radius + 6, 0, Math.PI * 2);\n    ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\n    ctx.lineWidth = 2;\n    ctx.stroke();\n    console.log(\"Drew calibration point at (\".concat(x, \", \").concat(y, \") with radius \").concat(radius));\n    return {\n        x,\n        y\n    };\n};\n/**\n * Draw all calibration points on a canvas (for debugging/visualization)\n * @param {Array} points - Array of point objects\n * @param {number} activeIndex - Index of the currently active point\n */ const drawCalibrationGrid = function(points) {\n    let activeIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;\n    if (!points || !points.length) return;\n    const canvas = getCanvas();\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    clearCanvasWithManager();\n    points.forEach((point, index)=>{\n        const isActive = index === activeIndex;\n        const radius = isActive ? 12 : 6; // Use standard radius for active, smaller for inactive\n        // Draw the point\n        ctx.beginPath();\n        ctx.arc(point.x, point.y, radius, 0, Math.PI * 2);\n        ctx.fillStyle = isActive ? 'red' : 'rgba(0, 102, 204, 0.7)';\n        ctx.fill();\n        // Add glow effect for active points\n        if (isActive) {\n            ctx.beginPath();\n            ctx.arc(point.x, point.y, radius + 3, 0, Math.PI * 2);\n            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';\n            ctx.lineWidth = 3;\n            ctx.stroke();\n        }\n        // Draw point number\n        ctx.fillStyle = 'white';\n        ctx.font = '10px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(\"\".concat(index + 1), point.x, point.y);\n        // Draw label for active point\n        if (isActive && point.label) {\n            ctx.font = '12px Arial';\n            ctx.fillStyle = 'black';\n            ctx.fillText(point.label, point.x, point.y - 25);\n        }\n    });\n    // Draw connecting lines (optional)\n    if (points.length > 1) {\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        for(let i = 1; i < points.length; i++){\n            ctx.lineTo(points[i].x, points[i].y);\n        }\n        ctx.strokeStyle = 'rgba(0, 102, 204, 0.3)';\n        ctx.lineWidth = 1;\n        ctx.stroke();\n    }\n};\n/**\n * Clear all calibration points from canvas\n */ const clearCalibrationPoints = ()=>{\n    clearCanvasWithManager();\n};\n// Default export for React compatibility\nconst CalibratePoints = ()=>null; // This is a utility file, so we don't need to render anything\n_c = CalibratePoints;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibratePoints);\nvar _c;\n$RefreshReg$(_c, \"CalibratePoints\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLHNCQUFzQjtBQUN0QixxRUFBcUU7QUFFM0M7QUFFMUI7OztDQUdDLEdBQ0QsTUFBTUMsaUJBQWlCO0lBQ3JCLElBQUksSUFBNkIsRUFBRTtRQUNqQyxPQUFPO1lBQ0xDLGFBQWFDLE9BQU9ELFdBQVc7WUFDL0JFLGVBQWVELE9BQU9DLGFBQWE7UUFDckM7SUFDRjtJQUNBLE9BQU87UUFBRUYsYUFBYTtRQUFNRSxlQUFlO0lBQUs7QUFDbEQ7QUFFQTs7O0NBR0MsR0FDRCxNQUFNQyxZQUFZO0lBQ2hCLE1BQU0sRUFBRUgsV0FBVyxFQUFFRSxhQUFhLEVBQUUsR0FBR0g7SUFFdkMsb0RBQW9EO0lBQ3BELElBQUlDLGVBQWUsT0FBT0EsWUFBWUcsU0FBUyxLQUFLLFlBQVk7UUFDOUQsT0FBT0gsWUFBWUcsU0FBUztJQUM5QjtJQUVBLDRCQUE0QjtJQUM1QixJQUFJRCxpQkFBaUIsT0FBT0EsY0FBY0MsU0FBUyxLQUFLLFlBQVk7UUFDbEUsT0FBT0QsY0FBY0MsU0FBUyxNQUFNRCxjQUFjRSxZQUFZO0lBQ2hFO0lBRUEsMkJBQTJCO0lBQzNCLE9BQU9DLFNBQVNDLGFBQWEsQ0FBQztBQUNoQztBQUVBOzs7OztDQUtDLEdBQ0QsTUFBTUMsdUJBQXVCLENBQUNDLFFBQVFDO0lBQ3BDLElBQUksQ0FBQ0QsVUFBVSxDQUFDQyxPQUFPLE9BQU9BO0lBRTlCLHdDQUF3QztJQUN4QyxNQUFNQyxlQUFlRixPQUFPRyxLQUFLLENBQUNDLFFBQVEsS0FBSyxXQUMxQkosQ0FBQUEsT0FBT0csS0FBSyxDQUFDRSxLQUFLLEtBQUssV0FBV0wsT0FBT0csS0FBSyxDQUFDRSxLQUFLLEtBQUssTUFBSztJQUVuRixJQUFJSCxjQUFjO1FBQ2hCLDRFQUE0RTtRQUM1RSxNQUFNSSxh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ZC9BY3Rpb24vQ2FsaWJyYXRlUG9pbnRzLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDYWxpYnJhdGVQb2ludHMuanN4XG4vLyBVdGlsaXR5IGZvciBnZW5lcmF0aW5nIGFuZCBtYW5hZ2luZyBjYWxpYnJhdGlvbiBwb2ludHMgb24gYSBjYW52YXNcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBHZXQgY2FudmFzIG1hbmFnZW1lbnQgdXRpbGl0aWVzIGZyb20gZ2xvYmFsIHNjb3BlIChmcm9tIGFjdGlvbkJ1dHRvbi5qcylcbiAqIEByZXR1cm5zIHtPYmplY3R9IENhbnZhcyB1dGlsaXRpZXMgb2JqZWN0XG4gKi9cbmNvbnN0IGdldENhbnZhc1V0aWxzID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzVXRpbHM6IHdpbmRvdy5jYW52YXNVdGlscyxcbiAgICAgIGNhbnZhc01hbmFnZXI6IHdpbmRvdy5jYW52YXNNYW5hZ2VyXG4gICAgfTtcbiAgfVxuICByZXR1cm4geyBjYW52YXNVdGlsczogbnVsbCwgY2FudmFzTWFuYWdlcjogbnVsbCB9O1xufTtcblxuLyoqXG4gKiBHZXQgb3IgY3JlYXRlIGNhbnZhcyB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtIGZyb20gYWN0aW9uQnV0dG9uLmpzXG4gKiBAcmV0dXJucyB7SFRNTENhbnZhc0VsZW1lbnR9IENhbnZhcyBlbGVtZW50XG4gKi9cbmNvbnN0IGdldENhbnZhcyA9ICgpID0+IHtcbiAgY29uc3QgeyBjYW52YXNVdGlscywgY2FudmFzTWFuYWdlciB9ID0gZ2V0Q2FudmFzVXRpbHMoKTtcbiAgXG4gIC8vIEZpcnN0IHRyeSB0byB1c2UgY2FudmFzVXRpbHMgZnJvbSBhY3Rpb25CdXR0b24uanNcbiAgaWYgKGNhbnZhc1V0aWxzICYmIHR5cGVvZiBjYW52YXNVdGlscy5nZXRDYW52YXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY2FudmFzVXRpbHMuZ2V0Q2FudmFzKCk7XG4gIH1cbiAgXG4gIC8vIEZhbGxiYWNrIHRvIGNhbnZhc01hbmFnZXJcbiAgaWYgKGNhbnZhc01hbmFnZXIgJiYgdHlwZW9mIGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCkgfHwgY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2sgdG8gZGlyZWN0IHF1ZXJ5XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBjYW52YXMgY29vcmRpbmF0ZXMgdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMgd2hlbiBpbiBmdWxsc2NyZWVuXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSBDYW52YXMgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHBvaW50IC0ge3gsIHl9IHBvaW50IGNvb3JkaW5hdGVzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUcmFuc2Zvcm1lZCBwb2ludCBjb29yZGluYXRlc1xuICovXG5jb25zdCB0cmFuc2Zvcm1Db29yZGluYXRlcyA9IChjYW52YXMsIHBvaW50KSA9PiB7XG4gIGlmICghY2FudmFzIHx8ICFwb2ludCkgcmV0dXJuIHBvaW50O1xuICBcbiAgLy8gQ2hlY2sgaWYgY2FudmFzIGlzIGluIGZ1bGxzY3JlZW4gbW9kZVxuICBjb25zdCBpc0Z1bGxzY3JlZW4gPSBjYW52YXMuc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgKGNhbnZhcy5zdHlsZS53aWR0aCA9PT0gJzEwMHZ3JyB8fCBjYW52YXMuc3R5bGUud2lkdGggPT09ICcxMDAlJyk7XG4gIFxuICBpZiAoaXNGdWxsc2NyZWVuKSB7XG4gICAgLy8gR2V0IHRoZSBjYW52YXMncyBib3VuZGluZyByZWN0IHRvIHVuZGVyc3RhbmQgaXRzIHBvc2l0aW9uIGluIHRoZSB2aWV3cG9ydFxuICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3JzXG4gICAgY29uc3Qgc2NhbGVYID0gY2FudmFzUmVjdC53aWR0aCAvIGNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBjYW52YXNSZWN0LmhlaWdodCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBjb29yZGluYXRlc1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkUG9pbnQgPSB7XG4gICAgICB4OiBwb2ludC54ICogc2NhbGVYICsgY2FudmFzUmVjdC5sZWZ0LFxuICAgICAgeTogcG9pbnQueSAqIHNjYWxlWSArIGNhbnZhc1JlY3QudG9wLFxuICAgICAgbGFiZWw6IHBvaW50LmxhYmVsXG4gICAgfTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvbiBpbiBDYWxpYnJhdGVQb2ludHM6Jywge1xuICAgICAgb3JpZ2luYWw6IHBvaW50LFxuICAgICAgdHJhbnNmb3JtZWQ6IHRyYW5zZm9ybWVkUG9pbnQsXG4gICAgICBjYW52YXNSZWN0LFxuICAgICAgc2NhbGU6IHsgeDogc2NhbGVYLCB5OiBzY2FsZVkgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0cmFuc2Zvcm1lZFBvaW50O1xuICB9XG4gIFxuICAvLyBJZiBub3QgZnVsbHNjcmVlbiwgcmV0dXJuIG9yaWdpbmFsIGNvb3JkaW5hdGVzXG4gIHJldHVybiBwb2ludDtcbn07XG5cbi8qKlxuICogRHJhdyBkb3QgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gRG90IHJhZGl1c1xuICogQHJldHVybnMge2Jvb2xlYW59IFN1Y2Nlc3Mgc3RhdHVzXG4gKi9cbmNvbnN0IGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlciA9ICh4LCB5LCByYWRpdXMgPSAxMikgPT4ge1xuICBjb25zdCB7IGNhbnZhc1V0aWxzIH0gPSBnZXRDYW52YXNVdGlscygpO1xuICBcbiAgaWYgKGNhbnZhc1V0aWxzICYmIHR5cGVvZiBjYW52YXNVdGlscy5kcmF3RG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNhbnZhc1V0aWxzLmRyYXdEb3QoeCwgeSwgcmFkaXVzKTtcbiAgfVxuICBcbiAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGRyYXcgZG90XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICBpZiAoY2FudmFzKSB7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZHJhd0NhbGlicmF0aW9uUG9pbnRMZWdhY3koY3R4LCB4LCB5LCByYWRpdXMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ2xlYXIgY2FudmFzIHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAqL1xuY29uc3QgY2xlYXJDYW52YXNXaXRoTWFuYWdlciA9ICgpID0+IHtcbiAgY29uc3QgeyBjYW52YXNVdGlscywgY2FudmFzTWFuYWdlciB9ID0gZ2V0Q2FudmFzVXRpbHMoKTtcbiAgXG4gIGlmIChjYW52YXNVdGlscyAmJiB0eXBlb2YgY2FudmFzVXRpbHMuY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYW52YXNVdGlscy5jbGVhcigpO1xuICAgIHJldHVybjtcbiAgfVxuICBcbiAgaWYgKGNhbnZhc01hbmFnZXIgJiYgdHlwZW9mIGNhbnZhc01hbmFnZXIuY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYW52YXNNYW5hZ2VyLmNsZWFyKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICAvLyBGYWxsYmFjazogbWFudWFsbHkgY2xlYXIgY2FudmFzXG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcygpO1xuICBpZiAoY2FudmFzKSB7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZ3JpZCBvZiBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gY2FudmFzIGRpbWVuc2lvbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIENhbnZhcyB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIENhbnZhcyBoZWlnaHRcbiAqIEByZXR1cm5zIHtBcnJheX0gQXJyYXkgb2YgcG9pbnQgb2JqZWN0cyB3aXRoIHgseSBjb29yZGluYXRlc1xuICovXG5leHBvcnQgY29uc3QgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gIGlmICghd2lkdGggfHwgIWhlaWdodCB8fCB3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgY29uc29sZS5lcnJvcihcImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHM6IEludmFsaWQgY2FudmFzIGRpbWVuc2lvbnNcIiwgeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IGNvbmRpdGlvbmFsUm91bmQgPSAoZGltZW5zaW9uLCBwZXJjZW50YWdlKSA9PiBNYXRoLnJvdW5kKGRpbWVuc2lvbiAqIHBlcmNlbnRhZ2UpO1xuXG4gIC8vIE91dGVyIGZyYW1lICgxMiUgZnJvbSBlZGdlcylcbiAgY29uc3QgeExlZnRPdXRlciA9IGNvbmRpdGlvbmFsUm91bmQod2lkdGgsIDAuMTIpO1xuICBjb25zdCB4UmlnaHRPdXRlciA9IHdpZHRoIC0geExlZnRPdXRlcjtcbiAgY29uc3QgeVRvcE91dGVyID0gY29uZGl0aW9uYWxSb3VuZChoZWlnaHQsIDAuMTIpO1xuICBjb25zdCB5Qm90dG9tT3V0ZXIgPSBoZWlnaHQgLSB5VG9wT3V0ZXI7XG5cbiAgLy8gSW5uZXIgZnJhbWUgKDI2JSBmcm9tIGVkZ2VzKVxuICBjb25zdCB4TGVmdElubmVyID0gY29uZGl0aW9uYWxSb3VuZCh3aWR0aCwgMC4yNik7XG4gIGNvbnN0IHhSaWdodElubmVyID0gd2lkdGggLSB4TGVmdElubmVyO1xuICBjb25zdCB5VG9wSW5uZXIgPSBjb25kaXRpb25hbFJvdW5kKGhlaWdodCwgMC4yNik7XG4gIGNvbnN0IHlCb3R0b21Jbm5lciA9IGhlaWdodCAtIHlUb3BJbm5lcjtcblxuICBjb25zdCB4Q2VudGVyID0gTWF0aC5mbG9vcih3aWR0aCAvIDIpO1xuICBjb25zdCB5Q2VudGVyID0gTWF0aC5mbG9vcihoZWlnaHQgLyAyKTtcblxuICByZXR1cm4gW1xuICAgIC8vIE91dGVyIGZyYW1lICg4IHBvaW50cylcbiAgICB7IHg6IHhMZWZ0T3V0ZXIsIHk6IHlUb3BPdXRlciwgbGFiZWw6IFwiT3V0ZXIgVG9wLUxlZnRcIiB9LFxuICAgIHsgeDogeENlbnRlciwgeTogeVRvcE91dGVyLCBsYWJlbDogXCJPdXRlciBUb3AtQ2VudGVyXCIgfSxcbiAgICB7IHg6IHhSaWdodE91dGVyLCB5OiB5VG9wT3V0ZXIsIGxhYmVsOiBcIk91dGVyIFRvcC1SaWdodFwiIH0sXG4gICAgeyB4OiB4TGVmdE91dGVyLCB5OiB5Q2VudGVyLCBsYWJlbDogXCJPdXRlciBNaWRkbGUtTGVmdFwiIH0sXG4gICAgeyB4OiB4UmlnaHRPdXRlciwgeTogeUNlbnRlciwgbGFiZWw6IFwiT3V0ZXIgTWlkZGxlLVJpZ2h0XCIgfSxcbiAgICB7IHg6IHhMZWZ0T3V0ZXIsIHk6IHlCb3R0b21PdXRlciwgbGFiZWw6IFwiT3V0ZXIgQm90dG9tLUxlZnRcIiB9LFxuICAgIHsgeDogeENlbnRlciwgeTogeUJvdHRvbU91dGVyLCBsYWJlbDogXCJPdXRlciBCb3R0b20tQ2VudGVyXCIgfSxcbiAgICB7IHg6IHhSaWdodE91dGVyLCB5OiB5Qm90dG9tT3V0ZXIsIGxhYmVsOiBcIk91dGVyIEJvdHRvbS1SaWdodFwiIH0sXG5cbiAgICAvLyBJbm5lciBmcmFtZSAoOCBwb2ludHMpXG4gICAgeyB4OiB4TGVmdElubmVyLCB5OiB5VG9wSW5uZXIsIGxhYmVsOiBcIklubmVyIFRvcC1MZWZ0XCIgfSxcbiAgICB7IHg6IHhDZW50ZXIsIHk6IHlUb3BJbm5lciwgbGFiZWw6IFwiSW5uZXIgVG9wLUNlbnRlclwiIH0sXG4gICAgeyB4OiB4UmlnaHRJbm5lciwgeTogeVRvcElubmVyLCBsYWJlbDogXCJJbm5lciBUb3AtUmlnaHRcIiB9LFxuICAgIHsgeDogeExlZnRJbm5lciwgeTogeUNlbnRlciwgbGFiZWw6IFwiSW5uZXIgTWlkZGxlLUxlZnRcIiB9LFxuICAgIHsgeDogeFJpZ2h0SW5uZXIsIHk6IHlDZW50ZXIsIGxhYmVsOiBcIklubmVyIE1pZGRsZS1SaWdodFwiIH0sXG4gICAgeyB4OiB4TGVmdElubmVyLCB5OiB5Qm90dG9tSW5uZXIsIGxhYmVsOiBcIklubmVyIEJvdHRvbS1MZWZ0XCIgfSxcbiAgICB7IHg6IHhDZW50ZXIsIHk6IHlCb3R0b21Jbm5lciwgbGFiZWw6IFwiSW5uZXIgQm90dG9tLUNlbnRlclwiIH0sXG4gICAgeyB4OiB4UmlnaHRJbm5lciwgeTogeUJvdHRvbUlubmVyLCBsYWJlbDogXCJJbm5lciBCb3R0b20tUmlnaHRcIiB9XG4gIF07XG59O1xuXG4vKipcbiAqIERyYXcgYSBjYWxpYnJhdGlvbiBwb2ludCBvbiBhIGNhbnZhcyB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFggY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBZIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uYWwgc2V0dGluZ3MgKGNvbG9yLCByYWRpdXMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBQb2ludCBwb3NpdGlvbiBvYmplY3Qge3gsIHl9XG4gKi9cbmV4cG9ydCBjb25zdCBkcmF3Q2FsaWJyYXRpb25Qb2ludCA9ICh4LCB5LCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMTI7IC8vIFVzZSBzdGFuZGFyZCByYWRpdXNcbiAgY29uc3Qgc3VjY2VzcyA9IGRyYXdEb3RXaXRoQ2FudmFzTWFuYWdlcih4LCB5LCByYWRpdXMpO1xuICByZXR1cm4geyB4LCB5LCBzdWNjZXNzIH07XG59O1xuXG4vKipcbiAqIExlZ2FjeSBmdW5jdGlvbiBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSAoZHJhd3MgZGlyZWN0bHkgb24gY2FudmFzIGNvbnRleHQpXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQ2FudmFzIDJEIGNvbnRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIERvdCByYWRpdXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFBvaW50IHBvc2l0aW9uIG9iamVjdCB7eCwgeX1cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYXdDYWxpYnJhdGlvblBvaW50TGVnYWN5ID0gKGN0eCwgeCwgeSwgcmFkaXVzID0gMTIpID0+IHtcbiAgaWYgKCFjdHgpIHJldHVybiB7IHgsIHkgfTtcblxuICBjb25zdCBjYW52YXMgPSBjdHguY2FudmFzO1xuICBcbiAgLy8gQ2xlYXIgdGhlIGNhbnZhc1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5maWxsU3R5bGUgPSAneWVsbG93JztcbiAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgLy8gRHJhdyB0aGUgZG90IHdpdGggYSBicmlnaHQgcmVkIGNvbG9yXG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcbiAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICBjdHguZmlsbCgpO1xuICBcbiAgLy8gQWRkIGdsb3cgZWZmZWN0IGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgcmFkaXVzICsgMywgMCwgTWF0aC5QSSAqIDIpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICBjdHgubGluZVdpZHRoID0gMztcbiAgY3R4LnN0cm9rZSgpO1xuICBcbiAgLy8gQWRkIGEgc2Vjb25kIGxhcmdlciBnbG93IGZvciBldmVuIGJldHRlciB2aXNpYmlsaXR5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCByYWRpdXMgKyA2LCAwLCBNYXRoLlBJICogMik7XG4gIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDI1NSwgMCwgMCwgMC4zKSc7XG4gIGN0eC5saW5lV2lkdGggPSAyO1xuICBjdHguc3Ryb2tlKCk7XG5cbiAgY29uc29sZS5sb2coYERyZXcgY2FsaWJyYXRpb24gcG9pbnQgYXQgKCR7eH0sICR7eX0pIHdpdGggcmFkaXVzICR7cmFkaXVzfWApO1xuICByZXR1cm4geyB4LCB5IH07XG59O1xuXG4vKipcbiAqIERyYXcgYWxsIGNhbGlicmF0aW9uIHBvaW50cyBvbiBhIGNhbnZhcyAoZm9yIGRlYnVnZ2luZy92aXN1YWxpemF0aW9uKVxuICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIC0gQXJyYXkgb2YgcG9pbnQgb2JqZWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGFjdGl2ZUluZGV4IC0gSW5kZXggb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgcG9pbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGRyYXdDYWxpYnJhdGlvbkdyaWQgPSAocG9pbnRzLCBhY3RpdmVJbmRleCA9IC0xKSA9PiB7XG4gIGlmICghcG9pbnRzIHx8ICFwb2ludHMubGVuZ3RoKSByZXR1cm47XG5cbiAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKCk7XG4gIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGNsZWFyQ2FudmFzV2l0aE1hbmFnZXIoKTtcblxuICBwb2ludHMuZm9yRWFjaCgocG9pbnQsIGluZGV4KSA9PiB7XG4gICAgY29uc3QgaXNBY3RpdmUgPSBpbmRleCA9PT0gYWN0aXZlSW5kZXg7XG4gICAgY29uc3QgcmFkaXVzID0gaXNBY3RpdmUgPyAxMiA6IDY7IC8vIFVzZSBzdGFuZGFyZCByYWRpdXMgZm9yIGFjdGl2ZSwgc21hbGxlciBmb3IgaW5hY3RpdmVcblxuICAgIC8vIERyYXcgdGhlIHBvaW50XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGlzQWN0aXZlID8gJ3JlZCcgOiAncmdiYSgwLCAxMDIsIDIwNCwgMC43KSc7XG4gICAgY3R4LmZpbGwoKTtcblxuICAgIC8vIEFkZCBnbG93IGVmZmVjdCBmb3IgYWN0aXZlIHBvaW50c1xuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCByYWRpdXMgKyAzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNSknO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IDM7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLy8gRHJhdyBwb2ludCBudW1iZXJcbiAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjdHguZm9udCA9ICcxMHB4IEFyaWFsJztcbiAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5maWxsVGV4dChgJHtpbmRleCArIDF9YCwgcG9pbnQueCwgcG9pbnQueSk7XG5cbiAgICAvLyBEcmF3IGxhYmVsIGZvciBhY3RpdmUgcG9pbnRcbiAgICBpZiAoaXNBY3RpdmUgJiYgcG9pbnQubGFiZWwpIHtcbiAgICAgIGN0eC5mb250ID0gJzEycHggQXJpYWwnO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdibGFjayc7XG4gICAgICBjdHguZmlsbFRleHQocG9pbnQubGFiZWwsIHBvaW50LngsIHBvaW50LnkgLSAyNSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBEcmF3IGNvbm5lY3RpbmcgbGluZXMgKG9wdGlvbmFsKVxuICBpZiAocG9pbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdHgubGluZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdyZ2JhKDAsIDEwMiwgMjA0LCAwLjMpJztcbiAgICBjdHgubGluZVdpZHRoID0gMTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgYWxsIGNhbGlicmF0aW9uIHBvaW50cyBmcm9tIGNhbnZhc1xuICovXG5leHBvcnQgY29uc3QgY2xlYXJDYWxpYnJhdGlvblBvaW50cyA9ICgpID0+IHtcbiAgY2xlYXJDYW52YXNXaXRoTWFuYWdlcigpO1xufTtcblxuLy8gRGVmYXVsdCBleHBvcnQgZm9yIFJlYWN0IGNvbXBhdGliaWxpdHlcbmNvbnN0IENhbGlicmF0ZVBvaW50cyA9ICgpID0+IG51bGw7IC8vIFRoaXMgaXMgYSB1dGlsaXR5IGZpbGUsIHNvIHdlIGRvbid0IG5lZWQgdG8gcmVuZGVyIGFueXRoaW5nXG5cbmV4cG9ydCBkZWZhdWx0IENhbGlicmF0ZVBvaW50czsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiZ2V0Q2FudmFzVXRpbHMiLCJjYW52YXNVdGlscyIsIndpbmRvdyIsImNhbnZhc01hbmFnZXIiLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ0cmFuc2Zvcm1Db29yZGluYXRlcyIsImNhbnZhcyIsInBvaW50IiwiaXNGdWxsc2NyZWVuIiwic3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiY2FudmFzUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNjYWxlWCIsInNjYWxlWSIsImhlaWdodCIsInRyYW5zZm9ybWVkUG9pbnQiLCJ4IiwibGVmdCIsInkiLCJ0b3AiLCJsYWJlbCIsImNvbnNvbGUiLCJsb2ciLCJvcmlnaW5hbCIsInRyYW5zZm9ybWVkIiwic2NhbGUiLCJkcmF3RG90V2l0aENhbnZhc01hbmFnZXIiLCJyYWRpdXMiLCJkcmF3RG90IiwiY3R4IiwiZ2V0Q29udGV4dCIsImRyYXdDYWxpYnJhdGlvblBvaW50TGVnYWN5IiwiY2xlYXJDYW52YXNXaXRoTWFuYWdlciIsImNsZWFyIiwiY2xlYXJSZWN0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZXJyb3IiLCJjb25kaXRpb25hbFJvdW5kIiwiZGltZW5zaW9uIiwicGVyY2VudGFnZSIsIk1hdGgiLCJyb3VuZCIsInhMZWZ0T3V0ZXIiLCJ4UmlnaHRPdXRlciIsInlUb3BPdXRlciIsInlCb3R0b21PdXRlciIsInhMZWZ0SW5uZXIiLCJ4UmlnaHRJbm5lciIsInlUb3BJbm5lciIsInlCb3R0b21Jbm5lciIsInhDZW50ZXIiLCJmbG9vciIsInlDZW50ZXIiLCJkcmF3Q2FsaWJyYXRpb25Qb2ludCIsIm9wdGlvbnMiLCJzdWNjZXNzIiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJmaWxsIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2UiLCJkcmF3Q2FsaWJyYXRpb25HcmlkIiwicG9pbnRzIiwiYWN0aXZlSW5kZXgiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaW5kZXgiLCJpc0FjdGl2ZSIsImZvbnQiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJmaWxsVGV4dCIsIm1vdmVUbyIsImkiLCJsaW5lVG8iLCJjbGVhckNhbGlicmF0aW9uUG9pbnRzIiwiQ2FsaWJyYXRlUG9pbnRzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.jsx\n"));

/***/ })

});