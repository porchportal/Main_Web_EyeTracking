"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_SetCalibrateAction_js",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.js":
/*!******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.js ***!
  \******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.js\n// Handles the calibration sequence functionality\n\n\n\nclass SetCalibrateAction {\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        var _this_canvasRef;\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas() {\n        let maxTries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20, interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Starting calibration sequence...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Use canvas manager to enter fullscreen\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate calibration points based on canvas size\n                    const points = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = \"\\n          position: fixed;\\n          top: 20px;\\n          right: 20px;\\n          background-color: rgba(0, 102, 204, 0.9);\\n          color: white;\\n          font-size: 16px;\\n          font-weight: bold;\\n          padding: 10px 15px;\\n          border-radius: 8px;\\n          z-index: 10000;\\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n        \";\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        // Update status displays\n                        statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                        this.setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                        // Clear canvas with white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        // Draw the calibration point\n                        const radius = 14; // Slightly larger for better visibility\n                        (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        }, 50);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = \"\\n            position: fixed;\\n            left: \".concat(point.x, \"px;\\n            top: \").concat(point.y - 60, \"px;\\n            transform: translateX(-50%);\\n            color: red;\\n            font-size: 36px;\\n            font-weight: bold;\\n            text-shadow: 0 0 10px white, 0 0 20px white;\\n            z-index: 10000;\\n            background-color: rgba(255, 255, 255, 0.8);\\n            border: 2px solid red;\\n            border-radius: 50%;\\n            width: 50px;\\n            height: 50px;\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n          \");\n                        document.body.appendChild(countdownElement);\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                                // Force redraw to ensure dot stays visible\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"âœ“\";\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Remove countdown element after delay\n                            setTimeout(()=>{\n                                if (countdownElement.parentNode) {\n                                    countdownElement.parentNode.removeChild(countdownElement);\n                                }\n                            }, 300);\n                            // Make sure dot is still visible\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Capture images at this point\n                            console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_2__.captureImagesAtPoint)({\n                                point: point,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_1__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                    }\n                    this.setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(\"Calibration error: \".concat(error.message));\n                } finally{\n                    // Exit fullscreen and restore canvas\n                    if (this.canvasManager) {\n                        this.canvasManager.exitFullscreen();\n                    }\n                    this.setIsCapturing(false);\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(true);\n                        }\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  true ? window.canvasManager : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx3QkFBd0I7QUFDeEIsaURBQWlEO0FBRWE7QUFDYTtBQUNqQjtBQUUxRCxNQUFNSztJQWtCSixtREFBbUQ7SUFDbkRDLFlBQVk7WUFNSDtRQUxQLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDdEIsT0FBTyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0QsU0FBUyxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxZQUFZO1FBQzFFO1FBRUEsdURBQXVEO1FBQ3ZELE9BQU8sd0JBQUksQ0FBQ0MsU0FBUyxjQUFkLHNEQUFnQkMsT0FBTyxLQUFJQyxTQUFTQyxhQUFhLENBQUM7SUFDM0Q7SUFFQSxtQ0FBbUM7SUFDbkMsTUFBTUMsZ0JBQTZDO1lBQS9CQyxXQUFBQSxpRUFBVyxJQUFJQyxXQUFBQSxpRUFBVztRQUM1QyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUUsSUFBSztZQUNqQyxNQUFNQyxTQUFTLElBQUksQ0FBQ1gsU0FBUztZQUM3QixJQUFJVyxVQUFVQSxPQUFPQyxLQUFLLEdBQUcsS0FBS0QsT0FBT0UsTUFBTSxHQUFHLEdBQUc7Z0JBQ25ELE9BQU9GO1lBQ1Q7WUFDQSxNQUFNLElBQUlHLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVNOO1FBQ25EO1FBQ0EsTUFBTSxJQUFJUSxNQUFNO0lBQ2xCO0lBckNBQyxZQUFZQyxNQUFNLENBQUU7UUF1Q3BCLCtDQUErQzthQUMvQ0MscUJBQXFCO1lBQ25CLDhDQUE4QztZQUM5QyxJQUFJLE9BQU8sSUFBSSxDQUFDQyxZQUFZLEtBQUssWUFBWTtnQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7WUFDcEIsT0FBTyxJQUFJLEtBQTZCLElBQUlDLE9BQU9ELFlBQVksRUFBRTtnQkFDL0RDLE9B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YUFBYSxHQUFHLENBQUk7SUFDbEY7QUF5T0Y7QUFFQSxpRUFBZUYsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNldENhbGlicmF0ZUFjdGlvbi5qc1xuLy8gSGFuZGxlcyB0aGUgY2FsaWJyYXRpb24gc2VxdWVuY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSBmcm9tICcuL2NvdW50U2F2ZSc7XG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uL0hlbHBlci9zYXZlZmlsZSc7XG5cbmNsYXNzIFNldENhbGlicmF0ZUFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8vIFJlcXVpcmVkIHByb3BlcnRpZXNcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcgPSBjb25maWcuc2V0SXNDYXB0dXJpbmc7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzID0gY29uZmlnLnNldFByb2Nlc3NTdGF0dXM7XG4gICAgdGhpcy5zZXRDdXJyZW50RG90ID0gY29uZmlnLnNldEN1cnJlbnREb3Q7XG4gICAgdGhpcy50cmlnZ2VyQ2FtZXJhQWNjZXNzID0gY29uZmlnLnRyaWdnZXJDYW1lcmFBY2Nlc3M7XG4gICAgdGhpcy5vblN0YXR1c1VwZGF0ZSA9IGNvbmZpZy5vblN0YXR1c1VwZGF0ZTtcbiAgICB0aGlzLnNhdmVJbWFnZVRvU2VydmVyID0gY29uZmlnLnNhdmVJbWFnZVRvU2VydmVyO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlcjtcbiAgICBcbiAgICAvLyBHZXQgY2FudmFzIG1hbmFnZXIgZnJvbSBnbG9iYWwgc2NvcGVcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNNYW5hZ2VyIDogbnVsbDtcbiAgfVxuXG4gIC8vIEdldCBvciBjcmVhdGUgY2FudmFzIHVzaW5nIHRoZSBuZXcgQ2FudmFzTWFuYWdlclxuICBnZXRDYW52YXMoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCB0aGlzLmNhbnZhc01hbmFnZXIuY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGNhbnZhc1JlZiBpZiBjYW52YXNNYW5hZ2VyIG5vdCBhdmFpbGFibGVcbiAgICByZXR1cm4gdGhpcy5jYW52YXNSZWY/LmN1cnJlbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICB9XG5cbiAgLy8gV2FpdCB1bnRpbCBjYW52YXMgaXMgZnVsbHkgcmVhZHlcbiAgYXN5bmMgd2FpdEZvckNhbnZhcyhtYXhUcmllcyA9IDIwLCBpbnRlcnZhbCA9IDEwMCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VHJpZXM7IGkrKykge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLndpZHRoID4gMCAmJiBjYW52YXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgcmVhZHkgYWZ0ZXIgbXVsdGlwbGUgYXR0ZW1wdHNcIik7XG4gIH1cblxuICAvLyBNYWluIGZ1bmN0aW9uIHRvIGhhbmRsZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZVxuICBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzdGFydGluZyBjYWxpYnJhdGlvblxuICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgcGFyZW50IGNvbXBvbmVudCBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5vblN0YXR1c1VwZGF0ZSkge1xuICAgICAgdGhpcy5vblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRpbWUgdG8gdXBkYXRlXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBhd2FpdCB0aGlzLndhaXRGb3JDYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBjYW52YXMgbWFuYWdlciB0byBlbnRlciBmdWxsc2NyZWVuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZW50ZXJGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgc3RhdHVzIGluZGljYXRvclxuICAgICAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgIGA7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbjogSW5pdGlhbGl6aW5nLi4uJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGRpc3BsYXlzXG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSAxNDsgLy8gU2xpZ2h0bHkgbGFyZ2VyIGZvciBiZXR0ZXIgdmlzaWJpbGl0eVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgIGNvbnN0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgICAgICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgY3VzdG9tIGNvdW50ZG93biBlbGVtZW50XG4gICAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgIGxlZnQ6ICR7cG9pbnQueH1weDtcbiAgICAgICAgICAgIHRvcDogJHtwb2ludC55IC0gNjB9cHg7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgICAgZm9udC1zaXplOiAzNnB4O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOCk7XG4gICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgICAgYDtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgUG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH06IENvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3IHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0XG4gICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtwb2ludC54fSwgJHtwb2ludC55fSlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICBjYXB0dXJlQ291bnQ6IHRoaXMuY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiB0aGlzLnNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgY291bnRkb3duIGlmIGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBFeGl0IGZ1bGxzY3JlZW4gYW5kIHJlc3RvcmUgY2FudmFzXG4gICAgICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhbGlicmF0ZUFjdGlvbjsiXSwibmFtZXMiOlsiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsImRyYXdSZWREb3QiLCJydW5Db3VudGRvd24iLCJzaG93Q2FwdHVyZVByZXZpZXciLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsIlNldENhbGlicmF0ZUFjdGlvbiIsImdldENhbnZhcyIsImNhbnZhc01hbmFnZXIiLCJjcmVhdGVDYW52YXMiLCJjYW52YXNSZWYiLCJjdXJyZW50IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwid2FpdEZvckNhbnZhcyIsIm1heFRyaWVzIiwiaW50ZXJ2YWwiLCJpIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwidG9nZ2xlVG9wQmFyIiwid2luZG93Iiwic2V0SXNDYXB0dXJpbmciLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJwcm9jZXNzU3RhdHVzIiwiaXNDYXB0dXJpbmciLCJlbnRlckZ1bGxzY3JlZW4iLCJwb2ludHMiLCJsZW5ndGgiLCJzdGF0dXNJbmRpY2F0b3IiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJjc3NUZXh0IiwidGV4dENvbnRlbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJzdWNjZXNzQ291bnQiLCJwb2ludCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInJhZGl1cyIsIngiLCJ5IiwicmVkcmF3SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImV4aXN0aW5nQ291bnRkb3ducyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjb3VudGRvd25FbGVtZW50IiwiY291bnQiLCJjb25zb2xlIiwibG9nIiwiY2FwdHVyZVJlc3VsdCIsImNhcHR1cmVDb3VudCIsImNhcHR1cmVDb3VudGVyIiwic2V0Q2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzY3JlZW5JbWFnZSIsInN1Y2Nlc3MiLCJlcnJvciIsImNsZWFySW50ZXJ2YWwiLCJtZXNzYWdlIiwiZXhpdEZ1bGxzY3JlZW4iLCJzZXRDdXJyZW50RG90IiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsInNhdmVJbWFnZVRvU2VydmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.js\n"));

/***/ })

});