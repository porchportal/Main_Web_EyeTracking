"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_SetCalibrateAction_jsx",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx":
/*!*******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.jsx ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.jsx\n// Handles the calibration sequence functionality\n\n\n\n\nclass SetCalibrateAction {\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        var _this_canvasRef;\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas() {\n        let maxTries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20, interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Starting calibration sequence...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Use canvas manager to enter fullscreen\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate calibration points based on canvas size\n                    const points = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_1__.generateCalibrationPoints)(canvas.width, canvas.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = \"\\n          position: fixed;\\n          top: 20px;\\n          right: 20px;\\n          background-color: rgba(0, 102, 204, 0.9);\\n          color: white;\\n          font-size: 16px;\\n          font-weight: bold;\\n          padding: 10px 15px;\\n          border-radius: 8px;\\n          z-index: 10000;\\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n        \";\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        // Update status displays\n                        statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                        this.setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                        // Clear canvas with white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        // Draw the calibration point with consistent size\n                        const radius = 24; // Larger size for better visibility\n                        (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element positioned at the same location as the dot\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = \"\\n            position: fixed;\\n            left: \".concat(point.x, \"px;\\n            top: \").concat(point.y, \"px;\\n            transform: translate(-50%, -50%);\\n            color: red;\\n            font-size: 24px;\\n            font-weight: bold;\\n            text-shadow: 0 0 10px white, 0 0 20px white;\\n            z-index: 10000;\\n            background-color: rgba(255, 255, 255, 0.9);\\n            border: 2px solid red;\\n            border-radius: 50%;\\n            width: 48px;\\n            height: 48px;\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);\\n          \");\n                        document.body.appendChild(countdownElement);\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                                // Force redraw to ensure dot stays visible\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"âœ“\";\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Remove countdown element immediately\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Make sure dot is still visible\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Capture images at this point\n                            console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_3__.captureImagesAtPoint)({\n                                point: point,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_2__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait a moment before clearing to ensure capture is complete\n                            await new Promise((resolve)=>setTimeout(resolve, 500));\n                            // Clear the dot after capture\n                            ctx.clearRect(0, 0, canvas.width, canvas.height);\n                            ctx.fillStyle = 'white';\n                            ctx.fillRect(0, 0, canvas.width, canvas.height);\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                    }\n                    this.setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(\"Calibration error: \".concat(error.message));\n                } finally{\n                    // Exit fullscreen and restore canvas\n                    if (this.canvasManager) {\n                        this.canvasManager.exitFullscreen();\n                    }\n                    this.setIsCapturing(false);\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(true);\n                        }\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  true ? window.canvasManager : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaURBQWlEO0FBRXZCO0FBQ29DO0FBQ2E7QUFDakI7QUFFMUQsTUFBTU07SUFrQkosbURBQW1EO0lBQ25EQyxZQUFZO1lBTUg7UUFMUCxJQUFJLElBQUksQ0FBQ0MsYUFBYSxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDQSxhQUFhLENBQUNELFNBQVMsTUFBTSxJQUFJLENBQUNDLGFBQWEsQ0FBQ0MsWUFBWTtRQUMxRTtRQUVBLHVEQUF1RDtRQUN2RCxPQUFPLHdCQUFJLENBQUNDLFNBQVMsY0FBZCxzREFBZ0JDLE9BQU8sS0FBSUMsU0FBU0MsYUFBYSxDQUFDO0lBQzNEO0lBRUEsbUNBQW1DO0lBQ25DLE1BQU1DLGdCQUE2QztZQUEvQkMsV0FBQUEsaUVBQVcsSUFBSUMsV0FBQUEsaUVBQVc7UUFDNUMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFVBQVVFLElBQUs7WUFDakMsTUFBTUMsU0FBUyxJQUFJLENBQUNYLFNBQVM7WUFDN0IsSUFBSVcsVUFBVUEsT0FBT0MsS0FBSyxHQUFHLEtBQUtELE9BQU9FLE1BQU0sR0FBRyxHQUFHO2dCQUNuRCxPQUFPRjtZQUNUO1lBQ0EsTUFBTSxJQUFJRyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTTjtRQUNuRDtRQUNBLE1BQU0sSUFBSVEsTUFBTTtJQUNsQjtJQXJDQUMsWUFBWUMsTUFBTSxDQUFFO1FBdUNwQiwrQ0FBK0M7YUFDL0NDLHFCQUFxQjtZQUNuQiw4Q0FBOEM7WUFDOUMsSUFBSSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLLFlBQVk7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxLQUE2QixJQUFJQyxPQUFPRCxZQUFZLEVBQUU7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QUFHTixPQUFPTSxjQUFjO1FBQzNDLElBQUksQ0FBQ2lELGlCQUFpQixHQUFHdkQsT0FBT3VELGlCQUFpQjtRQUNqRCxJQUFJLENBQUNULGlCQUFpQixHQUFHOUMsT0FBTzhDLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNGLGNBQWMsR0FBRzVDLE9BQU80QyxjQUFjO1FBRTNDLHVDQUF1QztRQUN2QyxJQUFJLENBQUM5RCxhQUFhLEdBQUcsS0FBNkIsR0FBR3FCLE9BQU9yQixhQUFhLEdBQUcsQ0FBSTtJQUNsRjtBQStPRjtBQUVBLGlFQUFlRixrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9TZXRDYWxpYnJhdGVBY3Rpb24uanN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNldENhbGlicmF0ZUFjdGlvbi5qc3hcbi8vIEhhbmRsZXMgdGhlIGNhbGlicmF0aW9uIHNlcXVlbmNlIGZ1bmN0aW9uYWxpdHlcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBkcmF3UmVkRG90LCBydW5Db3VudGRvd24sIHNob3dDYXB0dXJlUHJldmlldyB9IGZyb20gJy4vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vSGVscGVyL3NhdmVmaWxlJztcblxuY2xhc3MgU2V0Q2FsaWJyYXRlQWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLy8gUmVxdWlyZWQgcHJvcGVydGllc1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyA9IGNvbmZpZy5zZXRJc0NhcHR1cmluZztcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBjb25maWcuc2V0UHJvY2Vzc1N0YXR1cztcbiAgICB0aGlzLnNldEN1cnJlbnREb3QgPSBjb25maWcuc2V0Q3VycmVudERvdDtcbiAgICB0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MgPSBjb25maWcudHJpZ2dlckNhbWVyYUFjY2VzcztcbiAgICB0aGlzLm9uU3RhdHVzVXBkYXRlID0gY29uZmlnLm9uU3RhdHVzVXBkYXRlO1xuICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBjb25maWcuc2F2ZUltYWdlVG9TZXJ2ZXI7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBmcm9tIGdsb2JhbCBzY29wZVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIG5ldyBDYW52YXNNYW5hZ2VyXG4gIGdldENhbnZhcygpIHtcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBXYWl0IHVudGlsIGNhbnZhcyBpcyBmdWxseSByZWFkeVxuICBhc3luYyB3YWl0Rm9yQ2FudmFzKG1heFRyaWVzID0gMjAsIGludGVydmFsID0gMTAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmllczsgaSsrKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMud2lkdGggPiAwICYmIGNhbnZhcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCByZWFkeSBhZnRlciBtdWx0aXBsZSBhdHRlbXB0c1wiKTtcbiAgfVxuXG4gIC8vIE1haW4gZnVuY3Rpb24gdG8gaGFuZGxlIGNhbGlicmF0aW9uIHNlcXVlbmNlXG4gIGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHN0YXJ0aW5nIGNhbGlicmF0aW9uXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwYXJlbnQgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLm9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGltZSB0byB1cGRhdGVcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHRoaXMud2FpdEZvckNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGNhbnZhcyBtYW5hZ2VyIHRvIGVudGVyIGZ1bGxzY3JlZW5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cyBiYXNlZCBvbiBjYW52YXMgc2l6ZVxuICAgICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgcGFkZGluZzogMTBweCAxNXB4O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGlzcGxheXNcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgUHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludCB3aXRoIGNvbnNpc3RlbnQgc2l6ZVxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDI0OyAvLyBMYXJnZXIgc2l6ZSBmb3IgYmV0dGVyIHZpc2liaWxpdHlcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBpbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICBjb25zdCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBjdXN0b20gY291bnRkb3duIGVsZW1lbnQgcG9zaXRpb25lZCBhdCB0aGUgc2FtZSBsb2NhdGlvbiBhcyB0aGUgZG90XG4gICAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgIGxlZnQ6ICR7cG9pbnQueH1weDtcbiAgICAgICAgICAgIHRvcDogJHtwb2ludC55fXB4O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgICAgIGhlaWdodDogNDhweDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICAgICAgYDtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBNYW51YWwgY291bnRkb3duXG4gICAgICAgICAgICBmb3IgKGxldCBjb3VudCA9IDM7IGNvdW50ID4gMDsgY291bnQtLSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gY291bnQ7XG4gICAgICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgUG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH06IENvdW50ZG93biAke2NvdW50fWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gRm9yY2UgcmVkcmF3IHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0XG4gICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtwb2ludC54fSwgJHtwb2ludC55fSlgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZVJlc3VsdCA9IGF3YWl0IGNhcHR1cmVJbWFnZXNBdFBvaW50KHtcbiAgICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgICAgICBjYXB0dXJlQ291bnQ6IHRoaXMuY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50OiB0aGlzLnNldENhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3NDb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXYWl0IGEgbW9tZW50IGJlZm9yZSBjbGVhcmluZyB0byBlbnN1cmUgY2FwdHVyZSBpcyBjb21wbGV0ZVxuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZG90IGFmdGVyIGNhcHR1cmVcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYXIgcmVkcmF3IGludGVydmFsXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbGlicmF0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEV4aXQgZnVsbHNjcmVlbiBhbmQgcmVzdG9yZSBjYW52YXNcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FsaWJyYXRlQWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZHJhd1JlZERvdCIsInJ1bkNvdW50ZG93biIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiU2V0Q2FsaWJyYXRlQWN0aW9uIiwiZ2V0Q2FudmFzIiwiY2FudmFzTWFuYWdlciIsImNyZWF0ZUNhbnZhcyIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJ3YWl0Rm9yQ2FudmFzIiwibWF4VHJpZXMiLCJpbnRlcnZhbCIsImkiLCJjYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJoYW5kbGVTZXRDYWxpYnJhdGUiLCJ0b2dnbGVUb3BCYXIiLCJ3aW5kb3ciLCJzZXRJc0NhcHR1cmluZyIsInNldFByb2Nlc3NTdGF0dXMiLCJvblN0YXR1c1VwZGF0ZSIsInByb2Nlc3NTdGF0dXMiLCJpc0NhcHR1cmluZyIsImVudGVyRnVsbHNjcmVlbiIsInBvaW50cyIsImxlbmd0aCIsInN0YXR1c0luZGljYXRvciIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN1Y2Nlc3NDb3VudCIsInBvaW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicmFkaXVzIiwieCIsInkiLCJyZWRyYXdJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvdW50ZG93bkVsZW1lbnQiLCJjb3VudCIsImNvbnNvbGUiLCJsb2ciLCJjYXB0dXJlUmVzdWx0IiwiY2FwdHVyZUNvdW50IiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnRlciIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsImVycm9yIiwiY2xlYXJJbnRlcnZhbCIsIm1lc3NhZ2UiLCJleGl0RnVsbHNjcmVlbiIsInNldEN1cnJlbnREb3QiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwic2F2ZUltYWdlVG9TZXJ2ZXIiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\n"));

/***/ })

});