"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_CalibrateHandler_js",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/CalibrateHandler.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints_jsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints.jsx */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.jsx\");\n/* harmony import */ var _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CaptureHandler */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CaptureHandler.js\");\n/* harmony import */ var _DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DotCaptureUtil */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/DotCaptureUtil.js\");\n// CalibrateHandler.js - Using the existing CaptureHandler class\n\n\n\nclass CalibrateHandler {\n    createStatusIndicator() {\n        const existingIndicators = document.querySelectorAll('.calibrate-status-indicator');\n        existingIndicators.forEach((indicator)=>indicator.remove());\n        const indicator = document.createElement('div');\n        indicator.className = 'calibrate-status-indicator';\n        indicator.style.cssText = \"\\n      position: fixed;\\n      top: 10px;\\n      right: 10px;\\n      background-color: rgba(0, 102, 204, 0.9);\\n      color: white;\\n      font-size: 14px;\\n      font-weight: bold;\\n      padding: 8px 12px;\\n      border-radius: 6px;\\n      z-index: 9999;\\n      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);\\n    \";\n        document.body.appendChild(indicator);\n        this.statusIndicator = indicator;\n        return indicator;\n    }\n    async processCalibrationPoint(point, index, total) {\n        try {\n            var _this_setOutputText, _this;\n            if (!point || typeof point.x !== 'number' || typeof point.y !== 'number') {\n                throw new Error(\"Invalid calibration point\");\n            }\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Processing point \".concat(index + 1, \"/\").concat(total);\n            }\n            // Draw the dot\n            const canvas = this.canvasRef.current;\n            if (!canvas) {\n                throw new Error(\"Canvas not available\");\n            }\n            const ctx = canvas.getContext('2d');\n            (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n            // Create countdown element\n            const canvasRect = canvas.getBoundingClientRect();\n            const countdownElement = document.createElement('div');\n            countdownElement.className = 'calibrate-countdown';\n            countdownElement.style.cssText = \"\\n        position: fixed;\\n        left: \".concat(canvasRect.left + point.x, \"px;\\n        top: \").concat(canvasRect.top + point.y - 60, \"px;\\n        transform: translateX(-50%);\\n        color: red;\\n        font-size: 36px;\\n        font-weight: bold;\\n        text-shadow: 0 0 10px white, 0 0 20px white;\\n        z-index: 9999;\\n        background-color: rgba(255, 255, 255, 0.8);\\n        border: 2px solid red;\\n        border-radius: 50%;\\n        width: 50px;\\n        height: 50px;\\n        display: flex;\\n        justify-content: center;\\n        align-items: center;\\n        box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\\n      \");\n            document.body.appendChild(countdownElement);\n            // Run countdown\n            for(let count = 3; count > 0; count--){\n                var _this_setOutputText1, _this1;\n                countdownElement.textContent = count;\n                (_this_setOutputText1 = (_this1 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this1, \"Point \".concat(index + 1, \"/\").concat(total, \" - countdown \").concat(count));\n                // Make sure dot remains visible during countdown\n                (0,_DotCaptureUtil__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y);\n                // Wait for next countdown step\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            // Show capturing indicator\n            countdownElement.textContent = \"âœ“\";\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Capturing point \".concat(index + 1, \"/\").concat(total));\n            // Remove countdown element\n            setTimeout(()=>{\n                if (countdownElement.parentNode) {\n                    countdownElement.parentNode.removeChild(countdownElement);\n                }\n            }, 300);\n            // Use CaptureHandler to handle the capture process\n            const captureResult = await this.captureHandler.captureAndShowPreview(this.captureCounter, this.canvasRef, point);\n            // Add null check before using the result\n            if (!captureResult) {\n                console.warn(\"No capture result for point \".concat(index + 1));\n            // You might want to set a default or retry logic here\n            }\n            // Wait for the preview to complete\n            await new Promise((resolve)=>setTimeout(resolve, 2500));\n            return true;\n        } catch (err) {\n            var _this_setOutputText2, _this2;\n            console.error(\"Error processing point \".concat(index + 1, \":\"), err);\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Error: \".concat(err.message);\n            }\n            (_this_setOutputText2 = (_this2 = this).setOutputText) === null || _this_setOutputText2 === void 0 ? void 0 : _this_setOutputText2.call(_this2, \"Error: \".concat(err.message));\n            return false;\n        }\n    }\n    async startCalibration() {\n        if (this.isProcessing) return false;\n        this.isProcessing = true;\n        if (this.toggleTopBar) {\n            this.toggleTopBar(false);\n        }\n        const indicator = this.createStatusIndicator();\n        indicator.textContent = 'Initializing calibration...';\n        try {\n            var _this_setOutputText, _this, _this_setOutputText1, _this1;\n            const canvas = this.canvasRef.current;\n            if (!canvas || canvas.width === 0 || canvas.height === 0) {\n                throw new Error('Canvas is not ready');\n            }\n            // Only generate if none were passed in\n            if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                this.calibrationPoints = (0,_CalibratePoints_jsx__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                if (!this.calibrationPoints || this.calibrationPoints.length === 0) {\n                    throw new Error('Failed to generate calibration points');\n                }\n            }\n            (_this_setOutputText = (_this = this).setOutputText) === null || _this_setOutputText === void 0 ? void 0 : _this_setOutputText.call(_this, \"Starting calibration with \".concat(this.calibrationPoints.length, \" points\"));\n            let successCount = 0;\n            for(let i = 0; i < this.calibrationPoints.length; i++){\n                const success = await this.processCalibrationPoint(this.calibrationPoints[i], i, this.calibrationPoints.length);\n                if (success) {\n                    successCount++;\n                }\n                // Small delay between points\n                await new Promise((resolve)=>setTimeout(resolve, 800));\n            }\n            (_this_setOutputText1 = (_this1 = this).setOutputText) === null || _this_setOutputText1 === void 0 ? void 0 : _this_setOutputText1.call(_this1, \"Calibration completed: \".concat(successCount, \"/\").concat(this.calibrationPoints.length, \" points captured\"));\n            if (this.statusIndicator) {\n                this.statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(this.calibrationPoints.length, \" points\");\n            }\n            // Turn TopBar back on\n            if (this.toggleTopBar) {\n                this.toggleTopBar(true);\n            }\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        } catch (error) {\n            // console.error('Calibration error:', error);\n            // this.setOutputText?.(`Calibration error: ${error.message}`);\n            // if (this.statusIndicator) {\n            //   this.statusIndicator.textContent = `Error: ${error.message}`;\n            // }\n            // // Make sure we turn TopBar back on even on error\n            // if (this.toggleTopBar) {\n            //   this.toggleTopBar(true);\n            // }\n            console.error('Error during capture and preview:', error);\n            // Show error message\n            if (this.setProcessStatus) {\n                this.setProcessStatus('Error: ' + error.message);\n            }\n            // Show TopBar again even if there was an error\n            setTimeout(()=>{\n                if (typeof this.toggleTopBar === 'function') {\n                    this.toggleTopBar(true);\n                } else if ( true && window.toggleTopBar) {\n                    window.toggleTopBar(true);\n                }\n            }, 1500);\n            // Return a default object to prevent null reference errors\n            return {\n                screenImage: '',\n                webcamImage: '',\n                success: false\n            };\n        } finally{\n            this.isProcessing = false;\n            // Remove the status indicator after a delay\n            setTimeout(()=>{\n                if (this.statusIndicator && this.statusIndicator.parentNode) {\n                    this.statusIndicator.parentNode.removeChild(this.statusIndicator);\n                }\n            }, 3000);\n        }\n    }\n    constructor(config){\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setOutputText = config.setOutputText;\n        this.captureCounter = config.captureCounter || 1;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureFolder = config.captureFolder || 'eye_tracking_captures';\n        this.onComplete = config.onComplete;\n        // Accept passed-in calibration points (from SetCalibrateAction.js)\n        this.calibrationPoints = config.calibrationPoints || [];\n        // Create a CaptureHandler instance for handling the captures\n        this.captureHandler = new _CaptureHandler__WEBPACK_IMPORTED_MODULE_1__[\"default\"](// Pass saveImageToServer function\n        async (imageData, filename, type, folder)=>{\n            try {\n                const response = await fetch('/api/save-capture', {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        imageData,\n                        filename,\n                        type,\n                        folder: this.captureFolder\n                    })\n                });\n                if (!response.ok) {\n                    console.warn(\"Server responded with \".concat(response.status));\n                    return {};\n                }\n                return await response.json();\n            } catch (err) {\n                console.error(\"Error saving \".concat(type, \":\"), err);\n                return {};\n            }\n        }, // Pass setCaptureCounter function\n        (newCounter)=>{\n            if (typeof newCounter === 'function') {\n                this.captureCounter = newCounter(this.captureCounter);\n            } else {\n                this.captureCounter = newCounter;\n            }\n            if (this.setCaptureCounter) {\n                this.setCaptureCounter(this.captureCounter);\n            }\n        }, // Pass setProcessStatus function\n        (status)=>{\n            if (this.setOutputText) {\n                this.setOutputText(status);\n            }\n        }, // Pass toggleTopBar function\n        this.toggleTopBar);\n        // Internals\n        this.isProcessing = false;\n        this.currentPointIndex = 0;\n        this.statusIndicator = null;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CalibrateHandler);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vQ2FsaWJyYXRlSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsZ0VBQWdFO0FBQ0U7QUFDcEI7QUFDQTtBQUU5QyxNQUFNRztJQXNFSkMsd0JBQXdCO1FBQ3RCLE1BQU1DLHFCQUFxQkMsU0FBU0MsZ0JBQWdCLENBQUM7UUFDckRGLG1CQUFtQkcsT0FBTyxDQUFDQyxDQUFBQSxZQUFhQSxVQUFVQyxNQUFNO1FBRXhELE1BQU1ELFlBQVlILFNBQVNLLGFBQWEsQ0FBQztRQUN6Q0YsVUFBVUcsU0FBUyxHQUFHO1FBQ3RCSCxVQUFVSSxLQUFLLENBQUNDLE9BQU8sR0FBSTtRQWEzQlIsU0FBU1MsSUFBSSxDQUFDQyxXQUFXLENBQUNQO1FBQzFCLElBQUksQ0FBQ1EsZUFBZSxHQUFHUjtRQUN2QixPQUFPQTtJQUNUO0lBRUEsTUFBTVMsd0JBQXdCQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFO1FBQ2pELElBQUk7Z0JBMERGO1lBekRBLElBQUksQ0FBQ0YsU0FBUyxPQUFPQSxNQUFNRyxDQUFDLEtBQUssWUFBWSxPQUFPSCxNQUFNSSxDQUFDLEtBQUssVUFBVTtnQkFDeEUsTUFBTSxJQUFJQyxNQUFNO1lBQ2xCO1lBRUEsSUFBSSxJQUFJLENBQUNQLGVBQWUsRUFBRTtnQkFDeEIsSUFBSSxDQUFDQSxlQUFlLENBQUNRLFdBQVcsR0FBRyxvQkFBaUNKLE9BQWJELFFBQVEsR0FBRSxLQUFTLE9BQU5DO1lBQ3RFO1lBRUEsZUFBZTtZQUNmLE1BQU1LLFNBQVMsSUFBSSxDQUFDQyxTQUFTLENBQUNDLE9BQU87WUFDckMsSUFBSSxDQUFDRixRQUFRO2dCQUNYLE1BQU0sSUFBSUYsTUFBTTtZQUNsQjtZQUVBLE1BQU1LLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztZQUM5QjVCLDJEQUFVQSxDQUFDMkIsS0FBS1YsTUFBTUcsQ0FB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QVk7Z0JBQ3BDLElBQUksQ0FBQ3RDLGNBQWMsR0FBR3NDLFdBQVcsSUFBSSxDQUFDdEMsY0FBYztZQUN0RCxPQUFPO2dCQUNMLElBQUksQ0FBQ0EsY0FBYyxHQUFHc0M7WUFDeEI7WUFFQSxJQUFJLElBQUksQ0FBQ2YsaUJBQWlCLEVBQUU7Z0JBQzFCLElBQUksQ0FBQ0EsaUJBQWlCLENBQUMsSUFBSSxDQUFDdkIsY0FBYztZQUM1QztRQUNGLEdBQ0EsaUNBQWlDO1FBQ2pDLENBQUNvQztZQUNDLElBQUksSUFBSSxDQUFDN0MsYUFBYSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLGFBQWEsQ0FBQzZDO1lBQ3JCO1FBQ0YsR0FDQSw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDNUIsWUFBWTtRQUduQixZQUFZO1FBQ1osSUFBSSxDQUFDRCxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDZ0MsaUJBQWlCLEdBQUc7UUFDekIsSUFBSSxDQUFDcEUsZUFBZSxHQUFHO0lBQ3pCO0FBaU9GO0FBRUEsaUVBQWVkLGdCQUFnQkEsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL0NhbGlicmF0ZUhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ2FsaWJyYXRlSGFuZGxlci5qcyAtIFVzaW5nIHRoZSBleGlzdGluZyBDYXB0dXJlSGFuZGxlciBjbGFzc1xuaW1wb3J0IHsgZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyB9IGZyb20gJy4vQ2FsaWJyYXRlUG9pbnRzLmpzeCc7XG5pbXBvcnQgQ2FwdHVyZUhhbmRsZXIgZnJvbSAnLi9DYXB0dXJlSGFuZGxlcic7XG5pbXBvcnQgeyBkcmF3UmVkRG90IH0gZnJvbSAnLi9Eb3RDYXB0dXJlVXRpbCc7XG5cbmNsYXNzIENhbGlicmF0ZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0T3V0cHV0VGV4dCA9IGNvbmZpZy5zZXRPdXRwdXRUZXh0O1xuICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBjb25maWcuY2FwdHVyZUNvdW50ZXIgfHwgMTtcbiAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyID0gY29uZmlnLnNldENhcHR1cmVDb3VudGVyO1xuICAgIHRoaXMuY2FwdHVyZUZvbGRlciA9IGNvbmZpZy5jYXB0dXJlRm9sZGVyIHx8ICdleWVfdHJhY2tpbmdfY2FwdHVyZXMnO1xuICAgIHRoaXMub25Db21wbGV0ZSA9IGNvbmZpZy5vbkNvbXBsZXRlO1xuXG4gICAgLy8gQWNjZXB0IHBhc3NlZC1pbiBjYWxpYnJhdGlvbiBwb2ludHMgKGZyb20gU2V0Q2FsaWJyYXRlQWN0aW9uLmpzKVxuICAgIHRoaXMuY2FsaWJyYXRpb25Qb2ludHMgPSBjb25maWcuY2FsaWJyYXRpb25Qb2ludHMgfHwgW107XG5cbiAgICAvLyBDcmVhdGUgYSBDYXB0dXJlSGFuZGxlciBpbnN0YW5jZSBmb3IgaGFuZGxpbmcgdGhlIGNhcHR1cmVzXG4gICAgdGhpcy5jYXB0dXJlSGFuZGxlciA9IG5ldyBDYXB0dXJlSGFuZGxlcihcbiAgICAgIC8vIFBhc3Mgc2F2ZUltYWdlVG9TZXJ2ZXIgZnVuY3Rpb25cbiAgICAgIGFzeW5jIChpbWFnZURhdGEsIGZpbGVuYW1lLCB0eXBlLCBmb2xkZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKCcvYXBpL3NhdmUtY2FwdHVyZScsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgICAgICAgIGZpbGVuYW1lLFxuICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICBmb2xkZXI6IHRoaXMuY2FwdHVyZUZvbGRlclxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igc2F2aW5nICR7dHlwZX06YCwgZXJyKTtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBQYXNzIHNldENhcHR1cmVDb3VudGVyIGZ1bmN0aW9uXG4gICAgICAobmV3Q291bnRlcikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG5ld0NvdW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gbmV3Q291bnRlcih0aGlzLmNhcHR1cmVDb3VudGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gbmV3Q291bnRlcjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyKHRoaXMuY2FwdHVyZUNvdW50ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gUGFzcyBzZXRQcm9jZXNzU3RhdHVzIGZ1bmN0aW9uXG4gICAgICAoc3RhdHVzKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNldE91dHB1dFRleHQpIHtcbiAgICAgICAgICB0aGlzLnNldE91dHB1dFRleHQoc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFBhc3MgdG9nZ2xlVG9wQmFyIGZ1bmN0aW9uXG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhclxuICAgICk7XG5cbiAgICAvLyBJbnRlcm5hbHNcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudFBvaW50SW5kZXggPSAwO1xuICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yID0gbnVsbDtcbiAgfVxuXG4gIGNyZWF0ZVN0YXR1c0luZGljYXRvcigpIHtcbiAgICBjb25zdCBleGlzdGluZ0luZGljYXRvcnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InKTtcbiAgICBleGlzdGluZ0luZGljYXRvcnMuZm9yRWFjaChpbmRpY2F0b3IgPT4gaW5kaWNhdG9yLnJlbW92ZSgpKTtcblxuICAgIGNvbnN0IGluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGluZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgIGluZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgdG9wOiAxMHB4O1xuICAgICAgcmlnaHQ6IDEwcHg7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICBwYWRkaW5nOiA4cHggMTJweDtcbiAgICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbiAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICBib3gtc2hhZG93OiAwIDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgIGA7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbmRpY2F0b3IpO1xuICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yID0gaW5kaWNhdG9yO1xuICAgIHJldHVybiBpbmRpY2F0b3I7XG4gIH1cblxuICBhc3luYyBwcm9jZXNzQ2FsaWJyYXRpb25Qb2ludChwb2ludCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcG9pbnQgfHwgdHlwZW9mIHBvaW50LnggIT09ICdudW1iZXInIHx8IHR5cGVvZiBwb2ludC55ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbGlicmF0aW9uIHBvaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgUHJvY2Vzc2luZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gO1xuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1jb3VudGRvd24nO1xuICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGxlZnQ6ICR7Y2FudmFzUmVjdC5sZWZ0ICsgcG9pbnQueH1weDtcbiAgICAgICAgdG9wOiAke2NhbnZhc1JlY3QudG9wICsgcG9pbnQueSAtIDYwfXB4O1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVgoLTUwJSk7XG4gICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgIHotaW5kZXg6IDk5OTk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBib3gtc2hhZG93OiAwIDAgMTBweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgIFxuICAgICAgLy8gUnVuIGNvdW50ZG93blxuICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgUG9pbnQgJHtpbmRleCArIDF9LyR7dG90YWx9IC0gY291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgZG90IHJlbWFpbnMgdmlzaWJsZSBkdXJpbmcgY291bnRkb3duXG4gICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgZm9yIG5leHQgY291bnRkb3duIHN0ZXBcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaG93IGNhcHR1cmluZyBpbmRpY2F0b3JcbiAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhcHR1cmluZyBwb2ludCAke2luZGV4ICsgMX0vJHt0b3RhbH1gKTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICAgIFxuICAgICAgLy8gVXNlIENhcHR1cmVIYW5kbGVyIHRvIGhhbmRsZSB0aGUgY2FwdHVyZSBwcm9jZXNzXG4gICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgdGhpcy5jYXB0dXJlSGFuZGxlci5jYXB0dXJlQW5kU2hvd1ByZXZpZXcoXG4gICAgICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgIHRoaXMuY2FudmFzUmVmLFxuICAgICAgICBwb2ludFxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gQWRkIG51bGwgY2hlY2sgYmVmb3JlIHVzaW5nIHRoZSByZXN1bHRcbiAgICAgIGlmICghY2FwdHVyZVJlc3VsdCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYE5vIGNhcHR1cmUgcmVzdWx0IGZvciBwb2ludCAke2luZGV4ICsgMX1gKTtcbiAgICAgICAgLy8gWW91IG1pZ2h0IHdhbnQgdG8gc2V0IGEgZGVmYXVsdCBvciByZXRyeSBsb2dpYyBoZXJlXG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcmV2aWV3IHRvIGNvbXBsZXRlXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMjUwMCkpO1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgcG9pbnQgJHtpbmRleCArIDF9OmAsIGVycik7XG4gICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgRXJyb3I6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBFcnJvcjogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzdGFydENhbGlicmF0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzUHJvY2Vzc2luZykgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcblxuXG5cbiAgICBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRpY2F0b3IgPSB0aGlzLmNyZWF0ZVN0YXR1c0luZGljYXRvcigpO1xuICAgIGluZGljYXRvci50ZXh0Q29udGVudCA9ICdJbml0aWFsaXppbmcgY2FsaWJyYXRpb24uLi4nO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoIWNhbnZhcyB8fCBjYW52YXMud2lkdGggPT09IDAgfHwgY2FudmFzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBub3QgcmVhZHknKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBnZW5lcmF0ZSBpZiBub25lIHdlcmUgcGFzc2VkIGluXG4gICAgICBpZiAoIXRoaXMuY2FsaWJyYXRpb25Qb2ludHMgfHwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBpZiAoIXRoaXMuY2FsaWJyYXRpb25Qb2ludHMgfHwgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldE91dHB1dFRleHQ/LihgU3RhcnRpbmcgY2FsaWJyYXRpb24gd2l0aCAke3RoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RofSBwb2ludHNgKTtcbiAgICAgIFxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2FsaWJyYXRpb25Qb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGF3YWl0IHRoaXMucHJvY2Vzc0NhbGlicmF0aW9uUG9pbnQoXG4gICAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50c1tpXSwgXG4gICAgICAgICAgaSwgXG4gICAgICAgICAgdGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGhcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNtYWxsIGRlbGF5IGJldHdlZW4gcG9pbnRzXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRPdXRwdXRUZXh0Py4oYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7dGhpcy5jYWxpYnJhdGlvblBvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHt0aGlzLmNhbGlicmF0aW9uUG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHVybiBUb3BCYXIgYmFjayBvblxuICAgICAgaWYgKHRoaXMudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0NhbGlicmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIC8vIHRoaXMuc2V0T3V0cHV0VGV4dD8uKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgLy8gaWYgKHRoaXMuc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAvLyAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YDtcbiAgICAgIC8vIH1cbiAgICAgIFxuICAgICAgLy8gLy8gTWFrZSBzdXJlIHdlIHR1cm4gVG9wQmFyIGJhY2sgb24gZXZlbiBvbiBlcnJvclxuICAgICAgLy8gaWYgKHRoaXMudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAvLyAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgLy8gfVxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZHVyaW5nIGNhcHR1cmUgYW5kIHByZXZpZXc6JywgZXJyb3IpO1xuICBcbiAgICAgIC8vIFNob3cgZXJyb3IgbWVzc2FnZVxuICAgICAgaWYgKHRoaXMuc2V0UHJvY2Vzc1N0YXR1cykge1xuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0Vycm9yOiAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGV2ZW4gaWYgdGhlcmUgd2FzIGFuIGVycm9yXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxNTAwKTtcbiAgICAgIFxuICAgICAgLy8gUmV0dXJuIGEgZGVmYXVsdCBvYmplY3QgdG8gcHJldmVudCBudWxsIHJlZmVyZW5jZSBlcnJvcnNcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNjcmVlbkltYWdlOiAnJyxcbiAgICAgICAgd2ViY2FtSW1hZ2U6ICcnLFxuICAgICAgICBzdWNjZXNzOiBmYWxzZVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIHRoZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGEgZGVsYXlcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXNJbmRpY2F0b3IgJiYgdGhpcy5zdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRoaXMuc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICB9LCAzMDAwKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQ2FsaWJyYXRlSGFuZGxlcjsiXSwibmFtZXMiOlsiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsIkNhcHR1cmVIYW5kbGVyIiwiZHJhd1JlZERvdCIsIkNhbGlicmF0ZUhhbmRsZXIiLCJjcmVhdGVTdGF0dXNJbmRpY2F0b3IiLCJleGlzdGluZ0luZGljYXRvcnMiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaW5kaWNhdG9yIiwicmVtb3ZlIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN0YXR1c0luZGljYXRvciIsInByb2Nlc3NDYWxpYnJhdGlvblBvaW50IiwicG9pbnQiLCJpbmRleCIsInRvdGFsIiwieCIsInkiLCJFcnJvciIsInRleHRDb250ZW50IiwiY2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudCIsImN0eCIsImdldENvbnRleHQiLCJjYW52YXNSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY291bnRkb3duRWxlbWVudCIsImxlZnQiLCJ0b3AiLCJjb3VudCIsInNldE91dHB1dFRleHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjYXB0dXJlUmVzdWx0IiwiY2FwdHVyZUhhbmRsZXIiLCJjYXB0dXJlQW5kU2hvd1ByZXZpZXciLCJjYXB0dXJlQ291bnRlciIsImNvbnNvbGUiLCJ3YXJuIiwiZXJyIiwiZXJyb3IiLCJtZXNzYWdlIiwic3RhcnRDYWxpYnJhdGlvbiIsImlzUHJvY2Vzc2luZyIsInRvZ2dsZVRvcEJhciIsIndpZHRoIiwiaGVpZ2h0IiwiY2FsaWJyYXRpb25Qb2ludHMiLCJsZW5ndGgiLCJzdWNjZXNzQ291bnQiLCJpIiwic3VjY2VzcyIsIm9uQ29tcGxldGUiLCJzZXRQcm9jZXNzU3RhdHVzIiwid2luZG93Iiwic2NyZWVuSW1hZ2UiLCJ3ZWJjYW1JbWFnZSIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJjYXB0dXJlRm9sZGVyIiwiaW1hZ2VEYXRhIiwiZmlsZW5hbWUiLCJ0eXBlIiwiZm9sZGVyIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5Iiwib2siLCJzdGF0dXMiLCJqc29uIiwibmV3Q291bnRlciIsImN1cnJlbnRQb2ludEluZGV4Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibrateHandler.js\n"));

/***/ })

});