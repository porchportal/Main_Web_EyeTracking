"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_RandomDotAction_jsx",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/RandomDotAction.jsx ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n// RandomDotAction.jsx\n// Handles the random dot generation and countdown functionality\n\n\nclass RandomDotAction {\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        var _this_canvasRef;\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    constructor(config){\n        // Main function to handle random dot generation and capture\n        this.handleRandomDot = async ()=>{\n            // Hide the TopBar before showing dot\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Generating random dot...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Generating random dot...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                const canvas = this.getCanvas();\n                if (canvas) {\n                    // Use canvas manager to ensure proper initialization\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate random position\n                    const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.getRandomPosition)(canvas);\n                    // Draw the dot with consistent size\n                    const ctx = canvas.getContext('2d');\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y, 24, false);\n                    // Store current dot position\n                    this.setCurrentDot(position);\n                    try {\n                        // Use the shared capture and preview process\n                        await (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.captureAndPreviewProcess)({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            position,\n                            captureCounter: this.captureCounter,\n                            saveImageToServer: this.saveImageToServer,\n                            setCaptureCounter: this.setCaptureCounter,\n                            setProcessStatus: this.setProcessStatus,\n                            toggleTopBar: this.toggleTopBar,\n                            onStatusUpdate: this.onStatusUpdate,\n                            captureFolder: 'eye_tracking_captures'\n                        });\n                        // Clear the dot after capture\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        // Set capturing state to false after reasonable delay\n                        setTimeout(()=>{\n                            this.setIsCapturing(false);\n                        }, 2200); // Wait a bit longer than the preview duration\n                    } catch (error) {\n                        console.error(\"Error in capture and preview process:\", error);\n                        this.setProcessStatus('Error during capture process');\n                        this.setIsCapturing(false);\n                        // Clear error message after delay\n                        setTimeout(()=>{\n                            this.setProcessStatus('');\n                        }, 3000);\n                    }\n                } else {\n                    console.error(\"Canvas reference is null - cannot draw dot\");\n                    this.setProcessStatus('Error: Canvas not available');\n                    this.setIsCapturing(false);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  true ? window.canvasManager : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RandomDotAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsc0JBQXNCO0FBQ3RCLGdFQUFnRTtBQUV0QztBQUtMO0FBRXJCLE1BQU1JO0lBa0JKLG1EQUFtRDtJQUNuREMsWUFBWTtZQU1IO1FBTFAsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QixPQUFPLElBQUksQ0FBQ0EsYUFBYSxDQUFDRCxTQUFTLE1BQU0sSUFBSSxDQUFDQyxhQUFhLENBQUNDLFlBQVk7UUFDMUU7UUFFQSx1REFBdUQ7UUFDdkQsT0FBTyx3QkFBSSxDQUFDQyxTQUFTLGNBQWQsc0RBQWdCQyxPQUFPLEtBQUlDLFNBQVNDLGFBQWEsQ0FBQztJQUMzRDtJQXpCQUMsWUFBWUMsTUFBTSxDQUFFO1FBMkJwQiw0REFBNEQ7YUFDNURDLGtCQUFrQjtZQUNoQixxQ0FBcUM7WUFDckMsSUFBSSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLLFlBQVk7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxLQUE2QixJQUFJQyxPQUFPRCxZQUFZLEVBQUU7Z0JBQy9EQyxPQUFPRCxZQUFZLENBQUM7WUFDdEI7WUFFQSxJQUFJLENBQUNFLGNBQWMsQ0FBQztZQUNwQixJQUFJLENBQUNDLGdCQUFnQixDQUFDO1lBRXRCLHVDQUF1QztZQUN2QyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQztvQkFDbEJDLGVBQWU7b0JBQ2ZDLGFBQWE7Z0JBQ2Y7WUFDRjtZQUVBLG9DQUFvQztZQUNwQ0MsV0FBVztnQkFDVCxNQUFNQyxTQUFTLElBQUksQ0FBQ2xCLFNBQVM7Z0JBQzdCLElBQUlrQixRQUFRO29CQUNWLHFEQUFxRDtvQkFDckQsSUFBSSxJQUFJLENBQUNqQixhQUFhLEVBQUU7d0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDa0IsZUFBZTtvQkFDcEM7b0JBRUEsMkJBQTJCO29CQUMzQixNQUFNQyxXQUFXeEIsNkRBQWlCQSxDQUFDc0I7b0JBRW5DLG9DQUFvQztvQkFDcEMsTUFBTUcsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO29CQUNwQnpCLHNEQUFVQSxDQUFDd0IsS0FBS0QsU0FBU0csQ0FBQyxFQUFFSCxTQUFTSSxDQUFDLEVBQUUsSUFBSTtvQkFFdEQsNkJBQTZCO29CQUM3QixJQUFJLENBQUNDLGFBQWEsQ0FBQ0w7b0JBRW5CLElBQUk7d0JBQ0YsNkNBQTZDO3dCQUM3QyxNQUFNdEIsb0VBQXdCQSxDQUFDOzRCQUM3QkssV0FBVztnQ0FBRUMsU0FBU2M7NEJBQU87NEJBQzdCRTs0QkFDQU0sZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNDLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQjs0QkFDekNDLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQjs0QkFDekNmLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjs0QkFDdkNILGNBQWMsSUFBSSxDQUFDQSxZQUFZOzRCQUMvQkksZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNlLGVBQWU7d0JBQ2pCO3dCQUVBLDhCQUE4Qjt3QkFDOUIsTUFBTVIsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO3dCQUM5QkQsSUFBSVMsU0FBUyxDQUFDLEdBQUcsR0FBR1osT0FBT2EsS0FBSyxFQUFFYixPQUFPYyxNQUFNO3dCQUMvQ1gsSUFBSVksU0FBUyxHQUFHO3dCQUNoQlosSUFBSWEsUUFBUSxDQUFDLEdBQUcsR0FBR2hCLE9BQU9hLEtBQUssRUFBRWIsT0FBT2MsTUFBTTt3QkFFOUMsc0RBQXNEO3dCQUN0RGYsV0FBVzs0QkFDVCxJQUFJLENBQUNMLGNBQWMsQ0FBQzt3QkFDdEIsR0FBRyxPQUFPLDhDQUE4QztvQkFFMUQsRUFBRSxPQUFPdUIsT0FBTzt3QkFDZEMsUUFBUUQsS0FBSyxDQUFDLHlDQUF5Q0E7d0JBQ3ZELElBQUksQ0FBQ3RCLGdCQUFnQixDQUFDO3dCQUN0QixJQUFJLENBQUNELGNBQWMsQ0FBQzt3QkFFcEIsa0NBQWtDO3dCQUNsQ0ssV0FBVzs0QkFDVCxJQUFJLENBQUNKLGdCQUFnQixDQUFDO3dCQUN4QixHQUFHO29CQUNMO2dCQUNGLE9BQU87b0JBQ0x1QixRQUFRRCxLQUFLLENBQUM7b0JBQ2QsSUFBSSxDQUFDdEIsZ0JBQWdCLENBQUM7b0JBQ3RCLElBQUksQ0FBQ0QsY0FBYyxDQUFDO2dCQUN0QjtZQUNGLEdBQUc7UUFDTDtRQTFHRSxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDVCxTQUFTLEdBQUdLLE9BQU9MLFNBQVM7UUFDakMsSUFBSSxDQUFDTyxZQUFZLEdBQUdGLE9BQU9FLFlBQVk7UUFDdkMsSUFBSSxDQUFDRSxjQUFjLEdBQUdKLE9BQU9JLGNBQWM7UUFDM0MsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0wsT0FBT0ssZ0JBQWdCO1FBQy9DLElBQUksQ0FBQ1ksYUFBYSxHQUFHakIsT0FBT2lCLGFBQWE7UUFDekMsSUFBSSxDQUFDWSxtQkFBbUIsR0FBRzdCLE9BQU82QixtQkFBbUI7UUFDckQsSUFBSSxDQUFDdkIsY0FBYyxHQUFHTixPQUFPTSxjQUFjO1FBQzNDLElBQUksQ0FBQ2EsaUJBQWlCLEdBQUduQixPQUFPbUIsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0MsaUJBQWlCLEdBQUdwQixPQUFPb0IsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0YsY0FBYyxHQUFHbEIsT0FBT2tCLGNBQWM7UUFFM0MsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQ3pCLGFBQWEsR0FBRyxLQUE2QixHQUFHVSxPQUFPVixhQUFhLEdBQUcsQ0FBSTtJQUNsRjtBQTZGRjtBQUVBLGlFQUFlRixlQUFlQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBSYW5kb21Eb3RBY3Rpb24uanN4XG4vLyBIYW5kbGVzIHRoZSByYW5kb20gZG90IGdlbmVyYXRpb24gYW5kIGNvdW50ZG93biBmdW5jdGlvbmFsaXR5XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQge1xuICBnZXRSYW5kb21Qb3NpdGlvbixcbiAgZHJhd1JlZERvdCxcbiAgY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzXG59IGZyb20gJy4vY291bnRTYXZlJztcblxuY2xhc3MgUmFuZG9tRG90QWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLy8gUmVxdWlyZWQgcHJvcGVydGllc1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyA9IGNvbmZpZy5zZXRJc0NhcHR1cmluZztcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBjb25maWcuc2V0UHJvY2Vzc1N0YXR1cztcbiAgICB0aGlzLnNldEN1cnJlbnREb3QgPSBjb25maWcuc2V0Q3VycmVudERvdDtcbiAgICB0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MgPSBjb25maWcudHJpZ2dlckNhbWVyYUFjY2VzcztcbiAgICB0aGlzLm9uU3RhdHVzVXBkYXRlID0gY29uZmlnLm9uU3RhdHVzVXBkYXRlO1xuICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBjb25maWcuc2F2ZUltYWdlVG9TZXJ2ZXI7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBmcm9tIGdsb2JhbCBzY29wZVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIG5ldyBDYW52YXNNYW5hZ2VyXG4gIGdldENhbnZhcygpIHtcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBNYWluIGZ1bmN0aW9uIHRvIGhhbmRsZSByYW5kb20gZG90IGdlbmVyYXRpb24gYW5kIGNhcHR1cmVcbiAgaGFuZGxlUmFuZG9tRG90ID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIEhpZGUgdGhlIFRvcEJhciBiZWZvcmUgc2hvd2luZyBkb3RcbiAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwYXJlbnQgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLm9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ0dlbmVyYXRpbmcgcmFuZG9tIGRvdC4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRpbWUgdG8gdXBkYXRlXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAvLyBVc2UgY2FudmFzIG1hbmFnZXIgdG8gZW5zdXJlIHByb3BlciBpbml0aWFsaXphdGlvblxuICAgICAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gcG9zaXRpb25cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSYW5kb21Qb3NpdGlvbihjYW52YXMpO1xuICAgICAgICBcbiAgICAgICAgLy8gRHJhdyB0aGUgZG90IHdpdGggY29uc2lzdGVudCBzaXplXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDI0LCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBjdXJyZW50IGRvdCBwb3NpdGlvblxuICAgICAgICB0aGlzLnNldEN1cnJlbnREb3QocG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHNoYXJlZCBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAgICAgICAgICBhd2FpdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYXB0dXJlQ291bnRlcjogdGhpcy5jYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNhdmVJbWFnZVRvU2VydmVyOiB0aGlzLnNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzOiB0aGlzLnNldFByb2Nlc3NTdGF0dXMsXG4gICAgICAgICAgICB0b2dnbGVUb3BCYXI6IHRoaXMudG9nZ2xlVG9wQmFyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGU6IHRoaXMub25TdGF0dXNVcGRhdGUsXG4gICAgICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIHRoZSBkb3QgYWZ0ZXIgY2FwdHVyZVxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTZXQgY2FwdHVyaW5nIHN0YXRlIHRvIGZhbHNlIGFmdGVyIHJlYXNvbmFibGUgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIH0sIDIyMDApOyAvLyBXYWl0IGEgYml0IGxvbmdlciB0aGFuIHRoZSBwcmV2aWV3IGR1cmF0aW9uXG4gICAgICAgICAgXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIGNhcHR1cmUgYW5kIHByZXZpZXcgcHJvY2VzczpcIiwgZXJyb3IpO1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3IgZHVyaW5nIGNhcHR1cmUgcHJvY2VzcycpO1xuICAgICAgICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGVycm9yIG1lc3NhZ2UgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnJyk7XG4gICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYW52YXMgcmVmZXJlbmNlIGlzIG51bGwgLSBjYW5ub3QgZHJhdyBkb3RcIik7XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnRXJyb3I6IENhbnZhcyBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJhbmRvbURvdEFjdGlvbjsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiZ2V0UmFuZG9tUG9zaXRpb24iLCJkcmF3UmVkRG90IiwiY2FwdHVyZUFuZFByZXZpZXdQcm9jZXNzIiwiUmFuZG9tRG90QWN0aW9uIiwiZ2V0Q2FudmFzIiwiY2FudmFzTWFuYWdlciIsImNyZWF0ZUNhbnZhcyIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImhhbmRsZVJhbmRvbURvdCIsInRvZ2dsZVRvcEJhciIsIndpbmRvdyIsInNldElzQ2FwdHVyaW5nIiwic2V0UHJvY2Vzc1N0YXR1cyIsIm9uU3RhdHVzVXBkYXRlIiwicHJvY2Vzc1N0YXR1cyIsImlzQ2FwdHVyaW5nIiwic2V0VGltZW91dCIsImNhbnZhcyIsImVudGVyRnVsbHNjcmVlbiIsInBvc2l0aW9uIiwiY3R4IiwiZ2V0Q29udGV4dCIsIngiLCJ5Iiwic2V0Q3VycmVudERvdCIsImNhcHR1cmVDb3VudGVyIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJzZXRDYXB0dXJlQ291bnRlciIsImNhcHR1cmVGb2xkZXIiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZXJyb3IiLCJjb25zb2xlIiwidHJpZ2dlckNhbWVyYUFjY2VzcyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx\n"));

/***/ })

});