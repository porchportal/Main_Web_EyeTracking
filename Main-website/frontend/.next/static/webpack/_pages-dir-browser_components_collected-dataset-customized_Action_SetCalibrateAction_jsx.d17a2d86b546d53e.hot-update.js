"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_pages-dir-browser_components_collected-dataset-customized_Action_SetCalibrateAction_jsx",{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx":
/*!*******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.jsx ***!
  \*******************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-browser)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.jsx\n// Handles the calibration sequence functionality\n\n\n\n\nclass SetCalibrateAction {\n    // Get or create canvas using the canvas management system from actionButton.js\n    getCanvas() {\n        var _this_canvasRef;\n        // First try to use canvasUtils from actionButton.js\n        if (this.canvasUtils && typeof this.canvasUtils.getCanvas === 'function') {\n            return this.canvasUtils.getCanvas();\n        }\n        // Fallback to canvasManager\n        if (this.canvasManager && typeof this.canvasManager.getCanvas === 'function') {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    // Enter fullscreen using the canvas management system\n    enterFullscreen() {\n        if (this.canvasUtils && typeof this.canvasUtils.enterFullscreen === 'function') {\n            return this.canvasUtils.enterFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.enterFullscreen === 'function') {\n            this.canvasManager.enterFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually enter fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            document.body.appendChild(canvas);\n            canvas.style.cssText = \"\\n        position: fixed;\\n        top: 0;\\n        left: 0;\\n        width: 100vw;\\n        height: 100vh;\\n        z-index: 99999;\\n        background-color: white;\\n        border: none;\\n        display: block;\\n        opacity: 1;\\n        pointer-events: auto;\\n        margin: 0;\\n        padding: 0;\\n        box-sizing: border-box;\\n      \";\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            // Clear with white background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n        return canvas;\n    }\n    // Exit fullscreen using the canvas management system\n    exitFullscreen() {\n        if (this.canvasUtils && typeof this.canvasUtils.exitFullscreen === 'function') {\n            return this.canvasUtils.exitFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.exitFullscreen === 'function') {\n            this.canvasManager.exitFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually exit fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            container.appendChild(canvas);\n            canvas.style.position = 'relative';\n            canvas.style.top = '';\n            canvas.style.left = '';\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.zIndex = '';\n            canvas.style.backgroundColor = 'white';\n        }\n        return canvas;\n    }\n    // Clear canvas using the canvas management system\n    clearCanvas() {\n        if (this.canvasUtils && typeof this.canvasUtils.clear === 'function') {\n            this.canvasUtils.clear();\n            return;\n        }\n        if (this.canvasManager && typeof this.canvasManager.clear === 'function') {\n            this.canvasManager.clear();\n            return;\n        }\n        // Fallback: manually clear canvas\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    }\n    // Draw dot using the canvas management system\n    drawDot(x, y) {\n        let radius = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 24;\n        if (this.canvasUtils && typeof this.canvasUtils.drawDot === 'function') {\n            return this.canvasUtils.drawDot(x, y, radius);\n        }\n        // Fallback: manually draw dot\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, x, y, radius, false);\n            return true;\n        }\n        return false;\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas() {\n        let maxTries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 20, interval = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Starting calibration sequence...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Use canvas management system to enter fullscreen\n                    this.enterFullscreen();\n                    // Generate calibration points based on canvas size\n                    const points = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_1__.generateCalibrationPoints)(canvas.width, canvas.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = \"\\n          position: fixed;\\n          top: 20px;\\n          right: 20px;\\n          background-color: rgba(0, 102, 204, 0.9);\\n          color: white;\\n          font-size: 16px;\\n          font-weight: bold;\\n          padding: 10px 15px;\\n          border-radius: 8px;\\n          z-index: 10000;\\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\\n        \";\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        // Update status displays\n                        statusIndicator.textContent = \"Calibration: Point \".concat(i + 1, \"/\").concat(points.length);\n                        this.setProcessStatus(\"Processing calibration point \".concat(i + 1, \"/\").concat(points.length));\n                        // Clear canvas with white background using canvas management system\n                        this.clearCanvas();\n                        // Draw the calibration point using canvas management system\n                        const radius = 24; // Larger size for better visibility\n                        this.drawDot(point.x, point.y, radius);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            this.drawDot(point.x, point.y, radius);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element positioned at the same location as the dot\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = \"\\n            position: fixed;\\n            left: \".concat(point.x, \"px;\\n            top: \").concat(point.y, \"px;\\n            transform: translate(-50%, -50%);\\n            color: red;\\n            font-size: 24px;\\n            font-weight: bold;\\n            text-shadow: 0 0 10px white, 0 0 20px white;\\n            z-index: 10000;\\n            background-color: rgba(255, 255, 255, 0.9);\\n            border: 2px solid red;\\n            border-radius: 50%;\\n            width: 48px;\\n            height: 48px;\\n            display: flex;\\n            justify-content: center;\\n            align-items: center;\\n            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);\\n          \");\n                        document.body.appendChild(countdownElement);\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(\"Point \".concat(i + 1, \"/\").concat(points.length, \": Countdown \").concat(count));\n                                // Force redraw to ensure dot stays visible\n                                this.drawDot(point.x, point.y, radius);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                this.drawDot(point.x, point.y, radius);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"âœ“\";\n                            this.drawDot(point.x, point.y, radius);\n                            // Remove countdown element immediately\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Make sure dot is still visible\n                            this.drawDot(point.x, point.y, radius);\n                            // Capture images at this point\n                            console.log(\"Capturing calibration point \".concat(i + 1, \"/\").concat(points.length, \" at (\").concat(point.x, \", \").concat(point.y, \")\"));\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_3__.captureImagesAtPoint)({\n                                point: point,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_2__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait a moment before clearing to ensure capture is complete\n                            await new Promise((resolve)=>setTimeout(resolve, 500));\n                            // Clear the dot after capture using canvas management system\n                            this.clearCanvas();\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(\"Error processing calibration point \".concat(i + 1, \":\"), error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = \"Calibration complete: \".concat(successCount, \"/\").concat(points.length, \" points\");\n                    }\n                    this.setProcessStatus(\"Calibration completed: \".concat(successCount, \"/\").concat(points.length, \" points captured\"));\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(\"Calibration error: \".concat(error.message));\n                } finally{\n                    // Exit fullscreen and restore canvas using canvas management system\n                    this.exitFullscreen();\n                    this.setIsCapturing(false);\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if ( true && window.toggleTopBar) {\n                            window.toggleTopBar(true);\n                        }\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager and utilities from global scope (from actionButton.js)\n        this.canvasManager =  true ? window.canvasManager : 0;\n        this.canvasUtils =  true ? window.canvasUtils : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaURBQWlEO0FBRXZCO0FBQ29DO0FBQ2E7QUFDakI7QUFFMUQsTUFBTU07SUFtQkosK0VBQStFO0lBQy9FQyxZQUFZO1lBWUg7UUFYUCxvREFBb0Q7UUFDcEQsSUFBSSxJQUFJLENBQUNDLFdBQVcsSUFBSSxPQUFPLElBQUksQ0FBQ0EsV0FBVyxDQUFDRCxTQUFTLEtBQUssWUFBWTtZQUN4RSxPQUFPLElBQUksQ0FBQ0MsV0FBVyxDQUFDRCxTQUFTO1FBQ25DO1FBRUEsNEJBQTRCO1FBQzVCLElBQUksSUFBSSxDQUFDRSxhQUFhLElBQUksT0FBTyxJQUFJLENBQUNBLGFBQWEsQ0FBQ0YsU0FBUyxLQUFLLFlBQVk7WUFDNUUsT0FBTyxJQUFJLENBQUNFLGFBQWEsQ0FBQ0YsU0FBUyxNQUFNLElBQUksQ0FBQ0UsYUFBYSxDQUFDQyxZQUFZO1FBQzFFO1FBRUEsdURBQXVEO1FBQ3ZELE9BQU8sd0JBQUksQ0FBQ0MsU0FBUyxjQUFkLHNEQUFnQkMsT0FBTyxLQUFJQyxTQUFTQyxhQUFhLENBQUM7SUFDM0Q7SUFFQSxzREFBc0Q7SUFDdERDLGtCQUFrQjtRQUNoQixJQUFJLElBQUksQ0FBQ1AsV0FBVyxJQUFJLE9BQU8sSUFBSSxDQUFDQSxXQUFXLENBQUNPLGVBQWUsS0FBSyxZQUFZO1lBQzlFLE9BQU8sSUFBSSxDQUFDUCxXQUFXLENBQUNPLGVBQWU7UUFDekM7UUFFQSxJQUFJLElBQUksQ0FBQ04sYUFBYSxJQUFJLE9BQU8sSUFBSSxDQUFDQSxhQUFhLENBQUNNLGVBQWUsS0FBSyxZQUFZO1lBQ2xGLElBQUksQ0FBQ04sYUFBYSxDQUFDTSxlQUFlO1lBQ2xDLE9BQU8sSUFBSSxDQUFDTixhQUFhLENBQUNGLFNBQVM7UUFDckM7UUFF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SUFBSSxDQUFDNUMsU0FBUyxHQUFHMEMsT0FBTzFDLFNBQVM7UUFDakMsSUFBSSxDQUFDNEMsWUFBWSxHQUFHRixPQUFPRSxZQUFZO1FBQ3ZDLElBQUksQ0FBQ0MsY0FBYyxHQUFHSCxPQUFPRyxjQUFjO1FBQzNDLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdKLE9BQU9JLGdCQUFnQjtRQUMvQyxJQUFJLENBQUNrQyxhQUFhLEdBQUd0QyxPQUFPc0MsYUFBYTtRQUN6QyxJQUFJLENBQUNDLG1CQUFtQixHQUFHdkMsT0FBT3VDLG1CQUFtQjtRQUNyRCxJQUFJLENBQUNsQyxjQUFjLEdBQUdMLE9BQU9LLGNBQWM7UUFDM0MsSUFBSSxDQUFDbUMsaUJBQWlCLEdBQUd4QyxPQUFPd0MsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ1IsaUJBQWlCLEdBQUdoQyxPQUFPZ0MsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0YsY0FBYyxHQUFHOUIsT0FBTzhCLGNBQWM7UUFFM0MsNEVBQTRFO1FBQzVFLElBQUksQ0FBQzFFLGFBQWEsR0FBRyxLQUE2QixHQUFHYSxPQUFPYixhQUFhLEdBQUcsQ0FBSTtRQUNoRixJQUFJLENBQUNELFdBQVcsR0FBRyxLQUE2QixHQUFHYyxPQUFPZCxXQUFXLEdBQUcsQ0FBSTtJQUM5RTtBQXlWRjtBQUVBLGlFQUFlRixrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9TZXRDYWxpYnJhdGVBY3Rpb24uanN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNldENhbGlicmF0ZUFjdGlvbi5qc3hcbi8vIEhhbmRsZXMgdGhlIGNhbGlicmF0aW9uIHNlcXVlbmNlIGZ1bmN0aW9uYWxpdHlcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBkcmF3UmVkRG90LCBydW5Db3VudGRvd24sIHNob3dDYXB0dXJlUHJldmlldyB9IGZyb20gJy4vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vSGVscGVyL3NhdmVmaWxlJztcblxuY2xhc3MgU2V0Q2FsaWJyYXRlQWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLy8gUmVxdWlyZWQgcHJvcGVydGllc1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyA9IGNvbmZpZy5zZXRJc0NhcHR1cmluZztcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBjb25maWcuc2V0UHJvY2Vzc1N0YXR1cztcbiAgICB0aGlzLnNldEN1cnJlbnREb3QgPSBjb25maWcuc2V0Q3VycmVudERvdDtcbiAgICB0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MgPSBjb25maWcudHJpZ2dlckNhbWVyYUFjY2VzcztcbiAgICB0aGlzLm9uU3RhdHVzVXBkYXRlID0gY29uZmlnLm9uU3RhdHVzVXBkYXRlO1xuICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBjb25maWcuc2F2ZUltYWdlVG9TZXJ2ZXI7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBhbmQgdXRpbGl0aWVzIGZyb20gZ2xvYmFsIHNjb3BlIChmcm9tIGFjdGlvbkJ1dHRvbi5qcylcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNNYW5hZ2VyIDogbnVsbDtcbiAgICB0aGlzLmNhbnZhc1V0aWxzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuY2FudmFzVXRpbHMgOiBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICBnZXRDYW52YXMoKSB7XG4gICAgLy8gRmlyc3QgdHJ5IHRvIHVzZSBjYW52YXNVdGlscyBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmdldENhbnZhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVXRpbHMuZ2V0Q2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGNhbnZhc01hbmFnZXJcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBFbnRlciBmdWxsc2NyZWVuIHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgZW50ZXJGdWxsc2NyZWVuKCkge1xuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmVudGVyRnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVXRpbHMuZW50ZXJGdWxsc2NyZWVuKCk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIgJiYgdHlwZW9mIHRoaXMuY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBlbnRlciBmdWxsc2NyZWVuXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBjYW52YXMuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDB2dztcbiAgICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgICAgei1pbmRleDogOTk5OTk7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgYDtcbiAgICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gQ2xlYXIgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvLyBFeGl0IGZ1bGxzY3JlZW4gdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBleGl0RnVsbHNjcmVlbigpIHtcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5leGl0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVXRpbHMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgdGhpcy5jYW52YXNNYW5hZ2VyLmV4aXRGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBleGl0IGZ1bGxzY3JlZW5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJyc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnd2hpdGUnO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgLy8gQ2xlYXIgY2FudmFzIHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgY2xlYXJDYW52YXMoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzVXRpbHMgJiYgdHlwZW9mIHRoaXMuY2FudmFzVXRpbHMuY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2FudmFzVXRpbHMuY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgdGhpcy5jYW52YXNNYW5hZ2VyLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNhbnZhc01hbmFnZXIuY2xlYXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGNsZWFyIGNhbnZhc1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERyYXcgZG90IHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgZHJhd0RvdCh4LCB5LCByYWRpdXMgPSAyNCkge1xuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmRyYXdEb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc1V0aWxzLmRyYXdEb3QoeCwgeSwgcmFkaXVzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGRyYXcgZG90XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCB4LCB5LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXYWl0IHVudGlsIGNhbnZhcyBpcyBmdWxseSByZWFkeVxuICBhc3luYyB3YWl0Rm9yQ2FudmFzKG1heFRyaWVzID0gMjAsIGludGVydmFsID0gMTAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmllczsgaSsrKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMud2lkdGggPiAwICYmIGNhbnZhcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCByZWFkeSBhZnRlciBtdWx0aXBsZSBhdHRlbXB0c1wiKTtcbiAgfVxuXG4gIC8vIE1haW4gZnVuY3Rpb24gdG8gaGFuZGxlIGNhbGlicmF0aW9uIHNlcXVlbmNlXG4gIGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHN0YXJ0aW5nIGNhbGlicmF0aW9uXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwYXJlbnQgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLm9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGltZSB0byB1cGRhdGVcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHRoaXMud2FpdEZvckNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSB0byBlbnRlciBmdWxsc2NyZWVuXG4gICAgICAgIHRoaXMuZW50ZXJGdWxsc2NyZWVuKCk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIGNhbnZhcyBzaXplXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb246IEluaXRpYWxpemluZy4uLic7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBkaXNwbGF5c1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbjogUG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICAgIHRoaXMuY2xlYXJDYW52YXMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludCB1c2luZyBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgICAgICAgICBjb25zdCByYWRpdXMgPSAyNDsgLy8gTGFyZ2VyIHNpemUgZm9yIGJldHRlciB2aXNpYmlsaXR5XG4gICAgICAgICAgdGhpcy5kcmF3RG90KHBvaW50LngsIHBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBpbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICBjb25zdCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0RvdChwb2ludC54LCBwb2ludC55LCByYWRpdXMpO1xuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudCBwb3NpdGlvbmVkIGF0IHRoZSBzYW1lIGxvY2F0aW9uIGFzIHRoZSBkb3RcbiAgICAgICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgbGVmdDogJHtwb2ludC54fXB4O1xuICAgICAgICAgICAgdG9wOiAke3BvaW50Lnl9cHg7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcbiAgICAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxNXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgICAgICBgO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBQb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofTogQ291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBGb3JjZSByZWRyYXcgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgICAgICAgIHRoaXMuZHJhd0RvdChwb2ludC54LCBwb2ludC55LCByYWRpdXMpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVkcmF3IGFnYWluIGhhbGZ3YXkgdGhyb3VnaCB0aGUgd2FpdFxuICAgICAgICAgICAgICB0aGlzLmRyYXdEb3QocG9pbnQueCwgcG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgICAgdGhpcy5kcmF3RG90KHBvaW50LngsIHBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgICAgICAgdGhpcy5kcmF3RG90KHBvaW50LngsIHBvaW50LnksIHJhZGl1cyk7XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogdGhpcy5zZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhcHR1cmVSZXN1bHQgJiYgKGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgY2FwdHVyZVJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2FpdCBhIG1vbWVudCBiZWZvcmUgY2xlYXJpbmcgdG8gZW5zdXJlIGNhcHR1cmUgaXMgY29tcGxldGVcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGRvdCBhZnRlciBjYXB0dXJlIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICAgICAgdGhpcy5jbGVhckNhbnZhcygpO1xuXG4gICAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgY291bnRkb3duIGlmIGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBFeGl0IGZ1bGxzY3JlZW4gYW5kIHJlc3RvcmUgY2FudmFzIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FsaWJyYXRlQWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZHJhd1JlZERvdCIsInJ1bkNvdW50ZG93biIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiU2V0Q2FsaWJyYXRlQWN0aW9uIiwiZ2V0Q2FudmFzIiwiY2FudmFzVXRpbHMiLCJjYW52YXNNYW5hZ2VyIiwiY3JlYXRlQ2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImVudGVyRnVsbHNjcmVlbiIsImNhbnZhcyIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN0eWxlIiwiY3NzVGV4dCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImhlaWdodCIsImlubmVySGVpZ2h0IiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwiZXhpdEZ1bGxzY3JlZW4iLCJjb250YWluZXIiLCJwb3NpdGlvbiIsInRvcCIsImxlZnQiLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJjbGVhckNhbnZhcyIsImNsZWFyIiwiY2xlYXJSZWN0IiwiZHJhd0RvdCIsIngiLCJ5IiwicmFkaXVzIiwid2FpdEZvckNhbnZhcyIsIm1heFRyaWVzIiwiaW50ZXJ2YWwiLCJpIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImhhbmRsZVNldENhbGlicmF0ZSIsInRvZ2dsZVRvcEJhciIsInNldElzQ2FwdHVyaW5nIiwic2V0UHJvY2Vzc1N0YXR1cyIsIm9uU3RhdHVzVXBkYXRlIiwicHJvY2Vzc1N0YXR1cyIsImlzQ2FwdHVyaW5nIiwicG9pbnRzIiwibGVuZ3RoIiwic3RhdHVzSW5kaWNhdG9yIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInRleHRDb250ZW50Iiwic3VjY2Vzc0NvdW50IiwicG9pbnQiLCJyZWRyYXdJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvdW50ZG93bkVsZW1lbnQiLCJjb3VudCIsImNvbnNvbGUiLCJsb2ciLCJjYXB0dXJlUmVzdWx0IiwiY2FwdHVyZUNvdW50IiwiY2FwdHVyZUNvdW50ZXIiLCJzZXRDYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnRlciIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsImVycm9yIiwiY2xlYXJJbnRlcnZhbCIsIm1lc3NhZ2UiLCJzZXRDdXJyZW50RG90IiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsInNhdmVJbWFnZVRvU2VydmVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\n"));

/***/ })

});