"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_components_collected-dataset-customized_Action_RandomDotAction_jsx"],{

/***/ "(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/RandomDotAction.jsx ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(pages-dir-browser)/./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-browser)/./components/collected-dataset-customized/Action/countSave.js\");\n// RandomDotAction.jsx\n// Handles the random dot generation and countdown functionality\n\n\nclass RandomDotAction {\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        var _this_canvasRef;\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return ((_this_canvasRef = this.canvasRef) === null || _this_canvasRef === void 0 ? void 0 : _this_canvasRef.current) || document.querySelector('#tracking-canvas');\n    }\n    constructor(config){\n        // Main function to handle random dot generation and capture\n        this.handleRandomDot = async ()=>{\n            // Hide the TopBar before showing dot\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if ( true && window.toggleTopBar) {\n                window.toggleTopBar(false);\n            }\n            this.setIsCapturing(true);\n            this.setProcessStatus('Generating random dot...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Generating random dot...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                const canvas = this.getCanvas();\n                if (canvas) {\n                    // Use canvas manager to ensure proper initialization\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate random position\n                    const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.getRandomPosition)(canvas);\n                    // Draw the dot with consistent size\n                    const ctx = canvas.getContext('2d');\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y, 12, false);\n                    // Store current dot position\n                    this.setCurrentDot(position);\n                    try {\n                        // Use the shared capture and preview process\n                        await (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.captureAndPreviewProcess)({\n                            canvasRef: {\n                                current: canvas\n                            },\n                            position,\n                            captureCounter: this.captureCounter,\n                            saveImageToServer: this.saveImageToServer,\n                            setCaptureCounter: this.setCaptureCounter,\n                            setProcessStatus: this.setProcessStatus,\n                            toggleTopBar: this.toggleTopBar,\n                            onStatusUpdate: this.onStatusUpdate,\n                            captureFolder: 'eye_tracking_captures'\n                        });\n                        // Set capturing state to false after reasonable delay\n                        setTimeout(()=>{\n                            this.setIsCapturing(false);\n                        }, 2200); // Wait a bit longer than the preview duration\n                    } catch (error) {\n                        console.error(\"Error in capture and preview process:\", error);\n                        this.setProcessStatus('Error during capture process');\n                        this.setIsCapturing(false);\n                        // Clear error message after delay\n                        setTimeout(()=>{\n                            this.setProcessStatus('');\n                        }, 3000);\n                    }\n                } else {\n                    console.error(\"Canvas reference is null - cannot draw dot\");\n                    this.setProcessStatus('Error: Canvas not available');\n                    this.setIsCapturing(false);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  true ? window.canvasManager : 0;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RandomDotAction);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vUmFuZG9tRG90QWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsc0JBQXNCO0FBQ3RCLGdFQUFnRTtBQUV0QztBQUtMO0FBRXJCLE1BQU1JO0lBa0JKLG1EQUFtRDtJQUNuREMsWUFBWTtZQU1IO1FBTFAsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QixPQUFPLElBQUksQ0FBQ0EsYUFBYSxDQUFDRCxTQUFTLE1BQU0sSUFBSSxDQUFDQyxhQUFhLENBQUNDLFlBQVk7UUFDMUU7UUFFQSx1REFBdUQ7UUFDdkQsT0FBTyx3QkFBSSxDQUFDQyxTQUFTLGNBQWQsc0RBQWdCQyxPQUFPLEtBQUlDLFNBQVNDLGFBQWEsQ0FBQztJQUMzRDtJQXpCQUMsWUFBWUMsTUFBTSxDQUFFO1FBMkJwQiw0REFBNEQ7YUFDNURDLGtCQUFrQjtZQUNoQixxQ0FBcUM7WUFDckMsSUFBSSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLLFlBQVk7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxLQUE2QixJQUFJQyxPQUFPRCxZQUFZLEVBQUU7Z0JBQy9EQyxPQUFPRCxZQUFZLENBQUM7WUFDdEI7WUFFQSxJQUFJLENBQUNFLGNBQWMsQ0FBQztZQUNwQixJQUFJLENBQUNDLGdCQUFnQixDQUFDO1lBRXRCLHVDQUF1QztZQUN2QyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQztvQkFDbEJDLGVBQWU7b0JBQ2ZDLGFBQWE7Z0JBQ2Y7WUFDRjtZQUVBLG9DQUFvQztZQUNwQ0MsV0FBVztnQkFDVCxNQUFNQyxTQUFTLElBQUksQ0FBQ2xCLFNBQVM7Z0JBQzdCLElBQUlrQixRQUFRO29CQUNWLHFEQUFxRDtvQkFDckQsSUFBSSxJQUFJLENBQUNqQixhQUFhLEVBQUU7d0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDa0IsZUFBZTtvQkFDcEM7b0JBRUEsMkJBQTJCO29CQUMzQixNQUFNQyxXQUFXeEIsNkRBQWlCQSxDQUFDc0I7b0JBRW5DLG9DQUFvQztvQkFDcEMsTUFBTUcsTUFBTUgsT0FBT0ksVUFBVSxDQUFDO29CQUM5QnpCLHNEQUFVQSxDQUFDd0IsS0FBS0QsU0FBU0csQ0FBQyxFQUFFSCxTQUFTSSxDQUFDLEVBQUUsSUFBSTtvQkFFNUMsNkJBQTZCO29CQUM3QixJQUFJLENBQUNDLGFBQWEsQ0FBQ0w7b0JBRW5CLElBQUk7d0JBQ0YsNkNBQTZDO3dCQUM3QyxNQUFNdEIsb0VBQXdCQSxDQUFDOzRCQUM3QkssV0FBVztnQ0FBRUMsU0FBU2M7NEJBQU87NEJBQzdCRTs0QkFDQU0sZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNDLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQjs0QkFDekNDLG1CQUFtQixJQUFJLENBQUNBLGlCQUFpQjs0QkFDekNmLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjs0QkFDdkNILGNBQWMsSUFBSSxDQUFDQSxZQUFZOzRCQUMvQkksZ0JBQWdCLElBQUksQ0FBQ0EsY0FBYzs0QkFDbkNlLGVBQWU7d0JBQ2pCO3dCQUVBLHNEQUFzRDt3QkFDdERaLFdBQVc7NEJBQ1QsSUFBSSxDQUFDTCxjQUFjLENBQUM7d0JBQ3RCLEdBQUcsT0FBTyw4Q0FBOEM7b0JBRTFELEVBQUUsT0FBT2tCLE9BQU87d0JBQ2RDLFFBQVFELEtBQUssQ0FBQyx5Q0FBeUNBO3dCQUN2RCxJQUFJLENBQUNqQixnQkFBZ0IsQ0FBQzt3QkFDdEIsSUFBSSxDQUFDRCxjQUFjLENBQUM7d0JBRXBCLGtDQUFrQzt3QkFDbENLLFdBQVc7NEJBQ1QsSUFBSSxDQUFDSixnQkFBZ0IsQ0FBQzt3QkFDeEIsR0FBRztvQkFDTDtnQkFDRixPQUFPO29CQUNMa0IsUUFBUUQsS0FBSyxDQUFDO29CQUNkLElBQUksQ0FBQ2pCLGdCQUFnQixDQUFDO29CQUN0QixJQUFJLENBQUNELGNBQWMsQ0FBQztnQkFDdEI7WUFDRixHQUFHO1FBQ0w7UUFwR0Usc0JBQXNCO1FBQ3RCLElBQUksQ0FBQ1QsU0FBUyxHQUFHSyxPQUFPTCxTQUFTO1FBQ2pDLElBQUksQ0FBQ08sWUFBWSxHQUFHRixPQUFPRSxZQUFZO1FBQ3ZDLElBQUksQ0FBQ0UsY0FBYyxHQUFHSixPQUFPSSxjQUFjO1FBQzNDLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdMLE9BQU9LLGdCQUFnQjtRQUMvQyxJQUFJLENBQUNZLGFBQWEsR0FBR2pCLE9BQU9pQixhQUFhO1FBQ3pDLElBQUksQ0FBQ08sbUJBQW1CLEdBQUd4QixPQUFPd0IsbUJBQW1CO1FBQ3JELElBQUksQ0FBQ2xCLGNBQWMsR0FBR04sT0FBT00sY0FBYztRQUMzQyxJQUFJLENBQUNhLGlCQUFpQixHQUFHbkIsT0FBT21CLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHcEIsT0FBT29CLGlCQUFpQjtRQUNqRCxJQUFJLENBQUNGLGNBQWMsR0FBR2xCLE9BQU9rQixjQUFjO1FBRTNDLHVDQUF1QztRQUN2QyxJQUFJLENBQUN6QixhQUFhLEdBQUcsS0FBNkIsR0FBR1UsT0FBT1YsYUFBYSxHQUFHLENBQUk7SUFDbEY7QUF1RkY7QUFFQSxpRUFBZUYsZUFBZUEsRUFBQyIsInNvdXJjZXMiOlsiL2FwcC9jb21wb25lbnRzL2NvbGxlY3RlZC1kYXRhc2V0LWN1c3RvbWl6ZWQvQWN0aW9uL1JhbmRvbURvdEFjdGlvbi5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUmFuZG9tRG90QWN0aW9uLmpzeFxuLy8gSGFuZGxlcyB0aGUgcmFuZG9tIGRvdCBnZW5lcmF0aW9uIGFuZCBjb3VudGRvd24gZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgZ2V0UmFuZG9tUG9zaXRpb24sXG4gIGRyYXdSZWREb3QsXG4gIGNhcHR1cmVBbmRQcmV2aWV3UHJvY2Vzc1xufSBmcm9tICcuL2NvdW50U2F2ZSc7XG5cbmNsYXNzIFJhbmRvbURvdEFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8vIFJlcXVpcmVkIHByb3BlcnRpZXNcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcgPSBjb25maWcuc2V0SXNDYXB0dXJpbmc7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzID0gY29uZmlnLnNldFByb2Nlc3NTdGF0dXM7XG4gICAgdGhpcy5zZXRDdXJyZW50RG90ID0gY29uZmlnLnNldEN1cnJlbnREb3Q7XG4gICAgdGhpcy50cmlnZ2VyQ2FtZXJhQWNjZXNzID0gY29uZmlnLnRyaWdnZXJDYW1lcmFBY2Nlc3M7XG4gICAgdGhpcy5vblN0YXR1c1VwZGF0ZSA9IGNvbmZpZy5vblN0YXR1c1VwZGF0ZTtcbiAgICB0aGlzLnNhdmVJbWFnZVRvU2VydmVyID0gY29uZmlnLnNhdmVJbWFnZVRvU2VydmVyO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlcjtcbiAgICBcbiAgICAvLyBHZXQgY2FudmFzIG1hbmFnZXIgZnJvbSBnbG9iYWwgc2NvcGVcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNNYW5hZ2VyIDogbnVsbDtcbiAgfVxuXG4gIC8vIEdldCBvciBjcmVhdGUgY2FudmFzIHVzaW5nIHRoZSBuZXcgQ2FudmFzTWFuYWdlclxuICBnZXRDYW52YXMoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCB0aGlzLmNhbnZhc01hbmFnZXIuY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGNhbnZhc1JlZiBpZiBjYW52YXNNYW5hZ2VyIG5vdCBhdmFpbGFibGVcbiAgICByZXR1cm4gdGhpcy5jYW52YXNSZWY/LmN1cnJlbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICB9XG5cbiAgLy8gTWFpbiBmdW5jdGlvbiB0byBoYW5kbGUgcmFuZG9tIGRvdCBnZW5lcmF0aW9uIGFuZCBjYXB0dXJlXG4gIGhhbmRsZVJhbmRvbURvdCA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHNob3dpbmcgZG90XG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgcGFyZW50IGNvbXBvbmVudCBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5vblN0YXR1c1VwZGF0ZSkge1xuICAgICAgdGhpcy5vblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdHZW5lcmF0aW5nIHJhbmRvbSBkb3QuLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aW1lIHRvIHVwZGF0ZVxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgLy8gVXNlIGNhbnZhcyBtYW5hZ2VyIHRvIGVuc3VyZSBwcm9wZXIgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzKTtcbiAgICAgICAgXG4gICAgICAgIC8vIERyYXcgdGhlIGRvdCB3aXRoIGNvbnNpc3RlbnQgc2l6ZVxuICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTdG9yZSBjdXJyZW50IGRvdCBwb3NpdGlvblxuICAgICAgICB0aGlzLnNldEN1cnJlbnREb3QocG9zaXRpb24pO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBVc2UgdGhlIHNoYXJlZCBjYXB0dXJlIGFuZCBwcmV2aWV3IHByb2Nlc3NcbiAgICAgICAgICBhd2FpdCBjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3Moe1xuICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYXB0dXJlQ291bnRlcjogdGhpcy5jYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIHNhdmVJbWFnZVRvU2VydmVyOiB0aGlzLnNhdmVJbWFnZVRvU2VydmVyLFxuICAgICAgICAgICAgc2V0Q2FwdHVyZUNvdW50ZXI6IHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzZXRQcm9jZXNzU3RhdHVzOiB0aGlzLnNldFByb2Nlc3NTdGF0dXMsXG4gICAgICAgICAgICB0b2dnbGVUb3BCYXI6IHRoaXMudG9nZ2xlVG9wQmFyLFxuICAgICAgICAgICAgb25TdGF0dXNVcGRhdGU6IHRoaXMub25TdGF0dXNVcGRhdGUsXG4gICAgICAgICAgICBjYXB0dXJlRm9sZGVyOiAnZXllX3RyYWNraW5nX2NhcHR1cmVzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGUgdG8gZmFsc2UgYWZ0ZXIgcmVhc29uYWJsZSBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgfSwgMjIwMCk7IC8vIFdhaXQgYSBiaXQgbG9uZ2VyIHRoYW4gdGhlIHByZXZpZXcgZHVyYXRpb25cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gY2FwdHVyZSBhbmQgcHJldmlldyBwcm9jZXNzOlwiLCBlcnJvcik7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvciBkdXJpbmcgY2FwdHVyZSBwcm9jZXNzJyk7XG4gICAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgZXJyb3IgbWVzc2FnZSBhZnRlciBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCcnKTtcbiAgICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbnZhcyByZWZlcmVuY2UgaXMgbnVsbCAtIGNhbm5vdCBkcmF3IGRvdFwiKTtcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdFcnJvcjogQ2FudmFzIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmFuZG9tRG90QWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsImRyYXdSZWREb3QiLCJjYXB0dXJlQW5kUHJldmlld1Byb2Nlc3MiLCJSYW5kb21Eb3RBY3Rpb24iLCJnZXRDYW52YXMiLCJjYW52YXNNYW5hZ2VyIiwiY3JlYXRlQ2FudmFzIiwiY2FudmFzUmVmIiwiY3VycmVudCIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiaGFuZGxlUmFuZG9tRG90IiwidG9nZ2xlVG9wQmFyIiwid2luZG93Iiwic2V0SXNDYXB0dXJpbmciLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJwcm9jZXNzU3RhdHVzIiwiaXNDYXB0dXJpbmciLCJzZXRUaW1lb3V0IiwiY2FudmFzIiwiZW50ZXJGdWxsc2NyZWVuIiwicG9zaXRpb24iLCJjdHgiLCJnZXRDb250ZXh0IiwieCIsInkiLCJzZXRDdXJyZW50RG90IiwiY2FwdHVyZUNvdW50ZXIiLCJzYXZlSW1hZ2VUb1NlcnZlciIsInNldENhcHR1cmVDb3VudGVyIiwiY2FwdHVyZUZvbGRlciIsImVycm9yIiwiY29uc29sZSIsInRyaWdnZXJDYW1lcmFBY2Nlc3MiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./components/collected-dataset-customized/Action/RandomDotAction.jsx\n"));

/***/ })

}]);