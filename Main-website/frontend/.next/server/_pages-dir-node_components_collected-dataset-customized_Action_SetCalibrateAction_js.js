"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_js";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_js"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.js":
/*!******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-node)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.js\n// Handles the calibration sequence functionality\n\n\n\nclass SetCalibrateAction {\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if (false) {}\n            this.setIsCapturing(true);\n            this.setProcessStatus('Starting calibration sequence...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Use canvas manager to enter fullscreen\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate calibration points based on canvas size\n                    const points = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_0__.generateCalibrationPoints)(canvas.width, canvas.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = `\n          position: fixed;\n          top: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          font-size: 16px;\n          font-weight: bold;\n          padding: 10px 15px;\n          border-radius: 8px;\n          z-index: 10000;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n        `;\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        // Update status displays\n                        statusIndicator.textContent = `Calibration: Point ${i + 1}/${points.length}`;\n                        this.setProcessStatus(`Processing calibration point ${i + 1}/${points.length}`);\n                        // Clear canvas with white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        // Draw the calibration point\n                        const radius = 12; // Standard size for consistency\n                        (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = `\n            position: fixed;\n            left: ${point.x}px;\n            top: ${point.y - 60}px;\n            transform: translateX(-50%);\n            color: red;\n            font-size: 36px;\n            font-weight: bold;\n            text-shadow: 0 0 10px white, 0 0 20px white;\n            z-index: 10000;\n            background-color: rgba(255, 255, 255, 0.8);\n            border: 2px solid red;\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n          `;\n                        document.body.appendChild(countdownElement);\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(`Point ${i + 1}/${points.length}: Countdown ${count}`);\n                                // Force redraw to ensure dot stays visible\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"âœ“\";\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Remove countdown element after delay\n                            setTimeout(()=>{\n                                if (countdownElement.parentNode) {\n                                    countdownElement.parentNode.removeChild(countdownElement);\n                                }\n                            }, 300);\n                            // Make sure dot is still visible\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Capture images at this point\n                            console.log(`Capturing calibration point ${i + 1}/${points.length} at (${point.x}, ${point.y})`);\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_2__.captureImagesAtPoint)({\n                                point: point,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_1__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(`Error processing calibration point ${i + 1}:`, error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = `Calibration complete: ${successCount}/${points.length} points`;\n                    }\n                    this.setProcessStatus(`Calibration completed: ${successCount}/${points.length} points captured`);\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(`Calibration error: ${error.message}`);\n                } finally{\n                    // Exit fullscreen and restore canvas\n                    if (this.canvasManager) {\n                        this.canvasManager.exitFullscreen();\n                    }\n                    this.setIsCapturing(false);\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if (false) {}\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  false ? 0 : null;\n    }\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return this.canvasRef?.current || document.querySelector('#tracking-canvas');\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas(maxTries = 20, interval = 100) {\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQSx3QkFBd0I7QUFDeEIsaURBQWlEO0FBRWE7QUFDYTtBQUNqQjtBQUUxRCxNQUFNSztJQUNKQyxZQUFZQyxNQUFNLENBQUU7UUF1Q3BCLCtDQUErQzthQUMvQ0MscUJBQXFCO1lBQ25CLDhDQUE4QztZQUM5QyxJQUFJLE9BQU8sSUFBSSxDQUFDQyxZQUFZLEtBQUssWUFBWTtnQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7WUFDcEIsT0FBTyxJQUFJLEtBQW9ELEVBQUUsRUFFaEU7WUFFRCxJQUFJLENBQUNFLGNBQWMsQ0FBQztZQUNwQixJQUFJLENBQUNDLGdCQUFnQixDQUFDO1lBRXRCLHVDQUF1QztZQUN2QyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQztvQkFDbEJDLGVBQWU7b0JBQ2ZDLGFBQWE7Z0JBQ2Y7WUFDRjtZQUVBLG9DQUFvQztZQUNwQ0MsV0FBVztnQkFDVCxJQUFJO29CQUNGLE1BQU1DLFNBQVMsTUFBTSxJQUFJLENBQUNDLGFBQWE7b0JBQ3ZDLElBQUksQ0FBQ0QsUUFBUTt3QkFDWCxNQUFNLElBQUlFLE1BQU07b0JBQ2xCO29CQUVBLHlDQUF5QztvQkFDekMsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTt3QkFDdEIsSUFBSSxDQUFDQSxhQUFhLENBQUNDLGVBQWU7b0JBQ3BDO29CQUVBLG1EQUFtRDtvQkFDbkQsTUFBTUMsU0FBU3RCLDJFQUF5QkEsQ0FBQ2lCLE9BQU9NLEtBQUssRUFBRU4sT0FBT08sTUFBTTtvQkFFcEUsSUFBSSxDQUFDRixVQUFVQSxPQUFPRyxNQUFNLEtBQUssR0FBRzt3QkFDbEMsTUFBTSxJQUFJTixNQUFNO29CQUNsQjtvQkFFQSwwQkFBMEI7b0JBQzFCLE1BQU1P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Q25EO1FBQ0EsTUFBTSxJQUFJN0QsTUFBTTtJQUNsQjtBQW1ORjtBQUVBLGlFQUFlZCxrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9TZXRDYWxpYnJhdGVBY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2V0Q2FsaWJyYXRlQWN0aW9uLmpzXG4vLyBIYW5kbGVzIHRoZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZSBmdW5jdGlvbmFsaXR5XG5cbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cyc7XG5pbXBvcnQgeyBkcmF3UmVkRG90LCBydW5Db3VudGRvd24sIHNob3dDYXB0dXJlUHJldmlldyB9IGZyb20gJy4vY291bnRTYXZlJztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vSGVscGVyL3NhdmVmaWxlJztcblxuY2xhc3MgU2V0Q2FsaWJyYXRlQWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLy8gUmVxdWlyZWQgcHJvcGVydGllc1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyA9IGNvbmZpZy5zZXRJc0NhcHR1cmluZztcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBjb25maWcuc2V0UHJvY2Vzc1N0YXR1cztcbiAgICB0aGlzLnNldEN1cnJlbnREb3QgPSBjb25maWcuc2V0Q3VycmVudERvdDtcbiAgICB0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MgPSBjb25maWcudHJpZ2dlckNhbWVyYUFjY2VzcztcbiAgICB0aGlzLm9uU3RhdHVzVXBkYXRlID0gY29uZmlnLm9uU3RhdHVzVXBkYXRlO1xuICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBjb25maWcuc2F2ZUltYWdlVG9TZXJ2ZXI7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBmcm9tIGdsb2JhbCBzY29wZVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIG5ldyBDYW52YXNNYW5hZ2VyXG4gIGdldENhbnZhcygpIHtcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBXYWl0IHVudGlsIGNhbnZhcyBpcyBmdWxseSByZWFkeVxuICBhc3luYyB3YWl0Rm9yQ2FudmFzKG1heFRyaWVzID0gMjAsIGludGVydmFsID0gMTAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmllczsgaSsrKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMud2lkdGggPiAwICYmIGNhbnZhcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCByZWFkeSBhZnRlciBtdWx0aXBsZSBhdHRlbXB0c1wiKTtcbiAgfVxuXG4gIC8vIE1haW4gZnVuY3Rpb24gdG8gaGFuZGxlIGNhbGlicmF0aW9uIHNlcXVlbmNlXG4gIGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHN0YXJ0aW5nIGNhbGlicmF0aW9uXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcodHJ1ZSk7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicpO1xuICAgIFxuICAgIC8vIFVwZGF0ZSBwYXJlbnQgY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLm9uU3RhdHVzVXBkYXRlKSB7XG4gICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogJ1N0YXJ0aW5nIGNhbGlicmF0aW9uIHNlcXVlbmNlLi4uJyxcbiAgICAgICAgaXNDYXB0dXJpbmc6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGltZSB0byB1cGRhdGVcbiAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHRoaXMud2FpdEZvckNhbnZhcygpO1xuICAgICAgICBpZiAoIWNhbnZhcykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgYXZhaWxhYmxlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIGNhbnZhcyBtYW5hZ2VyIHRvIGVudGVyIGZ1bGxzY3JlZW5cbiAgICAgICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50cyBiYXNlZCBvbiBjYW52YXMgc2l6ZVxuICAgICAgICBjb25zdCBwb2ludHMgPSBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgcGFkZGluZzogMTBweCAxNXB4O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGlzcGxheXNcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgUHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDEyOyAvLyBTdGFuZGFyZCBzaXplIGZvciBjb25zaXN0ZW5jeVxuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgIGNvbnN0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudFxuICAgICAgICAgIGNvbnN0IGNvdW50ZG93bkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LmNsYXNzTmFtZSA9ICdkb3QtY291bnRkb3duJztcbiAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgICBsZWZ0OiAke3BvaW50Lnh9cHg7XG4gICAgICAgICAgICB0b3A6ICR7cG9pbnQueSAtIDYwfXB4O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICAgICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMzZweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xuICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgICAgd2lkdGg6IDUwcHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDUwcHg7XG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDEwcHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICAgIGA7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVkcmF3IGFnYWluIGhhbGZ3YXkgdGhyb3VnaCB0aGUgd2FpdFxuICAgICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGFmdGVyIGRlbGF5XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7cG9pbnQueH0sICR7cG9pbnQueX0pYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogdGhpcy5zZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhcHR1cmVSZXN1bHQgJiYgKGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgY2FwdHVyZVJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEyMDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGNvdW50ZG93biBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgc3RhdHVzIGluZGljYXRvciBhZnRlciBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FsaWJyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gRXhpdCBmdWxsc2NyZWVuIGFuZCByZXN0b3JlIGNhbnZhc1xuICAgICAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2hvdyBUb3BCYXIgYWdhaW4gYWZ0ZXIgYSBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudG9nZ2xlVG9wQmFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAxMDAwKTtcbiAgICAgIH1cbiAgICB9LCAyMDApO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBTZXRDYWxpYnJhdGVBY3Rpb247Il0sIm5hbWVzIjpbImdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMiLCJkcmF3UmVkRG90IiwicnVuQ291bnRkb3duIiwic2hvd0NhcHR1cmVQcmV2aWV3IiwiY2FwdHVyZUltYWdlc0F0UG9pbnQiLCJTZXRDYWxpYnJhdGVBY3Rpb24iLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImhhbmRsZVNldENhbGlicmF0ZSIsInRvZ2dsZVRvcEJhciIsIndpbmRvdyIsInNldElzQ2FwdHVyaW5nIiwic2V0UHJvY2Vzc1N0YXR1cyIsIm9uU3RhdHVzVXBkYXRlIiwicHJvY2Vzc1N0YXR1cyIsImlzQ2FwdHVyaW5nIiwic2V0VGltZW91dCIsImNhbnZhcyIsIndhaXRGb3JDYW52YXMiLCJFcnJvciIsImNhbnZhc01hbmFnZXIiLCJlbnRlckZ1bGxzY3JlZW4iLCJwb2ludHMiLCJ3aWR0aCIsImhlaWdodCIsImxlbmd0aCIsInN0YXR1c0luZGljYXRvciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsInN0eWxlIiwiY3NzVGV4dCIsInRleHRDb250ZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwic3VjY2Vzc0NvdW50IiwiaSIsInBvaW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicmFkaXVzIiwieCIsInkiLCJyZWRyYXdJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvdW50ZG93bkVsZW1lbnQiLCJjb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY29uc29sZSIsImxvZyIsImNhcHR1cmVSZXN1bHQiLCJjYXB0dXJlQ291bnQiLCJjYXB0dXJlQ291bnRlciIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnRlciIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsImVycm9yIiwiY2xlYXJJbnRlcnZhbCIsIm1lc3NhZ2UiLCJleGl0RnVsbHNjcmVlbiIsInNldEN1cnJlbnREb3QiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJxdWVyeVNlbGVjdG9yIiwibWF4VHJpZXMiLCJpbnRlcnZhbCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.js\n");

/***/ })

};
;