"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_SetRandomAction_js";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_SetRandomAction_js"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/SetRandomAction.js":
/*!***************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetRandomAction.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-node)/./components/collected-dataset-customized/Helper/savefile.js\");\n// components/Action/SetRandomAction.js\n\n\n\nconst SetRandomAction = ({ canvasRef, onStatusUpdate, setCaptureCounter, toggleTopBar, captureCounter = 1, triggerCameraAccess })=>{\n    const [randomTimes, setRandomTimes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const [delaySeconds, setDelaySeconds] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(3);\n    const [isCapturing, setIsCapturing] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    // Get canvas manager from global scope\n    const getCanvasManager = ()=>{\n        return  false ? 0 : null;\n    };\n    // Get or create canvas using the new CanvasManager\n    const getCanvas = ()=>{\n        const canvasManager = getCanvasManager();\n        if (canvasManager) {\n            return canvasManager.getCanvas() || canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return canvasRef?.current || document.querySelector('#tracking-canvas');\n    };\n    // Wait until canvas is fully ready\n    const waitForCanvas = async (maxTries = 20, interval = 100)=>{\n        for(let i = 0; i < maxTries; i++){\n            const canvas = getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    };\n    // Main handler for Set Random button\n    const handleSetRandom = async ()=>{\n        try {\n            // Get control values from the TopBar\n            const timeInput = document.querySelector('.control-input-field');\n            const delayInput = document.querySelectorAll('.control-input-field')[1];\n            // Default values if inputs can't be found\n            let times = 1;\n            let delay = 3;\n            // Parse input values if available\n            if (timeInput) {\n                const parsedTime = parseInt(timeInput.value, 10);\n                if (!isNaN(parsedTime) && parsedTime > 0) {\n                    times = parsedTime;\n                }\n            }\n            if (delayInput) {\n                const parsedDelay = parseInt(delayInput.value, 10);\n                if (!isNaN(parsedDelay) && parsedDelay > 0) {\n                    delay = parsedDelay;\n                }\n            }\n            // Hide UI during capture process\n            if (toggleTopBar) toggleTopBar(false);\n            onStatusUpdate?.({\n                processStatus: `Starting ${times} random captures with ${delay}s delay...`,\n                isCapturing: true,\n                remainingCaptures: times\n            });\n            // Wait for canvas to be ready\n            const canvas = await waitForCanvas();\n            // Use canvas manager to enter fullscreen\n            const canvasManager = getCanvasManager();\n            if (canvasManager) {\n                canvasManager.enterFullscreen();\n            }\n            // Process all captures sequentially\n            let successCount = 0;\n            let currentCapture = 1;\n            while(currentCapture <= times){\n                // Update status for current capture\n                onStatusUpdate?.({\n                    processStatus: `Capture ${currentCapture} of ${times}`,\n                    remainingCaptures: times - currentCapture + 1,\n                    isCapturing: true\n                });\n                // Clear canvas before each capture\n                const ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                ctx.fillStyle = 'white';\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                // Generate random position for this capture\n                const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.getRandomPosition)(canvas, 20);\n                // Draw the dot\n                (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y);\n                // Create a redrawInterval to ensure dot stays visible\n                let redrawInterval = setInterval(()=>{\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y, 12, false);\n                }, 200);\n                // Run countdown and wait for it to complete\n                await new Promise((resolve)=>{\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.runCountdown)(position, canvas, (status)=>{\n                        // Update UI based on status\n                        if (status.processStatus) {\n                            onStatusUpdate?.({\n                                processStatus: `Capture ${currentCapture}/${times}: ${status.processStatus}`,\n                                remainingCaptures: times - currentCapture + 1,\n                                isCapturing: true\n                            });\n                        }\n                    }, resolve // This will be called when countdown completes\n                    );\n                });\n                // Clear redrawInterval after countdown\n                clearInterval(redrawInterval);\n                // Trigger camera access before capture\n                if (triggerCameraAccess) {\n                    try {\n                        const cameraResult = triggerCameraAccess(true);\n                        if (!cameraResult) {\n                            console.warn('Camera access failed, but continuing with capture');\n                        }\n                    } catch (error) {\n                        console.warn('Camera access error, but continuing with capture:', error);\n                    }\n                }\n                // Wait briefly for camera to initialize\n                await new Promise((resolve)=>setTimeout(resolve, 500));\n                // Capture images at this point\n                try {\n                    const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_2__.captureImagesAtPoint)({\n                        point: position,\n                        captureCount: captureCounter,\n                        canvasRef: {\n                            current: canvas\n                        },\n                        setCaptureCount: setCaptureCounter,\n                        showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_1__.showCapturePreview\n                    });\n                    if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                        successCount++;\n                    }\n                    // Increment counter\n                    if (setCaptureCounter) {\n                        setCaptureCounter((prev)=>prev + 1);\n                    }\n                } catch (error) {\n                    console.error(`Error capturing point ${currentCapture}:`, error);\n                }\n                // Wait between captures for the specified delay time\n                if (currentCapture < times) {\n                    onStatusUpdate?.({\n                        processStatus: `Waiting ${delay}s before next capture...`,\n                        remainingCaptures: times - currentCapture,\n                        isCapturing: true\n                    });\n                    await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                }\n                // Move to next capture\n                currentCapture++;\n            }\n            // Sequence complete\n            onStatusUpdate?.({\n                processStatus: `Random capture sequence completed: ${successCount}/${times} captures successful`,\n                remainingCaptures: 0,\n                isCapturing: false\n            });\n            // Exit fullscreen and restore canvas\n            if (canvasManager) {\n                canvasManager.exitFullscreen();\n            }\n            // Turn TopBar back on\n            if (toggleTopBar) {\n                toggleTopBar(true);\n            }\n        } catch (err) {\n            console.error('Random sequence error:', err);\n            onStatusUpdate?.({\n                processStatus: `Random sequence failed: ${err.message}`,\n                isCapturing: false,\n                remainingCaptures: 0\n            });\n            // Make sure to restore the UI\n            if (toggleTopBar) toggleTopBar(true);\n        }\n    };\n    return {\n        handleAction: handleSetRandom\n    };\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetRandomAction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0UmFuZG9tQWN0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUEsdUNBQXVDO0FBQ0M7QUFDc0Q7QUFDcEM7QUFFMUQsTUFBTU8sa0JBQWtCLENBQUMsRUFDdkJDLFNBQVMsRUFDVEMsY0FBYyxFQUNkQyxpQkFBaUIsRUFDakJDLFlBQVksRUFDWkMsaUJBQWlCLENBQUMsRUFDbEJDLG1CQUFtQixFQUNwQjtJQUNDLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUMvQyxNQUFNLENBQUNlLGNBQWNDLGdCQUFnQixHQUFHaEIsK0NBQVFBLENBQUM7SUFDakQsTUFBTSxDQUFDaUIsYUFBYUMsZUFBZSxHQUFHbEIsK0NBQVFBLENBQUM7SUFFL0MsdUNBQXVDO0lBQ3ZDLE1BQU1tQixtQkFBbUI7UUFDdkIsT0FBTyxNQUE2QixHQUFHQyxDQUFvQixHQUFHO0lBQ2hFO0lBRUEsbURBQW1EO0lBQ25ELE1BQU1FLFlBQVk7UUFDaEIsTUFBTUQsZ0JBQWdCRjtRQUN0QixJQUFJRSxlQUFlO1lBQ2pCLE9BQU9BLGNBQWNDLFNBQVMsTUFBTUQsY0FBY0UsWUFBWTtRQUNoRTtRQUVBLHVEQUF1RDtRQUN2RCxPQUFPaEIsV0FBV2lCLFdBQVdDLFNBQVNDLGFBQWEsQ0FBQztJQUN0RDtJQUVBLG1DQUFtQztJQUNuQyxNQUFNQyxnQkFBZ0IsT0FBT0MsV0FBVyxFQUFFLEVBQUVDLFdBQVcsR0FBRztRQUN4RCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUUsSUFBSztZQUNqQyxNQUFNQyxTQUFTVDtZQUNmLElBQUlTLFVBQVVBLE9BQU9DLEtBQUssR0FBRyxLQUFLRCxPQUFPRSxNQUFNLEdBQUcsR0FBRztnQkFDbkQsT0FBT0Y7WUFDVDtZQUNBLE1BQU0sSUFBSUcsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBU047UUFDbkQ7UUFDQSxNQUFNLElBQUlRLE1BQU07SUFDbEI7SUFFQSxxQ0FBcUM7SUFDckMsTUFBTUMsa0JBQWtCO1FBQ3RCLElBQUk7WUFDRixxQ0FBcUM7WUFDckMsTUFBTUMsWUFBWWQsU0FBU0MsYUFBYSxDQUFDO1lBQ3pDLE1BQU1jLGFBQWFmLFNBQVNnQixnQkFBZ0IsQ0FBQyx1QkFBdUIsQ0FBQyxFQUFFO1lBRXZFLDBDQUEwQztZQUMxQyxJQUFJQyxRQUFRO1lBQ1osSUFBSUMsUUFBUTtZQUVaLGtDQUFrQztZQUNsQyxJQUFJSixXQUFXO2dCQUNiLE1BQU1LLGFBQWFDLFNBQVNOLFVBQVVPLEtBQUssRUFBRTtnQkFDN0MsSUFBSSxDQUFDQyxNQUFNSCxlQUFlQSxhQUFhLEdBQUc7b0JBQ3hDRixRQUFRRTtnQkFDVjtZQUNGO1lBRUEsSUFBSUosWUFBWTtnQkFDZCxNQUFNUSxjQUFjSCxTQUFTTCxXQUFXTSxLQUFLLEVBQUU7Z0JBQy9DLElBQUksQ0FBQ0MsTUFBTUMsZ0JBQWdCQSxjQUFjLEdBQUc7b0JBQzFDTCxRQUFRSztnQkFDVjtZQUNGO1lBRUEsaUNBQWlDO1lBQ2pDLElBQUl0QyxjQUFjQSxhQUFhO1lBRS9CRixpQkFBaUI7Z0JBQ2Z5QyxlQUFlLENBQUMsU0FBUyxFQUFFUCxNQUFNLHNCQUFzQixFQUFFQyxNQUFNLFVBQVUsQ0FBQztnQkFDMUUxQixhQUFhO2dCQUNiaUMsbUJBQW1CUjtZQUNyQjtZQUVBLDhCQUE4QjtZQUM5QixNQUFNWCxTQUFTLE1BQU1KO1lBRXJCLHlDQUF5QztZQUN6QyxNQUFNTixnQkFBZ0JGO1lBQ3RCLElBQUlFLGVBQWU7Z0JBQ2pCQSxjQUFjOEIsZUFBZTtZQUMvQjtZQUVBLG9DQUFvQztZQUNwQyxJQUFJQyxlQUFlO1lBQ25CLElBQUlDLGlCQUFpQjtZQUVyQixNQUFPQSxrQkFBa0JYLE1BQU87Z0JBQzlCLG9DQUFvQztnQkFDcENsQyxpQkFBaUI7b0JBQ2Z5QyxlQUFlLENBQUMsUUFBUSxFQUFFSSxlQUFlLElBQUksRUFBRVgsT0FBTztvQkFDdERRLG1CQUFtQlIsUUFBUVcsaUJBQWlCO29CQUM1Q3BDLGFBQWE7Z0JBQ2Y7Z0JBRUEsbUNBQW1DO2dCQUNuQyxNQUFNcUMsTUFBTXZCLE9BQU93QixVQUFVLENBQUM7Z0JBQzlCRCxJQUFJRSxTQUFTLENBQUMsR0FBRyxHQUFHekIsT0FBT0MsS0FBSyxFQUFFRCxPQUFPRSxNQUFNO2dCQUMvQ3FCLElBQUlHLFNBQVMsR0FBRztnQkFDaEJILElBQUlJLFFBQVEsQ0FBQyxHQUFHLEdBQUczQixPQUFPQyxLQUFLLEVBQUVELE9BQU9FLE1BQU07Z0JBRTlDLDRDQUE0QztnQkFDNUMsTUFBTTBCLFdBQVcxRCw2REFBaUJBLENBQUM4QixRQUFRO2dCQUUzQyxlQUFlO2dCQUNmN0Isc0RBQVVBLENBQUNvRCxLQUFLSyxTQUFTQyxDQUFDLEVBQUVELFNBQVNFLENBQUM7Z0JBRXRDLHNEQUFzRDtnQkFDdEQsSUFBSUMsaUJBQWlCQyxZQUFZO29CQUMvQjdELHNEQUFVQSxDQUFDb0QsS0FBS0ssU0FBU0MsQ0FBQyxFQUFFRCxTQUFTRSxDQUFDLEVBQUUsSUFBSTtnQkFDOUMsR0FBRztnQkFFSCw0Q0FBNEM7Z0JBQzVDLE1BQU0sSUFBSTNCLFFBQVFDLENBQUFBO29CQUNoQmhDLHdEQUFZQSxDQUNWd0QsVUFDQTVCLFFBQ0EsQ0FBQ2lDO3dCQUNDLDRCQUE0Qjt3QkFDNUIsSUFBSUEsT0FBT2YsYUFBYSxFQUFFOzRCQUN4QnpDLGlCQUFpQjtnQ0FDZnlDLGVBQWUsQ0FBQyxRQUFRLEVBQUVJLGVBQWUsQ0FBQyxFQUFFWCxNQUFNLEVBQUUsRUFBRXNCLE9BQU9mLGFBQWEsRUFBRTtnQ0FDNUVDLG1CQUFtQlIsUUFBUVcsaUJBQWlCO2dDQUM1Q3BDLGFBQWE7NEJBQ2Y7d0JBQ0Y7b0JBQ0YsR0FDQWtCLFFBQVEsK0NBQStDOztnQkFFM0Q7Z0JBRUEsdUNBQXVDO2dCQUN2QzhCLGNBQWNIO2dCQUVkLHVDQUF1QztnQkFDdkMsSUFBSWxELHFCQUFxQjtvQkFDdkIsSUFBSTt3QkFDRixNQUFNc0QsZUFBZXRELG9CQUFvQjt3QkFDekMsSUFBSSxDQUFDc0QsY0FBYzs0QkFDakJDLFFBQVFDLElBQUksQ0FBQzt3QkFDZjtvQkFDRixFQUFFLE9BQU9DLE9BQU87d0JBQ2RGLFFBQVFDLElBQUksQ0FBQyxxREFBcURDO29CQUNwRTtnQkFDRjtnQkFFQSx3Q0FBd0M7Z0JBQ3hDLE1BQU0sSUFBSW5DLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7Z0JBRWpELCtCQUErQjtnQkFDL0IsSUFBSTtvQkFDRixNQUFNbUMsZ0JBQWdCLE1BQU1qRSxzRUFBb0JBLENBQUM7d0JBQy9Da0UsT0FBT1o7d0JBQ1BhLGNBQWM3RDt3QkFDZEosV0FBVzs0QkFBRWlCLFNBQVNPO3dCQUFPO3dCQUM3QjBDLGlCQUFpQmhFO3dCQUNqQkwsa0JBQWtCQSw0REFBQUE7b0JBQ3BCO29CQUVBLElBQUlrRSxpQkFBa0JBLENBQUFBLGNBQWNJLFdBQVcsSUFBSUosY0FBY0ssT0FBTyxHQUFHO3dCQUN6RXZCO29CQUNGO29CQUVBLG9CQUFvQjtvQkFDcEIsSUFBSTNDLG1CQUFtQjt3QkFDckJBLGtCQUFrQm1FLENBQUFBLE9BQVFBLE9BQU87b0JBQ25DO2dCQUNGLEVBQUUsT0FBT1AsT0FBTztvQkFDZEYsUUFBUUUsS0FBSyxDQUFDLENBQUMsc0JBQXNCLEVBQUVoQixlQUFlLENBQUMsQ0FBQyxFQUFFZ0I7Z0JBQzVEO2dCQUVBLHFEQUFxRDtnQkFDckQsSUFBSWhCLGlCQUFpQlgsT0FBTztvQkFDMUJsQyxpQkFBaUI7d0JBQ2Z5QyxlQUFlLENBQUMsUUFBUSxFQUFFTixNQUFNLHdCQUF3QixDQUFDO3dCQUN6RE8sbUJBQW1CUixRQUFRVzt3QkFDM0JwQyxhQUFhO29CQUNmO29CQUVBLE1BQU0sSUFBSWlCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVNRLFFBQVE7Z0JBQzNEO2dCQUVBLHVCQUF1QjtnQkFDdkJVO1lBQ0Y7WUFFQSxvQkFBb0I7WUFDcEI3QyxpQkFBaUI7Z0JBQ2Z5QyxlQUFlLENBQUMsbUNBQW1DLEVBQUVHLGFBQWEsQ0FBQyxFQUFFVixNQUFNLG9CQUFvQixDQUFDO2dCQUNoR1EsbUJBQW1CO2dCQUNuQmpDLGFBQWE7WUFDZjtZQUVBLHFDQUFxQztZQUNyQyxJQUFJSSxlQUFlO2dCQUNqQkEsY0FBY3dELGNBQWM7WUFDOUI7WUFFQSxzQkFBc0I7WUFDdEIsSUFBSW5FLGNBQWM7Z0JBQ2hCQSxhQUFhO1lBQ2Y7UUFFRixFQUFFLE9BQU9vRSxLQUFLO1lBQ1pYLFFBQVFFLEtBQUssQ0FBQywwQkFBMEJTO1lBQ3hDdEUsaUJBQWlCO2dCQUNmeUMsZUFBZSxDQUFDLHdCQUF3QixFQUFFNkIsSUFBSUMsT0FBTyxFQUFFO2dCQUN2RDlELGFBQWE7Z0JBQ2JpQyxtQkFBbUI7WUFDckI7WUFFQSw4QkFBOEI7WUFDOUIsSUFBSXhDLGNBQWNBLGFBQWE7UUFDakM7SUFDRjtJQUVBLE9BQU87UUFDTHNFLGNBQWMxQztJQUNoQjtBQUNGO0FBRUEsaUVBQWVoQyxlQUFlQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0UmFuZG9tQWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbXBvbmVudHMvQWN0aW9uL1NldFJhbmRvbUFjdGlvbi5qc1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0UmFuZG9tUG9zaXRpb24sIGRyYXdSZWREb3QsIHJ1bkNvdW50ZG93biwgc2hvd0NhcHR1cmVQcmV2aWV3IH0gZnJvbSAnLi9jb3VudFNhdmUnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi9IZWxwZXIvc2F2ZWZpbGUnO1xuXG5jb25zdCBTZXRSYW5kb21BY3Rpb24gPSAoeyBcbiAgY2FudmFzUmVmLCBcbiAgb25TdGF0dXNVcGRhdGUsIFxuICBzZXRDYXB0dXJlQ291bnRlcixcbiAgdG9nZ2xlVG9wQmFyLFxuICBjYXB0dXJlQ291bnRlciA9IDEsXG4gIHRyaWdnZXJDYW1lcmFBY2Nlc3Ncbn0pID0+IHtcbiAgY29uc3QgW3JhbmRvbVRpbWVzLCBzZXRSYW5kb21UaW1lc10gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW2RlbGF5U2Vjb25kcywgc2V0RGVsYXlTZWNvbmRzXSA9IHVzZVN0YXRlKDMpO1xuICBjb25zdCBbaXNDYXB0dXJpbmcsIHNldElzQ2FwdHVyaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAvLyBHZXQgY2FudmFzIG1hbmFnZXIgZnJvbSBnbG9iYWwgc2NvcGVcbiAgY29uc3QgZ2V0Q2FudmFzTWFuYWdlciA9ICgpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuY2FudmFzTWFuYWdlciA6IG51bGw7XG4gIH07XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIG5ldyBDYW52YXNNYW5hZ2VyXG4gIGNvbnN0IGdldENhbnZhcyA9ICgpID0+IHtcbiAgICBjb25zdCBjYW52YXNNYW5hZ2VyID0gZ2V0Q2FudmFzTWFuYWdlcigpO1xuICAgIGlmIChjYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCBjYW52YXNNYW5hZ2VyLmNyZWF0ZUNhbnZhcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBjYW52YXNSZWYgaWYgY2FudmFzTWFuYWdlciBub3QgYXZhaWxhYmxlXG4gICAgcmV0dXJuIGNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH07XG5cbiAgLy8gV2FpdCB1bnRpbCBjYW52YXMgaXMgZnVsbHkgcmVhZHlcbiAgY29uc3Qgd2FpdEZvckNhbnZhcyA9IGFzeW5jIChtYXhUcmllcyA9IDIwLCBpbnRlcnZhbCA9IDEwMCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VHJpZXM7IGkrKykge1xuICAgICAgY29uc3QgY2FudmFzID0gZ2V0Q2FudmFzKCk7XG4gICAgICBpZiAoY2FudmFzICYmIGNhbnZhcy53aWR0aCA+IDAgJiYgY2FudmFzLmhlaWdodCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBpbnRlcnZhbCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IHJlYWR5IGFmdGVyIG11bHRpcGxlIGF0dGVtcHRzXCIpO1xuICB9O1xuXG4gIC8vIE1haW4gaGFuZGxlciBmb3IgU2V0IFJhbmRvbSBidXR0b25cbiAgY29uc3QgaGFuZGxlU2V0UmFuZG9tID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY29udHJvbCB2YWx1ZXMgZnJvbSB0aGUgVG9wQmFyXG4gICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZCcpO1xuICAgICAgY29uc3QgZGVsYXlJbnB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jb250cm9sLWlucHV0LWZpZWxkJylbMV07XG4gICAgICBcbiAgICAgIC8vIERlZmF1bHQgdmFsdWVzIGlmIGlucHV0cyBjYW4ndCBiZSBmb3VuZFxuICAgICAgbGV0IHRpbWVzID0gMTtcbiAgICAgIGxldCBkZWxheSA9IDM7XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIGlucHV0IHZhbHVlcyBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh0aW1lSW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVGltZSA9IHBhcnNlSW50KHRpbWVJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZFRpbWUpICYmIHBhcnNlZFRpbWUgPiAwKSB7XG4gICAgICAgICAgdGltZXMgPSBwYXJzZWRUaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChkZWxheUlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZERlbGF5ID0gcGFyc2VJbnQoZGVsYXlJbnB1dC52YWx1ZSwgMTApO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZERlbGF5KSAmJiBwYXJzZWREZWxheSA+IDApIHtcbiAgICAgICAgICBkZWxheSA9IHBhcnNlZERlbGF5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEhpZGUgVUkgZHVyaW5nIGNhcHR1cmUgcHJvY2Vzc1xuICAgICAgaWYgKHRvZ2dsZVRvcEJhcikgdG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIFxuICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6IGBTdGFydGluZyAke3RpbWVzfSByYW5kb20gY2FwdHVyZXMgd2l0aCAke2RlbGF5fXMgZGVsYXkuLi5gLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZSxcbiAgICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IHRpbWVzXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gV2FpdCBmb3IgY2FudmFzIHRvIGJlIHJlYWR5XG4gICAgICBjb25zdCBjYW52YXMgPSBhd2FpdCB3YWl0Rm9yQ2FudmFzKCk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBjYW52YXMgbWFuYWdlciB0byBlbnRlciBmdWxsc2NyZWVuXG4gICAgICBjb25zdCBjYW52YXNNYW5hZ2VyID0gZ2V0Q2FudmFzTWFuYWdlcigpO1xuICAgICAgaWYgKGNhbnZhc01hbmFnZXIpIHtcbiAgICAgICAgY2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJvY2VzcyBhbGwgY2FwdHVyZXMgc2VxdWVudGlhbGx5XG4gICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgIGxldCBjdXJyZW50Q2FwdHVyZSA9IDE7XG4gICAgICBcbiAgICAgIHdoaWxlIChjdXJyZW50Q2FwdHVyZSA8PSB0aW1lcykge1xuICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGZvciBjdXJyZW50IGNhcHR1cmVcbiAgICAgICAgb25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0gb2YgJHt0aW1lc31gLFxuICAgICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiB0aW1lcyAtIGN1cnJlbnRDYXB0dXJlICsgMSxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBiZWZvcmUgZWFjaCBjYXB0dXJlXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvbiBmb3IgdGhpcyBjYXB0dXJlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBkb3RcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVkcmF3SW50ZXJ2YWwgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgIGxldCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgMTIsIGZhbHNlKTtcbiAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJ1biBjb3VudGRvd24gYW5kIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgIHJ1bkNvdW50ZG93bihcbiAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAvLyBVcGRhdGUgVUkgYmFzZWQgb24gc3RhdHVzXG4gICAgICAgICAgICAgIGlmIChzdGF0dXMucHJvY2Vzc1N0YXR1cykge1xuICAgICAgICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0vJHt0aW1lc306ICR7c3RhdHVzLnByb2Nlc3NTdGF0dXN9YCxcbiAgICAgICAgICAgICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiB0aW1lcyAtIGN1cnJlbnRDYXB0dXJlICsgMSxcbiAgICAgICAgICAgICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNvbHZlIC8vIFRoaXMgd2lsbCBiZSBjYWxsZWQgd2hlbiBjb3VudGRvd24gY29tcGxldGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDbGVhciByZWRyYXdJbnRlcnZhbCBhZnRlciBjb3VudGRvd25cbiAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlnZ2VyIGNhbWVyYSBhY2Nlc3MgYmVmb3JlIGNhcHR1cmVcbiAgICAgICAgaWYgKHRyaWdnZXJDYW1lcmFBY2Nlc3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2FtZXJhUmVzdWx0ID0gdHJpZ2dlckNhbWVyYUFjY2Vzcyh0cnVlKTtcbiAgICAgICAgICAgIGlmICghY2FtZXJhUmVzdWx0KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2FtZXJhIGFjY2VzcyBmYWlsZWQsIGJ1dCBjb250aW51aW5nIHdpdGggY2FwdHVyZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NhbWVyYSBhY2Nlc3MgZXJyb3IsIGJ1dCBjb250aW51aW5nIHdpdGggY2FwdHVyZTonLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJyaWVmbHkgZm9yIGNhbWVyYSB0byBpbml0aWFsaXplXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgcG9pbnQ6IHBvc2l0aW9uLFxuICAgICAgICAgICAgY2FwdHVyZUNvdW50OiBjYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgIGNhbnZhc1JlZjogeyBjdXJyZW50OiBjYW52YXMgfSxcbiAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcbiAgICAgICAgICBpZiAoc2V0Q2FwdHVyZUNvdW50ZXIpIHtcbiAgICAgICAgICAgIHNldENhcHR1cmVDb3VudGVyKHByZXYgPT4gcHJldiArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBjYXB0dXJpbmcgcG9pbnQgJHtjdXJyZW50Q2FwdHVyZX06YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBXYWl0IGJldHdlZW4gY2FwdHVyZXMgZm9yIHRoZSBzcGVjaWZpZWQgZGVsYXkgdGltZVxuICAgICAgICBpZiAoY3VycmVudENhcHR1cmUgPCB0aW1lcykge1xuICAgICAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gLFxuICAgICAgICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IHRpbWVzIC0gY3VycmVudENhcHR1cmUsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSAqIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IGNhcHR1cmVcbiAgICAgICAgY3VycmVudENhcHR1cmUrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2VxdWVuY2UgY29tcGxldGVcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBgUmFuZG9tIGNhcHR1cmUgc2VxdWVuY2UgY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHt0aW1lc30gY2FwdHVyZXMgc3VjY2Vzc2Z1bGAsXG4gICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiAwLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBFeGl0IGZ1bGxzY3JlZW4gYW5kIHJlc3RvcmUgY2FudmFzXG4gICAgICBpZiAoY2FudmFzTWFuYWdlcikge1xuICAgICAgICBjYW52YXNNYW5hZ2VyLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFR1cm4gVG9wQmFyIGJhY2sgb25cbiAgICAgIGlmICh0b2dnbGVUb3BCYXIpIHtcbiAgICAgICAgdG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgfVxuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdSYW5kb20gc2VxdWVuY2UgZXJyb3I6JywgZXJyKTtcbiAgICAgIG9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBgUmFuZG9tIHNlcXVlbmNlIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2UsXG4gICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiAwXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlc3RvcmUgdGhlIFVJXG4gICAgICBpZiAodG9nZ2xlVG9wQmFyKSB0b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgaGFuZGxlQWN0aW9uOiBoYW5kbGVTZXRSYW5kb21cbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFNldFJhbmRvbUFjdGlvbjsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VTdGF0ZSIsImdldFJhbmRvbVBvc2l0aW9uIiwiZHJhd1JlZERvdCIsInJ1bkNvdW50ZG93biIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiU2V0UmFuZG9tQWN0aW9uIiwiY2FudmFzUmVmIiwib25TdGF0dXNVcGRhdGUiLCJzZXRDYXB0dXJlQ291bnRlciIsInRvZ2dsZVRvcEJhciIsImNhcHR1cmVDb3VudGVyIiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsInJhbmRvbVRpbWVzIiwic2V0UmFuZG9tVGltZXMiLCJkZWxheVNlY29uZHMiLCJzZXREZWxheVNlY29uZHMiLCJpc0NhcHR1cmluZyIsInNldElzQ2FwdHVyaW5nIiwiZ2V0Q2FudmFzTWFuYWdlciIsIndpbmRvdyIsImNhbnZhc01hbmFnZXIiLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJjdXJyZW50IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwid2FpdEZvckNhbnZhcyIsIm1heFRyaWVzIiwiaW50ZXJ2YWwiLCJpIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJFcnJvciIsImhhbmRsZVNldFJhbmRvbSIsInRpbWVJbnB1dCIsImRlbGF5SW5wdXQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidGltZXMiLCJkZWxheSIsInBhcnNlZFRpbWUiLCJwYXJzZUludCIsInZhbHVlIiwiaXNOYU4iLCJwYXJzZWREZWxheSIsInByb2Nlc3NTdGF0dXMiLCJyZW1haW5pbmdDYXB0dXJlcyIsImVudGVyRnVsbHNjcmVlbiIsInN1Y2Nlc3NDb3VudCIsImN1cnJlbnRDYXB0dXJlIiwiY3R4IiwiZ2V0Q29udGV4dCIsImNsZWFyUmVjdCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicG9zaXRpb24iLCJ4IiwieSIsInJlZHJhd0ludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJzdGF0dXMiLCJjbGVhckludGVydmFsIiwiY2FtZXJhUmVzdWx0IiwiY29uc29sZSIsIndhcm4iLCJlcnJvciIsImNhcHR1cmVSZXN1bHQiLCJwb2ludCIsImNhcHR1cmVDb3VudCIsInNldENhcHR1cmVDb3VudCIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsInByZXYiLCJleGl0RnVsbHNjcmVlbiIsImVyciIsIm1lc3NhZ2UiLCJoYW5kbGVBY3Rpb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/SetRandomAction.js\n");

/***/ })

};
;