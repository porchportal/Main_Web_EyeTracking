"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_jsx";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_jsx"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx":
/*!*******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.jsx ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CalibratePoints_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalibratePoints.jsx */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/CalibratePoints.jsx\");\n/* harmony import */ var _countSave_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countSave.jsx */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/countSave.jsx\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-node)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.jsx\n// Handles the calibration sequence functionality\n\n\n\n\nclass SetCalibrateAction {\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if (false) {}\n            // Set capturing state if function exists\n            if (typeof this.setIsCapturing === 'function') {\n                this.setIsCapturing(true);\n            }\n            if (typeof this.setProcessStatus === 'function') {\n                this.setProcessStatus('Starting calibration sequence...');\n            }\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Store original canvas dimensions before going fullscreen\n                    this.originalCanvasDimensions = {\n                        width: canvas.width,\n                        height: canvas.height\n                    };\n                    // Use canvas management system to enter fullscreen\n                    this.enterFullscreen();\n                    // Ensure canvas is properly positioned and sized\n                    const isProperlyPositioned = this.ensureCanvasFullscreen(canvas);\n                    if (!isProperlyPositioned) {\n                        console.warn('Canvas not properly positioned for fullscreen, attempting to fix...');\n                        // Try one more time after a short delay\n                        setTimeout(()=>{\n                            this.ensureCanvasFullscreen(canvas);\n                        }, 100);\n                    }\n                    // Test coordinate transformation\n                    this.testCoordinateTransformation(canvas);\n                    // Generate calibration points based on ORIGINAL canvas size\n                    const points = (0,_CalibratePoints_jsx__WEBPACK_IMPORTED_MODULE_1__.generateCalibrationPoints)(this.originalCanvasDimensions.width, this.originalCanvasDimensions.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = `\n          position: fixed;\n          top: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          font-size: 16px;\n          font-weight: bold;\n          padding: 10px 15px;\n          border-radius: 8px;\n          z-index: 10000;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n        `;\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const originalPoint = points[i];\n                        // Transform coordinates for fullscreen display\n                        const transformedPoint = this.transformCoordinates(canvas, originalPoint);\n                        // Update status displays\n                        statusIndicator.textContent = `Calibration: Point ${i + 1}/${points.length}`;\n                        this.setProcessStatus(`Processing calibration point ${i + 1}/${points.length}`);\n                        // Clear canvas with white background using canvas management system\n                        this.clearCanvas();\n                        // Draw the calibration point using ORIGINAL coordinates (canvas coordinates)\n                        const radius = 12; // Standard size for consistency\n                        this.drawDot(originalPoint.x, originalPoint.y, radius);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            this.drawDot(originalPoint.x, originalPoint.y, radius);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element positioned using TRANSFORMED coordinates (viewport coordinates)\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = `\n            position: fixed;\n            left: ${transformedPoint.x}px;\n            top: ${transformedPoint.y}px;\n            transform: translate(-50%, -50%);\n            color: red;\n            font-size: 24px;\n            font-weight: bold;\n            text-shadow: 0 0 10px white, 0 0 20px white;\n            z-index: 10000;\n            background-color: rgba(255, 255, 255, 0.9);\n            border: 2px solid red;\n            border-radius: 50%;\n            width: 48px;\n            height: 48px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);\n          `;\n                        document.body.appendChild(countdownElement);\n                        // Debug: Log positioning information\n                        console.log(`Point ${i + 1} positioning:`, {\n                            originalPoint,\n                            transformedPoint,\n                            countdownPosition: {\n                                left: transformedPoint.x,\n                                top: transformedPoint.y\n                            },\n                            canvasInfo: {\n                                width: canvas.width,\n                                height: canvas.height,\n                                rect: canvas.getBoundingClientRect()\n                            }\n                        });\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(`Point ${i + 1}/${points.length}: Countdown ${count}`);\n                                // Force redraw to ensure dot stays visible (using original coordinates)\n                                this.drawDot(originalPoint.x, originalPoint.y, radius);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                this.drawDot(originalPoint.x, originalPoint.y, radius);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"✓\";\n                            this.drawDot(originalPoint.x, originalPoint.y, radius);\n                            // Remove countdown element immediately\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Make sure dot is still visible\n                            this.drawDot(originalPoint.x, originalPoint.y, radius);\n                            // Capture images at this point (use original coordinates for capture)\n                            console.log(`Capturing calibration point ${i + 1}/${points.length} at (${originalPoint.x}, ${originalPoint.y})`);\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_3__.captureImagesAtPoint)({\n                                point: originalPoint,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave_jsx__WEBPACK_IMPORTED_MODULE_2__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait a moment before clearing to ensure capture is complete\n                            await new Promise((resolve)=>setTimeout(resolve, 500));\n                            // Clear the dot after capture using canvas management system\n                            this.clearCanvas();\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(`Error processing calibration point ${i + 1}:`, error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = `Calibration complete: ${successCount}/${points.length} points`;\n                    }\n                    this.setProcessStatus(`Calibration completed: ${successCount}/${points.length} points captured`);\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(`Calibration error: ${error.message}`);\n                } finally{\n                    // Exit fullscreen and restore canvas using canvas management system\n                    this.exitFullscreen();\n                    // Restore hidden elements\n                    this.restoreHiddenElements();\n                    // Set capturing state to false if function exists\n                    if (typeof this.setIsCapturing === 'function') {\n                        this.setIsCapturing(false);\n                    }\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if (false) {}\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager and utilities from global scope (from actionButton.js)\n        this.canvasManager =  false ? 0 : null;\n        this.canvasUtils =  false ? 0 : null;\n        // Store original canvas dimensions for coordinate transformation\n        this.originalCanvasDimensions = null;\n    }\n    // Get or create canvas using the canvas management system from actionButton.js\n    getCanvas() {\n        // Use the global canvas manager\n        if (false) {}\n        // Fallback to canvasUtils from actionButton.js\n        if (this.canvasUtils && typeof this.canvasUtils.getCanvas === 'function') {\n            return this.canvasUtils.getCanvas();\n        }\n        // Fallback to canvasManager\n        if (this.canvasManager && typeof this.canvasManager.getCanvas === 'function') {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return this.canvasRef?.current || document.querySelector('#tracking-canvas');\n    }\n    // Transform canvas coordinates to viewport coordinates when in fullscreen\n    transformCoordinates(canvas, point) {\n        if (!canvas || !point) return point;\n        // If canvas is in fullscreen mode, we need to transform coordinates\n        const isFullscreen = this.canvasManager?.isInFullscreen() || this.canvasUtils?.isFullscreen?.() || canvas.style.position === 'fixed' && canvas.style.width === '100vw';\n        console.log('Transform coordinates check:', {\n            canvasPosition: canvas.style.position,\n            canvasWidth: canvas.style.width,\n            canvasHeight: canvas.style.height,\n            isFullscreen,\n            originalPoint: point,\n            canvasRect: canvas.getBoundingClientRect()\n        });\n        if (isFullscreen) {\n            // Get the canvas's bounding rect to understand its position in the viewport\n            const canvasRect = canvas.getBoundingClientRect();\n            // Check if canvas is properly positioned\n            const isProperlyPositioned = canvasRect.left === 0 && canvasRect.top === 0 && canvasRect.width === window.innerWidth && canvasRect.height === window.innerHeight;\n            console.log('Canvas positioning check:', {\n                canvasRect,\n                windowSize: {\n                    width: window.innerWidth,\n                    height: window.innerHeight\n                },\n                isProperlyPositioned\n            });\n            // Calculate the scale factors\n            const scaleX = canvasRect.width / canvas.width;\n            const scaleY = canvasRect.height / canvas.height;\n            // Transform the coordinates\n            const transformedPoint = {\n                x: point.x * scaleX + canvasRect.left,\n                y: point.y * scaleY + canvasRect.top,\n                label: point.label\n            };\n            console.log('Coordinate transformation:', {\n                original: point,\n                transformed: transformedPoint,\n                canvasRect,\n                scale: {\n                    x: scaleX,\n                    y: scaleY\n                },\n                canvasDimensions: {\n                    width: canvas.width,\n                    height: canvas.height\n                }\n            });\n            return transformedPoint;\n        }\n        // If not fullscreen, return original coordinates\n        return point;\n    }\n    // Enter fullscreen using the canvas management system\n    enterFullscreen() {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.enterFullscreen === 'function') {\n            return this.canvasUtils.enterFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.enterFullscreen === 'function') {\n            this.canvasManager.enterFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually enter fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            // Store original dimensions before going fullscreen\n            this.originalCanvasDimensions = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            // Remove canvas from its current parent\n            if (canvas.parentNode) {\n                canvas.parentNode.removeChild(canvas);\n            }\n            // Append to body and set fullscreen styles\n            document.body.appendChild(canvas);\n            // Set fullscreen styles with proper positioning\n            canvas.style.cssText = `\n        position: fixed !important;\n        top: 0 !important;\n        left: 0 !important;\n        width: 100vw !important;\n        height: 100vh !important;\n        z-index: 99999 !important;\n        background-color: yellow !important;\n        border: none !important;\n        display: block !important;\n        opacity: 1 !important;\n        pointer-events: auto !important;\n        margin: 0 !important;\n        padding: 0 !important;\n        box-sizing: border-box !important;\n        transform: none !important;\n      `;\n            // Set canvas dimensions to match viewport\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            // Clear with yellow background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'yellow';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Force a reflow to ensure styles are applied\n            canvas.offsetHeight;\n            console.log('Canvas fullscreen setup:', {\n                width: canvas.width,\n                height: canvas.height,\n                style: canvas.style.cssText,\n                rect: canvas.getBoundingClientRect()\n            });\n        }\n        return canvas;\n    }\n    // Exit fullscreen using the canvas management system\n    exitFullscreen() {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.exitFullscreen === 'function') {\n            return this.canvasUtils.exitFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.exitFullscreen === 'function') {\n            this.canvasManager.exitFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually exit fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            container.appendChild(canvas);\n            canvas.style.position = 'relative';\n            canvas.style.top = '';\n            canvas.style.left = '';\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.zIndex = '';\n            canvas.style.backgroundColor = 'yellow';\n            // Restore original dimensions if available\n            if (this.originalCanvasDimensions) {\n                canvas.width = this.originalCanvasDimensions.width;\n                canvas.height = this.originalCanvasDimensions.height;\n                this.originalCanvasDimensions = null;\n            }\n        }\n        return canvas;\n    }\n    // Restore elements that were hidden during fullscreen\n    restoreHiddenElements() {\n        const hiddenElements = document.querySelectorAll('[data-hidden-by-canvas=\"true\"]');\n        hiddenElements.forEach((el)=>{\n            el.style.display = '';\n            el.removeAttribute('data-hidden-by-canvas');\n        });\n    }\n    // Clear canvas using the canvas management system\n    clearCanvas() {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.clear === 'function') {\n            this.canvasUtils.clear();\n            return;\n        }\n        if (this.canvasManager && typeof this.canvasManager.clear === 'function') {\n            this.canvasManager.clear();\n            return;\n        }\n        // Fallback: manually clear canvas\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'yellow';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    }\n    // Draw dot using the canvas management system\n    drawDot(x, y, radius = 12) {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.drawDot === 'function') {\n            return this.canvasUtils.drawDot(x, y, radius);\n        }\n        // Fallback: manually draw dot\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            (0,_countSave_jsx__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, x, y, radius, false);\n            return true;\n        }\n        return false;\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas(maxTries = 20, interval = 100) {\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n    // Test coordinate transformation\n    testCoordinateTransformation(canvas) {\n        console.log('Testing coordinate transformation...');\n        const testPoint = {\n            x: 100,\n            y: 100,\n            label: 'Test'\n        };\n        const transformed = this.transformCoordinates(canvas, testPoint);\n        console.log('Test transformation result:', {\n            original: testPoint,\n            transformed: transformed,\n            canvasInfo: {\n                width: canvas.width,\n                height: canvas.height,\n                style: {\n                    position: canvas.style.position,\n                    width: canvas.style.width,\n                    height: canvas.style.height\n                },\n                rect: canvas.getBoundingClientRect()\n            }\n        });\n        return transformed;\n    }\n    // Ensure canvas is properly positioned and sized for fullscreen\n    ensureCanvasFullscreen(canvas) {\n        if (!canvas) return false;\n        // Remove any conflicting elements that might interfere\n        this.removeConflictingElements();\n        // Ensure canvas is in body\n        if (canvas.parentNode !== document.body) {\n            if (canvas.parentNode) {\n                canvas.parentNode.removeChild(canvas);\n            }\n            document.body.appendChild(canvas);\n        }\n        // Force canvas to cover entire viewport\n        canvas.style.cssText = `\n      position: fixed !important;\n      top: 0 !important;\n      left: 0 !important;\n      width: 100vw !important;\n      height: 100vh !important;\n      z-index: 99999 !important;\n      background-color: white !important;\n      border: none !important;\n      display: block !important;\n      opacity: 1 !important;\n      pointer-events: auto !important;\n      margin: 0 !important;\n      padding: 0 !important;\n      box-sizing: border-box !important;\n      transform: none !important;\n    `;\n        // Set dimensions to match viewport\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Force reflow\n        canvas.offsetHeight;\n        // Verify positioning\n        const rect = canvas.getBoundingClientRect();\n        const isProperlyPositioned = rect.left === 0 && rect.top === 0 && rect.width === window.innerWidth && rect.height === window.innerHeight;\n        console.log('Canvas fullscreen verification:', {\n            rect,\n            windowSize: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            },\n            isProperlyPositioned,\n            canvasDimensions: {\n                width: canvas.width,\n                height: canvas.height\n            }\n        });\n        return isProperlyPositioned;\n    }\n    // Remove any conflicting elements that might interfere with fullscreen canvas\n    removeConflictingElements() {\n        // Hide any elements that might interfere with fullscreen display\n        const elementsToHide = [\n            '.topbar',\n            '.canvas-container',\n            '.main-content',\n            '.metrics-panel',\n            '.display-metrics',\n            'nav',\n            'header',\n            '.button-groups',\n            '.control-buttons'\n        ];\n        elementsToHide.forEach((selector)=>{\n            const elements = document.querySelectorAll(selector);\n            elements.forEach((el)=>{\n                if (el.style.display !== 'none') {\n                    el.style.display = 'none';\n                    el.setAttribute('data-hidden-by-canvas', 'true');\n                }\n            });\n        });\n        // Remove any existing countdown elements\n        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n        existingCountdowns.forEach((el)=>{\n            if (el.parentNode) el.parentNode.removeChild(el);\n        });\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaURBQWlEO0FBRXZCO0FBQ3dDO0FBQ2E7QUFDckI7QUFFMUQsTUFBTU07SUFDSkMsWUFBWUMsTUFBTSxDQUFFO1FBb1pwQiwrQ0FBK0M7YUFDL0NDLHFCQUFxQjtZQUNuQiw4Q0FBOEM7WUFDOUMsSUFBSSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLLFlBQVk7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxLQUFvRCxFQUFFLEVBRWhFO1lBRUQseUNBQXlDO1lBQ3pDLElBQUksT0FBTyxJQUFJLENBQUNFLGNBQWMsS0FBSyxZQUFZO2dCQUM3QyxJQUFJLENBQUNBLGNBQWMsQ0FBQztZQUN0QjtZQUVBLElBQUksT0FBTyxJQUFJLENBQUNDLGdCQUFnQixLQUFLLFlBQVk7Z0JBQy9DLElBQUksQ0FBQ0EsZ0JBQWdCLENBQUM7WUFDeEI7WUFFQSx1Q0FBdUM7WUFDdkMsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtnQkFDdkIsSUFBSSxDQUFDQSxjQUFjLENBQUM7b0JBQ2xCQyxlQUFlO29CQUNmQyxhQUFhO2dCQUNmO1lBQ0Y7WUFFQSxvQ0FBb0M7WUFDcENDLFdBQVc7Z0JBQ1QsSUFBSTtvQkFDRixNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDQyxhQUFhO29CQUN2QyxJQUFJLENBQUNELFFBQVE7d0JBQ1gsTUFBTSxJQUFJRSxNQUFNO29CQUNsQjtvQkFFQSwyREFBMkQ7b0JBQzNELElBQUksQ0FBQ0Msd0JBQXdCLEdBQUc7d0JBQzlCQyxPQUFPSixPQUFPSSxLQUFLO3dCQUNuQkMsUUFBUUwsT0FBT0ssTUFBTTtvQkFDdkI7b0JBRUEsbURBQW1EO29CQUNuRCxJQUFJLENBQUNDLGVBQWU7b0JBRXBC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aUI7WUFDckI7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1NBQ0Q7UUFFREEsZUFBZXpFLE9BQU8sQ0FBQzBFLENBQUFBO1lBQ3JCLE1BQU1DLFdBQVdqRyxTQUFTcUIsZ0JBQWdCLENBQUMyRTtZQUMzQ0MsU0FBUzNFLE9BQU8sQ0FBQ0MsQ0FBQUE7Z0JBQ2YsSUFBSUEsR0FBR3BCLEtBQUssQ0FBQ29GLE9BQU8sS0FBSyxRQUFRO29CQUMvQmhFLEdBQUdwQixLQUFLLENBQUNvRixPQUFPLEdBQUc7b0JBQ25CaEUsR0FBRzJFLFlBQVksQ0FBQyx5QkFBeUI7Z0JBQzNDO1lBQ0Y7UUFDRjtRQUVBLHlDQUF5QztRQUN6QyxNQUFNOUUscUJBQXFCcEIsU0FBU3FCLGdCQUFnQixDQUFDO1FBQ3JERCxtQkFBbUJFLE9BQU8sQ0FBQ0MsQ0FBQUE7WUFDekIsSUFBSUEsR0FBR0MsVUFBVSxFQUFFRCxHQUFHQyxVQUFVLENBQUNDLFdBQVcsQ0FBQ0Y7UUFDL0M7SUFDRjtBQWlRRjtBQUVBLGlFQUFlbEQsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXRDYWxpYnJhdGVBY3Rpb24uanN4XG4vLyBIYW5kbGVzIHRoZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZSBmdW5jdGlvbmFsaXR5XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi9DYWxpYnJhdGVQb2ludHMuanN4JztcbmltcG9ydCB7IGRyYXdSZWREb3QsIHJ1bkNvdW50ZG93biwgc2hvd0NhcHR1cmVQcmV2aWV3IH0gZnJvbSAnLi9jb3VudFNhdmUuanN4JztcbmltcG9ydCB7IGNhcHR1cmVJbWFnZXNBdFBvaW50IH0gZnJvbSAnLi4vSGVscGVyL3NhdmVmaWxlJztcblxuY2xhc3MgU2V0Q2FsaWJyYXRlQWN0aW9uIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgLy8gUmVxdWlyZWQgcHJvcGVydGllc1xuICAgIHRoaXMuY2FudmFzUmVmID0gY29uZmlnLmNhbnZhc1JlZjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5zZXRJc0NhcHR1cmluZyA9IGNvbmZpZy5zZXRJc0NhcHR1cmluZztcbiAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPSBjb25maWcuc2V0UHJvY2Vzc1N0YXR1cztcbiAgICB0aGlzLnNldEN1cnJlbnREb3QgPSBjb25maWcuc2V0Q3VycmVudERvdDtcbiAgICB0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MgPSBjb25maWcudHJpZ2dlckNhbWVyYUFjY2VzcztcbiAgICB0aGlzLm9uU3RhdHVzVXBkYXRlID0gY29uZmlnLm9uU3RhdHVzVXBkYXRlO1xuICAgIHRoaXMuc2F2ZUltYWdlVG9TZXJ2ZXIgPSBjb25maWcuc2F2ZUltYWdlVG9TZXJ2ZXI7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLmNhcHR1cmVDb3VudGVyID0gY29uZmlnLmNhcHR1cmVDb3VudGVyO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBhbmQgdXRpbGl0aWVzIGZyb20gZ2xvYmFsIHNjb3BlIChmcm9tIGFjdGlvbkJ1dHRvbi5qcylcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNNYW5hZ2VyIDogbnVsbDtcbiAgICB0aGlzLmNhbnZhc1V0aWxzID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuY2FudmFzVXRpbHMgOiBudWxsO1xuICAgIFxuICAgIC8vIFN0b3JlIG9yaWdpbmFsIGNhbnZhcyBkaW1lbnNpb25zIGZvciBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uXG4gICAgdGhpcy5vcmlnaW5hbENhbnZhc0RpbWVuc2lvbnMgPSBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICBnZXRDYW52YXMoKSB7XG4gICAgLy8gVXNlIHRoZSBnbG9iYWwgY2FudmFzIG1hbmFnZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzVXRpbHMgZnJvbSBhY3Rpb25CdXR0b24uanNcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5nZXRDYW52YXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc1V0aWxzLmdldENhbnZhcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBjYW52YXNNYW5hZ2VyXG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCB0aGlzLmNhbnZhc01hbmFnZXIuY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGNhbnZhc1JlZiBpZiBjYW52YXNNYW5hZ2VyIG5vdCBhdmFpbGFibGVcbiAgICByZXR1cm4gdGhpcy5jYW52YXNSZWY/LmN1cnJlbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICB9XG5cbiAgLy8gVHJhbnNmb3JtIGNhbnZhcyBjb29yZGluYXRlcyB0byB2aWV3cG9ydCBjb29yZGluYXRlcyB3aGVuIGluIGZ1bGxzY3JlZW5cbiAgdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY2FudmFzLCBwb2ludCkge1xuICAgIGlmICghY2FudmFzIHx8ICFwb2ludCkgcmV0dXJuIHBvaW50O1xuICAgIFxuICAgIC8vIElmIGNhbnZhcyBpcyBpbiBmdWxsc2NyZWVuIG1vZGUsIHdlIG5lZWQgdG8gdHJhbnNmb3JtIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgaXNGdWxsc2NyZWVuID0gdGhpcy5jYW52YXNNYW5hZ2VyPy5pc0luRnVsbHNjcmVlbigpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXNVdGlscz8uaXNGdWxsc2NyZWVuPy4oKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyAmJiBjYW52YXMuc3R5bGUud2lkdGggPT09ICcxMDB2dycpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgY2hlY2s6Jywge1xuICAgICAgY2FudmFzUG9zaXRpb246IGNhbnZhcy5zdHlsZS5wb3NpdGlvbixcbiAgICAgIGNhbnZhc1dpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHQsXG4gICAgICBpc0Z1bGxzY3JlZW4sXG4gICAgICBvcmlnaW5hbFBvaW50OiBwb2ludCxcbiAgICAgIGNhbnZhc1JlY3Q6IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIH0pO1xuICAgIFxuICAgIGlmIChpc0Z1bGxzY3JlZW4pIHtcbiAgICAgIC8vIEdldCB0aGUgY2FudmFzJ3MgYm91bmRpbmcgcmVjdCB0byB1bmRlcnN0YW5kIGl0cyBwb3NpdGlvbiBpbiB0aGUgdmlld3BvcnRcbiAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIGNhbnZhcyBpcyBwcm9wZXJseSBwb3NpdGlvbmVkXG4gICAgICBjb25zdCBpc1Byb3Blcmx5UG9zaXRpb25lZCA9IGNhbnZhc1JlY3QubGVmdCA9PT0gMCAmJiBjYW52YXNSZWN0LnRvcCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc1JlY3Qud2lkdGggPT09IHdpbmRvdy5pbm5lcldpZHRoICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc1JlY3QuaGVpZ2h0ID09PSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgcG9zaXRpb25pbmcgY2hlY2s6Jywge1xuICAgICAgICBjYW52YXNSZWN0LFxuICAgICAgICB3aW5kb3dTaXplOiB7IHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCwgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgfSxcbiAgICAgICAgaXNQcm9wZXJseVBvc2l0aW9uZWRcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIHNjYWxlIGZhY3RvcnNcbiAgICAgIGNvbnN0IHNjYWxlWCA9IGNhbnZhc1JlY3Qud2lkdGggLyBjYW52YXMud2lkdGg7XG4gICAgICBjb25zdCBzY2FsZVkgPSBjYW52YXNSZWN0LmhlaWdodCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICBcbiAgICAgIC8vIFRyYW5zZm9ybSB0aGUgY29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUG9pbnQgPSB7XG4gICAgICAgIHg6IHBvaW50LnggKiBzY2FsZVggKyBjYW52YXNSZWN0LmxlZnQsXG4gICAgICAgIHk6IHBvaW50LnkgKiBzY2FsZVkgKyBjYW52YXNSZWN0LnRvcCxcbiAgICAgICAgbGFiZWw6IHBvaW50LmxhYmVsXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvbjonLCB7XG4gICAgICAgIG9yaWdpbmFsOiBwb2ludCxcbiAgICAgICAgdHJhbnNmb3JtZWQ6IHRyYW5zZm9ybWVkUG9pbnQsXG4gICAgICAgIGNhbnZhc1JlY3QsXG4gICAgICAgIHNjYWxlOiB7IHg6IHNjYWxlWCwgeTogc2NhbGVZIH0sXG4gICAgICAgIGNhbnZhc0RpbWVuc2lvbnM6IHsgd2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0IH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdHJhbnNmb3JtZWRQb2ludDtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgbm90IGZ1bGxzY3JlZW4sIHJldHVybiBvcmlnaW5hbCBjb29yZGluYXRlc1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIC8vIEVudGVyIGZ1bGxzY3JlZW4gdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBlbnRlckZ1bGxzY3JlZW4oKSB7XG4gICAgLy8gVXNlIHRoZSBnbG9iYWwgY2FudmFzIG1hbmFnZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlci5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzVXRpbHMgJiYgdHlwZW9mIHRoaXMuY2FudmFzVXRpbHMuZW50ZXJGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNVdGlscy5lbnRlckZ1bGxzY3JlZW4oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgdGhpcy5jYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbigpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGVudGVyIGZ1bGxzY3JlZW5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIC8vIFN0b3JlIG9yaWdpbmFsIGRpbWVuc2lvbnMgYmVmb3JlIGdvaW5nIGZ1bGxzY3JlZW5cbiAgICAgIHRoaXMub3JpZ2luYWxDYW52YXNEaW1lbnNpb25zID0ge1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIFJlbW92ZSBjYW52YXMgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcbiAgICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBBcHBlbmQgdG8gYm9keSBhbmQgc2V0IGZ1bGxzY3JlZW4gc3R5bGVzXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBcbiAgICAgIC8vIFNldCBmdWxsc2NyZWVuIHN0eWxlcyB3aXRoIHByb3BlciBwb3NpdGlvbmluZ1xuICAgICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xuICAgICAgICB0b3A6IDAgIWltcG9ydGFudDtcbiAgICAgICAgbGVmdDogMCAhaW1wb3J0YW50O1xuICAgICAgICB3aWR0aDogMTAwdncgIWltcG9ydGFudDtcbiAgICAgICAgaGVpZ2h0OiAxMDB2aCAhaW1wb3J0YW50O1xuICAgICAgICB6LWluZGV4OiA5OTk5OSAhaW1wb3J0YW50O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB5ZWxsb3cgIWltcG9ydGFudDtcbiAgICAgICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrICFpbXBvcnRhbnQ7XG4gICAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG8gIWltcG9ydGFudDtcbiAgICAgICAgbWFyZ2luOiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50O1xuICAgICAgICB0cmFuc2Zvcm06IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIGA7XG4gICAgICBcbiAgICAgIC8vIFNldCBjYW52YXMgZGltZW5zaW9ucyB0byBtYXRjaCB2aWV3cG9ydFxuICAgICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgXG4gICAgICAvLyBDbGVhciB3aXRoIHllbGxvdyBiYWNrZ3JvdW5kXG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAneWVsbG93JztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBGb3JjZSBhIHJlZmxvdyB0byBlbnN1cmUgc3R5bGVzIGFyZSBhcHBsaWVkXG4gICAgICBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnQ2FudmFzIGZ1bGxzY3JlZW4gc2V0dXA6Jywge1xuICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICAgIHN0eWxlOiBjYW52YXMuc3R5bGUuY3NzVGV4dCxcbiAgICAgICAgcmVjdDogY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG4gIC8vIEV4aXQgZnVsbHNjcmVlbiB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgIC8vIFVzZSB0aGUgZ2xvYmFsIGNhbnZhcyBtYW5hZ2VyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5nbG9iYWxDYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzVXRpbHMgJiYgdHlwZW9mIHRoaXMuY2FudmFzVXRpbHMuZXhpdEZ1bGxzY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc1V0aWxzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIgJiYgdHlwZW9mIHRoaXMuY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjazogbWFudWFsbHkgZXhpdCBmdWxsc2NyZWVuXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLWNvbnRhaW5lcicpIHx8IFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm1haW4tY29udGVudCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5O1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgY2FudmFzLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICBjYW52YXMuc3R5bGUuekluZGV4ID0gJyc7XG4gICAgICBjYW52YXMuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3llbGxvdyc7XG4gICAgICBcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZGltZW5zaW9ucyBpZiBhdmFpbGFibGVcbiAgICAgIGlmICh0aGlzLm9yaWdpbmFsQ2FudmFzRGltZW5zaW9ucykge1xuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLm9yaWdpbmFsQ2FudmFzRGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IHRoaXMub3JpZ2luYWxDYW52YXNEaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENhbnZhc0RpbWVuc2lvbnMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgLy8gUmVzdG9yZSBlbGVtZW50cyB0aGF0IHdlcmUgaGlkZGVuIGR1cmluZyBmdWxsc2NyZWVuXG4gIHJlc3RvcmVIaWRkZW5FbGVtZW50cygpIHtcbiAgICBjb25zdCBoaWRkZW5FbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWhpZGRlbi1ieS1jYW52YXM9XCJ0cnVlXCJdJyk7XG4gICAgaGlkZGVuRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlkZGVuLWJ5LWNhbnZhcycpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2xlYXIgY2FudmFzIHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgY2xlYXJDYW52YXMoKSB7XG4gICAgLy8gVXNlIHRoZSBnbG9iYWwgY2FudmFzIG1hbmFnZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5jbGVhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jYW52YXNVdGlscy5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLmNhbnZhc01hbmFnZXIuY2xlYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjazogbWFudWFsbHkgY2xlYXIgY2FudmFzXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSAneWVsbG93JztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIERyYXcgZG90IHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgZHJhd0RvdCh4LCB5LCByYWRpdXMgPSAxMikge1xuICAgIC8vIFVzZSB0aGUgZ2xvYmFsIGNhbnZhcyBtYW5hZ2VyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5nbG9iYWxDYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIuZHJhd0RvdCh4LCB5LCByYWRpdXMpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5kcmF3RG90ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNVdGlscy5kcmF3RG90KHgsIHksIHJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBkcmF3IGRvdFxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBkcmF3UmVkRG90KGN0eCwgeCwgeSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2FpdCB1bnRpbCBjYW52YXMgaXMgZnVsbHkgcmVhZHlcbiAgYXN5bmMgd2FpdEZvckNhbnZhcyhtYXhUcmllcyA9IDIwLCBpbnRlcnZhbCA9IDEwMCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VHJpZXM7IGkrKykge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLndpZHRoID4gMCAmJiBjYW52YXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgcmVhZHkgYWZ0ZXIgbXVsdGlwbGUgYXR0ZW1wdHNcIik7XG4gIH1cblxuICAvLyBUZXN0IGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cbiAgdGVzdENvb3JkaW5hdGVUcmFuc2Zvcm1hdGlvbihjYW52YXMpIHtcbiAgICBjb25zb2xlLmxvZygnVGVzdGluZyBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uLi4uJyk7XG4gICAgXG4gICAgY29uc3QgdGVzdFBvaW50ID0geyB4OiAxMDAsIHk6IDEwMCwgbGFiZWw6ICdUZXN0JyB9O1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gdGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyhjYW52YXMsIHRlc3RQb2ludCk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1Rlc3QgdHJhbnNmb3JtYXRpb24gcmVzdWx0OicsIHtcbiAgICAgIG9yaWdpbmFsOiB0ZXN0UG9pbnQsXG4gICAgICB0cmFuc2Zvcm1lZDogdHJhbnNmb3JtZWQsXG4gICAgICBjYW52YXNJbmZvOiB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgICAgIHdpZHRoOiBjYW52YXMuc3R5bGUud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjYW52YXMuc3R5bGUuaGVpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIHJlY3Q6IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcbiAgfVxuXG4gIC8vIEVuc3VyZSBjYW52YXMgaXMgcHJvcGVybHkgcG9zaXRpb25lZCBhbmQgc2l6ZWQgZm9yIGZ1bGxzY3JlZW5cbiAgZW5zdXJlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpIHtcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIFJlbW92ZSBhbnkgY29uZmxpY3RpbmcgZWxlbWVudHMgdGhhdCBtaWdodCBpbnRlcmZlcmVcbiAgICB0aGlzLnJlbW92ZUNvbmZsaWN0aW5nRWxlbWVudHMoKTtcbiAgICBcbiAgICAvLyBFbnN1cmUgY2FudmFzIGlzIGluIGJvZHlcbiAgICBpZiAoY2FudmFzLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSkge1xuICAgICAgICBjYW52YXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjYW52YXMpO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGb3JjZSBjYW52YXMgdG8gY292ZXIgZW50aXJlIHZpZXdwb3J0XG4gICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICBwb3NpdGlvbjogZml4ZWQgIWltcG9ydGFudDtcbiAgICAgIHRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgbGVmdDogMCAhaW1wb3J0YW50O1xuICAgICAgd2lkdGg6IDEwMHZ3ICFpbXBvcnRhbnQ7XG4gICAgICBoZWlnaHQ6IDEwMHZoICFpbXBvcnRhbnQ7XG4gICAgICB6LWluZGV4OiA5OTk5OSAhaW1wb3J0YW50O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGUgIWltcG9ydGFudDtcbiAgICAgIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcbiAgICAgIG9wYWNpdHk6IDEgIWltcG9ydGFudDtcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvICFpbXBvcnRhbnQ7XG4gICAgICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgICAgIHBhZGRpbmc6IDAgIWltcG9ydGFudDtcbiAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcbiAgICAgIHRyYW5zZm9ybTogbm9uZSAhaW1wb3J0YW50O1xuICAgIGA7XG4gICAgXG4gICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gbWF0Y2ggdmlld3BvcnRcbiAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIFxuICAgIC8vIENsZWFyIHdpdGggd2hpdGUgYmFja2dyb3VuZFxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIFxuICAgIC8vIEZvcmNlIHJlZmxvd1xuICAgIGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHBvc2l0aW9uaW5nXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBpc1Byb3Blcmx5UG9zaXRpb25lZCA9IHJlY3QubGVmdCA9PT0gMCAmJiByZWN0LnRvcCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0LndpZHRoID09PSB3aW5kb3cuaW5uZXJXaWR0aCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjdC5oZWlnaHQgPT09IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnQ2FudmFzIGZ1bGxzY3JlZW4gdmVyaWZpY2F0aW9uOicsIHtcbiAgICAgIHJlY3QsXG4gICAgICB3aW5kb3dTaXplOiB7IHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCwgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQgfSxcbiAgICAgIGlzUHJvcGVybHlQb3NpdGlvbmVkLFxuICAgICAgY2FudmFzRGltZW5zaW9uczogeyB3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBpc1Byb3Blcmx5UG9zaXRpb25lZDtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbnkgY29uZmxpY3RpbmcgZWxlbWVudHMgdGhhdCBtaWdodCBpbnRlcmZlcmUgd2l0aCBmdWxsc2NyZWVuIGNhbnZhc1xuICByZW1vdmVDb25mbGljdGluZ0VsZW1lbnRzKCkge1xuICAgIC8vIEhpZGUgYW55IGVsZW1lbnRzIHRoYXQgbWlnaHQgaW50ZXJmZXJlIHdpdGggZnVsbHNjcmVlbiBkaXNwbGF5XG4gICAgY29uc3QgZWxlbWVudHNUb0hpZGUgPSBbXG4gICAgICAnLnRvcGJhcicsXG4gICAgICAnLmNhbnZhcy1jb250YWluZXInLCBcbiAgICAgICcubWFpbi1jb250ZW50JyxcbiAgICAgICcubWV0cmljcy1wYW5lbCcsXG4gICAgICAnLmRpc3BsYXktbWV0cmljcycsXG4gICAgICAnbmF2JyxcbiAgICAgICdoZWFkZXInLFxuICAgICAgJy5idXR0b24tZ3JvdXBzJyxcbiAgICAgICcuY29udHJvbC1idXR0b25zJ1xuICAgIF07XG4gICAgXG4gICAgZWxlbWVudHNUb0hpZGUuZm9yRWFjaChzZWxlY3RvciA9PiB7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgZWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIGlmIChlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS1oaWRkZW4tYnktY2FudmFzJywgJ3RydWUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBNYWluIGZ1bmN0aW9uIHRvIGhhbmRsZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZVxuICBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzdGFydGluZyBjYWxpYnJhdGlvblxuICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICAvLyBTZXQgY2FwdHVyaW5nIHN0YXRlIGlmIGZ1bmN0aW9uIGV4aXN0c1xuICAgIGlmICh0eXBlb2YgdGhpcy5zZXRJc0NhcHR1cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyh0cnVlKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNldFByb2Nlc3NTdGF0dXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVXBkYXRlIHBhcmVudCBjb21wb25lbnQgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMub25TdGF0dXNVcGRhdGUpIHtcbiAgICAgIHRoaXMub25TdGF0dXNVcGRhdGUoe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiAnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nLFxuICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aW1lIHRvIHVwZGF0ZVxuICAgIHNldFRpbWVvdXQoYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gYXdhaXQgdGhpcy53YWl0Rm9yQ2FudmFzKCk7XG4gICAgICAgIGlmICghY2FudmFzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBvcmlnaW5hbCBjYW52YXMgZGltZW5zaW9ucyBiZWZvcmUgZ29pbmcgZnVsbHNjcmVlblxuICAgICAgICB0aGlzLm9yaWdpbmFsQ2FudmFzRGltZW5zaW9ucyA9IHtcbiAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFVzZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW0gdG8gZW50ZXIgZnVsbHNjcmVlblxuICAgICAgICB0aGlzLmVudGVyRnVsbHNjcmVlbigpO1xuXG4gICAgICAgIC8vIEVuc3VyZSBjYW52YXMgaXMgcHJvcGVybHkgcG9zaXRpb25lZCBhbmQgc2l6ZWRcbiAgICAgICAgY29uc3QgaXNQcm9wZXJseVBvc2l0aW9uZWQgPSB0aGlzLmVuc3VyZUNhbnZhc0Z1bGxzY3JlZW4oY2FudmFzKTtcbiAgICAgICAgaWYgKCFpc1Byb3Blcmx5UG9zaXRpb25lZCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignQ2FudmFzIG5vdCBwcm9wZXJseSBwb3NpdGlvbmVkIGZvciBmdWxsc2NyZWVuLCBhdHRlbXB0aW5nIHRvIGZpeC4uLicpO1xuICAgICAgICAgIC8vIFRyeSBvbmUgbW9yZSB0aW1lIGFmdGVyIGEgc2hvcnQgZGVsYXlcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpO1xuICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUZXN0IGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgdGhpcy50ZXN0Q29vcmRpbmF0ZVRyYW5zZm9ybWF0aW9uKGNhbnZhcyk7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzIGJhc2VkIG9uIE9SSUdJTkFMIGNhbnZhcyBzaXplXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHModGhpcy5vcmlnaW5hbENhbnZhc0RpbWVuc2lvbnMud2lkdGgsIHRoaXMub3JpZ2luYWxDYW52YXNEaW1lbnNpb25zLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXBvaW50cyB8fCBwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdlbmVyYXRlIGNhbGlicmF0aW9uIHBvaW50c1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2NhbGlicmF0ZS1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnN0eWxlLmNzc1RleHQgPSBgXG4gICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgIHRvcDogMjBweDtcbiAgICAgICAgICByaWdodDogMjBweDtcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDEwMiwgMjA0LCAwLjkpO1xuICAgICAgICAgIGNvbG9yOiB3aGl0ZTtcbiAgICAgICAgICBmb250LXNpemU6IDE2cHg7XG4gICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgcGFkZGluZzogMTBweCAxNXB4O1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDhweDtcbiAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICBib3gtc2hhZG93OiAwIDRweCAxMnB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgYDtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gJ0NhbGlicmF0aW9uOiBJbml0aWFsaXppbmcuLi4nO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXR1c0luZGljYXRvcik7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBlYWNoIGNhbGlicmF0aW9uIHBvaW50XG4gICAgICAgIGxldCBzdWNjZXNzQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG9yaWdpbmFsUG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGNvb3JkaW5hdGVzIGZvciBmdWxsc2NyZWVuIGRpc3BsYXlcbiAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyhjYW52YXMsIG9yaWdpbmFsUG9pbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgZGlzcGxheXNcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb246IFBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gO1xuICAgICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgUHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYXIgY2FudmFzIHdpdGggd2hpdGUgYmFja2dyb3VuZCB1c2luZyBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnQgdXNpbmcgT1JJR0lOQUwgY29vcmRpbmF0ZXMgKGNhbnZhcyBjb29yZGluYXRlcylcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSAxMjsgLy8gU3RhbmRhcmQgc2l6ZSBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICB0aGlzLmRyYXdEb3Qob3JpZ2luYWxQb2ludC54LCBvcmlnaW5hbFBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBpbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICBjb25zdCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0RvdChvcmlnaW5hbFBvaW50LngsIG9yaWdpbmFsUG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBjdXN0b20gY291bnRkb3duIGVsZW1lbnQgcG9zaXRpb25lZCB1c2luZyBUUkFOU0ZPUk1FRCBjb29yZGluYXRlcyAodmlld3BvcnQgY29vcmRpbmF0ZXMpXG4gICAgICAgICAgY29uc3QgY291bnRkb3duRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQuY2xhc3NOYW1lID0gJ2RvdC1jb3VudGRvd24nO1xuICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICAgIGxlZnQ6ICR7dHJhbnNmb3JtZWRQb2ludC54fXB4O1xuICAgICAgICAgICAgdG9wOiAke3RyYW5zZm9ybWVkUG9pbnQueX1weDtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xuICAgICAgICAgICAgY29sb3I6IHJlZDtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMjRweDtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgdGV4dC1zaGFkb3c6IDAgMCAxMHB4IHdoaXRlLCAwIDAgMjBweCB3aGl0ZTtcbiAgICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAgICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmVkO1xuICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICAgICAgd2lkdGg6IDQ4cHg7XG4gICAgICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICAgICAgYm94LXNoYWRvdzogMCAwIDE1cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgICAgIGA7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEZWJ1ZzogTG9nIHBvc2l0aW9uaW5nIGluZm9ybWF0aW9uXG4gICAgICAgICAgY29uc29sZS5sb2coYFBvaW50ICR7aSsxfSBwb3NpdGlvbmluZzpgLCB7XG4gICAgICAgICAgICBvcmlnaW5hbFBvaW50LFxuICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludCxcbiAgICAgICAgICAgIGNvdW50ZG93blBvc2l0aW9uOiB7XG4gICAgICAgICAgICAgIGxlZnQ6IHRyYW5zZm9ybWVkUG9pbnQueCxcbiAgICAgICAgICAgICAgdG9wOiB0cmFuc2Zvcm1lZFBvaW50LnlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW52YXNJbmZvOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgICAgICAgcmVjdDogY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBQb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofTogQ291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBGb3JjZSByZWRyYXcgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlICh1c2luZyBvcmlnaW5hbCBjb29yZGluYXRlcylcbiAgICAgICAgICAgICAgdGhpcy5kcmF3RG90KG9yaWdpbmFsUG9pbnQueCwgb3JpZ2luYWxQb2ludC55LCByYWRpdXMpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDgwMCkpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gUmVkcmF3IGFnYWluIGhhbGZ3YXkgdGhyb3VnaCB0aGUgd2FpdFxuICAgICAgICAgICAgICB0aGlzLmRyYXdEb3Qob3JpZ2luYWxQb2ludC54LCBvcmlnaW5hbFBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNob3cgY2hlY2ttYXJrXG4gICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnRleHRDb250ZW50ID0gXCLinJNcIjtcbiAgICAgICAgICAgIHRoaXMuZHJhd0RvdChvcmlnaW5hbFBvaW50LngsIG9yaWdpbmFsUG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIGNvdW50ZG93biBlbGVtZW50IGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGRvdCBpcyBzdGlsbCB2aXNpYmxlXG4gICAgICAgICAgICB0aGlzLmRyYXdEb3Qob3JpZ2luYWxQb2ludC54LCBvcmlnaW5hbFBvaW50LnksIHJhZGl1cyk7XG5cbiAgICAgICAgICAgIC8vIENhcHR1cmUgaW1hZ2VzIGF0IHRoaXMgcG9pbnQgKHVzZSBvcmlnaW5hbCBjb29yZGluYXRlcyBmb3IgY2FwdHVyZSlcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYXB0dXJpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9LyR7cG9pbnRzLmxlbmd0aH0gYXQgKCR7b3JpZ2luYWxQb2ludC54fSwgJHtvcmlnaW5hbFBvaW50Lnl9KWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgICBwb2ludDogb3JpZ2luYWxQb2ludCwgLy8gVXNlIG9yaWdpbmFsIGNvb3JkaW5hdGVzIGZvciBjYXB0dXJlXG4gICAgICAgICAgICAgIGNhcHR1cmVDb3VudDogdGhpcy5jYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhaXQgYSBtb21lbnQgYmVmb3JlIGNsZWFyaW5nIHRvIGVuc3VyZSBjYXB0dXJlIGlzIGNvbXBsZXRlXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBkb3QgYWZ0ZXIgY2FwdHVyZSB1c2luZyBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJDYW52YXMoKTtcblxuICAgICAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIHBvaW50c1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEyMDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfTpgLCBlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGNvdW50ZG93biBpZiBpdCBzdGlsbCBleGlzdHNcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDbGVhciByZWRyYXcgaW50ZXJ2YWxcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ2FsaWJyYXRpb24gY29tcGxldGVcbiAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvcikge1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbiBjb21wbGV0ZTogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzYDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGNvbXBsZXRlZDogJHtzdWNjZXNzQ291bnR9LyR7cG9pbnRzLmxlbmd0aH0gcG9pbnRzIGNhcHR1cmVkYCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZW1vdmUgc3RhdHVzIGluZGljYXRvciBhZnRlciBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXR1c0luZGljYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAzMDAwKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQ2FsaWJyYXRpb24gZXJyb3I6XCIsIGVycm9yKTtcbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gRXhpdCBmdWxsc2NyZWVuIGFuZCByZXN0b3JlIGNhbnZhcyB1c2luZyBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgICAgICAgdGhpcy5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVzdG9yZSBoaWRkZW4gZWxlbWVudHNcbiAgICAgICAgdGhpcy5yZXN0b3JlSGlkZGVuRWxlbWVudHMoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGUgdG8gZmFsc2UgaWYgZnVuY3Rpb24gZXhpc3RzXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zZXRJc0NhcHR1cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBTaG93IFRvcEJhciBhZ2FpbiBhZnRlciBhIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgfVxuICAgIH0sIDIwMCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNldENhbGlicmF0ZUFjdGlvbjsgIl0sIm5hbWVzIjpbIlJlYWN0IiwiZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyIsImRyYXdSZWREb3QiLCJydW5Db3VudGRvd24iLCJzaG93Q2FwdHVyZVByZXZpZXciLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsIlNldENhbGlicmF0ZUFjdGlvbiIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwidG9nZ2xlVG9wQmFyIiwid2luZG93Iiwic2V0SXNDYXB0dXJpbmciLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJwcm9jZXNzU3RhdHVzIiwiaXNDYXB0dXJpbmciLCJzZXRUaW1lb3V0IiwiY2FudmFzIiwid2FpdEZvckNhbnZhcyIsIkVycm9yIiwib3JpZ2luYWxDYW52YXNEaW1lbnNpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJlbnRlckZ1bGxzY3JlZW4iLCJpc1Byb3Blcmx5UG9zaXRpb25lZCIsImVuc3VyZUNhbnZhc0Z1bGxzY3JlZW4iLCJjb25zb2xlIiwid2FybiIsInRlc3RDb29yZGluYXRlVHJhbnNmb3JtYXRpb24iLCJwb2ludHMiLCJsZW5ndGgiLCJzdGF0dXNJbmRpY2F0b3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN1Y2Nlc3NDb3VudCIsImkiLCJvcmlnaW5hbFBvaW50IiwidHJhbnNmb3JtZWRQb2ludCIsInRyYW5zZm9ybUNvb3JkaW5hdGVzIiwiY2xlYXJDYW52YXMiLCJyYWRpdXMiLCJkcmF3RG90IiwieCIsInkiLCJyZWRyYXdJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvdW50ZG93bkVsZW1lbnQiLCJsb2ciLCJjb3VudGRvd25Qb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJjYW52YXNJbmZvIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXB0dXJlUmVzdWx0IiwicG9pbnQiLCJjYXB0dXJlQ291bnQiLCJjYXB0dXJlQ291bnRlciIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnRlciIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsImVycm9yIiwiY2xlYXJJbnRlcnZhbCIsIm1lc3NhZ2UiLCJleGl0RnVsbHNjcmVlbiIsInJlc3RvcmVIaWRkZW5FbGVtZW50cyIsInNldEN1cnJlbnREb3QiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJjYW52YXNNYW5hZ2VyIiwiY2FudmFzVXRpbHMiLCJnZXRDYW52YXMiLCJnbG9iYWxDYW52YXNNYW5hZ2VyIiwiY3JlYXRlQ2FudmFzIiwicXVlcnlTZWxlY3RvciIsImlzRnVsbHNjcmVlbiIsImlzSW5GdWxsc2NyZWVuIiwicG9zaXRpb24iLCJjYW52YXNQb3NpdGlvbiIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiY2FudmFzUmVjdCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIndpbmRvd1NpemUiLCJzY2FsZVgiLCJzY2FsZVkiLCJsYWJlbCIsIm9yaWdpbmFsIiwidHJhbnNmb3JtZWQiLCJzY2FsZSIsImNhbnZhc0RpbWVuc2lvbnMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJvZmZzZXRIZWlnaHQiLCJjb250YWluZXIiLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJoaWRkZW5FbGVtZW50cyIsImRpc3BsYXkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJjbGVhciIsImNsZWFyUmVjdCIsIm1heFRyaWVzIiwiaW50ZXJ2YWwiLCJ0ZXN0UG9pbnQiLCJyZW1vdmVDb25mbGljdGluZ0VsZW1lbnRzIiwiZWxlbWVudHNUb0hpZGUiLCJzZWxlY3RvciIsImVsZW1lbnRzIiwic2V0QXR0cmlidXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\n");

/***/ })

};
;