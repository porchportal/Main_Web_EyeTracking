"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_jsx";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_jsx"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx":
/*!*******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.jsx ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CalibratePoints_jsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalibratePoints.jsx */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/CalibratePoints.jsx\");\n/* harmony import */ var _countSave_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countSave.jsx */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/countSave.jsx\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-node)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.jsx\n// Handles the calibration sequence functionality\n\n\n\n\nclass SetCalibrateAction {\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if (false) {}\n            // Set capturing state if function exists\n            if (typeof this.setIsCapturing === 'function') {\n                this.setIsCapturing(true);\n            }\n            if (typeof this.setProcessStatus === 'function') {\n                this.setProcessStatus('Starting calibration sequence...');\n            }\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Store original canvas dimensions before going fullscreen\n                    this.originalCanvasDimensions = {\n                        width: canvas.width,\n                        height: canvas.height\n                    };\n                    // Use canvas management system to enter fullscreen\n                    this.enterFullscreen();\n                    // Ensure canvas is properly positioned and sized\n                    const isProperlyPositioned = this.ensureCanvasFullscreen(canvas);\n                    if (!isProperlyPositioned) {\n                        console.warn('Canvas not properly positioned for fullscreen, attempting to fix...');\n                        // Try one more time after a short delay\n                        setTimeout(()=>{\n                            this.ensureCanvasFullscreen(canvas);\n                        }, 100);\n                    }\n                    // Test coordinate transformation\n                    this.testCoordinateTransformation(canvas);\n                    // Generate calibration points based on ORIGINAL canvas size\n                    const points = (0,_CalibratePoints_jsx__WEBPACK_IMPORTED_MODULE_1__.generateCalibrationPoints)(this.originalCanvasDimensions.width, this.originalCanvasDimensions.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = `\n          position: fixed;\n          top: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          font-size: 16px;\n          font-weight: bold;\n          padding: 10px 15px;\n          border-radius: 8px;\n          z-index: 10000;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n        `;\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const originalPoint = points[i];\n                        // Transform coordinates for fullscreen display\n                        const transformedPoint = this.transformCoordinates(canvas, originalPoint);\n                        // Update status displays\n                        statusIndicator.textContent = `Calibration: Point ${i + 1}/${points.length}`;\n                        this.setProcessStatus(`Processing calibration point ${i + 1}/${points.length}`);\n                        // Clear canvas with white background using canvas management system\n                        this.clearCanvas();\n                        // Draw the calibration point using ORIGINAL coordinates (canvas coordinates)\n                        const radius = 12; // Standard size for consistency\n                        this.drawDot(originalPoint.x, originalPoint.y, radius);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            this.drawDot(originalPoint.x, originalPoint.y, radius);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element positioned using TRANSFORMED coordinates (viewport coordinates)\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = `\n            position: fixed;\n            left: ${transformedPoint.x}px;\n            top: ${transformedPoint.y}px;\n            transform: translate(-50%, -50%);\n            color: red;\n            font-size: 24px;\n            font-weight: bold;\n            text-shadow: 0 0 10px white, 0 0 20px white;\n            z-index: 10000;\n            background-color: rgba(255, 255, 255, 0.9);\n            border: 2px solid red;\n            border-radius: 50%;\n            width: 48px;\n            height: 48px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);\n          `;\n                        document.body.appendChild(countdownElement);\n                        // Debug: Log positioning information\n                        console.log(`Point ${i + 1} positioning:`, {\n                            originalPoint,\n                            transformedPoint,\n                            countdownPosition: {\n                                left: transformedPoint.x,\n                                top: transformedPoint.y\n                            },\n                            canvasInfo: {\n                                width: canvas.width,\n                                height: canvas.height,\n                                rect: canvas.getBoundingClientRect()\n                            }\n                        });\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(`Point ${i + 1}/${points.length}: Countdown ${count}`);\n                                // Force redraw to ensure dot stays visible (using original coordinates)\n                                this.drawDot(originalPoint.x, originalPoint.y, radius);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                this.drawDot(originalPoint.x, originalPoint.y, radius);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"✓\";\n                            this.drawDot(originalPoint.x, originalPoint.y, radius);\n                            // Remove countdown element immediately\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Make sure dot is still visible\n                            this.drawDot(originalPoint.x, originalPoint.y, radius);\n                            // Capture images at this point (use original coordinates for capture)\n                            console.log(`Capturing calibration point ${i + 1}/${points.length} at (${originalPoint.x}, ${originalPoint.y})`);\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_3__.captureImagesAtPoint)({\n                                point: originalPoint,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave_jsx__WEBPACK_IMPORTED_MODULE_2__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait a moment before clearing to ensure capture is complete\n                            await new Promise((resolve)=>setTimeout(resolve, 500));\n                            // Clear the dot after capture using canvas management system\n                            this.clearCanvas();\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(`Error processing calibration point ${i + 1}:`, error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = `Calibration complete: ${successCount}/${points.length} points`;\n                    }\n                    this.setProcessStatus(`Calibration completed: ${successCount}/${points.length} points captured`);\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(`Calibration error: ${error.message}`);\n                } finally{\n                    // Exit fullscreen and restore canvas using canvas management system\n                    this.exitFullscreen();\n                    // Restore hidden elements\n                    this.restoreHiddenElements();\n                    // Set capturing state to false if function exists\n                    if (typeof this.setIsCapturing === 'function') {\n                        this.setIsCapturing(false);\n                    }\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if (false) {}\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager and utilities from global scope (from actionButton.js)\n        this.canvasManager =  false ? 0 : null;\n        this.canvasUtils =  false ? 0 : null;\n        // Store original canvas dimensions for coordinate transformation\n        this.originalCanvasDimensions = null;\n    }\n    // Get or create canvas using the canvas management system from actionButton.js\n    getCanvas() {\n        // Use the global canvas manager\n        if (false) {}\n        // Fallback to canvasUtils from actionButton.js\n        if (this.canvasUtils && typeof this.canvasUtils.getCanvas === 'function') {\n            return this.canvasUtils.getCanvas();\n        }\n        // Fallback to canvasManager\n        if (this.canvasManager && typeof this.canvasManager.getCanvas === 'function') {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return this.canvasRef?.current || document.querySelector('#tracking-canvas');\n    }\n    // Transform canvas coordinates to viewport coordinates when in fullscreen\n    transformCoordinates(canvas, point) {\n        if (!canvas || !point) return point;\n        // If canvas is in fullscreen mode, we need to transform coordinates\n        const isFullscreen = this.canvasManager?.isInFullscreen() || this.canvasUtils?.isFullscreen?.() || canvas.style.position === 'fixed' && canvas.style.width === '100vw';\n        console.log('Transform coordinates check:', {\n            canvasPosition: canvas.style.position,\n            canvasWidth: canvas.style.width,\n            canvasHeight: canvas.style.height,\n            isFullscreen,\n            originalPoint: point,\n            canvasRect: canvas.getBoundingClientRect()\n        });\n        if (isFullscreen) {\n            // Get the canvas's bounding rect to understand its position in the viewport\n            const canvasRect = canvas.getBoundingClientRect();\n            // Check if canvas is properly positioned\n            const isProperlyPositioned = canvasRect.left === 0 && canvasRect.top === 0 && canvasRect.width === window.innerWidth && canvasRect.height === window.innerHeight;\n            console.log('Canvas positioning check:', {\n                canvasRect,\n                windowSize: {\n                    width: window.innerWidth,\n                    height: window.innerHeight\n                },\n                isProperlyPositioned\n            });\n            // Calculate the scale factors\n            const scaleX = canvasRect.width / canvas.width;\n            const scaleY = canvasRect.height / canvas.height;\n            // Transform the coordinates\n            const transformedPoint = {\n                x: point.x * scaleX + canvasRect.left,\n                y: point.y * scaleY + canvasRect.top,\n                label: point.label\n            };\n            console.log('Coordinate transformation:', {\n                original: point,\n                transformed: transformedPoint,\n                canvasRect,\n                scale: {\n                    x: scaleX,\n                    y: scaleY\n                },\n                canvasDimensions: {\n                    width: canvas.width,\n                    height: canvas.height\n                }\n            });\n            return transformedPoint;\n        }\n        // If not fullscreen, return original coordinates\n        return point;\n    }\n    // Enter fullscreen using the canvas management system\n    enterFullscreen() {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.enterFullscreen === 'function') {\n            return this.canvasUtils.enterFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.enterFullscreen === 'function') {\n            this.canvasManager.enterFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually enter fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            // Store original dimensions before going fullscreen\n            this.originalCanvasDimensions = {\n                width: canvas.width,\n                height: canvas.height\n            };\n            // Remove canvas from its current parent\n            if (canvas.parentNode) {\n                canvas.parentNode.removeChild(canvas);\n            }\n            // Append to body and set fullscreen styles\n            document.body.appendChild(canvas);\n            // Set fullscreen styles with proper positioning\n            canvas.style.cssText = `\n        position: fixed !important;\n        top: 0 !important;\n        left: 0 !important;\n        width: 100vw !important;\n        height: 100vh !important;\n        z-index: 99999 !important;\n        background-color: yellow !important;\n        border: none !important;\n        display: block !important;\n        opacity: 1 !important;\n        pointer-events: auto !important;\n        margin: 0 !important;\n        padding: 0 !important;\n        box-sizing: border-box !important;\n        transform: none !important;\n      `;\n            // Set canvas dimensions to match viewport\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n            // Clear with yellow background\n            const ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'yellow';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            // Force a reflow to ensure styles are applied\n            canvas.offsetHeight;\n            console.log('Canvas fullscreen setup:', {\n                width: canvas.width,\n                height: canvas.height,\n                style: canvas.style.cssText,\n                rect: canvas.getBoundingClientRect()\n            });\n        }\n        return canvas;\n    }\n    // Exit fullscreen using the canvas management system\n    exitFullscreen() {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.exitFullscreen === 'function') {\n            return this.canvasUtils.exitFullscreen();\n        }\n        if (this.canvasManager && typeof this.canvasManager.exitFullscreen === 'function') {\n            this.canvasManager.exitFullscreen();\n            return this.canvasManager.getCanvas();\n        }\n        // Fallback: manually exit fullscreen\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const container = document.querySelector('.canvas-container') || document.querySelector('.main-content') || document.body;\n            container.appendChild(canvas);\n            canvas.style.position = 'relative';\n            canvas.style.top = '';\n            canvas.style.left = '';\n            canvas.style.width = '100%';\n            canvas.style.height = '100%';\n            canvas.style.zIndex = '';\n            canvas.style.backgroundColor = 'yellow';\n            // Restore original dimensions if available\n            if (this.originalCanvasDimensions) {\n                canvas.width = this.originalCanvasDimensions.width;\n                canvas.height = this.originalCanvasDimensions.height;\n                this.originalCanvasDimensions = null;\n            }\n        }\n        return canvas;\n    }\n    // Restore elements that were hidden during fullscreen\n    restoreHiddenElements() {\n        const hiddenElements = document.querySelectorAll('[data-hidden-by-canvas=\"true\"]');\n        hiddenElements.forEach((el)=>{\n            el.style.display = '';\n            el.removeAttribute('data-hidden-by-canvas');\n        });\n    }\n    // Clear canvas using the canvas management system\n    clearCanvas() {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.clear === 'function') {\n            this.canvasUtils.clear();\n            return;\n        }\n        if (this.canvasManager && typeof this.canvasManager.clear === 'function') {\n            this.canvasManager.clear();\n            return;\n        }\n        // Fallback: manually clear canvas\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'yellow';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n        }\n    }\n    // Draw dot using the canvas management system\n    drawDot(x, y, radius = 12) {\n        // Use the global canvas manager\n        if (false) {}\n        if (this.canvasUtils && typeof this.canvasUtils.drawDot === 'function') {\n            return this.canvasUtils.drawDot(x, y, radius);\n        }\n        // Fallback: manually draw dot\n        const canvas = this.getCanvas();\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            (0,_countSave_jsx__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, x, y, radius, false);\n            return true;\n        }\n        return false;\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas(maxTries = 20, interval = 100) {\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n    // Test coordinate transformation\n    testCoordinateTransformation(canvas) {\n        console.log('Testing coordinate transformation...');\n        const testPoint = {\n            x: 100,\n            y: 100,\n            label: 'Test'\n        };\n        const transformed = this.transformCoordinates(canvas, testPoint);\n        console.log('Test transformation result:', {\n            original: testPoint,\n            transformed: transformed,\n            canvasInfo: {\n                width: canvas.width,\n                height: canvas.height,\n                style: {\n                    position: canvas.style.position,\n                    width: canvas.style.width,\n                    height: canvas.style.height\n                },\n                rect: canvas.getBoundingClientRect()\n            }\n        });\n        return transformed;\n    }\n    // Ensure canvas is properly positioned and sized for fullscreen\n    ensureCanvasFullscreen(canvas) {\n        if (!canvas) return false;\n        // Remove any conflicting elements that might interfere\n        this.removeConflictingElements();\n        // Ensure canvas is in body\n        if (canvas.parentNode !== document.body) {\n            if (canvas.parentNode) {\n                canvas.parentNode.removeChild(canvas);\n            }\n            document.body.appendChild(canvas);\n        }\n        // Force canvas to cover entire viewport\n        canvas.style.cssText = `\n      position: fixed !important;\n      top: 0 !important;\n      left: 0 !important;\n      width: 100vw !important;\n      height: 100vh !important;\n      z-index: 99999 !important;\n      background-color: white !important;\n      border: none !important;\n      display: block !important;\n      opacity: 1 !important;\n      pointer-events: auto !important;\n      margin: 0 !important;\n      padding: 0 !important;\n      box-sizing: border-box !important;\n      transform: none !important;\n    `;\n        // Set dimensions to match viewport\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        // Clear with white background\n        const ctx = canvas.getContext('2d');\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // Force reflow\n        canvas.offsetHeight;\n        // Verify positioning\n        const rect = canvas.getBoundingClientRect();\n        const isProperlyPositioned = rect.left === 0 && rect.top === 0 && rect.width === window.innerWidth && rect.height === window.innerHeight;\n        console.log('Canvas fullscreen verification:', {\n            rect,\n            windowSize: {\n                width: window.innerWidth,\n                height: window.innerHeight\n            },\n            isProperlyPositioned,\n            canvasDimensions: {\n                width: canvas.width,\n                height: canvas.height\n            }\n        });\n        return isProperlyPositioned;\n    }\n    // Remove any conflicting elements that might interfere with fullscreen canvas\n    removeConflictingElements() {\n        // Hide any elements that might interfere with fullscreen display\n        const elementsToHide = [\n            '.topbar',\n            '.canvas-container',\n            '.main-content',\n            '.metrics-panel',\n            '.display-metrics',\n            'nav',\n            'header',\n            '.button-groups',\n            '.control-buttons'\n        ];\n        elementsToHide.forEach((selector)=>{\n            const elements = document.querySelectorAll(selector);\n            elements.forEach((el)=>{\n                if (el.style.display !== 'none') {\n                    el.style.display = 'none';\n                    el.setAttribute('data-hidden-by-canvas', 'true');\n                }\n            });\n        });\n        // Remove any existing countdown elements\n        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n        existingCountdowns.forEach((el)=>{\n            if (el.parentNode) el.parentNode.removeChild(el);\n        });\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaURBQWlEO0FBRXZCO0FBQ3dDO0FBQ2E7QUFDckI7QUFFMUQsTUFBTU07SUFDSixZQUFZQyxNQUFNLENBQUU7UUFvWnBCLCtDQUErQzthQUMvQ0MscUJBQXFCO1lBQ25CLDhDQUE4QztZQUM5QyxJQUFJLE9BQU8sSUFBSSxDQUFDQyxZQUFZLEtBQUssWUFBWTtnQkFDM0MsSUFBSSxDQUFDQSxZQUFZLENBQUM7WUFDcEIsT0FBTyxJQUFJLEtBQW9ELEVBQUUsRUFFaEU7WUFFRCx5Q0FBeUM7WUFDekMsSUFBSSxPQUFPLElBQUksQ0FBQ0UsY0FBYyxLQUFLLFlBQVk7Z0JBQzdDLElBQUksQ0FBQ0EsY0FBYyxDQUFDO1lBQ3RCO1lBRUEsSUFBSSxPQUFPLElBQUksQ0FBQ0MsZ0JBQWdCLEtBQUssWUFBWTtnQkFDL0MsSUFBSSxDQUFDQSxnQkFBZ0IsQ0FBQztZQUN4QjtZQUVBLHVDQUF1QztZQUN2QyxJQUFJLElBQUksQ0FBQ0MsY0FBYyxFQUFFO2dCQUN2QixJQUFJLENBQUNBLGNBQWMsQ0FBQztvQkFDbEJDLGVBQWU7b0JBQ2ZDLGFBQWE7Z0JBQ2Y7WUFDRjtZQUVBLG9DQUFvQztZQUNwQ0MsV0FBVztnQkFDVCxJQUFJO29CQUNGLE1BQU1DLFNBQVMsTUFBTSxJQUFJLENBQUNDLGFBQWE7b0JBQ3ZDLElBQUksQ0FBQ0QsUUFBUTt3QkFDWCxNQUFNLElBQUlFLE1BQU07b0JBQ2xCO29CQUVBLDJEQUEyRDtvQkFDM0QsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRzt3QkFDOUJDLE9BQU9KLE9BQU9JLEtBQUs7d0JBQ25CQyxRQUFRTCxPQUFPSyxNQUFNO29CQUN2QjtvQkFFQSxtREFBbUQ7b0JBQ25ELElBQUksQ0FBQ0MsZUFBZTtvQkFFcEIs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QjtZQUNyQjtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7WUFDQTtZQUNBO1lBQ0E7U0FDRDtRQUVEQSxlQUFlekUsT0FBTyxDQUFDMEUsQ0FBQUE7WUFDckIsTUFBTUMsV0FBV2pHLFNBQVNxQixnQkFBZ0IsQ0FBQzJFO1lBQzNDQyxTQUFTM0UsT0FBTyxDQUFDQyxDQUFBQTtnQkFDZixJQUFJQSxHQUFHcEIsS0FBSyxDQUFDb0YsT0FBTyxLQUFLLFFBQVE7b0JBQy9CaEUsR0FBR3BCLEtBQUssQ0FBQ29GLE9BQU8sR0FBRztvQkFDbkJoRSxHQUFHMkUsWUFBWSxDQUFDLHlCQUF5QjtnQkFDM0M7WUFDRjtRQUNGO1FBRUEseUNBQXlDO1FBQ3pDLE1BQU05RSxxQkFBcUJwQixTQUFTcUIsZ0JBQWdCLENBQUM7UUFDckRELG1CQUFtQkUsT0FBTyxDQUFDQyxDQUFBQTtZQUN6QixJQUFJQSxHQUFHQyxVQUFVLEVBQUVELEdBQUdDLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDRjtRQUMvQztJQUNGO0FBaVFGO0FBRUEsaUVBQWVqRCxrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIi9hcHAvY29tcG9uZW50cy9jb2xsZWN0ZWQtZGF0YXNldC1jdXN0b21pemVkL0FjdGlvbi9TZXRDYWxpYnJhdGVBY3Rpb24uanN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNldENhbGlicmF0ZUFjdGlvbi5qc3hcbi8vIEhhbmRsZXMgdGhlIGNhbGlicmF0aW9uIHNlcXVlbmNlIGZ1bmN0aW9uYWxpdHlcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdlbmVyYXRlQ2FsaWJyYXRpb25Qb2ludHMgfSBmcm9tICcuL0NhbGlicmF0ZVBvaW50cy5qc3gnO1xuaW1wb3J0IHsgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSBmcm9tICcuL2NvdW50U2F2ZS5qc3gnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi9IZWxwZXIvc2F2ZWZpbGUnO1xuXG5jbGFzcyBTZXRDYWxpYnJhdGVBY3Rpb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvLyBSZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMudG9nZ2xlVG9wQmFyID0gY29uZmlnLnRvZ2dsZVRvcEJhcjtcbiAgICB0aGlzLnNldElzQ2FwdHVyaW5nID0gY29uZmlnLnNldElzQ2FwdHVyaW5nO1xuICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyA9IGNvbmZpZy5zZXRQcm9jZXNzU3RhdHVzO1xuICAgIHRoaXMuc2V0Q3VycmVudERvdCA9IGNvbmZpZy5zZXRDdXJyZW50RG90O1xuICAgIHRoaXMudHJpZ2dlckNhbWVyYUFjY2VzcyA9IGNvbmZpZy50cmlnZ2VyQ2FtZXJhQWNjZXNzO1xuICAgIHRoaXMub25TdGF0dXNVcGRhdGUgPSBjb25maWcub25TdGF0dXNVcGRhdGU7XG4gICAgdGhpcy5zYXZlSW1hZ2VUb1NlcnZlciA9IGNvbmZpZy5zYXZlSW1hZ2VUb1NlcnZlcjtcbiAgICB0aGlzLnNldENhcHR1cmVDb3VudGVyID0gY29uZmlnLnNldENhcHR1cmVDb3VudGVyO1xuICAgIHRoaXMuY2FwdHVyZUNvdW50ZXIgPSBjb25maWcuY2FwdHVyZUNvdW50ZXI7XG4gICAgXG4gICAgLy8gR2V0IGNhbnZhcyBtYW5hZ2VyIGFuZCB1dGlsaXRpZXMgZnJvbSBnbG9iYWwgc2NvcGUgKGZyb20gYWN0aW9uQnV0dG9uLmpzKVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICAgIHRoaXMuY2FudmFzVXRpbHMgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNVdGlscyA6IG51bGw7XG4gICAgXG4gICAgLy8gU3RvcmUgb3JpZ2luYWwgY2FudmFzIGRpbWVuc2lvbnMgZm9yIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cbiAgICB0aGlzLm9yaWdpbmFsQ2FudmFzRGltZW5zaW9ucyA9IG51bGw7XG4gIH1cblxuICAvLyBHZXQgb3IgY3JlYXRlIGNhbnZhcyB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtIGZyb20gYWN0aW9uQnV0dG9uLmpzXG4gIGdldENhbnZhcygpIHtcbiAgICAvLyBVc2UgdGhlIGdsb2JhbCBjYW52YXMgbWFuYWdlclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlcikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5nbG9iYWxDYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBjYW52YXNVdGlscyBmcm9tIGFjdGlvbkJ1dHRvbi5qc1xuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmdldENhbnZhcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVXRpbHMuZ2V0Q2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGNhbnZhc01hbmFnZXJcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBUcmFuc2Zvcm0gY2FudmFzIGNvb3JkaW5hdGVzIHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIHdoZW4gaW4gZnVsbHNjcmVlblxuICB0cmFuc2Zvcm1Db29yZGluYXRlcyhjYW52YXMsIHBvaW50KSB7XG4gICAgaWYgKCFjYW52YXMgfHwgIXBvaW50KSByZXR1cm4gcG9pbnQ7XG4gICAgXG4gICAgLy8gSWYgY2FudmFzIGlzIGluIGZ1bGxzY3JlZW4gbW9kZSwgd2UgbmVlZCB0byB0cmFuc2Zvcm0gY29vcmRpbmF0ZXNcbiAgICBjb25zdCBpc0Z1bGxzY3JlZW4gPSB0aGlzLmNhbnZhc01hbmFnZXI/LmlzSW5GdWxsc2NyZWVuKCkgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1V0aWxzPy5pc0Z1bGxzY3JlZW4/LigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY2FudmFzLnN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnICYmIGNhbnZhcy5zdHlsZS53aWR0aCA9PT0gJzEwMHZ3Jyk7XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1RyYW5zZm9ybSBjb29yZGluYXRlcyBjaGVjazonLCB7XG4gICAgICBjYW52YXNQb3NpdGlvbjogY2FudmFzLnN0eWxlLnBvc2l0aW9uLFxuICAgICAgY2FudmFzV2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgIGNhbnZhc0hlaWdodDogY2FudmFzLnN0eWxlLmhlaWdodCxcbiAgICAgIGlzRnVsbHNjcmVlbixcbiAgICAgIG9yaWdpbmFsUG9pbnQ6IHBvaW50LFxuICAgICAgY2FudmFzUmVjdDogY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgfSk7XG4gICAgXG4gICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgLy8gR2V0IHRoZSBjYW52YXMncyBib3VuZGluZyByZWN0IHRvIHVuZGVyc3RhbmQgaXRzIHBvc2l0aW9uIGluIHRoZSB2aWV3cG9ydFxuICAgICAgY29uc3QgY2FudmFzUmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgaWYgY2FudmFzIGlzIHByb3Blcmx5IHBvc2l0aW9uZWRcbiAgICAgIGNvbnN0IGlzUHJvcGVybHlQb3NpdGlvbmVkID0gY2FudmFzUmVjdC5sZWZ0ID09PSAwICYmIGNhbnZhc1JlY3QudG9wID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVjdC53aWR0aCA9PT0gd2luZG93LmlubmVyV2lkdGggJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzUmVjdC5oZWlnaHQgPT09IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ0NhbnZhcyBwb3NpdGlvbmluZyBjaGVjazonLCB7XG4gICAgICAgIGNhbnZhc1JlY3QsXG4gICAgICAgIHdpbmRvd1NpemU6IHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9LFxuICAgICAgICBpc1Byb3Blcmx5UG9zaXRpb25lZFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yc1xuICAgICAgY29uc3Qgc2NhbGVYID0gY2FudmFzUmVjdC53aWR0aCAvIGNhbnZhcy53aWR0aDtcbiAgICAgIGNvbnN0IHNjYWxlWSA9IGNhbnZhc1JlY3QuaGVpZ2h0IC8gY2FudmFzLmhlaWdodDtcbiAgICAgIFxuICAgICAgLy8gVHJhbnNmb3JtIHRoZSBjb29yZGluYXRlc1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQb2ludCA9IHtcbiAgICAgICAgeDogcG9pbnQueCAqIHNjYWxlWCArIGNhbnZhc1JlY3QubGVmdCxcbiAgICAgICAgeTogcG9pbnQueSAqIHNjYWxlWSArIGNhbnZhc1JlY3QudG9wLFxuICAgICAgICBsYWJlbDogcG9pbnQubGFiZWxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdDb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uOicsIHtcbiAgICAgICAgb3JpZ2luYWw6IHBvaW50LFxuICAgICAgICB0cmFuc2Zvcm1lZDogdHJhbnNmb3JtZWRQb2ludCxcbiAgICAgICAgY2FudmFzUmVjdCxcbiAgICAgICAgc2NhbGU6IHsgeDogc2NhbGVYLCB5OiBzY2FsZVkgfSxcbiAgICAgICAgY2FudmFzRGltZW5zaW9uczogeyB3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZFBvaW50O1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBub3QgZnVsbHNjcmVlbiwgcmV0dXJuIG9yaWdpbmFsIGNvb3JkaW5hdGVzXG4gICAgcmV0dXJuIHBvaW50O1xuICB9XG5cbiAgLy8gRW50ZXIgZnVsbHNjcmVlbiB1c2luZyB0aGUgY2FudmFzIG1hbmFnZW1lbnQgc3lzdGVtXG4gIGVudGVyRnVsbHNjcmVlbigpIHtcbiAgICAvLyBVc2UgdGhlIGdsb2JhbCBjYW52YXMgbWFuYWdlclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlcikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5nbG9iYWxDYW52YXNNYW5hZ2VyLmVudGVyRnVsbHNjcmVlbigpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5lbnRlckZ1bGxzY3JlZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc1V0aWxzLmVudGVyRnVsbHNjcmVlbigpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyICYmIHR5cGVvZiB0aGlzLmNhbnZhc01hbmFnZXIuZW50ZXJGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZW50ZXJGdWxsc2NyZWVuKCk7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpO1xuICAgIH1cbiAgICBcbiAgICAvLyBGYWxsYmFjazogbWFudWFsbHkgZW50ZXIgZnVsbHNjcmVlblxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgaWYgKGNhbnZhcykge1xuICAgICAgLy8gU3RvcmUgb3JpZ2luYWwgZGltZW5zaW9ucyBiZWZvcmUgZ29pbmcgZnVsbHNjcmVlblxuICAgICAgdGhpcy5vcmlnaW5hbENhbnZhc0RpbWVuc2lvbnMgPSB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gUmVtb3ZlIGNhbnZhcyBmcm9tIGl0cyBjdXJyZW50IHBhcmVudFxuICAgICAgaWYgKGNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEFwcGVuZCB0byBib2R5IGFuZCBzZXQgZnVsbHNjcmVlbiBzdHlsZXNcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIFxuICAgICAgLy8gU2V0IGZ1bGxzY3JlZW4gc3R5bGVzIHdpdGggcHJvcGVyIHBvc2l0aW9uaW5nXG4gICAgICBjYW52YXMuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgcG9zaXRpb246IGZpeGVkICFpbXBvcnRhbnQ7XG4gICAgICAgIHRvcDogMCAhaW1wb3J0YW50O1xuICAgICAgICBsZWZ0OiAwICFpbXBvcnRhbnQ7XG4gICAgICAgIHdpZHRoOiAxMDB2dyAhaW1wb3J0YW50O1xuICAgICAgICBoZWlnaHQ6IDEwMHZoICFpbXBvcnRhbnQ7XG4gICAgICAgIHotaW5kZXg6IDk5OTk5ICFpbXBvcnRhbnQ7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHllbGxvdyAhaW1wb3J0YW50O1xuICAgICAgICBib3JkZXI6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgICAgZGlzcGxheTogYmxvY2sgIWltcG9ydGFudDtcbiAgICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0byAhaW1wb3J0YW50O1xuICAgICAgICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgICAgICAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94ICFpbXBvcnRhbnQ7XG4gICAgICAgIHRyYW5zZm9ybTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgYDtcbiAgICAgIFxuICAgICAgLy8gU2V0IGNhbnZhcyBkaW1lbnNpb25zIHRvIG1hdGNoIHZpZXdwb3J0XG4gICAgICBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgICBcbiAgICAgIC8vIENsZWFyIHdpdGggeWVsbG93IGJhY2tncm91bmRcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd5ZWxsb3cnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICBcbiAgICAgIC8vIEZvcmNlIGEgcmVmbG93IHRvIGVuc3VyZSBzdHlsZXMgYXJlIGFwcGxpZWRcbiAgICAgIGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZnVsbHNjcmVlbiBzZXR1cDonLCB7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodCxcbiAgICAgICAgc3R5bGU6IGNhbnZhcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgICByZWN0OiBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgLy8gRXhpdCBmdWxsc2NyZWVuIHVzaW5nIHRoZSBjYW52YXMgbWFuYWdlbWVudCBzeXN0ZW1cbiAgZXhpdEZ1bGxzY3JlZW4oKSB7XG4gICAgLy8gVXNlIHRoZSBnbG9iYWwgY2FudmFzIG1hbmFnZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodGhpcy5jYW52YXNVdGlscyAmJiB0eXBlb2YgdGhpcy5jYW52YXNVdGlscy5leGl0RnVsbHNjcmVlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzVXRpbHMuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlciAmJiB0eXBlb2YgdGhpcy5jYW52YXNNYW5hZ2VyLmV4aXRGdWxsc2NyZWVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc01hbmFnZXIuZ2V0Q2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBleGl0IGZ1bGxzY3JlZW5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtY29udGFpbmVyJykgfHwgXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFpbi1jb250ZW50JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHk7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICBjYW52YXMuc3R5bGUudG9wID0gJyc7XG4gICAgICBjYW52YXMuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIGNhbnZhcy5zdHlsZS56SW5kZXggPSAnJztcbiAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAneWVsbG93JztcbiAgICAgIFxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBkaW1lbnNpb25zIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHRoaXMub3JpZ2luYWxDYW52YXNEaW1lbnNpb25zKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMub3JpZ2luYWxDYW52YXNEaW1lbnNpb25zLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5vcmlnaW5hbENhbnZhc0RpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB0aGlzLm9yaWdpbmFsQ2FudmFzRGltZW5zaW9ucyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG4gIH1cblxuICAvLyBSZXN0b3JlIGVsZW1lbnRzIHRoYXQgd2VyZSBoaWRkZW4gZHVyaW5nIGZ1bGxzY3JlZW5cbiAgcmVzdG9yZUhpZGRlbkVsZW1lbnRzKCkge1xuICAgIGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtaGlkZGVuLWJ5LWNhbnZhcz1cInRydWVcIl0nKTtcbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1oaWRkZW4tYnktY2FudmFzJyk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBDbGVhciBjYW52YXMgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBjbGVhckNhbnZhcygpIHtcbiAgICAvLyBVc2UgdGhlIGdsb2JhbCBjYW52YXMgbWFuYWdlclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlcikge1xuICAgICAgcmV0dXJuIHdpbmRvdy5nbG9iYWxDYW52YXNNYW5hZ2VyLmNsZWFyKCk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmNsZWFyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNhbnZhc1V0aWxzLmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIgJiYgdHlwZW9mIHRoaXMuY2FudmFzTWFuYWdlci5jbGVhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmNsZWFyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrOiBtYW51YWxseSBjbGVhciBjYW52YXNcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICd5ZWxsb3cnO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRHJhdyBkb3QgdXNpbmcgdGhlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICBkcmF3RG90KHgsIHksIHJhZGl1cyA9IDEyKSB7XG4gICAgLy8gVXNlIHRoZSBnbG9iYWwgY2FudmFzIG1hbmFnZXJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmdsb2JhbENhbnZhc01hbmFnZXIpIHtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2xvYmFsQ2FudmFzTWFuYWdlci5kcmF3RG90KHgsIHksIHJhZGl1cyk7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmNhbnZhc1V0aWxzICYmIHR5cGVvZiB0aGlzLmNhbnZhc1V0aWxzLmRyYXdEb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhc1V0aWxzLmRyYXdEb3QoeCwgeSwgcmFkaXVzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2s6IG1hbnVhbGx5IGRyYXcgZG90XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGRyYXdSZWREb3QoY3R4LCB4LCB5LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBXYWl0IHVudGlsIGNhbnZhcyBpcyBmdWxseSByZWFkeVxuICBhc3luYyB3YWl0Rm9yQ2FudmFzKG1heFRyaWVzID0gMjAsIGludGVydmFsID0gMTAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmllczsgaSsrKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMud2lkdGggPiAwICYmIGNhbnZhcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCByZWFkeSBhZnRlciBtdWx0aXBsZSBhdHRlbXB0c1wiKTtcbiAgfVxuXG4gIC8vIFRlc3QgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxuICB0ZXN0Q29vcmRpbmF0ZVRyYW5zZm9ybWF0aW9uKGNhbnZhcykge1xuICAgIGNvbnNvbGUubG9nKCdUZXN0aW5nIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb24uLi4nKTtcbiAgICBcbiAgICBjb25zdCB0ZXN0UG9pbnQgPSB7IHg6IDEwMCwgeTogMTAwLCBsYWJlbDogJ1Rlc3QnIH07XG4gICAgY29uc3QgdHJhbnNmb3JtZWQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGNhbnZhcywgdGVzdFBvaW50KTtcbiAgICBcbiAgICBjb25zb2xlLmxvZygnVGVzdCB0cmFuc2Zvcm1hdGlvbiByZXN1bHQ6Jywge1xuICAgICAgb3JpZ2luYWw6IHRlc3RQb2ludCxcbiAgICAgIHRyYW5zZm9ybWVkOiB0cmFuc2Zvcm1lZCxcbiAgICAgIGNhbnZhc0luZm86IHtcbiAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiBjYW52YXMuc3R5bGUucG9zaXRpb24sXG4gICAgICAgICAgd2lkdGg6IGNhbnZhcy5zdHlsZS53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5zdHlsZS5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgcmVjdDogY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkO1xuICB9XG5cbiAgLy8gRW5zdXJlIGNhbnZhcyBpcyBwcm9wZXJseSBwb3NpdGlvbmVkIGFuZCBzaXplZCBmb3IgZnVsbHNjcmVlblxuICBlbnN1cmVDYW52YXNGdWxsc2NyZWVuKGNhbnZhcykge1xuICAgIGlmICghY2FudmFzKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gUmVtb3ZlIGFueSBjb25mbGljdGluZyBlbGVtZW50cyB0aGF0IG1pZ2h0IGludGVyZmVyZVxuICAgIHRoaXMucmVtb3ZlQ29uZmxpY3RpbmdFbGVtZW50cygpO1xuICAgIFxuICAgIC8vIEVuc3VyZSBjYW52YXMgaXMgaW4gYm9keVxuICAgIGlmIChjYW52YXMucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgaWYgKGNhbnZhcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZvcmNlIGNhbnZhcyB0byBjb3ZlciBlbnRpcmUgdmlld3BvcnRcbiAgICBjYW52YXMuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgIHBvc2l0aW9uOiBmaXhlZCAhaW1wb3J0YW50O1xuICAgICAgdG9wOiAwICFpbXBvcnRhbnQ7XG4gICAgICBsZWZ0OiAwICFpbXBvcnRhbnQ7XG4gICAgICB3aWR0aDogMTAwdncgIWltcG9ydGFudDtcbiAgICAgIGhlaWdodDogMTAwdmggIWltcG9ydGFudDtcbiAgICAgIHotaW5kZXg6IDk5OTk5ICFpbXBvcnRhbnQ7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZSAhaW1wb3J0YW50O1xuICAgICAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gICAgICBkaXNwbGF5OiBibG9jayAhaW1wb3J0YW50O1xuICAgICAgb3BhY2l0eTogMSAhaW1wb3J0YW50O1xuICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG8gIWltcG9ydGFudDtcbiAgICAgIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICAgICAgcGFkZGluZzogMCAhaW1wb3J0YW50O1xuICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveCAhaW1wb3J0YW50O1xuICAgICAgdHJhbnNmb3JtOiBub25lICFpbXBvcnRhbnQ7XG4gICAgYDtcbiAgICBcbiAgICAvLyBTZXQgZGltZW5zaW9ucyB0byBtYXRjaCB2aWV3cG9ydFxuICAgIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgXG4gICAgLy8gQ2xlYXIgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgLy8gRm9yY2UgcmVmbG93XG4gICAgY2FudmFzLm9mZnNldEhlaWdodDtcbiAgICBcbiAgICAvLyBWZXJpZnkgcG9zaXRpb25pbmdcbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGlzUHJvcGVybHlQb3NpdGlvbmVkID0gcmVjdC5sZWZ0ID09PSAwICYmIHJlY3QudG9wID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Qud2lkdGggPT09IHdpbmRvdy5pbm5lcldpZHRoICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWN0LmhlaWdodCA9PT0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIFxuICAgIGNvbnNvbGUubG9nKCdDYW52YXMgZnVsbHNjcmVlbiB2ZXJpZmljYXRpb246Jywge1xuICAgICAgcmVjdCxcbiAgICAgIHdpbmRvd1NpemU6IHsgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLCBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCB9LFxuICAgICAgaXNQcm9wZXJseVBvc2l0aW9uZWQsXG4gICAgICBjYW52YXNEaW1lbnNpb25zOiB7IHdpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodCB9XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGlzUHJvcGVybHlQb3NpdGlvbmVkO1xuICB9XG5cbiAgLy8gUmVtb3ZlIGFueSBjb25mbGljdGluZyBlbGVtZW50cyB0aGF0IG1pZ2h0IGludGVyZmVyZSB3aXRoIGZ1bGxzY3JlZW4gY2FudmFzXG4gIHJlbW92ZUNvbmZsaWN0aW5nRWxlbWVudHMoKSB7XG4gICAgLy8gSGlkZSBhbnkgZWxlbWVudHMgdGhhdCBtaWdodCBpbnRlcmZlcmUgd2l0aCBmdWxsc2NyZWVuIGRpc3BsYXlcbiAgICBjb25zdCBlbGVtZW50c1RvSGlkZSA9IFtcbiAgICAgICcudG9wYmFyJyxcbiAgICAgICcuY2FudmFzLWNvbnRhaW5lcicsIFxuICAgICAgJy5tYWluLWNvbnRlbnQnLFxuICAgICAgJy5tZXRyaWNzLXBhbmVsJyxcbiAgICAgICcuZGlzcGxheS1tZXRyaWNzJyxcbiAgICAgICduYXYnLFxuICAgICAgJ2hlYWRlcicsXG4gICAgICAnLmJ1dHRvbi1ncm91cHMnLFxuICAgICAgJy5jb250cm9sLWJ1dHRvbnMnXG4gICAgXTtcbiAgICBcbiAgICBlbGVtZW50c1RvSGlkZS5mb3JFYWNoKHNlbGVjdG9yID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICBlbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgaWYgKGVsLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLWhpZGRlbi1ieS1jYW52YXMnLCAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBSZW1vdmUgYW55IGV4aXN0aW5nIGNvdW50ZG93biBlbGVtZW50c1xuICAgIGNvbnN0IGV4aXN0aW5nQ291bnRkb3ducyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5kb3QtY291bnRkb3duLCAuY2FsaWJyYXRlLWNvdW50ZG93bicpO1xuICAgIGV4aXN0aW5nQ291bnRkb3ducy5mb3JFYWNoKGVsID0+IHtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlKSBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIE1haW4gZnVuY3Rpb24gdG8gaGFuZGxlIGNhbGlicmF0aW9uIHNlcXVlbmNlXG4gIGhhbmRsZVNldENhbGlicmF0ZSA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBIaWRlIHRoZSBUb3BCYXIgYmVmb3JlIHN0YXJ0aW5nIGNhbGlicmF0aW9uXG4gICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnRvZ2dsZVRvcEJhcikge1xuICAgICAgd2luZG93LnRvZ2dsZVRvcEJhcihmYWxzZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFNldCBjYXB0dXJpbmcgc3RhdGUgaWYgZnVuY3Rpb24gZXhpc3RzXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNldElzQ2FwdHVyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKCdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicpO1xuICAgIH1cbiAgICBcbiAgICAvLyBVcGRhdGUgcGFyZW50IGNvbXBvbmVudCBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5vblN0YXR1c1VwZGF0ZSkge1xuICAgICAgdGhpcy5vblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRpbWUgdG8gdXBkYXRlXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBhd2FpdCB0aGlzLndhaXRGb3JDYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIG9yaWdpbmFsIGNhbnZhcyBkaW1lbnNpb25zIGJlZm9yZSBnb2luZyBmdWxsc2NyZWVuXG4gICAgICAgIHRoaXMub3JpZ2luYWxDYW52YXNEaW1lbnNpb25zID0ge1xuICAgICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gVXNlIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbSB0byBlbnRlciBmdWxsc2NyZWVuXG4gICAgICAgIHRoaXMuZW50ZXJGdWxsc2NyZWVuKCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIGNhbnZhcyBpcyBwcm9wZXJseSBwb3NpdGlvbmVkIGFuZCBzaXplZFxuICAgICAgICBjb25zdCBpc1Byb3Blcmx5UG9zaXRpb25lZCA9IHRoaXMuZW5zdXJlQ2FudmFzRnVsbHNjcmVlbihjYW52YXMpO1xuICAgICAgICBpZiAoIWlzUHJvcGVybHlQb3NpdGlvbmVkKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdDYW52YXMgbm90IHByb3Blcmx5IHBvc2l0aW9uZWQgZm9yIGZ1bGxzY3JlZW4sIGF0dGVtcHRpbmcgdG8gZml4Li4uJyk7XG4gICAgICAgICAgLy8gVHJ5IG9uZSBtb3JlIHRpbWUgYWZ0ZXIgYSBzaG9ydCBkZWxheVxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVDYW52YXNGdWxsc2NyZWVuKGNhbnZhcyk7XG4gICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlc3QgY29vcmRpbmF0ZSB0cmFuc2Zvcm1hdGlvblxuICAgICAgICB0aGlzLnRlc3RDb29yZGluYXRlVHJhbnNmb3JtYXRpb24oY2FudmFzKTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gT1JJR0lOQUwgY2FudmFzIHNpemVcbiAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyh0aGlzLm9yaWdpbmFsQ2FudmFzRGltZW5zaW9ucy53aWR0aCwgdGhpcy5vcmlnaW5hbENhbnZhc0RpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGlmICghcG9pbnRzIHx8IHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2VuZXJhdGUgY2FsaWJyYXRpb24gcG9pbnRzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci5jbGFzc05hbWUgPSAnY2FsaWJyYXRlLXN0YXR1cy1pbmRpY2F0b3InO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3Iuc3R5bGUuY3NzVGV4dCA9IGBcbiAgICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgICAgdG9wOiAyMHB4O1xuICAgICAgICAgIHJpZ2h0OiAyMHB4O1xuICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMTAyLCAyMDQsIDAuOSk7XG4gICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICBwYWRkaW5nOiAxMHB4IDE1cHg7XG4gICAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICAgIHotaW5kZXg6IDEwMDAwO1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLCAwLCAwLCAwLjMpO1xuICAgICAgICBgO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSAnQ2FsaWJyYXRpb246IEluaXRpYWxpemluZy4uLic7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcblxuICAgICAgICAvLyBQcm9jZXNzIGVhY2ggY2FsaWJyYXRpb24gcG9pbnRcbiAgICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3JpZ2luYWxQb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gY29vcmRpbmF0ZXMgZm9yIGZ1bGxzY3JlZW4gZGlzcGxheVxuICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUG9pbnQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGNhbnZhcywgb3JpZ2luYWxQb2ludCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBkaXNwbGF5c1xuICAgICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9IGBDYWxpYnJhdGlvbjogUG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWA7XG4gICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBQcm9jZXNzaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSArIDF9LyR7cG9pbnRzLmxlbmd0aH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDbGVhciBjYW52YXMgd2l0aCB3aGl0ZSBiYWNrZ3JvdW5kIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICAgIHRoaXMuY2xlYXJDYW52YXMoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBEcmF3IHRoZSBjYWxpYnJhdGlvbiBwb2ludCB1c2luZyBPUklHSU5BTCBjb29yZGluYXRlcyAoY2FudmFzIGNvb3JkaW5hdGVzKVxuICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDEyOyAvLyBTdGFuZGFyZCBzaXplIGZvciBjb25zaXN0ZW5jeVxuICAgICAgICAgIHRoaXMuZHJhd0RvdChvcmlnaW5hbFBvaW50LngsIG9yaWdpbmFsUG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhdGUgcmVkcmF3IGludGVydmFsIHRvIGVuc3VyZSBkb3Qgc3RheXMgdmlzaWJsZVxuICAgICAgICAgIGNvbnN0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmF3RG90KG9yaWdpbmFsUG9pbnQueCwgb3JpZ2luYWxQb2ludC55LCByYWRpdXMpO1xuICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVtb3ZlIGFueSBleGlzdGluZyBjb3VudGRvd24gZWxlbWVudHNcbiAgICAgICAgICBjb25zdCBleGlzdGluZ0NvdW50ZG93bnMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuZG90LWNvdW50ZG93biwgLmNhbGlicmF0ZS1jb3VudGRvd24nKTtcbiAgICAgICAgICBleGlzdGluZ0NvdW50ZG93bnMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIGN1c3RvbSBjb3VudGRvd24gZWxlbWVudCBwb3NpdGlvbmVkIHVzaW5nIFRSQU5TRk9STUVEIGNvb3JkaW5hdGVzICh2aWV3cG9ydCBjb29yZGluYXRlcylcbiAgICAgICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgbGVmdDogJHt0cmFuc2Zvcm1lZFBvaW50Lnh9cHg7XG4gICAgICAgICAgICB0b3A6ICR7dHJhbnNmb3JtZWRQb2ludC55fXB4O1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XG4gICAgICAgICAgICBjb2xvcjogcmVkO1xuICAgICAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICB0ZXh0LXNoYWRvdzogMCAwIDEwcHggd2hpdGUsIDAgMCAyMHB4IHdoaXRlO1xuICAgICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gICAgICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgICAgIGhlaWdodDogNDhweDtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgICAgICBib3gtc2hhZG93OiAwIDAgMTVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICAgICAgYDtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERlYnVnOiBMb2cgcG9zaXRpb25pbmcgaW5mb3JtYXRpb25cbiAgICAgICAgICBjb25zb2xlLmxvZyhgUG9pbnQgJHtpKzF9IHBvc2l0aW9uaW5nOmAsIHtcbiAgICAgICAgICAgIG9yaWdpbmFsUG9pbnQsXG4gICAgICAgICAgICB0cmFuc2Zvcm1lZFBvaW50LFxuICAgICAgICAgICAgY291bnRkb3duUG9zaXRpb246IHtcbiAgICAgICAgICAgICAgbGVmdDogdHJhbnNmb3JtZWRQb2ludC54LFxuICAgICAgICAgICAgICB0b3A6IHRyYW5zZm9ybWVkUG9pbnQueVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbnZhc0luZm86IHtcbiAgICAgICAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgICAgICAgICByZWN0OiBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTWFudWFsIGNvdW50ZG93blxuICAgICAgICAgICAgZm9yIChsZXQgY291bnQgPSAzOyBjb3VudCA+IDA7IGNvdW50LS0pIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IGNvdW50O1xuICAgICAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYFBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9OiBDb3VudGRvd24gJHtjb3VudH1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEZvcmNlIHJlZHJhdyB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGUgKHVzaW5nIG9yaWdpbmFsIGNvb3JkaW5hdGVzKVxuICAgICAgICAgICAgICB0aGlzLmRyYXdEb3Qob3JpZ2luYWxQb2ludC54LCBvcmlnaW5hbFBvaW50LnksIHJhZGl1cyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgODAwKSk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBSZWRyYXcgYWdhaW4gaGFsZndheSB0aHJvdWdoIHRoZSB3YWl0XG4gICAgICAgICAgICAgIHRoaXMuZHJhd0RvdChvcmlnaW5hbFBvaW50LngsIG9yaWdpbmFsUG9pbnQueSwgcmFkaXVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2hvdyBjaGVja21hcmtcbiAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBcIuKck1wiO1xuICAgICAgICAgICAgdGhpcy5kcmF3RG90KG9yaWdpbmFsUG9pbnQueCwgb3JpZ2luYWxQb2ludC55LCByYWRpdXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBSZW1vdmUgY291bnRkb3duIGVsZW1lbnQgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNvdW50ZG93bkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgZG90IGlzIHN0aWxsIHZpc2libGVcbiAgICAgICAgICAgIHRoaXMuZHJhd0RvdChvcmlnaW5hbFBvaW50LngsIG9yaWdpbmFsUG9pbnQueSwgcmFkaXVzKTtcblxuICAgICAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludCAodXNlIG9yaWdpbmFsIGNvb3JkaW5hdGVzIGZvciBjYXB0dXJlKVxuICAgICAgICAgICAgY29uc29sZS5sb2coYENhcHR1cmluZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofSBhdCAoJHtvcmlnaW5hbFBvaW50Lnh9LCAke29yaWdpbmFsUG9pbnQueX0pYCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICAgIHBvaW50OiBvcmlnaW5hbFBvaW50LCAvLyBVc2Ugb3JpZ2luYWwgY29vcmRpbmF0ZXMgZm9yIGNhcHR1cmVcbiAgICAgICAgICAgICAgY2FwdHVyZUNvdW50OiB0aGlzLmNhcHR1cmVDb3VudGVyLFxuICAgICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICAgIHNldENhcHR1cmVDb3VudDogdGhpcy5zZXRDYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgc2hvd0NhcHR1cmVQcmV2aWV3XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGNhcHR1cmVSZXN1bHQgJiYgKGNhcHR1cmVSZXN1bHQuc2NyZWVuSW1hZ2UgfHwgY2FwdHVyZVJlc3VsdC5zdWNjZXNzKSkge1xuICAgICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2FpdCBhIG1vbWVudCBiZWZvcmUgY2xlYXJpbmcgdG8gZW5zdXJlIGNhcHR1cmUgaXMgY29tcGxldGVcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGRvdCBhZnRlciBjYXB0dXJlIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICAgICAgdGhpcy5jbGVhckNhbnZhcygpO1xuXG4gICAgICAgICAgICAvLyBXYWl0IGJldHdlZW4gcG9pbnRzXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTIwMCkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpKzF9OmAsIGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgY291bnRkb3duIGlmIGl0IHN0aWxsIGV4aXN0c1xuICAgICAgICAgICAgaWYgKGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENsZWFyIHJlZHJhdyBpbnRlcnZhbFxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWRyYXdJbnRlcnZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxpYnJhdGlvbiBjb21wbGV0ZVxuICAgICAgICBpZiAoc3RhdHVzSW5kaWNhdG9yKSB7XG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uIGNvbXBsZXRlOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHNgO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gY29tcGxldGVkOiAke3N1Y2Nlc3NDb3VudH0vJHtwb2ludHMubGVuZ3RofSBwb2ludHMgY2FwdHVyZWRgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSBzdGF0dXMgaW5kaWNhdG9yIGFmdGVyIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDMwMDApO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDYWxpYnJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYENhbGlicmF0aW9uIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBFeGl0IGZ1bGxzY3JlZW4gYW5kIHJlc3RvcmUgY2FudmFzIHVzaW5nIGNhbnZhcyBtYW5hZ2VtZW50IHN5c3RlbVxuICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXN0b3JlIGhpZGRlbiBlbGVtZW50c1xuICAgICAgICB0aGlzLnJlc3RvcmVIaWRkZW5FbGVtZW50cygpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGNhcHR1cmluZyBzdGF0ZSB0byBmYWxzZSBpZiBmdW5jdGlvbiBleGlzdHNcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNldElzQ2FwdHVyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5zZXRJc0NhcHR1cmluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FsaWJyYXRlQWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZHJhd1JlZERvdCIsInJ1bkNvdW50ZG93biIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiU2V0Q2FsaWJyYXRlQWN0aW9uIiwiY29uZmlnIiwiaGFuZGxlU2V0Q2FsaWJyYXRlIiwidG9nZ2xlVG9wQmFyIiwid2luZG93Iiwic2V0SXNDYXB0dXJpbmciLCJzZXRQcm9jZXNzU3RhdHVzIiwib25TdGF0dXNVcGRhdGUiLCJwcm9jZXNzU3RhdHVzIiwiaXNDYXB0dXJpbmciLCJzZXRUaW1lb3V0IiwiY2FudmFzIiwid2FpdEZvckNhbnZhcyIsIkVycm9yIiwib3JpZ2luYWxDYW52YXNEaW1lbnNpb25zIiwid2lkdGgiLCJoZWlnaHQiLCJlbnRlckZ1bGxzY3JlZW4iLCJpc1Byb3Blcmx5UG9zaXRpb25lZCIsImVuc3VyZUNhbnZhc0Z1bGxzY3JlZW4iLCJjb25zb2xlIiwid2FybiIsInRlc3RDb29yZGluYXRlVHJhbnNmb3JtYXRpb24iLCJwb2ludHMiLCJsZW5ndGgiLCJzdGF0dXNJbmRpY2F0b3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN1Y2Nlc3NDb3VudCIsImkiLCJvcmlnaW5hbFBvaW50IiwidHJhbnNmb3JtZWRQb2ludCIsInRyYW5zZm9ybUNvb3JkaW5hdGVzIiwiY2xlYXJDYW52YXMiLCJyYWRpdXMiLCJkcmF3RG90IiwieCIsInkiLCJyZWRyYXdJbnRlcnZhbCIsInNldEludGVydmFsIiwiZXhpc3RpbmdDb3VudGRvd25zIiwicXVlcnlTZWxlY3RvckFsbCIsImZvckVhY2giLCJlbCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNvdW50ZG93bkVsZW1lbnQiLCJsb2ciLCJjb3VudGRvd25Qb3NpdGlvbiIsImxlZnQiLCJ0b3AiLCJjYW52YXNJbmZvIiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvdW50IiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXB0dXJlUmVzdWx0IiwicG9pbnQiLCJjYXB0dXJlQ291bnQiLCJjYXB0dXJlQ291bnRlciIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnRlciIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsImVycm9yIiwiY2xlYXJJbnRlcnZhbCIsIm1lc3NhZ2UiLCJleGl0RnVsbHNjcmVlbiIsInJlc3RvcmVIaWRkZW5FbGVtZW50cyIsInNldEN1cnJlbnREb3QiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwic2F2ZUltYWdlVG9TZXJ2ZXIiLCJjYW52YXNNYW5hZ2VyIiwiY2FudmFzVXRpbHMiLCJnZXRDYW52YXMiLCJnbG9iYWxDYW52YXNNYW5hZ2VyIiwiY3JlYXRlQ2FudmFzIiwicXVlcnlTZWxlY3RvciIsImlzRnVsbHNjcmVlbiIsImlzSW5GdWxsc2NyZWVuIiwicG9zaXRpb24iLCJjYW52YXNQb3NpdGlvbiIsImNhbnZhc1dpZHRoIiwiY2FudmFzSGVpZ2h0IiwiY2FudmFzUmVjdCIsImlubmVyV2lkdGgiLCJpbm5lckhlaWdodCIsIndpbmRvd1NpemUiLCJzY2FsZVgiLCJzY2FsZVkiLCJsYWJlbCIsIm9yaWdpbmFsIiwidHJhbnNmb3JtZWQiLCJzY2FsZSIsImNhbnZhc0RpbWVuc2lvbnMiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJvZmZzZXRIZWlnaHQiLCJjb250YWluZXIiLCJ6SW5kZXgiLCJiYWNrZ3JvdW5kQ29sb3IiLCJoaWRkZW5FbGVtZW50cyIsImRpc3BsYXkiLCJyZW1vdmVBdHRyaWJ1dGUiLCJjbGVhciIsImNsZWFyUmVjdCIsIm1heFRyaWVzIiwiaW50ZXJ2YWwiLCJ0ZXN0UG9pbnQiLCJyZW1vdmVDb25mbGljdGluZ0VsZW1lbnRzIiwiZWxlbWVudHNUb0hpZGUiLCJzZWxlY3RvciIsImVsZW1lbnRzIiwic2V0QXR0cmlidXRlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\n");

/***/ })

};
;