"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_jsx";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_SetCalibrateAction_jsx"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx":
/*!*******************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetCalibrateAction.jsx ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _CalibratePoints__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CalibratePoints */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/CalibratePoints.js\");\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-node)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetCalibrateAction.jsx\n// Handles the calibration sequence functionality\n\n\n\n\nclass SetCalibrateAction {\n    constructor(config){\n        // Main function to handle calibration sequence\n        this.handleSetCalibrate = async ()=>{\n            // Hide the TopBar before starting calibration\n            if (typeof this.toggleTopBar === 'function') {\n                this.toggleTopBar(false);\n            } else if (false) {}\n            this.setIsCapturing(true);\n            this.setProcessStatus('Starting calibration sequence...');\n            // Update parent component if available\n            if (this.onStatusUpdate) {\n                this.onStatusUpdate({\n                    processStatus: 'Starting calibration sequence...',\n                    isCapturing: true\n                });\n            }\n            // Give the component time to update\n            setTimeout(async ()=>{\n                try {\n                    const canvas = await this.waitForCanvas();\n                    if (!canvas) {\n                        throw new Error(\"Canvas not available\");\n                    }\n                    // Use canvas manager to enter fullscreen\n                    if (this.canvasManager) {\n                        this.canvasManager.enterFullscreen();\n                    }\n                    // Generate calibration points based on canvas size\n                    const points = (0,_CalibratePoints__WEBPACK_IMPORTED_MODULE_1__.generateCalibrationPoints)(canvas.width, canvas.height);\n                    if (!points || points.length === 0) {\n                        throw new Error(\"Failed to generate calibration points\");\n                    }\n                    // Create status indicator\n                    const statusIndicator = document.createElement('div');\n                    statusIndicator.className = 'calibrate-status-indicator';\n                    statusIndicator.style.cssText = `\n          position: fixed;\n          top: 20px;\n          right: 20px;\n          background-color: rgba(0, 102, 204, 0.9);\n          color: white;\n          font-size: 16px;\n          font-weight: bold;\n          padding: 10px 15px;\n          border-radius: 8px;\n          z-index: 10000;\n          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\n        `;\n                    statusIndicator.textContent = 'Calibration: Initializing...';\n                    document.body.appendChild(statusIndicator);\n                    // Process each calibration point\n                    let successCount = 0;\n                    for(let i = 0; i < points.length; i++){\n                        const point = points[i];\n                        // Update status displays\n                        statusIndicator.textContent = `Calibration: Point ${i + 1}/${points.length}`;\n                        this.setProcessStatus(`Processing calibration point ${i + 1}/${points.length}`);\n                        // Clear canvas with white background\n                        const ctx = canvas.getContext('2d');\n                        ctx.clearRect(0, 0, canvas.width, canvas.height);\n                        ctx.fillStyle = 'white';\n                        ctx.fillRect(0, 0, canvas.width, canvas.height);\n                        // Draw the calibration point with consistent size\n                        const radius = 12; // Standard size for consistency\n                        (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        // Create redraw interval to ensure dot stays visible\n                        const redrawInterval = setInterval(()=>{\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                        }, 200);\n                        // Remove any existing countdown elements\n                        const existingCountdowns = document.querySelectorAll('.dot-countdown, .calibrate-countdown');\n                        existingCountdowns.forEach((el)=>{\n                            if (el.parentNode) el.parentNode.removeChild(el);\n                        });\n                        // Create custom countdown element\n                        const countdownElement = document.createElement('div');\n                        countdownElement.className = 'dot-countdown';\n                        countdownElement.style.cssText = `\n            position: fixed;\n            left: ${point.x}px;\n            top: ${point.y - 60}px;\n            transform: translateX(-50%);\n            color: red;\n            font-size: 36px;\n            font-weight: bold;\n            text-shadow: 0 0 10px white, 0 0 20px white;\n            z-index: 10000;\n            background-color: rgba(255, 255, 255, 0.8);\n            border: 2px solid red;\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);\n          `;\n                        document.body.appendChild(countdownElement);\n                        try {\n                            // Manual countdown\n                            for(let count = 3; count > 0; count--){\n                                countdownElement.textContent = count;\n                                this.setProcessStatus(`Point ${i + 1}/${points.length}: Countdown ${count}`);\n                                // Force redraw to ensure dot stays visible\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                                await new Promise((resolve)=>setTimeout(resolve, 800));\n                                // Redraw again halfway through the wait\n                                (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            }\n                            // Show checkmark\n                            countdownElement.textContent = \"âœ“\";\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Remove countdown element after delay\n                            setTimeout(()=>{\n                                if (countdownElement.parentNode) {\n                                    countdownElement.parentNode.removeChild(countdownElement);\n                                }\n                            }, 300);\n                            // Make sure dot is still visible\n                            (0,_countSave__WEBPACK_IMPORTED_MODULE_2__.drawRedDot)(ctx, point.x, point.y, radius, false);\n                            // Capture images at this point\n                            console.log(`Capturing calibration point ${i + 1}/${points.length} at (${point.x}, ${point.y})`);\n                            const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_3__.captureImagesAtPoint)({\n                                point: point,\n                                captureCount: this.captureCounter,\n                                canvasRef: {\n                                    current: canvas\n                                },\n                                setCaptureCount: this.setCaptureCounter,\n                                showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_2__.showCapturePreview\n                            });\n                            if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                                successCount++;\n                            }\n                            // Wait between points\n                            await new Promise((resolve)=>setTimeout(resolve, 1200));\n                        } catch (error) {\n                            console.error(`Error processing calibration point ${i + 1}:`, error);\n                        } finally{\n                            // Clean up countdown if it still exists\n                            if (countdownElement.parentNode) {\n                                countdownElement.parentNode.removeChild(countdownElement);\n                            }\n                            // Clear redraw interval\n                            clearInterval(redrawInterval);\n                        }\n                    }\n                    // Calibration complete\n                    if (statusIndicator) {\n                        statusIndicator.textContent = `Calibration complete: ${successCount}/${points.length} points`;\n                    }\n                    this.setProcessStatus(`Calibration completed: ${successCount}/${points.length} points captured`);\n                    // Remove status indicator after delay\n                    setTimeout(()=>{\n                        if (statusIndicator.parentNode) {\n                            statusIndicator.parentNode.removeChild(statusIndicator);\n                        }\n                    }, 3000);\n                } catch (error) {\n                    console.error(\"Calibration error:\", error);\n                    this.setProcessStatus(`Calibration error: ${error.message}`);\n                } finally{\n                    // Exit fullscreen and restore canvas\n                    if (this.canvasManager) {\n                        this.canvasManager.exitFullscreen();\n                    }\n                    this.setIsCapturing(false);\n                    // Show TopBar again after a delay\n                    setTimeout(()=>{\n                        if (typeof this.toggleTopBar === 'function') {\n                            this.toggleTopBar(true);\n                        } else if (false) {}\n                    }, 1000);\n                }\n            }, 200);\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.toggleTopBar = config.toggleTopBar;\n        this.setIsCapturing = config.setIsCapturing;\n        this.setProcessStatus = config.setProcessStatus;\n        this.setCurrentDot = config.setCurrentDot;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.saveImageToServer = config.saveImageToServer;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.captureCounter = config.captureCounter;\n        // Get canvas manager from global scope\n        this.canvasManager =  false ? 0 : null;\n    }\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return this.canvasRef?.current || document.querySelector('#tracking-canvas');\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas(maxTries = 20, interval = 100) {\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetCalibrateAction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFDekIsaURBQWlEO0FBRXZCO0FBQ29DO0FBQ2E7QUFDakI7QUFFMUQsTUFBTU07SUFDSkMsWUFBWUMsTUFBTSxDQUFFO1FBdUNwQiwrQ0FBK0M7YUFDL0NDLHFCQUFxQjtZQUNuQiw4Q0FBOEM7WUFDOUMsSUFBSSxPQUFPLElBQUksQ0FBQ0MsWUFBWSxLQUFLLFlBQVk7Z0JBQzNDLElBQUksQ0FBQ0EsWUFBWSxDQUFDO1lBQ3BCLE9BQU8sSUFBSSxLQUFvRCxFQUFFLEVBRWhFO1lBRUQsSUFBSSxDQUFDRSxjQUFjLENBQUM7WUFDcEIsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQztZQUV0Qix1Q0FBdUM7WUFDdkMsSUFBSSxJQUFJLENBQUNDLGNBQWMsRUFBRTtnQkFDdkIsSUFBSSxDQUFDQSxjQUFjLENBQUM7b0JBQ2xCQyxlQUFlO29CQUNmQyxhQUFhO2dCQUNmO1lBQ0Y7WUFFQSxvQ0FBb0M7WUFDcENDLFdBQVc7Z0JBQ1QsSUFBSTtvQkFDRixNQUFNQyxTQUFTLE1BQU0sSUFBSSxDQUFDQyxhQUFhO29CQUN2QyxJQUFJLENBQUNELFFBQVE7d0JBQ1gsTUFBTSxJQUFJRSxNQUFNO29CQUNsQjtvQkFFQSx5Q0FBeUM7b0JBQ3pDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7d0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDQyxlQUFlO29CQUNwQztvQkFFQSxtREFBbUQ7b0JBQ25ELE1BQU1DLFNBQVN0QiwyRUFBeUJBLENBQUNpQixPQUFPTSxLQUFLLEVBQUVOLE9BQU9PLE1BQU07b0JBRXBFLElBQUksQ0FBQ0YsVUFBVUEsT0FBT0csTUFBTSxLQUFLLEdBQUc7d0JBQ2xDLE1BQU0sSUFBSU4sTUFBTTtvQkFDbEI7b0JBRUEsMEJBQTBCO29CQUMxQixNQUFNTyxrQkFBa0JDLFNBQVNDLGFBQWEsQ0FBQztvQkFDL0NGLGdCQUFnQkcsU0FBUyxHQUFHO29CQUM1QkgsZ0JBQWdCSSxLQUFLLENBQUNDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7UUFZakMsQ0FBQztvQkFDREwsZ0JBQWdCTSxXQUFXLEdBQUc7b0JBQzlCTCxTQUFTTSxJQUFJLENBQUNDLFdBQVcsQ0FBQ1I7b0JBRTFCLGlDQUFpQztvQkFDakMsSUFBSVMsZUFBZTtvQkFDbkIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlkLE9BQU9HLE1BQU0sRUFBRVcsSUFBSzt3QkFDdEMsTUFBTUMsUUFBUWYsTUFBTSxDQUFDYyxFQUFFO3dCQUV2Qix5QkFBeUI7d0JBQ3pCVixnQkFBZ0JNLFdBQVcsR0FBRyxDQUFDLG1CQUFtQixFQUFFSSxJQUFJLEVBQUUsQ0FBQyxFQUFFZCxPQUFPRyxNQUFNLEVBQUU7d0JBQzVFLElBQUksQ0FBQ2IsZ0JBQWdCLENBQUMsQ0FBQyw2QkFBNkIsRUFBRXdCLElBQUksRUFBRSxDQUFDLEVBQUVkLE9BQU9HLE1BQU0sRUFBRTt3QkFFOUUscUNBQXFDO3dCQUNyQyxNQUFNYSxNQUFNckIsT0FBT3NCLFVBQVUsQ0FBQzt3QkFDOUJELElBQUlFLFNBQVMsQ0FBQyxHQUFHLEdBQUd2QixPQUFPTSxLQUFLLEVBQUVOLE9BQU9PLE1BQU07d0JBQy9DYyxJQUFJRyxTQUFTLEdBQUc7d0JBQ2hCSCxJQUFJSSxRQUFRLENBQUMsR0FBRyxHQUFHekIsT0FBT00sS0FBSyxFQUFFTixPQUFPTyxNQUFNO3dCQUU5QyxrREFBa0Q7d0JBQ2xELE1BQU1tQixTQUFTLElBQUksZ0NBQWdDO3dCQUNuRDFDLHNEQUFVQSxDQUFDcUMsS0FBS0QsTUFBTU8sQ0FBQyxFQUFFUCxNQUFNUSxDQUFDLEVBQUVGLFFBQVE7d0JBRTFDLHFEQUFxRDt3QkFDckQsTUFBTUcsaUJBQWlCQyxZQUFZOzRCQUNqQzlDLHNEQUFVQSxDQUFDcUMsS0FBS0QsTUFBTU8sQ0FBQyxFQUFFUCxNQUFNUSxDQUFDLEVBQUVGLFFBQVE7d0JBQzVDLEdBQUc7d0JBRUgseUNBQXlDO3dCQUN6QyxNQUFNSyxxQkFBcUJyQixTQUFTc0IsZ0JBQWdCLENBQUM7d0JBQ3JERCxtQkFBbUJFLE9BQU8sQ0FBQ0MsQ0FBQUE7NEJBQ3pCLElBQUlBLEdBQUdDLFVBQVUsRUFBRUQsR0FBR0MsVUFBVSxDQUFDQyxXQUFXLENBQUNGO3dCQUMvQzt3QkFFQSxrQ0FBa0M7d0JBQ2xDLE1BQU1HLG1CQUFtQjNCLFNBQVNDLGFBQWEsQ0FBQzt3QkFDaEQwQixpQkFBaUJ6QixTQUFTLEdBQUc7d0JBQzdCeUIsaUJBQWlCeEIsS0FBSyxDQUFDQyxPQUFPLEdBQUcsQ0FBQzs7a0JBRTFCLEVBQUVNLE1BQU1PLENBQUMsQ0FBQztpQkFDWCxFQUFFUCxNQUFNUSxDQUFDLEdBQUcsR0FBRzs7Ozs7Ozs7Ozs7Ozs7OztVQWdCdEIsQ0FBQzt3QkFDRGxCLFNBQVNNLElBQUksQ0FBQ0MsV0FBVyxDQUFDb0I7d0JBRTFCLElBQUk7NEJBQ0YsbUJBQW1COzRCQUNuQixJQUFLLElBQUlDLFFBQVEsR0FBR0EsUUFBUSxHQUFHQSxRQUFTO2dDQUN0Q0QsaUJBQWlCdEIsV0FBVyxHQUFHdUI7Z0NBQy9CLElBQUksQ0FBQzNDLGdCQUFnQixDQUFDLENBQUMsTUFBTSxFQUFFd0IsSUFBRSxFQUFFLENBQUMsRUFBRWQsT0FBT0csTUFBTSxDQUFDLFlBQVksRUFBRThCLE9BQU87Z0NBRXpFLDJDQUEyQztnQ0FDM0N0RCxzREFBVUEsQ0FBQ3FDLEtBQUtELE1BQU1PLENBQUMsRUFBRVAsTUFBTVEsQ0FBQyxFQUFFRixRQUFRO2dDQUUxQyxNQUFNLElBQUlhLFFBQVFDLENBQUFBLFVBQVd6QyxXQUFXeUMsU0FBUztnQ0FFakQsd0NBQXdDO2dDQUN4Q3hELHNEQUFVQSxDQUFDcUMsS0FBS0QsTUFBTU8sQ0FBQyxFQUFFUCxNQUFNUSxDQUFDLEVBQUVGLFFBQVE7NEJBQzVDOzRCQUVBLGlCQUFpQjs0QkFDakJXLGlCQUFpQnRCLFdBQVcsR0FBRzs0QkFDL0IvQixzREFBVUEsQ0FBQ3FDLEtBQUtELE1BQU1PLENBQUMsRUFBRVAsTUFBTVEsQ0FBQyxFQUFFRixRQUFROzRCQUUxQyx1Q0FBdUM7NEJBQ3ZDM0IsV0FBVztnQ0FDVCxJQUFJc0MsaUJBQWlCRixVQUFVLEVBQUU7b0NBQy9CRSxpQkFBaUJGLFVBQVUsQ0FBQ0MsV0FBVyxDQUFDQztnQ0FDMUM7NEJBQ0YsR0FBRzs0QkFFSCxpQ0FBaUM7NEJBQ2pDckQsc0RBQVVBLENBQUNxQyxLQUFLRCxNQUFNTyxDQUFDLEVBQUVQLE1BQU1RLENBQUMsRUFBRUYsUUFBUTs0QkFFMUMsK0JBQStCOzRCQUMvQmUsUUFBUUMsR0FBRyxDQUFDLENBQUMsNEJBQTRCLEVBQUV2QixJQUFFLEVBQUUsQ0FBQyxFQUFFZCxPQUFPRyxNQUFNLENBQUMsS0FBSyxFQUFFWSxNQUFNTyxDQUFDLENBQUMsRUFBRSxFQUFFUCxNQUFNUSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUU3RixNQUFNZSxnQkFBZ0IsTUFBTXhELHNFQUFvQkEsQ0FBQztnQ0FDL0NpQyxPQUFPQTtnQ0FDUHdCLGNBQWMsSUFBSSxDQUFDQyxjQUFjO2dDQUNqQ0MsV0FBVztvQ0FBRUMsU0FBUy9DO2dDQUFPO2dDQUM3QmdELGlCQUFpQixJQUFJLENBQUNDLGlCQUFpQjtnQ0FDdkMvRCxrQkFBa0JBLDREQUFBQTs0QkFDcEI7NEJBRUEsSUFBSXlELGlCQUFrQkEsQ0FBQUEsY0FBY08sV0FBVyxJQUFJUCxjQUFjUSxPQUFPLEdBQUc7Z0NBQ3pFakM7NEJBQ0Y7NEJBRUEsc0JBQXNCOzRCQUN0QixNQUFNLElBQUlxQixRQUFRQyxDQUFBQSxVQUFXekMsV0FBV3lDLFNBQVM7d0JBRW5ELEVBQUUsT0FBT1ksT0FBTzs0QkFDZFgsUUFBUVcsS0FBSyxDQUFDLENBQUMsbUNBQW1DLEVBQUVqQyxJQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUVpQzt3QkFDOUQsU0FBVTs0QkFDUix3Q0FBd0M7NEJBQ3hDLElBQUlmLGlCQUFpQkYsVUFBVSxFQUFFO2dDQUMvQkUsaUJBQWlCRixVQUFVLENBQUNDLFdBQVcsQ0FBQ0M7NEJBQzFDOzRCQUVBLHdCQUF3Qjs0QkFDeEJnQixjQUFjeEI7d0JBQ2hCO29CQUNGO29CQUVBLHVCQUF1QjtvQkFDdkIsSUFBSXBCLGlCQUFpQjt3QkFDbkJBLGdCQUFnQk0sV0FBVyxHQUFHLENBQUMsc0JBQXNCLEVBQUVHLGFBQWEsQ0FBQyxFQUFFYixPQUFPRyxNQUFNLENBQUMsT0FBTyxDQUFDO29CQUMvRjtvQkFDQSxJQUFJLENBQUNiLGdCQUFnQixDQUFDLENBQUMsdUJBQXVCLEVBQUV1QixhQUFhLENBQUMsRUFBRWIsT0FBT0csTUFBTSxDQUFDLGdCQUFnQixDQUFDO29CQUUvRixzQ0FBc0M7b0JBQ3RDVCxXQUFXO3dCQUNULElBQUlVLGdCQUFnQjBCLFVBQVUsRUFBRTs0QkFDOUIxQixnQkFBZ0IwQixVQUFVLENBQUNDLFdBQVcsQ0FBQzNCO3dCQUN6QztvQkFDRixHQUFHO2dCQUVMLEVBQUUsT0FBTzJDLE9BQU87b0JBQ2RYLFFBQVFXLEtBQUssQ0FBQyxzQkFBc0JBO29CQUNwQyxJQUFJLENBQUN6RCxnQkFBZ0IsQ0FBQyxDQUFDLG1CQUFtQixFQUFFeUQsTUFBTUUsT0FBTyxFQUFFO2dCQUM3RCxTQUFVO29CQUNSLHFDQUFxQztvQkFDckMsSUFBSSxJQUFJLENBQUNuRCxhQUFhLEVBQUU7d0JBQ3RCLElBQUksQ0FBQ0EsYUFBYSxDQUFDb0QsY0FBYztvQkFDbkM7b0JBRUEsSUFBSSxDQUFDN0QsY0FBYyxDQUFDO29CQUVwQixrQ0FBa0M7b0JBQ2xDSyxXQUFXO3dCQUNULElBQUksT0FBTyxJQUFJLENBQUNQLFlBQVksS0FBSyxZQUFZOzRCQUMzQyxJQUFJLENBQUNBLFlBQVksQ0FBQzt3QkFDcEIsT0FBTyxJQUFJLEtBQW9ELEVBQUUsRUFFaEU7b0JBQ0gsR0FBRztnQkFDTDtZQUNGLEdBQUc7UUFDTDtRQXRQRSxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDc0QsU0FBUyxHQUFHeEQsT0FBT3dELFNBQVM7UUFDakMsSUFBSSxDQUFDdEQsWUFBWSxHQUFHRixPQUFPRSxZQUFZO1FBQ3ZDLElBQUksQ0FBQ0UsY0FBYyxHQUFHSixPQUFPSSxjQUFjO1FBQzNDLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdMLE9BQU9LLGdCQUFnQjtRQUMvQyxJQUFJLENBQUM2RCxhQUFhLEdBQUdsRSxPQUFPa0UsYUFBYTtRQUN6QyxJQUFJLENBQUNDLG1CQUFtQixHQUFHbkUsT0FBT21FLG1CQUFtQjtRQUNyRCxJQUFJLENBQUM3RCxjQUFjLEdBQUdOLE9BQU9NLGNBQWM7UUFDM0MsSUFBSSxDQUFDOEQsaUJBQWlCLEdBQUdwRSxPQUFPb0UsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ1QsaUJBQWlCLEdBQUczRCxPQUFPMkQsaUJBQWlCO1FBQ2pELElBQUksQ0FBQ0osY0FBYyxHQUFHdkQsT0FBT3VELGNBQWM7UUFFM0MsdUNBQXVDO1FBQ3ZDLElBQUksQ0FBQzFDLGFBQWEsR0FBRyxNQUE2QixHQUFHVixDQUFvQixHQUFHO0lBQzlFO0lBRUEsbURBQW1EO0lBQ25Ea0UsWUFBWTtRQUNWLElBQUksSUFBSSxDQUFDeEQsYUFBYSxFQUFFO1lBQ3RCLE9BQU8sSUFBSSxDQUFDQSxhQUFhLENBQUN3RCxTQUFTLE1BQU0sSUFBSSxDQUFDeEQsYUFBYSxDQUFDeUQsWUFBWTtRQUMxRTtRQUVBLHVEQUF1RDtRQUN2RCxPQUFPLElBQUksQ0FBQ2QsU0FBUyxFQUFFQyxXQUFXckMsU0FBU21ELGFBQWEsQ0FBQztJQUMzRDtJQUVBLG1DQUFtQztJQUNuQyxNQUFNNUQsY0FBYzZELFdBQVcsRUFBRSxFQUFFQyxXQUFXLEdBQUcsRUFBRTtRQUNqRCxJQUFLLElBQUk1QyxJQUFJLEdBQUdBLElBQUkyQyxVQUFVM0MsSUFBSztZQUNqQyxNQUFNbkIsU0FBUyxJQUFJLENBQUMyRCxTQUFTO1lBQzdCLElBQUkzRCxVQUFVQSxPQUFPTSxLQUFLLEdBQUcsS0FBS04sT0FBT08sTUFBTSxHQUFHLEdBQUc7Z0JBQ25ELE9BQU9QO1lBQ1Q7WUFDQSxNQUFNLElBQUl1QyxRQUFRQyxDQUFBQSxVQUFXekMsV0FBV3lDLFNBQVN1QjtRQUNuRDtRQUNBLE1BQU0sSUFBSTdELE1BQU07SUFDbEI7QUFtTkY7QUFFQSxpRUFBZWQsa0JBQWtCQSxFQUFDIiwic291cmNlcyI6WyIvYXBwL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0Q2FsaWJyYXRlQWN0aW9uLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTZXRDYWxpYnJhdGVBY3Rpb24uanN4XG4vLyBIYW5kbGVzIHRoZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZSBmdW5jdGlvbmFsaXR5XG5cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIH0gZnJvbSAnLi9DYWxpYnJhdGVQb2ludHMnO1xuaW1wb3J0IHsgZHJhd1JlZERvdCwgcnVuQ291bnRkb3duLCBzaG93Q2FwdHVyZVByZXZpZXcgfSBmcm9tICcuL2NvdW50U2F2ZSc7XG5pbXBvcnQgeyBjYXB0dXJlSW1hZ2VzQXRQb2ludCB9IGZyb20gJy4uL0hlbHBlci9zYXZlZmlsZSc7XG5cbmNsYXNzIFNldENhbGlicmF0ZUFjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIC8vIFJlcXVpcmVkIHByb3BlcnRpZXNcbiAgICB0aGlzLmNhbnZhc1JlZiA9IGNvbmZpZy5jYW52YXNSZWY7XG4gICAgdGhpcy50b2dnbGVUb3BCYXIgPSBjb25maWcudG9nZ2xlVG9wQmFyO1xuICAgIHRoaXMuc2V0SXNDYXB0dXJpbmcgPSBjb25maWcuc2V0SXNDYXB0dXJpbmc7XG4gICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzID0gY29uZmlnLnNldFByb2Nlc3NTdGF0dXM7XG4gICAgdGhpcy5zZXRDdXJyZW50RG90ID0gY29uZmlnLnNldEN1cnJlbnREb3Q7XG4gICAgdGhpcy50cmlnZ2VyQ2FtZXJhQWNjZXNzID0gY29uZmlnLnRyaWdnZXJDYW1lcmFBY2Nlc3M7XG4gICAgdGhpcy5vblN0YXR1c1VwZGF0ZSA9IGNvbmZpZy5vblN0YXR1c1VwZGF0ZTtcbiAgICB0aGlzLnNhdmVJbWFnZVRvU2VydmVyID0gY29uZmlnLnNhdmVJbWFnZVRvU2VydmVyO1xuICAgIHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIgPSBjb25maWcuc2V0Q2FwdHVyZUNvdW50ZXI7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlcjtcbiAgICBcbiAgICAvLyBHZXQgY2FudmFzIG1hbmFnZXIgZnJvbSBnbG9iYWwgc2NvcGVcbiAgICB0aGlzLmNhbnZhc01hbmFnZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5jYW52YXNNYW5hZ2VyIDogbnVsbDtcbiAgfVxuXG4gIC8vIEdldCBvciBjcmVhdGUgY2FudmFzIHVzaW5nIHRoZSBuZXcgQ2FudmFzTWFuYWdlclxuICBnZXRDYW52YXMoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY2FudmFzTWFuYWdlci5nZXRDYW52YXMoKSB8fCB0aGlzLmNhbnZhc01hbmFnZXIuY3JlYXRlQ2FudmFzKCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGNhbnZhc1JlZiBpZiBjYW52YXNNYW5hZ2VyIG5vdCBhdmFpbGFibGVcbiAgICByZXR1cm4gdGhpcy5jYW52YXNSZWY/LmN1cnJlbnQgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RyYWNraW5nLWNhbnZhcycpO1xuICB9XG5cbiAgLy8gV2FpdCB1bnRpbCBjYW52YXMgaXMgZnVsbHkgcmVhZHlcbiAgYXN5bmMgd2FpdEZvckNhbnZhcyhtYXhUcmllcyA9IDIwLCBpbnRlcnZhbCA9IDEwMCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4VHJpZXM7IGkrKykge1xuICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcbiAgICAgIGlmIChjYW52YXMgJiYgY2FudmFzLndpZHRoID4gMCAmJiBjYW52YXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgfVxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGludGVydmFsKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3QgcmVhZHkgYWZ0ZXIgbXVsdGlwbGUgYXR0ZW1wdHNcIik7XG4gIH1cblxuICAvLyBNYWluIGZ1bmN0aW9uIHRvIGhhbmRsZSBjYWxpYnJhdGlvbiBzZXF1ZW5jZVxuICBoYW5kbGVTZXRDYWxpYnJhdGUgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gSGlkZSB0aGUgVG9wQmFyIGJlZm9yZSBzdGFydGluZyBjYWxpYnJhdGlvblxuICAgIGlmICh0eXBlb2YgdGhpcy50b2dnbGVUb3BCYXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy50b2dnbGVUb3BCYXIpIHtcbiAgICAgIHdpbmRvdy50b2dnbGVUb3BCYXIoZmFsc2UpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNldElzQ2FwdHVyaW5nKHRydWUpO1xuICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cygnU3RhcnRpbmcgY2FsaWJyYXRpb24gc2VxdWVuY2UuLi4nKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgcGFyZW50IGNvbXBvbmVudCBpZiBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5vblN0YXR1c1VwZGF0ZSkge1xuICAgICAgdGhpcy5vblN0YXR1c1VwZGF0ZSh7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6ICdTdGFydGluZyBjYWxpYnJhdGlvbiBzZXF1ZW5jZS4uLicsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRpbWUgdG8gdXBkYXRlXG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjYW52YXMgPSBhd2FpdCB0aGlzLndhaXRGb3JDYW52YXMoKTtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzZSBjYW52YXMgbWFuYWdlciB0byBlbnRlciBmdWxsc2NyZWVuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZW50ZXJGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHMgYmFzZWQgb24gY2FudmFzIHNpemVcbiAgICAgICAgY29uc3QgcG9pbnRzID0gZ2VuZXJhdGVDYWxpYnJhdGlvblBvaW50cyhjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFwb2ludHMgfHwgcG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZW5lcmF0ZSBjYWxpYnJhdGlvbiBwb2ludHNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgc3RhdHVzIGluZGljYXRvclxuICAgICAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdjYWxpYnJhdGUtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgICB0b3A6IDIwcHg7XG4gICAgICAgICAgcmlnaHQ6IDIwcHg7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCAxMDIsIDIwNCwgMC45KTtcbiAgICAgICAgICBjb2xvcjogd2hpdGU7XG4gICAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgIHBhZGRpbmc6IDEwcHggMTVweDtcbiAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgei1pbmRleDogMTAwMDA7XG4gICAgICAgICAgYm94LXNoYWRvdzogMCA0cHggMTJweCByZ2JhKDAsIDAsIDAsIDAuMyk7XG4gICAgICAgIGA7XG4gICAgICAgIHN0YXR1c0luZGljYXRvci50ZXh0Q29udGVudCA9ICdDYWxpYnJhdGlvbjogSW5pdGlhbGl6aW5nLi4uJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBjYWxpYnJhdGlvbiBwb2ludFxuICAgICAgICBsZXQgc3VjY2Vzc0NvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBVcGRhdGUgc3RhdHVzIGRpc3BsYXlzXG4gICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYENhbGlicmF0aW9uOiBQb2ludCAke2kgKyAxfS8ke3BvaW50cy5sZW5ndGh9YDtcbiAgICAgICAgICB0aGlzLnNldFByb2Nlc3NTdGF0dXMoYFByb2Nlc3NpbmcgY2FsaWJyYXRpb24gcG9pbnQgJHtpICsgMX0vJHtwb2ludHMubGVuZ3RofWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFyIGNhbnZhcyB3aXRoIHdoaXRlIGJhY2tncm91bmRcbiAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRHJhdyB0aGUgY2FsaWJyYXRpb24gcG9pbnQgd2l0aCBjb25zaXN0ZW50IHNpemVcbiAgICAgICAgICBjb25zdCByYWRpdXMgPSAxMjsgLy8gU3RhbmRhcmQgc2l6ZSBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXRlIHJlZHJhdyBpbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgICBjb25zdCByZWRyYXdJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFJlbW92ZSBhbnkgZXhpc3RpbmcgY291bnRkb3duIGVsZW1lbnRzXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDb3VudGRvd25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmRvdC1jb3VudGRvd24sIC5jYWxpYnJhdGUtY291bnRkb3duJyk7XG4gICAgICAgICAgZXhpc3RpbmdDb3VudGRvd25zLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWF0ZSBjdXN0b20gY291bnRkb3duIGVsZW1lbnRcbiAgICAgICAgICBjb25zdCBjb3VudGRvd25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5jbGFzc05hbWUgPSAnZG90LWNvdW50ZG93bic7XG4gICAgICAgICAgY291bnRkb3duRWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gYFxuICAgICAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICAgICAgbGVmdDogJHtwb2ludC54fXB4O1xuICAgICAgICAgICAgdG9wOiAke3BvaW50LnkgLSA2MH1weDtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgtNTAlKTtcbiAgICAgICAgICAgIGNvbG9yOiByZWQ7XG4gICAgICAgICAgICBmb250LXNpemU6IDM2cHg7XG4gICAgICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgICAgIHRleHQtc2hhZG93OiAwIDAgMTBweCB3aGl0ZSwgMCAwIDIwcHggd2hpdGU7XG4gICAgICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KTtcbiAgICAgICAgICAgIGJvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4zKTtcbiAgICAgICAgICBgO1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE1hbnVhbCBjb3VudGRvd25cbiAgICAgICAgICAgIGZvciAobGV0IGNvdW50ID0gMzsgY291bnQgPiAwOyBjb3VudC0tKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQudGV4dENvbnRlbnQgPSBjb3VudDtcbiAgICAgICAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBQb2ludCAke2krMX0vJHtwb2ludHMubGVuZ3RofTogQ291bnRkb3duICR7Y291bnR9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBGb3JjZSByZWRyYXcgdG8gZW5zdXJlIGRvdCBzdGF5cyB2aXNpYmxlXG4gICAgICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb2ludC54LCBwb2ludC55LCByYWRpdXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA4MDApKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIFJlZHJhdyBhZ2FpbiBoYWxmd2F5IHRocm91Z2ggdGhlIHdhaXRcbiAgICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG93IGNoZWNrbWFya1xuICAgICAgICAgICAgY291bnRkb3duRWxlbWVudC50ZXh0Q29udGVudCA9IFwi4pyTXCI7XG4gICAgICAgICAgICBkcmF3UmVkRG90KGN0eCwgcG9pbnQueCwgcG9pbnQueSwgcmFkaXVzLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlbW92ZSBjb3VudGRvd24gZWxlbWVudCBhZnRlciBkZWxheVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudGRvd25FbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY291bnRkb3duRWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBkb3QgaXMgc3RpbGwgdmlzaWJsZVxuICAgICAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvaW50LngsIHBvaW50LnksIHJhZGl1cywgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBDYXB0dXJlIGltYWdlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FwdHVyaW5nIGNhbGlicmF0aW9uIHBvaW50ICR7aSsxfS8ke3BvaW50cy5sZW5ndGh9IGF0ICgke3BvaW50Lnh9LCAke3BvaW50Lnl9KWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlUmVzdWx0ID0gYXdhaXQgY2FwdHVyZUltYWdlc0F0UG9pbnQoe1xuICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgIGNhcHR1cmVDb3VudDogdGhpcy5jYXB0dXJlQ291bnRlcixcbiAgICAgICAgICAgICAgY2FudmFzUmVmOiB7IGN1cnJlbnQ6IGNhbnZhcyB9LFxuICAgICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICAgIHNob3dDYXB0dXJlUHJldmlld1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjYXB0dXJlUmVzdWx0ICYmIChjYXB0dXJlUmVzdWx0LnNjcmVlbkltYWdlIHx8IGNhcHR1cmVSZXN1bHQuc3VjY2VzcykpIHtcbiAgICAgICAgICAgICAgc3VjY2Vzc0NvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdhaXQgYmV0d2VlbiBwb2ludHNcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMjAwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcHJvY2Vzc2luZyBjYWxpYnJhdGlvbiBwb2ludCAke2krMX06YCwgZXJyb3IpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBjb3VudGRvd24gaWYgaXQgc3RpbGwgZXhpc3RzXG4gICAgICAgICAgICBpZiAoY291bnRkb3duRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIGNvdW50ZG93bkVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjb3VudGRvd25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ2xlYXIgcmVkcmF3IGludGVydmFsXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlZHJhd0ludGVydmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENhbGlicmF0aW9uIGNvbXBsZXRlXG4gICAgICAgIGlmIChzdGF0dXNJbmRpY2F0b3IpIHtcbiAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgQ2FsaWJyYXRpb24gY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50c2A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRQcm9jZXNzU3RhdHVzKGBDYWxpYnJhdGlvbiBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3BvaW50cy5sZW5ndGh9IHBvaW50cyBjYXB0dXJlZGApO1xuICAgICAgICBcbiAgICAgICAgLy8gUmVtb3ZlIHN0YXR1cyBpbmRpY2F0b3IgYWZ0ZXIgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHN0YXR1c0luZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNhbGlicmF0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgIHRoaXMuc2V0UHJvY2Vzc1N0YXR1cyhgQ2FsaWJyYXRpb24gZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIEV4aXQgZnVsbHNjcmVlbiBhbmQgcmVzdG9yZSBjYW52YXNcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5leGl0RnVsbHNjcmVlbigpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldElzQ2FwdHVyaW5nKGZhbHNlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNob3cgVG9wQmFyIGFnYWluIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvZ2dsZVRvcEJhciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVUb3BCYXIodHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cudG9nZ2xlVG9wQmFyKSB7XG4gICAgICAgICAgICB3aW5kb3cudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgICB9XG4gICAgfSwgMjAwKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2V0Q2FsaWJyYXRlQWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZW5lcmF0ZUNhbGlicmF0aW9uUG9pbnRzIiwiZHJhd1JlZERvdCIsInJ1bkNvdW50ZG93biIsInNob3dDYXB0dXJlUHJldmlldyIsImNhcHR1cmVJbWFnZXNBdFBvaW50IiwiU2V0Q2FsaWJyYXRlQWN0aW9uIiwiY29uc3RydWN0b3IiLCJjb25maWciLCJoYW5kbGVTZXRDYWxpYnJhdGUiLCJ0b2dnbGVUb3BCYXIiLCJ3aW5kb3ciLCJzZXRJc0NhcHR1cmluZyIsInNldFByb2Nlc3NTdGF0dXMiLCJvblN0YXR1c1VwZGF0ZSIsInByb2Nlc3NTdGF0dXMiLCJpc0NhcHR1cmluZyIsInNldFRpbWVvdXQiLCJjYW52YXMiLCJ3YWl0Rm9yQ2FudmFzIiwiRXJyb3IiLCJjYW52YXNNYW5hZ2VyIiwiZW50ZXJGdWxsc2NyZWVuIiwicG9pbnRzIiwid2lkdGgiLCJoZWlnaHQiLCJsZW5ndGgiLCJzdGF0dXNJbmRpY2F0b3IiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImNzc1RleHQiLCJ0ZXh0Q29udGVudCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsInN1Y2Nlc3NDb3VudCIsImkiLCJwb2ludCIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJmaWxsU3R5bGUiLCJmaWxsUmVjdCIsInJhZGl1cyIsIngiLCJ5IiwicmVkcmF3SW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImV4aXN0aW5nQ291bnRkb3ducyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiZWwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjb3VudGRvd25FbGVtZW50IiwiY291bnQiLCJQcm9taXNlIiwicmVzb2x2ZSIsImNvbnNvbGUiLCJsb2ciLCJjYXB0dXJlUmVzdWx0IiwiY2FwdHVyZUNvdW50IiwiY2FwdHVyZUNvdW50ZXIiLCJjYW52YXNSZWYiLCJjdXJyZW50Iiwic2V0Q2FwdHVyZUNvdW50Iiwic2V0Q2FwdHVyZUNvdW50ZXIiLCJzY3JlZW5JbWFnZSIsInN1Y2Nlc3MiLCJlcnJvciIsImNsZWFySW50ZXJ2YWwiLCJtZXNzYWdlIiwiZXhpdEZ1bGxzY3JlZW4iLCJzZXRDdXJyZW50RG90IiwidHJpZ2dlckNhbWVyYUFjY2VzcyIsInNhdmVJbWFnZVRvU2VydmVyIiwiZ2V0Q2FudmFzIiwiY3JlYXRlQ2FudmFzIiwicXVlcnlTZWxlY3RvciIsIm1heFRyaWVzIiwiaW50ZXJ2YWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/SetCalibrateAction.jsx\n");

/***/ })

};
;