"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "_pages-dir-node_components_collected-dataset-customized_Action_SetRandomAction_jsx";
exports.ids = ["_pages-dir-node_components_collected-dataset-customized_Action_SetRandomAction_jsx"];
exports.modules = {

/***/ "(pages-dir-node)/./components/collected-dataset-customized/Action/SetRandomAction.jsx":
/*!****************************************************************************!*\
  !*** ./components/collected-dataset-customized/Action/SetRandomAction.jsx ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _countSave__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./countSave */ \"(pages-dir-node)/./components/collected-dataset-customized/Action/countSave.js\");\n/* harmony import */ var _Helper_savefile__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helper/savefile */ \"(pages-dir-node)/./components/collected-dataset-customized/Helper/savefile.js\");\n// SetRandomAction.jsx\n// Handles the set random sequence functionality\n\n\n\nclass SetRandomAction {\n    constructor(config){\n        // Main handler for Set Random button\n        this.handleAction = async ()=>{\n            try {\n                // Get control values from the TopBar\n                const timeInput = document.querySelector('.control-input-field[data-control=\"time\"]');\n                const delayInput = document.querySelector('.control-input-field[data-control=\"delay\"]');\n                // Default values if inputs can't be found\n                let times = 1;\n                let delay = 3;\n                // Parse input values if available\n                if (timeInput) {\n                    const parsedTime = parseInt(timeInput.value, 10);\n                    if (!isNaN(parsedTime) && parsedTime > 0) {\n                        times = parsedTime;\n                    }\n                }\n                if (delayInput) {\n                    const parsedDelay = parseInt(delayInput.value, 10);\n                    if (!isNaN(parsedDelay) && parsedDelay > 0) {\n                        delay = parsedDelay;\n                    }\n                }\n                // Hide UI during capture process\n                if (this.toggleTopBar) this.toggleTopBar(false);\n                this.onStatusUpdate?.({\n                    processStatus: `Starting ${times} random captures with ${delay}s delay...`,\n                    isCapturing: true,\n                    remainingCaptures: times\n                });\n                // Wait for canvas to be ready\n                const canvas = await this.waitForCanvas();\n                // Use canvas manager to enter fullscreen\n                if (this.canvasManager) {\n                    this.canvasManager.enterFullscreen();\n                }\n                // Process all captures sequentially\n                let successCount = 0;\n                let currentCapture = 1;\n                while(currentCapture <= times){\n                    // Update status for current capture\n                    this.onStatusUpdate?.({\n                        processStatus: `Capture ${currentCapture} of ${times}`,\n                        remainingCaptures: times - currentCapture + 1,\n                        isCapturing: true\n                    });\n                    // Clear canvas before each capture\n                    const ctx = canvas.getContext('2d');\n                    ctx.clearRect(0, 0, canvas.width, canvas.height);\n                    ctx.fillStyle = 'white';\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    // Generate random position for this capture\n                    const position = (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.getRandomPosition)(canvas, 20);\n                    // Draw the dot with consistent size\n                    (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y, 12, false);\n                    // Create a redrawInterval to ensure dot stays visible\n                    let redrawInterval = setInterval(()=>{\n                        (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.drawRedDot)(ctx, position.x, position.y, 12, false);\n                    }, 200);\n                    // Run countdown and wait for it to complete\n                    await new Promise((resolve)=>{\n                        (0,_countSave__WEBPACK_IMPORTED_MODULE_1__.runCountdown)(position, canvas, (status)=>{\n                            // Update UI based on status\n                            if (status.processStatus) {\n                                this.onStatusUpdate?.({\n                                    processStatus: `Capture ${currentCapture}/${times}: ${status.processStatus}`,\n                                    remainingCaptures: times - currentCapture + 1,\n                                    isCapturing: true\n                                });\n                            }\n                        }, resolve // This will be called when countdown completes\n                        );\n                    });\n                    // Clear redrawInterval after countdown\n                    clearInterval(redrawInterval);\n                    // Trigger camera access before capture\n                    if (this.triggerCameraAccess) {\n                        try {\n                            const cameraResult = this.triggerCameraAccess(true);\n                            if (!cameraResult) {\n                                console.warn('Camera access failed, but continuing with capture');\n                            }\n                        } catch (error) {\n                            console.warn('Camera access error, but continuing with capture:', error);\n                        }\n                    }\n                    // Wait briefly for camera to initialize\n                    await new Promise((resolve)=>setTimeout(resolve, 500));\n                    // Capture images at this point\n                    try {\n                        const captureResult = await (0,_Helper_savefile__WEBPACK_IMPORTED_MODULE_2__.captureImagesAtPoint)({\n                            point: position,\n                            captureCount: this.captureCounter,\n                            canvasRef: {\n                                current: canvas\n                            },\n                            setCaptureCount: this.setCaptureCounter,\n                            showCapturePreview: _countSave__WEBPACK_IMPORTED_MODULE_1__.showCapturePreview\n                        });\n                        if (captureResult && (captureResult.screenImage || captureResult.success)) {\n                            successCount++;\n                        }\n                        // Increment counter\n                        if (this.setCaptureCounter) {\n                            this.setCaptureCounter((prev)=>prev + 1);\n                        }\n                    } catch (error) {\n                        console.error(`Error capturing point ${currentCapture}:`, error);\n                    }\n                    // Wait between captures for the specified delay time\n                    if (currentCapture < times) {\n                        this.onStatusUpdate?.({\n                            processStatus: `Waiting ${delay}s before next capture...`,\n                            remainingCaptures: times - currentCapture,\n                            isCapturing: true\n                        });\n                        await new Promise((resolve)=>setTimeout(resolve, delay * 1000));\n                    }\n                    // Move to next capture\n                    currentCapture++;\n                }\n                // Sequence complete\n                this.onStatusUpdate?.({\n                    processStatus: `Random capture sequence completed: ${successCount}/${times} captures successful`,\n                    remainingCaptures: 0,\n                    isCapturing: false\n                });\n                // Exit fullscreen and restore canvas\n                if (this.canvasManager) {\n                    this.canvasManager.exitFullscreen();\n                }\n                // Turn TopBar back on\n                if (this.toggleTopBar) {\n                    this.toggleTopBar(true);\n                }\n            } catch (err) {\n                console.error('Random sequence error:', err);\n                this.onStatusUpdate?.({\n                    processStatus: `Random sequence failed: ${err.message}`,\n                    isCapturing: false,\n                    remainingCaptures: 0\n                });\n                // Make sure to restore the UI\n                if (this.toggleTopBar) this.toggleTopBar(true);\n            }\n        };\n        // Required properties\n        this.canvasRef = config.canvasRef;\n        this.onStatusUpdate = config.onStatusUpdate;\n        this.setCaptureCounter = config.setCaptureCounter;\n        this.toggleTopBar = config.toggleTopBar;\n        this.captureCounter = config.captureCounter || 1;\n        this.triggerCameraAccess = config.triggerCameraAccess;\n        // Get canvas manager from global scope\n        this.canvasManager =  false ? 0 : null;\n    }\n    // Get or create canvas using the new CanvasManager\n    getCanvas() {\n        if (this.canvasManager) {\n            return this.canvasManager.getCanvas() || this.canvasManager.createCanvas();\n        }\n        // Fallback to canvasRef if canvasManager not available\n        return this.canvasRef?.current || document.querySelector('#tracking-canvas');\n    }\n    // Wait until canvas is fully ready\n    async waitForCanvas(maxTries = 20, interval = 100) {\n        for(let i = 0; i < maxTries; i++){\n            const canvas = this.getCanvas();\n            if (canvas && canvas.width > 0 && canvas.height > 0) {\n                return canvas;\n            }\n            await new Promise((resolve)=>setTimeout(resolve, interval));\n        }\n        throw new Error(\"Canvas not ready after multiple attempts\");\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SetRandomAction);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1ub2RlKS8uL2NvbXBvbmVudHMvY29sbGVjdGVkLWRhdGFzZXQtY3VzdG9taXplZC9BY3Rpb24vU2V0UmFuZG9tQWN0aW9uLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHNCQUFzQjtBQUN0QixnREFBZ0Q7QUFFdEI7QUFDb0U7QUFDcEM7QUFFMUQsTUFBTU07SUFDSkMsWUFBWUMsTUFBTSxDQUFFO1FBbUNwQixxQ0FBcUM7YUFDckNDLGVBQWU7WUFDYixJQUFJO2dCQUNGLHFDQUFxQztnQkFDckMsTUFBTUMsWUFBWUMsU0FBU0MsYUFBYSxDQUFDO2dCQUN6QyxNQUFNQyxhQUFhRixTQUFTQyxhQUFhLENBQUM7Z0JBRTFDLDBDQUEwQztnQkFDMUMsSUFBSUUsUUFBUTtnQkFDWixJQUFJQyxRQUFRO2dCQUVaLGtDQUFrQztnQkFDbEMsSUFBSUwsV0FBVztvQkFDYixNQUFNTSxhQUFhQyxTQUFTUCxVQUFVUSxLQUFLLEVBQUU7b0JBQzdDLElBQUksQ0FBQ0MsTUFBTUgsZUFBZUEsYUFBYSxHQUFHO3dCQUN4Q0YsUUFBUUU7b0JBQ1Y7Z0JBQ0Y7Z0JBRUEsSUFBSUgsWUFBWTtvQkFDZCxNQUFNTyxjQUFjSCxTQUFTSixXQUFXSyxLQUFLLEVBQUU7b0JBQy9DLElBQUksQ0FBQ0MsTUFBTUMsZ0JBQWdCQSxjQUFjLEdBQUc7d0JBQzFDTCxRQUFRSztvQkFDVjtnQkFDRjtnQkFFQSxpQ0FBaUM7Z0JBQ2pDLElBQUksSUFBSSxDQUFDQyxZQUFZLEVBQUUsSUFBSSxDQUFDQSxZQUFZLENBQUM7Z0JBRXpDLElBQUksQ0FBQ0MsY0FBYyxHQUFHO29CQUNwQkMsZUFBZSxDQUFDLFNBQVMsRUFBRVQsTUFBTSxzQkFBc0IsRUFBRUMsTUFBTSxVQUFVLENBQUM7b0JBQzFFUyxhQUFhO29CQUNiQyxtQkFBbUJYO2dCQUNyQjtnQkFFQSw4QkFBOEI7Z0JBQzlCLE1BQU1ZLFNBQVMsTUFBTSxJQUFJLENBQUNDLGFBQWE7Z0JBRXZDLHlDQUF5QztnQkFDekMs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ZXRSYW5kb21BY3Rpb24uanN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFNldFJhbmRvbUFjdGlvbi5qc3hcbi8vIEhhbmRsZXMgdGhlIHNldCByYW5kb20gc2VxdWVuY2UgZnVuY3Rpb25hbGl0eVxuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0UmFuZG9tUG9zaXRpb24sIGRyYXdSZWREb3QsIHJ1bkNvdW50ZG93biwgc2hvd0NhcHR1cmVQcmV2aWV3IH0gZnJvbSAnLi9jb3VudFNhdmUnO1xuaW1wb3J0IHsgY2FwdHVyZUltYWdlc0F0UG9pbnQgfSBmcm9tICcuLi9IZWxwZXIvc2F2ZWZpbGUnO1xuXG5jbGFzcyBTZXRSYW5kb21BY3Rpb24ge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAvLyBSZXF1aXJlZCBwcm9wZXJ0aWVzXG4gICAgdGhpcy5jYW52YXNSZWYgPSBjb25maWcuY2FudmFzUmVmO1xuICAgIHRoaXMub25TdGF0dXNVcGRhdGUgPSBjb25maWcub25TdGF0dXNVcGRhdGU7XG4gICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlciA9IGNvbmZpZy5zZXRDYXB0dXJlQ291bnRlcjtcbiAgICB0aGlzLnRvZ2dsZVRvcEJhciA9IGNvbmZpZy50b2dnbGVUb3BCYXI7XG4gICAgdGhpcy5jYXB0dXJlQ291bnRlciA9IGNvbmZpZy5jYXB0dXJlQ291bnRlciB8fCAxO1xuICAgIHRoaXMudHJpZ2dlckNhbWVyYUFjY2VzcyA9IGNvbmZpZy50cmlnZ2VyQ2FtZXJhQWNjZXNzO1xuICAgIFxuICAgIC8vIEdldCBjYW52YXMgbWFuYWdlciBmcm9tIGdsb2JhbCBzY29wZVxuICAgIHRoaXMuY2FudmFzTWFuYWdlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmNhbnZhc01hbmFnZXIgOiBudWxsO1xuICB9XG5cbiAgLy8gR2V0IG9yIGNyZWF0ZSBjYW52YXMgdXNpbmcgdGhlIG5ldyBDYW52YXNNYW5hZ2VyXG4gIGdldENhbnZhcygpIHtcbiAgICBpZiAodGhpcy5jYW52YXNNYW5hZ2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXNNYW5hZ2VyLmdldENhbnZhcygpIHx8IHRoaXMuY2FudmFzTWFuYWdlci5jcmVhdGVDYW52YXMoKTtcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gY2FudmFzUmVmIGlmIGNhbnZhc01hbmFnZXIgbm90IGF2YWlsYWJsZVxuICAgIHJldHVybiB0aGlzLmNhbnZhc1JlZj8uY3VycmVudCB8fCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdHJhY2tpbmctY2FudmFzJyk7XG4gIH1cblxuICAvLyBXYWl0IHVudGlsIGNhbnZhcyBpcyBmdWxseSByZWFkeVxuICBhc3luYyB3YWl0Rm9yQ2FudmFzKG1heFRyaWVzID0gMjAsIGludGVydmFsID0gMTAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUcmllczsgaSsrKSB7XG4gICAgICBjb25zdCBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuICAgICAgaWYgKGNhbnZhcyAmJiBjYW52YXMud2lkdGggPiAwICYmIGNhbnZhcy5oZWlnaHQgPiAwKSB7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgICB9XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgaW50ZXJ2YWwpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIG5vdCByZWFkeSBhZnRlciBtdWx0aXBsZSBhdHRlbXB0c1wiKTtcbiAgfVxuXG4gIC8vIE1haW4gaGFuZGxlciBmb3IgU2V0IFJhbmRvbSBidXR0b25cbiAgaGFuZGxlQWN0aW9uID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgY29udHJvbCB2YWx1ZXMgZnJvbSB0aGUgVG9wQmFyXG4gICAgICBjb25zdCB0aW1lSW5wdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udHJvbC1pbnB1dC1maWVsZFtkYXRhLWNvbnRyb2w9XCJ0aW1lXCJdJyk7XG4gICAgICBjb25zdCBkZWxheUlucHV0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtaW5wdXQtZmllbGRbZGF0YS1jb250cm9sPVwiZGVsYXlcIl0nKTtcbiAgICAgIFxuICAgICAgLy8gRGVmYXVsdCB2YWx1ZXMgaWYgaW5wdXRzIGNhbid0IGJlIGZvdW5kXG4gICAgICBsZXQgdGltZXMgPSAxO1xuICAgICAgbGV0IGRlbGF5ID0gMztcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgaW5wdXQgdmFsdWVzIGlmIGF2YWlsYWJsZVxuICAgICAgaWYgKHRpbWVJbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUaW1lID0gcGFyc2VJbnQodGltZUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4ocGFyc2VkVGltZSkgJiYgcGFyc2VkVGltZSA+IDApIHtcbiAgICAgICAgICB0aW1lcyA9IHBhcnNlZFRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGRlbGF5SW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRGVsYXkgPSBwYXJzZUludChkZWxheUlucHV0LnZhbHVlLCAxMCk7XG4gICAgICAgIGlmICghaXNOYU4ocGFyc2VkRGVsYXkpICYmIHBhcnNlZERlbGF5ID4gMCkge1xuICAgICAgICAgIGRlbGF5ID0gcGFyc2VkRGVsYXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSGlkZSBVSSBkdXJpbmcgY2FwdHVyZSBwcm9jZXNzXG4gICAgICBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHRoaXMudG9nZ2xlVG9wQmFyKGZhbHNlKTtcbiAgICAgIFxuICAgICAgdGhpcy5vblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgcHJvY2Vzc1N0YXR1czogYFN0YXJ0aW5nICR7dGltZXN9IHJhbmRvbSBjYXB0dXJlcyB3aXRoICR7ZGVsYXl9cyBkZWxheS4uLmAsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiB0cnVlLFxuICAgICAgICByZW1haW5pbmdDYXB0dXJlczogdGltZXNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciBjYW52YXMgdG8gYmUgcmVhZHlcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGF3YWl0IHRoaXMud2FpdEZvckNhbnZhcygpO1xuICAgICAgXG4gICAgICAvLyBVc2UgY2FudmFzIG1hbmFnZXIgdG8gZW50ZXIgZnVsbHNjcmVlblxuICAgICAgaWYgKHRoaXMuY2FudmFzTWFuYWdlcikge1xuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIuZW50ZXJGdWxsc2NyZWVuKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgYWxsIGNhcHR1cmVzIHNlcXVlbnRpYWxseVxuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBsZXQgY3VycmVudENhcHR1cmUgPSAxO1xuICAgICAgXG4gICAgICB3aGlsZSAoY3VycmVudENhcHR1cmUgPD0gdGltZXMpIHtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyBmb3IgY3VycmVudCBjYXB0dXJlXG4gICAgICAgIHRoaXMub25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgICAgcHJvY2Vzc1N0YXR1czogYENhcHR1cmUgJHtjdXJyZW50Q2FwdHVyZX0gb2YgJHt0aW1lc31gLFxuICAgICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiB0aW1lcyAtIGN1cnJlbnRDYXB0dXJlICsgMSxcbiAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIENsZWFyIGNhbnZhcyBiZWZvcmUgZWFjaCBjYXB0dXJlXG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBwb3NpdGlvbiBmb3IgdGhpcyBjYXB0dXJlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmFuZG9tUG9zaXRpb24oY2FudmFzLCAyMCk7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBkb3Qgd2l0aCBjb25zaXN0ZW50IHNpemVcbiAgICAgICAgZHJhd1JlZERvdChjdHgsIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIDEyLCBmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhdGUgYSByZWRyYXdJbnRlcnZhbCB0byBlbnN1cmUgZG90IHN0YXlzIHZpc2libGVcbiAgICAgICAgbGV0IHJlZHJhd0ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgIGRyYXdSZWREb3QoY3R4LCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAxMiwgZmFsc2UpO1xuICAgICAgICB9LCAyMDApO1xuICAgICAgICBcbiAgICAgICAgLy8gUnVuIGNvdW50ZG93biBhbmQgd2FpdCBmb3IgaXQgdG8gY29tcGxldGVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgcnVuQ291bnRkb3duKFxuICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgICAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSBVSSBiYXNlZCBvbiBzdGF0dXNcbiAgICAgICAgICAgICAgaWYgKHN0YXR1cy5wcm9jZXNzU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0YXR1c1VwZGF0ZT8uKHtcbiAgICAgICAgICAgICAgICAgIHByb2Nlc3NTdGF0dXM6IGBDYXB0dXJlICR7Y3VycmVudENhcHR1cmV9LyR7dGltZXN9OiAke3N0YXR1cy5wcm9jZXNzU3RhdHVzfWAsXG4gICAgICAgICAgICAgICAgICByZW1haW5pbmdDYXB0dXJlczogdGltZXMgLSBjdXJyZW50Q2FwdHVyZSArIDEsXG4gICAgICAgICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzb2x2ZSAvLyBUaGlzIHdpbGwgYmUgY2FsbGVkIHdoZW4gY291bnRkb3duIGNvbXBsZXRlc1xuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2xlYXIgcmVkcmF3SW50ZXJ2YWwgYWZ0ZXIgY291bnRkb3duXG4gICAgICAgIGNsZWFySW50ZXJ2YWwocmVkcmF3SW50ZXJ2YWwpO1xuICAgICAgICBcbiAgICAgICAgLy8gVHJpZ2dlciBjYW1lcmEgYWNjZXNzIGJlZm9yZSBjYXB0dXJlXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJDYW1lcmFBY2Nlc3MpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY2FtZXJhUmVzdWx0ID0gdGhpcy50cmlnZ2VyQ2FtZXJhQWNjZXNzKHRydWUpO1xuICAgICAgICAgICAgaWYgKCFjYW1lcmFSZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW1lcmEgYWNjZXNzIGZhaWxlZCwgYnV0IGNvbnRpbnVpbmcgd2l0aCBjYXB0dXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2FtZXJhIGFjY2VzcyBlcnJvciwgYnV0IGNvbnRpbnVpbmcgd2l0aCBjYXB0dXJlOicsIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFdhaXQgYnJpZWZseSBmb3IgY2FtZXJhIHRvIGluaXRpYWxpemVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2FwdHVyZSBpbWFnZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVSZXN1bHQgPSBhd2FpdCBjYXB0dXJlSW1hZ2VzQXRQb2ludCh7XG4gICAgICAgICAgICBwb2ludDogcG9zaXRpb24sXG4gICAgICAgICAgICBjYXB0dXJlQ291bnQ6IHRoaXMuY2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBjYW52YXNSZWY6IHsgY3VycmVudDogY2FudmFzIH0sXG4gICAgICAgICAgICBzZXRDYXB0dXJlQ291bnQ6IHRoaXMuc2V0Q2FwdHVyZUNvdW50ZXIsXG4gICAgICAgICAgICBzaG93Q2FwdHVyZVByZXZpZXdcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoY2FwdHVyZVJlc3VsdCAmJiAoY2FwdHVyZVJlc3VsdC5zY3JlZW5JbWFnZSB8fCBjYXB0dXJlUmVzdWx0LnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICBzdWNjZXNzQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSW5jcmVtZW50IGNvdW50ZXJcbiAgICAgICAgICBpZiAodGhpcy5zZXRDYXB0dXJlQ291bnRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRDYXB0dXJlQ291bnRlcihwcmV2ID0+IHByZXYgKyAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgY2FwdHVyaW5nIHBvaW50ICR7Y3VycmVudENhcHR1cmV9OmAsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gV2FpdCBiZXR3ZWVuIGNhcHR1cmVzIGZvciB0aGUgc3BlY2lmaWVkIGRlbGF5IHRpbWVcbiAgICAgICAgaWYgKGN1cnJlbnRDYXB0dXJlIDwgdGltZXMpIHtcbiAgICAgICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICAgICAgcHJvY2Vzc1N0YXR1czogYFdhaXRpbmcgJHtkZWxheX1zIGJlZm9yZSBuZXh0IGNhcHR1cmUuLi5gLFxuICAgICAgICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IHRpbWVzIC0gY3VycmVudENhcHR1cmUsXG4gICAgICAgICAgICBpc0NhcHR1cmluZzogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSAqIDEwMDApKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSB0byBuZXh0IGNhcHR1cmVcbiAgICAgICAgY3VycmVudENhcHR1cmUrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2VxdWVuY2UgY29tcGxldGVcbiAgICAgIHRoaXMub25TdGF0dXNVcGRhdGU/Lih7XG4gICAgICAgIHByb2Nlc3NTdGF0dXM6IGBSYW5kb20gY2FwdHVyZSBzZXF1ZW5jZSBjb21wbGV0ZWQ6ICR7c3VjY2Vzc0NvdW50fS8ke3RpbWVzfSBjYXB0dXJlcyBzdWNjZXNzZnVsYCxcbiAgICAgICAgcmVtYWluaW5nQ2FwdHVyZXM6IDAsXG4gICAgICAgIGlzQ2FwdHVyaW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEV4aXQgZnVsbHNjcmVlbiBhbmQgcmVzdG9yZSBjYW52YXNcbiAgICAgIGlmICh0aGlzLmNhbnZhc01hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFR1cm4gVG9wQmFyIGJhY2sgb25cbiAgICAgIGlmICh0aGlzLnRvZ2dsZVRvcEJhcikge1xuICAgICAgICB0aGlzLnRvZ2dsZVRvcEJhcih0cnVlKTtcbiAgICAgIH1cbiAgICAgIFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignUmFuZG9tIHNlcXVlbmNlIGVycm9yOicsIGVycik7XG4gICAgICB0aGlzLm9uU3RhdHVzVXBkYXRlPy4oe1xuICAgICAgICBwcm9jZXNzU3RhdHVzOiBgUmFuZG9tIHNlcXVlbmNlIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gLFxuICAgICAgICBpc0NhcHR1cmluZzogZmFsc2UsXG4gICAgICAgIHJlbWFpbmluZ0NhcHR1cmVzOiAwXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTWFrZSBzdXJlIHRvIHJlc3RvcmUgdGhlIFVJXG4gICAgICBpZiAodGhpcy50b2dnbGVUb3BCYXIpIHRoaXMudG9nZ2xlVG9wQmFyKHRydWUpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgU2V0UmFuZG9tQWN0aW9uOyAiXSwibmFtZXMiOlsiUmVhY3QiLCJnZXRSYW5kb21Qb3NpdGlvbiIsImRyYXdSZWREb3QiLCJydW5Db3VudGRvd24iLCJzaG93Q2FwdHVyZVByZXZpZXciLCJjYXB0dXJlSW1hZ2VzQXRQb2ludCIsIlNldFJhbmRvbUFjdGlvbiIsImNvbnN0cnVjdG9yIiwiY29uZmlnIiwiaGFuZGxlQWN0aW9uIiwidGltZUlucHV0IiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiZGVsYXlJbnB1dCIsInRpbWVzIiwiZGVsYXkiLCJwYXJzZWRUaW1lIiwicGFyc2VJbnQiLCJ2YWx1ZSIsImlzTmFOIiwicGFyc2VkRGVsYXkiLCJ0b2dnbGVUb3BCYXIiLCJvblN0YXR1c1VwZGF0ZSIsInByb2Nlc3NTdGF0dXMiLCJpc0NhcHR1cmluZyIsInJlbWFpbmluZ0NhcHR1cmVzIiwiY2FudmFzIiwid2FpdEZvckNhbnZhcyIsImNhbnZhc01hbmFnZXIiLCJlbnRlckZ1bGxzY3JlZW4iLCJzdWNjZXNzQ291bnQiLCJjdXJyZW50Q2FwdHVyZSIsImN0eCIsImdldENvbnRleHQiLCJjbGVhclJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwicG9zaXRpb24iLCJ4IiwieSIsInJlZHJhd0ludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInN0YXR1cyIsImNsZWFySW50ZXJ2YWwiLCJ0cmlnZ2VyQ2FtZXJhQWNjZXNzIiwiY2FtZXJhUmVzdWx0IiwiY29uc29sZSIsIndhcm4iLCJlcnJvciIsInNldFRpbWVvdXQiLCJjYXB0dXJlUmVzdWx0IiwicG9pbnQiLCJjYXB0dXJlQ291bnQiLCJjYXB0dXJlQ291bnRlciIsImNhbnZhc1JlZiIsImN1cnJlbnQiLCJzZXRDYXB0dXJlQ291bnQiLCJzZXRDYXB0dXJlQ291bnRlciIsInNjcmVlbkltYWdlIiwic3VjY2VzcyIsInByZXYiLCJleGl0RnVsbHNjcmVlbiIsImVyciIsIm1lc3NhZ2UiLCJ3aW5kb3ciLCJnZXRDYW52YXMiLCJjcmVhdGVDYW52YXMiLCJtYXhUcmllcyIsImludGVydmFsIiwiaSIsIkVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-node)/./components/collected-dataset-customized/Action/SetRandomAction.jsx\n");

/***/ })

};
;